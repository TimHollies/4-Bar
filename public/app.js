/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	+(function($, undefined) {

	    'use strict';

	    var
	        Ractive = __webpack_require__(13),
	        toastr = __webpack_require__(17),
	        routingConfig = __webpack_require__(1);
	        //audio = require("./engine/audio/audio");

	    function route() {
	        var currentRoute = location.hash.substring(1);

	        if (routingConfig[currentRoute] !== undefined) {
	            var currentRouteConfig = routingConfig[currentRoute];
	            var dummyData = {};
	            var ractive = new Ractive({
	                el: "#stage",
	                template: currentRouteConfig.template,
	                data: dummyData,
	                lazy: false
	            });

	            currentRouteConfig.model(ractive, dummyData);

	        } else {
	            toastr.error("No route found");
	        }
	    }

	    route();

	    window.onhashchange = route;

	})(__webpack_require__(4), undefined);

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var
	    home = __webpack_require__(2),
	    editor = __webpack_require__(3);

	module.exports = {
	    "": {
	        template: __webpack_require__(5),
	        model: home
	    },
	    editor: {
	        template: __webpack_require__(6),
	        model: editor
	    },
	    dog: {
	        template: "home",
	        model: {
	            title: "Test Title 2",
	            body: "WOOOOOOOOOOOOOOOOOOOOOOOooooooooooooooooooooooooooooWWWWWWWWWWWWWWWWoooooooooooooooo"
	        }
	    }
	};

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	    var $ = __webpack_require__(4);

	var
	    Rx = __webpack_require__(9),
	    adapter = __webpack_require__(10),
	    fade = __webpack_require__(11),
	    fly = __webpack_require__(12),
	    toastr = __webpack_require__(17);


	module.exports = function(ractive, context) {

	    ractive.set("loggedIn", false);

	    ractive.on('new_tune', function(event) {
	        window.location.hash = "editor";
	    });

	    $.getJSON("/api/tunes")
	        .then(function(data) {
	            ractive.set("tuneNames", data);
	        });

	    $.getJSON("/api/user/current")
	        .then(function(data) {
	            console.log("CURRENT USER", data);
	            ractive.set("loggedIn", true);
	            ractive.set("user", data);
	        });

	    ractive.set("filterTuneNames", function(tuneNames, filter) {
	        if (filter.length <= 0) return tuneNames;
	        return tuneNames.filter(function(a) {
	            return a.name.toLowerCase().lastIndexOf(filter.toLowerCase(), 0) === 0;
	        });
	    });

	    // toastr.success("YAY");
	}

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var
	    _ = __webpack_require__(14),
	    Rx = __webpack_require__(9),
	    adapter = __webpack_require__(10),
	    parser = __webpack_require__(7),
	    renderer = __webpack_require__(8),
	    diff = __webpack_require__(18);

	__webpack_require__(11);
	__webpack_require__(12);

	var emptyTuneName = "Untitled Tune";

	module.exports = function(ractive, context) {

	    renderer.initialize();

	    var lines = [];

	    ractive.set("title", emptyTuneName);

	    //incorporates an elements index into its object
	    function addIndexToObject(element, index) {
	        return {
	            raw: element,
	            i: index
	        };
	    }

	    //select many:
	    function linesInChange(change) {

	        return Rx.Observable.create(function(observer) {

	            var
	                newSplit = (change.newValue || "").split('\n'),
	                oldSplit = (change.oldValue || "").split('\n'),
	                newLength = Math.max(newSplit.length, oldSplit.length);

	            function get_diff(matrix, a1, a2, x, y) {
	                if (x > 0 && y > 0 && a1[y - 1] === a2[x - 1]) {
	                    get_diff(matrix, a1, a2, x - 1, y - 1);
	                    //make_row(x, y, ' ', a1[y-1]);
	                    if (x !== y)
	                        observer.onNext({
	                            action: "move",
	                            i: x - 1,
	                            j: y - 1,
	                            newLength: newLength
	                        });
	                } else {
	                    if (x > 0 && (y === 0 || matrix[y][x - 1] >= matrix[y - 1][x])) {
	                        get_diff(matrix, a1, a2, x - 1, y);
	                        //make_row(x, '', '+', a2[x-1]);
	                        observer.onNext({
	                            raw: a2[x - 1],
	                            i: x - 1,
	                            action: "add",
	                            newLength: newLength
	                        });
	                    } else if (y > 0 && (x === 0 || matrix[y][x - 1] < matrix[y - 1][x])) {
	                        get_diff(matrix, a1, a2, x, y - 1);
	                        //make_row('', y, '-', a1[y-1]);
	                        observer.onNext({
	                            raw: a1[y - 1],
	                            i: y - 1,
	                            action: "del",
	                            newLength: newLength
	                        });
	                    } else {
	                        return;
	                    }
	                }
	            }

	            function diff(a1, a2) {
	                var matrix = new Array(a1.length + 1);
	                var x, y;

	                for (y = 0; y < matrix.length; y++) {
	                    matrix[y] = new Array(a2.length + 1);

	                    for (x = 0; x < matrix[y].length; x++) {
	                        matrix[y][x] = 0;
	                    }
	                }

	                for (y = 1; y < matrix.length; y++) {
	                    for (x = 1; x < matrix[y].length; x++) {
	                        if (a1[y - 1] === a2[x - 1]) {
	                            matrix[y][x] = 1 + matrix[y - 1][x - 1];
	                        } else {
	                            matrix[y][x] = Math.max(matrix[y - 1][x], matrix[y][x - 1]);
	                        }
	                    }
	                }

	                get_diff(matrix, a1, a2, x - 1, y - 1);
	            }

	            diff(oldSplit, newSplit);
	            //observer.onNext({ action: "endofinput" });
	        });
	    }

	    //composition root
	    Rx.Observable.fromRactive(ractive, 'inputValue')
	        .selectMany(linesInChange)
	        .map(parser)
	    //.map(renderer.onNext)
	    .subscribe(function(a) {
	        //if(a.action != "del")console.log(a.parsed); 
	        /*if(a.type_class === "data" && a.parsed[0].type === "title") {
	                if(!(a.action === "del") && a.parsed[0].data.length > 0) {
	                    ractive.set("title", a.parsed[0].data);
	                } else {
	                    ractive.set("title", emptyTuneName);
	                }                
	            }      */
	    });


	    //handle events
	    ractive.on({
	        "navigate_back": function(event) {
	            window.location.hash = "";
	        },
	        "editor_mouseup": function() {
	            var field = document.getElementById("abc");
	            //console.log("SELECTED", field.value.substr(0, field.selectionStart).split("\n").length);
	        },
	        "editor_keyup": function() {
	            var field = document.getElementById("abc");
	            if (field.scrollHeight > field.clientHeight) {
	                console.log("grow");
	                field.style.height = field.scrollHeight + "px";
	            }

	            // console.log("SELECTED", field.value.substr(0, field.selectionStart).split("\n").length);
	        }
	    });

	}

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery JavaScript Library v2.1.1
	 * http://jquery.com/
	 *
	 * Includes Sizzle.js
	 * http://sizzlejs.com/
	 *
	 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2014-05-01T17:11Z
	 */

	(function( global, factory ) {

		if ( typeof module === "object" && typeof module.exports === "object" ) {
			// For CommonJS and CommonJS-like environments where a proper window is present,
			// execute the factory and get jQuery
			// For environments that do not inherently posses a window with a document
			// (such as Node.js), expose a jQuery-making factory as module.exports
			// This accentuates the need for the creation of a real window
			// e.g. var jQuery = require("jquery")(window);
			// See ticket #14549 for more info
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( "jQuery requires a window with a document" );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}

	// Pass this if window is not defined yet
	}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

	// Can't do this because several apps including ASP.NET trace
	// the stack via arguments.caller.callee and Firefox dies if
	// you try to trace through "use strict" call chains. (#13335)
	// Support: Firefox 18+
	//

	var arr = [];

	var slice = arr.slice;

	var concat = arr.concat;

	var push = arr.push;

	var indexOf = arr.indexOf;

	var class2type = {};

	var toString = class2type.toString;

	var hasOwn = class2type.hasOwnProperty;

	var support = {};



	var
		// Use the correct document accordingly with window argument (sandbox)
		document = window.document,

		version = "2.1.1",

		// Define a local copy of jQuery
		jQuery = function( selector, context ) {
			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		},

		// Support: Android<4.1
		// Make sure we trim BOM and NBSP
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

		// Matches dashed string for camelizing
		rmsPrefix = /^-ms-/,
		rdashAlpha = /-([\da-z])/gi,

		// Used by jQuery.camelCase as callback to replace()
		fcamelCase = function( all, letter ) {
			return letter.toUpperCase();
		};

	jQuery.fn = jQuery.prototype = {
		// The current version of jQuery being used
		jquery: version,

		constructor: jQuery,

		// Start with an empty selector
		selector: "",

		// The default length of a jQuery object is 0
		length: 0,

		toArray: function() {
			return slice.call( this );
		},

		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {
			return num != null ?

				// Return just the one element from the set
				( num < 0 ? this[ num + this.length ] : this[ num ] ) :

				// Return all the elements in a clean array
				slice.call( this );
		},

		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {

			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );

			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;
			ret.context = this.context;

			// Return the newly-formed element set
			return ret;
		},

		// Execute a callback for every element in the matched set.
		// (You can seed the arguments with an array of args, but this is
		// only used internally.)
		each: function( callback, args ) {
			return jQuery.each( this, callback, args );
		},

		map: function( callback ) {
			return this.pushStack( jQuery.map(this, function( elem, i ) {
				return callback.call( elem, i, elem );
			}));
		},

		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},

		first: function() {
			return this.eq( 0 );
		},

		last: function() {
			return this.eq( -1 );
		},

		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
		},

		end: function() {
			return this.prevObject || this.constructor(null);
		},

		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};

	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[0] || {},
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;

			// skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
			target = {};
		}

		// extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}

		for ( ; i < length; i++ ) {
			// Only deal with non-null/undefined values
			if ( (options = arguments[ i ]) != null ) {
				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];

					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && jQuery.isArray(src) ? src : [];

						} else {
							clone = src && jQuery.isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );

					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	jQuery.extend({
		// Unique for each copy of jQuery on the page
		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

		// Assume jQuery is ready without the ready module
		isReady: true,

		error: function( msg ) {
			throw new Error( msg );
		},

		noop: function() {},

		// See test/unit/core.js for details concerning isFunction.
		// Since version 1.3, DOM methods and functions like alert
		// aren't supported. They return false on IE (#2968).
		isFunction: function( obj ) {
			return jQuery.type(obj) === "function";
		},

		isArray: Array.isArray,

		isWindow: function( obj ) {
			return obj != null && obj === obj.window;
		},

		isNumeric: function( obj ) {
			// parseFloat NaNs numeric-cast false positives (null|true|false|"")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			return !jQuery.isArray( obj ) && obj - parseFloat( obj ) >= 0;
		},

		isPlainObject: function( obj ) {
			// Not plain objects:
			// - Any object or value whose internal [[Class]] property is not "[object Object]"
			// - DOM nodes
			// - window
			if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
				return false;
			}

			if ( obj.constructor &&
					!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
				return false;
			}

			// If the function hasn't returned already, we're confident that
			// |obj| is a plain object, created by {} or constructed with new Object
			return true;
		},

		isEmptyObject: function( obj ) {
			var name;
			for ( name in obj ) {
				return false;
			}
			return true;
		},

		type: function( obj ) {
			if ( obj == null ) {
				return obj + "";
			}
			// Support: Android < 4.0, iOS < 6 (functionish RegExp)
			return typeof obj === "object" || typeof obj === "function" ?
				class2type[ toString.call(obj) ] || "object" :
				typeof obj;
		},

		// Evaluates a script in a global context
		globalEval: function( code ) {
			var script,
				indirect = eval;

			code = jQuery.trim( code );

			if ( code ) {
				// If the code includes a valid, prologue position
				// strict mode pragma, execute code by injecting a
				// script tag into the document.
				if ( code.indexOf("use strict") === 1 ) {
					script = document.createElement("script");
					script.text = code;
					document.head.appendChild( script ).parentNode.removeChild( script );
				} else {
				// Otherwise, avoid the DOM node creation, insertion
				// and removal by using an indirect global eval
					indirect( code );
				}
			}
		},

		// Convert dashed to camelCase; used by the css and data modules
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function( string ) {
			return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
		},

		nodeName: function( elem, name ) {
			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
		},

		// args is for internal usage only
		each: function( obj, callback, args ) {
			var value,
				i = 0,
				length = obj.length,
				isArray = isArraylike( obj );

			if ( args ) {
				if ( isArray ) {
					for ( ; i < length; i++ ) {
						value = callback.apply( obj[ i ], args );

						if ( value === false ) {
							break;
						}
					}
				} else {
					for ( i in obj ) {
						value = callback.apply( obj[ i ], args );

						if ( value === false ) {
							break;
						}
					}
				}

			// A special, fast, case for the most common use of each
			} else {
				if ( isArray ) {
					for ( ; i < length; i++ ) {
						value = callback.call( obj[ i ], i, obj[ i ] );

						if ( value === false ) {
							break;
						}
					}
				} else {
					for ( i in obj ) {
						value = callback.call( obj[ i ], i, obj[ i ] );

						if ( value === false ) {
							break;
						}
					}
				}
			}

			return obj;
		},

		// Support: Android<4.1
		trim: function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},

		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];

			if ( arr != null ) {
				if ( isArraylike( Object(arr) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}

			return ret;
		},

		inArray: function( elem, arr, i ) {
			return arr == null ? -1 : indexOf.call( arr, elem, i );
		},

		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;

			for ( ; j < len; j++ ) {
				first[ i++ ] = second[ j ];
			}

			first.length = i;

			return first;
		},

		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;

			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}

			return matches;
		},

		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var value,
				i = 0,
				length = elems.length,
				isArray = isArraylike( elems ),
				ret = [];

			// Go through the array, translating each of the items to their new values
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}

			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}
			}

			// Flatten any nested arrays
			return concat.apply( [], ret );
		},

		// A global GUID counter for objects
		guid: 1,

		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function( fn, context ) {
			var tmp, args, proxy;

			if ( typeof context === "string" ) {
				tmp = fn[ context ];
				context = fn;
				fn = tmp;
			}

			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if ( !jQuery.isFunction( fn ) ) {
				return undefined;
			}

			// Simulated bind
			args = slice.call( arguments, 2 );
			proxy = function() {
				return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
			};

			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;

			return proxy;
		},

		now: Date.now,

		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	});

	// Populate the class2type map
	jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	});

	function isArraylike( obj ) {
		var length = obj.length,
			type = jQuery.type( obj );

		if ( type === "function" || jQuery.isWindow( obj ) ) {
			return false;
		}

		if ( obj.nodeType === 1 && length ) {
			return true;
		}

		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	}
	var Sizzle =
	/*!
	 * Sizzle CSS Selector Engine v1.10.19
	 * http://sizzlejs.com/
	 *
	 * Copyright 2013 jQuery Foundation, Inc. and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2014-04-18
	 */
	(function( window ) {

	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,

		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,

		// Instance-specific data
		expando = "sizzle" + -(new Date()),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},

		// General-purpose constants
		strundefined = typeof undefined,
		MAX_NEGATIVE = 1 << 31,

		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf if we can't use a native one
		indexOf = arr.indexOf || function( elem ) {
			var i = 0,
				len = this.length;
			for ( ; i < len; i++ ) {
				if ( this[i] === elem ) {
					return i;
				}
			}
			return -1;
		},

		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

		// Regular expressions

		// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",
		// http://www.w3.org/TR/css3-syntax/#characters
		characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

		// Loosely modeled on CSS identifier characters
		// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
		// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = characterEncoding.replace( "w", "w#" ),

		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
			"*\\]",

		pseudos = ":(" + characterEncoding + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",

		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),

		matchExpr = {
			"ID": new RegExp( "^#(" + characterEncoding + ")" ),
			"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
			"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},

		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,

		rnative = /^[^{]+\{\s*\[native \w/,

		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

		rsibling = /[+~]/,
		rescape = /'|\\/g,

		// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ?
				escaped :
				high < 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		};

	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android<4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?

			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :

			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can't trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}

	function Sizzle( selector, context, results, seed ) {
		var match, elem, m, nodeType,
			// QSA vars
			i, groups, old, nid, newContext, newSelector;

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}

		context = context || document;
		results = results || [];

		if ( !selector || typeof selector !== "string" ) {
			return results;
		}

		if ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {
			return [];
		}

		if ( documentIsHTML && !seed ) {

			// Shortcuts
			if ( (match = rquickExpr.exec( selector )) ) {
				// Speed-up: Sizzle("#ID")
				if ( (m = match[1]) ) {
					if ( nodeType === 9 ) {
						elem = context.getElementById( m );
						// Check parentNode to catch when Blackberry 4.6 returns
						// nodes that are no longer in the document (jQuery #6963)
						if ( elem && elem.parentNode ) {
							// Handle the case where IE, Opera, and Webkit return items
							// by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}
					} else {
						// Context is not a document
						if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
							contains( context, elem ) && elem.id === m ) {
							results.push( elem );
							return results;
						}
					}

				// Speed-up: Sizzle("TAG")
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Speed-up: Sizzle(".CLASS")
				} else if ( (m = match[3]) && support.getElementsByClassName && context.getElementsByClassName ) {
					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// QSA path
			if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
				nid = old = expando;
				newContext = context;
				newSelector = nodeType === 9 && selector;

				// qSA works strangely on Element-rooted queries
				// We can work around this by specifying an extra ID on the root
				// and working up from there (Thanks to Andrew Dupont for the technique)
				// IE 8 doesn't work on object elements
				if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
					groups = tokenize( selector );

					if ( (old = context.getAttribute("id")) ) {
						nid = old.replace( rescape, "\\$&" );
					} else {
						context.setAttribute( "id", nid );
					}
					nid = "[id='" + nid + "'] ";

					i = groups.length;
					while ( i-- ) {
						groups[i] = nid + toSelector( groups[i] );
					}
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
					newSelector = groups.join(",");
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch(qsaError) {
					} finally {
						if ( !old ) {
							context.removeAttribute("id");
						}
					}
				}
			}
		}

		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}

	/**
	 * Create key-value caches of limited size
	 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];

		function cache( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + " " ] = value);
		}
		return cache;
	}

	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}

	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created div and expects a boolean result
	 */
	function assert( fn ) {
		var div = document.createElement("div");

		try {
			return !!fn( div );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( div.parentNode ) {
				div.parentNode.removeChild( div );
			}
			// release memory in IE
			div = null;
		}
	}

	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split("|"),
			i = attrs.length;

		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}

	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				( ~b.sourceIndex || MAX_NEGATIVE ) -
				( ~a.sourceIndex || MAX_NEGATIVE );

		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}

		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}

		return a ? 1 : -1;
	}

	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;

				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}

	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== strundefined && context;
	}

	// Expose support vars for convenience
	support = Sizzle.support = {};

	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};

	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare,
			doc = node ? node.ownerDocument || node : preferredDoc,
			parent = doc.defaultView;

		// If no document and documentElement is available, return
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}

		// Set our document
		document = doc;
		docElem = doc.documentElement;

		// Support tests
		documentIsHTML = !isXML( doc );

		// Support: IE>8
		// If iframe document is assigned to "document" variable and if iframe has been reloaded,
		// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
		// IE6-8 do not support the defaultView property so parent will be undefined
		if ( parent && parent !== parent.top ) {
			// IE11 does not have attachEvent, so all must suffer
			if ( parent.addEventListener ) {
				parent.addEventListener( "unload", function() {
					setDocument();
				}, false );
			} else if ( parent.attachEvent ) {
				parent.attachEvent( "onunload", function() {
					setDocument();
				});
			}
		}

		/* Attributes
		---------------------------------------------------------------------- */

		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)
		support.attributes = assert(function( div ) {
			div.className = "i";
			return !div.getAttribute("className");
		});

		/* getElement(s)By*
		---------------------------------------------------------------------- */

		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert(function( div ) {
			div.appendChild( doc.createComment("") );
			return !div.getElementsByTagName("*").length;
		});

		// Check if getElementsByClassName can be trusted
		support.getElementsByClassName = rnative.test( doc.getElementsByClassName ) && assert(function( div ) {
			div.innerHTML = "<div class='a'></div><div class='a i'></div>";

			// Support: Safari<4
			// Catch class over-caching
			div.firstChild.className = "i";
			// Support: Opera<10
			// Catch gEBCN failure to find non-leading classes
			return div.getElementsByClassName("i").length === 2;
		});

		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( div ) {
			docElem.appendChild( div ).id = expando;
			return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
		});

		// ID find and filter
		if ( support.getById ) {
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== strundefined && documentIsHTML ) {
					var m = context.getElementById( id );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					return m && m.parentNode ? [ m ] : [];
				}
			};
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
		} else {
			// Support: IE6/7
			// getElementById is not reliable as a find shortcut
			delete Expr.find["ID"];

			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};
		}

		// Tag
		Expr.find["TAG"] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== strundefined ) {
					return context.getElementsByTagName( tag );
				}
			} :
			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					results = context.getElementsByTagName( tag );

				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}

					return tmp;
				}
				return results;
			};

		// Class
		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
			if ( typeof context.getElementsByClassName !== strundefined && documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};

		/* QSA/matchesSelector
		---------------------------------------------------------------------- */

		// QSA and matchesSelector support

		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];

		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See http://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];

		if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( div ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// http://bugs.jquery.com/ticket/12359
				div.innerHTML = "<select msallowclip=''><option selected=''></option></select>";

				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( div.querySelectorAll("[msallowclip^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}

				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !div.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}

				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}
			});

			assert(function( div ) {
				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = doc.createElement("input");
				input.setAttribute( "type", "hidden" );
				div.appendChild( input ).setAttribute( "name", "D" );

				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( div.querySelectorAll("[name=d]").length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}

				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":enabled").length ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}

				// Opera 10-11 does not throw on post-comma invalid pseudos
				div.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}

		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {

			assert(function( div ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( div, "div" );

				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( div, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}

		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );

		// Element contains another
		// Purposefully does not implement inclusive descendent
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};

		/* Sorting
		---------------------------------------------------------------------- */

		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {

			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}

			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :

				// Otherwise we know they are disconnected
				1;

			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

				// Choose the first element that is related to our preferred document
				if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
					return 1;
				}

				// Maintain original order
				return sortInput ?
					( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
					0;
			}

			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];

			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === doc ? -1 :
					b === doc ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
					0;

			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}

			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}

			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}

			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :

				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};

		return doc;
	};

	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};

	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );

		if ( support.matchesSelector && documentIsHTML &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

			try {
				var ret = matches.call( elem, expr );

				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch(e) {}
		}

		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};

	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};

	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;

		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
	};

	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};

	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;

		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}

		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;

		return results;
	};

	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes

		return ret;
	};

	Expr = Sizzle.selectors = {

		// Can be adjusted by the user
		cacheLength: 50,

		createPseudo: markFunction,

		match: matchExpr,

		attrHandle: {},

		find: {},

		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},

		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );

				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}

				return match.slice( 0, 4 );
			},

			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();

				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}

					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}

				return match;
			},

			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[6] && match[2];

				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}

				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || "";

				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}

				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},

		filter: {

			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},

			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];

				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "" );
					});
			},

			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );

					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}

					result += "";

					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},

			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";

				return first === 1 && last === 0 ?

					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :

					function( elem, context, xml ) {
						var cache, outerCache, node, diff, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType;

						if ( parent ) {

							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}

							start = [ forward ? parent.firstChild : parent.lastChild ];

							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {
								// Seek `elem` from a previously-cached index
								outerCache = parent[ expando ] || (parent[ expando ] = {});
								cache = outerCache[ type ] || [];
								nodeIndex = cache[0] === dirruns && cache[1];
								diff = cache[0] === dirruns && cache[2];
								node = nodeIndex && parent.childNodes[ nodeIndex ];

								while ( (node = ++nodeIndex && node && node[ dir ] ||

									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {

									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										outerCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}

							// Use previously-cached element index if available
							} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
								diff = cache[1];

							// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
							} else {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
										// Cache the index of each encountered element
										if ( useCache ) {
											(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}

							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},

			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );

				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}

				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf.call( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}

				return fn;
			}
		},

		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );

				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;

						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						return !results.pop();
					};
			}),

			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),

			"contains": markFunction(function( text ) {
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),

			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),

			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},

			"root": function( elem ) {
				return elem === docElem;
			},

			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},

			// Boolean properties
			"enabled": function( elem ) {
				return elem.disabled === false;
			},

			"disabled": function( elem ) {
				return elem.disabled === true;
			},

			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},

			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}

				return elem.selected === true;
			},

			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},

			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},

			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},

			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},

			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},

			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&

					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
			},

			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),

			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),

			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),

			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};

	Expr.pseudos["nth"] = Expr.pseudos["eq"];

	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}

	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();

	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];

		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}

		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;

		while ( soFar ) {

			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}

			matched = false;

			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				});
				soFar = soFar.slice( matched.length );
			}

			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}

			if ( !matched ) {
				break;
			}
		}

		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};

	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}

	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			checkNonElements = base && dir === "parentNode",
			doneName = done++;

		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
			} :

			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, outerCache,
					newCache = [ dirruns, doneName ];

				// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});
							if ( (oldCache = outerCache[ dir ]) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								outerCache[ dir ] = newCache;

								// A match means we're done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
			};
	}

	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}

	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}

	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;

		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}

		return newUnmatched;
	}

	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,

				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,

				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

						// ...intermediate processing is necessary
						[] :

						// ...otherwise use results directly
						results :
					matcherIn;

			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}

			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );

				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}

			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}

					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {

							seed[temp] = !(results[temp] = elem);
						}
					}
				}

			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}

	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,

			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf.call( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
			} ];

		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}

		return elementMatcher( matchers );
	}

	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;

				if ( outermost ) {
					outermostContext = context !== document && context;
				}

				// Add elements passing elementMatchers directly to results
				// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context, xml ) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}

					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}

						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}

				// Apply set filters to unmatched elements
				matchedCount += i;
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}

					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}

						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}

					// Add matches to results
					push.apply( results, setMatched );

					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {

						Sizzle.uniqueSort( results );
					}
				}

				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}

				return unmatched;
			};

		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}

	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];

		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}

			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};

	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( (selector = compiled.selector || selector) );

		results = results || [];

		// Try to minimize operations if there is no seed and only one group
		if ( match.length === 1 ) {

			// Take a shortcut and set the context if the root selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					support.getById && context.nodeType === 9 && documentIsHTML &&
					Expr.relative[ tokens[1].type ] ) {

				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;

				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}

				selector = selector.slice( tokens.shift().value.length );
			}

			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}

						break;
					}
				}
			}
		}

		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};

	// One-time assignments

	// Sort stability
	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

	// Support: Chrome<14
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;

	// Initialize against the default document
	setDocument();

	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( div1 ) {
		// Should return 1, but returns 4 (following)
		return div1.compareDocumentPosition( document.createElement("div") ) & 1;
	});

	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( div ) {
		div.innerHTML = "<a href='#'></a>";
		return div.firstChild.getAttribute("href") === "#" ;
	}) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		});
	}

	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert(function( div ) {
		div.innerHTML = "<input/>";
		div.firstChild.setAttribute( "value", "" );
		return div.firstChild.getAttribute( "value" ) === "";
	}) ) {
		addHandle( "value", function( elem, name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		});
	}

	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( div ) {
		return div.getAttribute("disabled") == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) && val.specified ?
						val.value :
					null;
			}
		});
	}

	return Sizzle;

	})( window );



	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;
	jQuery.expr[":"] = jQuery.expr.pseudos;
	jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;



	var rneedsContext = jQuery.expr.match.needsContext;

	var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



	var risSimple = /^.[^:#\[\.,]*$/;

	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( jQuery.isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				/* jshint -W018 */
				return !!qualifier.call( elem, i, elem ) !== not;
			});

		}

		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			});

		}

		if ( typeof qualifier === "string" ) {
			if ( risSimple.test( qualifier ) ) {
				return jQuery.filter( qualifier, elements, not );
			}

			qualifier = jQuery.filter( qualifier, elements );
		}

		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) >= 0 ) !== not;
		});
	}

	jQuery.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];

		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 && elem.nodeType === 1 ?
			jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
			jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
				return elem.nodeType === 1;
			}));
	};

	jQuery.fn.extend({
		find: function( selector ) {
			var i,
				len = this.length,
				ret = [],
				self = this;

			if ( typeof selector !== "string" ) {
				return this.pushStack( jQuery( selector ).filter(function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				}) );
			}

			for ( i = 0; i < len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}

			// Needed because $( selector, context ) becomes $( context ).find( selector )
			ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
			ret.selector = this.selector ? this.selector + " " + selector : selector;
			return ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow(this, selector || [], false) );
		},
		not: function( selector ) {
			return this.pushStack( winnow(this, selector || [], true) );
		},
		is: function( selector ) {
			return !!winnow(
				this,

				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	});


	// Initialize a jQuery object


	// A central reference to the root jQuery(document)
	var rootjQuery,

		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

		init = jQuery.fn.init = function( selector, context ) {
			var match, elem;

			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}

			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector[0] === "<" && selector[ selector.length - 1 ] === ">" && selector.length >= 3 ) {
					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];

				} else {
					match = rquickExpr.exec( selector );
				}

				// Match html or make sure no context is specified for #id
				if ( match && (match[1] || !context) ) {

					// HANDLE: $(html) -> $(array)
					if ( match[1] ) {
						context = context instanceof jQuery ? context[0] : context;

						// scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[1],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );

						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {
								// Properties of context are called as methods if possible
								if ( jQuery.isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );

								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}

						return this;

					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[2] );

						// Check parentNode to catch when Blackberry 4.6 returns
						// nodes that are no longer in the document #6963
						if ( elem && elem.parentNode ) {
							// Inject the element directly into the jQuery object
							this.length = 1;
							this[0] = elem;
						}

						this.context = document;
						this.selector = selector;
						return this;
					}

				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || rootjQuery ).find( selector );

				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}

			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this.context = this[0] = selector;
				this.length = 1;
				return this;

			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( jQuery.isFunction( selector ) ) {
				return typeof rootjQuery.ready !== "undefined" ?
					rootjQuery.ready( selector ) :
					// Execute immediately if ready is not present
					selector( jQuery );
			}

			if ( selector.selector !== undefined ) {
				this.selector = selector.selector;
				this.context = selector.context;
			}

			return jQuery.makeArray( selector, this );
		};

	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;

	// Initialize central reference
	rootjQuery = jQuery( document );


	var rparentsprev = /^(?:parents|prev(?:Until|All))/,
		// methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};

	jQuery.extend({
		dir: function( elem, dir, until ) {
			var matched = [],
				truncate = until !== undefined;

			while ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {
				if ( elem.nodeType === 1 ) {
					if ( truncate && jQuery( elem ).is( until ) ) {
						break;
					}
					matched.push( elem );
				}
			}
			return matched;
		},

		sibling: function( n, elem ) {
			var matched = [];

			for ( ; n; n = n.nextSibling ) {
				if ( n.nodeType === 1 && n !== elem ) {
					matched.push( n );
				}
			}

			return matched;
		}
	});

	jQuery.fn.extend({
		has: function( target ) {
			var targets = jQuery( target, this ),
				l = targets.length;

			return this.filter(function() {
				var i = 0;
				for ( ; i < l; i++ ) {
					if ( jQuery.contains( this, targets[i] ) ) {
						return true;
					}
				}
			});
		},

		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
					jQuery( selectors, context || this.context ) :
					0;

			for ( ; i < l; i++ ) {
				for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
					// Always skip document fragments
					if ( cur.nodeType < 11 && (pos ?
						pos.index(cur) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector(cur, selectors)) ) {

						matched.push( cur );
						break;
					}
				}
			}

			return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
		},

		// Determine the position of an element within
		// the matched set of elements
		index: function( elem ) {

			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}

			// index in selector
			if ( typeof elem === "string" ) {
				return indexOf.call( jQuery( elem ), this[ 0 ] );
			}

			// Locate the position of the desired element
			return indexOf.call( this,

				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},

		add: function( selector, context ) {
			return this.pushStack(
				jQuery.unique(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},

		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter(selector)
			);
		}
	});

	function sibling( cur, dir ) {
		while ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}
		return cur;
	}

	jQuery.each({
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return jQuery.dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, i, until ) {
			return jQuery.dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return jQuery.dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return jQuery.dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, i, until ) {
			return jQuery.dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, i, until ) {
			return jQuery.dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return jQuery.sibling( elem.firstChild );
		},
		contents: function( elem ) {
			return elem.contentDocument || jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var matched = jQuery.map( this, fn, until );

			if ( name.slice( -5 ) !== "Until" ) {
				selector = until;
			}

			if ( selector && typeof selector === "string" ) {
				matched = jQuery.filter( selector, matched );
			}

			if ( this.length > 1 ) {
				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery.unique( matched );
				}

				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}

			return this.pushStack( matched );
		};
	});
	var rnotwhite = (/\S+/g);



	// String to Object options format cache
	var optionsCache = {};

	// Convert String-formatted options into Object-formatted ones and store in cache
	function createOptions( options ) {
		var object = optionsCache[ options ] = {};
		jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		});
		return object;
	}

	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {

		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			( optionsCache[ options ] || createOptions( options ) ) :
			jQuery.extend( {}, options );

		var // Last fire value (for non-forgettable lists)
			memory,
			// Flag to know if list was already fired
			fired,
			// Flag to know if list is currently firing
			firing,
			// First callback to fire (used internally by add and fireWith)
			firingStart,
			// End of the loop when firing
			firingLength,
			// Index of currently firing callback (modified by remove if needed)
			firingIndex,
			// Actual callback list
			list = [],
			// Stack of fire calls for repeatable lists
			stack = !options.once && [],
			// Fire callbacks
			fire = function( data ) {
				memory = options.memory && data;
				fired = true;
				firingIndex = firingStart || 0;
				firingStart = 0;
				firingLength = list.length;
				firing = true;
				for ( ; list && firingIndex < firingLength; firingIndex++ ) {
					if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
						memory = false; // To prevent further calls using add
						break;
					}
				}
				firing = false;
				if ( list ) {
					if ( stack ) {
						if ( stack.length ) {
							fire( stack.shift() );
						}
					} else if ( memory ) {
						list = [];
					} else {
						self.disable();
					}
				}
			},
			// Actual Callbacks object
			self = {
				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {
						// First, we save the current length
						var start = list.length;
						(function add( args ) {
							jQuery.each( args, function( _, arg ) {
								var type = jQuery.type( arg );
								if ( type === "function" ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && type !== "string" ) {
									// Inspect recursively
									add( arg );
								}
							});
						})( arguments );
						// Do we need to add the callbacks to the
						// current firing batch?
						if ( firing ) {
							firingLength = list.length;
						// With memory, if we're not firing then
						// we should call right away
						} else if ( memory ) {
							firingStart = start;
							fire( memory );
						}
					}
					return this;
				},
				// Remove a callback from the list
				remove: function() {
					if ( list ) {
						jQuery.each( arguments, function( _, arg ) {
							var index;
							while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
								list.splice( index, 1 );
								// Handle firing indexes
								if ( firing ) {
									if ( index <= firingLength ) {
										firingLength--;
									}
									if ( index <= firingIndex ) {
										firingIndex--;
									}
								}
							}
						});
					}
					return this;
				},
				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
				},
				// Remove all callbacks from the list
				empty: function() {
					list = [];
					firingLength = 0;
					return this;
				},
				// Have the list do nothing anymore
				disable: function() {
					list = stack = memory = undefined;
					return this;
				},
				// Is it disabled?
				disabled: function() {
					return !list;
				},
				// Lock the list in its current state
				lock: function() {
					stack = undefined;
					if ( !memory ) {
						self.disable();
					}
					return this;
				},
				// Is it locked?
				locked: function() {
					return !stack;
				},
				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( list && ( !fired || stack ) ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						if ( firing ) {
							stack.push( args );
						} else {
							fire( args );
						}
					}
					return this;
				},
				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},
				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};

		return self;
	};


	jQuery.extend({

		Deferred: function( func ) {
			var tuples = [
					// action, add listener, listener list, final state
					[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
					[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
					[ "notify", "progress", jQuery.Callbacks("memory") ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					then: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;
						return jQuery.Deferred(function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {
								var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
								// deferred[ done | fail | progress ] for forwarding actions to newDefer
								deferred[ tuple[1] ](function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.done( newDefer.resolve )
											.fail( newDefer.reject )
											.progress( newDefer.notify );
									} else {
										newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
									}
								});
							});
							fns = null;
						}).promise();
					},
					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};

			// Keep pipe for back-compat
			promise.pipe = promise.then;

			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 3 ];

				// promise[ done | fail | progress ] = list.add
				promise[ tuple[1] ] = list.add;

				// Handle state
				if ( stateString ) {
					list.add(function() {
						// state = [ resolved | rejected ]
						state = stateString;

					// [ reject_list | resolve_list ].disable; progress_list.lock
					}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
				}

				// deferred[ resolve | reject | notify ]
				deferred[ tuple[0] ] = function() {
					deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
					return this;
				};
				deferred[ tuple[0] + "With" ] = list.fireWith;
			});

			// Make the deferred a promise
			promise.promise( deferred );

			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}

			// All done!
			return deferred;
		},

		// Deferred helper
		when: function( subordinate /* , ..., subordinateN */ ) {
			var i = 0,
				resolveValues = slice.call( arguments ),
				length = resolveValues.length,

				// the count of uncompleted subordinates
				remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

				// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
				deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

				// Update function for both resolve and progress values
				updateFunc = function( i, contexts, values ) {
					return function( value ) {
						contexts[ i ] = this;
						values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
						if ( values === progressValues ) {
							deferred.notifyWith( contexts, values );
						} else if ( !( --remaining ) ) {
							deferred.resolveWith( contexts, values );
						}
					};
				},

				progressValues, progressContexts, resolveContexts;

			// add listeners to Deferred subordinates; treat others as resolved
			if ( length > 1 ) {
				progressValues = new Array( length );
				progressContexts = new Array( length );
				resolveContexts = new Array( length );
				for ( ; i < length; i++ ) {
					if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
						resolveValues[ i ].promise()
							.done( updateFunc( i, resolveContexts, resolveValues ) )
							.fail( deferred.reject )
							.progress( updateFunc( i, progressContexts, progressValues ) );
					} else {
						--remaining;
					}
				}
			}

			// if we're not waiting on anything, resolve the master
			if ( !remaining ) {
				deferred.resolveWith( resolveContexts, resolveValues );
			}

			return deferred.promise();
		}
	});


	// The deferred used on DOM ready
	var readyList;

	jQuery.fn.ready = function( fn ) {
		// Add the callback
		jQuery.ready.promise().done( fn );

		return this;
	};

	jQuery.extend({
		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,

		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,

		// Hold (or release) the ready event
		holdReady: function( hold ) {
			if ( hold ) {
				jQuery.readyWait++;
			} else {
				jQuery.ready( true );
			}
		},

		// Handle when the DOM is ready
		ready: function( wait ) {

			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );

			// Trigger any bound ready events
			if ( jQuery.fn.triggerHandler ) {
				jQuery( document ).triggerHandler( "ready" );
				jQuery( document ).off( "ready" );
			}
		}
	});

	/**
	 * The ready event handler and self cleanup method
	 */
	function completed() {
		document.removeEventListener( "DOMContentLoaded", completed, false );
		window.removeEventListener( "load", completed, false );
		jQuery.ready();
	}

	jQuery.ready.promise = function( obj ) {
		if ( !readyList ) {

			readyList = jQuery.Deferred();

			// Catch cases where $(document).ready() is called after the browser event has already occurred.
			// we once tried to use readyState "interactive" here, but it caused issues like the one
			// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
			if ( document.readyState === "complete" ) {
				// Handle it asynchronously to allow scripts the opportunity to delay ready
				setTimeout( jQuery.ready );

			} else {

				// Use the handy event callback
				document.addEventListener( "DOMContentLoaded", completed, false );

				// A fallback to window.onload, that will always work
				window.addEventListener( "load", completed, false );
			}
		}
		return readyList.promise( obj );
	};

	// Kick off the DOM ready check even if the user does not
	jQuery.ready.promise();




	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			len = elems.length,
			bulk = key == null;

		// Sets many values
		if ( jQuery.type( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
			}

		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;

			if ( !jQuery.isFunction( value ) ) {
				raw = true;
			}

			if ( bulk ) {
				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;

				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}

			if ( fn ) {
				for ( ; i < len; i++ ) {
					fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
				}
			}
		}

		return chainable ?
			elems :

			// Gets
			bulk ?
				fn.call( elems ) :
				len ? fn( elems[0], key ) : emptyGet;
	};


	/**
	 * Determines whether an object can have data
	 */
	jQuery.acceptData = function( owner ) {
		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		/* jshint -W018 */
		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
	};


	function Data() {
		// Support: Android < 4,
		// Old WebKit does not have Object.preventExtensions/freeze method,
		// return new empty object instead with no [[set]] accessor
		Object.defineProperty( this.cache = {}, 0, {
			get: function() {
				return {};
			}
		});

		this.expando = jQuery.expando + Math.random();
	}

	Data.uid = 1;
	Data.accepts = jQuery.acceptData;

	Data.prototype = {
		key: function( owner ) {
			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return the key for a frozen object.
			if ( !Data.accepts( owner ) ) {
				return 0;
			}

			var descriptor = {},
				// Check if the owner object already has a cache key
				unlock = owner[ this.expando ];

			// If not, create one
			if ( !unlock ) {
				unlock = Data.uid++;

				// Secure it in a non-enumerable, non-writable property
				try {
					descriptor[ this.expando ] = { value: unlock };
					Object.defineProperties( owner, descriptor );

				// Support: Android < 4
				// Fallback to a less secure definition
				} catch ( e ) {
					descriptor[ this.expando ] = unlock;
					jQuery.extend( owner, descriptor );
				}
			}

			// Ensure the cache object
			if ( !this.cache[ unlock ] ) {
				this.cache[ unlock ] = {};
			}

			return unlock;
		},
		set: function( owner, data, value ) {
			var prop,
				// There may be an unlock assigned to this node,
				// if there is no entry for this "owner", create one inline
				// and set the unlock as though an owner entry had always existed
				unlock = this.key( owner ),
				cache = this.cache[ unlock ];

			// Handle: [ owner, key, value ] args
			if ( typeof data === "string" ) {
				cache[ data ] = value;

			// Handle: [ owner, { properties } ] args
			} else {
				// Fresh assignments by object are shallow copied
				if ( jQuery.isEmptyObject( cache ) ) {
					jQuery.extend( this.cache[ unlock ], data );
				// Otherwise, copy the properties one-by-one to the cache object
				} else {
					for ( prop in data ) {
						cache[ prop ] = data[ prop ];
					}
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			// Either a valid cache is found, or will be created.
			// New caches will be created and the unlock returned,
			// allowing direct access to the newly created
			// empty data object. A valid owner object must be provided.
			var cache = this.cache[ this.key( owner ) ];

			return key === undefined ?
				cache : cache[ key ];
		},
		access: function( owner, key, value ) {
			var stored;
			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key === undefined ||
					((key && typeof key === "string") && value === undefined) ) {

				stored = this.get( owner, key );

				return stored !== undefined ?
					stored : this.get( owner, jQuery.camelCase(key) );
			}

			// [*]When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );

			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i, name, camel,
				unlock = this.key( owner ),
				cache = this.cache[ unlock ];

			if ( key === undefined ) {
				this.cache[ unlock ] = {};

			} else {
				// Support array or space separated string of keys
				if ( jQuery.isArray( key ) ) {
					// If "name" is an array of keys...
					// When data is initially created, via ("key", "val") signature,
					// keys will be converted to camelCase.
					// Since there is no way to tell _how_ a key was added, remove
					// both plain key and camelCase key. #12786
					// This will only penalize the array argument path.
					name = key.concat( key.map( jQuery.camelCase ) );
				} else {
					camel = jQuery.camelCase( key );
					// Try the string as a key before any manipulation
					if ( key in cache ) {
						name = [ key, camel ];
					} else {
						// If a key with the spaces exists, use it.
						// Otherwise, create an array by matching non-whitespace
						name = camel;
						name = name in cache ?
							[ name ] : ( name.match( rnotwhite ) || [] );
					}
				}

				i = name.length;
				while ( i-- ) {
					delete cache[ name[ i ] ];
				}
			}
		},
		hasData: function( owner ) {
			return !jQuery.isEmptyObject(
				this.cache[ owner[ this.expando ] ] || {}
			);
		},
		discard: function( owner ) {
			if ( owner[ this.expando ] ) {
				delete this.cache[ owner[ this.expando ] ];
			}
		}
	};
	var data_priv = new Data();

	var data_user = new Data();



	/*
		Implementation Summary

		1. Enforce API surface and semantic compatibility with 1.9.x branch
		2. Improve the module's maintainability by reducing the storage
			paths to a single mechanism.
		3. Use the same single mechanism to support "private" and "user" data.
		4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
		5. Avoid exposing implementation details on user objects (eg. expando properties)
		6. Provide a clear path for implementation upgrade to WeakMap in 2014
	*/
	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /([A-Z])/g;

	function dataAttr( elem, key, data ) {
		var name;

		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
			name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
			data = elem.getAttribute( name );

			if ( typeof data === "string" ) {
				try {
					data = data === "true" ? true :
						data === "false" ? false :
						data === "null" ? null :
						// Only convert to a number if it doesn't change the string
						+data + "" === data ? +data :
						rbrace.test( data ) ? jQuery.parseJSON( data ) :
						data;
				} catch( e ) {}

				// Make sure we set the data so it isn't changed later
				data_user.set( elem, key, data );
			} else {
				data = undefined;
			}
		}
		return data;
	}

	jQuery.extend({
		hasData: function( elem ) {
			return data_user.hasData( elem ) || data_priv.hasData( elem );
		},

		data: function( elem, name, data ) {
			return data_user.access( elem, name, data );
		},

		removeData: function( elem, name ) {
			data_user.remove( elem, name );
		},

		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to data_priv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return data_priv.access( elem, name, data );
		},

		_removeData: function( elem, name ) {
			data_priv.remove( elem, name );
		}
	});

	jQuery.fn.extend({
		data: function( key, value ) {
			var i, name, data,
				elem = this[ 0 ],
				attrs = elem && elem.attributes;

			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = data_user.get( elem );

					if ( elem.nodeType === 1 && !data_priv.get( elem, "hasDataAttrs" ) ) {
						i = attrs.length;
						while ( i-- ) {

							// Support: IE11+
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( "data-" ) === 0 ) {
									name = jQuery.camelCase( name.slice(5) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						data_priv.set( elem, "hasDataAttrs", true );
					}
				}

				return data;
			}

			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each(function() {
					data_user.set( this, key );
				});
			}

			return access( this, function( value ) {
				var data,
					camelKey = jQuery.camelCase( key );

				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem && value === undefined ) {
					// Attempt to get data from the cache
					// with the key as-is
					data = data_user.get( elem, key );
					if ( data !== undefined ) {
						return data;
					}

					// Attempt to get data from the cache
					// with the key camelized
					data = data_user.get( elem, camelKey );
					if ( data !== undefined ) {
						return data;
					}

					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr( elem, camelKey, undefined );
					if ( data !== undefined ) {
						return data;
					}

					// We tried really hard, but the data doesn't exist.
					return;
				}

				// Set the data...
				this.each(function() {
					// First, attempt to store a copy or reference of any
					// data that might've been store with a camelCased key.
					var data = data_user.get( this, camelKey );

					// For HTML5 data-* attribute interop, we have to
					// store property names with dashes in a camelCase form.
					// This might not apply to all properties...*
					data_user.set( this, camelKey, value );

					// *... In the case of properties that might _actually_
					// have dashes, we need to also store a copy of that
					// unchanged property.
					if ( key.indexOf("-") !== -1 && data !== undefined ) {
						data_user.set( this, key, value );
					}
				});
			}, null, value, arguments.length > 1, null, true );
		},

		removeData: function( key ) {
			return this.each(function() {
				data_user.remove( this, key );
			});
		}
	});


	jQuery.extend({
		queue: function( elem, type, data ) {
			var queue;

			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = data_priv.get( elem, type );

				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || jQuery.isArray( data ) ) {
						queue = data_priv.access( elem, type, jQuery.makeArray(data) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},

		dequeue: function( elem, type ) {
			type = type || "fx";

			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};

			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}

			if ( fn ) {

				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}

				// clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}

			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},

		// not intended for public consumption - generates a queueHooks object, or returns the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return data_priv.get( elem, key ) || data_priv.access( elem, key, {
				empty: jQuery.Callbacks("once memory").add(function() {
					data_priv.remove( elem, [ type + "queue", key ] );
				})
			});
		}
	});

	jQuery.fn.extend({
		queue: function( type, data ) {
			var setter = 2;

			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}

			if ( arguments.length < setter ) {
				return jQuery.queue( this[0], type );
			}

			return data === undefined ?
				this :
				this.each(function() {
					var queue = jQuery.queue( this, type, data );

					// ensure a hooks for this queue
					jQuery._queueHooks( this, type );

					if ( type === "fx" && queue[0] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				});
		},
		dequeue: function( type ) {
			return this.each(function() {
				jQuery.dequeue( this, type );
			});
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},
		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};

			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";

			while ( i-- ) {
				tmp = data_priv.get( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	});
	var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

	var isHidden = function( elem, el ) {
			// isHidden might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;
			return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
		};

	var rcheckableType = (/^(?:checkbox|radio)$/i);



	(function() {
		var fragment = document.createDocumentFragment(),
			div = fragment.appendChild( document.createElement( "div" ) ),
			input = document.createElement( "input" );

		// #11217 - WebKit loses check when the name is after the checked attribute
		// Support: Windows Web Apps (WWA)
		// `name` and `type` need .setAttribute for WWA
		input.setAttribute( "type", "radio" );
		input.setAttribute( "checked", "checked" );
		input.setAttribute( "name", "t" );

		div.appendChild( input );

		// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
		// old WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

		// Make sure textarea (and checkbox) defaultValue is properly cloned
		// Support: IE9-IE11+
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
	})();
	var strundefined = typeof undefined;



	support.focusinBubbles = "onfocusin" in window;


	var
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
		rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

	function returnTrue() {
		return true;
	}

	function returnFalse() {
		return false;
	}

	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}

	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {

		global: {},

		add: function( elem, types, handler, data, selector ) {

			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = data_priv.get( elem );

			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}

			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}

			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}

			// Init the element's event structure and main handler, if this is the first
			if ( !(events = elemData.events) ) {
				events = elemData.events = {};
			}
			if ( !(eventHandle = elemData.handle) ) {
				eventHandle = elemData.handle = function( e ) {
					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}

			// Handle multiple events separated by a space
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[t] ) || [];
				type = origType = tmp[1];
				namespaces = ( tmp[2] || "" ).split( "." ).sort();

				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}

				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};

				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;

				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};

				// handleObj is passed to all event handlers
				handleObj = jQuery.extend({
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join(".")
				}, handleObjIn );

				// Init the event handler queue if we're the first
				if ( !(handlers = events[ type ]) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;

					// Only use addEventListener if the special events handler returns false
					if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle, false );
						}
					}
				}

				if ( special.add ) {
					special.add.call( elem, handleObj );

					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}

				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}

				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}

		},

		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {

			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = data_priv.hasData( elem ) && data_priv.get( elem );

			if ( !elemData || !(events = elemData.events) ) {
				return;
			}

			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[t] ) || [];
				type = origType = tmp[1];
				namespaces = ( tmp[2] || "" ).split( "." ).sort();

				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}

				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];

					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );

						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}

				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
						jQuery.removeEvent( elem, type, elemData.handle );
					}

					delete events[ type ];
				}
			}

			// Remove the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				delete elemData.handle;
				data_priv.remove( elem, "events" );
			}
		},

		trigger: function( event, data, elem, onlyHandlers ) {

			var i, cur, tmp, bubbleType, ontype, handle, special,
				eventPath = [ elem || document ],
				type = hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

			cur = tmp = elem = elem || document;

			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}

			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}

			if ( type.indexOf(".") >= 0 ) {
				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split(".");
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf(":") < 0 && "on" + type;

			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );

			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join(".");
			event.namespace_re = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
				null;

			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}

			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );

			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}

			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}

				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === (elem.ownerDocument || document) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}

			// Fire handlers on the event path
			i = 0;
			while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;

				// jQuery handler
				handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}

				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;

			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {

				if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
					jQuery.acceptData( elem ) ) {

					// Call a native DOM method on the target with the same name name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];

						if ( tmp ) {
							elem[ ontype ] = null;
						}

						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						elem[ type ]();
						jQuery.event.triggered = undefined;

						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}

			return event.result;
		},

		dispatch: function( event ) {

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( event );

			var i, j, ret, matched, handleObj,
				handlerQueue = [],
				args = slice.call( arguments ),
				handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};

			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[0] = event;
			event.delegateTarget = this;

			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}

			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );

			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;

				j = 0;
				while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

					// Triggered event must either 1) have no namespace, or
					// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

						event.handleObj = handleObj;
						event.data = handleObj.data;

						ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
								.apply( matched.elem, args );

						if ( ret !== undefined ) {
							if ( (event.result = ret) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}

			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}

			return event.result;
		},

		handlers: function( event, handlers ) {
			var i, matches, sel, handleObj,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;

			// Find delegate handlers
			// Black-hole SVG <use> instance trees (#13180)
			// Avoid non-left-click bubbling in Firefox (#3861)
			if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

				for ( ; cur !== this; cur = cur.parentNode || this ) {

					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.disabled !== true || event.type !== "click" ) {
						matches = [];
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];

							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";

							if ( matches[ sel ] === undefined ) {
								matches[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) >= 0 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matches[ sel ] ) {
								matches.push( handleObj );
							}
						}
						if ( matches.length ) {
							handlerQueue.push({ elem: cur, handlers: matches });
						}
					}
				}
			}

			// Add the remaining (directly-bound) handlers
			if ( delegateCount < handlers.length ) {
				handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
			}

			return handlerQueue;
		},

		// Includes some event props shared by KeyEvent and MouseEvent
		props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

		fixHooks: {},

		keyHooks: {
			props: "char charCode key keyCode".split(" "),
			filter: function( event, original ) {

				// Add which for key events
				if ( event.which == null ) {
					event.which = original.charCode != null ? original.charCode : original.keyCode;
				}

				return event;
			}
		},

		mouseHooks: {
			props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
			filter: function( event, original ) {
				var eventDoc, doc, body,
					button = original.button;

				// Calculate pageX/Y if missing and clientX/Y available
				if ( event.pageX == null && original.clientX != null ) {
					eventDoc = event.target.ownerDocument || document;
					doc = eventDoc.documentElement;
					body = eventDoc.body;

					event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
					event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
				}

				// Add which for click: 1 === left; 2 === middle; 3 === right
				// Note: button is not normalized, so don't use it
				if ( !event.which && button !== undefined ) {
					event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
				}

				return event;
			}
		},

		fix: function( event ) {
			if ( event[ jQuery.expando ] ) {
				return event;
			}

			// Create a writable copy of the event object and normalize some properties
			var i, prop, copy,
				type = event.type,
				originalEvent = event,
				fixHook = this.fixHooks[ type ];

			if ( !fixHook ) {
				this.fixHooks[ type ] = fixHook =
					rmouseEvent.test( type ) ? this.mouseHooks :
					rkeyEvent.test( type ) ? this.keyHooks :
					{};
			}
			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

			event = new jQuery.Event( originalEvent );

			i = copy.length;
			while ( i-- ) {
				prop = copy[ i ];
				event[ prop ] = originalEvent[ prop ];
			}

			// Support: Cordova 2.5 (WebKit) (#13255)
			// All events should have a target; Cordova deviceready doesn't
			if ( !event.target ) {
				event.target = document;
			}

			// Support: Safari 6.0+, Chrome < 28
			// Target should not be a text node (#504, #13143)
			if ( event.target.nodeType === 3 ) {
				event.target = event.target.parentNode;
			}

			return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
		},

		special: {
			load: {
				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {
				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== safeActiveElement() && this.focus ) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if ( this === safeActiveElement() && this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {
				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
						this.click();
						return false;
					}
				},

				// For cross-browser consistency, don't fire native .click() on links
				_default: function( event ) {
					return jQuery.nodeName( event.target, "a" );
				}
			},

			beforeunload: {
				postDispatch: function( event ) {

					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if ( event.result !== undefined && event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		},

		simulate: function( type, elem, event, bubble ) {
			// Piggyback on a donor event to simulate a different one.
			// Fake originalEvent to avoid donor's stopPropagation, but if the
			// simulated event prevents default then we do the same on the donor.
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true,
					originalEvent: {}
				}
			);
			if ( bubble ) {
				jQuery.event.trigger( e, null, elem );
			} else {
				jQuery.event.dispatch.call( elem, e );
			}
			if ( e.isDefaultPrevented() ) {
				event.preventDefault();
			}
		}
	};

	jQuery.removeEvent = function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	};

	jQuery.Event = function( src, props ) {
		// Allow instantiation without the 'new' keyword
		if ( !(this instanceof jQuery.Event) ) {
			return new jQuery.Event( src, props );
		}

		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;

			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &&
					// Support: Android < 4.0
					src.returnValue === false ?
				returnTrue :
				returnFalse;

		// Event type
		} else {
			this.type = src;
		}

		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}

		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();

		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};

	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,

		preventDefault: function() {
			var e = this.originalEvent;

			this.isDefaultPrevented = returnTrue;

			if ( e && e.preventDefault ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;

			this.isPropagationStopped = returnTrue;

			if ( e && e.stopPropagation ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;

			this.isImmediatePropagationStopped = returnTrue;

			if ( e && e.stopImmediatePropagation ) {
				e.stopImmediatePropagation();
			}

			this.stopPropagation();
		}
	};

	// Create mouseenter/leave events using mouseover/out and event-time checks
	// Support: Chrome 15+
	jQuery.each({
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,

			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;

				// For mousenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	});

	// Create "bubbling" focus and blur events
	// Support: Firefox, Chrome, Safari
	if ( !support.focusinBubbles ) {
		jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function( event ) {
					jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
				};

			jQuery.event.special[ fix ] = {
				setup: function() {
					var doc = this.ownerDocument || this,
						attaches = data_priv.access( doc, fix );

					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					data_priv.access( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this,
						attaches = data_priv.access( doc, fix ) - 1;

					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						data_priv.remove( doc, fix );

					} else {
						data_priv.access( doc, fix, attaches );
					}
				}
			};
		});
	}

	jQuery.fn.extend({

		on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
			var origFn, type;

			// Types can be a map of types/handlers
			if ( typeof types === "object" ) {
				// ( types-Object, selector, data )
				if ( typeof selector !== "string" ) {
					// ( types-Object, data )
					data = data || selector;
					selector = undefined;
				}
				for ( type in types ) {
					this.on( type, selector, data, types[ type ], one );
				}
				return this;
			}

			if ( data == null && fn == null ) {
				// ( types, fn )
				fn = selector;
				data = selector = undefined;
			} else if ( fn == null ) {
				if ( typeof selector === "string" ) {
					// ( types, selector, fn )
					fn = data;
					data = undefined;
				} else {
					// ( types, data, fn )
					fn = data;
					data = selector;
					selector = undefined;
				}
			}
			if ( fn === false ) {
				fn = returnFalse;
			} else if ( !fn ) {
				return this;
			}

			if ( one === 1 ) {
				origFn = fn;
				fn = function( event ) {
					// Can use an empty set, since event contains the info
					jQuery().off( event );
					return origFn.apply( this, arguments );
				};
				// Use same guid so caller can remove using origFn
				fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
			}
			return this.each( function() {
				jQuery.event.add( this, types, fn, data, selector );
			});
		},
		one: function( types, selector, data, fn ) {
			return this.on( types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {
				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {
				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {
				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each(function() {
				jQuery.event.remove( this, types, fn, selector );
			});
		},

		trigger: function( type, data ) {
			return this.each(function() {
				jQuery.event.trigger( type, data, this );
			});
		},
		triggerHandler: function( type, data ) {
			var elem = this[0];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	});


	var
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
		rtagName = /<([\w:]+)/,
		rhtml = /<|&#?\w+;/,
		rnoInnerhtml = /<(?:script|style|link)/i,
		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rscriptType = /^$|\/(?:java|ecma)script/i,
		rscriptTypeMasked = /^true\/(.*)/,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

		// We have to close these tags to support XHTML (#13200)
		wrapMap = {

			// Support: IE 9
			option: [ 1, "<select multiple='multiple'>", "</select>" ],

			thead: [ 1, "<table>", "</table>" ],
			col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
			tr: [ 2, "<table><tbody>", "</tbody></table>" ],
			td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

			_default: [ 0, "", "" ]
		};

	// Support: IE 9
	wrapMap.optgroup = wrapMap.option;

	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;

	// Support: 1.x compatibility
	// Manipulating tables requires a tbody
	function manipulationTarget( elem, content ) {
		return jQuery.nodeName( elem, "table" ) &&
			jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

			elem.getElementsByTagName("tbody")[0] ||
				elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
			elem;
	}

	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		var match = rscriptTypeMasked.exec( elem.type );

		if ( match ) {
			elem.type = match[ 1 ];
		} else {
			elem.removeAttribute("type");
		}

		return elem;
	}

	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			data_priv.set(
				elems[ i ], "globalEval", !refElements || data_priv.get( refElements[ i ], "globalEval" )
			);
		}
	}

	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

		if ( dest.nodeType !== 1 ) {
			return;
		}

		// 1. Copy private data: events, handlers, etc.
		if ( data_priv.hasData( src ) ) {
			pdataOld = data_priv.access( src );
			pdataCur = data_priv.set( dest, pdataOld );
			events = pdataOld.events;

			if ( events ) {
				delete pdataCur.handle;
				pdataCur.events = {};

				for ( type in events ) {
					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
						jQuery.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}

		// 2. Copy user data
		if ( data_user.hasData( src ) ) {
			udataOld = data_user.access( src );
			udataCur = jQuery.extend( {}, udataOld );

			data_user.set( dest, udataCur );
		}
	}

	function getAll( context, tag ) {
		var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || "*" ) :
				context.querySelectorAll ? context.querySelectorAll( tag || "*" ) :
				[];

		return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
			jQuery.merge( [ context ], ret ) :
			ret;
	}

	// Support: IE >= 9
	function fixInput( src, dest ) {
		var nodeName = dest.nodeName.toLowerCase();

		// Fails to persist the checked state of a cloned checkbox or radio button.
		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;

		// Fails to return the selected option to the default selected state when cloning options
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}

	jQuery.extend({
		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode( true ),
				inPage = jQuery.contains( elem.ownerDocument, elem );

			// Support: IE >= 9
			// Fix Cloning issues
			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
					!jQuery.isXMLDoc( elem ) ) {

				// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					fixInput( srcElements[ i ], destElements[ i ] );
				}
			}

			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );

					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}

			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}

			// Return the cloned set
			return clone;
		},

		buildFragment: function( elems, context, scripts, selection ) {
			var elem, tmp, tag, wrap, contains, j,
				fragment = context.createDocumentFragment(),
				nodes = [],
				i = 0,
				l = elems.length;

			for ( ; i < l; i++ ) {
				elem = elems[ i ];

				if ( elem || elem === 0 ) {

					// Add nodes directly
					if ( jQuery.type( elem ) === "object" ) {
						// Support: QtWebKit
						// jQuery.merge because push.apply(_, arraylike) throws
						jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

					// Convert non-html into a text node
					} else if ( !rhtml.test( elem ) ) {
						nodes.push( context.createTextNode( elem ) );

					// Convert html into DOM nodes
					} else {
						tmp = tmp || fragment.appendChild( context.createElement("div") );

						// Deserialize a standard representation
						tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
						wrap = wrapMap[ tag ] || wrapMap._default;
						tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[ 2 ];

						// Descend through wrappers to the right content
						j = wrap[ 0 ];
						while ( j-- ) {
							tmp = tmp.lastChild;
						}

						// Support: QtWebKit
						// jQuery.merge because push.apply(_, arraylike) throws
						jQuery.merge( nodes, tmp.childNodes );

						// Remember the top-level container
						tmp = fragment.firstChild;

						// Fixes #12346
						// Support: Webkit, IE
						tmp.textContent = "";
					}
				}
			}

			// Remove wrapper from fragment
			fragment.textContent = "";

			i = 0;
			while ( (elem = nodes[ i++ ]) ) {

				// #4087 - If origin and destination elements are the same, and this is
				// that element, do not do anything
				if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
					continue;
				}

				contains = jQuery.contains( elem.ownerDocument, elem );

				// Append to fragment
				tmp = getAll( fragment.appendChild( elem ), "script" );

				// Preserve script evaluation history
				if ( contains ) {
					setGlobalEval( tmp );
				}

				// Capture executables
				if ( scripts ) {
					j = 0;
					while ( (elem = tmp[ j++ ]) ) {
						if ( rscriptType.test( elem.type || "" ) ) {
							scripts.push( elem );
						}
					}
				}
			}

			return fragment;
		},

		cleanData: function( elems ) {
			var data, elem, type, key,
				special = jQuery.event.special,
				i = 0;

			for ( ; (elem = elems[ i ]) !== undefined; i++ ) {
				if ( jQuery.acceptData( elem ) ) {
					key = elem[ data_priv.expando ];

					if ( key && (data = data_priv.cache[ key ]) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );

								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}
						if ( data_priv.cache[ key ] ) {
							// Discard any remaining `private` data
							delete data_priv.cache[ key ];
						}
					}
				}
				// Discard any remaining `user` data
				delete data_user.cache[ elem[ data_user.expando ] ];
			}
		}
	});

	jQuery.fn.extend({
		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().each(function() {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							this.textContent = value;
						}
					});
			}, null, value, arguments.length );
		},

		append: function() {
			return this.domManip( arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			});
		},

		prepend: function() {
			return this.domManip( arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			});
		},

		before: function() {
			return this.domManip( arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			});
		},

		after: function() {
			return this.domManip( arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			});
		},

		remove: function( selector, keepData /* Internal Use Only */ ) {
			var elem,
				elems = selector ? jQuery.filter( selector, this ) : this,
				i = 0;

			for ( ; (elem = elems[i]) != null; i++ ) {
				if ( !keepData && elem.nodeType === 1 ) {
					jQuery.cleanData( getAll( elem ) );
				}

				if ( elem.parentNode ) {
					if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
						setGlobalEval( getAll( elem, "script" ) );
					}
					elem.parentNode.removeChild( elem );
				}
			}

			return this;
		},

		empty: function() {
			var elem,
				i = 0;

			for ( ; (elem = this[i]) != null; i++ ) {
				if ( elem.nodeType === 1 ) {

					// Prevent memory leaks
					jQuery.cleanData( getAll( elem, false ) );

					// Remove any remaining nodes
					elem.textContent = "";
				}
			}

			return this;
		},

		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

			return this.map(function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			});
		},

		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;

				if ( value === undefined && elem.nodeType === 1 ) {
					return elem.innerHTML;
				}

				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

					value = value.replace( rxhtmlTag, "<$1></$2>" );

					try {
						for ( ; i < l; i++ ) {
							elem = this[ i ] || {};

							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}

						elem = 0;

					// If using innerHTML throws an exception, use the fallback method
					} catch( e ) {}
				}

				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},

		replaceWith: function() {
			var arg = arguments[ 0 ];

			// Make the changes, replacing each context element with the new content
			this.domManip( arguments, function( elem ) {
				arg = this.parentNode;

				jQuery.cleanData( getAll( this ) );

				if ( arg ) {
					arg.replaceChild( elem, this );
				}
			});

			// Force removal if there was no new content (e.g., from empty arguments)
			return arg && (arg.length || arg.nodeType) ? this : this.remove();
		},

		detach: function( selector ) {
			return this.remove( selector, true );
		},

		domManip: function( args, callback ) {

			// Flatten any nested arrays
			args = concat.apply( [], args );

			var fragment, first, scripts, hasScripts, node, doc,
				i = 0,
				l = this.length,
				set = this,
				iNoClone = l - 1,
				value = args[ 0 ],
				isFunction = jQuery.isFunction( value );

			// We can't cloneNode fragments that contain checked, in WebKit
			if ( isFunction ||
					( l > 1 && typeof value === "string" &&
						!support.checkClone && rchecked.test( value ) ) ) {
				return this.each(function( index ) {
					var self = set.eq( index );
					if ( isFunction ) {
						args[ 0 ] = value.call( this, index, self.html() );
					}
					self.domManip( args, callback );
				});
			}

			if ( l ) {
				fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
				first = fragment.firstChild;

				if ( fragment.childNodes.length === 1 ) {
					fragment = first;
				}

				if ( first ) {
					scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
					hasScripts = scripts.length;

					// Use the original fragment for the last item instead of the first because it can end up
					// being emptied incorrectly in certain situations (#8070).
					for ( ; i < l; i++ ) {
						node = fragment;

						if ( i !== iNoClone ) {
							node = jQuery.clone( node, true, true );

							// Keep references to cloned scripts for later restoration
							if ( hasScripts ) {
								// Support: QtWebKit
								// jQuery.merge because push.apply(_, arraylike) throws
								jQuery.merge( scripts, getAll( node, "script" ) );
							}
						}

						callback.call( this[ i ], node, i );
					}

					if ( hasScripts ) {
						doc = scripts[ scripts.length - 1 ].ownerDocument;

						// Reenable scripts
						jQuery.map( scripts, restoreScript );

						// Evaluate executable scripts on first document insertion
						for ( i = 0; i < hasScripts; i++ ) {
							node = scripts[ i ];
							if ( rscriptType.test( node.type || "" ) &&
								!data_priv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

								if ( node.src ) {
									// Optional AJAX dependency, but won't run scripts if not present
									if ( jQuery._evalUrl ) {
										jQuery._evalUrl( node.src );
									}
								} else {
									jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
								}
							}
						}
					}
				}
			}

			return this;
		}
	});

	jQuery.each({
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1,
				i = 0;

			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone( true );
				jQuery( insert[ i ] )[ original ]( elems );

				// Support: QtWebKit
				// .get() because push.apply(_, arraylike) throws
				push.apply( ret, elems.get() );
			}

			return this.pushStack( ret );
		};
	});


	var iframe,
		elemdisplay = {};

	/**
	 * Retrieve the actual display of a element
	 * @param {String} name nodeName of the element
	 * @param {Object} doc Document object
	 */
	// Called only from within defaultDisplay
	function actualDisplay( name, doc ) {
		var style,
			elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

			// getDefaultComputedStyle might be reliably used only on attached element
			display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?

				// Use of this method is a temporary fix (more like optmization) until something better comes along,
				// since it was removed from specification and supported only in FF
				style.display : jQuery.css( elem[ 0 ], "display" );

		// We don't have any data stored on the element,
		// so use "detach" method as fast way to get rid of the element
		elem.detach();

		return display;
	}

	/**
	 * Try to determine the default display value of an element
	 * @param {String} nodeName
	 */
	function defaultDisplay( nodeName ) {
		var doc = document,
			display = elemdisplay[ nodeName ];

		if ( !display ) {
			display = actualDisplay( nodeName, doc );

			// If the simple way fails, read from inside an iframe
			if ( display === "none" || !display ) {

				// Use the already-created iframe if possible
				iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

				// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
				doc = iframe[ 0 ].contentDocument;

				// Support: IE
				doc.write();
				doc.close();

				display = actualDisplay( nodeName, doc );
				iframe.detach();
			}

			// Store the correct default display
			elemdisplay[ nodeName ] = display;
		}

		return display;
	}
	var rmargin = (/^margin/);

	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

	var getStyles = function( elem ) {
			return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
		};



	function curCSS( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,
			style = elem.style;

		computed = computed || getStyles( elem );

		// Support: IE9
		// getPropertyValue is only needed for .css('filter') in IE9, see #12537
		if ( computed ) {
			ret = computed.getPropertyValue( name ) || computed[ name ];
		}

		if ( computed ) {

			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}

			// Support: iOS < 6
			// A tribute to the "awesome hack by Dean Edwards"
			// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
			// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
			if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret !== undefined ?
			// Support: IE
			// IE returns zIndex value as an integer.
			ret + "" :
			ret;
	}


	function addGetHookIf( conditionFn, hookFn ) {
		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function() {
				if ( conditionFn() ) {
					// Hook not needed (or it's not possible to use it due to missing dependency),
					// remove it.
					// Since there are no other hooks for marginRight, remove the whole object.
					delete this.get;
					return;
				}

				// Hook needed; redefine it so that the support test is not executed again.

				return (this.get = hookFn).apply( this, arguments );
			}
		};
	}


	(function() {
		var pixelPositionVal, boxSizingReliableVal,
			docElem = document.documentElement,
			container = document.createElement( "div" ),
			div = document.createElement( "div" );

		if ( !div.style ) {
			return;
		}

		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";

		container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
			"position:absolute";
		container.appendChild( div );

		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computePixelPositionAndBoxSizingReliable() {
			div.style.cssText =
				// Support: Firefox<29, Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
				"box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
				"border:1px;padding:1px;width:4px;position:absolute";
			div.innerHTML = "";
			docElem.appendChild( container );

			var divStyle = window.getComputedStyle( div, null );
			pixelPositionVal = divStyle.top !== "1%";
			boxSizingReliableVal = divStyle.width === "4px";

			docElem.removeChild( container );
		}

		// Support: node.js jsdom
		// Don't assume that getComputedStyle is a property of the global object
		if ( window.getComputedStyle ) {
			jQuery.extend( support, {
				pixelPosition: function() {
					// This test is executed only once but we still do memoizing
					// since we can use the boxSizingReliable pre-computing.
					// No need to check if the test was already performed, though.
					computePixelPositionAndBoxSizingReliable();
					return pixelPositionVal;
				},
				boxSizingReliable: function() {
					if ( boxSizingReliableVal == null ) {
						computePixelPositionAndBoxSizingReliable();
					}
					return boxSizingReliableVal;
				},
				reliableMarginRight: function() {
					// Support: Android 2.3
					// Check if div with explicit width and no margin-right incorrectly
					// gets computed margin-right based on width of container. (#3333)
					// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
					// This support function is only executed once so no memoizing is needed.
					var ret,
						marginDiv = div.appendChild( document.createElement( "div" ) );

					// Reset CSS: box-sizing; display; margin; border; padding
					marginDiv.style.cssText = div.style.cssText =
						// Support: Firefox<29, Android 2.3
						// Vendor-prefix box-sizing
						"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
						"box-sizing:content-box;display:block;margin:0;border:0;padding:0";
					marginDiv.style.marginRight = marginDiv.style.width = "0";
					div.style.width = "1px";
					docElem.appendChild( container );

					ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );

					docElem.removeChild( container );

					return ret;
				}
			});
		}
	})();


	// A method for quickly swapping in/out CSS properties to get correct calculations.
	jQuery.swap = function( elem, options, callback, args ) {
		var ret, name,
			old = {};

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.apply( elem, args || [] );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	};


	var
		// swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
		// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
		rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
		rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		},

		cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];

	// return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( style, name ) {

		// shortcut for names that are not vendor prefixed
		if ( name in style ) {
			return name;
		}

		// check for vendor prefixed names
		var capName = name[0].toUpperCase() + name.slice(1),
			origName = name,
			i = cssPrefixes.length;

		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in style ) {
				return name;
			}
		}

		return origName;
	}

	function setPositiveNumber( elem, value, subtract ) {
		var matches = rnumsplit.exec( value );
		return matches ?
			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
			value;
	}

	function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
		var i = extra === ( isBorderBox ? "border" : "content" ) ?
			// If we already have the right measurement, avoid augmentation
			4 :
			// Otherwise initialize for horizontal or vertical properties
			name === "width" ? 1 : 0,

			val = 0;

		for ( ; i < 4; i += 2 ) {
			// both box models exclude margin, so add it if we want it
			if ( extra === "margin" ) {
				val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
			}

			if ( isBorderBox ) {
				// border-box includes padding, so remove it if we want content
				if ( extra === "content" ) {
					val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}

				// at this point, extra isn't border nor margin, so remove border
				if ( extra !== "margin" ) {
					val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			} else {
				// at this point, extra isn't content, so add padding
				val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

				// at this point, extra isn't content nor padding, so add border
				if ( extra !== "padding" ) {
					val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}

		return val;
	}

	function getWidthOrHeight( elem, name, extra ) {

		// Start with offset property, which is equivalent to the border-box value
		var valueIsBorderBox = true,
			val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
			styles = getStyles( elem ),
			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// some non-html elements return undefined for offsetWidth, so check for null/undefined
		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
		if ( val <= 0 || val == null ) {
			// Fall back to computed then uncomputed css if necessary
			val = curCSS( elem, name, styles );
			if ( val < 0 || val == null ) {
				val = elem.style[ name ];
			}

			// Computed unit is not pixels. Stop here and return.
			if ( rnumnonpx.test(val) ) {
				return val;
			}

			// we need the check for style in case a browser which returns unreliable values
			// for getComputedStyle silently falls back to the reliable elem.style
			valueIsBorderBox = isBorderBox &&
				( support.boxSizingReliable() || val === elem.style[ name ] );

			// Normalize "", auto, and prepare for extra
			val = parseFloat( val ) || 0;
		}

		// use the active box-sizing model to add/subtract irrelevant styles
		return ( val +
			augmentWidthOrHeight(
				elem,
				name,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles
			)
		) + "px";
	}

	function showHide( elements, show ) {
		var display, elem, hidden,
			values = [],
			index = 0,
			length = elements.length;

		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}

			values[ index ] = data_priv.get( elem, "olddisplay" );
			display = elem.style.display;
			if ( show ) {
				// Reset the inline display of this element to learn if it is
				// being hidden by cascaded rules or not
				if ( !values[ index ] && display === "none" ) {
					elem.style.display = "";
				}

				// Set elements which have been overridden with display: none
				// in a stylesheet to whatever the default browser style is
				// for such an element
				if ( elem.style.display === "" && isHidden( elem ) ) {
					values[ index ] = data_priv.access( elem, "olddisplay", defaultDisplay(elem.nodeName) );
				}
			} else {
				hidden = isHidden( elem );

				if ( display !== "none" || !hidden ) {
					data_priv.set( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
				}
			}
		}

		// Set the display of most of the elements in a second loop
		// to avoid the constant reflow
		for ( index = 0; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}
			if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
				elem.style.display = show ? values[ index ] || "" : "none";
			}
		}

		return elements;
	}

	jQuery.extend({
		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {
						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},

		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},

		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			// normalize float css property
			"float": "cssFloat"
		},

		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {
			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}

			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = jQuery.camelCase( name ),
				style = elem.style;

			name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

			// gets hook for the prefixed version
			// followed by the unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;

				// convert relative number strings (+= or -=) to relative numbers. #7345
				if ( type === "string" && (ret = rrelNum.exec( value )) ) {
					value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
					// Fixes bug #9237
					type = "number";
				}

				// Make sure that null and NaN values aren't set. See: #7116
				if ( value == null || value !== value ) {
					return;
				}

				// If a number was passed in, add 'px' to the (except for certain CSS properties)
				if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
					value += "px";
				}

				// Fixes #8908, it can be done more correctly by specifying setters in cssHooks,
				// but it would mean to define eight (for every problematic property) identical functions
				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
					style[ name ] = "inherit";
				}

				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
					style[ name ] = value;
				}

			} else {
				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
					return ret;
				}

				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},

		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = jQuery.camelCase( name );

			// Make sure that we're working with the right name
			name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

			// gets hook for the prefixed version
			// followed by the unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}

			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}

			//convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}

			// Return, converting to number if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
			}
			return val;
		}
	});

	jQuery.each([ "height", "width" ], function( i, name ) {
		jQuery.cssHooks[ name ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {
					// certain elements can have dimension info if we invisibly show them
					// however, it must have a current display style that would benefit from this
					return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
						jQuery.swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, name, extra );
						}) :
						getWidthOrHeight( elem, name, extra );
				}
			},

			set: function( elem, value, extra ) {
				var styles = extra && getStyles( elem );
				return setPositiveNumber( elem, value, extra ?
					augmentWidthOrHeight(
						elem,
						name,
						extra,
						jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
						styles
					) : 0
				);
			}
		};
	});

	// Support: Android 2.3
	jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
		function( elem, computed ) {
			if ( computed ) {
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// Work around by temporarily setting element display to inline-block
				return jQuery.swap( elem, { "display": "inline-block" },
					curCSS, [ elem, "marginRight" ] );
			}
		}
	);

	// These hooks are used by animate to expand properties
	jQuery.each({
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},

					// assumes a single number if not a string
					parts = typeof value === "string" ? value.split(" ") : [ value ];

				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}

				return expanded;
			}
		};

		if ( !rmargin.test( prefix ) ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	});

	jQuery.fn.extend({
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;

				if ( jQuery.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;

					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}

					return map;
				}

				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		},
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === "boolean" ) {
				return state ? this.show() : this.hide();
			}

			return this.each(function() {
				if ( isHidden( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			});
		}
	});


	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;

	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || "swing";
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];

			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];

			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;

			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}

			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};

	Tween.prototype.init.prototype = Tween.prototype;

	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;

				if ( tween.elem[ tween.prop ] != null &&
					(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
					return tween.elem[ tween.prop ];
				}

				// passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails
				// so, simple values such as "10px" are parsed to Float.
				// complex values such as "rotate(1rad)" are returned as is.
				result = jQuery.css( tween.elem, tween.prop, "" );
				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {
				// use step hook for back compat - use cssHook if its there - use .style if its
				// available and use plain properties where available
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};

	// Support: IE9
	// Panic based approach to setting things on disconnected nodes

	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};

	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		}
	};

	jQuery.fx = Tween.prototype.init;

	// Back Compat <1.8 extension point
	jQuery.fx.step = {};




	var
		fxNow, timerId,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
		rrun = /queueHooks$/,
		animationPrefilters = [ defaultPrefilter ],
		tweeners = {
			"*": [ function( prop, value ) {
				var tween = this.createTween( prop, value ),
					target = tween.cur(),
					parts = rfxnum.exec( value ),
					unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

					// Starting value computation is required for potential unit mismatches
					start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
						rfxnum.exec( jQuery.css( tween.elem, prop ) ),
					scale = 1,
					maxIterations = 20;

				if ( start && start[ 3 ] !== unit ) {
					// Trust units reported by jQuery.css
					unit = unit || start[ 3 ];

					// Make sure we update the tween properties later on
					parts = parts || [];

					// Iteratively approximate from a nonzero starting point
					start = +target || 1;

					do {
						// If previous iteration zeroed out, double until we get *something*
						// Use a string for doubling factor so we don't accidentally see scale as unchanged below
						scale = scale || ".5";

						// Adjust and apply
						start = start / scale;
						jQuery.style( tween.elem, prop, start + unit );

					// Update scale, tolerating zero or NaN from tween.cur()
					// And breaking the loop if scale is unchanged or perfect, or if we've just had enough
					} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
				}

				// Update tween properties
				if ( parts ) {
					start = tween.start = +start || +target || 0;
					tween.unit = unit;
					// If a +=/-= token was provided, we're doing a relative animation
					tween.end = parts[ 1 ] ?
						start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
						+parts[ 2 ];
				}

				return tween;
			} ]
		};

	// Animations created synchronously will run synchronously
	function createFxNow() {
		setTimeout(function() {
			fxNow = undefined;
		});
		return ( fxNow = jQuery.now() );
	}

	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i = 0,
			attrs = { height: type };

		// if we include width, step value is 1 to do all cssExpand values,
		// if we don't include width, step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i < 4 ; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}

		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}

		return attrs;
	}

	function createTween( value, prop, animation ) {
		var tween,
			collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( (tween = collection[ index ].call( animation, prop, value )) ) {

				// we're done with this property
				return tween;
			}
		}
	}

	function defaultPrefilter( elem, props, opts ) {
		/* jshint validthis: true */
		var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHidden( elem ),
			dataShow = data_priv.get( elem, "fxshow" );

		// handle queue: false promises
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;

			anim.always(function() {
				// doing this makes sure that the complete handler will be called
				// before this completes
				anim.always(function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				});
			});
		}

		// height/width overflow pass
		if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
			// Make sure that nothing sneaks out
			// Record all 3 overflow attributes because IE9-10 do not
			// change the overflow attribute when overflowX and
			// overflowY are set to the same value
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

			// Set display property to inline-block for height/width
			// animations on inline elements that are having width/height animated
			display = jQuery.css( elem, "display" );

			// Test default display if display is currently "none"
			checkDisplay = display === "none" ?
				data_priv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

			if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
				style.display = "inline-block";
			}
		}

		if ( opts.overflow ) {
			style.overflow = "hidden";
			anim.always(function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			});
		}

		// show/hide pass
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.exec( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {

					// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
						hidden = true;
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

			// Any non-fx value stops us from restoring the original display value
			} else {
				display = undefined;
			}
		}

		if ( !jQuery.isEmptyObject( orig ) ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = data_priv.access( elem, "fxshow", {} );
			}

			// store state if its toggle - enables .stop().toggle() to "reverse"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}
			if ( hidden ) {
				jQuery( elem ).show();
			} else {
				anim.done(function() {
					jQuery( elem ).hide();
				});
			}
			anim.done(function() {
				var prop;

				data_priv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			});
			for ( prop in orig ) {
				tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

				if ( !( prop in dataShow ) ) {
					dataShow[ prop ] = tween.start;
					if ( hidden ) {
						tween.end = tween.start;
						tween.start = prop === "width" || prop === "height" ? 1 : 0;
					}
				}
			}

		// If this is a noop like .hide().hide(), restore an overwritten display value
		} else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
			style.display = display;
		}
	}

	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;

		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = jQuery.camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( jQuery.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}

			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}

			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];

				// not quite $.extend, this wont overwrite keys already present.
				// also - reusing 'index' from above because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}

	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = animationPrefilters.length,
			deferred = jQuery.Deferred().always( function() {
				// don't match elem in the :animated selector
				delete tick.elem;
			}),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
					// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;

				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( percent );
				}

				deferred.notifyWith( elem, [ animation, percent, remaining ]);

				if ( percent < 1 && length ) {
					return remaining;
				} else {
					deferred.resolveWith( elem, [ animation ] );
					return false;
				}
			},
			animation = deferred.promise({
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, { specialEasing: {} }, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,
						// if we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length ; index++ ) {
						animation.tweens[ index ].run( 1 );
					}

					// resolve when we played the last frame
					// otherwise, reject
					if ( gotoEnd ) {
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			}),
			props = animation.props;

		propFilter( props, animation.opts.specialEasing );

		for ( ; index < length ; index++ ) {
			result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				return result;
			}
		}

		jQuery.map( props, createTween, animation );

		if ( jQuery.isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}

		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			})
		);

		// attach callbacks from options
		return animation.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );
	}

	jQuery.Animation = jQuery.extend( Animation, {

		tweener: function( props, callback ) {
			if ( jQuery.isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.split(" ");
			}

			var prop,
				index = 0,
				length = props.length;

			for ( ; index < length ; index++ ) {
				prop = props[ index ];
				tweeners[ prop ] = tweeners[ prop ] || [];
				tweeners[ prop ].unshift( callback );
			}
		},

		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				animationPrefilters.unshift( callback );
			} else {
				animationPrefilters.push( callback );
			}
		}
	});

	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};

		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

		// normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function() {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};

		return opt;
	};

	jQuery.fn.extend({
		fadeTo: function( speed, to, easing, callback ) {

			// show any hidden elements after setting opacity to 0
			return this.filter( isHidden ).css( "opacity", 0 ).show()

				// animate to the value specified
				.end().animate({ opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {
					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );

					// Empty animations, or finishing resolves immediately
					if ( empty || data_priv.get( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;

			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};

			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue && type !== false ) {
				this.queue( type || "fx", [] );
			}

			return this.each(function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = data_priv.get( this );

				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}

				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}

				// start the next in the queue if the last step wasn't forced
				// timers currently will call their complete callbacks, which will dequeue
				// but only if they were gotoEnd
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			});
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each(function() {
				var index,
					data = data_priv.get( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;

				// enable finishing flag on private data
				data.finish = true;

				// empty the queue first
				jQuery.queue( this, type, [] );

				if ( hooks && hooks.stop ) {
					hooks.stop.call( this, true );
				}

				// look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}

				// look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}

				// turn off finishing flag
				delete data.finish;
			});
		}
	});

	jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	});

	// Generate shortcuts for custom animations
	jQuery.each({
		slideDown: genFx("show"),
		slideUp: genFx("hide"),
		slideToggle: genFx("toggle"),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	});

	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery.timers;

		fxNow = jQuery.now();

		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];
			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};

	jQuery.fx.timer = function( timer ) {
		jQuery.timers.push( timer );
		if ( timer() ) {
			jQuery.fx.start();
		} else {
			jQuery.timers.pop();
		}
	};

	jQuery.fx.interval = 13;

	jQuery.fx.start = function() {
		if ( !timerId ) {
			timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
		}
	};

	jQuery.fx.stop = function() {
		clearInterval( timerId );
		timerId = null;
	};

	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,
		// Default speed
		_default: 400
	};


	// Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = setTimeout( next, time );
			hooks.stop = function() {
				clearTimeout( timeout );
			};
		});
	};


	(function() {
		var input = document.createElement( "input" ),
			select = document.createElement( "select" ),
			opt = select.appendChild( document.createElement( "option" ) );

		input.type = "checkbox";

		// Support: iOS 5.1, Android 4.x, Android 2.3
		// Check the default checkbox/radio value ("" on old WebKit; "on" elsewhere)
		support.checkOn = input.value !== "";

		// Must access the parent to make an option select properly
		// Support: IE9, IE10
		support.optSelected = opt.selected;

		// Make sure that the options inside disabled selects aren't marked as disabled
		// (WebKit marks them as disabled)
		select.disabled = true;
		support.optDisabled = !opt.disabled;

		// Check if an input maintains its value after becoming a radio
		// Support: IE9, IE10
		input = document.createElement( "input" );
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	})();


	var nodeHook, boolHook,
		attrHandle = jQuery.expr.attrHandle;

	jQuery.fn.extend({
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length > 1 );
		},

		removeAttr: function( name ) {
			return this.each(function() {
				jQuery.removeAttr( this, name );
			});
		}
	});

	jQuery.extend({
		attr: function( elem, name, value ) {
			var hooks, ret,
				nType = elem.nodeType;

			// don't get/set attributes on text, comment and attribute nodes
			if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === strundefined ) {
				return jQuery.prop( elem, name, value );
			}

			// All attributes are lowercase
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
				name = name.toLowerCase();
				hooks = jQuery.attrHooks[ name ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
			}

			if ( value !== undefined ) {

				if ( value === null ) {
					jQuery.removeAttr( elem, name );

				} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
					return ret;

				} else {
					elem.setAttribute( name, value + "" );
					return value;
				}

			} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
				return ret;

			} else {
				ret = jQuery.find.attr( elem, name );

				// Non-existent attributes return null, we normalize to undefined
				return ret == null ?
					undefined :
					ret;
			}
		},

		removeAttr: function( elem, value ) {
			var name, propName,
				i = 0,
				attrNames = value && value.match( rnotwhite );

			if ( attrNames && elem.nodeType === 1 ) {
				while ( (name = attrNames[i++]) ) {
					propName = jQuery.propFix[ name ] || name;

					// Boolean attributes get special treatment (#10870)
					if ( jQuery.expr.match.bool.test( name ) ) {
						// Set corresponding property to false
						elem[ propName ] = false;
					}

					elem.removeAttribute( name );
				}
			}
		},

		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue && value === "radio" &&
						jQuery.nodeName( elem, "input" ) ) {
						// Setting the type on a radio button after the value resets the value in IE6-9
						// Reset value to default in case type is set after value during creation
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		}
	});

	// Hooks for boolean attributes
	boolHook = {
		set: function( elem, value, name ) {
			if ( value === false ) {
				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else {
				elem.setAttribute( name, name );
			}
			return name;
		}
	};
	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
		var getter = attrHandle[ name ] || jQuery.find.attr;

		attrHandle[ name ] = function( elem, name, isXML ) {
			var ret, handle;
			if ( !isXML ) {
				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ name ];
				attrHandle[ name ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					name.toLowerCase() :
					null;
				attrHandle[ name ] = handle;
			}
			return ret;
		};
	});




	var rfocusable = /^(?:input|select|textarea|button)$/i;

	jQuery.fn.extend({
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length > 1 );
		},

		removeProp: function( name ) {
			return this.each(function() {
				delete this[ jQuery.propFix[ name ] || name ];
			});
		}
	});

	jQuery.extend({
		propFix: {
			"for": "htmlFor",
			"class": "className"
		},

		prop: function( elem, name, value ) {
			var ret, hooks, notxml,
				nType = elem.nodeType;

			// don't get/set properties on text, comment and attribute nodes
			if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

			if ( notxml ) {
				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}

			if ( value !== undefined ) {
				return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
					ret :
					( elem[ name ] = value );

			} else {
				return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
					ret :
					elem[ name ];
			}
		},

		propHooks: {
			tabIndex: {
				get: function( elem ) {
					return elem.hasAttribute( "tabindex" ) || rfocusable.test( elem.nodeName ) || elem.href ?
						elem.tabIndex :
						-1;
				}
			}
		}
	});

	// Support: IE9+
	// Selectedness for an option in an optgroup can be inaccurate
	if ( !support.optSelected ) {
		jQuery.propHooks.selected = {
			get: function( elem ) {
				var parent = elem.parentNode;
				if ( parent && parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
				return null;
			}
		};
	}

	jQuery.each([
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery.propFix[ this.toLowerCase() ] = this;
	});




	var rclass = /[\t\r\n\f]/g;

	jQuery.fn.extend({
		addClass: function( value ) {
			var classes, elem, cur, clazz, j, finalValue,
				proceed = typeof value === "string" && value,
				i = 0,
				len = this.length;

			if ( jQuery.isFunction( value ) ) {
				return this.each(function( j ) {
					jQuery( this ).addClass( value.call( this, j, this.className ) );
				});
			}

			if ( proceed ) {
				// The disjunction here is for better compressibility (see removeClass)
				classes = ( value || "" ).match( rnotwhite ) || [];

				for ( ; i < len; i++ ) {
					elem = this[ i ];
					cur = elem.nodeType === 1 && ( elem.className ?
						( " " + elem.className + " " ).replace( rclass, " " ) :
						" "
					);

					if ( cur ) {
						j = 0;
						while ( (clazz = classes[j++]) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}

						// only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim( cur );
						if ( elem.className !== finalValue ) {
							elem.className = finalValue;
						}
					}
				}
			}

			return this;
		},

		removeClass: function( value ) {
			var classes, elem, cur, clazz, j, finalValue,
				proceed = arguments.length === 0 || typeof value === "string" && value,
				i = 0,
				len = this.length;

			if ( jQuery.isFunction( value ) ) {
				return this.each(function( j ) {
					jQuery( this ).removeClass( value.call( this, j, this.className ) );
				});
			}
			if ( proceed ) {
				classes = ( value || "" ).match( rnotwhite ) || [];

				for ( ; i < len; i++ ) {
					elem = this[ i ];
					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 && ( elem.className ?
						( " " + elem.className + " " ).replace( rclass, " " ) :
						""
					);

					if ( cur ) {
						j = 0;
						while ( (clazz = classes[j++]) ) {
							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}

						// only assign if different to avoid unneeded rendering.
						finalValue = value ? jQuery.trim( cur ) : "";
						if ( elem.className !== finalValue ) {
							elem.className = finalValue;
						}
					}
				}
			}

			return this;
		},

		toggleClass: function( value, stateVal ) {
			var type = typeof value;

			if ( typeof stateVal === "boolean" && type === "string" ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}

			if ( jQuery.isFunction( value ) ) {
				return this.each(function( i ) {
					jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
				});
			}

			return this.each(function() {
				if ( type === "string" ) {
					// toggle individual class names
					var className,
						i = 0,
						self = jQuery( this ),
						classNames = value.match( rnotwhite ) || [];

					while ( (className = classNames[ i++ ]) ) {
						// check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}

				// Toggle whole class name
				} else if ( type === strundefined || type === "boolean" ) {
					if ( this.className ) {
						// store className if set
						data_priv.set( this, "__className__", this.className );
					}

					// If the element has a class name or if we're passed "false",
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					this.className = this.className || value === false ? "" : data_priv.get( this, "__className__" ) || "";
				}
			});
		},

		hasClass: function( selector ) {
			var className = " " + selector + " ",
				i = 0,
				l = this.length;
			for ( ; i < l; i++ ) {
				if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
					return true;
				}
			}

			return false;
		}
	});




	var rreturn = /\r/g;

	jQuery.fn.extend({
		val: function( value ) {
			var hooks, ret, isFunction,
				elem = this[0];

			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

					if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
						return ret;
					}

					ret = elem.value;

					return typeof ret === "string" ?
						// handle most common string cases
						ret.replace(rreturn, "") :
						// handle cases where value is null/undef or number
						ret == null ? "" : ret;
				}

				return;
			}

			isFunction = jQuery.isFunction( value );

			return this.each(function( i ) {
				var val;

				if ( this.nodeType !== 1 ) {
					return;
				}

				if ( isFunction ) {
					val = value.call( this, i, jQuery( this ).val() );
				} else {
					val = value;
				}

				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";

				} else if ( typeof val === "number" ) {
					val += "";

				} else if ( jQuery.isArray( val ) ) {
					val = jQuery.map( val, function( value ) {
						return value == null ? "" : value + "";
					});
				}

				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

				// If set returns undefined, fall back to normal setting
				if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			});
		}
	});

	jQuery.extend({
		valHooks: {
			option: {
				get: function( elem ) {
					var val = jQuery.find.attr( elem, "value" );
					return val != null ?
						val :
						// Support: IE10-11+
						// option.text throws exceptions (#14686, #14858)
						jQuery.trim( jQuery.text( elem ) );
				}
			},
			select: {
				get: function( elem ) {
					var value, option,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one" || index < 0,
						values = one ? null : [],
						max = one ? index + 1 : options.length,
						i = index < 0 ?
							max :
							one ? index : 0;

					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];

						// IE6-9 doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&
								// Don't return options that are disabled or in a disabled optgroup
								( support.optDisabled ? !option.disabled : option.getAttribute( "disabled" ) === null ) &&
								( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

							// Get the specific value for the option
							value = jQuery( option ).val();

							// We don't need an array for one selects
							if ( one ) {
								return value;
							}

							// Multi-Selects return an array
							values.push( value );
						}
					}

					return values;
				},

				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray( value ),
						i = options.length;

					while ( i-- ) {
						option = options[ i ];
						if ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {
							optionSet = true;
						}
					}

					// force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	});

	// Radios and checkboxes getter/setter
	jQuery.each([ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( jQuery.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get = function( elem ) {
				// Support: Webkit
				// "" is returned instead of "on" if a value isn't specified
				return elem.getAttribute("value") === null ? "on" : elem.value;
			};
		}
	});




	// Return jQuery for attributes-only inclusion


	jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	});

	jQuery.fn.extend({
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		},

		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},

		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {
			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
		}
	});


	var nonce = jQuery.now();

	var rquery = (/\?/);



	// Support: Android 2.3
	// Workaround failure to string-cast null input
	jQuery.parseJSON = function( data ) {
		return JSON.parse( data + "" );
	};


	// Cross-browser xml parsing
	jQuery.parseXML = function( data ) {
		var xml, tmp;
		if ( !data || typeof data !== "string" ) {
			return null;
		}

		// Support: IE9
		try {
			tmp = new DOMParser();
			xml = tmp.parseFromString( data, "text/xml" );
		} catch ( e ) {
			xml = undefined;
		}

		if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	};


	var
		// Document location
		ajaxLocParts,
		ajaxLocation,

		rhash = /#.*$/,
		rts = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,
		rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},

		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},

		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat("*");

	// #8138, IE may throw an exception when accessing
	// a field from window.location if document.domain has been set
	try {
		ajaxLocation = location.href;
	} catch( e ) {
		// Use the href attribute of an A element
		// since IE will modify it given document.location
		ajaxLocation = document.createElement( "a" );
		ajaxLocation.href = "";
		ajaxLocation = ajaxLocation.href;
	}

	// Segment location into parts
	ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {

		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {

			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}

			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

			if ( jQuery.isFunction( func ) ) {
				// For each dataType in the dataTypeExpression
				while ( (dataType = dataTypes[i++]) ) {
					// Prepend if requested
					if ( dataType[0] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

					// Otherwise append
					} else {
						(structure[ dataType ] = structure[ dataType ] || []).push( func );
					}
				}
			}
		};
	}

	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

		var inspected = {},
			seekingTransport = ( structure === transports );

		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			});
			return selected;
		}

		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}

	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};

		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}

		return target;
	}

	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {

		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;

		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
			}
		}

		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}

		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {
			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}
			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}

		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}

	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},
			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();

		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}

		current = dataTypes.shift();

		// Convert to each sequential dataType
		while ( current ) {

			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}

			// Apply the dataFilter if provided
			if ( !prev && isSuccess && s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}

			prev = current;
			current = dataTypes.shift();

			if ( current ) {

			// There's only work to do if current dataType is non-auto
				if ( current === "*" ) {

					current = prev;

				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== "*" && prev !== current ) {

					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];

					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {

							// If conv2 outputs current
							tmp = conv2.split( " " );
							if ( tmp[ 1 ] === current ) {

								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {
									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];

									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}

					// Apply converter (if not an equivalence)
					if ( conv !== true ) {

						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s[ "throws" ] ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
							}
						}
					}
				}
			}
		}

		return { state: "success", data: response };
	}

	jQuery.extend({

		// Counter for holding the number of active queries
		active: 0,

		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},

		ajaxSettings: {
			url: ajaxLocation,
			type: "GET",
			isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/

			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},

			contents: {
				xml: /xml/,
				html: /html/,
				json: /json/
			},

			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},

			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {

				// Convert anything to text
				"* text": String,

				// Text to html (true = no transformation)
				"text html": true,

				// Evaluate text as a json expression
				"text json": jQuery.parseJSON,

				// Parse text as xml
				"text xml": jQuery.parseXML
			},

			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},

		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?

				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},

		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),

		// Main method
		ajax: function( url, options ) {

			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}

			// Force options to be an object
			options = options || {};

			var transport,
				// URL without anti-cache param
				cacheURL,
				// Response headers
				responseHeadersString,
				responseHeaders,
				// timeout handle
				timeoutTimer,
				// Cross-domain detection vars
				parts,
				// To know if global events are to be dispatched
				fireGlobals,
				// Loop variable
				i,
				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),
				// Callbacks context
				callbackContext = s.context || s,
				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,
				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks("once memory"),
				// Status-dependent callbacks
				statusCode = s.statusCode || {},
				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},
				// The jqXHR state
				state = 0,
				// Default abort message
				strAbort = "canceled",
				// Fake xhr
				jqXHR = {
					readyState: 0,

					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( state === 2 ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( (match = rheaders.exec( responseHeadersString )) ) {
									responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},

					// Raw string
					getAllResponseHeaders: function() {
						return state === 2 ? responseHeadersString : null;
					},

					// Caches the header
					setRequestHeader: function( name, value ) {
						var lname = name.toLowerCase();
						if ( !state ) {
							name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},

					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( !state ) {
							s.mimeType = type;
						}
						return this;
					},

					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( state < 2 ) {
								for ( code in map ) {
									// Lazy-add the new callback in a way that preserves old ones
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							} else {
								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							}
						}
						return this;
					},

					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};

			// Attach deferreds
			deferred.promise( jqXHR ).complete = completeDeferred.add;
			jqXHR.success = jqXHR.done;
			jqXHR.error = jqXHR.fail;

			// Remove hash character (#7531: and string promotion)
			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )
				.replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;

			// Extract dataTypes list
			s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

			// A cross-domain request is in order when we have a protocol:host:port mismatch
			if ( s.crossDomain == null ) {
				parts = rurl.exec( s.url.toLowerCase() );
				s.crossDomain = !!( parts &&
					( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
						( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
							( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
				);
			}

			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}

			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

			// If request was aborted inside a prefilter, stop there
			if ( state === 2 ) {
				return jqXHR;
			}

			// We can fire global events as of now if asked to
			fireGlobals = s.global;

			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger("ajaxStart");
			}

			// Uppercase the type
			s.type = s.type.toUpperCase();

			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );

			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			cacheURL = s.url;

			// More options handling for requests with no content
			if ( !s.hasContent ) {

				// If data is available, append data to url
				if ( s.data ) {
					cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}

				// Add anti-cache in url if needed
				if ( s.cache === false ) {
					s.url = rts.test( cacheURL ) ?

						// If there is already a '_' parameter, set its value
						cacheURL.replace( rts, "$1_=" + nonce++ ) :

						// Otherwise add one to the end
						cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
				}
			}

			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}

			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}

			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
					s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);

			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}

			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
				// Abort if not done already and return
				return jqXHR.abort();
			}

			// aborting is no longer a cancellation
			strAbort = "abort";

			// Install callbacks on deferreds
			for ( i in { success: 1, error: 1, complete: 1 } ) {
				jqXHR[ i ]( s[ i ] );
			}

			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;

				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}
				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = setTimeout(function() {
						jqXHR.abort("timeout");
					}, s.timeout );
				}

				try {
					state = 1;
					transport.send( requestHeaders, done );
				} catch ( e ) {
					// Propagate exception as error if not done
					if ( state < 2 ) {
						done( -1, e );
					// Simply rethrow otherwise
					} else {
						throw e;
					}
				}
			}

			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;

				// Called once
				if ( state === 2 ) {
					return;
				}

				// State is "done" now
				state = 2;

				// Clear timeout if it exists
				if ( timeoutTimer ) {
					clearTimeout( timeoutTimer );
				}

				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;

				// Cache response headers
				responseHeadersString = headers || "";

				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;

				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;

				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}

				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );

				// If successful, handle type chaining
				if ( isSuccess ) {

					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader("Last-Modified");
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader("etag");
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}

					// if no content
					if ( status === 204 || s.type === "HEAD" ) {
						statusText = "nocontent";

					// if not modified
					} else if ( status === 304 ) {
						statusText = "notmodified";

					// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {
					// We extract error from statusText
					// then normalize statusText and status for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}

				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";

				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}

				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;

				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}

				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger("ajaxStop");
					}
				}
			}

			return jqXHR;
		},

		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		},

		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		}
	});

	jQuery.each( [ "get", "post" ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {
			// shift arguments if data argument was omitted
			if ( jQuery.isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}

			return jQuery.ajax({
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			});
		};
	});

	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
		jQuery.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	});


	jQuery._evalUrl = function( url ) {
		return jQuery.ajax({
			url: url,
			type: "GET",
			dataType: "script",
			async: false,
			global: false,
			"throws": true
		});
	};


	jQuery.fn.extend({
		wrapAll: function( html ) {
			var wrap;

			if ( jQuery.isFunction( html ) ) {
				return this.each(function( i ) {
					jQuery( this ).wrapAll( html.call(this, i) );
				});
			}

			if ( this[ 0 ] ) {

				// The elements to wrap the target around
				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}

				wrap.map(function() {
					var elem = this;

					while ( elem.firstElementChild ) {
						elem = elem.firstElementChild;
					}

					return elem;
				}).append( this );
			}

			return this;
		},

		wrapInner: function( html ) {
			if ( jQuery.isFunction( html ) ) {
				return this.each(function( i ) {
					jQuery( this ).wrapInner( html.call(this, i) );
				});
			}

			return this.each(function() {
				var self = jQuery( this ),
					contents = self.contents();

				if ( contents.length ) {
					contents.wrapAll( html );

				} else {
					self.append( html );
				}
			});
		},

		wrap: function( html ) {
			var isFunction = jQuery.isFunction( html );

			return this.each(function( i ) {
				jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
			});
		},

		unwrap: function() {
			return this.parent().each(function() {
				if ( !jQuery.nodeName( this, "body" ) ) {
					jQuery( this ).replaceWith( this.childNodes );
				}
			}).end();
		}
	});


	jQuery.expr.filters.hidden = function( elem ) {
		// Support: Opera <= 12.12
		// Opera reports offsetWidths and offsetHeights less than zero on some elements
		return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
	};
	jQuery.expr.filters.visible = function( elem ) {
		return !jQuery.expr.filters.hidden( elem );
	};




	var r20 = /%20/g,
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;

	function buildParams( prefix, obj, traditional, add ) {
		var name;

		if ( jQuery.isArray( obj ) ) {
			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {
					// Treat each array item as a scalar.
					add( prefix, v );

				} else {
					// Item is non-scalar (array or object), encode its numeric index.
					buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
				}
			});

		} else if ( !traditional && jQuery.type( obj ) === "object" ) {
			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}

		} else {
			// Serialize scalar item.
			add( prefix, obj );
		}
	}

	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, value ) {
				// If value is a function, invoke it and return its value
				value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
			};

		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if ( traditional === undefined ) {
			traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
		}

		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			});

		} else {
			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" ).replace( r20, "+" );
	};

	jQuery.fn.extend({
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map(function() {
				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			})
			.filter(function() {
				var type = this.type;

				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !rcheckableType.test( type ) );
			})
			.map(function( i, elem ) {
				var val = jQuery( this ).val();

				return val == null ?
					null :
					jQuery.isArray( val ) ?
						jQuery.map( val, function( val ) {
							return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
						}) :
						{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			}).get();
		}
	});


	jQuery.ajaxSettings.xhr = function() {
		try {
			return new XMLHttpRequest();
		} catch( e ) {}
	};

	var xhrId = 0,
		xhrCallbacks = {},
		xhrSuccessStatus = {
			// file protocol always yields status code 0, assume 200
			0: 200,
			// Support: IE9
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported = jQuery.ajaxSettings.xhr();

	// Support: IE9
	// Open requests must be manually aborted on unload (#5280)
	if ( window.ActiveXObject ) {
		jQuery( window ).on( "unload", function() {
			for ( var key in xhrCallbacks ) {
				xhrCallbacks[ key ]();
			}
		});
	}

	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	support.ajax = xhrSupported = !!xhrSupported;

	jQuery.ajaxTransport(function( options ) {
		var callback;

		// Cross domain only allowed if supported through XMLHttpRequest
		if ( support.cors || xhrSupported && !options.crossDomain ) {
			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr(),
						id = ++xhrId;

					xhr.open( options.type, options.url, options.async, options.username, options.password );

					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers["X-Requested-With"] ) {
						headers["X-Requested-With"] = "XMLHttpRequest";
					}

					// Set headers
					for ( i in headers ) {
						xhr.setRequestHeader( i, headers[ i ] );
					}

					// Callback
					callback = function( type ) {
						return function() {
							if ( callback ) {
								delete xhrCallbacks[ id ];
								callback = xhr.onload = xhr.onerror = null;

								if ( type === "abort" ) {
									xhr.abort();
								} else if ( type === "error" ) {
									complete(
										// file: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								} else {
									complete(
										xhrSuccessStatus[ xhr.status ] || xhr.status,
										xhr.statusText,
										// Support: IE9
										// Accessing binary-data responseText throws an exception
										// (#11426)
										typeof xhr.responseText === "string" ? {
											text: xhr.responseText
										} : undefined,
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};

					// Listen to events
					xhr.onload = callback();
					xhr.onerror = callback("error");

					// Create the abort callback
					callback = xhrCallbacks[ id ] = callback("abort");

					try {
						// Do send the request (this may raise an exception)
						xhr.send( options.hasContent && options.data || null );
					} catch ( e ) {
						// #14683: Only rethrow if this hasn't been notified as an error yet
						if ( callback ) {
							throw e;
						}
					}
				},

				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	});




	// Install script dataType
	jQuery.ajaxSetup({
		accepts: {
			script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /(?:java|ecma)script/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	});

	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
		}
	});

	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function( s ) {
		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script = jQuery("<script>").prop({
						async: true,
						charset: s.scriptCharset,
						src: s.url
					}).on(
						"load error",
						callback = function( evt ) {
							script.remove();
							callback = null;
							if ( evt ) {
								complete( evt.type === "error" ? 404 : 200, evt.type );
							}
						}
					);
					document.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	});




	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;

	// Default jsonp settings
	jQuery.ajaxSetup({
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	});

	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
			);

		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;

			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}

			// Use data converter to retrieve json after script execution
			s.converters["script json"] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};

			// force json dataType
			s.dataTypes[ 0 ] = "json";

			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};

			// Clean-up function (fires after converters)
			jqXHR.always(function() {
				// Restore preexisting value
				window[ callbackName ] = overwritten;

				// Save back as free
				if ( s[ callbackName ] ) {
					// make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;

					// save the callback name for future use
					oldCallbacks.push( callbackName );
				}

				// Call if it was a function and we have a response
				if ( responseContainer && jQuery.isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}

				responseContainer = overwritten = undefined;
			});

			// Delegate to script
			return "script";
		}
	});




	// data: string of html
	// context (optional): If specified, the fragment will be created in this context, defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function( data, context, keepScripts ) {
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}
		context = context || document;

		var parsed = rsingleTag.exec( data ),
			scripts = !keepScripts && [];

		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[1] ) ];
		}

		parsed = jQuery.buildFragment( [ data ], context, scripts );

		if ( scripts && scripts.length ) {
			jQuery( scripts ).remove();
		}

		return jQuery.merge( [], parsed.childNodes );
	};


	// Keep a copy of the old load method
	var _load = jQuery.fn.load;

	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function( url, params, callback ) {
		if ( typeof url !== "string" && _load ) {
			return _load.apply( this, arguments );
		}

		var selector, type, response,
			self = this,
			off = url.indexOf(" ");

		if ( off >= 0 ) {
			selector = jQuery.trim( url.slice( off ) );
			url = url.slice( 0, off );
		}

		// If it's a function
		if ( jQuery.isFunction( params ) ) {

			// We assume that it's the callback
			callback = params;
			params = undefined;

		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}

		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax({
				url: url,

				// if "type" variable is undefined, then "GET" method will be used
				type: type,
				dataType: "html",
				data: params
			}).done(function( responseText ) {

				// Save response for use in complete callback
				response = arguments;

				self.html( selector ?

					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

					// Otherwise use the full result
					responseText );

			}).complete( callback && function( jqXHR, status ) {
				self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
			});
		}

		return this;
	};




	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function( fn ) {
			return elem === fn.elem;
		}).length;
	};




	var docElem = window.document.documentElement;

	/**
	 * Gets a window from an element
	 */
	function getWindow( elem ) {
		return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
	}

	jQuery.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css( elem, "position" ),
				curElem = jQuery( elem ),
				props = {};

			// Set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}

			curOffset = curElem.offset();
			curCSSTop = jQuery.css( elem, "top" );
			curCSSLeft = jQuery.css( elem, "left" );
			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
				( curCSSTop + curCSSLeft ).indexOf("auto") > -1;

			// Need to be able to calculate position if either top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;

			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}

			if ( jQuery.isFunction( options ) ) {
				options = options.call( elem, i, curOffset );
			}

			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}

			if ( "using" in options ) {
				options.using.call( elem, props );

			} else {
				curElem.css( props );
			}
		}
	};

	jQuery.fn.extend({
		offset: function( options ) {
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each(function( i ) {
						jQuery.offset.setOffset( this, options, i );
					});
			}

			var docElem, win,
				elem = this[ 0 ],
				box = { top: 0, left: 0 },
				doc = elem && elem.ownerDocument;

			if ( !doc ) {
				return;
			}

			docElem = doc.documentElement;

			// Make sure it's not a disconnected DOM node
			if ( !jQuery.contains( docElem, elem ) ) {
				return box;
			}

			// If we don't have gBCR, just use 0,0 rather than error
			// BlackBerry 5, iOS 3 (original iPhone)
			if ( typeof elem.getBoundingClientRect !== strundefined ) {
				box = elem.getBoundingClientRect();
			}
			win = getWindow( doc );
			return {
				top: box.top + win.pageYOffset - docElem.clientTop,
				left: box.left + win.pageXOffset - docElem.clientLeft
			};
		},

		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}

			var offsetParent, offset,
				elem = this[ 0 ],
				parentOffset = { top: 0, left: 0 };

			// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
			if ( jQuery.css( elem, "position" ) === "fixed" ) {
				// We assume that getBoundingClientRect is available when computed position is fixed
				offset = elem.getBoundingClientRect();

			} else {
				// Get *real* offsetParent
				offsetParent = this.offsetParent();

				// Get correct offsets
				offset = this.offset();
				if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
					parentOffset = offsetParent.offset();
				}

				// Add offsetParent borders
				parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
			}

			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
			};
		},

		offsetParent: function() {
			return this.map(function() {
				var offsetParent = this.offsetParent || docElem;

				while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
					offsetParent = offsetParent.offsetParent;
				}

				return offsetParent || docElem;
			});
		}
	});

	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
		var top = "pageYOffset" === prop;

		jQuery.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {
				var win = getWindow( elem );

				if ( val === undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}

				if ( win ) {
					win.scrollTo(
						!top ? val : window.pageXOffset,
						top ? val : window.pageYOffset
					);

				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length, null );
		};
	});

	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// getComputedStyle returns percent when specified for top/left/bottom/right
	// rather than make the css module depend on the offset module, we just check for it here
	jQuery.each( [ "top", "left" ], function( i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );
					// if curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + "px" :
						computed;
				}
			}
		);
	});


	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
			// margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

				return access( this, function( elem, type, value ) {
					var doc;

					if ( jQuery.isWindow( elem ) ) {
						// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
						// isn't a whole lot we can do. See pull request at this URL for discussion:
						// https://github.com/jquery/jquery/pull/764
						return elem.document.documentElement[ "client" + name ];
					}

					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;

						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}

					return value === undefined ?
						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :

						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable, null );
			};
		});
	});


	// The number of elements contained in the matched element set
	jQuery.fn.size = function() {
		return this.length;
	};

	jQuery.fn.andSelf = jQuery.fn.addBack;




	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.

	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}




	var
		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,

		// Map over the $ in case of overwrite
		_$ = window.$;

	jQuery.noConflict = function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	};

	// Expose jQuery and $ identifiers, even in
	// AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( typeof noGlobal === strundefined ) {
		window.jQuery = window.$ = jQuery;
	}




	return jQuery;

	}));


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	module.exports={"v":1,"t":[{"t":7,"e":"div","a":{"class":"header row coloured"},"t1":"fade","f":[{"t":7,"e":"div","a":{"class":"central-menu"},"f":[{"t":7,"e":"h1","f":["Welcome to WebABC"]},{"t":7,"e":"small","f":["Version 0.0.1"]}]}," "]}," ",{"t":7,"e":"div","a":{"class":"row editor"},"f":[{"t":7,"e":"div","a":{"class":"column quarter right-divide"},"t1":{"n":"fade","a":[{"delay":100}]},"f":[{"t":7,"e":"div","a":{"class":"text-area-padding"},"f":[{"t":7,"e":"h3","f":["Recent Tunes"]}," ",{"t":7,"e":"div","a":{"id":"search-box"},"f":[{"t":7,"e":"i","a":{"class":"fa fa-search"}}," ",{"t":7,"e":"input","v":{"change":"updated_search"},"a":{"type":"text","value":[{"t":2,"r":"search_filter"}]}}]}," ",{"t":7,"e":"ul","a":{"class":"item-list"},"f":[{"t":4,"n":52,"x":{"r":["filterTuneNames","tuneNames","search_filter"],"s":"_0(_1,_2)"},"f":[{"t":7,"e":"li","v":{"click":"new_tune"},"f":[{"t":2,"r":"name"},{"t":7,"e":"br"},{"t":7,"e":"small","f":["12/09/2014 - Reel - Gm"]}]}]}]}]}]}," ",{"t":7,"e":"div","a":{"class":"column three-quarters","id":"task-pane"},"t1":{"n":"fade","a":[{"delay":200}]},"f":[{"t":7,"e":"div","a":{"class":"tile-button-container"},"f":[{"t":7,"e":"div","a":{"class":"tile-button"},"v":{"click":"new_tune"},"f":[{"t":7,"e":"h4","f":["+ New Tune"]}]}]}]}]}]};

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	module.exports={"v":1,"t":[{"t":7,"e":"div","a":{"class":"header row"},"t1":"fade","f":[{"t":7,"e":"div","a":{"class":"back-button"},"v":{"click":"navigate_back"},"f":[{"t":7,"e":"p","f":[{"t":7,"e":"i","a":{"class":"fa fa-arrow-left"}}]}]}," ",{"t":7,"e":"div","a":{"class":"central-menu"},"f":[{"t":7,"e":"h3","a":{"class":"tune-title"},"f":[{"t":2,"r":"title"}]}," ",{"t":7,"e":"br"}," ",{"t":7,"e":"div","a":{"class":"flat-button"},"f":[{"t":7,"e":"p","f":["File"]}]}," ",{"t":7,"e":"div","a":{"class":"flat-button"},"f":[{"t":7,"e":"p","f":["Edit"]}]}]}," ",{"t":7,"e":"div","a":{"class":"user-box"},"f":[{"t":4,"n":50,"x":{"r":["loggedIn"],"s":"_0===false"},"f":[{"t":7,"e":"a","a":{"href":"/auth/google","class":"google-button"},"f":[{"t":7,"e":"span","a":{"class":"fa fa-google-plus"}}," Google"]}]},{"t":4,"n":51,"f":[{"t":7,"e":"span","f":["Hi ",{"t":2,"r":"user.name.givenName"}]}," ",{"t":7,"e":"a","a":{"href":"/logout"},"f":["Log out"]}],"x":{"r":["loggedIn"],"s":"_0===false"}}]}]}," ",{"t":7,"e":"div","a":{"class":"row toolbar"},"f":[]}," ",{"t":7,"e":"div","a":{"class":"row editor"},"t1":"fade","f":[{"t":7,"e":"div","a":{"class":"column third","id":"abc-container"},"f":[{"t":7,"e":"textarea","a":{"id":"abc","value":[{"t":2,"r":"inputValue"}],"placeholder":"Start typing a tune..","spellcheck":"false"},"v":{"keyup":"editor_keyup","mouseup":"editor_mouseup","paste":"editor_paste"}}]}," ",{"t":7,"e":"div","a":{"class":"column two-thirds"},"f":[{"t":7,"e":"svg","a":{"id":"canvas"}}]}]}]};

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';  

	var
	 lexer = __webpack_require__(15),
	 data_tables = __webpack_require__(16),
	 _ = __webpack_require__(14);
	          
	    
	    var cache = {};
	    var drawableIndex = 0;
	    
	    function ParserException(message) {
	        this.message = message;
	        this.name = "ParserException";
	    }
	    
	    function lex(string) {
	        if(cache[string] !== undefined)return cache[string];
	        var lexed = lexer.collect(string);
	        cache[string] = lexed;
	        return lexed;
	    }
	    
	    var decorationstack = [];
	    
	    function parseNote(lexer) {
	        var newNote = {
	            type: "note",
	            type_class: "drawable"
	        };
	        
	        while(lexer[0] && lexer[0].subType === "decoration") {
	            lexer.shift();
	        }
	        
	        if(lexer[0].subType == "accidental") {
	            newNote.accidental = lexer.shift().data;
	        }
	        
	        if(!lexer[0] || lexer[0].subType !== "letter"){
	            lexer.shift();
	            return new ParserException("Missing note name");
	        }
	        
	        if(lexer[0] && lexer[0].subType == "letter") {
	            newNote.note = lexer.shift().data;
	        }
	        
	        if(lexer[0] && lexer[0].subType == "pitch") {
	            newNote.octave = lexer.shift().data;
	        }
	        
	        if(lexer[0] && lexer[0].subType == "length") {
	            newNote.notelength = lexer.shift().data;
	        }
	        
	        return newNote;
	    }
	    
	    function parseRest(lexer) {
	        var newRest = {};
	        
	        newRest.type_class = lexer[0].subType === "visible" ? "drawable" : "hidden";
	        newRest.type = lexer[0].data === "short" ? "beat_rest" : "bar_rest";
	        
	        lexer.shift();
	        
	        if(lexer[0] && lexer[0].subType == "length") {
	            newRest.notelength = lexer.shift().data;
	        }
	        
	        return newRest;
	    }
	    
	    function noteGroup(parsed, lexed, name, start, stop) {
	        if(lexed[0].type === start) {
	            lexed.shift();
	                        
	            var groupNotes = [];
	                        
	            while(lexed.length > 0 && lexed[0].type != stop) {
	                if(lexed[0].type === "note") {
	                    groupNotes.push(parseNote(lexed));
	                    continue;
	                } else {
	                    /*throw new*/ groupNotes.push(new ParserException("Only notes are allowed in " + name + "s"));
	                    lexed.shift();
	                    continue;
	                }
	            }
	                        
	            parsed.push({
	                type: name,
	                type_class: "drawable",
	                notes: groupNotes
	            });
	                        
	            lexed.shift();
	            return true;
	        }
	        
	        if(lexed[0].type === stop) {
	            parsed.push(new ParserException("Closing " + name + " found before starting it"));
	            lexed.shift();
	            return true;
	        }
	        
	        return false;
	    }
	    
	    function parse(lexed) {
	        
	        var parsed = [];
	        
	        while(lexed.length > 0) {
	            if(lexed[0].type === "err") {
	                /*throw new*/parsed.push(new ParserException("Unrecognised sequence: " + lexed[0].data));
	                lexed.shift();
	                continue;
	            }
	                    
	            if(lexed[0].type_class === "data") {
	                lexed.shift();
	                continue;
	            }
	            
	            if(lexed[0].type === "beam") {
	                lexed.shift();
	                continue;
	            }
	            
	            if(lexed[0].type === "chord_annotation") {
	                parsed.push({
	                    type_class: "drawable",
	                    type: "chord_annotation",
	                    text: lexed[0].data
	                });
	                lexed.shift();
	                continue;
	            }            
	            
	            if(lexed[0].type === "note") {
	                parsed.push(parseNote(lexed));
	                continue;
	            }
	            
	            if(lexed[0].type === "rest") {
	                parsed.push(parseRest(lexed));
	                continue;
	            }
	            
	            if(lexed[0].type === "space") {
	                parsed.push({
	                    type: "space",
	                    type_class: "hidden"
	                });
	                lexed.shift();
	                continue;
	            }
	                    
	            if(noteGroup(parsed, lexed, "chord", "chord_start", "chord_stop"))continue;
	            if(noteGroup(parsed, lexed, "slur", "slur_start", "slur_stop"))continue;
	            if(noteGroup(parsed, lexed, "grace", "grace_start", "grace_stop"))continue;                    
	               
	            if(lexed[0].type === "barline") {
	                lexed.shift();
	                parsed.push({
	                    type: "barline",
	                    type_class: "drawable"                                    
	                });
	                continue;
	            }
	        }
	        
	        return parsed;
	    }
	    
	    module.exports = function(line) {        
	        
	        if(line.action !== "move") {           
	                
	            var lexed = lex(line.raw);
	            
	            console.log("DEBUG-LEXED:", lexed);
	            
	            if(lexed.length > 0) {    
	                line.parsed = parse(lexed); 
	            }
	        }
	           
	        console.log("DEBUG-PARSED:", line.parsed);
	        return line;       
	    } 

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var
	    _ = __webpack_require__(14),
	    svg = __webpack_require__(24),
	    randomColor = __webpack_require__(21);

	var
	    draw,
	    scoreLines,
	    data = {},
	    lineHeight = 25;

	var arrangeGroups = function() {
	    var offset = 0;

	    if (data.title != null) offset = 4;

	    for (var i = 0; i < scoreLines.length; i++) {
	        if (scoreLines[i] === undefined) continue;

	        if (scoreLines[i] != 0) {
	            scoreLines[i].move(0, lineHeight * offset);
	            offset += 1;
	        }
	    }
	}

	var symbolHandler = {
	    "drawable": function(a) {

	        if (scoreLines[a.i] === undefined) {
	            scoreLines[a.i] = draw.group();
	        } else {
	            scoreLines.splice(a.i, 0, draw.group());
	        }

	        for (var j = 0, totalOffset = 0; j < a.parsed.length; j++)
	            totalOffset += drawingFunctions[a.parsed[j].type](scoreLines[a.i], a, j, totalOffset);

	    },
	    "data": function(a) {

	        scoreLines[a.i] = 0;

	        if (informationFieldFunctions[a.parsed[0].type] === undefined) {
	            console.log("NOT YET IMPLEMENTED");
	            return;
	        }

	        informationFieldFunctions[a.parsed[0].type](a);
	    }
	};

	var deleteSymbolHandler = {
	    "drawable": function(a) {
	        if (scoreLines[a.i]) scoreLines[a.i].remove();
	        scoreLines[a.i] = undefined;
	    },
	    "data": function(a) {

	        scoreLines[a.i] = undefined;

	        if (informationFieldFunctions[a.parsed[0].type] === undefined) {
	            console.log("NOT YET IMPLEMENTED");
	            return;
	        }

	        delInformationFieldFunctions[a.parsed[0].type](a);
	    }
	};

	var actionHandler = {
	    "add": function(a) {
	        symbolHandler[a.type_class](a);
	        console.log("ADD", scoreLines);
	    },
	    "del": function(a) {
	        deleteSymbolHandler[a.type_class](a);
	        console.log("DEL", scoreLines);
	    },
	    "move": function(a) {
	        if (a.i < a.j) {
	            scoreLines[a.i] = scoreLines[a.j];
	            scoreLines[a.j] = undefined;
	        }
	        console.log("MOV", scoreLines);
	    },
	    "endofinput": _.noop
	}

	var drawingFunctions = {
	    "note": function(line, a, j, totalOffset) {
	        line.rect(a.parsed[j].notelength * 20, 20).attr({
	            fill: a.error ? '#F00' : randomColor({
	                luminosity: 'dark'
	            })
	        }).move(totalOffset, 0);
	        return a.parsed[j].notelength * 20 + 5;
	    },
	    "barline": function(line, a, j, totalOffset) {
	        line.circle(20).attr({
	            fill: "#CCC"
	        }).move(totalOffset, 0);
	        return 25;
	    },
	    "space": function() {
	        return 25;
	    }
	};

	var informationFieldFunctions = {
	    "title": function(a) {
	        if (data.title) data.title.remove();
	        data.title = draw.text(a.parsed[0].data).font({
	            family: 'Georgia',
	            size: 32,
	            anchor: 'middle',
	            leading: '1.5em'
	        }).move(400, 0);
	    },
	    "rhythm": function(a) {
	        if (data.rhythm) data.rhythm.remove();
	        data.rhythm = draw.text(a.parsed[0].data).font({
	            family: 'Georgia',
	            size: 16,
	            anchor: 'middle',
	            leading: '1.5em'
	        }).move(20, 60);
	    }
	}

	var delInformationFieldFunctions = {
	    "title": function(a) {
	        data.title.remove();
	        data.title = null;
	    },
	    "rhythm": function(a) {
	        data.rhythm.remove();
	        data.rhythm = null;
	    }
	}

	//exported functions
	module.exports = {
	    initialize: function(canvasSelector) {
	        draw = svg('canvas');
	        scoreLines = [];
	    },

	    onNext: function(a) {
	        //actionHandler[a.action](a);
	        //arrangeGroups();
	        //scoreLines = scoreLines.slice(0, a.newLength);
	        return a;
	    }

	};



/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	
	    Rx = __webpack_require__(19);

	    'use strict';
	    
	    //create RxObserveables from ractive observe
	    Rx.Observable.fromRactive = function(ractive, name) {
	        return Rx.Observable.create(function(observer) {
	            ractive.observe(name, function(newValue, oldValue) {
	                observer.onNext({ newValue: newValue, oldValue: oldValue});
	            });
	        });       
	    }
	    
	    //create RxObserveables from lexer
	    Rx.Observable.fromJsLex = function(lexer, inputValue) {
	        return Rx.Observable.create(function(observer) {
	            lexer.lex(inputValue, function(a) { observer.onNext(a); });
	        });       
	    }    
	    module.exports = Rx;


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/*

		ractive-adaptors-rxjs
		======================

		Version 0.1.0.

		RxJS adaptor for Ractive

		==========================

		Troubleshooting: If you're using a module system in your app (AMD or
		something more nodey) then you may need to change the paths below,
		where it says `require( 'ractive' )` or `define([ 'ractive' ]...)`.

		==========================

		Usage: Include this file on your page below Ractive, e.g:

		    <script src='lib/ractive.js'></script>
		    <script src='lib/rxjs.js'></script>
		    <script src='lib/ractive-adaptors-rxjs.js'></script>

		Or, if you're using a module loader, require this module:

		    // requiring the plugin will 'activate' it - no need to use
		    // the return value
		    require( 'ractive-adaptors-rxjs' );

		Then, tell Ractive to use the `RxJS` adaptor:

			ractive = new Ractive({
				el: 'body',
				template: myTemplate,
				adapt: 'RxJS',
				data: {
					foo: someReactiveProperty
				}
			});

	*/

	(function ( global, factory ) {

		factory( __webpack_require__( 13), __webpack_require__(19) );
		

	}( typeof window !== 'undefined' ? window : this, function ( Ractive, Rx ) {

		'use strict';

		var RxWrapper = function ( ractive, observable, keypath ) {
			var self = this;

			this.ractive = ractive;
			this.value = observable;
			this.keypath = keypath;

			this.dispose = observable.subscribe( function ( value ) {
				if ( self.updating ) {
					return;
				}

				self._value = value;

				self.updating = true;
				ractive.set( keypath, value );
				self.updating = false;
			});
		};

		RxWrapper.prototype = {
			get: function () {
				return this._value;
			},
			teardown: function () {
				this.dispose();
			},
			reset: function ( value ) {
				if ( this.updating ) {
					return;
				}

				if ( value instanceof Rx.Observable ) {
					return false;
				}

				this.updating = true;
				// TODO how do you set the value of a Rx.Observable?!
				this.updating = false;
			}
		};

		Ractive.adaptors.RxJS = {
			filter: function ( object ) {
				return object instanceof Rx.Observable;
			},
			wrap: function ( ractive, observable, keypath ) {
				return new RxWrapper( ractive, observable, keypath );
			}
		};

	}));

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*

		ractive-transitions-fade
		========================

		Version 0.1.2.

		This plugin does exactly what it says on the tin - it fades elements
		in and out, using CSS transitions. You can control the following
		properties: `duration`, `delay` and `easing` (which must be a valid
		CSS transition timing function, and defaults to `linear`).

		The `duration` property is in milliseconds, and defaults to 300 (you
		can also use `fast` or `slow` instead of a millisecond value, which
		equate to 200 and 600 respectively). As a shorthand, you can use
		`intro='fade:500'` instead of `intro='fade:{"duration":500}'` - this
		applies to many other transition plugins as well.

		If an element has an opacity other than 1 (whether directly, because
		of an inline style, or indirectly because of a CSS rule), it will be
		respected. You can override the target opacity of an intro fade by
		specifying a `to` property between 0 and 1.

		==========================

		Troubleshooting: If you're using a module system in your app (AMD or
		something more nodey) then you may need to change the paths below,
		where it says `require( 'Ractive' )` or `define([ 'Ractive' ]...)`.

		==========================

		Usage: Include this file on your page below Ractive, e.g:

		    <script src='lib/ractive.js'></script>
		    <script src='lib/ractive-transitions-fade.js'></script>

		Or, if you're using a module loader, require this module:

		    // requiring the plugin will 'activate' it - no need to use
		    // the return value
		    require( 'ractive-transitions-fade' );

		Add a fade transition like so:

		    <div intro='fade'>this will fade in</div>

	*/

	(function ( global, factory ) {

		'use strict';

		// Common JS (i.e. browserify) environment
		if ( typeof module !== 'undefined' && module.exports && "function" === 'function' ) {
			factory( __webpack_require__( 13 ) );
		}

		// AMD?
		else if ( true ) {
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(13) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}

		// browser global
		else if ( global.Ractive ) {
			factory( global.Ractive );
		}

		else {
			throw new Error( 'Could not find Ractive! It must be loaded before the ractive-transitions-fade plugin' );
		}

	}( typeof window !== 'undefined' ? window : this, function ( Ractive ) {

		'use strict';

		var fade, defaults;

		defaults = {
			delay: 0,
			duration: 300,
			easing: 'linear'
		};

		fade = function ( t, params ) {
			var targetOpacity;

			params = t.processParams( params, defaults );

			if ( t.isIntro ) {
				targetOpacity = t.getStyle( 'opacity' );
				t.setStyle( 'opacity', 0 );
			} else {
				targetOpacity = 0;
			}

			t.animateStyle( 'opacity', targetOpacity, params ).then( t.complete );
		};

		Ractive.transitions.fade = fade;

	}));

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*

		ractive-transitions-fly
		=======================

		Version 0.1.3.

		This transition uses CSS transforms to 'fly' elements to their
		natural location on the page, fading in from transparent as they go.
		By default, they will fly in from left.

		==========================

		Troubleshooting: If you're using a module system in your app (AMD or
		something more nodey) then you may need to change the paths below,
		where it says `require( 'ractive' )` or `define([ 'ractive' ]...)`.

		==========================

		Usage: Include this file on your page below Ractive, e.g:

		    <script src='lib/ractive.js'></script>
		    <script src='lib/ractive-transitions-fly.js'></script>

		Or, if you're using a module loader, require this module:

		    // requiring the plugin will 'activate' it - no need to use
		    // the return value
		    require( 'ractive-transitions-fly' );

		You can adjust the following parameters: `x`, `y`, `duration`,
		`delay` and `easing`.

	*/

	(function ( global, factory ) {

		'use strict';

		// Common JS (i.e. browserify) environment
		if ( typeof module !== 'undefined' && module.exports && "function" === 'function' ) {
			factory( __webpack_require__( 13 ) );
		}

		// AMD?
		else if ( true ) {
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(13) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}

		// browser global
		else if ( global.Ractive ) {
			factory( global.Ractive );
		}

		else {
			throw new Error( 'Could not find Ractive! It must be loaded before the ractive-transitions-fly plugin' );
		}

	}( typeof window !== 'undefined' ? window : this, function ( Ractive ) {

		'use strict';

		var fly, addPx, defaults;

		defaults = {
			duration: 400,
			easing: 'easeOut',
			opacity: 0,
			x: -500,
			y: 0
		};

		addPx = function ( num ) {
			if ( num === 0 || typeof num === 'string' ) {
				return num;
			}

			return num + 'px';
		};

		fly = function ( t, params ) {
			var x, y, offscreen, target;

			params = t.processParams( params, defaults );

			x = addPx( params.x );
			y = addPx( params.y );

			offscreen = {
				transform: 'translate(' + x + ',' + y + ')',
				opacity: 0
			};

			if ( t.isIntro ) {
				// animate to the current style
				target = t.getStyle([ 'opacity', 'transform' ]);

				// set offscreen style
				t.setStyle( offscreen );
			} else {
				target = offscreen;
			}

			t.animateStyle( target, params ).then( t.complete );
		};

		Ractive.transitions.fly = fly;

	}));

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
		ractive.js v0.6.1
		2014-10-25 - commit 3a576eb3 

		http://ractivejs.org
		http://twitter.com/RactiveJS

		Released under the MIT License.
	*/

	( function( global ) {

		'use strict';

		var noConflict = global.Ractive;

		/* config/defaults/options.js */
		var options = function() {

			var defaultOptions = {
				// render placement:
				el: void 0,
				append: false,
				// template:
				template: {
					v: 1,
					t: []
				},
				yield: null,
				// parse:
				preserveWhitespace: false,
				sanitize: false,
				stripComments: true,
				// data & binding:
				data: {},
				computed: {},
				magic: false,
				modifyArrays: true,
				adapt: [],
				isolated: false,
				twoway: true,
				lazy: false,
				// transitions:
				noIntro: false,
				transitionsEnabled: true,
				complete: void 0,
				// css:
				noCssTransform: false,
				// debug:
				debug: false
			};
			return defaultOptions;
		}();

		/* config/defaults/easing.js */
		var easing = {
			linear: function( pos ) {
				return pos;
			},
			easeIn: function( pos ) {
				return Math.pow( pos, 3 );
			},
			easeOut: function( pos ) {
				return Math.pow( pos - 1, 3 ) + 1;
			},
			easeInOut: function( pos ) {
				if ( ( pos /= 0.5 ) < 1 ) {
					return 0.5 * Math.pow( pos, 3 );
				}
				return 0.5 * ( Math.pow( pos - 2, 3 ) + 2 );
			}
		};

		/* circular.js */
		var circular = [];

		/* utils/hasOwnProperty.js */
		var hasOwn = Object.prototype.hasOwnProperty;

		/* utils/isArray.js */
		var isArray = function() {

			var toString = Object.prototype.toString;
			// thanks, http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/
			return function( thing ) {
				return toString.call( thing ) === '[object Array]';
			};
		}();

		/* utils/isObject.js */
		var isObject = function() {

			var toString = Object.prototype.toString;
			return function( thing ) {
				return thing && toString.call( thing ) === '[object Object]';
			};
		}();

		/* utils/isNumeric.js */
		var isNumeric = function( thing ) {
			return !isNaN( parseFloat( thing ) ) && isFinite( thing );
		};

		/* config/defaults/interpolators.js */
		var interpolators = function( circular, hasOwnProperty, isArray, isObject, isNumeric ) {

			var interpolators, interpolate, cssLengthPattern;
			circular.push( function() {
				interpolate = circular.interpolate;
			} );
			cssLengthPattern = /^([+-]?[0-9]+\.?(?:[0-9]+)?)(px|em|ex|%|in|cm|mm|pt|pc)$/;
			interpolators = {
				number: function( from, to ) {
					var delta;
					if ( !isNumeric( from ) || !isNumeric( to ) ) {
						return null;
					}
					from = +from;
					to = +to;
					delta = to - from;
					if ( !delta ) {
						return function() {
							return from;
						};
					}
					return function( t ) {
						return from + t * delta;
					};
				},
				array: function( from, to ) {
					var intermediate, interpolators, len, i;
					if ( !isArray( from ) || !isArray( to ) ) {
						return null;
					}
					intermediate = [];
					interpolators = [];
					i = len = Math.min( from.length, to.length );
					while ( i-- ) {
						interpolators[ i ] = interpolate( from[ i ], to[ i ] );
					}
					// surplus values - don't interpolate, but don't exclude them either
					for ( i = len; i < from.length; i += 1 ) {
						intermediate[ i ] = from[ i ];
					}
					for ( i = len; i < to.length; i += 1 ) {
						intermediate[ i ] = to[ i ];
					}
					return function( t ) {
						var i = len;
						while ( i-- ) {
							intermediate[ i ] = interpolators[ i ]( t );
						}
						return intermediate;
					};
				},
				object: function( from, to ) {
					var properties, len, interpolators, intermediate, prop;
					if ( !isObject( from ) || !isObject( to ) ) {
						return null;
					}
					properties = [];
					intermediate = {};
					interpolators = {};
					for ( prop in from ) {
						if ( hasOwnProperty.call( from, prop ) ) {
							if ( hasOwnProperty.call( to, prop ) ) {
								properties.push( prop );
								interpolators[ prop ] = interpolate( from[ prop ], to[ prop ] );
							} else {
								intermediate[ prop ] = from[ prop ];
							}
						}
					}
					for ( prop in to ) {
						if ( hasOwnProperty.call( to, prop ) && !hasOwnProperty.call( from, prop ) ) {
							intermediate[ prop ] = to[ prop ];
						}
					}
					len = properties.length;
					return function( t ) {
						var i = len,
							prop;
						while ( i-- ) {
							prop = properties[ i ];
							intermediate[ prop ] = interpolators[ prop ]( t );
						}
						return intermediate;
					};
				}
			};
			return interpolators;
		}( circular, hasOwn, isArray, isObject, isNumeric );

		/* config/svg.js */
		var svg = function() {

			var svg;
			if ( typeof document === 'undefined' ) {
				svg = false;
			} else {
				svg = document && document.implementation.hasFeature( 'http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1' );
			}
			return svg;
		}();

		/* utils/warn.js */
		var warn = function() {

			/* global console */
			var warn, warned = {};
			if ( typeof console !== 'undefined' && typeof console.warn === 'function' && typeof console.warn.apply === 'function' ) {
				warn = function( message, allowDuplicates ) {
					if ( !allowDuplicates ) {
						if ( warned[ message ] ) {
							return;
						}
						warned[ message ] = true;
					}
					console.warn( '%cRactive.js: %c' + message, 'color: rgb(114, 157, 52);', 'color: rgb(85, 85, 85);' );
				};
			} else {
				warn = function() {};
			}
			return warn;
		}();

		/* config/errors.js */
		var errors = {
			missingParser: 'Missing Ractive.parse - cannot parse template. Either preparse or use the version that includes the parser',
			mergeComparisonFail: 'Merge operation: comparison failed. Falling back to identity checking',
			noComponentEventArguments: 'Components currently only support simple events - you cannot include arguments. Sorry!',
			noTemplateForPartial: 'Could not find template for partial "{name}"',
			noNestedPartials: 'Partials ({{>{name}}}) cannot contain nested inline partials',
			evaluationError: 'Error evaluating "{uniqueString}": {err}',
			badArguments: 'Bad arguments "{arguments}". I\'m not allowed to argue unless you\'ve paid.',
			failedComputation: 'Failed to compute "{key}": {err}',
			missingPlugin: 'Missing "{name}" {plugin} plugin. You may need to download a {plugin} via http://docs.ractivejs.org/latest/plugins#{plugin}s',
			badRadioInputBinding: 'A radio input can have two-way binding on its name attribute, or its checked attribute - not both',
			noRegistryFunctionReturn: 'A function was specified for "{name}" {registry}, but no {registry} was returned',
			defaultElSpecified: 'The <{name}/> component has a default `el` property; it has been disregarded',
			noElementProxyEventWildcards: 'Only component proxy-events may contain "*" wildcards, <{element} on-{event}/> is not valid.',
			methodDeprecated: 'The method "{deprecated}" has been deprecated in favor of "{replacement}" and will likely be removed in a future release. See http://docs.ractivejs.org/latest/migrating for more information.'
		};

		/* utils/log.js */
		var log = function( consolewarn, errors ) {

			var log = {
				warn: function( options, passthru ) {
					if ( !options.debug && !passthru ) {
						return;
					}
					this.warnAlways( options );
				},
				warnAlways: function( options ) {
					this.logger( getMessage( options ), options.allowDuplicates );
				},
				error: function( options ) {
					this.errorOnly( options );
					if ( !options.debug ) {
						this.warn( options, true );
					}
				},
				errorOnly: function( options ) {
					if ( options.debug ) {
						this.critical( options );
					}
				},
				critical: function( options ) {
					var err = options.err || new Error( getMessage( options ) );
					this.thrower( err );
				},
				logger: consolewarn,
				thrower: function( err ) {
					throw err;
				}
			};

			function getMessage( options ) {
				var message = errors[ options.message ] || options.message || '';
				return interpolate( message, options.args );
			}
			// simple interpolation. probably quicker (and better) out there,
			// but log is not in golden path of execution, only exceptions
			function interpolate( message, args ) {
				return message.replace( /{([^{}]*)}/g, function( a, b ) {
					return args[ b ];
				} );
			}
			return log;
		}( warn, errors );

		/* Ractive/prototype/shared/hooks/Hook.js */
		var Ractive$shared_hooks_Hook = function( log ) {

			var deprecations = {
				construct: {
					deprecated: 'beforeInit',
					replacement: 'onconstruct'
				},
				render: {
					deprecated: 'init',
					message: 'The "init" method has been deprecated ' + 'and will likely be removed in a future release. ' + 'You can either use the "oninit" method which will fire ' + 'only once prior to, and regardless of, any eventual ractive ' + 'instance being rendered, or if you need to access the ' + 'rendered DOM, use "onrender" instead. ' + 'See http://docs.ractivejs.org/latest/migrating for more information.'
				},
				complete: {
					deprecated: 'complete',
					replacement: 'oncomplete'
				}
			};

			function Hook( event ) {
				this.event = event;
				this.method = 'on' + event;
				this.deprecate = deprecations[ event ];
			}
			Hook.prototype.fire = function( ractive, arg ) {
				function call( method ) {
					if ( ractive[ method ] ) {
						arg ? ractive[ method ]( arg ) : ractive[ method ]();
						return true;
					}
				}
				call( this.method );
				if ( !ractive[ this.method ] && this.deprecate && call( this.deprecate.deprecated ) ) {
					log.warnAlways( {
						debug: ractive.debug,
						message: this.deprecate.message || 'methodDeprecated',
						args: this.deprecate
					} );
				}
				arg ? ractive.fire( this.event, arg ) : ractive.fire( this.event );
			};
			return Hook;
		}( log );

		/* utils/removeFromArray.js */
		var removeFromArray = function( array, member ) {
			var index = array.indexOf( member );
			if ( index !== -1 ) {
				array.splice( index, 1 );
			}
		};

		/* utils/Promise.js */
		var Promise = function() {

			var __export;
			var _Promise, PENDING = {},
				FULFILLED = {},
				REJECTED = {};
			if ( typeof Promise === 'function' ) {
				// use native Promise
				_Promise = Promise;
			} else {
				_Promise = function( callback ) {
					var fulfilledHandlers = [],
						rejectedHandlers = [],
						state = PENDING,
						result, dispatchHandlers, makeResolver, fulfil, reject, promise;
					makeResolver = function( newState ) {
						return function( value ) {
							if ( state !== PENDING ) {
								return;
							}
							result = value;
							state = newState;
							dispatchHandlers = makeDispatcher( state === FULFILLED ? fulfilledHandlers : rejectedHandlers, result );
							// dispatch onFulfilled and onRejected handlers asynchronously
							wait( dispatchHandlers );
						};
					};
					fulfil = makeResolver( FULFILLED );
					reject = makeResolver( REJECTED );
					try {
						callback( fulfil, reject );
					} catch ( err ) {
						reject( err );
					}
					promise = {
						// `then()` returns a Promise - 2.2.7
						then: function( onFulfilled, onRejected ) {
							var promise2 = new _Promise( function( fulfil, reject ) {
								var processResolutionHandler = function( handler, handlers, forward ) {
									// 2.2.1.1
									if ( typeof handler === 'function' ) {
										handlers.push( function( p1result ) {
											var x;
											try {
												x = handler( p1result );
												resolve( promise2, x, fulfil, reject );
											} catch ( err ) {
												reject( err );
											}
										} );
									} else {
										// Forward the result of promise1 to promise2, if resolution handlers
										// are not given
										handlers.push( forward );
									}
								};
								// 2.2
								processResolutionHandler( onFulfilled, fulfilledHandlers, fulfil );
								processResolutionHandler( onRejected, rejectedHandlers, reject );
								if ( state !== PENDING ) {
									// If the promise has resolved already, dispatch the appropriate handlers asynchronously
									wait( dispatchHandlers );
								}
							} );
							return promise2;
						}
					};
					promise[ 'catch' ] = function( onRejected ) {
						return this.then( null, onRejected );
					};
					return promise;
				};
				_Promise.all = function( promises ) {
					return new _Promise( function( fulfil, reject ) {
						var result = [],
							pending, i, processPromise;
						if ( !promises.length ) {
							fulfil( result );
							return;
						}
						processPromise = function( i ) {
							promises[ i ].then( function( value ) {
								result[ i ] = value;
								if ( !--pending ) {
									fulfil( result );
								}
							}, reject );
						};
						pending = i = promises.length;
						while ( i-- ) {
							processPromise( i );
						}
					} );
				};
				_Promise.resolve = function( value ) {
					return new _Promise( function( fulfil ) {
						fulfil( value );
					} );
				};
				_Promise.reject = function( reason ) {
					return new _Promise( function( fulfil, reject ) {
						reject( reason );
					} );
				};
			}
			__export = _Promise;
			// TODO use MutationObservers or something to simulate setImmediate
			function wait( callback ) {
				setTimeout( callback, 0 );
			}

			function makeDispatcher( handlers, result ) {
				return function() {
					var handler;
					while ( handler = handlers.shift() ) {
						handler( result );
					}
				};
			}

			function resolve( promise, x, fulfil, reject ) {
				// Promise Resolution Procedure
				var then;
				// 2.3.1
				if ( x === promise ) {
					throw new TypeError( 'A promise\'s fulfillment handler cannot return the same promise' );
				}
				// 2.3.2
				if ( x instanceof _Promise ) {
					x.then( fulfil, reject );
				} else if ( x && ( typeof x === 'object' || typeof x === 'function' ) ) {
					try {
						then = x.then;
					} catch ( e ) {
						reject( e );
						// 2.3.3.2
						return;
					}
					// 2.3.3.3
					if ( typeof then === 'function' ) {
						var called, resolvePromise, rejectPromise;
						resolvePromise = function( y ) {
							if ( called ) {
								return;
							}
							called = true;
							resolve( promise, y, fulfil, reject );
						};
						rejectPromise = function( r ) {
							if ( called ) {
								return;
							}
							called = true;
							reject( r );
						};
						try {
							then.call( x, resolvePromise, rejectPromise );
						} catch ( e ) {
							if ( !called ) {
								// 2.3.3.3.4.1
								reject( e );
								// 2.3.3.3.4.2
								called = true;
								return;
							}
						}
					} else {
						fulfil( x );
					}
				} else {
					fulfil( x );
				}
			}
			return __export;
		}();

		/* utils/normaliseRef.js */
		var normaliseRef = function() {

			var regex = /\[\s*(\*|[0-9]|[1-9][0-9]+)\s*\]/g;
			return function normaliseRef( ref ) {
				return ( ref || '' ).replace( regex, '.$1' );
			};
		}();

		/* shared/getInnerContext.js */
		var getInnerContext = function( fragment ) {
			do {
				if ( fragment.context !== undefined ) {
					return fragment.context;
				}
			} while ( fragment = fragment.parent );
			return '';
		};

		/* utils/isEqual.js */
		var isEqual = function( a, b ) {
			if ( a === null && b === null ) {
				return true;
			}
			if ( typeof a === 'object' || typeof b === 'object' ) {
				return false;
			}
			return a === b;
		};

		/* shared/createComponentBinding.js */
		var createComponentBinding = function( circular, isEqual ) {

			var runloop;
			circular.push( function() {
				return runloop = circular.runloop;
			} );
			var Binding = function( ractive, keypath, otherInstance, otherKeypath ) {
				var this$0 = this;
				this.root = ractive;
				this.keypath = keypath;
				this.otherInstance = otherInstance;
				this.otherKeypath = otherKeypath;
				this.lock = function() {
					return this$0.updating = true;
				};
				this.unlock = function() {
					return this$0.updating = false;
				};
				this.bind();
				this.value = this.root.viewmodel.get( this.keypath );
			};
			Binding.prototype = {
				isLocked: function() {
					return this.updating || this.counterpart && this.counterpart.updating;
				},
				shuffle: function( newIndices, value ) {
					this.propagateChange( value, newIndices );
				},
				setValue: function( value ) {
					this.propagateChange( value );
				},
				propagateChange: function( value, newIndices ) {
					var other;
					// Only *you* can prevent infinite loops
					if ( this.isLocked() ) {
						this.value = value;
						return;
					}
					if ( !isEqual( value, this.value ) ) {
						this.lock();
						// TODO maybe the case that `value === this.value` - should that result
						// in an update rather than a set?
						// if the other viewmodel is already locked up, need to do a deferred update
						if ( !runloop.addViewmodel( other = this.otherInstance.viewmodel ) && this.counterpart.value !== value ) {
							runloop.scheduleTask( function() {
								return runloop.addViewmodel( other );
							} );
						}
						if ( newIndices ) {
							other.smartUpdate( this.otherKeypath, value, newIndices );
						} else {
							if ( isSettable( other, this.otherKeypath ) ) {
								other.set( this.otherKeypath, value );
							}
						}
						this.value = value;
						// TODO will the counterpart update after this line, during
						// the runloop end cycle? may be a problem...
						runloop.scheduleTask( this.unlock );
					}
				},
				refineValue: function( keypaths ) {
					var this$0 = this;
					var other;
					if ( this.isLocked() ) {
						return;
					}
					this.lock();
					runloop.addViewmodel( other = this.otherInstance.viewmodel );
					keypaths.map( function( keypath ) {
						return this$0.otherKeypath + keypath.substr( this$0.keypath.length );
					} ).forEach( function( keypath ) {
						return other.mark( keypath );
					} );
					runloop.scheduleTask( this.unlock );
				},
				bind: function() {
					this.root.viewmodel.register( this.keypath, this );
				},
				rebind: function( newKeypath ) {
					this.unbind();
					this.keypath = newKeypath;
					this.counterpart.otherKeypath = newKeypath;
					this.bind();
				},
				unbind: function() {
					this.root.viewmodel.unregister( this.keypath, this );
				}
			};

			function isSettable( viewmodel, keypath ) {
				var computed = viewmodel.computations[ keypath ];
				return !computed || computed.setter;
			}
			return function createComponentBinding( component, parentInstance, parentKeypath, childKeypath ) {
				var hash, childInstance, bindings, parentToChildBinding, childToParentBinding;
				hash = parentKeypath + '=' + childKeypath;
				bindings = component.bindings;
				if ( bindings[ hash ] ) {
					// TODO does this ever happen?
					return;
				}
				childInstance = component.instance;
				parentToChildBinding = new Binding( parentInstance, parentKeypath, childInstance, childKeypath );
				bindings.push( parentToChildBinding );
				if ( childInstance.twoway ) {
					childToParentBinding = new Binding( childInstance, childKeypath, parentInstance, parentKeypath );
					bindings.push( childToParentBinding );
					parentToChildBinding.counterpart = childToParentBinding;
					childToParentBinding.counterpart = parentToChildBinding;
				}
				bindings[ hash ] = parentToChildBinding;
			};
		}( circular, isEqual );

		/* shared/resolveRef.js */
		var resolveRef = function( normaliseRef, getInnerContext, createComponentBinding ) {

			var __export;
			var ancestorErrorMessage, getOptions;
			ancestorErrorMessage = 'Could not resolve reference - too many "../" prefixes';
			getOptions = {
				evaluateWrapped: true
			};
			__export = function resolveRef( ractive, ref, fragment, isParentLookup ) {
				var context, key, index, keypath, parentValue, hasContextChain, parentKeys, childKeys, parentKeypath, childKeypath;
				ref = normaliseRef( ref );
				// If a reference begins '~/', it's a top-level reference
				if ( ref.substr( 0, 2 ) === '~/' ) {
					return ref.substring( 2 );
				}
				// If a reference begins with '.', it's either a restricted reference or
				// an ancestor reference...
				if ( ref.charAt( 0 ) === '.' ) {
					return resolveAncestorReference( getInnerContext( fragment ), ref );
				}
				// ...otherwise we need to find the keypath
				key = ref.split( '.' )[ 0 ];
				// get() in viewmodel creation means no fragment (yet)
				fragment = fragment || {};
				do {
					context = fragment.context;
					if ( !context ) {
						continue;
					}
					hasContextChain = true;
					parentValue = ractive.viewmodel.get( context, getOptions );
					if ( parentValue && ( typeof parentValue === 'object' || typeof parentValue === 'function' ) && key in parentValue ) {
						return context + '.' + ref;
					}
				} while ( fragment = fragment.parent );
				// Root/computed property?
				if ( key in ractive.data || key in ractive.viewmodel.computations ) {
					return ref;
				}
				// If this is an inline component, and it's not isolated, we
				// can try going up the scope chain
				if ( ractive._parent && !ractive.isolated ) {
					hasContextChain = true;
					fragment = ractive.component.parentFragment;
					// Special case - index refs
					if ( fragment.indexRefs && ( index = fragment.indexRefs[ ref ] ) !== undefined ) {
						// Create an index ref binding, so that it can be rebound letter if necessary.
						// It doesn't have an alias since it's an implicit binding, hence `...[ ref ] = ref`
						ractive.component.indexRefBindings[ ref ] = ref;
						ractive.viewmodel.set( ref, index, true );
						return;
					}
					keypath = resolveRef( ractive._parent, ref, fragment, true );
					if ( keypath ) {
						// We need to create an inter-component binding
						// If parent keypath is 'one.foo' and child is 'two.foo', we bind
						// 'one' to 'two' as it's more efficient and avoids edge cases
						parentKeys = keypath.split( '.' );
						childKeys = ref.split( '.' );
						while ( parentKeys.length > 1 && childKeys.length > 1 && parentKeys[ parentKeys.length - 1 ] === childKeys[ childKeys.length - 1 ] ) {
							parentKeys.pop();
							childKeys.pop();
						}
						parentKeypath = parentKeys.join( '.' );
						childKeypath = childKeys.join( '.' );
						ractive.viewmodel.set( childKeypath, ractive._parent.viewmodel.get( parentKeypath ), true );
						createComponentBinding( ractive.component, ractive._parent, parentKeypath, childKeypath );
						return ref;
					}
				}
				// If there's no context chain, and the instance is either a) isolated or
				// b) an orphan, then we know that the keypath is identical to the reference
				if ( !isParentLookup && !hasContextChain ) {
					// the data object needs to have a property by this name,
					// to prevent future failed lookups
					ractive.viewmodel.set( ref, undefined );
					return ref;
				}
				if ( ractive.viewmodel.get( ref ) !== undefined ) {
					return ref;
				}
			};

			function resolveAncestorReference( baseContext, ref ) {
				var contextKeys;
				// {{.}} means 'current context'
				if ( ref === '.' )
					return baseContext;
				contextKeys = baseContext ? baseContext.split( '.' ) : [];
				// ancestor references (starting "../") go up the tree
				if ( ref.substr( 0, 3 ) === '../' ) {
					while ( ref.substr( 0, 3 ) === '../' ) {
						if ( !contextKeys.length ) {
							throw new Error( ancestorErrorMessage );
						}
						contextKeys.pop();
						ref = ref.substring( 3 );
					}
					contextKeys.push( ref );
					return contextKeys.join( '.' );
				}
				// not an ancestor reference - must be a restricted reference (prepended with "." or "./")
				if ( !baseContext ) {
					return ref.replace( /^\.\/?/, '' );
				}
				return baseContext + ref.replace( /^\.\//, '.' );
			}
			return __export;
		}( normaliseRef, getInnerContext, createComponentBinding );

		/* global/TransitionManager.js */
		var TransitionManager = function( removeFromArray ) {

			var TransitionManager = function( callback, parent ) {
				this.callback = callback;
				this.parent = parent;
				this.intros = [];
				this.outros = [];
				this.children = [];
				this.totalChildren = this.outroChildren = 0;
				this.detachQueue = [];
				this.outrosComplete = false;
				if ( parent ) {
					parent.addChild( this );
				}
			};
			TransitionManager.prototype = {
				addChild: function( child ) {
					this.children.push( child );
					this.totalChildren += 1;
					this.outroChildren += 1;
				},
				decrementOutros: function() {
					this.outroChildren -= 1;
					check( this );
				},
				decrementTotal: function() {
					this.totalChildren -= 1;
					check( this );
				},
				add: function( transition ) {
					var list = transition.isIntro ? this.intros : this.outros;
					list.push( transition );
				},
				remove: function( transition ) {
					var list = transition.isIntro ? this.intros : this.outros;
					removeFromArray( list, transition );
					check( this );
				},
				init: function() {
					this.ready = true;
					check( this );
				},
				detachNodes: function() {
					this.detachQueue.forEach( detach );
					this.children.forEach( detachNodes );
				}
			};

			function detach( element ) {
				element.detach();
			}

			function detachNodes( tm ) {
				tm.detachNodes();
			}

			function check( tm ) {
				if ( !tm.ready || tm.outros.length || tm.outroChildren )
					return;
				// If all outros are complete, and we haven't already done this,
				// we notify the parent if there is one, otherwise
				// start detaching nodes
				if ( !tm.outrosComplete ) {
					if ( tm.parent ) {
						tm.parent.decrementOutros( tm );
					} else {
						tm.detachNodes();
					}
					tm.outrosComplete = true;
				}
				// Once everything is done, we can notify parent transition
				// manager and call the callback
				if ( !tm.intros.length && !tm.totalChildren ) {
					if ( typeof tm.callback === 'function' ) {
						tm.callback();
					}
					if ( tm.parent ) {
						tm.parent.decrementTotal();
					}
				}
			}
			return TransitionManager;
		}( removeFromArray );

		/* global/runloop.js */
		var runloop = function( circular, Hook, removeFromArray, Promise, resolveRef, TransitionManager ) {

			var __export;
			var batch, runloop, unresolved = [],
				changeHook = new Hook( 'change' );
			runloop = {
				start: function( instance, returnPromise ) {
					var promise, fulfilPromise;
					if ( returnPromise ) {
						promise = new Promise( function( f ) {
							return fulfilPromise = f;
						} );
					}
					batch = {
						previousBatch: batch,
						transitionManager: new TransitionManager( fulfilPromise, batch && batch.transitionManager ),
						views: [],
						tasks: [],
						viewmodels: [],
						instance: instance
					};
					if ( instance ) {
						batch.viewmodels.push( instance.viewmodel );
					}
					return promise;
				},
				end: function() {
					flushChanges();
					batch.transitionManager.init();
					if ( !batch.previousBatch && !!batch.instance )
						batch.instance.viewmodel.changes = [];
					batch = batch.previousBatch;
				},
				addViewmodel: function( viewmodel ) {
					if ( batch ) {
						if ( batch.viewmodels.indexOf( viewmodel ) === -1 ) {
							batch.viewmodels.push( viewmodel );
							return true;
						} else {
							return false;
						}
					} else {
						viewmodel.applyChanges();
						return false;
					}
				},
				registerTransition: function( transition ) {
					transition._manager = batch.transitionManager;
					batch.transitionManager.add( transition );
				},
				addView: function( view ) {
					batch.views.push( view );
				},
				addUnresolved: function( thing ) {
					unresolved.push( thing );
				},
				removeUnresolved: function( thing ) {
					removeFromArray( unresolved, thing );
				},
				// synchronise node detachments with transition ends
				detachWhenReady: function( thing ) {
					batch.transitionManager.detachQueue.push( thing );
				},
				scheduleTask: function( task, postRender ) {
					var _batch;
					if ( !batch ) {
						task();
					} else {
						_batch = batch;
						while ( postRender && _batch.previousBatch ) {
							// this can't happen until the DOM has been fully updated
							// otherwise in some situations (with components inside elements)
							// transitions and decorators will initialise prematurely
							_batch = _batch.previousBatch;
						}
						_batch.tasks.push( task );
					}
				}
			};
			circular.runloop = runloop;
			__export = runloop;

			function flushChanges() {
				var i, thing, changeHash;
				for ( i = 0; i < batch.viewmodels.length; i += 1 ) {
					thing = batch.viewmodels[ i ];
					changeHash = thing.applyChanges();
					if ( changeHash ) {
						changeHook.fire( thing.ractive, changeHash );
					}
				}
				batch.viewmodels.length = 0;
				attemptKeypathResolution();
				// Now that changes have been fully propagated, we can update the DOM
				// and complete other tasks
				for ( i = 0; i < batch.views.length; i += 1 ) {
					batch.views[ i ].update();
				}
				batch.views.length = 0;
				for ( i = 0; i < batch.tasks.length; i += 1 ) {
					batch.tasks[ i ]();
				}
				batch.tasks.length = 0;
				// If updating the view caused some model blowback - e.g. a triple
				// containing <option> elements caused the binding on the <select>
				// to update - then we start over
				if ( batch.viewmodels.length )
					return flushChanges();
			}

			function attemptKeypathResolution() {
				var i, item, keypath, resolved;
				i = unresolved.length;
				// see if we can resolve any unresolved references
				while ( i-- ) {
					item = unresolved[ i ];
					if ( item.keypath ) {
						// it resolved some other way. TODO how? two-way binding? Seems
						// weird that we'd still end up here
						unresolved.splice( i, 1 );
					}
					if ( keypath = resolveRef( item.root, item.ref, item.parentFragment ) ) {
						( resolved || ( resolved = [] ) ).push( {
							item: item,
							keypath: keypath
						} );
						unresolved.splice( i, 1 );
					}
				}
				if ( resolved ) {
					resolved.forEach( resolve );
				}
			}

			function resolve( resolved ) {
				resolved.item.resolve( resolved.keypath );
			}
			return __export;
		}( circular, Ractive$shared_hooks_Hook, removeFromArray, Promise, resolveRef, TransitionManager );

		/* utils/createBranch.js */
		var createBranch = function() {

			var numeric = /^\s*[0-9]+\s*$/;
			return function( key ) {
				return numeric.test( key ) ? [] : {};
			};
		}();

		/* viewmodel/prototype/get/magicAdaptor.js */
		var viewmodel$get_magicAdaptor = function( runloop, createBranch, isArray ) {

			var __export;
			var magicAdaptor, MagicWrapper;
			try {
				Object.defineProperty( {}, 'test', {
					value: 0
				} );
				magicAdaptor = {
					filter: function( object, keypath, ractive ) {
						var keys, key, parentKeypath, parentWrapper, parentValue;
						if ( !keypath ) {
							return false;
						}
						keys = keypath.split( '.' );
						key = keys.pop();
						parentKeypath = keys.join( '.' );
						// If the parent value is a wrapper, other than a magic wrapper,
						// we shouldn't wrap this property
						if ( ( parentWrapper = ractive.viewmodel.wrapped[ parentKeypath ] ) && !parentWrapper.magic ) {
							return false;
						}
						parentValue = ractive.get( parentKeypath );
						// if parentValue is an array that doesn't include this member,
						// we should return false otherwise lengths will get messed up
						if ( isArray( parentValue ) && /^[0-9]+$/.test( key ) ) {
							return false;
						}
						return parentValue && ( typeof parentValue === 'object' || typeof parentValue === 'function' );
					},
					wrap: function( ractive, property, keypath ) {
						return new MagicWrapper( ractive, property, keypath );
					}
				};
				MagicWrapper = function( ractive, value, keypath ) {
					var keys, objKeypath, template, siblings;
					this.magic = true;
					this.ractive = ractive;
					this.keypath = keypath;
					this.value = value;
					keys = keypath.split( '.' );
					this.prop = keys.pop();
					objKeypath = keys.join( '.' );
					this.obj = objKeypath ? ractive.get( objKeypath ) : ractive.data;
					template = this.originalDescriptor = Object.getOwnPropertyDescriptor( this.obj, this.prop );
					// Has this property already been wrapped?
					if ( template && template.set && ( siblings = template.set._ractiveWrappers ) ) {
						// Yes. Register this wrapper to this property, if it hasn't been already
						if ( siblings.indexOf( this ) === -1 ) {
							siblings.push( this );
						}
						return;
					}
					// No, it hasn't been wrapped
					createAccessors( this, value, template );
				};
				MagicWrapper.prototype = {
					get: function() {
						return this.value;
					},
					reset: function( value ) {
						if ( this.updating ) {
							return;
						}
						this.updating = true;
						this.obj[ this.prop ] = value;
						// trigger set() accessor
						runloop.addViewmodel( this.ractive.viewmodel );
						this.ractive.viewmodel.mark( this.keypath );
						this.updating = false;
					},
					set: function( key, value ) {
						if ( this.updating ) {
							return;
						}
						if ( !this.obj[ this.prop ] ) {
							this.updating = true;
							this.obj[ this.prop ] = createBranch( key );
							this.updating = false;
						}
						this.obj[ this.prop ][ key ] = value;
					},
					teardown: function() {
						var template, set, value, wrappers, index;
						// If this method was called because the cache was being cleared as a
						// result of a set()/update() call made by this wrapper, we return false
						// so that it doesn't get torn down
						if ( this.updating ) {
							return false;
						}
						template = Object.getOwnPropertyDescriptor( this.obj, this.prop );
						set = template && template.set;
						if ( !set ) {
							// most likely, this was an array member that was spliced out
							return;
						}
						wrappers = set._ractiveWrappers;
						index = wrappers.indexOf( this );
						if ( index !== -1 ) {
							wrappers.splice( index, 1 );
						}
						// Last one out, turn off the lights
						if ( !wrappers.length ) {
							value = this.obj[ this.prop ];
							Object.defineProperty( this.obj, this.prop, this.originalDescriptor || {
								writable: true,
								enumerable: true,
								configurable: true
							} );
							this.obj[ this.prop ] = value;
						}
					}
				};
			} catch ( err ) {
				magicAdaptor = false;
			}
			__export = magicAdaptor;

			function createAccessors( originalWrapper, value, template ) {
				var object, property, oldGet, oldSet, get, set;
				object = originalWrapper.obj;
				property = originalWrapper.prop;
				// Is this template configurable?
				if ( template && !template.configurable ) {
					// Special case - array length
					if ( property === 'length' ) {
						return;
					}
					throw new Error( 'Cannot use magic mode with property "' + property + '" - object is not configurable' );
				}
				// Time to wrap this property
				if ( template ) {
					oldGet = template.get;
					oldSet = template.set;
				}
				get = oldGet || function() {
					return value;
				};
				set = function( v ) {
					if ( oldSet ) {
						oldSet( v );
					}
					value = oldGet ? oldGet() : v;
					set._ractiveWrappers.forEach( updateWrapper );
				};

				function updateWrapper( wrapper ) {
					var keypath, ractive;
					wrapper.value = value;
					if ( wrapper.updating ) {
						return;
					}
					ractive = wrapper.ractive;
					keypath = wrapper.keypath;
					wrapper.updating = true;
					runloop.start( ractive );
					ractive.viewmodel.mark( keypath );
					runloop.end();
					wrapper.updating = false;
				}
				// Create an array of wrappers, in case other keypaths/ractives depend on this property.
				// Handily, we can store them as a property of the set function. Yay JavaScript.
				set._ractiveWrappers = [ originalWrapper ];
				Object.defineProperty( object, property, {
					get: get,
					set: set,
					enumerable: true,
					configurable: true
				} );
			}
			return __export;
		}( runloop, createBranch, isArray );

		/* config/magic.js */
		var magic = function( magicAdaptor ) {

			return !!magicAdaptor;
		}( viewmodel$get_magicAdaptor );

		/* config/namespaces.js */
		var namespaces = {
			html: 'http://www.w3.org/1999/xhtml',
			mathml: 'http://www.w3.org/1998/Math/MathML',
			svg: 'http://www.w3.org/2000/svg',
			xlink: 'http://www.w3.org/1999/xlink',
			xml: 'http://www.w3.org/XML/1998/namespace',
			xmlns: 'http://www.w3.org/2000/xmlns/'
		};

		/* utils/createElement.js */
		var createElement = function( svg, namespaces ) {

			var createElement;
			// Test for SVG support
			if ( !svg ) {
				createElement = function( type, ns ) {
					if ( ns && ns !== namespaces.html ) {
						throw 'This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you\'re trying to render SVG in an older browser. See http://docs.ractivejs.org/latest/svg-and-older-browsers for more information';
					}
					return document.createElement( type );
				};
			} else {
				createElement = function( type, ns ) {
					if ( !ns || ns === namespaces.html ) {
						return document.createElement( type );
					}
					return document.createElementNS( ns, type );
				};
			}
			return createElement;
		}( svg, namespaces );

		/* config/isClient.js */
		var isClient = function() {

			var isClient = typeof document === 'object';
			return isClient;
		}();

		/* utils/defineProperty.js */
		var defineProperty = function( isClient ) {

			var defineProperty;
			try {
				Object.defineProperty( {}, 'test', {
					value: 0
				} );
				if ( isClient ) {
					Object.defineProperty( document.createElement( 'div' ), 'test', {
						value: 0
					} );
				}
				defineProperty = Object.defineProperty;
			} catch ( err ) {
				// Object.defineProperty doesn't exist, or we're in IE8 where you can
				// only use it with DOM objects (what the fuck were you smoking, MSFT?)
				defineProperty = function( obj, prop, desc ) {
					obj[ prop ] = desc.value;
				};
			}
			return defineProperty;
		}( isClient );

		/* utils/defineProperties.js */
		var defineProperties = function( createElement, defineProperty, isClient ) {

			var defineProperties;
			try {
				try {
					Object.defineProperties( {}, {
						test: {
							value: 0
						}
					} );
				} catch ( err ) {
					// TODO how do we account for this? noMagic = true;
					throw err;
				}
				if ( isClient ) {
					Object.defineProperties( createElement( 'div' ), {
						test: {
							value: 0
						}
					} );
				}
				defineProperties = Object.defineProperties;
			} catch ( err ) {
				defineProperties = function( obj, props ) {
					var prop;
					for ( prop in props ) {
						if ( props.hasOwnProperty( prop ) ) {
							defineProperty( obj, prop, props[ prop ] );
						}
					}
				};
			}
			return defineProperties;
		}( createElement, defineProperty, isClient );

		/* Ractive/prototype/shared/add.js */
		var Ractive$shared_add = function( isNumeric ) {

			return function add( root, keypath, d ) {
				var value;
				if ( typeof keypath !== 'string' || !isNumeric( d ) ) {
					throw new Error( 'Bad arguments' );
				}
				value = +root.get( keypath ) || 0;
				if ( !isNumeric( value ) ) {
					throw new Error( 'Cannot add to a non-numeric value' );
				}
				return root.set( keypath, value + d );
			};
		}( isNumeric );

		/* Ractive/prototype/add.js */
		var Ractive$add = function( add ) {

			return function Ractive$add( keypath, d ) {
				return add( this, keypath, d === undefined ? 1 : +d );
			};
		}( Ractive$shared_add );

		/* utils/normaliseKeypath.js */
		var normaliseKeypath = function( normaliseRef ) {

			var leadingDot = /^\.+/;
			return function normaliseKeypath( keypath ) {
				return normaliseRef( keypath ).replace( leadingDot, '' );
			};
		}( normaliseRef );

		/* config/vendors.js */
		var vendors = [
			'o',
			'ms',
			'moz',
			'webkit'
		];

		/* utils/requestAnimationFrame.js */
		var requestAnimationFrame = function( vendors ) {

			var requestAnimationFrame;
			// If window doesn't exist, we don't need requestAnimationFrame
			if ( typeof window === 'undefined' ) {
				requestAnimationFrame = null;
			} else {
				// https://gist.github.com/paulirish/1579671
				( function( vendors, lastTime, window ) {
					var x, setTimeout;
					if ( window.requestAnimationFrame ) {
						return;
					}
					for ( x = 0; x < vendors.length && !window.requestAnimationFrame; ++x ) {
						window.requestAnimationFrame = window[ vendors[ x ] + 'RequestAnimationFrame' ];
					}
					if ( !window.requestAnimationFrame ) {
						setTimeout = window.setTimeout;
						window.requestAnimationFrame = function( callback ) {
							var currTime, timeToCall, id;
							currTime = Date.now();
							timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );
							id = setTimeout( function() {
								callback( currTime + timeToCall );
							}, timeToCall );
							lastTime = currTime + timeToCall;
							return id;
						};
					}
				}( vendors, 0, window ) );
				requestAnimationFrame = window.requestAnimationFrame;
			}
			return requestAnimationFrame;
		}( vendors );

		/* utils/getTime.js */
		var getTime = function() {

			var getTime;
			if ( typeof window !== 'undefined' && window.performance && typeof window.performance.now === 'function' ) {
				getTime = function() {
					return window.performance.now();
				};
			} else {
				getTime = function() {
					return Date.now();
				};
			}
			return getTime;
		}();

		/* shared/animations.js */
		var animations = function( rAF, getTime, runloop ) {

			var queue = [];
			var animations = {
				tick: function() {
					var i, animation, now;
					now = getTime();
					runloop.start();
					for ( i = 0; i < queue.length; i += 1 ) {
						animation = queue[ i ];
						if ( !animation.tick( now ) ) {
							// animation is complete, remove it from the stack, and decrement i so we don't miss one
							queue.splice( i--, 1 );
						}
					}
					runloop.end();
					if ( queue.length ) {
						rAF( animations.tick );
					} else {
						animations.running = false;
					}
				},
				add: function( animation ) {
					queue.push( animation );
					if ( !animations.running ) {
						animations.running = true;
						rAF( animations.tick );
					}
				},
				// TODO optimise this
				abort: function( keypath, root ) {
					var i = queue.length,
						animation;
					while ( i-- ) {
						animation = queue[ i ];
						if ( animation.root === root && animation.keypath === keypath ) {
							animation.stop();
						}
					}
				}
			};
			return animations;
		}( requestAnimationFrame, getTime, runloop );

		/* config/options/css/transform.js */
		var transform = function() {

			var __export;
			var selectorsPattern = /(?:^|\})?\s*([^\{\}]+)\s*\{/g,
				commentsPattern = /\/\*.*?\*\//g,
				selectorUnitPattern = /((?:(?:\[[^\]+]\])|(?:[^\s\+\>\~:]))+)((?::[^\s\+\>\~]+)?\s*[\s\+\>\~]?)\s*/g,
				mediaQueryPattern = /^@media/,
				dataRvcGuidPattern = /\[data-rvcguid="[a-z0-9-]+"]/g;
			__export = function transformCss( css, guid ) {
				var transformed, addGuid;
				addGuid = function( selector ) {
					var selectorUnits, match, unit, dataAttr, base, prepended, appended, i, transformed = [];
					selectorUnits = [];
					while ( match = selectorUnitPattern.exec( selector ) ) {
						selectorUnits.push( {
							str: match[ 0 ],
							base: match[ 1 ],
							modifiers: match[ 2 ]
						} );
					}
					// For each simple selector within the selector, we need to create a version
					// that a) combines with the guid, and b) is inside the guid
					dataAttr = '[data-rvcguid="' + guid + '"]';
					base = selectorUnits.map( extractString );
					i = selectorUnits.length;
					while ( i-- ) {
						appended = base.slice();
						// Pseudo-selectors should go after the attribute selector
						unit = selectorUnits[ i ];
						appended[ i ] = unit.base + dataAttr + unit.modifiers || '';
						prepended = base.slice();
						prepended[ i ] = dataAttr + ' ' + prepended[ i ];
						transformed.push( appended.join( ' ' ), prepended.join( ' ' ) );
					}
					return transformed.join( ', ' );
				};
				if ( dataRvcGuidPattern.test( css ) ) {
					transformed = css.replace( dataRvcGuidPattern, '[data-rvcguid="' + guid + '"]' );
				} else {
					transformed = css.replace( commentsPattern, '' ).replace( selectorsPattern, function( match, $1 ) {
						var selectors, transformed;
						// don't transform media queries!
						if ( mediaQueryPattern.test( $1 ) )
							return match;
						selectors = $1.split( ',' ).map( trim );
						transformed = selectors.map( addGuid ).join( ', ' ) + ' ';
						return match.replace( $1, transformed );
					} );
				}
				return transformed;
			};

			function trim( str ) {
				if ( str.trim ) {
					return str.trim();
				}
				return str.replace( /^\s+/, '' ).replace( /\s+$/, '' );
			}

			function extractString( unit ) {
				return unit.str;
			}
			return __export;
		}();

		/* config/options/css/css.js */
		var css = function( transformCss ) {

			var cssConfig = {
				name: 'css',
				extend: extend,
				init: function() {}
			};

			function extend( Parent, proto, options ) {
				var guid = proto.constructor._guid,
					css;
				if ( css = getCss( options.css, options, guid ) || getCss( Parent.css, Parent, guid ) ) {
					proto.constructor.css = css;
				}
			}

			function getCss( css, target, guid ) {
				if ( !css ) {
					return;
				}
				return target.noCssTransform ? css : transformCss( css, guid );
			}
			return cssConfig;
		}( transform );

		/* utils/wrapMethod.js */
		var wrapMethod = function() {

			var __export;
			__export = function( method, superMethod, force ) {
				if ( force || needsSuper( method, superMethod ) ) {
					return function() {
						var hasSuper = '_super' in this,
							_super = this._super,
							result;
						this._super = superMethod;
						result = method.apply( this, arguments );
						if ( hasSuper ) {
							this._super = _super;
						}
						return result;
					};
				} else {
					return method;
				}
			};

			function needsSuper( method, superMethod ) {
				return typeof superMethod === 'function' && /_super/.test( method );
			}
			return __export;
		}();

		/* config/options/data.js */
		var data = function( wrap ) {

			var __export;
			var dataConfig = {
				name: 'data',
				extend: extend,
				init: init,
				reset: reset
			};
			__export = dataConfig;

			function combine( Parent, target, options ) {
				var value = options.data || {},
					parentValue = getAddedKeys( Parent.prototype.data );
				if ( typeof value !== 'object' && typeof value !== 'function' ) {
					throw new TypeError( 'data option must be an object or a function, "' + value + '" is not valid' );
				}
				return dispatch( parentValue, value );
			}

			function extend( Parent, proto, options ) {
				proto.data = combine( Parent, proto, options );
			}

			function init( Parent, ractive, options ) {
				var value = options.data,
					result = combine( Parent, ractive, options );
				if ( typeof result === 'function' ) {
					result = result.call( ractive, value ) || value;
				}
				return ractive.data = result || {};
			}

			function reset( ractive ) {
				var result = this.init( ractive.constructor, ractive, ractive );
				if ( result ) {
					ractive.data = result;
					return true;
				}
			}

			function getAddedKeys( parent ) {
				// only for functions that had keys added
				if ( typeof parent !== 'function' || !Object.keys( parent ).length ) {
					return parent;
				}
				// copy the added keys to temp 'object', otherwise
				// parent would be interpreted as 'function' by dispatch
				var temp = {};
				copy( parent, temp );
				// roll in added keys
				return dispatch( parent, temp );
			}

			function dispatch( parent, child ) {
				if ( typeof child === 'function' ) {
					return extendFn( child, parent );
				} else if ( typeof parent === 'function' ) {
					return fromFn( child, parent );
				} else {
					return fromProperties( child, parent );
				}
			}

			function copy( from, to, fillOnly ) {
				for ( var key in from ) {
					if ( fillOnly && key in to ) {
						continue;
					}
					to[ key ] = from[ key ];
				}
			}

			function fromProperties( child, parent ) {
				child = child || {};
				if ( !parent ) {
					return child;
				}
				copy( parent, child, true );
				return child;
			}

			function fromFn( child, parentFn ) {
				return function( data ) {
					var keys;
					if ( child ) {
						// Track the keys that our on the child,
						// but not on the data. We'll need to apply these
						// after the parent function returns.
						keys = [];
						for ( var key in child ) {
							if ( !data || !( key in data ) ) {
								keys.push( key );
							}
						}
					}
					// call the parent fn, use data if no return value
					data = parentFn.call( this, data ) || data;
					// Copy child keys back onto data. The child keys
					// should take precedence over whatever the
					// parent did with the data.
					if ( keys && keys.length ) {
						data = data || {};
						keys.forEach( function( key ) {
							data[ key ] = child[ key ];
						} );
					}
					return data;
				};
			}

			function extendFn( childFn, parent ) {
				var parentFn;
				if ( typeof parent !== 'function' ) {
					// copy props to data
					parentFn = function( data ) {
						fromProperties( data, parent );
					};
				} else {
					parentFn = function( data ) {
						// give parent function it's own this._super context,
						// otherwise this._super is from child and
						// causes infinite loop
						parent = wrap( parent, function() {}, true );
						return parent.call( this, data ) || data;
					};
				}
				return wrap( childFn, parentFn );
			}
			return __export;
		}( wrapMethod );

		/* config/types.js */
		var types = {
			TEXT: 1,
			INTERPOLATOR: 2,
			TRIPLE: 3,
			SECTION: 4,
			INVERTED: 5,
			CLOSING: 6,
			ELEMENT: 7,
			PARTIAL: 8,
			COMMENT: 9,
			DELIMCHANGE: 10,
			MUSTACHE: 11,
			TAG: 12,
			ATTRIBUTE: 13,
			CLOSING_TAG: 14,
			COMPONENT: 15,
			NUMBER_LITERAL: 20,
			STRING_LITERAL: 21,
			ARRAY_LITERAL: 22,
			OBJECT_LITERAL: 23,
			BOOLEAN_LITERAL: 24,
			GLOBAL: 26,
			KEY_VALUE_PAIR: 27,
			REFERENCE: 30,
			REFINEMENT: 31,
			MEMBER: 32,
			PREFIX_OPERATOR: 33,
			BRACKETED: 34,
			CONDITIONAL: 35,
			INFIX_OPERATOR: 36,
			INVOCATION: 40,
			SECTION_IF: 50,
			SECTION_UNLESS: 51,
			SECTION_EACH: 52,
			SECTION_WITH: 53,
			SECTION_IF_WITH: 54
		};

		/* utils/create.js */
		var create = function() {

			var create;
			try {
				Object.create( null );
				create = Object.create;
			} catch ( err ) {
				// sigh
				create = function() {
					var F = function() {};
					return function( proto, props ) {
						var obj;
						if ( proto === null ) {
							return {};
						}
						F.prototype = proto;
						obj = new F();
						if ( props ) {
							Object.defineProperties( obj, props );
						}
						return obj;
					};
				}();
			}
			return create;
		}();

		/* parse/Parser/expressions/shared/errors.js */
		var parse_Parser_expressions_shared_errors = {
			expectedExpression: 'Expected a JavaScript expression',
			expectedParen: 'Expected closing paren'
		};

		/* parse/Parser/expressions/primary/literal/numberLiteral.js */
		var numberLiteral = function( types ) {

			var numberPattern = /^(?:[+-]?)(?:(?:(?:0|[1-9]\d*)?\.\d+)|(?:(?:0|[1-9]\d*)\.)|(?:0|[1-9]\d*))(?:[eE][+-]?\d+)?/;
			return function( parser ) {
				var result;
				if ( result = parser.matchPattern( numberPattern ) ) {
					return {
						t: types.NUMBER_LITERAL,
						v: result
					};
				}
				return null;
			};
		}( types );

		/* parse/Parser/expressions/primary/literal/booleanLiteral.js */
		var booleanLiteral = function( types ) {

			return function( parser ) {
				var remaining = parser.remaining();
				if ( remaining.substr( 0, 4 ) === 'true' ) {
					parser.pos += 4;
					return {
						t: types.BOOLEAN_LITERAL,
						v: 'true'
					};
				}
				if ( remaining.substr( 0, 5 ) === 'false' ) {
					parser.pos += 5;
					return {
						t: types.BOOLEAN_LITERAL,
						v: 'false'
					};
				}
				return null;
			};
		}( types );

		/* parse/Parser/expressions/primary/literal/stringLiteral/makeQuotedStringMatcher.js */
		var makeQuotedStringMatcher = function() {

			var stringMiddlePattern, escapeSequencePattern, lineContinuationPattern;
			// Match one or more characters until: ", ', \, or EOL/EOF.
			// EOL/EOF is written as (?!.) (meaning there's no non-newline char next).
			stringMiddlePattern = /^(?=.)[^"'\\]+?(?:(?!.)|(?=["'\\]))/;
			// Match one escape sequence, including the backslash.
			escapeSequencePattern = /^\\(?:['"\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;
			// Match one ES5 line continuation (backslash + line terminator).
			lineContinuationPattern = /^\\(?:\r\n|[\u000A\u000D\u2028\u2029])/;
			// Helper for defining getDoubleQuotedString and getSingleQuotedString.
			return function( okQuote ) {
				return function( parser ) {
					var start, literal, done, next;
					start = parser.pos;
					literal = '"';
					done = false;
					while ( !done ) {
						next = parser.matchPattern( stringMiddlePattern ) || parser.matchPattern( escapeSequencePattern ) || parser.matchString( okQuote );
						if ( next ) {
							if ( next === '"' ) {
								literal += '\\"';
							} else if ( next === '\\\'' ) {
								literal += '\'';
							} else {
								literal += next;
							}
						} else {
							next = parser.matchPattern( lineContinuationPattern );
							if ( next ) {
								// convert \(newline-like) into a \u escape, which is allowed in JSON
								literal += '\\u' + ( '000' + next.charCodeAt( 1 ).toString( 16 ) ).slice( -4 );
							} else {
								done = true;
							}
						}
					}
					literal += '"';
					// use JSON.parse to interpret escapes
					return JSON.parse( literal );
				};
			};
		}();

		/* parse/Parser/expressions/primary/literal/stringLiteral/singleQuotedString.js */
		var singleQuotedString = function( makeQuotedStringMatcher ) {

			return makeQuotedStringMatcher( '"' );
		}( makeQuotedStringMatcher );

		/* parse/Parser/expressions/primary/literal/stringLiteral/doubleQuotedString.js */
		var doubleQuotedString = function( makeQuotedStringMatcher ) {

			return makeQuotedStringMatcher( '\'' );
		}( makeQuotedStringMatcher );

		/* parse/Parser/expressions/primary/literal/stringLiteral/_stringLiteral.js */
		var stringLiteral = function( types, getSingleQuotedString, getDoubleQuotedString ) {

			return function( parser ) {
				var start, string;
				start = parser.pos;
				if ( parser.matchString( '"' ) ) {
					string = getDoubleQuotedString( parser );
					if ( !parser.matchString( '"' ) ) {
						parser.pos = start;
						return null;
					}
					return {
						t: types.STRING_LITERAL,
						v: string
					};
				}
				if ( parser.matchString( '\'' ) ) {
					string = getSingleQuotedString( parser );
					if ( !parser.matchString( '\'' ) ) {
						parser.pos = start;
						return null;
					}
					return {
						t: types.STRING_LITERAL,
						v: string
					};
				}
				return null;
			};
		}( types, singleQuotedString, doubleQuotedString );

		/* parse/Parser/expressions/shared/patterns.js */
		var patterns = {
			name: /^[a-zA-Z_$][a-zA-Z_$0-9]*/
		};

		/* parse/Parser/expressions/shared/key.js */
		var key = function( getStringLiteral, getNumberLiteral, patterns ) {

			var identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
			// http://mathiasbynens.be/notes/javascript-properties
			// can be any name, string literal, or number literal
			return function( parser ) {
				var token;
				if ( token = getStringLiteral( parser ) ) {
					return identifier.test( token.v ) ? token.v : '"' + token.v.replace( /"/g, '\\"' ) + '"';
				}
				if ( token = getNumberLiteral( parser ) ) {
					return token.v;
				}
				if ( token = parser.matchPattern( patterns.name ) ) {
					return token;
				}
			};
		}( stringLiteral, numberLiteral, patterns );

		/* parse/Parser/expressions/primary/literal/objectLiteral/keyValuePair.js */
		var keyValuePair = function( types, getKey ) {

			return function( parser ) {
				var start, key, value;
				start = parser.pos;
				// allow whitespace between '{' and key
				parser.allowWhitespace();
				key = getKey( parser );
				if ( key === null ) {
					parser.pos = start;
					return null;
				}
				// allow whitespace between key and ':'
				parser.allowWhitespace();
				// next character must be ':'
				if ( !parser.matchString( ':' ) ) {
					parser.pos = start;
					return null;
				}
				// allow whitespace between ':' and value
				parser.allowWhitespace();
				// next expression must be a, well... expression
				value = parser.readExpression();
				if ( value === null ) {
					parser.pos = start;
					return null;
				}
				return {
					t: types.KEY_VALUE_PAIR,
					k: key,
					v: value
				};
			};
		}( types, key );

		/* parse/Parser/expressions/primary/literal/objectLiteral/keyValuePairs.js */
		var keyValuePairs = function( getKeyValuePair ) {

			return function getKeyValuePairs( parser ) {
				var start, pairs, pair, keyValuePairs;
				start = parser.pos;
				pair = getKeyValuePair( parser );
				if ( pair === null ) {
					return null;
				}
				pairs = [ pair ];
				if ( parser.matchString( ',' ) ) {
					keyValuePairs = getKeyValuePairs( parser );
					if ( !keyValuePairs ) {
						parser.pos = start;
						return null;
					}
					return pairs.concat( keyValuePairs );
				}
				return pairs;
			};
		}( keyValuePair );

		/* parse/Parser/expressions/primary/literal/objectLiteral/_objectLiteral.js */
		var objectLiteral = function( types, getKeyValuePairs ) {

			return function( parser ) {
				var start, keyValuePairs;
				start = parser.pos;
				// allow whitespace
				parser.allowWhitespace();
				if ( !parser.matchString( '{' ) ) {
					parser.pos = start;
					return null;
				}
				keyValuePairs = getKeyValuePairs( parser );
				// allow whitespace between final value and '}'
				parser.allowWhitespace();
				if ( !parser.matchString( '}' ) ) {
					parser.pos = start;
					return null;
				}
				return {
					t: types.OBJECT_LITERAL,
					m: keyValuePairs
				};
			};
		}( types, keyValuePairs );

		/* parse/Parser/expressions/shared/expressionList.js */
		var expressionList = function( errors ) {

			return function getExpressionList( parser ) {
				var start, expressions, expr, next;
				start = parser.pos;
				parser.allowWhitespace();
				expr = parser.readExpression();
				if ( expr === null ) {
					return null;
				}
				expressions = [ expr ];
				// allow whitespace between expression and ','
				parser.allowWhitespace();
				if ( parser.matchString( ',' ) ) {
					next = getExpressionList( parser );
					if ( next === null ) {
						parser.error( errors.expectedExpression );
					}
					next.forEach( append );
				}

				function append( expression ) {
					expressions.push( expression );
				}
				return expressions;
			};
		}( parse_Parser_expressions_shared_errors );

		/* parse/Parser/expressions/primary/literal/arrayLiteral.js */
		var arrayLiteral = function( types, getExpressionList ) {

			return function( parser ) {
				var start, expressionList;
				start = parser.pos;
				// allow whitespace before '['
				parser.allowWhitespace();
				if ( !parser.matchString( '[' ) ) {
					parser.pos = start;
					return null;
				}
				expressionList = getExpressionList( parser );
				if ( !parser.matchString( ']' ) ) {
					parser.pos = start;
					return null;
				}
				return {
					t: types.ARRAY_LITERAL,
					m: expressionList
				};
			};
		}( types, expressionList );

		/* parse/Parser/expressions/primary/literal/_literal.js */
		var literal = function( getNumberLiteral, getBooleanLiteral, getStringLiteral, getObjectLiteral, getArrayLiteral ) {

			return function( parser ) {
				var literal = getNumberLiteral( parser ) || getBooleanLiteral( parser ) || getStringLiteral( parser ) || getObjectLiteral( parser ) || getArrayLiteral( parser );
				return literal;
			};
		}( numberLiteral, booleanLiteral, stringLiteral, objectLiteral, arrayLiteral );

		/* parse/Parser/expressions/primary/reference.js */
		var reference = function( types, patterns ) {

			var dotRefinementPattern, arrayMemberPattern, getArrayRefinement, globals, keywords;
			dotRefinementPattern = /^\.[a-zA-Z_$0-9]+/;
			getArrayRefinement = function( parser ) {
				var num = parser.matchPattern( arrayMemberPattern );
				if ( num ) {
					return '.' + num;
				}
				return null;
			};
			arrayMemberPattern = /^\[(0|[1-9][0-9]*)\]/;
			// if a reference is a browser global, we don't deference it later, so it needs special treatment
			globals = /^(?:Array|console|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null)$/;
			// keywords are not valid references, with the exception of `this`
			keywords = /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/;
			return function( parser ) {
				var startPos, ancestor, name, dot, combo, refinement, lastDotIndex;
				startPos = parser.pos;
				// we might have a root-level reference
				if ( parser.matchString( '~/' ) ) {
					ancestor = '~/';
				} else {
					// we might have ancestor refs...
					ancestor = '';
					while ( parser.matchString( '../' ) ) {
						ancestor += '../';
					}
				}
				if ( !ancestor ) {
					// we might have an implicit iterator or a restricted reference
					dot = parser.matchString( './' ) || parser.matchString( '.' ) || '';
				}
				name = parser.matchPattern( /^@(?:keypath|index|key)/ ) || parser.matchPattern( patterns.name ) || '';
				// bug out if it's a keyword
				if ( keywords.test( name ) ) {
					parser.pos = startPos;
					return null;
				}
				// if this is a browser global, stop here
				if ( !ancestor && !dot && globals.test( name ) ) {
					return {
						t: types.GLOBAL,
						v: name
					};
				}
				combo = ( ancestor || dot ) + name;
				if ( !combo ) {
					return null;
				}
				while ( refinement = parser.matchPattern( dotRefinementPattern ) || getArrayRefinement( parser ) ) {
					combo += refinement;
				}
				if ( parser.matchString( '(' ) ) {
					// if this is a method invocation (as opposed to a function) we need
					// to strip the method name from the reference combo, else the context
					// will be wrong
					lastDotIndex = combo.lastIndexOf( '.' );
					if ( lastDotIndex !== -1 ) {
						combo = combo.substr( 0, lastDotIndex );
						parser.pos = startPos + combo.length;
					} else {
						parser.pos -= 1;
					}
				}
				return {
					t: types.REFERENCE,
					n: combo.replace( /^this\./, './' ).replace( /^this$/, '.' )
				};
			};
		}( types, patterns );

		/* parse/Parser/expressions/primary/bracketedExpression.js */
		var bracketedExpression = function( types, errors ) {

			return function( parser ) {
				var start, expr;
				start = parser.pos;
				if ( !parser.matchString( '(' ) ) {
					return null;
				}
				parser.allowWhitespace();
				expr = parser.readExpression();
				if ( !expr ) {
					parser.error( errors.expectedExpression );
				}
				parser.allowWhitespace();
				if ( !parser.matchString( ')' ) ) {
					parser.error( errors.expectedParen );
				}
				return {
					t: types.BRACKETED,
					x: expr
				};
			};
		}( types, parse_Parser_expressions_shared_errors );

		/* parse/Parser/expressions/primary/_primary.js */
		var primary = function( getLiteral, getReference, getBracketedExpression ) {

			return function( parser ) {
				return getLiteral( parser ) || getReference( parser ) || getBracketedExpression( parser );
			};
		}( literal, reference, bracketedExpression );

		/* parse/Parser/expressions/shared/refinement.js */
		var refinement = function( types, errors, patterns ) {

			return function getRefinement( parser ) {
				var start, name, expr;
				start = parser.pos;
				parser.allowWhitespace();
				// "." name
				if ( parser.matchString( '.' ) ) {
					parser.allowWhitespace();
					if ( name = parser.matchPattern( patterns.name ) ) {
						return {
							t: types.REFINEMENT,
							n: name
						};
					}
					parser.error( 'Expected a property name' );
				}
				// "[" expression "]"
				if ( parser.matchString( '[' ) ) {
					parser.allowWhitespace();
					expr = parser.readExpression();
					if ( !expr ) {
						parser.error( errors.expectedExpression );
					}
					parser.allowWhitespace();
					if ( !parser.matchString( ']' ) ) {
						parser.error( 'Expected \']\'' );
					}
					return {
						t: types.REFINEMENT,
						x: expr
					};
				}
				return null;
			};
		}( types, parse_Parser_expressions_shared_errors, patterns );

		/* parse/Parser/expressions/memberOrInvocation.js */
		var memberOrInvocation = function( types, getPrimary, getExpressionList, getRefinement, errors ) {

			return function( parser ) {
				var current, expression, refinement, expressionList;
				expression = getPrimary( parser );
				if ( !expression ) {
					return null;
				}
				while ( expression ) {
					current = parser.pos;
					if ( refinement = getRefinement( parser ) ) {
						expression = {
							t: types.MEMBER,
							x: expression,
							r: refinement
						};
					} else if ( parser.matchString( '(' ) ) {
						parser.allowWhitespace();
						expressionList = getExpressionList( parser );
						parser.allowWhitespace();
						if ( !parser.matchString( ')' ) ) {
							parser.error( errors.expectedParen );
						}
						expression = {
							t: types.INVOCATION,
							x: expression
						};
						if ( expressionList ) {
							expression.o = expressionList;
						}
					} else {
						break;
					}
				}
				return expression;
			};
		}( types, primary, expressionList, refinement, parse_Parser_expressions_shared_errors );

		/* parse/Parser/expressions/typeof.js */
		var _typeof = function( types, errors, getMemberOrInvocation ) {

			var getTypeof, makePrefixSequenceMatcher;
			makePrefixSequenceMatcher = function( symbol, fallthrough ) {
				return function( parser ) {
					var expression;
					if ( expression = fallthrough( parser ) ) {
						return expression;
					}
					if ( !parser.matchString( symbol ) ) {
						return null;
					}
					parser.allowWhitespace();
					expression = parser.readExpression();
					if ( !expression ) {
						parser.error( errors.expectedExpression );
					}
					return {
						s: symbol,
						o: expression,
						t: types.PREFIX_OPERATOR
					};
				};
			};
			// create all prefix sequence matchers, return getTypeof
			( function() {
				var i, len, matcher, prefixOperators, fallthrough;
				prefixOperators = '! ~ + - typeof'.split( ' ' );
				fallthrough = getMemberOrInvocation;
				for ( i = 0, len = prefixOperators.length; i < len; i += 1 ) {
					matcher = makePrefixSequenceMatcher( prefixOperators[ i ], fallthrough );
					fallthrough = matcher;
				}
				// typeof operator is higher precedence than multiplication, so provides the
				// fallthrough for the multiplication sequence matcher we're about to create
				// (we're skipping void and delete)
				getTypeof = fallthrough;
			}() );
			return getTypeof;
		}( types, parse_Parser_expressions_shared_errors, memberOrInvocation );

		/* parse/Parser/expressions/logicalOr.js */
		var logicalOr = function( types, getTypeof ) {

			var getLogicalOr, makeInfixSequenceMatcher;
			makeInfixSequenceMatcher = function( symbol, fallthrough ) {
				return function( parser ) {
					var start, left, right;
					left = fallthrough( parser );
					if ( !left ) {
						return null;
					}
					// Loop to handle left-recursion in a case like `a * b * c` and produce
					// left association, i.e. `(a * b) * c`.  The matcher can't call itself
					// to parse `left` because that would be infinite regress.
					while ( true ) {
						start = parser.pos;
						parser.allowWhitespace();
						if ( !parser.matchString( symbol ) ) {
							parser.pos = start;
							return left;
						}
						// special case - in operator must not be followed by [a-zA-Z_$0-9]
						if ( symbol === 'in' && /[a-zA-Z_$0-9]/.test( parser.remaining().charAt( 0 ) ) ) {
							parser.pos = start;
							return left;
						}
						parser.allowWhitespace();
						// right operand must also consist of only higher-precedence operators
						right = fallthrough( parser );
						if ( !right ) {
							parser.pos = start;
							return left;
						}
						left = {
							t: types.INFIX_OPERATOR,
							s: symbol,
							o: [
								left,
								right
							]
						};
					}
				};
			};
			// create all infix sequence matchers, and return getLogicalOr
			( function() {
				var i, len, matcher, infixOperators, fallthrough;
				// All the infix operators on order of precedence (source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence)
				// Each sequence matcher will initially fall through to its higher precedence
				// neighbour, and only attempt to match if one of the higher precedence operators
				// (or, ultimately, a literal, reference, or bracketed expression) already matched
				infixOperators = '* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||'.split( ' ' );
				// A typeof operator is higher precedence than multiplication
				fallthrough = getTypeof;
				for ( i = 0, len = infixOperators.length; i < len; i += 1 ) {
					matcher = makeInfixSequenceMatcher( infixOperators[ i ], fallthrough );
					fallthrough = matcher;
				}
				// Logical OR is the fallthrough for the conditional matcher
				getLogicalOr = fallthrough;
			}() );
			return getLogicalOr;
		}( types, _typeof );

		/* parse/Parser/expressions/conditional.js */
		var conditional = function( types, getLogicalOr, errors ) {

			return function( parser ) {
				var start, expression, ifTrue, ifFalse;
				expression = getLogicalOr( parser );
				if ( !expression ) {
					return null;
				}
				start = parser.pos;
				parser.allowWhitespace();
				if ( !parser.matchString( '?' ) ) {
					parser.pos = start;
					return expression;
				}
				parser.allowWhitespace();
				ifTrue = parser.readExpression();
				if ( !ifTrue ) {
					parser.error( errors.expectedExpression );
				}
				parser.allowWhitespace();
				if ( !parser.matchString( ':' ) ) {
					parser.error( 'Expected ":"' );
				}
				parser.allowWhitespace();
				ifFalse = parser.readExpression();
				if ( !ifFalse ) {
					parser.error( errors.expectedExpression );
				}
				return {
					t: types.CONDITIONAL,
					o: [
						expression,
						ifTrue,
						ifFalse
					]
				};
			};
		}( types, logicalOr, parse_Parser_expressions_shared_errors );

		/* parse/Parser/utils/flattenExpression.js */
		var flattenExpression = function( types, isObject ) {

			var __export;
			__export = function( expression ) {
				var refs = [],
					flattened;
				extractRefs( expression, refs );
				flattened = {
					r: refs,
					s: stringify( this, expression, refs )
				};
				return flattened;
			};

			function quoteStringLiteral( str ) {
				return JSON.stringify( String( str ) );
			}
			// TODO maybe refactor this?
			function extractRefs( node, refs ) {
				var i, list;
				if ( node.t === types.REFERENCE ) {
					if ( refs.indexOf( node.n ) === -1 ) {
						refs.unshift( node.n );
					}
				}
				list = node.o || node.m;
				if ( list ) {
					if ( isObject( list ) ) {
						extractRefs( list, refs );
					} else {
						i = list.length;
						while ( i-- ) {
							extractRefs( list[ i ], refs );
						}
					}
				}
				if ( node.x ) {
					extractRefs( node.x, refs );
				}
				if ( node.r ) {
					extractRefs( node.r, refs );
				}
				if ( node.v ) {
					extractRefs( node.v, refs );
				}
			}

			function stringify( parser, node, refs ) {
				var stringifyAll = function( item ) {
					return stringify( parser, item, refs );
				};
				switch ( node.t ) {
					case types.BOOLEAN_LITERAL:
					case types.GLOBAL:
					case types.NUMBER_LITERAL:
						return node.v;
					case types.STRING_LITERAL:
						return quoteStringLiteral( node.v );
					case types.ARRAY_LITERAL:
						return '[' + ( node.m ? node.m.map( stringifyAll ).join( ',' ) : '' ) + ']';
					case types.OBJECT_LITERAL:
						return '{' + ( node.m ? node.m.map( stringifyAll ).join( ',' ) : '' ) + '}';
					case types.KEY_VALUE_PAIR:
						return node.k + ':' + stringify( parser, node.v, refs );
					case types.PREFIX_OPERATOR:
						return ( node.s === 'typeof' ? 'typeof ' : node.s ) + stringify( parser, node.o, refs );
					case types.INFIX_OPERATOR:
						return stringify( parser, node.o[ 0 ], refs ) + ( node.s.substr( 0, 2 ) === 'in' ? ' ' + node.s + ' ' : node.s ) + stringify( parser, node.o[ 1 ], refs );
					case types.INVOCATION:
						return stringify( parser, node.x, refs ) + '(' + ( node.o ? node.o.map( stringifyAll ).join( ',' ) : '' ) + ')';
					case types.BRACKETED:
						return '(' + stringify( parser, node.x, refs ) + ')';
					case types.MEMBER:
						return stringify( parser, node.x, refs ) + stringify( parser, node.r, refs );
					case types.REFINEMENT:
						return node.n ? '.' + node.n : '[' + stringify( parser, node.x, refs ) + ']';
					case types.CONDITIONAL:
						return stringify( parser, node.o[ 0 ], refs ) + '?' + stringify( parser, node.o[ 1 ], refs ) + ':' + stringify( parser, node.o[ 2 ], refs );
					case types.REFERENCE:
						return '_' + refs.indexOf( node.n );
					default:
						parser.error( 'Expected legal JavaScript' );
				}
			}
			return __export;
		}( types, isObject );

		/* parse/Parser/_Parser.js */
		var Parser = function( circular, create, hasOwnProperty, getConditional, flattenExpression ) {

			var Parser, ParseError, leadingWhitespace = /^\s+/;
			ParseError = function( message ) {
				this.name = 'ParseError';
				this.message = message;
				try {
					throw new Error( message );
				} catch ( e ) {
					this.stack = e.stack;
				}
			};
			ParseError.prototype = Error.prototype;
			Parser = function( str, options ) {
				var items, item, lineStart = 0;
				this.str = str;
				this.options = options || {};
				this.pos = 0;
				this.lines = this.str.split( '\n' );
				this.lineEnds = this.lines.map( function( line ) {
					var lineEnd = lineStart + line.length + 1;
					// +1 for the newline
					lineStart = lineEnd;
					return lineEnd;
				}, 0 );
				// Custom init logic
				if ( this.init )
					this.init( str, options );
				items = [];
				while ( this.pos < this.str.length && ( item = this.read() ) ) {
					items.push( item );
				}
				this.leftover = this.remaining();
				this.result = this.postProcess ? this.postProcess( items, options ) : items;
			};
			Parser.prototype = {
				read: function( converters ) {
					var pos, i, len, item;
					if ( !converters )
						converters = this.converters;
					pos = this.pos;
					len = converters.length;
					for ( i = 0; i < len; i += 1 ) {
						this.pos = pos;
						// reset for each attempt
						if ( item = converters[ i ]( this ) ) {
							return item;
						}
					}
					return null;
				},
				readExpression: function() {
					// The conditional operator is the lowest precedence operator (except yield,
					// assignment operators, and commas, none of which are supported), so we
					// start there. If it doesn't match, it 'falls through' to progressively
					// higher precedence operators, until it eventually matches (or fails to
					// match) a 'primary' - a literal or a reference. This way, the abstract syntax
					// tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.
					return getConditional( this );
				},
				flattenExpression: flattenExpression,
				getLinePos: function( char ) {
					var lineNum = 0,
						lineStart = 0,
						columnNum;
					while ( char >= this.lineEnds[ lineNum ] ) {
						lineStart = this.lineEnds[ lineNum ];
						lineNum += 1;
					}
					columnNum = char - lineStart;
					return [
						lineNum + 1,
						columnNum + 1,
						char
					];
				},
				error: function( message ) {
					var pos, lineNum, columnNum, line, annotation, error;
					pos = this.getLinePos( this.pos );
					lineNum = pos[ 0 ];
					columnNum = pos[ 1 ];
					line = this.lines[ pos[ 0 ] - 1 ];
					annotation = line + '\n' + new Array( pos[ 1 ] ).join( ' ' ) + '^----';
					error = new ParseError( message + ' at line ' + lineNum + ' character ' + columnNum + ':\n' + annotation );
					error.line = pos[ 0 ];
					error.character = pos[ 1 ];
					error.shortMessage = message;
					throw error;
				},
				matchString: function( string ) {
					if ( this.str.substr( this.pos, string.length ) === string ) {
						this.pos += string.length;
						return string;
					}
				},
				matchPattern: function( pattern ) {
					var match;
					if ( match = pattern.exec( this.remaining() ) ) {
						this.pos += match[ 0 ].length;
						return match[ 1 ] || match[ 0 ];
					}
				},
				allowWhitespace: function() {
					this.matchPattern( leadingWhitespace );
				},
				remaining: function() {
					return this.str.substring( this.pos );
				},
				nextChar: function() {
					return this.str.charAt( this.pos );
				}
			};
			Parser.extend = function( proto ) {
				var Parent = this,
					Child, key;
				Child = function( str, options ) {
					Parser.call( this, str, options );
				};
				Child.prototype = create( Parent.prototype );
				for ( key in proto ) {
					if ( hasOwnProperty.call( proto, key ) ) {
						Child.prototype[ key ] = proto[ key ];
					}
				}
				Child.extend = Parser.extend;
				return Child;
			};
			circular.Parser = Parser;
			return Parser;
		}( circular, create, hasOwn, conditional, flattenExpression );

		/* parse/converters/mustache/delimiterChange.js */
		var delimiterChange = function() {

			var delimiterChangePattern = /^[^\s=]+/,
				whitespacePattern = /^\s+/;
			return function( parser ) {
				var start, opening, closing;
				if ( !parser.matchString( '=' ) ) {
					return null;
				}
				start = parser.pos;
				// allow whitespace before new opening delimiter
				parser.allowWhitespace();
				opening = parser.matchPattern( delimiterChangePattern );
				if ( !opening ) {
					parser.pos = start;
					return null;
				}
				// allow whitespace (in fact, it's necessary...)
				if ( !parser.matchPattern( whitespacePattern ) ) {
					return null;
				}
				closing = parser.matchPattern( delimiterChangePattern );
				if ( !closing ) {
					parser.pos = start;
					return null;
				}
				// allow whitespace before closing '='
				parser.allowWhitespace();
				if ( !parser.matchString( '=' ) ) {
					parser.pos = start;
					return null;
				}
				return [
					opening,
					closing
				];
			};
		}();

		/* parse/converters/mustache/delimiterTypes.js */
		var delimiterTypes = [ {
			delimiters: 'delimiters',
			isTriple: false,
			isStatic: false
		}, {
			delimiters: 'tripleDelimiters',
			isTriple: true,
			isStatic: false
		}, {
			delimiters: 'staticDelimiters',
			isTriple: false,
			isStatic: true
		}, {
			delimiters: 'staticTripleDelimiters',
			isTriple: true,
			isStatic: true
		} ];

		/* parse/converters/mustache/type.js */
		var type = function( types ) {

			var mustacheTypes = {
				'#': types.SECTION,
				'^': types.INVERTED,
				'/': types.CLOSING,
				'>': types.PARTIAL,
				'!': types.COMMENT,
				'&': types.TRIPLE
			};
			return function( parser ) {
				var type = mustacheTypes[ parser.str.charAt( parser.pos ) ];
				if ( !type ) {
					return null;
				}
				parser.pos += 1;
				return type;
			};
		}( types );

		/* parse/converters/mustache/handlebarsBlockCodes.js */
		var handlebarsBlockCodes = function( types ) {

			return {
				'each': types.SECTION_EACH,
				'if': types.SECTION_IF,
				'if-with': types.SECTION_IF_WITH,
				'with': types.SECTION_WITH,
				'unless': types.SECTION_UNLESS
			};
		}( types );

		/* empty/legacy.js */
		var legacy = null;

		/* parse/converters/mustache/content.js */
		var content = function( types, mustacheType, handlebarsBlockCodes ) {

			var __export;
			var indexRefPattern = /^\s*:\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,
				arrayMemberPattern = /^[0-9][1-9]*$/,
				handlebarsBlockPattern = new RegExp( '^(' + Object.keys( handlebarsBlockCodes ).join( '|' ) + ')\\b' ),
				legalReference;
			legalReference = /^[a-zA-Z$_0-9]+(?:(\.[a-zA-Z$_0-9]+)|(\[[a-zA-Z$_0-9]+\]))*$/;
			__export = function( parser, delimiterType ) {
				var start, pos, mustache, type, block, expression, i, remaining, index, delimiters;
				start = parser.pos;
				mustache = {};
				delimiters = parser[ delimiterType.delimiters ];
				if ( delimiterType.isStatic ) {
					mustache.s = true;
				}
				// Determine mustache type
				if ( delimiterType.isTriple ) {
					mustache.t = types.TRIPLE;
				} else {
					// We need to test for expressions before we test for mustache type, because
					// an expression that begins '!' looks a lot like a comment
					if ( parser.remaining()[ 0 ] === '!' ) {
						try {
							expression = parser.readExpression();
							// Was it actually an expression, or a comment block in disguise?
							parser.allowWhitespace();
							if ( parser.remaining().indexOf( delimiters[ 1 ] ) ) {
								expression = null;
							} else {
								mustache.t = types.INTERPOLATOR;
							}
						} catch ( err ) {}
						if ( !expression ) {
							index = parser.remaining().indexOf( delimiters[ 1 ] );
							if ( ~index ) {
								parser.pos += index;
							} else {
								parser.error( 'Expected closing delimiter (\'' + delimiters[ 1 ] + '\')' );
							}
							return {
								t: types.COMMENT
							};
						}
					}
					if ( !expression ) {
						type = mustacheType( parser );
						mustache.t = type || types.INTERPOLATOR;
						// default
						// See if there's an explicit section type e.g. {{#with}}...{{/with}}
						if ( type === types.SECTION ) {
							if ( block = parser.matchPattern( handlebarsBlockPattern ) ) {
								mustache.n = block;
							}
							parser.allowWhitespace();
						} else if ( type === types.COMMENT || type === types.CLOSING ) {
							remaining = parser.remaining();
							index = remaining.indexOf( delimiters[ 1 ] );
							if ( index !== -1 ) {
								mustache.r = remaining.substr( 0, index ).split( ' ' )[ 0 ];
								parser.pos += index;
								return mustache;
							}
						}
					}
				}
				if ( !expression ) {
					// allow whitespace
					parser.allowWhitespace();
					// get expression
					expression = parser.readExpression();
					// If this is a partial, it may have a context (e.g. `{{>item foo}}`). These
					// cases involve a bit of a hack - we want to turn it into the equivalent of
					// `{{#with foo}}{{>item}}{{/with}}`, but to get there we temporarily append
					// a 'contextPartialExpression' to the mustache, and process the context instead of
					// the reference
					var temp;
					if ( mustache.t === types.PARTIAL && expression && ( temp = parser.readExpression() ) ) {
						mustache = {
							contextPartialExpression: expression
						};
						expression = temp;
					}
					// With certain valid references that aren't valid expressions,
					// e.g. {{1.foo}}, we have a problem: it looks like we've got an
					// expression, but the expression didn't consume the entire
					// reference. So we need to check that the mustache delimiters
					// appear next, unless there's an index reference (i.e. a colon)
					remaining = parser.remaining();
					if ( remaining.substr( 0, delimiters[ 1 ].length ) !== delimiters[ 1 ] && remaining.charAt( 0 ) !== ':' ) {
						pos = parser.pos;
						parser.pos = start;
						remaining = parser.remaining();
						index = remaining.indexOf( delimiters[ 1 ] );
						if ( index !== -1 ) {
							mustache.r = remaining.substr( 0, index ).trim();
							// Check it's a legal reference
							if ( !legalReference.test( mustache.r ) ) {
								parser.error( 'Expected a legal Mustache reference' );
							}
							parser.pos += index;
							return mustache;
						}
						parser.pos = pos;
					}
				}
				refineExpression( parser, expression, mustache );
				// if there was context, process the expression now and save it for later
				if ( mustache.contextPartialExpression ) {
					mustache.contextPartialExpression = [ refineExpression( parser, mustache.contextPartialExpression, {
						t: types.PARTIAL
					} ) ];
				}
				// optional index reference
				if ( i = parser.matchPattern( indexRefPattern ) ) {
					mustache.i = i;
				}
				return mustache;
			};

			function refineExpression( parser, expression, mustache ) {
				var referenceExpression;
				if ( expression ) {
					while ( expression.t === types.BRACKETED && expression.x ) {
						expression = expression.x;
					}
					// special case - integers should be treated as array members references,
					// rather than as expressions in their own right
					if ( expression.t === types.REFERENCE ) {
						mustache.r = expression.n;
					} else {
						if ( expression.t === types.NUMBER_LITERAL && arrayMemberPattern.test( expression.v ) ) {
							mustache.r = expression.v;
						} else if ( referenceExpression = getReferenceExpression( parser, expression ) ) {
							mustache.rx = referenceExpression;
						} else {
							mustache.x = parser.flattenExpression( expression );
						}
					}
					return mustache;
				}
			}
			// TODO refactor this! it's bewildering
			function getReferenceExpression( parser, expression ) {
				var members = [],
					refinement;
				while ( expression.t === types.MEMBER && expression.r.t === types.REFINEMENT ) {
					refinement = expression.r;
					if ( refinement.x ) {
						if ( refinement.x.t === types.REFERENCE ) {
							members.unshift( refinement.x );
						} else {
							members.unshift( parser.flattenExpression( refinement.x ) );
						}
					} else {
						members.unshift( refinement.n );
					}
					expression = expression.x;
				}
				if ( expression.t !== types.REFERENCE ) {
					return null;
				}
				return {
					r: expression.n,
					m: members
				};
			}
			return __export;
		}( types, type, handlebarsBlockCodes, legacy );

		/* parse/converters/mustache.js */
		var mustache = function( types, delimiterChange, delimiterTypes, mustacheContent, handlebarsBlockCodes ) {

			var __export;
			var delimiterChangeToken = {
				t: types.DELIMCHANGE,
				exclude: true
			};
			__export = getMustache;

			function getMustache( parser ) {
				var types;
				// If we're inside a <script> or <style> tag, and we're not
				// interpolating, bug out
				if ( parser.interpolate[ parser.inside ] === false ) {
					return null;
				}
				types = delimiterTypes.slice().sort( function compare( a, b ) {
					// Sort in order of descending opening delimiter length (longer first),
					// to protect against opening delimiters being substrings of each other
					return parser[ b.delimiters ][ 0 ].length - parser[ a.delimiters ][ 0 ].length;
				} );
				return function r( type ) {
					if ( !type ) {
						return null;
					} else {
						return getMustacheOfType( parser, type ) || r( types.shift() );
					}
				}( types.shift() );
			}

			function getMustacheOfType( parser, delimiterType ) {
				var start, mustache, delimiters, children, expectedClose, elseChildren, currentChildren, child;
				start = parser.pos;
				delimiters = parser[ delimiterType.delimiters ];
				if ( !parser.matchString( delimiters[ 0 ] ) ) {
					return null;
				}
				// delimiter change?
				if ( mustache = delimiterChange( parser ) ) {
					// find closing delimiter or abort...
					if ( !parser.matchString( delimiters[ 1 ] ) ) {
						return null;
					}
					// ...then make the switch
					parser[ delimiterType.delimiters ] = mustache;
					return delimiterChangeToken;
				}
				parser.allowWhitespace();
				mustache = mustacheContent( parser, delimiterType );
				if ( mustache === null ) {
					parser.pos = start;
					return null;
				}
				// allow whitespace before closing delimiter
				parser.allowWhitespace();
				if ( !parser.matchString( delimiters[ 1 ] ) ) {
					parser.error( 'Expected closing delimiter \'' + delimiters[ 1 ] + '\' after reference' );
				}
				if ( mustache.t === types.COMMENT ) {
					mustache.exclude = true;
				}
				if ( mustache.t === types.CLOSING ) {
					parser.sectionDepth -= 1;
					if ( parser.sectionDepth < 0 ) {
						parser.pos = start;
						parser.error( 'Attempted to close a section that wasn\'t open' );
					}
				}
				// partials with context
				if ( mustache.contextPartialExpression ) {
					mustache.f = mustache.contextPartialExpression;
					mustache.t = types.SECTION;
					mustache.n = 'with';
					delete mustache.contextPartialExpression;
				} else if ( isSection( mustache ) ) {
					parser.sectionDepth += 1;
					children = [];
					currentChildren = children;
					expectedClose = mustache.n;
					while ( child = parser.read() ) {
						if ( child.t === types.CLOSING ) {
							if ( expectedClose && child.r !== expectedClose ) {
								parser.error( 'Expected {{/' + expectedClose + '}}' );
							}
							break;
						}
						// {{else}} tags require special treatment
						if ( child.t === types.INTERPOLATOR && child.r === 'else' ) {
							// no {{else}} allowed in {{#unless}}
							if ( mustache.n === 'unless' ) {
								parser.error( '{{else}} not allowed in {{#unless}}' );
							} else {
								currentChildren = elseChildren = [];
								continue;
							}
						}
						currentChildren.push( child );
					}
					if ( children.length ) {
						mustache.f = children;
					}
					if ( elseChildren && elseChildren.length ) {
						mustache.l = elseChildren;
						if ( mustache.n === 'with' ) {
							mustache.n = 'if-with';
						}
					}
				}
				if ( parser.includeLinePositions ) {
					mustache.p = parser.getLinePos( start );
				}
				// Replace block name with code
				if ( mustache.n ) {
					mustache.n = handlebarsBlockCodes[ mustache.n ];
				} else if ( mustache.t === types.INVERTED ) {
					mustache.t = types.SECTION;
					mustache.n = types.SECTION_UNLESS;
				}
				return mustache;
			}

			function isSection( mustache ) {
				return mustache.t === types.SECTION || mustache.t === types.INVERTED;
			}
			return __export;
		}( types, delimiterChange, delimiterTypes, content, handlebarsBlockCodes );

		/* parse/converters/comment.js */
		var comment = function( types ) {

			var OPEN_COMMENT = '<!--',
				CLOSE_COMMENT = '-->';
			return function( parser ) {
				var start, content, remaining, endIndex, comment;
				start = parser.pos;
				if ( !parser.matchString( OPEN_COMMENT ) ) {
					return null;
				}
				remaining = parser.remaining();
				endIndex = remaining.indexOf( CLOSE_COMMENT );
				if ( endIndex === -1 ) {
					parser.error( 'Illegal HTML - expected closing comment sequence (\'-->\')' );
				}
				content = remaining.substr( 0, endIndex );
				parser.pos += endIndex + 3;
				comment = {
					t: types.COMMENT,
					c: content
				};
				if ( parser.includeLinePositions ) {
					comment.p = parser.getLinePos( start );
				}
				return comment;
			};
		}( types );

		/* config/voidElementNames.js */
		var voidElementNames = function() {

			var voidElementNames = /^(?:area|base|br|col|command|doctype|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;
			return voidElementNames;
		}();

		/* parse/converters/utils/getLowestIndex.js */
		var getLowestIndex = function( haystack, needles ) {
			var i, index, lowest;
			i = needles.length;
			while ( i-- ) {
				index = haystack.indexOf( needles[ i ] );
				// short circuit
				if ( !index ) {
					return 0;
				}
				if ( index === -1 ) {
					continue;
				}
				if ( !lowest || index < lowest ) {
					lowest = index;
				}
			}
			return lowest || -1;
		};

		/* shared/decodeCharacterReferences.js */
		var decodeCharacterReferences = function() {

			var __export;
			var htmlEntities, controlCharacters, entityPattern;
			htmlEntities = {
				quot: 34,
				amp: 38,
				apos: 39,
				lt: 60,
				gt: 62,
				nbsp: 160,
				iexcl: 161,
				cent: 162,
				pound: 163,
				curren: 164,
				yen: 165,
				brvbar: 166,
				sect: 167,
				uml: 168,
				copy: 169,
				ordf: 170,
				laquo: 171,
				not: 172,
				shy: 173,
				reg: 174,
				macr: 175,
				deg: 176,
				plusmn: 177,
				sup2: 178,
				sup3: 179,
				acute: 180,
				micro: 181,
				para: 182,
				middot: 183,
				cedil: 184,
				sup1: 185,
				ordm: 186,
				raquo: 187,
				frac14: 188,
				frac12: 189,
				frac34: 190,
				iquest: 191,
				Agrave: 192,
				Aacute: 193,
				Acirc: 194,
				Atilde: 195,
				Auml: 196,
				Aring: 197,
				AElig: 198,
				Ccedil: 199,
				Egrave: 200,
				Eacute: 201,
				Ecirc: 202,
				Euml: 203,
				Igrave: 204,
				Iacute: 205,
				Icirc: 206,
				Iuml: 207,
				ETH: 208,
				Ntilde: 209,
				Ograve: 210,
				Oacute: 211,
				Ocirc: 212,
				Otilde: 213,
				Ouml: 214,
				times: 215,
				Oslash: 216,
				Ugrave: 217,
				Uacute: 218,
				Ucirc: 219,
				Uuml: 220,
				Yacute: 221,
				THORN: 222,
				szlig: 223,
				agrave: 224,
				aacute: 225,
				acirc: 226,
				atilde: 227,
				auml: 228,
				aring: 229,
				aelig: 230,
				ccedil: 231,
				egrave: 232,
				eacute: 233,
				ecirc: 234,
				euml: 235,
				igrave: 236,
				iacute: 237,
				icirc: 238,
				iuml: 239,
				eth: 240,
				ntilde: 241,
				ograve: 242,
				oacute: 243,
				ocirc: 244,
				otilde: 245,
				ouml: 246,
				divide: 247,
				oslash: 248,
				ugrave: 249,
				uacute: 250,
				ucirc: 251,
				uuml: 252,
				yacute: 253,
				thorn: 254,
				yuml: 255,
				OElig: 338,
				oelig: 339,
				Scaron: 352,
				scaron: 353,
				Yuml: 376,
				fnof: 402,
				circ: 710,
				tilde: 732,
				Alpha: 913,
				Beta: 914,
				Gamma: 915,
				Delta: 916,
				Epsilon: 917,
				Zeta: 918,
				Eta: 919,
				Theta: 920,
				Iota: 921,
				Kappa: 922,
				Lambda: 923,
				Mu: 924,
				Nu: 925,
				Xi: 926,
				Omicron: 927,
				Pi: 928,
				Rho: 929,
				Sigma: 931,
				Tau: 932,
				Upsilon: 933,
				Phi: 934,
				Chi: 935,
				Psi: 936,
				Omega: 937,
				alpha: 945,
				beta: 946,
				gamma: 947,
				delta: 948,
				epsilon: 949,
				zeta: 950,
				eta: 951,
				theta: 952,
				iota: 953,
				kappa: 954,
				lambda: 955,
				mu: 956,
				nu: 957,
				xi: 958,
				omicron: 959,
				pi: 960,
				rho: 961,
				sigmaf: 962,
				sigma: 963,
				tau: 964,
				upsilon: 965,
				phi: 966,
				chi: 967,
				psi: 968,
				omega: 969,
				thetasym: 977,
				upsih: 978,
				piv: 982,
				ensp: 8194,
				emsp: 8195,
				thinsp: 8201,
				zwnj: 8204,
				zwj: 8205,
				lrm: 8206,
				rlm: 8207,
				ndash: 8211,
				mdash: 8212,
				lsquo: 8216,
				rsquo: 8217,
				sbquo: 8218,
				ldquo: 8220,
				rdquo: 8221,
				bdquo: 8222,
				dagger: 8224,
				Dagger: 8225,
				bull: 8226,
				hellip: 8230,
				permil: 8240,
				prime: 8242,
				Prime: 8243,
				lsaquo: 8249,
				rsaquo: 8250,
				oline: 8254,
				frasl: 8260,
				euro: 8364,
				image: 8465,
				weierp: 8472,
				real: 8476,
				trade: 8482,
				alefsym: 8501,
				larr: 8592,
				uarr: 8593,
				rarr: 8594,
				darr: 8595,
				harr: 8596,
				crarr: 8629,
				lArr: 8656,
				uArr: 8657,
				rArr: 8658,
				dArr: 8659,
				hArr: 8660,
				forall: 8704,
				part: 8706,
				exist: 8707,
				empty: 8709,
				nabla: 8711,
				isin: 8712,
				notin: 8713,
				ni: 8715,
				prod: 8719,
				sum: 8721,
				minus: 8722,
				lowast: 8727,
				radic: 8730,
				prop: 8733,
				infin: 8734,
				ang: 8736,
				and: 8743,
				or: 8744,
				cap: 8745,
				cup: 8746,
				'int': 8747,
				there4: 8756,
				sim: 8764,
				cong: 8773,
				asymp: 8776,
				ne: 8800,
				equiv: 8801,
				le: 8804,
				ge: 8805,
				sub: 8834,
				sup: 8835,
				nsub: 8836,
				sube: 8838,
				supe: 8839,
				oplus: 8853,
				otimes: 8855,
				perp: 8869,
				sdot: 8901,
				lceil: 8968,
				rceil: 8969,
				lfloor: 8970,
				rfloor: 8971,
				lang: 9001,
				rang: 9002,
				loz: 9674,
				spades: 9824,
				clubs: 9827,
				hearts: 9829,
				diams: 9830
			};
			controlCharacters = [
				8364,
				129,
				8218,
				402,
				8222,
				8230,
				8224,
				8225,
				710,
				8240,
				352,
				8249,
				338,
				141,
				381,
				143,
				144,
				8216,
				8217,
				8220,
				8221,
				8226,
				8211,
				8212,
				732,
				8482,
				353,
				8250,
				339,
				157,
				382,
				376
			];
			entityPattern = new RegExp( '&(#?(?:x[\\w\\d]+|\\d+|' + Object.keys( htmlEntities ).join( '|' ) + '));?', 'g' );
			__export = function decodeCharacterReferences( html ) {
				return html.replace( entityPattern, function( match, entity ) {
					var code;
					// Handle named entities
					if ( entity[ 0 ] !== '#' ) {
						code = htmlEntities[ entity ];
					} else if ( entity[ 1 ] === 'x' ) {
						code = parseInt( entity.substring( 2 ), 16 );
					} else {
						code = parseInt( entity.substring( 1 ), 10 );
					}
					if ( !code ) {
						return match;
					}
					return String.fromCharCode( validateCode( code ) );
				} );
			};
			// some code points are verboten. If we were inserting HTML, the browser would replace the illegal
			// code points with alternatives in some cases - since we're bypassing that mechanism, we need
			// to replace them ourselves
			//
			// Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters
			function validateCode( code ) {
				if ( !code ) {
					return 65533;
				}
				// line feed becomes generic whitespace
				if ( code === 10 ) {
					return 32;
				}
				// ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)
				if ( code < 128 ) {
					return code;
				}
				// code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need
				// to correct the mistake or we'll end up with missing  signs and so on
				if ( code <= 159 ) {
					return controlCharacters[ code - 128 ];
				}
				// basic multilingual plane
				if ( code < 55296 ) {
					return code;
				}
				// UTF-16 surrogate halves
				if ( code <= 57343 ) {
					return 65533;
				}
				// rest of the basic multilingual plane
				if ( code <= 65535 ) {
					return code;
				}
				return 65533;
			}
			return __export;
		}( legacy );

		/* parse/converters/text.js */
		var text = function( getLowestIndex, decodeCharacterReferences ) {

			return function( parser ) {
				var index, remaining, disallowed, barrier;
				remaining = parser.remaining();
				barrier = parser.inside ? '</' + parser.inside : '<';
				if ( parser.inside && !parser.interpolate[ parser.inside ] ) {
					index = remaining.indexOf( barrier );
				} else {
					disallowed = [
						parser.delimiters[ 0 ],
						parser.tripleDelimiters[ 0 ],
						parser.staticDelimiters[ 0 ],
						parser.staticTripleDelimiters[ 0 ]
					];
					// http://developers.whatwg.org/syntax.html#syntax-attributes
					if ( parser.inAttribute === true ) {
						// we're inside an unquoted attribute value
						disallowed.push( '"', '\'', '=', '<', '>', '`' );
					} else if ( parser.inAttribute ) {
						// quoted attribute value
						disallowed.push( parser.inAttribute );
					} else {
						disallowed.push( barrier );
					}
					index = getLowestIndex( remaining, disallowed );
				}
				if ( !index ) {
					return null;
				}
				if ( index === -1 ) {
					index = remaining.length;
				}
				parser.pos += index;
				return parser.inside ? remaining.substr( 0, index ) : decodeCharacterReferences( remaining.substr( 0, index ) );
			};
		}( getLowestIndex, decodeCharacterReferences );

		/* parse/converters/element/closingTag.js */
		var closingTag = function( types ) {

			var closingTagPattern = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\-]*)\s*\>/;
			return function( parser ) {
				var tag;
				// are we looking at a closing tag?
				if ( !parser.matchString( '</' ) ) {
					return null;
				}
				if ( tag = parser.matchPattern( closingTagPattern ) ) {
					return {
						t: types.CLOSING_TAG,
						e: tag
					};
				}
				// We have an illegal closing tag, report it
				parser.pos -= 2;
				parser.error( 'Illegal closing tag' );
			};
		}( types );

		/* parse/converters/element/attribute.js */
		var attribute = function( getLowestIndex, getMustache, decodeCharacterReferences ) {

			var __export;
			var attributeNamePattern = /^[^\s"'>\/=]+/,
				unquotedAttributeValueTextPattern = /^[^\s"'=<>`]+/;
			__export = getAttribute;

			function getAttribute( parser ) {
				var attr, name, value;
				parser.allowWhitespace();
				name = parser.matchPattern( attributeNamePattern );
				if ( !name ) {
					return null;
				}
				attr = {
					name: name
				};
				value = getAttributeValue( parser );
				if ( value ) {
					attr.value = value;
				}
				return attr;
			}

			function getAttributeValue( parser ) {
				var start, valueStart, startDepth, value;
				start = parser.pos;
				parser.allowWhitespace();
				if ( !parser.matchString( '=' ) ) {
					parser.pos = start;
					return null;
				}
				parser.allowWhitespace();
				valueStart = parser.pos;
				startDepth = parser.sectionDepth;
				value = getQuotedAttributeValue( parser, '\'' ) || getQuotedAttributeValue( parser, '"' ) || getUnquotedAttributeValue( parser );
				if ( parser.sectionDepth !== startDepth ) {
					parser.pos = valueStart;
					parser.error( 'An attribute value must contain as many opening section tags as closing section tags' );
				}
				if ( value === null ) {
					parser.pos = start;
					return null;
				}
				if ( !value.length ) {
					return null;
				}
				if ( value.length === 1 && typeof value[ 0 ] === 'string' ) {
					return decodeCharacterReferences( value[ 0 ] );
				}
				return value;
			}

			function getUnquotedAttributeValueToken( parser ) {
				var start, text, haystack, needles, index;
				start = parser.pos;
				text = parser.matchPattern( unquotedAttributeValueTextPattern );
				if ( !text ) {
					return null;
				}
				haystack = text;
				needles = [
					parser.delimiters[ 0 ],
					parser.tripleDelimiters[ 0 ],
					parser.staticDelimiters[ 0 ],
					parser.staticTripleDelimiters[ 0 ]
				];
				if ( ( index = getLowestIndex( haystack, needles ) ) !== -1 ) {
					text = text.substr( 0, index );
					parser.pos = start + text.length;
				}
				return text;
			}

			function getUnquotedAttributeValue( parser ) {
				var tokens, token;
				parser.inAttribute = true;
				tokens = [];
				token = getMustache( parser ) || getUnquotedAttributeValueToken( parser );
				while ( token !== null ) {
					tokens.push( token );
					token = getMustache( parser ) || getUnquotedAttributeValueToken( parser );
				}
				if ( !tokens.length ) {
					return null;
				}
				parser.inAttribute = false;
				return tokens;
			}

			function getQuotedAttributeValue( parser, quoteMark ) {
				var start, tokens, token;
				start = parser.pos;
				if ( !parser.matchString( quoteMark ) ) {
					return null;
				}
				parser.inAttribute = quoteMark;
				tokens = [];
				token = getMustache( parser ) || getQuotedStringToken( parser, quoteMark );
				while ( token !== null ) {
					tokens.push( token );
					token = getMustache( parser ) || getQuotedStringToken( parser, quoteMark );
				}
				if ( !parser.matchString( quoteMark ) ) {
					parser.pos = start;
					return null;
				}
				parser.inAttribute = false;
				return tokens;
			}

			function getQuotedStringToken( parser, quoteMark ) {
				var start, index, haystack, needles;
				start = parser.pos;
				haystack = parser.remaining();
				needles = [
					quoteMark,
					parser.delimiters[ 0 ],
					parser.tripleDelimiters[ 0 ],
					parser.staticDelimiters[ 0 ],
					parser.staticTripleDelimiters[ 0 ]
				];
				index = getLowestIndex( haystack, needles );
				if ( index === -1 ) {
					parser.error( 'Quoted attribute value must have a closing quote' );
				}
				if ( !index ) {
					return null;
				}
				parser.pos += index;
				return haystack.substr( 0, index );
			}
			return __export;
		}( getLowestIndex, mustache, decodeCharacterReferences );

		/* utils/parseJSON.js */
		var parseJSON = function( Parser, getStringLiteral, getKey ) {

			var JsonParser, specials, specialsPattern, numberPattern, placeholderPattern, placeholderAtStartPattern, onlyWhitespace;
			specials = {
				'true': true,
				'false': false,
				'undefined': undefined,
				'null': null
			};
			specialsPattern = new RegExp( '^(?:' + Object.keys( specials ).join( '|' ) + ')' );
			numberPattern = /^(?:[+-]?)(?:(?:(?:0|[1-9]\d*)?\.\d+)|(?:(?:0|[1-9]\d*)\.)|(?:0|[1-9]\d*))(?:[eE][+-]?\d+)?/;
			placeholderPattern = /\$\{([^\}]+)\}/g;
			placeholderAtStartPattern = /^\$\{([^\}]+)\}/;
			onlyWhitespace = /^\s*$/;
			JsonParser = Parser.extend( {
				init: function( str, options ) {
					this.values = options.values;
					this.allowWhitespace();
				},
				postProcess: function( result ) {
					if ( result.length !== 1 || !onlyWhitespace.test( this.leftover ) ) {
						return null;
					}
					return {
						value: result[ 0 ].v
					};
				},
				converters: [

					function getPlaceholder( parser ) {
						var placeholder;
						if ( !parser.values ) {
							return null;
						}
						placeholder = parser.matchPattern( placeholderAtStartPattern );
						if ( placeholder && parser.values.hasOwnProperty( placeholder ) ) {
							return {
								v: parser.values[ placeholder ]
							};
						}
					},
					function getSpecial( parser ) {
						var special;
						if ( special = parser.matchPattern( specialsPattern ) ) {
							return {
								v: specials[ special ]
							};
						}
					},
					function getNumber( parser ) {
						var number;
						if ( number = parser.matchPattern( numberPattern ) ) {
							return {
								v: +number
							};
						}
					},
					function getString( parser ) {
						var stringLiteral = getStringLiteral( parser ),
							values;
						if ( stringLiteral && ( values = parser.values ) ) {
							return {
								v: stringLiteral.v.replace( placeholderPattern, function( match, $1 ) {
									return $1 in values ? values[ $1 ] : $1;
								} )
							};
						}
						return stringLiteral;
					},
					function getObject( parser ) {
						var result, pair;
						if ( !parser.matchString( '{' ) ) {
							return null;
						}
						result = {};
						parser.allowWhitespace();
						if ( parser.matchString( '}' ) ) {
							return {
								v: result
							};
						}
						while ( pair = getKeyValuePair( parser ) ) {
							result[ pair.key ] = pair.value;
							parser.allowWhitespace();
							if ( parser.matchString( '}' ) ) {
								return {
									v: result
								};
							}
							if ( !parser.matchString( ',' ) ) {
								return null;
							}
						}
						return null;
					},
					function getArray( parser ) {
						var result, valueToken;
						if ( !parser.matchString( '[' ) ) {
							return null;
						}
						result = [];
						parser.allowWhitespace();
						if ( parser.matchString( ']' ) ) {
							return {
								v: result
							};
						}
						while ( valueToken = parser.read() ) {
							result.push( valueToken.v );
							parser.allowWhitespace();
							if ( parser.matchString( ']' ) ) {
								return {
									v: result
								};
							}
							if ( !parser.matchString( ',' ) ) {
								return null;
							}
							parser.allowWhitespace();
						}
						return null;
					}
				]
			} );

			function getKeyValuePair( parser ) {
				var key, valueToken, pair;
				parser.allowWhitespace();
				key = getKey( parser );
				if ( !key ) {
					return null;
				}
				pair = {
					key: key
				};
				parser.allowWhitespace();
				if ( !parser.matchString( ':' ) ) {
					return null;
				}
				parser.allowWhitespace();
				valueToken = parser.read();
				if ( !valueToken ) {
					return null;
				}
				pair.value = valueToken.v;
				return pair;
			}
			return function( str, values ) {
				var parser = new JsonParser( str, {
					values: values
				} );
				return parser.result;
			};
		}( Parser, stringLiteral, key );

		/* parse/converters/element/processDirective.js */
		var processDirective = function( Parser, conditional, flattenExpression, parseJSON ) {

			var methodCallPattern = /^([a-zA-Z_$][a-zA-Z_$0-9]*)\(/,
				ExpressionParser;
			ExpressionParser = Parser.extend( {
				converters: [ conditional ]
			} );
			// TODO clean this up, it's shocking
			return function( tokens ) {
				var result, match, parser, args, token, colonIndex, directiveName, directiveArgs, parsed;
				if ( typeof tokens === 'string' ) {
					if ( match = methodCallPattern.exec( tokens ) ) {
						result = {
							m: match[ 1 ]
						};
						args = '[' + tokens.slice( result.m.length + 1, -1 ) + ']';
						parser = new ExpressionParser( args );
						result.a = flattenExpression( parser.result[ 0 ] );
						return result;
					}
					if ( tokens.indexOf( ':' ) === -1 ) {
						return tokens.trim();
					}
					tokens = [ tokens ];
				}
				result = {};
				directiveName = [];
				directiveArgs = [];
				if ( tokens ) {
					while ( tokens.length ) {
						token = tokens.shift();
						if ( typeof token === 'string' ) {
							colonIndex = token.indexOf( ':' );
							if ( colonIndex === -1 ) {
								directiveName.push( token );
							} else {
								// is the colon the first character?
								if ( colonIndex ) {
									// no
									directiveName.push( token.substr( 0, colonIndex ) );
								}
								// if there is anything after the colon in this token, treat
								// it as the first token of the directiveArgs fragment
								if ( token.length > colonIndex + 1 ) {
									directiveArgs[ 0 ] = token.substring( colonIndex + 1 );
								}
								break;
							}
						} else {
							directiveName.push( token );
						}
					}
					directiveArgs = directiveArgs.concat( tokens );
				}
				if ( !directiveName.length ) {
					result = '';
				} else if ( directiveArgs.length || typeof directiveName !== 'string' ) {
					result = {
						// TODO is this really necessary? just use the array
						n: directiveName.length === 1 && typeof directiveName[ 0 ] === 'string' ? directiveName[ 0 ] : directiveName
					};
					if ( directiveArgs.length === 1 && typeof directiveArgs[ 0 ] === 'string' ) {
						parsed = parseJSON( '[' + directiveArgs[ 0 ] + ']' );
						result.a = parsed ? parsed.value : directiveArgs[ 0 ].trim();
					} else {
						result.d = directiveArgs;
					}
				} else {
					result = directiveName;
				}
				return result;
			};
		}( Parser, conditional, flattenExpression, parseJSON );

		/* parse/converters/element.js */
		var element = function( types, voidElementNames, getMustache, getComment, getText, getClosingTag, getAttribute, processDirective ) {

			var __export;
			var tagNamePattern = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\-]*/,
				validTagNameFollower = /^[\s\n\/>]/,
				onPattern = /^on/,
				proxyEventPattern = /^on-([a-zA-Z\\*\\.$_][a-zA-Z\\*\\.$_0-9\-]+)$/,
				reservedEventNames = /^(?:change|reset|teardown|update|construct|config|init|render|unrender|detach|insert)$/,
				directives = {
					'intro-outro': 't0',
					intro: 't1',
					outro: 't2',
					decorator: 'o'
				},
				exclude = {
					exclude: true
				},
				converters, disallowedContents;
			// Different set of converters, because this time we're looking for closing tags
			converters = [
				getMustache,
				getComment,
				getElement,
				getText,
				getClosingTag
			];
			// based on http://developers.whatwg.org/syntax.html#syntax-tag-omission
			disallowedContents = {
				li: [ 'li' ],
				dt: [
					'dt',
					'dd'
				],
				dd: [
					'dt',
					'dd'
				],
				p: 'address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul'.split( ' ' ),
				rt: [
					'rt',
					'rp'
				],
				rp: [
					'rt',
					'rp'
				],
				optgroup: [ 'optgroup' ],
				option: [
					'option',
					'optgroup'
				],
				thead: [
					'tbody',
					'tfoot'
				],
				tbody: [
					'tbody',
					'tfoot'
				],
				tfoot: [ 'tbody' ],
				tr: [
					'tr',
					'tbody'
				],
				td: [
					'td',
					'th',
					'tr'
				],
				th: [
					'td',
					'th',
					'tr'
				]
			};
			__export = getElement;

			function getElement( parser ) {
				var start, element, lowerCaseName, directiveName, match, addProxyEvent, attribute, directive, selfClosing, children, child;
				start = parser.pos;
				if ( parser.inside || parser.inAttribute ) {
					return null;
				}
				if ( !parser.matchString( '<' ) ) {
					return null;
				}
				// if this is a closing tag, abort straight away
				if ( parser.nextChar() === '/' ) {
					return null;
				}
				element = {
					t: types.ELEMENT
				};
				if ( parser.includeLinePositions ) {
					element.p = parser.getLinePos( start );
				}
				if ( parser.matchString( '!' ) ) {
					element.y = 1;
				}
				// element name
				element.e = parser.matchPattern( tagNamePattern );
				if ( !element.e ) {
					return null;
				}
				// next character must be whitespace, closing solidus or '>'
				if ( !validTagNameFollower.test( parser.nextChar() ) ) {
					parser.error( 'Illegal tag name' );
				}
				addProxyEvent = function( name, directive ) {
					var directiveName = directive.n || directive;
					if ( reservedEventNames.test( directiveName ) ) {
						parser.pos -= directiveName.length;
						parser.error( 'Cannot use reserved event names (change, reset, teardown, update, construct, config, init, render, unrender, detach, insert)' );
					}
					element.v[ name ] = directive;
				};
				parser.allowWhitespace();
				// directives and attributes
				while ( attribute = getMustache( parser ) || getAttribute( parser ) ) {
					// regular attributes
					if ( attribute.name ) {
						// intro, outro, decorator
						if ( directiveName = directives[ attribute.name ] ) {
							element[ directiveName ] = processDirective( attribute.value );
						} else if ( match = proxyEventPattern.exec( attribute.name ) ) {
							if ( !element.v )
								element.v = {};
							directive = processDirective( attribute.value );
							addProxyEvent( match[ 1 ], directive );
						} else {
							if ( !parser.sanitizeEventAttributes || !onPattern.test( attribute.name ) ) {
								if ( !element.a )
									element.a = {};
								element.a[ attribute.name ] = attribute.value || 0;
							}
						}
					} else {
						if ( !element.m )
							element.m = [];
						element.m.push( attribute );
					}
					parser.allowWhitespace();
				}
				// allow whitespace before closing solidus
				parser.allowWhitespace();
				// self-closing solidus?
				if ( parser.matchString( '/' ) ) {
					selfClosing = true;
				}
				// closing angle bracket
				if ( !parser.matchString( '>' ) ) {
					return null;
				}
				lowerCaseName = element.e.toLowerCase();
				if ( !selfClosing && !voidElementNames.test( element.e ) ) {
					// Special case - if we open a script element, further tags should
					// be ignored unless they're a closing script element
					if ( lowerCaseName === 'script' || lowerCaseName === 'style' ) {
						parser.inside = lowerCaseName;
					}
					children = [];
					while ( canContain( lowerCaseName, parser.remaining() ) && ( child = parser.read( converters ) ) ) {
						// Special case - closing section tag
						if ( child.t === types.CLOSING ) {
							break;
						}
						if ( child.t === types.CLOSING_TAG ) {
							break;
						}
						children.push( child );
					}
					if ( children.length ) {
						element.f = children;
					}
				}
				parser.inside = null;
				if ( parser.sanitizeElements && parser.sanitizeElements.indexOf( lowerCaseName ) !== -1 ) {
					return exclude;
				}
				return element;
			}

			function canContain( name, remaining ) {
				var match, disallowed;
				match = /^<([a-zA-Z][a-zA-Z0-9]*)/.exec( remaining );
				disallowed = disallowedContents[ name ];
				if ( !match || !disallowed ) {
					return true;
				}
				return !~disallowed.indexOf( match[ 1 ].toLowerCase() );
			}
			return __export;
		}( types, voidElementNames, mustache, comment, text, closingTag, attribute, processDirective );

		/* parse/utils/trimWhitespace.js */
		var trimWhitespace = function() {

			var leadingWhitespace = /^[ \t\f\r\n]+/,
				trailingWhitespace = /[ \t\f\r\n]+$/;
			return function( items, leading, trailing ) {
				var item;
				if ( leading ) {
					item = items[ 0 ];
					if ( typeof item === 'string' ) {
						item = item.replace( leadingWhitespace, '' );
						if ( !item ) {
							items.shift();
						} else {
							items[ 0 ] = item;
						}
					}
				}
				if ( trailing ) {
					item = items[ items.length - 1 ];
					if ( typeof item === 'string' ) {
						item = item.replace( trailingWhitespace, '' );
						if ( !item ) {
							items.pop();
						} else {
							items[ items.length - 1 ] = item;
						}
					}
				}
			};
		}();

		/* parse/utils/stripStandalones.js */
		var stripStandalones = function( types ) {

			var __export;
			var leadingLinebreak = /^\s*\r?\n/,
				trailingLinebreak = /\r?\n\s*$/;
			__export = function( items ) {
				var i, current, backOne, backTwo, lastSectionItem;
				for ( i = 1; i < items.length; i += 1 ) {
					current = items[ i ];
					backOne = items[ i - 1 ];
					backTwo = items[ i - 2 ];
					// if we're at the end of a [text][comment][text] sequence...
					if ( isString( current ) && isComment( backOne ) && isString( backTwo ) ) {
						// ... and the comment is a standalone (i.e. line breaks either side)...
						if ( trailingLinebreak.test( backTwo ) && leadingLinebreak.test( current ) ) {
							// ... then we want to remove the whitespace after the first line break
							items[ i - 2 ] = backTwo.replace( trailingLinebreak, '\n' );
							// and the leading line break of the second text token
							items[ i ] = current.replace( leadingLinebreak, '' );
						}
					}
					// if the current item is a section, and it is preceded by a linebreak, and
					// its first item is a linebreak...
					if ( isSection( current ) && isString( backOne ) ) {
						if ( trailingLinebreak.test( backOne ) && isString( current.f[ 0 ] ) && leadingLinebreak.test( current.f[ 0 ] ) ) {
							items[ i - 1 ] = backOne.replace( trailingLinebreak, '\n' );
							current.f[ 0 ] = current.f[ 0 ].replace( leadingLinebreak, '' );
						}
					}
					// if the last item was a section, and it is followed by a linebreak, and
					// its last item is a linebreak...
					if ( isString( current ) && isSection( backOne ) ) {
						lastSectionItem = backOne.f[ backOne.f.length - 1 ];
						if ( isString( lastSectionItem ) && trailingLinebreak.test( lastSectionItem ) && leadingLinebreak.test( current ) ) {
							backOne.f[ backOne.f.length - 1 ] = lastSectionItem.replace( trailingLinebreak, '\n' );
							items[ i ] = current.replace( leadingLinebreak, '' );
						}
					}
				}
				return items;
			};

			function isString( item ) {
				return typeof item === 'string';
			}

			function isComment( item ) {
				return item.t === types.COMMENT || item.t === types.DELIMCHANGE;
			}

			function isSection( item ) {
				return ( item.t === types.SECTION || item.t === types.INVERTED ) && item.f;
			}
			return __export;
		}( types );

		/* utils/escapeRegExp.js */
		var escapeRegExp = function() {

			var pattern = /[-/\\^$*+?.()|[\]{}]/g;
			return function escapeRegExp( str ) {
				return str.replace( pattern, '\\$&' );
			};
		}();

		/* parse/_parse.js */
		var parse = function( types, Parser, mustache, comment, element, text, trimWhitespace, stripStandalones, escapeRegExp ) {

			var __export;
			var StandardParser, parse, contiguousWhitespace = /[ \t\f\r\n]+/g,
				preserveWhitespaceElements = /^(?:pre|script|style|textarea)$/i,
				leadingWhitespace = /^\s+/,
				trailingWhitespace = /\s+$/;
			StandardParser = Parser.extend( {
				init: function( str, options ) {
					// config
					setDelimiters( options, this );
					this.sectionDepth = 0;
					this.interpolate = {
						script: !options.interpolate || options.interpolate.script !== false,
						style: !options.interpolate || options.interpolate.style !== false
					};
					if ( options.sanitize === true ) {
						options.sanitize = {
							// blacklist from https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json
							elements: 'applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title'.split( ' ' ),
							eventAttributes: true
						};
					}
					this.sanitizeElements = options.sanitize && options.sanitize.elements;
					this.sanitizeEventAttributes = options.sanitize && options.sanitize.eventAttributes;
					this.includeLinePositions = options.includeLinePositions;
				},
				postProcess: function( items, options ) {
					if ( this.sectionDepth > 0 ) {
						this.error( 'A section was left open' );
					}
					cleanup( items, options.stripComments !== false, options.preserveWhitespace, !options.preserveWhitespace, !options.preserveWhitespace, options.rewriteElse !== false );
					return items;
				},
				converters: [
					mustache,
					comment,
					element,
					text
				]
			} );
			parse = function( template ) {
				var options = arguments[ 1 ];
				if ( options === void 0 )
					options = {};
				var result, remaining, partials, name, startMatch, endMatch, inlinePartialStart, inlinePartialEnd;
				setDelimiters( options );
				inlinePartialStart = new RegExp( '<!--\\s*' + escapeRegExp( options.delimiters[ 0 ] ) + '\\s*>\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*' + escapeRegExp( options.delimiters[ 1 ] ) + '\\s*-->' );
				inlinePartialEnd = new RegExp( '<!--\\s*' + escapeRegExp( options.delimiters[ 0 ] ) + '\\s*\\/\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*' + escapeRegExp( options.delimiters[ 1 ] ) + '\\s*-->' );
				result = {
					v: 1
				};
				if ( inlinePartialStart.test( template ) ) {
					remaining = template;
					template = '';
					while ( startMatch = inlinePartialStart.exec( remaining ) ) {
						name = startMatch[ 1 ];
						template += remaining.substr( 0, startMatch.index );
						remaining = remaining.substring( startMatch.index + startMatch[ 0 ].length );
						endMatch = inlinePartialEnd.exec( remaining );
						if ( !endMatch || endMatch[ 1 ] !== name ) {
							throw new Error( 'Inline partials must have a closing delimiter, and cannot be nested. Expected closing for "' + name + '", but ' + ( endMatch ? 'instead found "' + endMatch[ 1 ] + '"' : ' no closing found' ) );
						}
						( partials || ( partials = {} ) )[ name ] = new StandardParser( remaining.substr( 0, endMatch.index ), options ).result;
						remaining = remaining.substring( endMatch.index + endMatch[ 0 ].length );
					}
					template += remaining;
					result.p = partials;
				}
				result.t = new StandardParser( template, options ).result;
				return result;
			};
			__export = parse;

			function cleanup( items, stripComments, preserveWhitespace, removeLeadingWhitespace, removeTrailingWhitespace, rewriteElse ) {
				var i, item, previousItem, nextItem, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, unlessBlock, key;
				// First pass - remove standalones and comments etc
				stripStandalones( items );
				i = items.length;
				while ( i-- ) {
					item = items[ i ];
					// Remove delimiter changes, unsafe elements etc
					if ( item.exclude ) {
						items.splice( i, 1 );
					} else if ( stripComments && item.t === types.COMMENT ) {
						items.splice( i, 1 );
					}
				}
				// If necessary, remove leading and trailing whitespace
				trimWhitespace( items, removeLeadingWhitespace, removeTrailingWhitespace );
				i = items.length;
				while ( i-- ) {
					item = items[ i ];
					// Recurse
					if ( item.f ) {
						preserveWhitespaceInsideFragment = preserveWhitespace || item.t === types.ELEMENT && preserveWhitespaceElements.test( item.e );
						if ( !preserveWhitespaceInsideFragment ) {
							previousItem = items[ i - 1 ];
							nextItem = items[ i + 1 ];
							// if the previous item was a text item with trailing whitespace,
							// remove leading whitespace inside the fragment
							if ( !previousItem || typeof previousItem === 'string' && trailingWhitespace.test( previousItem ) ) {
								removeLeadingWhitespaceInsideFragment = true;
							}
							// and vice versa
							if ( !nextItem || typeof nextItem === 'string' && leadingWhitespace.test( nextItem ) ) {
								removeTrailingWhitespaceInsideFragment = true;
							}
						}
						cleanup( item.f, stripComments, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, rewriteElse );
					}
					// Split if-else blocks into two (an if, and an unless)
					if ( item.l ) {
						cleanup( item.l, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, rewriteElse );
						if ( rewriteElse ) {
							unlessBlock = {
								t: 4,
								n: types.SECTION_UNLESS,
								f: item.l
							};
							// copy the conditional based on its type
							if ( item.r ) {
								unlessBlock.r = item.r;
							}
							if ( item.x ) {
								unlessBlock.x = item.x;
							}
							if ( item.rx ) {
								unlessBlock.rx = item.rx;
							}
							items.splice( i + 1, 0, unlessBlock );
							delete item.l;
						}
					}
					// Clean up element attributes
					if ( item.a ) {
						for ( key in item.a ) {
							if ( item.a.hasOwnProperty( key ) && typeof item.a[ key ] !== 'string' ) {
								cleanup( item.a[ key ], stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, rewriteElse );
							}
						}
					}
				}
				// final pass - fuse text nodes together
				i = items.length;
				while ( i-- ) {
					if ( typeof items[ i ] === 'string' ) {
						if ( typeof items[ i + 1 ] === 'string' ) {
							items[ i ] = items[ i ] + items[ i + 1 ];
							items.splice( i + 1, 1 );
						}
						if ( !preserveWhitespace ) {
							items[ i ] = items[ i ].replace( contiguousWhitespace, ' ' );
						}
						if ( items[ i ] === '' ) {
							items.splice( i, 1 );
						}
					}
				}
			}

			function setDelimiters( source ) {
				var target = arguments[ 1 ];
				if ( target === void 0 )
					target = source;
				target.delimiters = source.delimiters || [
					'{{',
					'}}'
				];
				target.tripleDelimiters = source.tripleDelimiters || [
					'{{{',
					'}}}'
				];
				target.staticDelimiters = source.staticDelimiters || [
					'[[',
					']]'
				];
				target.staticTripleDelimiters = source.staticTripleDelimiters || [
					'[[[',
					']]]'
				];
			}
			return __export;
		}( types, Parser, mustache, comment, element, text, trimWhitespace, stripStandalones, escapeRegExp );

		/* config/options/groups/optionGroup.js */
		var optionGroup = function() {

			return function createOptionGroup( keys, config ) {
				var group = keys.map( config );
				keys.forEach( function( key, i ) {
					group[ key ] = group[ i ];
				} );
				return group;
			};
		}( legacy );

		/* config/options/groups/parseOptions.js */
		var parseOptions = function( optionGroup ) {

			var keys, parseOptions;
			keys = [
				'preserveWhitespace',
				'sanitize',
				'stripComments',
				'delimiters',
				'tripleDelimiters',
				'interpolate'
			];
			parseOptions = optionGroup( keys, function( key ) {
				return key;
			} );
			return parseOptions;
		}( optionGroup );

		/* config/options/template/parser.js */
		var parser = function( errors, isClient, parse, create, parseOptions ) {

			var parser = {
				parse: doParse,
				fromId: fromId,
				isHashedId: isHashedId,
				isParsed: isParsed,
				getParseOptions: getParseOptions,
				createHelper: createHelper
			};

			function createHelper( parseOptions ) {
				var helper = create( parser );
				helper.parse = function( template, options ) {
					return doParse( template, options || parseOptions );
				};
				return helper;
			}

			function doParse( template, parseOptions ) {
				if ( !parse ) {
					throw new Error( errors.missingParser );
				}
				return parse( template, parseOptions || this.options );
			}

			function fromId( id, options ) {
				var template;
				if ( !isClient ) {
					if ( options && options.noThrow ) {
						return;
					}
					throw new Error( 'Cannot retrieve template #' + id + ' as Ractive is not running in a browser.' );
				}
				if ( isHashedId( id ) ) {
					id = id.substring( 1 );
				}
				if ( !( template = document.getElementById( id ) ) ) {
					if ( options && options.noThrow ) {
						return;
					}
					throw new Error( 'Could not find template element with id #' + id );
				}
				if ( template.tagName.toUpperCase() !== 'SCRIPT' ) {
					if ( options && options.noThrow ) {
						return;
					}
					throw new Error( 'Template element with id #' + id + ', must be a <script> element' );
				}
				return template.innerHTML;
			}

			function isHashedId( id ) {
				return id && id.charAt( 0 ) === '#';
			}

			function isParsed( template ) {
				return !( typeof template === 'string' );
			}

			function getParseOptions( ractive ) {
				// Could be Ractive or a Component
				if ( ractive.defaults ) {
					ractive = ractive.defaults;
				}
				return parseOptions.reduce( function( val, key ) {
					val[ key ] = ractive[ key ];
					return val;
				}, {} );
			}
			return parser;
		}( errors, isClient, parse, create, parseOptions );

		/* config/options/template/template.js */
		var template = function( parser, parse ) {

			var templateConfig = {
				name: 'template',
				extend: function extend( Parent, proto, options ) {
					var template;
					// only assign if exists
					if ( 'template' in options ) {
						template = options.template;
						if ( typeof template === 'function' ) {
							proto.template = template;
						} else {
							proto.template = parseIfString( template, proto );
						}
					}
				},
				init: function init( Parent, ractive, options ) {
					var template, fn;
					// TODO because of prototypal inheritance, we might just be able to use
					// ractive.template, and not bother passing through the Parent object.
					// At present that breaks the test mocks' expectations
					template = 'template' in options ? options.template : Parent.prototype.template;
					if ( typeof template === 'function' ) {
						fn = template;
						template = getDynamicTemplate( ractive, fn );
						ractive._config.template = {
							fn: fn,
							result: template
						};
					}
					template = parseIfString( template, ractive );
					// TODO the naming of this is confusing - ractive.template refers to [...],
					// but Component.prototype.template refers to {v:1,t:[],p:[]}...
					// it's unnecessary, because the developer never needs to access
					// ractive.template
					ractive.template = template.t;
					if ( template.p ) {
						extendPartials( ractive.partials, template.p );
					}
				},
				reset: function( ractive ) {
					var result = resetValue( ractive ),
						parsed;
					if ( result ) {
						parsed = parseIfString( result, ractive );
						ractive.template = parsed.t;
						extendPartials( ractive.partials, parsed.p, true );
						return true;
					}
				}
			};

			function resetValue( ractive ) {
				var initial = ractive._config.template,
					result;
				// If this isn't a dynamic template, there's nothing to do
				if ( !initial || !initial.fn ) {
					return;
				}
				result = getDynamicTemplate( ractive, initial.fn );
				// TODO deep equality check to prevent unnecessary re-rendering
				// in the case of already-parsed templates
				if ( result !== initial.result ) {
					initial.result = result;
					result = parseIfString( result, ractive );
					return result;
				}
			}

			function getDynamicTemplate( ractive, fn ) {
				var helper = parser.createHelper( parser.getParseOptions( ractive ) );
				return fn.call( ractive, ractive.data, helper );
			}

			function parseIfString( template, ractive ) {
				if ( typeof template === 'string' ) {
					// ID of an element containing the template?
					if ( template[ 0 ] === '#' ) {
						template = parser.fromId( template );
					}
					template = parse( template, parser.getParseOptions( ractive ) );
				} else if ( template.v !== 1 ) {
					throw new Error( 'Mismatched template version! Please ensure you are using the latest version of Ractive.js in your build process as well as in your app' );
				}
				return template;
			}

			function extendPartials( existingPartials, newPartials, overwrite ) {
				if ( !newPartials )
					return;
				// TODO there's an ambiguity here - we need to overwrite in the `reset()`
				// case, but not initially...
				for ( var key in newPartials ) {
					if ( overwrite || !existingPartials.hasOwnProperty( key ) ) {
						existingPartials[ key ] = newPartials[ key ];
					}
				}
			}
			return templateConfig;
		}( parser, parse );

		/* config/options/Registry.js */
		var Registry = function( create ) {

			function Registry( name, useDefaults ) {
				this.name = name;
				this.useDefaults = useDefaults;
			}
			Registry.prototype = {
				constructor: Registry,
				extend: function( Parent, proto, options ) {
					this.configure( this.useDefaults ? Parent.defaults : Parent, this.useDefaults ? proto : proto.constructor, options );
				},
				init: function( Parent, ractive, options ) {
					this.configure( this.useDefaults ? Parent.defaults : Parent, ractive, options );
				},
				configure: function( Parent, target, options ) {
					var name = this.name,
						option = options[ name ],
						registry;
					registry = create( Parent[ name ] );
					for ( var key in option ) {
						registry[ key ] = option[ key ];
					}
					target[ name ] = registry;
				},
				reset: function( ractive ) {
					var registry = ractive[ this.name ];
					var changed = false;
					Object.keys( registry ).forEach( function( key ) {
						var item = registry[ key ];
						if ( item._fn ) {
							if ( item._fn.isOwner ) {
								registry[ key ] = item._fn;
							} else {
								delete registry[ key ];
							}
							changed = true;
						}
					} );
					return changed;
				},
				findOwner: function( ractive, key ) {
					return ractive[ this.name ].hasOwnProperty( key ) ? ractive : this.findConstructor( ractive.constructor, key );
				},
				findConstructor: function( constructor, key ) {
					if ( !constructor ) {
						return;
					}
					return constructor[ this.name ].hasOwnProperty( key ) ? constructor : this.findConstructor( constructor._parent, key );
				},
				find: function( ractive, key ) {
					var this$0 = this;
					return recurseFind( ractive, function( r ) {
						return r[ this$0.name ][ key ];
					} );
				},
				findInstance: function( ractive, key ) {
					var this$0 = this;
					return recurseFind( ractive, function( r ) {
						return r[ this$0.name ][ key ] ? r : void 0;
					} );
				}
			};

			function recurseFind( ractive, fn ) {
				var find, parent;
				if ( find = fn( ractive ) ) {
					return find;
				}
				if ( !ractive.isolated && ( parent = ractive._parent ) ) {
					return recurseFind( parent, fn );
				}
			}
			return Registry;
		}( create, legacy );

		/* config/options/groups/registries.js */
		var registries = function( optionGroup, Registry ) {

			var keys = [
					'adaptors',
					'components',
					'computed',
					'decorators',
					'easing',
					'events',
					'interpolators',
					'partials',
					'transitions'
				],
				registries = optionGroup( keys, function( key ) {
					return new Registry( key, key === 'computed' );
				} );
			return registries;
		}( optionGroup, Registry );

		/* utils/noop.js */
		var noop = function() {};

		/* utils/wrapPrototypeMethod.js */
		var wrapPrototypeMethod = function( noop ) {

			var __export;
			__export = function wrap( parent, name, method ) {
				if ( !/_super/.test( method ) ) {
					return method;
				}
				var wrapper = function wrapSuper() {
					var superMethod = getSuperMethod( wrapper._parent, name ),
						hasSuper = '_super' in this,
						oldSuper = this._super,
						result;
					this._super = superMethod;
					result = method.apply( this, arguments );
					if ( hasSuper ) {
						this._super = oldSuper;
					} else {
						delete this._super;
					}
					return result;
				};
				wrapper._parent = parent;
				wrapper._method = method;
				return wrapper;
			};

			function getSuperMethod( parent, name ) {
				var method;
				if ( name in parent ) {
					var value = parent[ name ];
					if ( typeof value === 'function' ) {
						method = value;
					} else {
						method = function returnValue() {
							return value;
						};
					}
				} else {
					method = noop;
				}
				return method;
			}
			return __export;
		}( noop );

		/* config/deprecate.js */
		var deprecate = function( warn, isArray ) {

			function deprecate( options, deprecated, correct ) {
				if ( deprecated in options ) {
					if ( !( correct in options ) ) {
						warn( getMessage( deprecated, correct ) );
						options[ correct ] = options[ deprecated ];
					} else {
						throw new Error( getMessage( deprecated, correct, true ) );
					}
				}
			}

			function getMessage( deprecated, correct, isError ) {
				return 'options.' + deprecated + ' has been deprecated in favour of options.' + correct + '.' + ( isError ? ' You cannot specify both options, please use options.' + correct + '.' : '' );
			}

			function deprecateEventDefinitions( options ) {
				deprecate( options, 'eventDefinitions', 'events' );
			}

			function deprecateAdaptors( options ) {
				// Using extend with Component instead of options,
				// like Human.extend( Spider ) means adaptors as a registry
				// gets copied to options. So we have to check if actually an array
				if ( isArray( options.adaptors ) ) {
					deprecate( options, 'adaptors', 'adapt' );
				}
			}
			return function deprecateOptions( options ) {
				deprecate( options, 'beforeInit', 'onconstruct' );
				deprecate( options, 'init', 'onrender' );
				deprecate( options, 'complete', 'oncomplete' );
				deprecateEventDefinitions( options );
				deprecateAdaptors( options );
			};
		}( warn, isArray );

		/* config/config.js */
		var config = function( css, data, defaults, template, parseOptions, registries, wrapPrototype, deprecate ) {

			var custom, options, config, blacklisted;
			// would be nice to not have these here,
			// they get added during initialise, so for now we have
			// to make sure not to try and extend them.
			// Possibly, we could re-order and not add till later
			// in process.
			blacklisted = {
				'_parent': true,
				'_component': true
			};
			custom = {
				data: data,
				template: template,
				css: css
			};
			options = Object.keys( defaults ).filter( function( key ) {
				return !registries[ key ] && !custom[ key ] && !parseOptions[ key ];
			} );
			// this defines the order:
			config = [].concat( custom.data, parseOptions, options, registries, custom.template, custom.css );
			for ( var key in custom ) {
				config[ key ] = custom[ key ];
			}
			// for iteration
			config.keys = Object.keys( defaults ).concat( registries.map( function( r ) {
				return r.name;
			} ) ).concat( [ 'css' ] );
			// add these to blacklisted key's that we don't double extend
			config.keys.forEach( function( key ) {
				return blacklisted[ key ] = true;
			} );
			config.parseOptions = parseOptions;
			config.registries = registries;

			function customConfig( method, key, Parent, instance, options ) {
				custom[ key ][ method ]( Parent, instance, options );
			}
			config.extend = function( Parent, proto, options ) {
				configure( 'extend', Parent, proto, options );
			};
			config.init = function( Parent, ractive, options ) {
				configure( 'init', Parent, ractive, options );
			};

			function isStandardDefaultKey( key ) {
				return key in defaults && !( key in config.parseOptions ) && !( key in custom );
			}

			function configure( method, Parent, instance, options ) {
				deprecate( options );
				customConfig( method, 'data', Parent, instance, options );
				config.parseOptions.forEach( function( key ) {
					if ( key in options ) {
						instance[ key ] = options[ key ];
					}
				} );
				for ( var key in options ) {
					if ( isStandardDefaultKey( key ) ) {
						var value = options[ key ];
						instance[ key ] = typeof value === 'function' ? wrapPrototype( Parent.prototype, key, value ) : value;
					}
				}
				config.registries.forEach( function( registry ) {
					registry[ method ]( Parent, instance, options );
				} );
				customConfig( method, 'template', Parent, instance, options );
				customConfig( method, 'css', Parent, instance, options );
				extendOtherMethods( Parent.prototype, instance, options );
			}

			function extendOtherMethods( parent, instance, options ) {
				for ( var key in options ) {
					if ( !( key in blacklisted ) && options.hasOwnProperty( key ) ) {
						var member = options[ key ];
						// if this is a method that overwrites a method, wrap it:
						if ( typeof member === 'function' ) {
							member = wrapPrototype( parent, key, member );
						}
						instance[ key ] = member;
					}
				}
			}
			config.reset = function( ractive ) {
				return config.filter( function( c ) {
					return c.reset && c.reset( ractive );
				} ).map( function( c ) {
					return c.name;
				} );
			};
			config.getConstructTarget = function( ractive, options ) {
				if ( options.onconstruct ) {
					// pretend this object literal is the ractive instance
					return {
						onconstruct: wrapPrototype( ractive, 'onconstruct', options.onconstruct ).bind( ractive ),
						fire: ractive.fire.bind( ractive )
					};
				} else {
					return ractive;
				}
			};
			return config;
		}( css, data, options, template, parseOptions, registries, wrapPrototypeMethod, deprecate );

		/* shared/interpolate.js */
		var interpolate = function( circular, warn, interpolators, config ) {

			var __export;
			var interpolate = function( from, to, ractive, type ) {
				if ( from === to ) {
					return snap( to );
				}
				if ( type ) {
					var interpol = config.registries.interpolators.find( ractive, type );
					if ( interpol ) {
						return interpol( from, to ) || snap( to );
					}
					warn( 'Missing "' + type + '" interpolator. You may need to download a plugin from [TODO]' );
				}
				return interpolators.number( from, to ) || interpolators.array( from, to ) || interpolators.object( from, to ) || snap( to );
			};
			circular.interpolate = interpolate;
			__export = interpolate;

			function snap( to ) {
				return function() {
					return to;
				};
			}
			return __export;
		}( circular, warn, interpolators, config );

		/* Ractive/prototype/animate/Animation.js */
		var Ractive$animate_Animation = function( warn, runloop, interpolate ) {

			var Animation = function( options ) {
				var key;
				this.startTime = Date.now();
				// from and to
				for ( key in options ) {
					if ( options.hasOwnProperty( key ) ) {
						this[ key ] = options[ key ];
					}
				}
				this.interpolator = interpolate( this.from, this.to, this.root, this.interpolator );
				this.running = true;
				this.tick();
			};
			Animation.prototype = {
				tick: function() {
					var elapsed, t, value, timeNow, index, keypath;
					keypath = this.keypath;
					if ( this.running ) {
						timeNow = Date.now();
						elapsed = timeNow - this.startTime;
						if ( elapsed >= this.duration ) {
							if ( keypath !== null ) {
								runloop.start( this.root );
								this.root.viewmodel.set( keypath, this.to );
								runloop.end();
							}
							if ( this.step ) {
								this.step( 1, this.to );
							}
							this.complete( this.to );
							index = this.root._animations.indexOf( this );
							// TODO investigate why this happens
							if ( index === -1 ) {
								warn( 'Animation was not found' );
							}
							this.root._animations.splice( index, 1 );
							this.running = false;
							return false;
						}
						t = this.easing ? this.easing( elapsed / this.duration ) : elapsed / this.duration;
						if ( keypath !== null ) {
							value = this.interpolator( t );
							runloop.start( this.root );
							this.root.viewmodel.set( keypath, value );
							runloop.end();
						}
						if ( this.step ) {
							this.step( t, value );
						}
						return true;
					}
					return false;
				},
				stop: function() {
					var index;
					this.running = false;
					index = this.root._animations.indexOf( this );
					// TODO investigate why this happens
					if ( index === -1 ) {
						warn( 'Animation was not found' );
					}
					this.root._animations.splice( index, 1 );
				}
			};
			return Animation;
		}( warn, runloop, interpolate );

		/* Ractive/prototype/animate.js */
		var Ractive$animate = function( isEqual, Promise, normaliseKeypath, animations, Animation ) {

			var __export;
			var noop = function() {},
				noAnimation = {
					stop: noop
				};
			__export = function Ractive$animate( keypath, to, options ) {
				var promise, fulfilPromise, k, animation, animations, easing, duration, step, complete, makeValueCollector, currentValues, collectValue, dummy, dummyOptions;
				promise = new Promise( function( fulfil ) {
					fulfilPromise = fulfil;
				} );
				// animate multiple keypaths
				if ( typeof keypath === 'object' ) {
					options = to || {};
					easing = options.easing;
					duration = options.duration;
					animations = [];
					// we don't want to pass the `step` and `complete` handlers, as they will
					// run for each animation! So instead we'll store the handlers and create
					// our own...
					step = options.step;
					complete = options.complete;
					if ( step || complete ) {
						currentValues = {};
						options.step = null;
						options.complete = null;
						makeValueCollector = function( keypath ) {
							return function( t, value ) {
								currentValues[ keypath ] = value;
							};
						};
					}
					for ( k in keypath ) {
						if ( keypath.hasOwnProperty( k ) ) {
							if ( step || complete ) {
								collectValue = makeValueCollector( k );
								options = {
									easing: easing,
									duration: duration
								};
								if ( step ) {
									options.step = collectValue;
								}
							}
							options.complete = complete ? collectValue : noop;
							animations.push( animate( this, k, keypath[ k ], options ) );
						}
					}
					// Create a dummy animation, to facilitate step/complete
					// callbacks, and Promise fulfilment
					dummyOptions = {
						easing: easing,
						duration: duration
					};
					if ( step ) {
						dummyOptions.step = function( t ) {
							step( t, currentValues );
						};
					}
					if ( complete ) {
						promise.then( function( t ) {
							complete( t, currentValues );
						} );
					}
					dummyOptions.complete = fulfilPromise;
					dummy = animate( this, null, null, dummyOptions );
					animations.push( dummy );
					promise.stop = function() {
						var animation;
						while ( animation = animations.pop() ) {
							animation.stop();
						}
						if ( dummy ) {
							dummy.stop();
						}
					};
					return promise;
				}
				// animate a single keypath
				options = options || {};
				if ( options.complete ) {
					promise.then( options.complete );
				}
				options.complete = fulfilPromise;
				animation = animate( this, keypath, to, options );
				promise.stop = function() {
					animation.stop();
				};
				return promise;
			};

			function animate( root, keypath, to, options ) {
				var easing, duration, animation, from;
				if ( keypath ) {
					keypath = normaliseKeypath( keypath );
				}
				if ( keypath !== null ) {
					from = root.viewmodel.get( keypath );
				}
				// cancel any existing animation
				// TODO what about upstream/downstream keypaths?
				animations.abort( keypath, root );
				// don't bother animating values that stay the same
				if ( isEqual( from, to ) ) {
					if ( options.complete ) {
						options.complete( options.to );
					}
					return noAnimation;
				}
				// easing function
				if ( options.easing ) {
					if ( typeof options.easing === 'function' ) {
						easing = options.easing;
					} else {
						easing = root.easing[ options.easing ];
					}
					if ( typeof easing !== 'function' ) {
						easing = null;
					}
				}
				// duration
				duration = options.duration === undefined ? 400 : options.duration;
				// TODO store keys, use an internal set method
				animation = new Animation( {
					keypath: keypath,
					from: from,
					to: to,
					root: root,
					duration: duration,
					easing: easing,
					interpolator: options.interpolator,
					// TODO wrap callbacks if necessary, to use instance as context
					step: options.step,
					complete: options.complete
				} );
				animations.add( animation );
				root._animations.push( animation );
				return animation;
			}
			return __export;
		}( isEqual, Promise, normaliseKeypath, animations, Ractive$animate_Animation );

		/* Ractive/prototype/detach.js */
		var Ractive$detach = function( Hook, removeFromArray ) {

			var detachHook = new Hook( 'detach' );
			return function Ractive$detach() {
				if ( this.detached ) {
					return this.detached;
				}
				if ( this.el ) {
					removeFromArray( this.el.__ractive_instances__, this );
				}
				this.detached = this.fragment.detach();
				detachHook.fire( this );
				return this.detached;
			};
		}( Ractive$shared_hooks_Hook, removeFromArray );

		/* Ractive/prototype/find.js */
		var Ractive$find = function Ractive$find( selector ) {
			if ( !this.el ) {
				return null;
			}
			return this.fragment.find( selector );
		};

		/* utils/matches.js */
		var matches = function( isClient, vendors, createElement ) {

			var matches, div, methodNames, unprefixed, prefixed, i, j, makeFunction;
			if ( !isClient ) {
				matches = null;
			} else {
				div = createElement( 'div' );
				methodNames = [
					'matches',
					'matchesSelector'
				];
				makeFunction = function( methodName ) {
					return function( node, selector ) {
						return node[ methodName ]( selector );
					};
				};
				i = methodNames.length;
				while ( i-- && !matches ) {
					unprefixed = methodNames[ i ];
					if ( div[ unprefixed ] ) {
						matches = makeFunction( unprefixed );
					} else {
						j = vendors.length;
						while ( j-- ) {
							prefixed = vendors[ i ] + unprefixed.substr( 0, 1 ).toUpperCase() + unprefixed.substring( 1 );
							if ( div[ prefixed ] ) {
								matches = makeFunction( prefixed );
								break;
							}
						}
					}
				}
				// IE8...
				if ( !matches ) {
					matches = function( node, selector ) {
						var nodes, parentNode, i;
						parentNode = node.parentNode;
						if ( !parentNode ) {
							// empty dummy <div>
							div.innerHTML = '';
							parentNode = div;
							node = node.cloneNode();
							div.appendChild( node );
						}
						nodes = parentNode.querySelectorAll( selector );
						i = nodes.length;
						while ( i-- ) {
							if ( nodes[ i ] === node ) {
								return true;
							}
						}
						return false;
					};
				}
			}
			return matches;
		}( isClient, vendors, createElement );

		/* Ractive/prototype/shared/makeQuery/test.js */
		var Ractive$shared_makeQuery_test = function( matches ) {

			return function( item, noDirty ) {
				var itemMatches = this._isComponentQuery ? !this.selector || item.name === this.selector : matches( item.node, this.selector );
				if ( itemMatches ) {
					this.push( item.node || item.instance );
					if ( !noDirty ) {
						this._makeDirty();
					}
					return true;
				}
			};
		}( matches );

		/* Ractive/prototype/shared/makeQuery/cancel.js */
		var Ractive$shared_makeQuery_cancel = function() {
			var liveQueries, selector, index;
			liveQueries = this._root[ this._isComponentQuery ? 'liveComponentQueries' : 'liveQueries' ];
			selector = this.selector;
			index = liveQueries.indexOf( selector );
			if ( index !== -1 ) {
				liveQueries.splice( index, 1 );
				liveQueries[ selector ] = null;
			}
		};

		/* Ractive/prototype/shared/makeQuery/sortByItemPosition.js */
		var Ractive$shared_makeQuery_sortByItemPosition = function() {

			var __export;
			__export = function( a, b ) {
				var ancestryA, ancestryB, oldestA, oldestB, mutualAncestor, indexA, indexB, fragments, fragmentA, fragmentB;
				ancestryA = getAncestry( a.component || a._ractive.proxy );
				ancestryB = getAncestry( b.component || b._ractive.proxy );
				oldestA = ancestryA[ ancestryA.length - 1 ];
				oldestB = ancestryB[ ancestryB.length - 1 ];
				// remove items from the end of both ancestries as long as they are identical
				// - the final one removed is the closest mutual ancestor
				while ( oldestA && oldestA === oldestB ) {
					ancestryA.pop();
					ancestryB.pop();
					mutualAncestor = oldestA;
					oldestA = ancestryA[ ancestryA.length - 1 ];
					oldestB = ancestryB[ ancestryB.length - 1 ];
				}
				// now that we have the mutual ancestor, we can find which is earliest
				oldestA = oldestA.component || oldestA;
				oldestB = oldestB.component || oldestB;
				fragmentA = oldestA.parentFragment;
				fragmentB = oldestB.parentFragment;
				// if both items share a parent fragment, our job is easy
				if ( fragmentA === fragmentB ) {
					indexA = fragmentA.items.indexOf( oldestA );
					indexB = fragmentB.items.indexOf( oldestB );
					// if it's the same index, it means one contains the other,
					// so we see which has the longest ancestry
					return indexA - indexB || ancestryA.length - ancestryB.length;
				}
				// if mutual ancestor is a section, we first test to see which section
				// fragment comes first
				if ( fragments = mutualAncestor.fragments ) {
					indexA = fragments.indexOf( fragmentA );
					indexB = fragments.indexOf( fragmentB );
					return indexA - indexB || ancestryA.length - ancestryB.length;
				}
				throw new Error( 'An unexpected condition was met while comparing the position of two components. Please file an issue at https://github.com/RactiveJS/Ractive/issues - thanks!' );
			};

			function getParent( item ) {
				var parentFragment;
				if ( parentFragment = item.parentFragment ) {
					return parentFragment.owner;
				}
				if ( item.component && ( parentFragment = item.component.parentFragment ) ) {
					return parentFragment.owner;
				}
			}

			function getAncestry( item ) {
				var ancestry, ancestor;
				ancestry = [ item ];
				ancestor = getParent( item );
				while ( ancestor ) {
					ancestry.push( ancestor );
					ancestor = getParent( ancestor );
				}
				return ancestry;
			}
			return __export;
		}();

		/* Ractive/prototype/shared/makeQuery/sortByDocumentPosition.js */
		var Ractive$shared_makeQuery_sortByDocumentPosition = function( sortByItemPosition ) {

			return function( node, otherNode ) {
				var bitmask;
				if ( node.compareDocumentPosition ) {
					bitmask = node.compareDocumentPosition( otherNode );
					return bitmask & 2 ? 1 : -1;
				}
				// In old IE, we can piggy back on the mechanism for
				// comparing component positions
				return sortByItemPosition( node, otherNode );
			};
		}( Ractive$shared_makeQuery_sortByItemPosition );

		/* Ractive/prototype/shared/makeQuery/sort.js */
		var Ractive$shared_makeQuery_sort = function( sortByDocumentPosition, sortByItemPosition ) {

			return function() {
				this.sort( this._isComponentQuery ? sortByItemPosition : sortByDocumentPosition );
				this._dirty = false;
			};
		}( Ractive$shared_makeQuery_sortByDocumentPosition, Ractive$shared_makeQuery_sortByItemPosition );

		/* Ractive/prototype/shared/makeQuery/dirty.js */
		var Ractive$shared_makeQuery_dirty = function( runloop ) {

			return function() {
				var this$0 = this;
				if ( !this._dirty ) {
					this._dirty = true;
					// Once the DOM has been updated, ensure the query
					// is correctly ordered
					runloop.scheduleTask( function() {
						this$0._sort();
					} );
				}
			};
		}( runloop );

		/* Ractive/prototype/shared/makeQuery/remove.js */
		var Ractive$shared_makeQuery_remove = function( nodeOrComponent ) {
			var index = this.indexOf( this._isComponentQuery ? nodeOrComponent.instance : nodeOrComponent );
			if ( index !== -1 ) {
				this.splice( index, 1 );
			}
		};

		/* Ractive/prototype/shared/makeQuery/_makeQuery.js */
		var Ractive$shared_makeQuery__makeQuery = function( defineProperties, test, cancel, sort, dirty, remove ) {

			return function makeQuery( ractive, selector, live, isComponentQuery ) {
				var query = [];
				defineProperties( query, {
					selector: {
						value: selector
					},
					live: {
						value: live
					},
					_isComponentQuery: {
						value: isComponentQuery
					},
					_test: {
						value: test
					}
				} );
				if ( !live ) {
					return query;
				}
				defineProperties( query, {
					cancel: {
						value: cancel
					},
					_root: {
						value: ractive
					},
					_sort: {
						value: sort
					},
					_makeDirty: {
						value: dirty
					},
					_remove: {
						value: remove
					},
					_dirty: {
						value: false,
						writable: true
					}
				} );
				return query;
			};
		}( defineProperties, Ractive$shared_makeQuery_test, Ractive$shared_makeQuery_cancel, Ractive$shared_makeQuery_sort, Ractive$shared_makeQuery_dirty, Ractive$shared_makeQuery_remove );

		/* Ractive/prototype/findAll.js */
		var Ractive$findAll = function( makeQuery ) {

			return function Ractive$findAll( selector, options ) {
				var liveQueries, query;
				if ( !this.el ) {
					return [];
				}
				options = options || {};
				liveQueries = this._liveQueries;
				// Shortcut: if we're maintaining a live query with this
				// selector, we don't need to traverse the parallel DOM
				if ( query = liveQueries[ selector ] ) {
					// Either return the exact same query, or (if not live) a snapshot
					return options && options.live ? query : query.slice();
				}
				query = makeQuery( this, selector, !!options.live, false );
				// Add this to the list of live queries Ractive needs to maintain,
				// if applicable
				if ( query.live ) {
					liveQueries.push( selector );
					liveQueries[ '_' + selector ] = query;
				}
				this.fragment.findAll( selector, query );
				return query;
			};
		}( Ractive$shared_makeQuery__makeQuery );

		/* Ractive/prototype/findAllComponents.js */
		var Ractive$findAllComponents = function( makeQuery ) {

			return function Ractive$findAllComponents( selector, options ) {
				var liveQueries, query;
				options = options || {};
				liveQueries = this._liveComponentQueries;
				// Shortcut: if we're maintaining a live query with this
				// selector, we don't need to traverse the parallel DOM
				if ( query = liveQueries[ selector ] ) {
					// Either return the exact same query, or (if not live) a snapshot
					return options && options.live ? query : query.slice();
				}
				query = makeQuery( this, selector, !!options.live, true );
				// Add this to the list of live queries Ractive needs to maintain,
				// if applicable
				if ( query.live ) {
					liveQueries.push( selector );
					liveQueries[ '_' + selector ] = query;
				}
				this.fragment.findAllComponents( selector, query );
				return query;
			};
		}( Ractive$shared_makeQuery__makeQuery );

		/* Ractive/prototype/findComponent.js */
		var Ractive$findComponent = function Ractive$findComponent( selector ) {
			return this.fragment.findComponent( selector );
		};

		/* utils/getPotentialWildcardMatches.js */
		var getPotentialWildcardMatches = function() {

			var __export;
			var starMaps = {};
			// This function takes a keypath such as 'foo.bar.baz', and returns
			// all the variants of that keypath that include a wildcard in place
			// of a key, such as 'foo.bar.*', 'foo.*.baz', 'foo.*.*' and so on.
			// These are then checked against the dependants map (ractive.viewmodel.depsMap)
			// to see if any pattern observers are downstream of one or more of
			// these wildcard keypaths (e.g. 'foo.bar.*.status')
			__export = function getPotentialWildcardMatches( keypath ) {
				var keys, starMap, mapper, i, result, wildcardKeypath;
				keys = keypath.split( '.' );
				if ( !( starMap = starMaps[ keys.length ] ) ) {
					starMap = getStarMap( keys.length );
				}
				result = [];
				mapper = function( star, i ) {
					return star ? '*' : keys[ i ];
				};
				i = starMap.length;
				while ( i-- ) {
					wildcardKeypath = starMap[ i ].map( mapper ).join( '.' );
					if ( !result.hasOwnProperty( wildcardKeypath ) ) {
						result.push( wildcardKeypath );
						result[ wildcardKeypath ] = true;
					}
				}
				return result;
			};
			// This function returns all the possible true/false combinations for
			// a given number - e.g. for two, the possible combinations are
			// [ true, true ], [ true, false ], [ false, true ], [ false, false ].
			// It does so by getting all the binary values between 0 and e.g. 11
			function getStarMap( num ) {
				var ones = '',
					max, binary, starMap, mapper, i;
				if ( !starMaps[ num ] ) {
					starMap = [];
					while ( ones.length < num ) {
						ones += 1;
					}
					max = parseInt( ones, 2 );
					mapper = function( digit ) {
						return digit === '1';
					};
					for ( i = 0; i <= max; i += 1 ) {
						binary = i.toString( 2 );
						while ( binary.length < num ) {
							binary = '0' + binary;
						}
						starMap[ i ] = Array.prototype.map.call( binary, mapper );
					}
					starMaps[ num ] = starMap;
				}
				return starMaps[ num ];
			}
			return __export;
		}();

		/* Ractive/prototype/shared/fireEvent.js */
		var Ractive$shared_fireEvent = function( getPotentialWildcardMatches ) {

			var __export;
			__export = function fireEvent( ractive, eventName ) {
				var options = arguments[ 2 ];
				if ( options === void 0 )
					options = {};
				if ( !eventName ) {
					return;
				}
				if ( !options.event ) {
					options.event = {
						name: eventName,
						context: ractive.data,
						keypath: '',
						// until event not included as argument default
						_noArg: true
					};
				} else {
					options.event.name = eventName;
				}
				var eventNames = getPotentialWildcardMatches( eventName );
				fireEventAs( ractive, eventNames, options.event, options.args, true );
			};

			function fireEventAs( ractive, eventNames, event, args ) {
				var initialFire = arguments[ 4 ];
				if ( initialFire === void 0 )
					initialFire = false;
				var subscribers, i, bubble = true;
				if ( event ) {
					ractive.event = event;
				}
				for ( i = eventNames.length; i >= 0; i-- ) {
					subscribers = ractive._subs[ eventNames[ i ] ];
					if ( subscribers ) {
						bubble = notifySubscribers( ractive, subscribers, event, args ) && bubble;
					}
				}
				if ( event ) {
					delete ractive.event;
				}
				if ( ractive._parent && bubble ) {
					if ( initialFire && ractive.component ) {
						var fullName = ractive.component.name + '.' + eventNames[ eventNames.length - 1 ];
						eventNames = getPotentialWildcardMatches( fullName );
						if ( event ) {
							event.component = ractive;
						}
					}
					fireEventAs( ractive._parent, eventNames, event, args );
				}
			}

			function notifySubscribers( ractive, subscribers, event, args ) {
				var originalEvent = null,
					stopEvent = false;
				if ( event && !event._noArg ) {
					args = [ event ].concat( args );
				}
				for ( var i = 0, len = subscribers.length; i < len; i += 1 ) {
					if ( subscribers[ i ].apply( ractive, args ) === false ) {
						stopEvent = true;
					}
				}
				if ( event && !event._noArg && stopEvent && ( originalEvent = event.original ) ) {
					originalEvent.preventDefault && originalEvent.preventDefault();
					originalEvent.stopPropagation && originalEvent.stopPropagation();
				}
				return !stopEvent;
			}
			return __export;
		}( getPotentialWildcardMatches );

		/* Ractive/prototype/fire.js */
		var Ractive$fire = function( fireEvent ) {

			return function Ractive$fire( eventName ) {
				var options = {
					args: Array.prototype.slice.call( arguments, 1 )
				};
				fireEvent( this, eventName, options );
			};
		}( Ractive$shared_fireEvent );

		/* Ractive/prototype/get.js */
		var Ractive$get = function( normaliseKeypath, resolveRef ) {

			var options = {
				capture: true
			};
			// top-level calls should be intercepted
			return function Ractive$get( keypath ) {
				var value;
				keypath = normaliseKeypath( keypath );
				value = this.viewmodel.get( keypath, options );
				// Create inter-component binding, if necessary
				if ( value === undefined && this._parent && !this.isolated ) {
					if ( resolveRef( this, keypath, this.fragment ) ) {
						// creates binding as side-effect, if appropriate
						value = this.viewmodel.get( keypath );
					}
				}
				return value;
			};
		}( normaliseKeypath, resolveRef );

		/* utils/getElement.js */
		var getElement = function getElement( input ) {
			var output;
			if ( !input || typeof input === 'boolean' ) {
				return;
			}
			if ( typeof window === 'undefined' || !document || !input ) {
				return null;
			}
			// We already have a DOM node - no work to do. (Duck typing alert!)
			if ( input.nodeType ) {
				return input;
			}
			// Get node from string
			if ( typeof input === 'string' ) {
				// try ID first
				output = document.getElementById( input );
				// then as selector, if possible
				if ( !output && document.querySelector ) {
					output = document.querySelector( input );
				}
				// did it work?
				if ( output && output.nodeType ) {
					return output;
				}
			}
			// If we've been given a collection (jQuery, Zepto etc), extract the first item
			if ( input[ 0 ] && input[ 0 ].nodeType ) {
				return input[ 0 ];
			}
			return null;
		};

		/* Ractive/prototype/insert.js */
		var Ractive$insert = function( Hook, getElement ) {

			var __export;
			var insertHook = new Hook( 'insert' );
			__export = function Ractive$insert( target, anchor ) {
				if ( !this.fragment.rendered ) {
					// TODO create, and link to, documentation explaining this
					throw new Error( 'The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.' );
				}
				target = getElement( target );
				anchor = getElement( anchor ) || null;
				if ( !target ) {
					throw new Error( 'You must specify a valid target to insert into' );
				}
				target.insertBefore( this.detach(), anchor );
				this.el = target;
				( target.__ractive_instances__ || ( target.__ractive_instances__ = [] ) ).push( this );
				this.detached = null;
				fireInsertHook( this );
			};

			function fireInsertHook( ractive ) {
				insertHook.fire( ractive );
				ractive.findAllComponents( '*' ).forEach( function( child ) {
					fireInsertHook( child.instance );
				} );
			}
			return __export;
		}( Ractive$shared_hooks_Hook, getElement );

		/* Ractive/prototype/merge.js */
		var Ractive$merge = function( runloop, isArray, normaliseKeypath ) {

			return function Ractive$merge( keypath, array, options ) {
				var currentArray, promise;
				keypath = normaliseKeypath( keypath );
				currentArray = this.viewmodel.get( keypath );
				// If either the existing value or the new value isn't an
				// array, just do a regular set
				if ( !isArray( currentArray ) || !isArray( array ) ) {
					return this.set( keypath, array, options && options.complete );
				}
				// Manage transitions
				promise = runloop.start( this, true );
				this.viewmodel.merge( keypath, currentArray, array, options );
				runloop.end();
				// attach callback as fulfilment handler, if specified
				if ( options && options.complete ) {
					promise.then( options.complete );
				}
				return promise;
			};
		}( runloop, isArray, normaliseKeypath );

		/* Ractive/prototype/observe/Observer.js */
		var Ractive$observe_Observer = function( runloop, isEqual ) {

			var Observer = function( ractive, keypath, callback, options ) {
				this.root = ractive;
				this.keypath = keypath;
				this.callback = callback;
				this.defer = options.defer;
				// default to root as context, but allow it to be overridden
				this.context = options && options.context ? options.context : ractive;
			};
			Observer.prototype = {
				init: function( immediate ) {
					this.value = this.root.get( this.keypath );
					if ( immediate !== false ) {
						this.update();
					} else {
						this.oldValue = this.value;
					}
				},
				setValue: function( value ) {
					var this$0 = this;
					if ( !isEqual( value, this.value ) ) {
						this.value = value;
						if ( this.defer && this.ready ) {
							runloop.scheduleTask( function() {
								return this$0.update();
							} );
						} else {
							this.update();
						}
					}
				},
				update: function() {
					// Prevent infinite loops
					if ( this.updating ) {
						return;
					}
					this.updating = true;
					this.callback.call( this.context, this.value, this.oldValue, this.keypath );
					this.oldValue = this.value;
					this.updating = false;
				}
			};
			return Observer;
		}( runloop, isEqual );

		/* shared/getMatchingKeypaths.js */
		var getMatchingKeypaths = function( isArray ) {

			return function getMatchingKeypaths( ractive, pattern ) {
				var keys, key, matchingKeypaths;
				keys = pattern.split( '.' );
				matchingKeypaths = [ '' ];
				while ( key = keys.shift() ) {
					if ( key === '*' ) {
						// expand to find all valid child keypaths
						matchingKeypaths = matchingKeypaths.reduce( expand, [] );
					} else {
						if ( matchingKeypaths[ 0 ] === '' ) {
							// first key
							matchingKeypaths[ 0 ] = key;
						} else {
							matchingKeypaths = matchingKeypaths.map( concatenate( key ) );
						}
					}
				}
				return matchingKeypaths;

				function expand( matchingKeypaths, keypath ) {
					var value, key, childKeypath;
					value = ractive.viewmodel.wrapped[ keypath ] ? ractive.viewmodel.wrapped[ keypath ].get() : ractive.get( keypath );
					for ( key in value ) {
						if ( value.hasOwnProperty( key ) && ( key !== '_ractive' || !isArray( value ) ) ) {
							// for benefit of IE8
							childKeypath = keypath ? keypath + '.' + key : key;
							matchingKeypaths.push( childKeypath );
						}
					}
					return matchingKeypaths;
				}

				function concatenate( key ) {
					return function( keypath ) {
						return keypath ? keypath + '.' + key : key;
					};
				}
			};
		}( isArray );

		/* Ractive/prototype/observe/getPattern.js */
		var Ractive$observe_getPattern = function( getMatchingKeypaths ) {

			return function getPattern( ractive, pattern ) {
				var matchingKeypaths, values;
				matchingKeypaths = getMatchingKeypaths( ractive, pattern );
				values = {};
				matchingKeypaths.forEach( function( keypath ) {
					values[ keypath ] = ractive.get( keypath );
				} );
				return values;
			};
		}( getMatchingKeypaths );

		/* Ractive/prototype/observe/PatternObserver.js */
		var Ractive$observe_PatternObserver = function( runloop, isEqual, getPattern ) {

			var PatternObserver, wildcard = /\*/,
				slice = Array.prototype.slice;
			PatternObserver = function( ractive, keypath, callback, options ) {
				this.root = ractive;
				this.callback = callback;
				this.defer = options.defer;
				this.keypath = keypath;
				this.regex = new RegExp( '^' + keypath.replace( /\./g, '\\.' ).replace( /\*/g, '([^\\.]+)' ) + '$' );
				this.values = {};
				if ( this.defer ) {
					this.proxies = [];
				}
				// default to root as context, but allow it to be overridden
				this.context = options && options.context ? options.context : ractive;
			};
			PatternObserver.prototype = {
				init: function( immediate ) {
					var values, keypath;
					values = getPattern( this.root, this.keypath );
					if ( immediate !== false ) {
						for ( keypath in values ) {
							if ( values.hasOwnProperty( keypath ) ) {
								this.update( keypath );
							}
						}
					} else {
						this.values = values;
					}
				},
				update: function( keypath ) {
					var this$0 = this;
					var values;
					if ( wildcard.test( keypath ) ) {
						values = getPattern( this.root, keypath );
						for ( keypath in values ) {
							if ( values.hasOwnProperty( keypath ) ) {
								this.update( keypath );
							}
						}
						return;
					}
					// special case - array mutation should not trigger `array.*`
					// pattern observer with `array.length`
					if ( this.root.viewmodel.implicitChanges[ keypath ] ) {
						return;
					}
					if ( this.defer && this.ready ) {
						runloop.scheduleTask( function() {
							return this$0.getProxy( keypath ).update();
						} );
						return;
					}
					this.reallyUpdate( keypath );
				},
				reallyUpdate: function( keypath ) {
					var value, keys, args;
					value = this.root.viewmodel.get( keypath );
					// Prevent infinite loops
					if ( this.updating ) {
						this.values[ keypath ] = value;
						return;
					}
					this.updating = true;
					if ( !isEqual( value, this.values[ keypath ] ) || !this.ready ) {
						keys = slice.call( this.regex.exec( keypath ), 1 );
						args = [
							value,
							this.values[ keypath ],
							keypath
						].concat( keys );
						this.callback.apply( this.context, args );
						this.values[ keypath ] = value;
					}
					this.updating = false;
				},
				getProxy: function( keypath ) {
					var self = this;
					if ( !this.proxies[ keypath ] ) {
						this.proxies[ keypath ] = {
							update: function() {
								self.reallyUpdate( keypath );
							}
						};
					}
					return this.proxies[ keypath ];
				}
			};
			return PatternObserver;
		}( runloop, isEqual, Ractive$observe_getPattern );

		/* Ractive/prototype/observe/getObserverFacade.js */
		var Ractive$observe_getObserverFacade = function( normaliseKeypath, Observer, PatternObserver ) {

			var wildcard = /\*/,
				emptyObject = {};
			return function getObserverFacade( ractive, keypath, callback, options ) {
				var observer, isPatternObserver, cancelled;
				keypath = normaliseKeypath( keypath );
				options = options || emptyObject;
				// pattern observers are treated differently
				if ( wildcard.test( keypath ) ) {
					observer = new PatternObserver( ractive, keypath, callback, options );
					ractive.viewmodel.patternObservers.push( observer );
					isPatternObserver = true;
				} else {
					observer = new Observer( ractive, keypath, callback, options );
				}
				ractive.viewmodel.register( keypath, observer, isPatternObserver ? 'patternObservers' : 'observers' );
				observer.init( options.init );
				// This flag allows observers to initialise even with undefined values
				observer.ready = true;
				return {
					cancel: function() {
						var index;
						if ( cancelled ) {
							return;
						}
						if ( isPatternObserver ) {
							index = ractive.viewmodel.patternObservers.indexOf( observer );
							ractive.viewmodel.patternObservers.splice( index, 1 );
							ractive.viewmodel.unregister( keypath, observer, 'patternObservers' );
						} else {
							ractive.viewmodel.unregister( keypath, observer, 'observers' );
						}
						cancelled = true;
					}
				};
			};
		}( normaliseKeypath, Ractive$observe_Observer, Ractive$observe_PatternObserver );

		/* Ractive/prototype/observe.js */
		var Ractive$observe = function( isObject, getObserverFacade ) {

			return function Ractive$observe( keypath, callback, options ) {
				var observers, map, keypaths, i;
				// Allow a map of keypaths to handlers
				if ( isObject( keypath ) ) {
					options = callback;
					map = keypath;
					observers = [];
					for ( keypath in map ) {
						if ( map.hasOwnProperty( keypath ) ) {
							callback = map[ keypath ];
							observers.push( this.observe( keypath, callback, options ) );
						}
					}
					return {
						cancel: function() {
							while ( observers.length ) {
								observers.pop().cancel();
							}
						}
					};
				}
				// Allow `ractive.observe( callback )` - i.e. observe entire model
				if ( typeof keypath === 'function' ) {
					options = callback;
					callback = keypath;
					keypath = '';
					return getObserverFacade( this, keypath, callback, options );
				}
				keypaths = keypath.split( ' ' );
				// Single keypath
				if ( keypaths.length === 1 ) {
					return getObserverFacade( this, keypath, callback, options );
				}
				// Multiple space-separated keypaths
				observers = [];
				i = keypaths.length;
				while ( i-- ) {
					keypath = keypaths[ i ];
					if ( keypath ) {
						observers.push( getObserverFacade( this, keypath, callback, options ) );
					}
				}
				return {
					cancel: function() {
						while ( observers.length ) {
							observers.pop().cancel();
						}
					}
				};
			};
		}( isObject, Ractive$observe_getObserverFacade );

		/* Ractive/prototype/shared/trim.js */
		var Ractive$shared_trim = function( str ) {
			return str.trim();
		};

		/* Ractive/prototype/shared/notEmptyString.js */
		var Ractive$shared_notEmptyString = function( str ) {
			return str !== '';
		};

		/* Ractive/prototype/off.js */
		var Ractive$off = function( trim, notEmptyString ) {

			return function Ractive$off( eventName, callback ) {
				var this$0 = this;
				var eventNames;
				// if no arguments specified, remove all callbacks
				if ( !eventName ) {
					// TODO use this code instead, once the following issue has been resolved
					// in PhantomJS (tests are unpassable otherwise!)
					// https://github.com/ariya/phantomjs/issues/11856
					// defineProperty( this, '_subs', { value: create( null ), configurable: true });
					for ( eventName in this._subs ) {
						delete this._subs[ eventName ];
					}
				} else {
					// Handle multiple space-separated event names
					eventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );
					eventNames.forEach( function( eventName ) {
						var subscribers, index;
						// If we have subscribers for this event...
						if ( subscribers = this$0._subs[ eventName ] ) {
							// ...if a callback was specified, only remove that
							if ( callback ) {
								index = subscribers.indexOf( callback );
								if ( index !== -1 ) {
									subscribers.splice( index, 1 );
								}
							} else {
								this$0._subs[ eventName ] = [];
							}
						}
					} );
				}
				return this;
			};
		}( Ractive$shared_trim, Ractive$shared_notEmptyString );

		/* Ractive/prototype/on.js */
		var Ractive$on = function( trim, notEmptyString ) {

			return function Ractive$on( eventName, callback ) {
				var this$0 = this;
				var self = this,
					listeners, n, eventNames;
				// allow mutliple listeners to be bound in one go
				if ( typeof eventName === 'object' ) {
					listeners = [];
					for ( n in eventName ) {
						if ( eventName.hasOwnProperty( n ) ) {
							listeners.push( this.on( n, eventName[ n ] ) );
						}
					}
					return {
						cancel: function() {
							var listener;
							while ( listener = listeners.pop() ) {
								listener.cancel();
							}
						}
					};
				}
				// Handle multiple space-separated event names
				eventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );
				eventNames.forEach( function( eventName ) {
					( this$0._subs[ eventName ] || ( this$0._subs[ eventName ] = [] ) ).push( callback );
				} );
				return {
					cancel: function() {
						self.off( eventName, callback );
					}
				};
			};
		}( Ractive$shared_trim, Ractive$shared_notEmptyString );

		/* shared/getNewIndices.js */
		var getNewIndices = function() {

			var __export;
			// This function takes an array, the name of a mutator method, and the
			// arguments to call that mutator method with, and returns an array that
			// maps the old indices to their new indices.
			// So if you had something like this...
			//
			//     array = [ 'a', 'b', 'c', 'd' ];
			//     array.push( 'e' );
			//
			// ...you'd get `[ 0, 1, 2, 3 ]` - in other words, none of the old indices
			// have changed. If you then did this...
			//
			//     array.unshift( 'z' );
			//
			// ...the indices would be `[ 1, 2, 3, 4, 5 ]` - every item has been moved
			// one higher to make room for the 'z'. If you removed an item, the new index
			// would be -1...
			//
			//     array.splice( 2, 2 );
			//
			// ...this would result in [ 0, 1, -1, -1, 2, 3 ].
			//
			// This information is used to enable fast, non-destructive shuffling of list
			// sections when you do e.g. `ractive.splice( 'items', 2, 2 );
			__export = function getNewIndices( array, methodName, args ) {
				var spliceArguments, len, newIndices = [],
					removeStart, removeEnd, balance, i;
				spliceArguments = getSpliceEquivalent( array, methodName, args );
				if ( !spliceArguments ) {
					return null;
				}
				len = array.length;
				balance = spliceArguments.length - 2 - spliceArguments[ 1 ];
				removeStart = Math.min( len, spliceArguments[ 0 ] );
				removeEnd = removeStart + spliceArguments[ 1 ];
				for ( i = 0; i < removeStart; i += 1 ) {
					newIndices.push( i );
				}
				for ( ; i < removeEnd; i += 1 ) {
					newIndices.push( -1 );
				}
				for ( ; i < len; i += 1 ) {
					newIndices.push( i + balance );
				}
				return newIndices;
			};
			// The pop, push, shift an unshift methods can all be represented
			// as an equivalent splice
			function getSpliceEquivalent( array, methodName, args ) {
				switch ( methodName ) {
					case 'splice':
						if ( args[ 0 ] !== undefined && args[ 0 ] < 0 ) {
							args[ 0 ] = array.length + Math.max( args[ 0 ], -array.length );
						}
						while ( args.length < 2 ) {
							args.push( 0 );
						}
						// ensure we only remove elements that exist
						args[ 1 ] = Math.min( args[ 1 ], array.length - args[ 0 ] );
						return args;
					case 'sort':
					case 'reverse':
						return null;
					case 'pop':
						if ( array.length ) {
							return [
								array.length - 1,
								1
							];
						}
						return null;
					case 'push':
						return [
							array.length,
							0
						].concat( args );
					case 'shift':
						return [
							0,
							1
						];
					case 'unshift':
						return [
							0,
							0
						].concat( args );
				}
			}
			return __export;
		}();

		/* Ractive/prototype/shared/makeArrayMethod.js */
		var Ractive$shared_makeArrayMethod = function( isArray, runloop, getNewIndices ) {

			var arrayProto = Array.prototype;
			return function( methodName ) {
				return function( keypath ) {
					var SLICE$0 = Array.prototype.slice;
					var args = SLICE$0.call( arguments, 1 );
					var array, newIndices = [],
						len, promise, result;
					array = this.get( keypath );
					len = array.length;
					if ( !isArray( array ) ) {
						throw new Error( 'Called ractive.' + methodName + '(\'' + keypath + '\'), but \'' + keypath + '\' does not refer to an array' );
					}
					newIndices = getNewIndices( array, methodName, args );
					result = arrayProto[ methodName ].apply( array, args );
					promise = runloop.start( this, true ).then( function() {
						return result;
					} );
					if ( !!newIndices ) {
						this.viewmodel.smartUpdate( keypath, array, newIndices );
					} else {
						this.viewmodel.mark( keypath );
					}
					runloop.end();
					return promise;
				};
			};
		}( isArray, runloop, getNewIndices );

		/* Ractive/prototype/pop.js */
		var Ractive$pop = function( makeArrayMethod ) {

			return makeArrayMethod( 'pop' );
		}( Ractive$shared_makeArrayMethod );

		/* Ractive/prototype/push.js */
		var Ractive$push = function( makeArrayMethod ) {

			return makeArrayMethod( 'push' );
		}( Ractive$shared_makeArrayMethod );

		/* global/css.js */
		var global_css = function( circular, isClient, removeFromArray ) {

			var css, update, runloop, styleElement, head, styleSheet, inDom, prefix = '/* Ractive.js component styles */\n',
				componentsInPage = {},
				styles = [];
			if ( !isClient ) {
				css = null;
			} else {
				circular.push( function() {
					runloop = circular.runloop;
				} );
				styleElement = document.createElement( 'style' );
				styleElement.type = 'text/css';
				head = document.getElementsByTagName( 'head' )[ 0 ];
				inDom = false;
				// Internet Exploder won't let you use styleSheet.innerHTML - we have to
				// use styleSheet.cssText instead
				styleSheet = styleElement.styleSheet;
				update = function() {
					var css;
					if ( styles.length ) {
						css = prefix + styles.join( ' ' );
						if ( styleSheet ) {
							styleSheet.cssText = css;
						} else {
							styleElement.innerHTML = css;
						}
						if ( !inDom ) {
							head.appendChild( styleElement );
							inDom = true;
						}
					} else if ( inDom ) {
						head.removeChild( styleElement );
						inDom = false;
					}
				};
				css = {
					add: function( Component ) {
						if ( !Component.css ) {
							return;
						}
						if ( !componentsInPage[ Component._guid ] ) {
							// we create this counter so that we can in/decrement it as
							// instances are added and removed. When all components are
							// removed, the style is too
							componentsInPage[ Component._guid ] = 0;
							styles.push( Component.css );
							update();
						}
						componentsInPage[ Component._guid ] += 1;
					},
					remove: function( Component ) {
						if ( !Component.css ) {
							return;
						}
						componentsInPage[ Component._guid ] -= 1;
						if ( !componentsInPage[ Component._guid ] ) {
							removeFromArray( styles, Component.css );
							runloop.scheduleTask( update );
						}
					}
				};
			}
			return css;
		}( circular, isClient, removeFromArray );

		/* Ractive/prototype/render.js */
		var Ractive$render = function( css, Hook, getElement, runloop ) {

			var renderHook = new Hook( 'render' ),
				completeHook = new Hook( 'complete' );
			return function Ractive$render( target, anchor ) {
				var this$0 = this;
				var promise, instances, transitionsEnabled;
				// if `noIntro` is `true`, temporarily disable transitions
				transitionsEnabled = this.transitionsEnabled;
				if ( this.noIntro ) {
					this.transitionsEnabled = false;
				}
				promise = runloop.start( this, true );
				runloop.scheduleTask( function() {
					return renderHook.fire( this$0 );
				}, true );
				if ( this.fragment.rendered ) {
					throw new Error( 'You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first' );
				}
				target = getElement( target ) || this.el;
				anchor = getElement( anchor ) || this.anchor;
				this.el = target;
				this.anchor = anchor;
				// Add CSS, if applicable
				if ( this.constructor.css ) {
					css.add( this.constructor );
				}
				if ( target ) {
					if ( !( instances = target.__ractive_instances__ ) ) {
						target.__ractive_instances__ = [ this ];
					} else {
						instances.push( this );
					}
					if ( anchor ) {
						target.insertBefore( this.fragment.render(), anchor );
					} else {
						target.appendChild( this.fragment.render() );
					}
				}
				runloop.end();
				this.transitionsEnabled = transitionsEnabled;
				// It is now more problematic to know if the complete hook
				// would fire. Method checking is straight-forward, but would
				// also require preflighting event subscriptions. Which seems
				// like more work then just letting the promise happen.
				// But perhaps I'm wrong about that...
				promise.then( function() {
					return completeHook.fire( this$0 );
				} );
				return promise;
			};
		}( global_css, Ractive$shared_hooks_Hook, getElement, runloop );

		/* virtualdom/Fragment/prototype/bubble.js */
		var virtualdom_Fragment$bubble = function Fragment$bubble() {
			this.dirtyValue = this.dirtyArgs = true;
			if ( this.bound && typeof this.owner.bubble === 'function' ) {
				this.owner.bubble();
			}
		};

		/* virtualdom/Fragment/prototype/detach.js */
		var virtualdom_Fragment$detach = function Fragment$detach() {
			var docFrag;
			if ( this.items.length === 1 ) {
				return this.items[ 0 ].detach();
			}
			docFrag = document.createDocumentFragment();
			this.items.forEach( function( item ) {
				var node = item.detach();
				// TODO The if {...} wasn't previously required - it is now, because we're
				// forcibly detaching everything to reorder sections after an update. That's
				// a non-ideal brute force approach, implemented to get all the tests to pass
				// - as soon as it's replaced with something more elegant, this should
				// revert to `docFrag.appendChild( item.detach() )`
				if ( node ) {
					docFrag.appendChild( node );
				}
			} );
			return docFrag;
		};

		/* virtualdom/Fragment/prototype/find.js */
		var virtualdom_Fragment$find = function Fragment$find( selector ) {
			var i, len, item, queryResult;
			if ( this.items ) {
				len = this.items.length;
				for ( i = 0; i < len; i += 1 ) {
					item = this.items[ i ];
					if ( item.find && ( queryResult = item.find( selector ) ) ) {
						return queryResult;
					}
				}
				return null;
			}
		};

		/* virtualdom/Fragment/prototype/findAll.js */
		var virtualdom_Fragment$findAll = function Fragment$findAll( selector, query ) {
			var i, len, item;
			if ( this.items ) {
				len = this.items.length;
				for ( i = 0; i < len; i += 1 ) {
					item = this.items[ i ];
					if ( item.findAll ) {
						item.findAll( selector, query );
					}
				}
			}
			return query;
		};

		/* virtualdom/Fragment/prototype/findAllComponents.js */
		var virtualdom_Fragment$findAllComponents = function Fragment$findAllComponents( selector, query ) {
			var i, len, item;
			if ( this.items ) {
				len = this.items.length;
				for ( i = 0; i < len; i += 1 ) {
					item = this.items[ i ];
					if ( item.findAllComponents ) {
						item.findAllComponents( selector, query );
					}
				}
			}
			return query;
		};

		/* virtualdom/Fragment/prototype/findComponent.js */
		var virtualdom_Fragment$findComponent = function Fragment$findComponent( selector ) {
			var len, i, item, queryResult;
			if ( this.items ) {
				len = this.items.length;
				for ( i = 0; i < len; i += 1 ) {
					item = this.items[ i ];
					if ( item.findComponent && ( queryResult = item.findComponent( selector ) ) ) {
						return queryResult;
					}
				}
				return null;
			}
		};

		/* virtualdom/Fragment/prototype/findNextNode.js */
		var virtualdom_Fragment$findNextNode = function Fragment$findNextNode( item ) {
			var index = item.index,
				node;
			if ( this.items[ index + 1 ] ) {
				node = this.items[ index + 1 ].firstNode();
			} else if ( this.owner === this.root ) {
				if ( !this.owner.component ) {
					// TODO but something else could have been appended to
					// this.root.el, no?
					node = null;
				} else {
					node = this.owner.component.findNextNode();
				}
			} else {
				node = this.owner.findNextNode( this );
			}
			return node;
		};

		/* virtualdom/Fragment/prototype/firstNode.js */
		var virtualdom_Fragment$firstNode = function Fragment$firstNode() {
			if ( this.items && this.items[ 0 ] ) {
				return this.items[ 0 ].firstNode();
			}
			return null;
		};

		/* virtualdom/Fragment/prototype/getNode.js */
		var virtualdom_Fragment$getNode = function Fragment$getNode() {
			var fragment = this;
			do {
				if ( fragment.pElement ) {
					return fragment.pElement.node;
				}
			} while ( fragment = fragment.parent );
			return this.root.detached || this.root.el;
		};

		/* virtualdom/Fragment/prototype/getValue.js */
		var virtualdom_Fragment$getValue = function( parseJSON ) {

			var __export;
			var empty = {};
			__export = function Fragment$getValue() {
				var options = arguments[ 0 ];
				if ( options === void 0 )
					options = empty;
				var asArgs, values, source, parsed, cachedResult, dirtyFlag, result;
				asArgs = options.args;
				cachedResult = asArgs ? 'argsList' : 'value';
				dirtyFlag = asArgs ? 'dirtyArgs' : 'dirtyValue';
				if ( this[ dirtyFlag ] ) {
					source = processItems( this.items, values = {}, this.root._guid );
					parsed = parseJSON( asArgs ? '[' + source + ']' : source, values );
					if ( !parsed ) {
						result = asArgs ? [ this.toString() ] : this.toString();
					} else {
						result = parsed.value;
					}
					this[ cachedResult ] = result;
					this[ dirtyFlag ] = false;
				}
				return this[ cachedResult ];
			};

			function processItems( items, values, guid, counter ) {
				counter = counter || 0;
				return items.map( function( item ) {
					var placeholderId, wrapped, value;
					if ( item.text ) {
						return item.text;
					}
					if ( item.fragments ) {
						return item.fragments.map( function( fragment ) {
							return processItems( fragment.items, values, guid, counter );
						} ).join( '' );
					}
					placeholderId = guid + '-' + counter++;
					if ( wrapped = item.root.viewmodel.wrapped[ item.keypath ] ) {
						value = wrapped.value;
					} else {
						value = item.getValue();
					}
					values[ placeholderId ] = value;
					return '${' + placeholderId + '}';
				} ).join( '' );
			}
			return __export;
		}( parseJSON );

		/* utils/escapeHtml.js */
		var escapeHtml = function() {

			var lessThan = /</g;
			var greaterThan = />/g;
			var amp = /&/g;
			return function escapeHtml( str ) {
				return str.replace( amp, '&amp;' ).replace( lessThan, '&lt;' ).replace( greaterThan, '&gt;' );
			};
		}();

		/* utils/detachNode.js */
		var detachNode = function detachNode( node ) {
			if ( node && node.parentNode ) {
				node.parentNode.removeChild( node );
			}
			return node;
		};

		/* virtualdom/items/shared/detach.js */
		var detach = function( detachNode ) {

			return function() {
				return detachNode( this.node );
			};
		}( detachNode );

		/* virtualdom/items/Text.js */
		var Text = function( types, escapeHtml, detach ) {

			var Text = function( options ) {
				this.type = types.TEXT;
				this.text = options.template;
			};
			Text.prototype = {
				detach: detach,
				firstNode: function() {
					return this.node;
				},
				render: function() {
					if ( !this.node ) {
						this.node = document.createTextNode( this.text );
					}
					return this.node;
				},
				toString: function( escape ) {
					return escape ? escapeHtml( this.text ) : this.text;
				},
				unrender: function( shouldDestroy ) {
					if ( shouldDestroy ) {
						return this.detach();
					}
				}
			};
			return Text;
		}( types, escapeHtml, detach );

		/* virtualdom/items/shared/unbind.js */
		var unbind = function unbind() {
			if ( this.registered ) {
				// this was registered as a dependant
				this.root.viewmodel.unregister( this.keypath, this );
			}
			if ( this.resolver ) {
				this.resolver.unbind();
			}
		};

		/* virtualdom/items/shared/Mustache/getValue.js */
		var getValue = function Mustache$getValue() {
			return this.value;
		};

		/* virtualdom/items/shared/utils/startsWithKeypath.js */
		var startsWithKeypath = function startsWithKeypath( target, keypath ) {
			return target && keypath && target.substr( 0, keypath.length + 1 ) === keypath + '.';
		};

		/* virtualdom/items/shared/utils/getNewKeypath.js */
		var getNewKeypath = function( startsWithKeypath ) {

			return function getNewKeypath( targetKeypath, oldKeypath, newKeypath ) {
				// exact match
				if ( targetKeypath === oldKeypath ) {
					return newKeypath !== undefined ? newKeypath : null;
				}
				// partial match based on leading keypath segments
				if ( startsWithKeypath( targetKeypath, oldKeypath ) ) {
					return newKeypath === null ? newKeypath : targetKeypath.replace( oldKeypath + '.', newKeypath + '.' );
				}
			};
		}( startsWithKeypath );

		/* virtualdom/items/shared/Resolvers/ReferenceResolver.js */
		var ReferenceResolver = function( runloop, resolveRef, getNewKeypath ) {

			var ReferenceResolver = function( owner, ref, callback ) {
				var keypath;
				this.ref = ref;
				this.resolved = false;
				this.root = owner.root;
				this.parentFragment = owner.parentFragment;
				this.callback = callback;
				keypath = resolveRef( owner.root, ref, owner.parentFragment );
				if ( keypath !== undefined ) {
					this.resolve( keypath );
				} else {
					runloop.addUnresolved( this );
				}
			};
			ReferenceResolver.prototype = {
				resolve: function( keypath ) {
					this.resolved = true;
					this.keypath = keypath;
					this.callback( keypath );
				},
				forceResolution: function() {
					this.resolve( this.ref );
				},
				rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
					var keypath;
					if ( this.keypath !== undefined ) {
						keypath = getNewKeypath( this.keypath, oldKeypath, newKeypath );
						// was a new keypath created?
						if ( keypath !== undefined ) {
							// resolve it
							this.resolve( keypath );
						}
					}
				},
				unbind: function() {
					if ( !this.resolved ) {
						runloop.removeUnresolved( this );
					}
				}
			};
			return ReferenceResolver;
		}( runloop, resolveRef, getNewKeypath );

		/* virtualdom/items/shared/Resolvers/SpecialResolver.js */
		var SpecialResolver = function() {

			var SpecialResolver = function( owner, ref, callback ) {
				this.parentFragment = owner.parentFragment;
				this.ref = ref;
				this.callback = callback;
				this.rebind();
			};
			SpecialResolver.prototype = {
				rebind: function() {
					var ref = this.ref,
						fragment = this.parentFragment;
					if ( ref === '@keypath' ) {
						while ( fragment ) {
							if ( !!fragment.context ) {
								return this.callback( '@' + fragment.context );
							}
							fragment = fragment.parent;
						}
					}
					if ( ref === '@index' || ref === '@key' ) {
						while ( fragment ) {
							if ( fragment.index !== undefined ) {
								return this.callback( '@' + fragment.index );
							}
							fragment = fragment.parent;
						}
					}
					throw new Error( 'Unknown special reference "' + ref + '" - valid references are @index, @key and @keypath' );
				},
				unbind: function() {}
			};
			return SpecialResolver;
		}();

		/* virtualdom/items/shared/Resolvers/IndexResolver.js */
		var IndexResolver = function() {

			var IndexResolver = function( owner, ref, callback ) {
				this.parentFragment = owner.parentFragment;
				this.ref = ref;
				this.callback = callback;
				this.rebind();
			};
			IndexResolver.prototype = {
				rebind: function() {
					var ref = this.ref,
						indexRefs = this.parentFragment.indexRefs,
						index = indexRefs[ ref ];
					if ( index !== undefined ) {
						this.callback( '@' + index );
					}
				},
				unbind: function() {}
			};
			return IndexResolver;
		}();

		/* virtualdom/items/shared/Resolvers/createReferenceResolver.js */
		var createReferenceResolver = function( ReferenceResolver, SpecialResolver, IndexResolver ) {

			return function createReferenceResolver( owner, ref, callback ) {
				var indexRefs, index;
				if ( ref.charAt( 0 ) === '@' ) {
					return new SpecialResolver( owner, ref, callback );
				}
				indexRefs = owner.parentFragment.indexRefs;
				if ( indexRefs && ( index = indexRefs[ ref ] ) !== undefined ) {
					return new IndexResolver( owner, ref, callback );
				}
				return new ReferenceResolver( owner, ref, callback );
			};
		}( ReferenceResolver, SpecialResolver, IndexResolver );

		/* shared/getFunctionFromString.js */
		var getFunctionFromString = function() {

			var cache = {};
			return function getFunctionFromString( str, i ) {
				var fn, args;
				if ( cache[ str ] ) {
					return cache[ str ];
				}
				args = [];
				while ( i-- ) {
					args[ i ] = '_' + i;
				}
				fn = new Function( args.join( ',' ), 'return(' + str + ')' );
				cache[ str ] = fn;
				return fn;
			};
		}();

		/* virtualdom/items/shared/Resolvers/ExpressionResolver.js */
		var ExpressionResolver = function( defineProperty, isNumeric, createReferenceResolver, getFunctionFromString ) {

			var __export;
			var ExpressionResolver, bind = Function.prototype.bind;
			ExpressionResolver = function( owner, parentFragment, expression, callback ) {
				var resolver = this,
					ractive, indexRefs;
				ractive = owner.root;
				resolver.root = ractive;
				resolver.parentFragment = parentFragment;
				resolver.callback = callback;
				resolver.owner = owner;
				resolver.str = expression.s;
				resolver.keypaths = [];
				indexRefs = parentFragment.indexRefs;
				// Create resolvers for each reference
				resolver.pending = expression.r.length;
				resolver.refResolvers = expression.r.map( function( ref, i ) {
					return createReferenceResolver( resolver, ref, function( keypath ) {
						resolver.resolve( i, keypath );
					} );
				} );
				resolver.ready = true;
				resolver.bubble();
			};
			ExpressionResolver.prototype = {
				bubble: function() {
					if ( !this.ready ) {
						return;
					}
					this.uniqueString = getUniqueString( this.str, this.keypaths );
					this.keypath = getKeypath( this.uniqueString );
					this.createEvaluator();
					this.callback( this.keypath );
				},
				unbind: function() {
					var resolver;
					while ( resolver = this.refResolvers.pop() ) {
						resolver.unbind();
					}
				},
				resolve: function( index, keypath ) {
					this.keypaths[ index ] = keypath;
					this.bubble();
				},
				createEvaluator: function() {
					var this$0 = this;
					var self = this,
						computation, valueGetters, signature, keypath, fn;
					computation = this.root.viewmodel.computations[ this.keypath ];
					// only if it doesn't exist yet!
					if ( !computation ) {
						fn = getFunctionFromString( this.str, this.refResolvers.length );
						valueGetters = this.keypaths.map( function( keypath ) {
							var value;
							if ( keypath === 'undefined' ) {
								return function() {
									return undefined;
								};
							}
							// 'special' keypaths encode a value
							if ( keypath[ 0 ] === '@' ) {
								value = keypath.slice( 1 );
								return isNumeric( value ) ? function() {
									return +value;
								} : function() {
									return value;
								};
							}
							return function() {
								var value = this$0.root.viewmodel.get( keypath );
								if ( typeof value === 'function' ) {
									value = wrapFunction( value, self.root );
								}
								return value;
							};
						} );
						signature = {
							deps: this.keypaths.filter( isValidDependency ),
							get: function() {
								var args = valueGetters.map( call );
								return fn.apply( null, args );
							}
						};
						computation = this.root.viewmodel.compute( this.keypath, signature );
					} else {
						this.root.viewmodel.mark( this.keypath );
					}
				},
				rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
					// TODO only bubble once, no matter how many references are affected by the rebind
					this.refResolvers.forEach( function( r ) {
						return r.rebind( indexRef, newIndex, oldKeypath, newKeypath );
					} );
				}
			};
			__export = ExpressionResolver;

			function call( value ) {
				return value.call();
			}

			function getUniqueString( str, keypaths ) {
				// get string that is unique to this expression
				return str.replace( /_([0-9]+)/g, function( match, $1 ) {
					var keypath, value;
					keypath = keypaths[ $1 ];
					if ( keypath === undefined ) {
						return 'undefined';
					}
					if ( keypath[ 0 ] === '@' ) {
						value = keypath.slice( 1 );
						return isNumeric( value ) ? value : '"' + value + '"';
					}
					return keypath;
				} );
			}

			function getKeypath( uniqueString ) {
				// Sanitize by removing any periods or square brackets. Otherwise
				// we can't split the keypath into keys!
				return '${' + uniqueString.replace( /[\.\[\]]/g, '-' ) + '}';
			}

			function isValidDependency( keypath ) {
				return keypath !== undefined && keypath[ 0 ] !== '@';
			}

			function wrapFunction( fn, ractive ) {
				var wrapped, prop, key;
				if ( fn._noWrap ) {
					return fn;
				}
				prop = '__ractive_' + ractive._guid;
				wrapped = fn[ prop ];
				if ( wrapped ) {
					return wrapped;
				} else if ( /this/.test( fn.toString() ) ) {
					defineProperty( fn, prop, {
						value: bind.call( fn, ractive )
					} );
					// Add properties/methods to wrapped function
					for ( key in fn ) {
						if ( fn.hasOwnProperty( key ) ) {
							fn[ prop ][ key ] = fn[ key ];
						}
					}
					return fn[ prop ];
				}
				defineProperty( fn, '__ractive_nowrap', {
					value: fn
				} );
				return fn.__ractive_nowrap;
			}
			return __export;
		}( defineProperty, isNumeric, createReferenceResolver, getFunctionFromString, legacy );

		/* virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/MemberResolver.js */
		var MemberResolver = function( types, createReferenceResolver, ExpressionResolver ) {

			var MemberResolver = function( template, resolver, parentFragment ) {
				var member = this,
					keypath;
				member.resolver = resolver;
				member.root = resolver.root;
				member.parentFragment = parentFragment;
				member.viewmodel = resolver.root.viewmodel;
				if ( typeof template === 'string' ) {
					member.value = template;
				} else if ( template.t === types.REFERENCE ) {
					member.refResolver = createReferenceResolver( this, template.n, function( keypath ) {
						member.resolve( keypath );
					} );
				} else {
					new ExpressionResolver( resolver, parentFragment, template, function( keypath ) {
						member.resolve( keypath );
					} );
				}
			};
			MemberResolver.prototype = {
				resolve: function( keypath ) {
					if ( this.keypath ) {
						this.viewmodel.unregister( this.keypath, this );
					}
					this.keypath = keypath;
					this.value = this.viewmodel.get( keypath );
					this.bind();
					this.resolver.bubble();
				},
				bind: function() {
					this.viewmodel.register( this.keypath, this );
				},
				rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
					if ( this.refResolver ) {
						this.refResolver.rebind( indexRef, newIndex, oldKeypath, newKeypath );
					}
				},
				setValue: function( value ) {
					this.value = value;
					this.resolver.bubble();
				},
				unbind: function() {
					if ( this.keypath ) {
						this.viewmodel.unregister( this.keypath, this );
					}
					if ( this.unresolved ) {
						this.unresolved.unbind();
					}
				},
				forceResolution: function() {
					if ( this.refResolver ) {
						this.refResolver.forceResolution();
					}
				}
			};
			return MemberResolver;
		}( types, createReferenceResolver, ExpressionResolver );

		/* virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/ReferenceExpressionResolver.js */
		var ReferenceExpressionResolver = function( resolveRef, ReferenceResolver, MemberResolver ) {

			var ReferenceExpressionResolver = function( mustache, template, callback ) {
				var this$0 = this;
				var resolver = this,
					ractive, ref, keypath, parentFragment;
				resolver.parentFragment = parentFragment = mustache.parentFragment;
				resolver.root = ractive = mustache.root;
				resolver.mustache = mustache;
				resolver.ref = ref = template.r;
				resolver.callback = callback;
				resolver.unresolved = [];
				// Find base keypath
				if ( keypath = resolveRef( ractive, ref, parentFragment ) ) {
					resolver.base = keypath;
				} else {
					resolver.baseResolver = new ReferenceResolver( this, ref, function( keypath ) {
						resolver.base = keypath;
						resolver.baseResolver = null;
						resolver.bubble();
					} );
				}
				// Find values for members, or mark them as unresolved
				resolver.members = template.m.map( function( template ) {
					return new MemberResolver( template, this$0, parentFragment );
				} );
				resolver.ready = true;
				resolver.bubble();
			};
			ReferenceExpressionResolver.prototype = {
				getKeypath: function() {
					var values = this.members.map( getValue );
					if ( !values.every( isDefined ) || this.baseResolver ) {
						return null;
					}
					return this.base + '.' + values.join( '.' );
				},
				bubble: function() {
					if ( !this.ready || this.baseResolver ) {
						return;
					}
					this.callback( this.getKeypath() );
				},
				unbind: function() {
					this.members.forEach( unbind );
				},
				rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
					var changed;
					this.members.forEach( function( members ) {
						if ( members.rebind( indexRef, newIndex, oldKeypath, newKeypath ) ) {
							changed = true;
						}
					} );
					if ( changed ) {
						this.bubble();
					}
				},
				forceResolution: function() {
					if ( this.baseResolver ) {
						this.base = this.ref;
						this.baseResolver.unbind();
						this.baseResolver = null;
					}
					this.members.forEach( function( m ) {
						return m.forceResolution();
					} );
					this.bubble();
				}
			};

			function getValue( member ) {
				return member.value;
			}

			function isDefined( value ) {
				return value != undefined;
			}

			function unbind( member ) {
				member.unbind();
			}
			return ReferenceExpressionResolver;
		}( resolveRef, ReferenceResolver, MemberResolver );

		/* virtualdom/items/shared/Mustache/initialise.js */
		var initialise = function( types, createReferenceResolver, ReferenceExpressionResolver, ExpressionResolver ) {

			return function Mustache$init( mustache, options ) {
				var ref, parentFragment, template;
				parentFragment = options.parentFragment;
				template = options.template;
				mustache.root = parentFragment.root;
				mustache.parentFragment = parentFragment;
				mustache.pElement = parentFragment.pElement;
				mustache.template = options.template;
				mustache.index = options.index || 0;
				mustache.isStatic = options.template.s;
				mustache.type = options.template.t;
				mustache.registered = false;
				// if this is a simple mustache, with a reference, we just need to resolve
				// the reference to a keypath
				if ( ref = template.r ) {
					mustache.resolver = new createReferenceResolver( mustache, ref, resolve );
				}
				// if it's an expression, we have a bit more work to do
				if ( options.template.x ) {
					mustache.resolver = new ExpressionResolver( mustache, parentFragment, options.template.x, resolveAndRebindChildren );
				}
				if ( options.template.rx ) {
					mustache.resolver = new ReferenceExpressionResolver( mustache, options.template.rx, resolveAndRebindChildren );
				}
				// Special case - inverted sections
				if ( mustache.template.n === types.SECTION_UNLESS && !mustache.hasOwnProperty( 'value' ) ) {
					mustache.setValue( undefined );
				}

				function resolve( keypath ) {
					mustache.resolve( keypath );
				}

				function resolveAndRebindChildren( newKeypath ) {
					var oldKeypath = mustache.keypath;
					if ( newKeypath !== oldKeypath ) {
						mustache.resolve( newKeypath );
						if ( oldKeypath !== undefined ) {
							mustache.fragments && mustache.fragments.forEach( function( f ) {
								f.rebind( null, null, oldKeypath, newKeypath );
							} );
						}
					}
				}
			};
		}( types, createReferenceResolver, ReferenceExpressionResolver, ExpressionResolver );

		/* virtualdom/items/shared/Mustache/resolve.js */
		var resolve = function( isNumeric ) {

			return function Mustache$resolve( keypath ) {
				var wasResolved, value, twowayBinding;
				// 'Special' keypaths, e.g. @foo or @7, encode a value
				if ( keypath && keypath[ 0 ] === '@' ) {
					value = keypath.slice( 1 );
					if ( isNumeric( value ) ) {
						value = +value;
					}
					this.keypath = keypath;
					this.setValue( value );
					return;
				}
				// If we resolved previously, we need to unregister
				if ( this.registered ) {
					// undefined or null
					this.root.viewmodel.unregister( this.keypath, this );
					this.registered = false;
					wasResolved = true;
				}
				this.keypath = keypath;
				// If the new keypath exists, we need to register
				// with the viewmodel
				if ( keypath != undefined ) {
					// undefined or null
					value = this.root.viewmodel.get( keypath );
					this.root.viewmodel.register( keypath, this );
					this.registered = true;
				}
				// Either way we need to queue up a render (`value`
				// will be `undefined` if there's no keypath)
				this.setValue( value );
				// Two-way bindings need to point to their new target keypath
				if ( wasResolved && ( twowayBinding = this.twowayBinding ) ) {
					twowayBinding.rebound();
				}
			};
		}( isNumeric );

		/* virtualdom/items/shared/Mustache/rebind.js */
		var rebind = function Mustache$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
			// Children first
			if ( this.fragments ) {
				this.fragments.forEach( function( f ) {
					return f.rebind( indexRef, newIndex, oldKeypath, newKeypath );
				} );
			}
			// Expression mustache?
			if ( this.resolver ) {
				this.resolver.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			}
		};

		/* virtualdom/items/shared/Mustache/_Mustache.js */
		var Mustache = function( getValue, init, resolve, rebind ) {

			return {
				getValue: getValue,
				init: init,
				resolve: resolve,
				rebind: rebind
			};
		}( getValue, initialise, resolve, rebind );

		/* virtualdom/items/Interpolator.js */
		var Interpolator = function( types, runloop, escapeHtml, detachNode, isEqual, unbind, Mustache, detach ) {

			var Interpolator = function( options ) {
				this.type = types.INTERPOLATOR;
				Mustache.init( this, options );
			};
			Interpolator.prototype = {
				update: function() {
					this.node.data = this.value == undefined ? '' : this.value;
				},
				resolve: Mustache.resolve,
				rebind: Mustache.rebind,
				detach: detach,
				unbind: unbind,
				render: function() {
					if ( !this.node ) {
						this.node = document.createTextNode( this.value != undefined ? this.value : '' );
					}
					return this.node;
				},
				unrender: function( shouldDestroy ) {
					if ( shouldDestroy ) {
						detachNode( this.node );
					}
				},
				getValue: Mustache.getValue,
				// TEMP
				setValue: function( value ) {
					var wrapper;
					// TODO is there a better way to approach this?
					if ( wrapper = this.root.viewmodel.wrapped[ this.keypath ] ) {
						value = wrapper.get();
					}
					if ( !isEqual( value, this.value ) ) {
						this.value = value;
						this.parentFragment.bubble();
						if ( this.node ) {
							runloop.addView( this );
						}
					}
				},
				firstNode: function() {
					return this.node;
				},
				toString: function( escape ) {
					var string = this.value != undefined ? '' + this.value : '';
					return escape ? escapeHtml( string ) : string;
				}
			};
			return Interpolator;
		}( types, runloop, escapeHtml, detachNode, isEqual, unbind, Mustache, detach );

		/* virtualdom/items/Section/prototype/bubble.js */
		var virtualdom_items_Section$bubble = function Section$bubble() {
			this.parentFragment.bubble();
		};

		/* virtualdom/items/Section/prototype/detach.js */
		var virtualdom_items_Section$detach = function Section$detach() {
			var docFrag;
			if ( this.fragments.length === 1 ) {
				return this.fragments[ 0 ].detach();
			}
			docFrag = document.createDocumentFragment();
			this.fragments.forEach( function( item ) {
				docFrag.appendChild( item.detach() );
			} );
			return docFrag;
		};

		/* virtualdom/items/Section/prototype/find.js */
		var virtualdom_items_Section$find = function Section$find( selector ) {
			var i, len, queryResult;
			len = this.fragments.length;
			for ( i = 0; i < len; i += 1 ) {
				if ( queryResult = this.fragments[ i ].find( selector ) ) {
					return queryResult;
				}
			}
			return null;
		};

		/* virtualdom/items/Section/prototype/findAll.js */
		var virtualdom_items_Section$findAll = function Section$findAll( selector, query ) {
			var i, len;
			len = this.fragments.length;
			for ( i = 0; i < len; i += 1 ) {
				this.fragments[ i ].findAll( selector, query );
			}
		};

		/* virtualdom/items/Section/prototype/findAllComponents.js */
		var virtualdom_items_Section$findAllComponents = function Section$findAllComponents( selector, query ) {
			var i, len;
			len = this.fragments.length;
			for ( i = 0; i < len; i += 1 ) {
				this.fragments[ i ].findAllComponents( selector, query );
			}
		};

		/* virtualdom/items/Section/prototype/findComponent.js */
		var virtualdom_items_Section$findComponent = function Section$findComponent( selector ) {
			var i, len, queryResult;
			len = this.fragments.length;
			for ( i = 0; i < len; i += 1 ) {
				if ( queryResult = this.fragments[ i ].findComponent( selector ) ) {
					return queryResult;
				}
			}
			return null;
		};

		/* virtualdom/items/Section/prototype/findNextNode.js */
		var virtualdom_items_Section$findNextNode = function Section$findNextNode( fragment ) {
			if ( this.fragments[ fragment.index + 1 ] ) {
				return this.fragments[ fragment.index + 1 ].firstNode();
			}
			return this.parentFragment.findNextNode( this );
		};

		/* virtualdom/items/Section/prototype/firstNode.js */
		var virtualdom_items_Section$firstNode = function Section$firstNode() {
			var len, i, node;
			if ( len = this.fragments.length ) {
				for ( i = 0; i < len; i += 1 ) {
					if ( node = this.fragments[ i ].firstNode() ) {
						return node;
					}
				}
			}
			return this.parentFragment.findNextNode( this );
		};

		/* virtualdom/items/Section/prototype/shuffle.js */
		var virtualdom_items_Section$shuffle = function( types, runloop, circular ) {

			var Fragment;
			circular.push( function() {
				Fragment = circular.Fragment;
			} );
			return function Section$shuffle( newIndices ) {
				var this$0 = this;
				var section = this,
					parentFragment, firstChange, i, newLength, reboundFragments, fragmentOptions, fragment;
				// short circuit any double-updates, and ensure that this isn't applied to
				// non-list sections
				if ( this.shuffling || this.unbound || this.subtype && this.subtype !== types.SECTION_EACH ) {
					return;
				}
				this.shuffling = true;
				runloop.scheduleTask( function() {
					return this$0.shuffling = false;
				} );
				parentFragment = this.parentFragment;
				reboundFragments = [];
				// first, rebind existing fragments
				newIndices.forEach( function rebindIfNecessary( newIndex, oldIndex ) {
					var fragment, by, oldKeypath, newKeypath;
					if ( newIndex === oldIndex ) {
						reboundFragments[ newIndex ] = section.fragments[ oldIndex ];
						return;
					}
					fragment = section.fragments[ oldIndex ];
					if ( firstChange === undefined ) {
						firstChange = oldIndex;
					}
					// does this fragment need to be torn down?
					if ( newIndex === -1 ) {
						section.fragmentsToUnrender.push( fragment );
						fragment.unbind();
						return;
					}
					// Otherwise, it needs to be rebound to a new index
					by = newIndex - oldIndex;
					oldKeypath = section.keypath + '.' + oldIndex;
					newKeypath = section.keypath + '.' + newIndex;
					fragment.rebind( section.template.i, newIndex, oldKeypath, newKeypath );
					fragment.index = newIndex;
					reboundFragments[ newIndex ] = fragment;
				} );
				newLength = this.root.get( this.keypath ).length;
				// If nothing changed with the existing fragments, then we start adding
				// new fragments at the end...
				if ( firstChange === undefined ) {
					// ...unless there are no new fragments to add
					if ( this.length === newLength ) {
						return;
					}
					firstChange = this.length;
				}
				this.length = this.fragments.length = newLength;
				if ( this.rendered ) {
					runloop.addView( this );
				}
				// Prepare new fragment options
				fragmentOptions = {
					template: this.template.f,
					root: this.root,
					owner: this
				};
				if ( this.template.i ) {
					fragmentOptions.indexRef = this.template.i;
				}
				// Add as many new fragments as we need to, or add back existing
				// (detached) fragments
				for ( i = firstChange; i < newLength; i += 1 ) {
					fragment = reboundFragments[ i ];
					if ( !fragment ) {
						this.fragmentsToCreate.push( i );
					}
					this.fragments[ i ] = fragment;
				}
			};
		}( types, runloop, circular );

		/* virtualdom/items/Section/prototype/render.js */
		var virtualdom_items_Section$render = function Section$render() {
			var docFrag;
			docFrag = this.docFrag = document.createDocumentFragment();
			this.update();
			this.rendered = true;
			return docFrag;
		};

		/* utils/isArrayLike.js */
		var isArrayLike = function() {

			var pattern = /^\[object (?:Array|FileList)\]$/,
				toString = Object.prototype.toString;
			return function isArrayLike( obj ) {
				return pattern.test( toString.call( obj ) );
			};
		}();

		/* virtualdom/items/Section/prototype/setValue.js */
		var virtualdom_items_Section$setValue = function( types, isArrayLike, isObject, runloop, circular ) {

			var __export;
			var Fragment;
			circular.push( function() {
				Fragment = circular.Fragment;
			} );
			__export = function Section$setValue( value ) {
				var this$0 = this;
				var wrapper, fragmentOptions;
				if ( this.updating ) {
					// If a child of this section causes a re-evaluation - for example, an
					// expression refers to a function that mutates the array that this
					// section depends on - we'll end up with a double rendering bug (see
					// https://github.com/ractivejs/ractive/issues/748). This prevents it.
					return;
				}
				this.updating = true;
				// with sections, we need to get the fake value if we have a wrapped object
				if ( wrapper = this.root.viewmodel.wrapped[ this.keypath ] ) {
					value = wrapper.get();
				}
				// If any fragments are awaiting creation after a splice,
				// this is the place to do it
				if ( this.fragmentsToCreate.length ) {
					fragmentOptions = {
						template: this.template.f,
						root: this.root,
						pElement: this.pElement,
						owner: this,
						indexRef: this.template.i
					};
					this.fragmentsToCreate.forEach( function( index ) {
						var fragment;
						fragmentOptions.context = this$0.keypath + '.' + index;
						fragmentOptions.index = index;
						fragment = new Fragment( fragmentOptions );
						this$0.fragmentsToRender.push( this$0.fragments[ index ] = fragment );
					} );
					this.fragmentsToCreate.length = 0;
				} else if ( reevaluateSection( this, value ) ) {
					this.bubble();
					if ( this.rendered ) {
						runloop.addView( this );
					}
				}
				this.value = value;
				this.updating = false;
			};

			function reevaluateSection( section, value ) {
				var fragmentOptions = {
					template: section.template.f,
					root: section.root,
					pElement: section.parentFragment.pElement,
					owner: section
				};
				// If we already know the section type, great
				// TODO can this be optimised? i.e. pick an reevaluateSection function during init
				// and avoid doing this each time?
				if ( section.subtype ) {
					switch ( section.subtype ) {
						case types.SECTION_IF:
							return reevaluateConditionalSection( section, value, false, fragmentOptions );
						case types.SECTION_UNLESS:
							return reevaluateConditionalSection( section, value, true, fragmentOptions );
						case types.SECTION_WITH:
							return reevaluateContextSection( section, fragmentOptions );
						case types.SECTION_IF_WITH:
							return reevaluateConditionalContextSection( section, value, fragmentOptions );
						case types.SECTION_EACH:
							if ( isObject( value ) ) {
								return reevaluateListObjectSection( section, value, fragmentOptions );
							}
					}
				}
				// Otherwise we need to work out what sort of section we're dealing with
				section.ordered = !!isArrayLike( value );
				// Ordered list section
				if ( section.ordered ) {
					return reevaluateListSection( section, value, fragmentOptions );
				}
				// Unordered list, or context
				if ( isObject( value ) || typeof value === 'function' ) {
					// Index reference indicates section should be treated as a list
					if ( section.template.i ) {
						return reevaluateListObjectSection( section, value, fragmentOptions );
					}
					// Otherwise, object provides context for contents
					return reevaluateContextSection( section, fragmentOptions );
				}
				// Conditional section
				return reevaluateConditionalSection( section, value, false, fragmentOptions );
			}

			function reevaluateListSection( section, value, fragmentOptions ) {
				var i, length, fragment;
				length = value.length;
				if ( length === section.length ) {
					// Nothing to do
					return false;
				}
				// if the array is shorter than it was previously, remove items
				if ( length < section.length ) {
					section.fragmentsToUnrender = section.fragments.splice( length, section.length - length );
					section.fragmentsToUnrender.forEach( unbind );
				} else {
					if ( length > section.length ) {
						// add any new ones
						for ( i = section.length; i < length; i += 1 ) {
							// append list item to context stack
							fragmentOptions.context = section.keypath + '.' + i;
							fragmentOptions.index = i;
							if ( section.template.i ) {
								fragmentOptions.indexRef = section.template.i;
							}
							fragment = new Fragment( fragmentOptions );
							section.fragmentsToRender.push( section.fragments[ i ] = fragment );
						}
					}
				}
				section.length = length;
				return true;
			}

			function reevaluateListObjectSection( section, value, fragmentOptions ) {
				var id, i, hasKey, fragment, changed;
				hasKey = section.hasKey || ( section.hasKey = {} );
				// remove any fragments that should no longer exist
				i = section.fragments.length;
				while ( i-- ) {
					fragment = section.fragments[ i ];
					if ( !( fragment.index in value ) ) {
						changed = true;
						fragment.unbind();
						section.fragmentsToUnrender.push( fragment );
						section.fragments.splice( i, 1 );
						hasKey[ fragment.index ] = false;
					}
				}
				// add any that haven't been created yet
				for ( id in value ) {
					if ( !hasKey[ id ] ) {
						changed = true;
						fragmentOptions.context = section.keypath + '.' + id;
						fragmentOptions.index = id;
						if ( section.template.i ) {
							fragmentOptions.indexRef = section.template.i;
						}
						fragment = new Fragment( fragmentOptions );
						section.fragmentsToRender.push( fragment );
						section.fragments.push( fragment );
						hasKey[ id ] = true;
					}
				}
				section.length = section.fragments.length;
				return changed;
			}

			function reevaluateConditionalContextSection( section, value, fragmentOptions ) {
				if ( value ) {
					return reevaluateContextSection( section, fragmentOptions );
				} else {
					return removeSectionFragments( section );
				}
			}

			function reevaluateContextSection( section, fragmentOptions ) {
				var fragment;
				// ...then if it isn't rendered, render it, adding section.keypath to the context stack
				// (if it is already rendered, then any children dependent on the context stack
				// will update themselves without any prompting)
				if ( !section.length ) {
					// append this section to the context stack
					fragmentOptions.context = section.keypath;
					fragmentOptions.index = 0;
					fragment = new Fragment( fragmentOptions );
					section.fragmentsToRender.push( section.fragments[ 0 ] = fragment );
					section.length = 1;
					return true;
				}
			}

			function reevaluateConditionalSection( section, value, inverted, fragmentOptions ) {
				var doRender, emptyArray, emptyObject, fragment, name;
				emptyArray = isArrayLike( value ) && value.length === 0;
				emptyObject = false;
				if ( !isArrayLike( value ) && isObject( value ) ) {
					emptyObject = true;
					for ( name in value ) {
						emptyObject = false;
						break;
					}
				}
				if ( inverted ) {
					doRender = emptyArray || emptyObject || !value;
				} else {
					doRender = value && !emptyArray && !emptyObject;
				}
				if ( doRender ) {
					if ( !section.length ) {
						// no change to context stack
						fragmentOptions.index = 0;
						fragment = new Fragment( fragmentOptions );
						section.fragmentsToRender.push( section.fragments[ 0 ] = fragment );
						section.length = 1;
						return true;
					}
					if ( section.length > 1 ) {
						section.fragmentsToUnrender = section.fragments.splice( 1 );
						section.fragmentsToUnrender.forEach( unbind );
						return true;
					}
				} else {
					return removeSectionFragments( section );
				}
			}

			function removeSectionFragments( section ) {
				if ( section.length ) {
					section.fragmentsToUnrender = section.fragments.splice( 0, section.fragments.length ).filter( isRendered );
					section.fragmentsToUnrender.forEach( unbind );
					section.length = section.fragmentsToRender.length = 0;
					return true;
				}
			}

			function unbind( fragment ) {
				fragment.unbind();
			}

			function isRendered( fragment ) {
				return fragment.rendered;
			}
			return __export;
		}( types, isArrayLike, isObject, runloop, circular );

		/* virtualdom/items/Section/prototype/toString.js */
		var virtualdom_items_Section$toString = function Section$toString( escape ) {
			var str, i, len;
			str = '';
			i = 0;
			len = this.length;
			for ( i = 0; i < len; i += 1 ) {
				str += this.fragments[ i ].toString( escape );
			}
			return str;
		};

		/* virtualdom/items/Section/prototype/unbind.js */
		var virtualdom_items_Section$unbind = function( unbind ) {

			var __export;
			__export = function Section$unbind() {
				this.fragments.forEach( unbindFragment );
				unbind.call( this );
				this.length = 0;
				this.unbound = true;
			};

			function unbindFragment( fragment ) {
				fragment.unbind();
			}
			return __export;
		}( unbind );

		/* virtualdom/items/Section/prototype/unrender.js */
		var virtualdom_items_Section$unrender = function() {

			var __export;
			__export = function Section$unrender( shouldDestroy ) {
				this.fragments.forEach( shouldDestroy ? unrenderAndDestroy : unrender );
			};

			function unrenderAndDestroy( fragment ) {
				fragment.unrender( true );
			}

			function unrender( fragment ) {
				fragment.unrender( false );
			}
			return __export;
		}();

		/* virtualdom/items/Section/prototype/update.js */
		var virtualdom_items_Section$update = function Section$update() {
			var fragment, renderIndex, renderedFragments, anchor, target, i, len;
			// `this.renderedFragments` is in the order of the previous render.
			// If fragments have shuffled about, this allows us to quickly
			// reinsert them in the correct place
			renderedFragments = this.renderedFragments;
			// Remove fragments that have been marked for destruction
			while ( fragment = this.fragmentsToUnrender.pop() ) {
				fragment.unrender( true );
				renderedFragments.splice( renderedFragments.indexOf( fragment ), 1 );
			}
			// Render new fragments (but don't insert them yet)
			while ( fragment = this.fragmentsToRender.shift() ) {
				fragment.render();
			}
			if ( this.rendered ) {
				target = this.parentFragment.getNode();
			}
			len = this.fragments.length;
			for ( i = 0; i < len; i += 1 ) {
				fragment = this.fragments[ i ];
				renderIndex = renderedFragments.indexOf( fragment, i );
				// search from current index - it's guaranteed to be the same or higher
				if ( renderIndex === i ) {
					// already in the right place. insert accumulated nodes (if any) and carry on
					if ( this.docFrag.childNodes.length ) {
						anchor = fragment.firstNode();
						target.insertBefore( this.docFrag, anchor );
					}
					continue;
				}
				this.docFrag.appendChild( fragment.detach() );
				// update renderedFragments
				if ( renderIndex !== -1 ) {
					renderedFragments.splice( renderIndex, 1 );
				}
				renderedFragments.splice( i, 0, fragment );
			}
			if ( this.rendered && this.docFrag.childNodes.length ) {
				anchor = this.parentFragment.findNextNode( this );
				target.insertBefore( this.docFrag, anchor );
			}
			// Save the rendering order for next time
			this.renderedFragments = this.fragments.slice();
		};

		/* virtualdom/items/Section/_Section.js */
		var Section = function( types, Mustache, bubble, detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, shuffle, render, setValue, toString, unbind, unrender, update ) {

			var Section = function( options ) {
				this.type = types.SECTION;
				this.subtype = options.template.n;
				this.inverted = this.subtype === types.SECTION_UNLESS;
				this.pElement = options.pElement;
				this.fragments = [];
				this.fragmentsToCreate = [];
				this.fragmentsToRender = [];
				this.fragmentsToUnrender = [];
				this.renderedFragments = [];
				this.length = 0;
				// number of times this section is rendered
				Mustache.init( this, options );
			};
			Section.prototype = {
				bubble: bubble,
				detach: detach,
				find: find,
				findAll: findAll,
				findAllComponents: findAllComponents,
				findComponent: findComponent,
				findNextNode: findNextNode,
				firstNode: firstNode,
				getValue: Mustache.getValue,
				shuffle: shuffle,
				rebind: Mustache.rebind,
				render: render,
				resolve: Mustache.resolve,
				setValue: setValue,
				toString: toString,
				unbind: unbind,
				unrender: unrender,
				update: update
			};
			return Section;
		}( types, Mustache, virtualdom_items_Section$bubble, virtualdom_items_Section$detach, virtualdom_items_Section$find, virtualdom_items_Section$findAll, virtualdom_items_Section$findAllComponents, virtualdom_items_Section$findComponent, virtualdom_items_Section$findNextNode, virtualdom_items_Section$firstNode, virtualdom_items_Section$shuffle, virtualdom_items_Section$render, virtualdom_items_Section$setValue, virtualdom_items_Section$toString, virtualdom_items_Section$unbind, virtualdom_items_Section$unrender, virtualdom_items_Section$update );

		/* virtualdom/items/Triple/prototype/detach.js */
		var virtualdom_items_Triple$detach = function Triple$detach() {
			var len, i;
			if ( this.docFrag ) {
				len = this.nodes.length;
				for ( i = 0; i < len; i += 1 ) {
					this.docFrag.appendChild( this.nodes[ i ] );
				}
				return this.docFrag;
			}
		};

		/* virtualdom/items/Triple/prototype/find.js */
		var virtualdom_items_Triple$find = function( matches ) {

			return function Triple$find( selector ) {
				var i, len, node, queryResult;
				len = this.nodes.length;
				for ( i = 0; i < len; i += 1 ) {
					node = this.nodes[ i ];
					if ( node.nodeType !== 1 ) {
						continue;
					}
					if ( matches( node, selector ) ) {
						return node;
					}
					if ( queryResult = node.querySelector( selector ) ) {
						return queryResult;
					}
				}
				return null;
			};
		}( matches );

		/* virtualdom/items/Triple/prototype/findAll.js */
		var virtualdom_items_Triple$findAll = function( matches ) {

			return function Triple$findAll( selector, queryResult ) {
				var i, len, node, queryAllResult, numNodes, j;
				len = this.nodes.length;
				for ( i = 0; i < len; i += 1 ) {
					node = this.nodes[ i ];
					if ( node.nodeType !== 1 ) {
						continue;
					}
					if ( matches( node, selector ) ) {
						queryResult.push( node );
					}
					if ( queryAllResult = node.querySelectorAll( selector ) ) {
						numNodes = queryAllResult.length;
						for ( j = 0; j < numNodes; j += 1 ) {
							queryResult.push( queryAllResult[ j ] );
						}
					}
				}
			};
		}( matches );

		/* virtualdom/items/Triple/prototype/firstNode.js */
		var virtualdom_items_Triple$firstNode = function Triple$firstNode() {
			if ( this.rendered && this.nodes[ 0 ] ) {
				return this.nodes[ 0 ];
			}
			return this.parentFragment.findNextNode( this );
		};

		/* virtualdom/items/Triple/helpers/insertHtml.js */
		var insertHtml = function( namespaces, createElement ) {

			var __export;
			var elementCache = {},
				ieBug, ieBlacklist;
			try {
				createElement( 'table' ).innerHTML = 'foo';
			} catch ( err ) {
				ieBug = true;
				ieBlacklist = {
					TABLE: [
						'<table class="x">',
						'</table>'
					],
					THEAD: [
						'<table><thead class="x">',
						'</thead></table>'
					],
					TBODY: [
						'<table><tbody class="x">',
						'</tbody></table>'
					],
					TR: [
						'<table><tr class="x">',
						'</tr></table>'
					],
					SELECT: [
						'<select class="x">',
						'</select>'
					]
				};
			}
			__export = function( html, node, docFrag ) {
				var container, nodes = [],
					wrapper, selectedOption, child, i;
				// render 0 and false
				if ( html != null && html !== '' ) {
					if ( ieBug && ( wrapper = ieBlacklist[ node.tagName ] ) ) {
						container = element( 'DIV' );
						container.innerHTML = wrapper[ 0 ] + html + wrapper[ 1 ];
						container = container.querySelector( '.x' );
						if ( container.tagName === 'SELECT' ) {
							selectedOption = container.options[ container.selectedIndex ];
						}
					} else if ( node.namespaceURI === namespaces.svg ) {
						container = element( 'DIV' );
						container.innerHTML = '<svg class="x">' + html + '</svg>';
						container = container.querySelector( '.x' );
					} else {
						container = element( node.tagName );
						container.innerHTML = html;
						if ( container.tagName === 'SELECT' ) {
							selectedOption = container.options[ container.selectedIndex ];
						}
					}
					while ( child = container.firstChild ) {
						nodes.push( child );
						docFrag.appendChild( child );
					}
					// This is really annoying. Extracting <option> nodes from the
					// temporary container <select> causes the remaining ones to
					// become selected. So now we have to deselect them. IE8, you
					// amaze me. You really do
					// ...and now Chrome too
					if ( node.tagName === 'SELECT' ) {
						i = nodes.length;
						while ( i-- ) {
							if ( nodes[ i ] !== selectedOption ) {
								nodes[ i ].selected = false;
							}
						}
					}
				}
				return nodes;
			};

			function element( tagName ) {
				return elementCache[ tagName ] || ( elementCache[ tagName ] = createElement( tagName ) );
			}
			return __export;
		}( namespaces, createElement );

		/* utils/toArray.js */
		var toArray = function toArray( arrayLike ) {
			var array = [],
				i = arrayLike.length;
			while ( i-- ) {
				array[ i ] = arrayLike[ i ];
			}
			return array;
		};

		/* virtualdom/items/Triple/helpers/updateSelect.js */
		var updateSelect = function( toArray ) {

			var __export;
			__export = function updateSelect( parentElement ) {
				var selectedOptions, option, value;
				if ( !parentElement || parentElement.name !== 'select' || !parentElement.binding ) {
					return;
				}
				selectedOptions = toArray( parentElement.node.options ).filter( isSelected );
				// If one of them had a `selected` attribute, we need to sync
				// the model to the view
				if ( parentElement.getAttribute( 'multiple' ) ) {
					value = selectedOptions.map( function( o ) {
						return o.value;
					} );
				} else if ( option = selectedOptions[ 0 ] ) {
					value = option.value;
				}
				if ( value !== undefined ) {
					parentElement.binding.setValue( value );
				}
				parentElement.bubble();
			};

			function isSelected( option ) {
				return option.selected;
			}
			return __export;
		}( toArray );

		/* virtualdom/items/Triple/prototype/render.js */
		var virtualdom_items_Triple$render = function( insertHtml, updateSelect ) {

			return function Triple$render() {
				if ( this.rendered ) {
					throw new Error( 'Attempted to render an item that was already rendered' );
				}
				this.docFrag = document.createDocumentFragment();
				this.nodes = insertHtml( this.value, this.parentFragment.getNode(), this.docFrag );
				// Special case - we're inserting the contents of a <select>
				updateSelect( this.pElement );
				this.rendered = true;
				return this.docFrag;
			};
		}( insertHtml, updateSelect );

		/* virtualdom/items/Triple/prototype/setValue.js */
		var virtualdom_items_Triple$setValue = function( runloop ) {

			return function Triple$setValue( value ) {
				var wrapper;
				// TODO is there a better way to approach this?
				if ( wrapper = this.root.viewmodel.wrapped[ this.keypath ] ) {
					value = wrapper.get();
				}
				if ( value !== this.value ) {
					this.value = value;
					this.parentFragment.bubble();
					if ( this.rendered ) {
						runloop.addView( this );
					}
				}
			};
		}( runloop );

		/* virtualdom/items/Triple/prototype/toString.js */
		var virtualdom_items_Triple$toString = function( decodeCharacterReferences ) {

			return function Triple$toString() {
				return this.value != undefined ? decodeCharacterReferences( '' + this.value ) : '';
			};
		}( decodeCharacterReferences );

		/* virtualdom/items/Triple/prototype/unrender.js */
		var virtualdom_items_Triple$unrender = function( detachNode ) {

			return function Triple$unrender( shouldDestroy ) {
				if ( this.rendered && shouldDestroy ) {
					this.nodes.forEach( detachNode );
					this.rendered = false;
				}
			};
		}( detachNode );

		/* virtualdom/items/Triple/prototype/update.js */
		var virtualdom_items_Triple$update = function( insertHtml, updateSelect ) {

			return function Triple$update() {
				var node, parentNode;
				if ( !this.rendered ) {
					return;
				}
				// Remove existing nodes
				while ( this.nodes && this.nodes.length ) {
					node = this.nodes.pop();
					node.parentNode.removeChild( node );
				}
				// Insert new nodes
				parentNode = this.parentFragment.getNode();
				this.nodes = insertHtml( this.value, parentNode, this.docFrag );
				parentNode.insertBefore( this.docFrag, this.parentFragment.findNextNode( this ) );
				// Special case - we're inserting the contents of a <select>
				updateSelect( this.pElement );
			};
		}( insertHtml, updateSelect );

		/* virtualdom/items/Triple/_Triple.js */
		var Triple = function( types, Mustache, detach, find, findAll, firstNode, render, setValue, toString, unrender, update, unbind ) {

			var Triple = function( options ) {
				this.type = types.TRIPLE;
				Mustache.init( this, options );
			};
			Triple.prototype = {
				detach: detach,
				find: find,
				findAll: findAll,
				firstNode: firstNode,
				getValue: Mustache.getValue,
				rebind: Mustache.rebind,
				render: render,
				resolve: Mustache.resolve,
				setValue: setValue,
				toString: toString,
				unbind: unbind,
				unrender: unrender,
				update: update
			};
			return Triple;
		}( types, Mustache, virtualdom_items_Triple$detach, virtualdom_items_Triple$find, virtualdom_items_Triple$findAll, virtualdom_items_Triple$firstNode, virtualdom_items_Triple$render, virtualdom_items_Triple$setValue, virtualdom_items_Triple$toString, virtualdom_items_Triple$unrender, virtualdom_items_Triple$update, unbind );

		/* virtualdom/items/Element/prototype/bubble.js */
		var virtualdom_items_Element$bubble = function() {
			this.parentFragment.bubble();
		};

		/* virtualdom/items/Element/prototype/detach.js */
		var virtualdom_items_Element$detach = function Element$detach() {
			var node = this.node,
				parentNode;
			if ( node ) {
				// need to check for parent node - DOM may have been altered
				// by something other than Ractive! e.g. jQuery UI...
				if ( parentNode = node.parentNode ) {
					parentNode.removeChild( node );
				}
				return node;
			}
		};

		/* virtualdom/items/Element/prototype/find.js */
		var virtualdom_items_Element$find = function( matches ) {

			return function( selector ) {
				if ( matches( this.node, selector ) ) {
					return this.node;
				}
				if ( this.fragment && this.fragment.find ) {
					return this.fragment.find( selector );
				}
			};
		}( matches );

		/* virtualdom/items/Element/prototype/findAll.js */
		var virtualdom_items_Element$findAll = function( selector, query ) {
			// Add this node to the query, if applicable, and register the
			// query on this element
			if ( query._test( this, true ) && query.live ) {
				( this.liveQueries || ( this.liveQueries = [] ) ).push( query );
			}
			if ( this.fragment ) {
				this.fragment.findAll( selector, query );
			}
		};

		/* virtualdom/items/Element/prototype/findAllComponents.js */
		var virtualdom_items_Element$findAllComponents = function( selector, query ) {
			if ( this.fragment ) {
				this.fragment.findAllComponents( selector, query );
			}
		};

		/* virtualdom/items/Element/prototype/findComponent.js */
		var virtualdom_items_Element$findComponent = function( selector ) {
			if ( this.fragment ) {
				return this.fragment.findComponent( selector );
			}
		};

		/* virtualdom/items/Element/prototype/findNextNode.js */
		var virtualdom_items_Element$findNextNode = function Element$findNextNode() {
			return null;
		};

		/* virtualdom/items/Element/prototype/firstNode.js */
		var virtualdom_items_Element$firstNode = function Element$firstNode() {
			return this.node;
		};

		/* virtualdom/items/Element/prototype/getAttribute.js */
		var virtualdom_items_Element$getAttribute = function Element$getAttribute( name ) {
			if ( !this.attributes || !this.attributes[ name ] ) {
				return;
			}
			return this.attributes[ name ].value;
		};

		/* virtualdom/items/Element/shared/enforceCase.js */
		var enforceCase = function() {

			var svgCamelCaseElements, svgCamelCaseAttributes, createMap, map;
			svgCamelCaseElements = 'altGlyph altGlyphDef altGlyphItem animateColor animateMotion animateTransform clipPath feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur feImage feMerge feMergeNode feMorphology feOffset fePointLight feSpecularLighting feSpotLight feTile feTurbulence foreignObject glyphRef linearGradient radialGradient textPath vkern'.split( ' ' );
			svgCamelCaseAttributes = 'attributeName attributeType baseFrequency baseProfile calcMode clipPathUnits contentScriptType contentStyleType diffuseConstant edgeMode externalResourcesRequired filterRes filterUnits glyphRef gradientTransform gradientUnits kernelMatrix kernelUnitLength keyPoints keySplines keyTimes lengthAdjust limitingConeAngle markerHeight markerUnits markerWidth maskContentUnits maskUnits numOctaves pathLength patternContentUnits patternTransform patternUnits pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits refX refY repeatCount repeatDur requiredExtensions requiredFeatures specularConstant specularExponent spreadMethod startOffset stdDeviation stitchTiles surfaceScale systemLanguage tableValues targetX targetY textLength viewBox viewTarget xChannelSelector yChannelSelector zoomAndPan'.split( ' ' );
			createMap = function( items ) {
				var map = {},
					i = items.length;
				while ( i-- ) {
					map[ items[ i ].toLowerCase() ] = items[ i ];
				}
				return map;
			};
			map = createMap( svgCamelCaseElements.concat( svgCamelCaseAttributes ) );
			return function( elementName ) {
				var lowerCaseElementName = elementName.toLowerCase();
				return map[ lowerCaseElementName ] || lowerCaseElementName;
			};
		}();

		/* virtualdom/items/Element/Attribute/prototype/bubble.js */
		var virtualdom_items_Element_Attribute$bubble = function( runloop, isEqual ) {

			return function Attribute$bubble() {
				var value = this.fragment.getValue();
				// TODO this can register the attribute multiple times (see render test
				// 'Attribute with nested mustaches')
				if ( !isEqual( value, this.value ) ) {
					// Need to clear old id from ractive.nodes
					if ( this.name === 'id' && this.value ) {
						delete this.root.nodes[ this.value ];
					}
					this.value = value;
					if ( this.name === 'value' && this.node ) {
						// We need to store the value on the DOM like this so we
						// can retrieve it later without it being coerced to a string
						this.node._ractive.value = value;
					}
					if ( this.rendered ) {
						runloop.addView( this );
					}
				}
			};
		}( runloop, isEqual );

		/* config/booleanAttributes.js */
		var booleanAttributes = function() {

			// https://github.com/kangax/html-minifier/issues/63#issuecomment-37763316
			var booleanAttributes = /^(allowFullscreen|async|autofocus|autoplay|checked|compact|controls|declare|default|defaultChecked|defaultMuted|defaultSelected|defer|disabled|draggable|enabled|formNoValidate|hidden|indeterminate|inert|isMap|itemScope|loop|multiple|muted|noHref|noResize|noShade|noValidate|noWrap|open|pauseOnExit|readOnly|required|reversed|scoped|seamless|selected|sortable|translate|trueSpeed|typeMustMatch|visible)$/i;
			return booleanAttributes;
		}();

		/* virtualdom/items/Element/Attribute/helpers/determineNameAndNamespace.js */
		var determineNameAndNamespace = function( namespaces, enforceCase ) {

			return function( attribute, name ) {
				var colonIndex, namespacePrefix;
				// are we dealing with a namespaced attribute, e.g. xlink:href?
				colonIndex = name.indexOf( ':' );
				if ( colonIndex !== -1 ) {
					// looks like we are, yes...
					namespacePrefix = name.substr( 0, colonIndex );
					// ...unless it's a namespace *declaration*, which we ignore (on the assumption
					// that only valid namespaces will be used)
					if ( namespacePrefix !== 'xmlns' ) {
						name = name.substring( colonIndex + 1 );
						attribute.name = enforceCase( name );
						attribute.namespace = namespaces[ namespacePrefix.toLowerCase() ];
						attribute.namespacePrefix = namespacePrefix;
						if ( !attribute.namespace ) {
							throw 'Unknown namespace ("' + namespacePrefix + '")';
						}
						return;
					}
				}
				// SVG attribute names are case sensitive
				attribute.name = attribute.element.namespace !== namespaces.html ? enforceCase( name ) : name;
			};
		}( namespaces, enforceCase );

		/* virtualdom/items/Element/Attribute/helpers/getInterpolator.js */
		var getInterpolator = function( types ) {

			return function getInterpolator( attribute ) {
				var items = attribute.fragment.items;
				if ( items.length !== 1 ) {
					return;
				}
				if ( items[ 0 ].type === types.INTERPOLATOR ) {
					return items[ 0 ];
				}
			};
		}( types );

		/* virtualdom/items/Element/Attribute/helpers/determinePropertyName.js */
		var determinePropertyName = function( namespaces, booleanAttributes ) {

			var propertyNames = {
				'accept-charset': 'acceptCharset',
				accesskey: 'accessKey',
				bgcolor: 'bgColor',
				'class': 'className',
				codebase: 'codeBase',
				colspan: 'colSpan',
				contenteditable: 'contentEditable',
				datetime: 'dateTime',
				dirname: 'dirName',
				'for': 'htmlFor',
				'http-equiv': 'httpEquiv',
				ismap: 'isMap',
				maxlength: 'maxLength',
				novalidate: 'noValidate',
				pubdate: 'pubDate',
				readonly: 'readOnly',
				rowspan: 'rowSpan',
				tabindex: 'tabIndex',
				usemap: 'useMap'
			};
			return function( attribute, options ) {
				var propertyName;
				if ( attribute.pNode && !attribute.namespace && ( !options.pNode.namespaceURI || options.pNode.namespaceURI === namespaces.html ) ) {
					propertyName = propertyNames[ attribute.name ] || attribute.name;
					if ( options.pNode[ propertyName ] !== undefined ) {
						attribute.propertyName = propertyName;
					}
					// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.
					// node.selected = true rather than node.setAttribute( 'selected', '' )
					if ( booleanAttributes.test( propertyName ) || propertyName === 'value' ) {
						attribute.useProperty = true;
					}
				}
			};
		}( namespaces, booleanAttributes );

		/* virtualdom/items/Element/Attribute/prototype/init.js */
		var virtualdom_items_Element_Attribute$init = function( types, booleanAttributes, determineNameAndNamespace, getInterpolator, determinePropertyName, circular ) {

			var Fragment;
			circular.push( function() {
				Fragment = circular.Fragment;
			} );
			return function Attribute$init( options ) {
				this.type = types.ATTRIBUTE;
				this.element = options.element;
				this.root = options.root;
				determineNameAndNamespace( this, options.name );
				// if it's an empty attribute, or just a straight key-value pair, with no
				// mustache shenanigans, set the attribute accordingly and go home
				if ( !options.value || typeof options.value === 'string' ) {
					this.value = booleanAttributes.test( this.name ) ? true : options.value || '';
					return;
				}
				// otherwise we need to do some work
				// share parentFragment with parent element
				this.parentFragment = this.element.parentFragment;
				this.fragment = new Fragment( {
					template: options.value,
					root: this.root,
					owner: this
				} );
				this.value = this.fragment.getValue();
				// Store a reference to this attribute's interpolator, if its fragment
				// takes the form `{{foo}}`. This is necessary for two-way binding and
				// for correctly rendering HTML later
				this.interpolator = getInterpolator( this );
				this.isBindable = !!this.interpolator && !this.interpolator.isStatic;
				// can we establish this attribute's property name equivalent?
				determinePropertyName( this, options );
				// mark as ready
				this.ready = true;
			};
		}( types, booleanAttributes, determineNameAndNamespace, getInterpolator, determinePropertyName, circular );

		/* virtualdom/items/Element/Attribute/prototype/rebind.js */
		var virtualdom_items_Element_Attribute$rebind = function Attribute$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
			if ( this.fragment ) {
				this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			}
		};

		/* virtualdom/items/Element/Attribute/prototype/render.js */
		var virtualdom_items_Element_Attribute$render = function( namespaces, booleanAttributes ) {

			var propertyNames = {
				'accept-charset': 'acceptCharset',
				'accesskey': 'accessKey',
				'bgcolor': 'bgColor',
				'class': 'className',
				'codebase': 'codeBase',
				'colspan': 'colSpan',
				'contenteditable': 'contentEditable',
				'datetime': 'dateTime',
				'dirname': 'dirName',
				'for': 'htmlFor',
				'http-equiv': 'httpEquiv',
				'ismap': 'isMap',
				'maxlength': 'maxLength',
				'novalidate': 'noValidate',
				'pubdate': 'pubDate',
				'readonly': 'readOnly',
				'rowspan': 'rowSpan',
				'tabindex': 'tabIndex',
				'usemap': 'useMap'
			};
			return function Attribute$render( node ) {
				var propertyName;
				this.node = node;
				// should we use direct property access, or setAttribute?
				if ( !node.namespaceURI || node.namespaceURI === namespaces.html ) {
					propertyName = propertyNames[ this.name ] || this.name;
					if ( node[ propertyName ] !== undefined ) {
						this.propertyName = propertyName;
					}
					// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.
					// node.selected = true rather than node.setAttribute( 'selected', '' )
					if ( booleanAttributes.test( propertyName ) || propertyName === 'value' ) {
						this.useProperty = true;
					}
					if ( propertyName === 'value' ) {
						this.useProperty = true;
						node._ractive.value = this.value;
					}
				}
				this.rendered = true;
				this.update();
			};
		}( namespaces, booleanAttributes );

		/* virtualdom/items/Element/Attribute/prototype/toString.js */
		var virtualdom_items_Element_Attribute$toString = function( booleanAttributes ) {

			var __export;
			__export = function Attribute$toString() {
				var name = ( fragment = this ).name,
					namespacePrefix = fragment.namespacePrefix,
					value = fragment.value,
					interpolator = fragment.interpolator,
					fragment = fragment.fragment;
				// Special case - select and textarea values (should not be stringified)
				if ( name === 'value' && ( this.element.name === 'select' || this.element.name === 'textarea' ) ) {
					return;
				}
				// Special case - content editable
				if ( name === 'value' && this.element.getAttribute( 'contenteditable' ) !== undefined ) {
					return;
				}
				// Special case - radio names
				if ( name === 'name' && this.element.name === 'input' && interpolator ) {
					return 'name={{' + ( interpolator.keypath || interpolator.ref ) + '}}';
				}
				// Boolean attributes
				if ( booleanAttributes.test( name ) ) {
					return value ? name : '';
				}
				if ( fragment ) {
					value = fragment.toString();
				}
				if ( namespacePrefix ) {
					name = namespacePrefix + ':' + name;
				}
				return value ? name + '="' + escape( value ) + '"' : name;
			};

			function escape( value ) {
				return value.replace( /&/g, '&amp;' ).replace( /"/g, '&quot;' ).replace( /'/g, '&#39;' );
			}
			return __export;
		}( booleanAttributes );

		/* virtualdom/items/Element/Attribute/prototype/unbind.js */
		var virtualdom_items_Element_Attribute$unbind = function Attribute$unbind() {
			// ignore non-dynamic attributes
			if ( this.fragment ) {
				this.fragment.unbind();
			}
			if ( this.name === 'id' ) {
				delete this.root.nodes[ this.value ];
			}
		};

		/* virtualdom/items/Element/Attribute/prototype/update/updateSelectValue.js */
		var virtualdom_items_Element_Attribute$update_updateSelectValue = function Attribute$updateSelect() {
			var value = this.value,
				options, option, optionValue, i;
			if ( !this.locked ) {
				this.node._ractive.value = value;
				options = this.node.options;
				i = options.length;
				while ( i-- ) {
					option = options[ i ];
					optionValue = option._ractive ? option._ractive.value : option.value;
					// options inserted via a triple don't have _ractive
					if ( optionValue == value ) {
						// double equals as we may be comparing numbers with strings
						option.selected = true;
						break;
					}
				}
			}
		};

		/* utils/arrayContains.js */
		var arrayContains = function arrayContains( array, value ) {
			for ( var i = 0, c = array.length; i < c; i++ ) {
				if ( array[ i ] == value ) {
					return true;
				}
			}
			return false;
		};

		/* virtualdom/items/Element/Attribute/prototype/update/updateMultipleSelectValue.js */
		var virtualdom_items_Element_Attribute$update_updateMultipleSelectValue = function( arrayContains, isArray ) {

			return function Attribute$updateMultipleSelect() {
				var value = this.value,
					options, i, option, optionValue;
				if ( !isArray( value ) ) {
					value = [ value ];
				}
				options = this.node.options;
				i = options.length;
				while ( i-- ) {
					option = options[ i ];
					optionValue = option._ractive ? option._ractive.value : option.value;
					// options inserted via a triple don't have _ractive
					option.selected = arrayContains( value, optionValue );
				}
			};
		}( arrayContains, isArray );

		/* virtualdom/items/Element/Attribute/prototype/update/updateRadioName.js */
		var virtualdom_items_Element_Attribute$update_updateRadioName = function Attribute$updateRadioName() {
			var node = ( value = this ).node,
				value = value.value;
			node.checked = value == node._ractive.value;
		};

		/* virtualdom/items/Element/Attribute/prototype/update/updateRadioValue.js */
		var virtualdom_items_Element_Attribute$update_updateRadioValue = function( runloop ) {

			return function Attribute$updateRadioValue() {
				var wasChecked, node = this.node,
					binding, bindings, i;
				wasChecked = node.checked;
				node.value = this.element.getAttribute( 'value' );
				node.checked = this.element.getAttribute( 'value' ) === this.element.getAttribute( 'name' );
				// This is a special case - if the input was checked, and the value
				// changed so that it's no longer checked, the twoway binding is
				// most likely out of date. To fix it we have to jump through some
				// hoops... this is a little kludgy but it works
				if ( wasChecked && !node.checked && this.element.binding ) {
					bindings = this.element.binding.siblings;
					if ( i = bindings.length ) {
						while ( i-- ) {
							binding = bindings[ i ];
							if ( !binding.element.node ) {
								// this is the initial render, siblings are still rendering!
								// we'll come back later...
								return;
							}
							if ( binding.element.node.checked ) {
								runloop.addViewmodel( binding.root.viewmodel );
								return binding.handleChange();
							}
						}
						runloop.addViewmodel( binding.root.viewmodel );
						this.root.viewmodel.set( binding.keypath, undefined );
					}
				}
			};
		}( runloop );

		/* virtualdom/items/Element/Attribute/prototype/update/updateCheckboxName.js */
		var virtualdom_items_Element_Attribute$update_updateCheckboxName = function( isArray ) {

			return function Attribute$updateCheckboxName() {
				var element = ( value = this ).element,
					node = value.node,
					value = value.value,
					valueAttribute, i;
				valueAttribute = element.getAttribute( 'value' );
				if ( !isArray( value ) ) {
					node.checked = value == valueAttribute;
				} else {
					i = value.length;
					while ( i-- ) {
						if ( valueAttribute == value[ i ] ) {
							node.checked = true;
							return;
						}
					}
					node.checked = false;
				}
			};
		}( isArray );

		/* virtualdom/items/Element/Attribute/prototype/update/updateClassName.js */
		var virtualdom_items_Element_Attribute$update_updateClassName = function Attribute$updateClassName() {
			var node, value;
			node = this.node;
			value = this.value;
			if ( value === undefined ) {
				value = '';
			}
			node.className = value;
		};

		/* virtualdom/items/Element/Attribute/prototype/update/updateIdAttribute.js */
		var virtualdom_items_Element_Attribute$update_updateIdAttribute = function Attribute$updateIdAttribute() {
			var node = ( value = this ).node,
				value = value.value;
			this.root.nodes[ value ] = node;
			node.id = value;
		};

		/* virtualdom/items/Element/Attribute/prototype/update/updateIEStyleAttribute.js */
		var virtualdom_items_Element_Attribute$update_updateIEStyleAttribute = function Attribute$updateIEStyleAttribute() {
			var node, value;
			node = this.node;
			value = this.value;
			if ( value === undefined ) {
				value = '';
			}
			node.style.setAttribute( 'cssText', value );
		};

		/* virtualdom/items/Element/Attribute/prototype/update/updateContentEditableValue.js */
		var virtualdom_items_Element_Attribute$update_updateContentEditableValue = function Attribute$updateContentEditableValue() {
			var value = this.value;
			if ( value === undefined ) {
				value = '';
			}
			if ( !this.locked ) {
				this.node.innerHTML = value;
			}
		};

		/* virtualdom/items/Element/Attribute/prototype/update/updateValue.js */
		var virtualdom_items_Element_Attribute$update_updateValue = function Attribute$updateValue() {
			var node = ( value = this ).node,
				value = value.value;
			// store actual value, so it doesn't get coerced to a string
			node._ractive.value = value;
			// with two-way binding, only update if the change wasn't initiated by the user
			// otherwise the cursor will often be sent to the wrong place
			if ( !this.locked ) {
				node.value = value == undefined ? '' : value;
			}
		};

		/* virtualdom/items/Element/Attribute/prototype/update/updateBoolean.js */
		var virtualdom_items_Element_Attribute$update_updateBoolean = function Attribute$updateBooleanAttribute() {
			// with two-way binding, only update if the change wasn't initiated by the user
			// otherwise the cursor will often be sent to the wrong place
			if ( !this.locked ) {
				this.node[ this.propertyName ] = this.value;
			}
		};

		/* virtualdom/items/Element/Attribute/prototype/update/updateEverythingElse.js */
		var virtualdom_items_Element_Attribute$update_updateEverythingElse = function( booleanAttributes ) {

			return function Attribute$updateEverythingElse() {
				var node = ( fragment = this ).node,
					namespace = fragment.namespace,
					name = fragment.name,
					value = fragment.value,
					fragment = fragment.fragment;
				if ( namespace ) {
					node.setAttributeNS( namespace, name, ( fragment || value ).toString() );
				} else if ( !booleanAttributes.test( name ) ) {
					node.setAttribute( name, ( fragment || value ).toString() );
				} else {
					if ( value ) {
						node.setAttribute( name, '' );
					} else {
						node.removeAttribute( name );
					}
				}
			};
		}( booleanAttributes );

		/* virtualdom/items/Element/Attribute/prototype/update.js */
		var virtualdom_items_Element_Attribute$update = function( namespaces, noop, updateSelectValue, updateMultipleSelectValue, updateRadioName, updateRadioValue, updateCheckboxName, updateClassName, updateIdAttribute, updateIEStyleAttribute, updateContentEditableValue, updateValue, updateBoolean, updateEverythingElse ) {

			return function Attribute$update() {
				var name = ( node = this ).name,
					element = node.element,
					node = node.node,
					type, updateMethod;
				if ( name === 'id' ) {
					updateMethod = updateIdAttribute;
				} else if ( name === 'value' ) {
					// special case - selects
					if ( element.name === 'select' && name === 'value' ) {
						updateMethod = element.getAttribute( 'multiple' ) ? updateMultipleSelectValue : updateSelectValue;
					} else if ( element.name === 'textarea' ) {
						updateMethod = updateValue;
					} else if ( element.getAttribute( 'contenteditable' ) != null ) {
						updateMethod = updateContentEditableValue;
					} else if ( element.name === 'input' ) {
						type = element.getAttribute( 'type' );
						// type='file' value='{{fileList}}'>
						if ( type === 'file' ) {
							updateMethod = noop;
						} else if ( type === 'radio' && element.binding && element.binding.name === 'name' ) {
							updateMethod = updateRadioValue;
						} else {
							updateMethod = updateValue;
						}
					}
				} else if ( this.twoway && name === 'name' ) {
					if ( node.type === 'radio' ) {
						updateMethod = updateRadioName;
					} else if ( node.type === 'checkbox' ) {
						updateMethod = updateCheckboxName;
					}
				} else if ( name === 'style' && node.style.setAttribute ) {
					updateMethod = updateIEStyleAttribute;
				} else if ( name === 'class' && ( !node.namespaceURI || node.namespaceURI === namespaces.html ) ) {
					updateMethod = updateClassName;
				} else if ( this.useProperty ) {
					updateMethod = updateBoolean;
				}
				if ( !updateMethod ) {
					updateMethod = updateEverythingElse;
				}
				this.update = updateMethod;
				this.update();
			};
		}( namespaces, noop, virtualdom_items_Element_Attribute$update_updateSelectValue, virtualdom_items_Element_Attribute$update_updateMultipleSelectValue, virtualdom_items_Element_Attribute$update_updateRadioName, virtualdom_items_Element_Attribute$update_updateRadioValue, virtualdom_items_Element_Attribute$update_updateCheckboxName, virtualdom_items_Element_Attribute$update_updateClassName, virtualdom_items_Element_Attribute$update_updateIdAttribute, virtualdom_items_Element_Attribute$update_updateIEStyleAttribute, virtualdom_items_Element_Attribute$update_updateContentEditableValue, virtualdom_items_Element_Attribute$update_updateValue, virtualdom_items_Element_Attribute$update_updateBoolean, virtualdom_items_Element_Attribute$update_updateEverythingElse );

		/* virtualdom/items/Element/Attribute/_Attribute.js */
		var Attribute = function( bubble, init, rebind, render, toString, unbind, update ) {

			var Attribute = function( options ) {
				this.init( options );
			};
			Attribute.prototype = {
				bubble: bubble,
				init: init,
				rebind: rebind,
				render: render,
				toString: toString,
				unbind: unbind,
				update: update
			};
			return Attribute;
		}( virtualdom_items_Element_Attribute$bubble, virtualdom_items_Element_Attribute$init, virtualdom_items_Element_Attribute$rebind, virtualdom_items_Element_Attribute$render, virtualdom_items_Element_Attribute$toString, virtualdom_items_Element_Attribute$unbind, virtualdom_items_Element_Attribute$update );

		/* virtualdom/items/Element/prototype/init/createAttributes.js */
		var virtualdom_items_Element$init_createAttributes = function( Attribute ) {

			return function( element, attributes ) {
				var name, attribute, result = [];
				for ( name in attributes ) {
					if ( attributes.hasOwnProperty( name ) ) {
						attribute = new Attribute( {
							element: element,
							name: name,
							value: attributes[ name ],
							root: element.root
						} );
						result.push( result[ name ] = attribute );
					}
				}
				return result;
			};
		}( Attribute );

		/* virtualdom/items/Element/ConditionalAttribute/_ConditionalAttribute.js */
		var ConditionalAttribute = function( circular, namespaces, createElement, toArray ) {

			var __export;
			var Fragment, div;
			if ( typeof document !== 'undefined' ) {
				div = createElement( 'div' );
			}
			circular.push( function() {
				Fragment = circular.Fragment;
			} );
			var ConditionalAttribute = function( element, template ) {
				this.element = element;
				this.root = element.root;
				this.parentFragment = element.parentFragment;
				this.attributes = [];
				this.fragment = new Fragment( {
					root: element.root,
					owner: this,
					template: [ template ]
				} );
			};
			ConditionalAttribute.prototype = {
				bubble: function() {
					if ( this.node ) {
						this.update();
					}
					this.element.bubble();
				},
				rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
					this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
				},
				render: function( node ) {
					this.node = node;
					this.isSvg = node.namespaceURI === namespaces.svg;
					this.update();
				},
				unbind: function() {
					this.fragment.unbind();
				},
				update: function() {
					var this$0 = this;
					var str, attrs;
					str = this.fragment.toString();
					attrs = parseAttributes( str, this.isSvg );
					// any attributes that previously existed but no longer do
					// must be removed
					this.attributes.filter( function( a ) {
						return notIn( attrs, a );
					} ).forEach( function( a ) {
						this$0.node.removeAttribute( a.name );
					} );
					attrs.forEach( function( a ) {
						this$0.node.setAttribute( a.name, a.value );
					} );
					this.attributes = attrs;
				},
				toString: function() {
					return this.fragment.toString();
				}
			};
			__export = ConditionalAttribute;

			function parseAttributes( str, isSvg ) {
				var tag = isSvg ? 'svg' : 'div';
				div.innerHTML = '<' + tag + ' ' + str + '></' + tag + '>';
				return toArray( div.childNodes[ 0 ].attributes );
			}

			function notIn( haystack, needle ) {
				var i = haystack.length;
				while ( i-- ) {
					if ( haystack[ i ].name === needle.name ) {
						return false;
					}
				}
				return true;
			}
			return __export;
		}( circular, namespaces, createElement, toArray );

		/* virtualdom/items/Element/prototype/init/createConditionalAttributes.js */
		var virtualdom_items_Element$init_createConditionalAttributes = function( ConditionalAttribute ) {

			return function( element, attributes ) {
				if ( !attributes ) {
					return [];
				}
				return attributes.map( function( a ) {
					return new ConditionalAttribute( element, a );
				} );
			};
		}( ConditionalAttribute );

		/* utils/extend.js */
		var extend = function( target ) {
			var SLICE$0 = Array.prototype.slice;
			var sources = SLICE$0.call( arguments, 1 );
			var prop, source;
			while ( source = sources.shift() ) {
				for ( prop in source ) {
					if ( source.hasOwnProperty( prop ) ) {
						target[ prop ] = source[ prop ];
					}
				}
			}
			return target;
		};

		/* virtualdom/items/Element/Binding/Binding.js */
		var Binding = function( runloop, warn, create, extend, removeFromArray ) {

			var Binding = function( element ) {
				var interpolator, keypath, value;
				this.element = element;
				this.root = element.root;
				this.attribute = element.attributes[ this.name || 'value' ];
				interpolator = this.attribute.interpolator;
				interpolator.twowayBinding = this;
				if ( interpolator.keypath && interpolator.keypath.substr( 0, 2 ) === '${' ) {
					warn( 'Two-way binding does not work with expressions (`' + interpolator.keypath.slice( 2, -1 ) + '`)' );
					return false;
				}
				// A mustache may be *ambiguous*. Let's say we were given
				// `value="{{bar}}"`. If the context was `foo`, and `foo.bar`
				// *wasn't* `undefined`, the keypath would be `foo.bar`.
				// Then, any user input would result in `foo.bar` being updated.
				//
				// If, however, `foo.bar` *was* undefined, and so was `bar`, we would be
				// left with an unresolved partial keypath - so we are forced to make an
				// assumption. That assumption is that the input in question should
				// be forced to resolve to `bar`, and any user input would affect `bar`
				// and not `foo.bar`.
				//
				// Did that make any sense? No? Oh. Sorry. Well the moral of the story is
				// be explicit when using two-way data-binding about what keypath you're
				// updating. Using it in lists is probably a recipe for confusion...
				if ( !interpolator.keypath ) {
					interpolator.resolver.forceResolution();
				}
				this.keypath = keypath = interpolator.keypath;
				// initialise value, if it's undefined
				if ( this.root.viewmodel.get( keypath ) === undefined && this.getInitialValue ) {
					value = this.getInitialValue();
					if ( value !== undefined ) {
						this.root.viewmodel.set( keypath, value );
					}
				}
			};
			Binding.prototype = {
				handleChange: function() {
					var this$0 = this;
					runloop.start( this.root );
					this.attribute.locked = true;
					this.root.viewmodel.set( this.keypath, this.getValue() );
					runloop.scheduleTask( function() {
						return this$0.attribute.locked = false;
					} );
					runloop.end();
				},
				rebound: function() {
					var bindings, oldKeypath, newKeypath;
					oldKeypath = this.keypath;
					newKeypath = this.attribute.interpolator.keypath;
					// The attribute this binding is linked to has already done the work
					if ( oldKeypath === newKeypath ) {
						return;
					}
					removeFromArray( this.root._twowayBindings[ oldKeypath ], this );
					this.keypath = newKeypath;
					bindings = this.root._twowayBindings[ newKeypath ] || ( this.root._twowayBindings[ newKeypath ] = [] );
					bindings.push( this );
				},
				unbind: function() {}
			};
			Binding.extend = function( properties ) {
				var Parent = this,
					SpecialisedBinding;
				SpecialisedBinding = function( element ) {
					Binding.call( this, element );
					if ( this.init ) {
						this.init();
					}
				};
				SpecialisedBinding.prototype = create( Parent.prototype );
				extend( SpecialisedBinding.prototype, properties );
				SpecialisedBinding.extend = Binding.extend;
				return SpecialisedBinding;
			};
			return Binding;
		}( runloop, warn, create, extend, removeFromArray );

		/* virtualdom/items/Element/Binding/shared/handleDomEvent.js */
		var handleDomEvent = function handleChange() {
			this._ractive.binding.handleChange();
		};

		/* virtualdom/items/Element/Binding/ContentEditableBinding.js */
		var ContentEditableBinding = function( Binding, handleDomEvent ) {

			var ContentEditableBinding = Binding.extend( {
				getInitialValue: function() {
					return this.element.fragment ? this.element.fragment.toString() : '';
				},
				render: function() {
					var node = this.element.node;
					node.addEventListener( 'change', handleDomEvent, false );
					if ( !this.root.lazy ) {
						node.addEventListener( 'input', handleDomEvent, false );
						if ( node.attachEvent ) {
							node.addEventListener( 'keyup', handleDomEvent, false );
						}
					}
				},
				unrender: function() {
					var node = this.element.node;
					node.removeEventListener( 'change', handleDomEvent, false );
					node.removeEventListener( 'input', handleDomEvent, false );
					node.removeEventListener( 'keyup', handleDomEvent, false );
				},
				getValue: function() {
					return this.element.node.innerHTML;
				}
			} );
			return ContentEditableBinding;
		}( Binding, handleDomEvent );

		/* virtualdom/items/Element/Binding/shared/getSiblings.js */
		var getSiblings = function() {

			var sets = {};
			return function getSiblings( id, group, keypath ) {
				var hash = id + group + keypath;
				return sets[ hash ] || ( sets[ hash ] = [] );
			};
		}();

		/* virtualdom/items/Element/Binding/RadioBinding.js */
		var RadioBinding = function( runloop, removeFromArray, Binding, getSiblings, handleDomEvent ) {

			var RadioBinding = Binding.extend( {
				name: 'checked',
				init: function() {
					this.siblings = getSiblings( this.root._guid, 'radio', this.element.getAttribute( 'name' ) );
					this.siblings.push( this );
				},
				render: function() {
					var node = this.element.node;
					node.addEventListener( 'change', handleDomEvent, false );
					if ( node.attachEvent ) {
						node.addEventListener( 'click', handleDomEvent, false );
					}
				},
				unrender: function() {
					var node = this.element.node;
					node.removeEventListener( 'change', handleDomEvent, false );
					node.removeEventListener( 'click', handleDomEvent, false );
				},
				handleChange: function() {
					runloop.start( this.root );
					this.siblings.forEach( function( binding ) {
						binding.root.viewmodel.set( binding.keypath, binding.getValue() );
					} );
					runloop.end();
				},
				getValue: function() {
					return this.element.node.checked;
				},
				unbind: function() {
					removeFromArray( this.siblings, this );
				}
			} );
			return RadioBinding;
		}( runloop, removeFromArray, Binding, getSiblings, handleDomEvent );

		/* virtualdom/items/Element/Binding/RadioNameBinding.js */
		var RadioNameBinding = function( removeFromArray, Binding, handleDomEvent, getSiblings ) {

			var RadioNameBinding = Binding.extend( {
				name: 'name',
				init: function() {
					this.siblings = getSiblings( this.root._guid, 'radioname', this.keypath );
					this.siblings.push( this );
					this.radioName = true;
					// so that ractive.updateModel() knows what to do with this
					this.attribute.twoway = true;
				},
				getInitialValue: function() {
					if ( this.element.getAttribute( 'checked' ) ) {
						return this.element.getAttribute( 'value' );
					}
				},
				render: function() {
					var node = this.element.node;
					node.name = '{{' + this.keypath + '}}';
					node.checked = this.root.viewmodel.get( this.keypath ) == this.element.getAttribute( 'value' );
					node.addEventListener( 'change', handleDomEvent, false );
					if ( node.attachEvent ) {
						node.addEventListener( 'click', handleDomEvent, false );
					}
				},
				unrender: function() {
					var node = this.element.node;
					node.removeEventListener( 'change', handleDomEvent, false );
					node.removeEventListener( 'click', handleDomEvent, false );
				},
				getValue: function() {
					var node = this.element.node;
					return node._ractive ? node._ractive.value : node.value;
				},
				handleChange: function() {
					// If this <input> is the one that's checked, then the value of its
					// `name` keypath gets set to its value
					if ( this.element.node.checked ) {
						Binding.prototype.handleChange.call( this );
					}
				},
				rebound: function( indexRef, newIndex, oldKeypath, newKeypath ) {
					var node;
					Binding.prototype.rebound.call( this, indexRef, newIndex, oldKeypath, newKeypath );
					if ( node = this.element.node ) {
						node.name = '{{' + this.keypath + '}}';
					}
				},
				unbind: function() {
					removeFromArray( this.siblings, this );
				}
			} );
			return RadioNameBinding;
		}( removeFromArray, Binding, handleDomEvent, getSiblings );

		/* virtualdom/items/Element/Binding/CheckboxNameBinding.js */
		var CheckboxNameBinding = function( isArray, arrayContains, removeFromArray, Binding, getSiblings, handleDomEvent ) {

			var CheckboxNameBinding = Binding.extend( {
				name: 'name',
				getInitialValue: function() {
					// This only gets called once per group (of inputs that
					// share a name), because it only gets called if there
					// isn't an initial value. By the same token, we can make
					// a note of that fact that there was no initial value,
					// and populate it using any `checked` attributes that
					// exist (which users should avoid, but which we should
					// support anyway to avoid breaking expectations)
					this.noInitialValue = true;
					return [];
				},
				init: function() {
					var existingValue, bindingValue;
					this.checkboxName = true;
					// so that ractive.updateModel() knows what to do with this
					this.attribute.twoway = true;
					// we set this property so that the attribute gets the correct update method
					// Each input has a reference to an array containing it and its
					// siblings, as two-way binding depends on being able to ascertain
					// the status of all inputs within the group
					this.siblings = getSiblings( this.root._guid, 'checkboxes', this.keypath );
					this.siblings.push( this );
					if ( this.noInitialValue ) {
						this.siblings.noInitialValue = true;
					}
					// If no initial value was set, and this input is checked, we
					// update the model
					if ( this.siblings.noInitialValue && this.element.getAttribute( 'checked' ) ) {
						existingValue = this.root.viewmodel.get( this.keypath );
						bindingValue = this.element.getAttribute( 'value' );
						existingValue.push( bindingValue );
					}
				},
				unbind: function() {
					removeFromArray( this.siblings, this );
				},
				render: function() {
					var node = this.element.node,
						existingValue, bindingValue;
					existingValue = this.root.viewmodel.get( this.keypath );
					bindingValue = this.element.getAttribute( 'value' );
					if ( isArray( existingValue ) ) {
						this.isChecked = arrayContains( existingValue, bindingValue );
					} else {
						this.isChecked = existingValue == bindingValue;
					}
					node.name = '{{' + this.keypath + '}}';
					node.checked = this.isChecked;
					node.addEventListener( 'change', handleDomEvent, false );
					// in case of IE emergency, bind to click event as well
					if ( node.attachEvent ) {
						node.addEventListener( 'click', handleDomEvent, false );
					}
				},
				unrender: function() {
					var node = this.element.node;
					node.removeEventListener( 'change', handleDomEvent, false );
					node.removeEventListener( 'click', handleDomEvent, false );
				},
				changed: function() {
					var wasChecked = !!this.isChecked;
					this.isChecked = this.element.node.checked;
					return this.isChecked === wasChecked;
				},
				handleChange: function() {
					this.isChecked = this.element.node.checked;
					Binding.prototype.handleChange.call( this );
				},
				getValue: function() {
					return this.siblings.filter( isChecked ).map( getValue );
				}
			} );

			function isChecked( binding ) {
				return binding.isChecked;
			}

			function getValue( binding ) {
				return binding.element.getAttribute( 'value' );
			}
			return CheckboxNameBinding;
		}( isArray, arrayContains, removeFromArray, Binding, getSiblings, handleDomEvent );

		/* virtualdom/items/Element/Binding/CheckboxBinding.js */
		var CheckboxBinding = function( Binding, handleDomEvent ) {

			var CheckboxBinding = Binding.extend( {
				name: 'checked',
				render: function() {
					var node = this.element.node;
					node.addEventListener( 'change', handleDomEvent, false );
					if ( node.attachEvent ) {
						node.addEventListener( 'click', handleDomEvent, false );
					}
				},
				unrender: function() {
					var node = this.element.node;
					node.removeEventListener( 'change', handleDomEvent, false );
					node.removeEventListener( 'click', handleDomEvent, false );
				},
				getValue: function() {
					return this.element.node.checked;
				}
			} );
			return CheckboxBinding;
		}( Binding, handleDomEvent );

		/* virtualdom/items/Element/Binding/SelectBinding.js */
		var SelectBinding = function( runloop, Binding, handleDomEvent ) {

			var SelectBinding = Binding.extend( {
				getInitialValue: function() {
					var options = this.element.options,
						len, i, value, optionWasSelected;
					if ( this.element.getAttribute( 'value' ) !== undefined ) {
						return;
					}
					i = len = options.length;
					if ( !len ) {
						return;
					}
					// take the final selected option...
					while ( i-- ) {
						if ( options[ i ].getAttribute( 'selected' ) ) {
							value = options[ i ].getAttribute( 'value' );
							optionWasSelected = true;
							break;
						}
					}
					// or the first non-disabled option, if none are selected
					if ( !optionWasSelected ) {
						while ( ++i < len ) {
							if ( !options[ i ].getAttribute( 'disabled' ) ) {
								value = options[ i ].getAttribute( 'value' );
								break;
							}
						}
					}
					// This is an optimisation (aka hack) that allows us to forgo some
					// other more expensive work
					if ( value !== undefined ) {
						this.element.attributes.value.value = value;
					}
					return value;
				},
				render: function() {
					this.element.node.addEventListener( 'change', handleDomEvent, false );
				},
				unrender: function() {
					this.element.node.removeEventListener( 'change', handleDomEvent, false );
				},
				// TODO this method is an anomaly... is it necessary?
				setValue: function( value ) {
					runloop.addViewmodel( this.root.viewmodel );
					this.root.viewmodel.set( this.keypath, value );
				},
				getValue: function() {
					var options, i, len, option, optionValue;
					options = this.element.node.options;
					len = options.length;
					for ( i = 0; i < len; i += 1 ) {
						option = options[ i ];
						if ( options[ i ].selected ) {
							optionValue = option._ractive ? option._ractive.value : option.value;
							return optionValue;
						}
					}
				},
				forceUpdate: function() {
					var this$0 = this;
					var value = this.getValue();
					if ( value !== undefined ) {
						this.attribute.locked = true;
						runloop.addViewmodel( this.root.viewmodel );
						runloop.scheduleTask( function() {
							return this$0.attribute.locked = false;
						} );
						this.root.viewmodel.set( this.keypath, value );
					}
				}
			} );
			return SelectBinding;
		}( runloop, Binding, handleDomEvent );

		/* utils/arrayContentsMatch.js */
		var arrayContentsMatch = function( isArray ) {

			return function( a, b ) {
				var i;
				if ( !isArray( a ) || !isArray( b ) ) {
					return false;
				}
				if ( a.length !== b.length ) {
					return false;
				}
				i = a.length;
				while ( i-- ) {
					if ( a[ i ] !== b[ i ] ) {
						return false;
					}
				}
				return true;
			};
		}( isArray );

		/* virtualdom/items/Element/Binding/MultipleSelectBinding.js */
		var MultipleSelectBinding = function( runloop, arrayContentsMatch, SelectBinding, handleDomEvent ) {

			var MultipleSelectBinding = SelectBinding.extend( {
				getInitialValue: function() {
					return this.element.options.filter( function( option ) {
						return option.getAttribute( 'selected' );
					} ).map( function( option ) {
						return option.getAttribute( 'value' );
					} );
				},
				render: function() {
					var valueFromModel;
					this.element.node.addEventListener( 'change', handleDomEvent, false );
					valueFromModel = this.root.viewmodel.get( this.keypath );
					if ( valueFromModel === undefined ) {
						// get value from DOM, if possible
						this.handleChange();
					}
				},
				unrender: function() {
					this.element.node.removeEventListener( 'change', handleDomEvent, false );
				},
				setValue: function() {
					throw new Error( 'TODO not implemented yet' );
				},
				getValue: function() {
					var selectedValues, options, i, len, option, optionValue;
					selectedValues = [];
					options = this.element.node.options;
					len = options.length;
					for ( i = 0; i < len; i += 1 ) {
						option = options[ i ];
						if ( option.selected ) {
							optionValue = option._ractive ? option._ractive.value : option.value;
							selectedValues.push( optionValue );
						}
					}
					return selectedValues;
				},
				handleChange: function() {
					var attribute, previousValue, value;
					attribute = this.attribute;
					previousValue = attribute.value;
					value = this.getValue();
					if ( previousValue === undefined || !arrayContentsMatch( value, previousValue ) ) {
						SelectBinding.prototype.handleChange.call( this );
					}
					return this;
				},
				forceUpdate: function() {
					var this$0 = this;
					var value = this.getValue();
					if ( value !== undefined ) {
						this.attribute.locked = true;
						runloop.addViewmodel( this.root.viewmodel );
						runloop.scheduleTask( function() {
							return this$0.attribute.locked = false;
						} );
						this.root.viewmodel.set( this.keypath, value );
					}
				},
				updateModel: function() {
					if ( this.attribute.value === undefined || !this.attribute.value.length ) {
						this.root.viewmodel.set( this.keypath, this.initialValue );
					}
				}
			} );
			return MultipleSelectBinding;
		}( runloop, arrayContentsMatch, SelectBinding, handleDomEvent );

		/* virtualdom/items/Element/Binding/FileListBinding.js */
		var FileListBinding = function( Binding, handleDomEvent ) {

			var FileListBinding = Binding.extend( {
				render: function() {
					this.element.node.addEventListener( 'change', handleDomEvent, false );
				},
				unrender: function() {
					this.element.node.removeEventListener( 'change', handleDomEvent, false );
				},
				getValue: function() {
					return this.element.node.files;
				}
			} );
			return FileListBinding;
		}( Binding, handleDomEvent );

		/* virtualdom/items/Element/Binding/GenericBinding.js */
		var GenericBinding = function( Binding, handleDomEvent ) {

			var __export;
			var GenericBinding, getOptions;
			getOptions = {
				evaluateWrapped: true
			};
			GenericBinding = Binding.extend( {
				getInitialValue: function() {
					return '';
				},
				getValue: function() {
					return this.element.node.value;
				},
				render: function() {
					var node = this.element.node;
					node.addEventListener( 'change', handleDomEvent, false );
					if ( !this.root.lazy ) {
						node.addEventListener( 'input', handleDomEvent, false );
						if ( node.attachEvent ) {
							node.addEventListener( 'keyup', handleDomEvent, false );
						}
					}
					node.addEventListener( 'blur', handleBlur, false );
				},
				unrender: function() {
					var node = this.element.node;
					node.removeEventListener( 'change', handleDomEvent, false );
					node.removeEventListener( 'input', handleDomEvent, false );
					node.removeEventListener( 'keyup', handleDomEvent, false );
					node.removeEventListener( 'blur', handleBlur, false );
				}
			} );
			__export = GenericBinding;

			function handleBlur() {
				var value;
				handleDomEvent.call( this );
				value = this._ractive.root.viewmodel.get( this._ractive.binding.keypath, getOptions );
				this.value = value == undefined ? '' : value;
			}
			return __export;
		}( Binding, handleDomEvent );

		/* virtualdom/items/Element/Binding/NumericBinding.js */
		var NumericBinding = function( GenericBinding ) {

			return GenericBinding.extend( {
				getInitialValue: function() {
					return undefined;
				},
				getValue: function() {
					var value = parseFloat( this.element.node.value );
					return isNaN( value ) ? undefined : value;
				}
			} );
		}( GenericBinding );

		/* virtualdom/items/Element/prototype/init/createTwowayBinding.js */
		var virtualdom_items_Element$init_createTwowayBinding = function( log, ContentEditableBinding, RadioBinding, RadioNameBinding, CheckboxNameBinding, CheckboxBinding, SelectBinding, MultipleSelectBinding, FileListBinding, NumericBinding, GenericBinding ) {

			var __export;
			__export = function createTwowayBinding( element ) {
				var attributes = element.attributes,
					type, Binding, bindName, bindChecked;
				// if this is a late binding, and there's already one, it
				// needs to be torn down
				if ( element.binding ) {
					element.binding.teardown();
					element.binding = null;
				}
				// contenteditable
				if ( // if the contenteditable attribute is true or is bindable and may thus become true
					( element.getAttribute( 'contenteditable' ) || !!attributes.contenteditable && isBindable( attributes.contenteditable ) ) && isBindable( attributes.value ) ) {
					Binding = ContentEditableBinding;
				} else if ( element.name === 'input' ) {
					type = element.getAttribute( 'type' );
					if ( type === 'radio' || type === 'checkbox' ) {
						bindName = isBindable( attributes.name );
						bindChecked = isBindable( attributes.checked );
						// we can either bind the name attribute, or the checked attribute - not both
						if ( bindName && bindChecked ) {
							log.error( {
								message: 'badRadioInputBinding'
							} );
						}
						if ( bindName ) {
							Binding = type === 'radio' ? RadioNameBinding : CheckboxNameBinding;
						} else if ( bindChecked ) {
							Binding = type === 'radio' ? RadioBinding : CheckboxBinding;
						}
					} else if ( type === 'file' && isBindable( attributes.value ) ) {
						Binding = FileListBinding;
					} else if ( isBindable( attributes.value ) ) {
						Binding = type === 'number' || type === 'range' ? NumericBinding : GenericBinding;
					}
				} else if ( element.name === 'select' && isBindable( attributes.value ) ) {
					Binding = element.getAttribute( 'multiple' ) ? MultipleSelectBinding : SelectBinding;
				} else if ( element.name === 'textarea' && isBindable( attributes.value ) ) {
					Binding = GenericBinding;
				}
				if ( Binding ) {
					return new Binding( element );
				}
			};

			function isBindable( attribute ) {
				return attribute && attribute.isBindable;
			}
			return __export;
		}( log, ContentEditableBinding, RadioBinding, RadioNameBinding, CheckboxNameBinding, CheckboxBinding, SelectBinding, MultipleSelectBinding, FileListBinding, NumericBinding, GenericBinding );

		/* virtualdom/items/Element/EventHandler/prototype/bubble.js */
		var virtualdom_items_Element_EventHandler$bubble = function EventHandler$bubble() {
			var hasAction = this.getAction();
			if ( hasAction && !this.hasListener ) {
				this.listen();
			} else if ( !hasAction && this.hasListener ) {
				this.unrender();
			}
		};

		/* virtualdom/items/Element/EventHandler/prototype/fire.js */
		var virtualdom_items_Element_EventHandler$fire = function( fireEvent ) {

			return function EventHandler$fire( event ) {
				fireEvent( this.root, this.getAction(), {
					event: event
				} );
			};
		}( Ractive$shared_fireEvent );

		/* virtualdom/items/Element/EventHandler/prototype/getAction.js */
		var virtualdom_items_Element_EventHandler$getAction = function EventHandler$getAction() {
			return this.action.toString().trim();
		};

		/* virtualdom/items/Element/EventHandler/prototype/init.js */
		var virtualdom_items_Element_EventHandler$init = function( getFunctionFromString, createReferenceResolver, circular, fireEvent, log ) {

			var __export;
			var Fragment, getValueOptions = {
					args: true
				},
				eventPattern = /^event(?:\.(.+))?/;
			circular.push( function() {
				Fragment = circular.Fragment;
			} );
			__export = function EventHandler$init( element, name, template ) {
				var handler = this,
					action, refs, ractive;
				handler.element = element;
				handler.root = element.root;
				handler.name = name;
				if ( name.indexOf( '*' ) !== -1 ) {
					log.error( {
						debug: this.root.debug,
						message: 'noElementProxyEventWildcards',
						args: {
							element: element.tagName,
							event: name
						}
					} );
					this.invalid = true;
				}
				if ( template.m ) {
					refs = template.a.r;
					// This is a method call
					handler.method = template.m;
					handler.keypaths = [];
					handler.fn = getFunctionFromString( template.a.s, refs.length );
					handler.parentFragment = element.parentFragment;
					ractive = handler.root;
					// Create resolvers for each reference
					handler.refResolvers = refs.map( function( ref, i ) {
						var match;
						// special case - the `event` object
						if ( match = eventPattern.exec( ref ) ) {
							handler.keypaths[ i ] = {
								eventObject: true,
								refinements: match[ 1 ] ? match[ 1 ].split( '.' ) : []
							};
							return null;
						}
						return createReferenceResolver( handler, ref, function( keypath ) {
							handler.resolve( i, keypath );
						} );
					} );
					this.fire = fireMethodCall;
				} else {
					// Get action ('foo' in 'on-click='foo')
					action = template.n || template;
					if ( typeof action !== 'string' ) {
						action = new Fragment( {
							template: action,
							root: this.root,
							owner: this
						} );
					}
					this.action = action;
					// Get parameters
					if ( template.d ) {
						this.dynamicParams = new Fragment( {
							template: template.d,
							root: this.root,
							owner: this.element
						} );
						this.fire = fireEventWithDynamicParams;
					} else if ( template.a ) {
						this.params = template.a;
						this.fire = fireEventWithParams;
					}
				}
			};

			function fireMethodCall( event ) {
				var ractive, values, args;
				ractive = this.root;
				if ( typeof ractive[ this.method ] !== 'function' ) {
					throw new Error( 'Attempted to call a non-existent method ("' + this.method + '")' );
				}
				values = this.keypaths.map( function( keypath ) {
					var value, len, i;
					if ( keypath === undefined ) {
						// not yet resolved
						return undefined;
					}
					// TODO the refinements stuff would be better handled at parse time
					if ( keypath.eventObject ) {
						value = event;
						if ( len = keypath.refinements.length ) {
							for ( i = 0; i < len; i += 1 ) {
								value = value[ keypath.refinements[ i ] ];
							}
						}
					} else {
						value = ractive.viewmodel.get( keypath );
					}
					return value;
				} );
				ractive.event = event;
				args = this.fn.apply( null, values );
				ractive[ this.method ].apply( ractive, args );
				delete ractive.event;
			}

			function fireEventWithParams( event ) {
				fireEvent( this.root, this.getAction(), {
					event: event,
					args: this.params
				} );
			}

			function fireEventWithDynamicParams( event ) {
				var args = this.dynamicParams.getValue( getValueOptions );
				// need to strip [] from ends if a string!
				if ( typeof args === 'string' ) {
					args = args.substr( 1, args.length - 2 );
				}
				fireEvent( this.root, this.getAction(), {
					event: event,
					args: args
				} );
			}
			return __export;
		}( getFunctionFromString, createReferenceResolver, circular, Ractive$shared_fireEvent, log );

		/* virtualdom/items/Element/EventHandler/shared/genericHandler.js */
		var genericHandler = function genericHandler( event ) {
			var storage, handler;
			storage = this._ractive;
			handler = storage.events[ event.type ];
			handler.fire( {
				node: this,
				original: event,
				index: storage.index,
				keypath: storage.keypath,
				context: storage.root.get( storage.keypath )
			} );
		};

		/* virtualdom/items/Element/EventHandler/prototype/listen.js */
		var virtualdom_items_Element_EventHandler$listen = function( config, genericHandler, log ) {

			var __export;
			var customHandlers = {},
				touchEvents = {
					touchstart: true,
					touchmove: true,
					touchend: true,
					touchcancel: true,
					//not w3c, but supported in some browsers
					touchleave: true
				};
			__export = function EventHandler$listen() {
				var definition, name = this.name;
				if ( this.invalid ) {
					return;
				}
				if ( definition = config.registries.events.find( this.root, name ) ) {
					this.custom = definition( this.node, getCustomHandler( name ) );
				} else {
					// Looks like we're dealing with a standard DOM event... but let's check
					if ( !( 'on' + name in this.node ) && !( window && 'on' + name in window ) ) {
						// okay to use touch events if this browser doesn't support them
						if ( !touchEvents[ name ] ) {
							log.error( {
								debug: this.root.debug,
								message: 'missingPlugin',
								args: {
									plugin: 'event',
									name: name
								}
							} );
						}
						return;
					}
					this.node.addEventListener( name, genericHandler, false );
				}
				this.hasListener = true;
			};

			function getCustomHandler( name ) {
				if ( !customHandlers[ name ] ) {
					customHandlers[ name ] = function( event ) {
						var storage = event.node._ractive;
						event.index = storage.index;
						event.keypath = storage.keypath;
						event.context = storage.root.get( storage.keypath );
						storage.events[ name ].fire( event );
					};
				}
				return customHandlers[ name ];
			}
			return __export;
		}( config, genericHandler, log );

		/* virtualdom/items/Element/EventHandler/prototype/rebind.js */
		var virtualdom_items_Element_EventHandler$rebind = function EventHandler$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
			var fragment;
			if ( this.method ) {
				fragment = this.element.parentFragment;
				this.refResolvers.forEach( rebind );
				return;
			}
			if ( typeof this.action !== 'string' ) {
				rebind( this.action );
			}
			if ( this.dynamicParams ) {
				rebind( this.dynamicParams );
			}

			function rebind( thing ) {
				thing && thing.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			}
		};

		/* virtualdom/items/Element/EventHandler/prototype/render.js */
		var virtualdom_items_Element_EventHandler$render = function EventHandler$render() {
			this.node = this.element.node;
			// store this on the node itself, so it can be retrieved by a
			// universal handler
			this.node._ractive.events[ this.name ] = this;
			if ( this.method || this.getAction() ) {
				this.listen();
			}
		};

		/* virtualdom/items/Element/EventHandler/prototype/resolve.js */
		var virtualdom_items_Element_EventHandler$resolve = function EventHandler$resolve( index, keypath ) {
			this.keypaths[ index ] = keypath;
		};

		/* virtualdom/items/Element/EventHandler/prototype/unbind.js */
		var virtualdom_items_Element_EventHandler$unbind = function() {

			var __export;
			__export = function EventHandler$unbind() {
				if ( this.method ) {
					this.refResolvers.forEach( unbind );
					return;
				}
				// Tear down dynamic name
				if ( typeof this.action !== 'string' ) {
					this.action.unbind();
				}
				// Tear down dynamic parameters
				if ( this.dynamicParams ) {
					this.dynamicParams.unbind();
				}
			};

			function unbind( x ) {
				x.unbind();
			}
			return __export;
		}();

		/* virtualdom/items/Element/EventHandler/prototype/unrender.js */
		var virtualdom_items_Element_EventHandler$unrender = function( genericHandler ) {

			return function EventHandler$unrender() {
				if ( this.custom ) {
					this.custom.teardown();
				} else {
					this.node.removeEventListener( this.name, genericHandler, false );
				}
				this.hasListener = false;
			};
		}( genericHandler );

		/* virtualdom/items/Element/EventHandler/_EventHandler.js */
		var EventHandler = function( bubble, fire, getAction, init, listen, rebind, render, resolve, unbind, unrender ) {

			var EventHandler = function( element, name, template ) {
				this.init( element, name, template );
			};
			EventHandler.prototype = {
				bubble: bubble,
				fire: fire,
				getAction: getAction,
				init: init,
				listen: listen,
				rebind: rebind,
				render: render,
				resolve: resolve,
				unbind: unbind,
				unrender: unrender
			};
			return EventHandler;
		}( virtualdom_items_Element_EventHandler$bubble, virtualdom_items_Element_EventHandler$fire, virtualdom_items_Element_EventHandler$getAction, virtualdom_items_Element_EventHandler$init, virtualdom_items_Element_EventHandler$listen, virtualdom_items_Element_EventHandler$rebind, virtualdom_items_Element_EventHandler$render, virtualdom_items_Element_EventHandler$resolve, virtualdom_items_Element_EventHandler$unbind, virtualdom_items_Element_EventHandler$unrender );

		/* virtualdom/items/Element/prototype/init/createEventHandlers.js */
		var virtualdom_items_Element$init_createEventHandlers = function( EventHandler ) {

			return function( element, template ) {
				var i, name, names, handler, result = [];
				for ( name in template ) {
					if ( template.hasOwnProperty( name ) ) {
						names = name.split( '-' );
						i = names.length;
						while ( i-- ) {
							handler = new EventHandler( element, names[ i ], template[ name ] );
							result.push( handler );
						}
					}
				}
				return result;
			};
		}( EventHandler );

		/* virtualdom/items/Element/Decorator/_Decorator.js */
		var Decorator = function( log, circular, config ) {

			var Fragment, getValueOptions, Decorator;
			circular.push( function() {
				Fragment = circular.Fragment;
			} );
			getValueOptions = {
				args: true
			};
			Decorator = function( element, template ) {
				var decorator = this,
					ractive, name, fragment;
				decorator.element = element;
				decorator.root = ractive = element.root;
				name = template.n || template;
				if ( typeof name !== 'string' ) {
					fragment = new Fragment( {
						template: name,
						root: ractive,
						owner: element
					} );
					name = fragment.toString();
					fragment.unbind();
				}
				if ( template.a ) {
					decorator.params = template.a;
				} else if ( template.d ) {
					decorator.fragment = new Fragment( {
						template: template.d,
						root: ractive,
						owner: element
					} );
					decorator.params = decorator.fragment.getValue( getValueOptions );
					decorator.fragment.bubble = function() {
						this.dirtyArgs = this.dirtyValue = true;
						decorator.params = this.getValue( getValueOptions );
						if ( decorator.ready ) {
							decorator.update();
						}
					};
				}
				decorator.fn = config.registries.decorators.find( ractive, name );
				if ( !decorator.fn ) {
					log.error( {
						debug: ractive.debug,
						message: 'missingPlugin',
						args: {
							plugin: 'decorator',
							name: name
						}
					} );
				}
			};
			Decorator.prototype = {
				init: function() {
					var decorator = this,
						node, result, args;
					node = decorator.element.node;
					if ( decorator.params ) {
						args = [ node ].concat( decorator.params );
						result = decorator.fn.apply( decorator.root, args );
					} else {
						result = decorator.fn.call( decorator.root, node );
					}
					if ( !result || !result.teardown ) {
						throw new Error( 'Decorator definition must return an object with a teardown method' );
					}
					// TODO does this make sense?
					decorator.actual = result;
					decorator.ready = true;
				},
				update: function() {
					if ( this.actual.update ) {
						this.actual.update.apply( this.root, this.params );
					} else {
						this.actual.teardown( true );
						this.init();
					}
				},
				rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
					if ( this.fragment ) {
						this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
					}
				},
				teardown: function( updating ) {
					this.actual.teardown();
					if ( !updating && this.fragment ) {
						this.fragment.unbind();
					}
				}
			};
			return Decorator;
		}( log, circular, config );

		/* virtualdom/items/Element/special/select/sync.js */
		var sync = function( toArray ) {

			var __export;
			__export = function syncSelect( selectElement ) {
				var selectNode, selectValue, isMultiple, options, optionWasSelected;
				selectNode = selectElement.node;
				if ( !selectNode ) {
					return;
				}
				options = toArray( selectNode.options );
				selectValue = selectElement.getAttribute( 'value' );
				isMultiple = selectElement.getAttribute( 'multiple' );
				// If the <select> has a specified value, that should override
				// these options
				if ( selectValue !== undefined ) {
					options.forEach( function( o ) {
						var optionValue, shouldSelect;
						optionValue = o._ractive ? o._ractive.value : o.value;
						shouldSelect = isMultiple ? valueContains( selectValue, optionValue ) : selectValue == optionValue;
						if ( shouldSelect ) {
							optionWasSelected = true;
						}
						o.selected = shouldSelect;
					} );
					if ( !optionWasSelected ) {
						if ( options[ 0 ] ) {
							options[ 0 ].selected = true;
						}
						if ( selectElement.binding ) {
							selectElement.binding.forceUpdate();
						}
					}
				} else if ( selectElement.binding ) {
					selectElement.binding.forceUpdate();
				}
			};

			function valueContains( selectValue, optionValue ) {
				var i = selectValue.length;
				while ( i-- ) {
					if ( selectValue[ i ] == optionValue ) {
						return true;
					}
				}
			}
			return __export;
		}( toArray );

		/* virtualdom/items/Element/special/select/bubble.js */
		var bubble = function( runloop, syncSelect ) {

			return function bubbleSelect() {
				var this$0 = this;
				if ( !this.dirty ) {
					this.dirty = true;
					runloop.scheduleTask( function() {
						syncSelect( this$0 );
						this$0.dirty = false;
					} );
				}
				this.parentFragment.bubble();
			};
		}( runloop, sync );

		/* virtualdom/items/Element/special/option/findParentSelect.js */
		var findParentSelect = function findParentSelect( element ) {
			do {
				if ( element.name === 'select' ) {
					return element;
				}
			} while ( element = element.parent );
		};

		/* virtualdom/items/Element/special/option/init.js */
		var init = function( findParentSelect ) {

			return function initOption( option, template ) {
				option.select = findParentSelect( option.parent );
				// we might be inside a <datalist> element
				if ( !option.select ) {
					return;
				}
				option.select.options.push( option );
				// If the value attribute is missing, use the element's content
				if ( !template.a ) {
					template.a = {};
				}
				// ...as long as it isn't disabled
				if ( template.a.value === undefined && !template.a.hasOwnProperty( 'disabled' ) ) {
					template.a.value = template.f;
				}
				// If there is a `selected` attribute, but the <select>
				// already has a value, delete it
				if ( 'selected' in template.a && option.select.getAttribute( 'value' ) !== undefined ) {
					delete template.a.selected;
				}
			};
		}( findParentSelect );

		/* virtualdom/items/Element/prototype/init.js */
		var virtualdom_items_Element$init = function( types, enforceCase, createAttributes, createConditionalAttributes, createTwowayBinding, createEventHandlers, Decorator, bubbleSelect, initOption, circular ) {

			var Fragment;
			circular.push( function() {
				Fragment = circular.Fragment;
			} );
			return function Element$init( options ) {
				var parentFragment, template, ractive, binding, bindings;
				this.type = types.ELEMENT;
				// stuff we'll need later
				parentFragment = this.parentFragment = options.parentFragment;
				template = this.template = options.template;
				this.parent = options.pElement || parentFragment.pElement;
				this.root = ractive = parentFragment.root;
				this.index = options.index;
				this.name = enforceCase( template.e );
				// Special case - <option> elements
				if ( this.name === 'option' ) {
					initOption( this, template );
				}
				// Special case - <select> elements
				if ( this.name === 'select' ) {
					this.options = [];
					this.bubble = bubbleSelect;
				}
				// create attributes
				this.attributes = createAttributes( this, template.a );
				this.conditionalAttributes = createConditionalAttributes( this, template.m );
				// append children, if there are any
				if ( template.f ) {
					this.fragment = new Fragment( {
						template: template.f,
						root: ractive,
						owner: this,
						pElement: this
					} );
				}
				// create twoway binding
				if ( ractive.twoway && ( binding = createTwowayBinding( this, template.a ) ) ) {
					this.binding = binding;
					// register this with the root, so that we can do ractive.updateModel()
					bindings = this.root._twowayBindings[ binding.keypath ] || ( this.root._twowayBindings[ binding.keypath ] = [] );
					bindings.push( binding );
				}
				// create event proxies
				if ( template.v ) {
					this.eventHandlers = createEventHandlers( this, template.v );
				}
				// create decorator
				if ( template.o ) {
					this.decorator = new Decorator( this, template.o );
				}
				// create transitions
				this.intro = template.t0 || template.t1;
				this.outro = template.t0 || template.t2;
			};
		}( types, enforceCase, virtualdom_items_Element$init_createAttributes, virtualdom_items_Element$init_createConditionalAttributes, virtualdom_items_Element$init_createTwowayBinding, virtualdom_items_Element$init_createEventHandlers, Decorator, bubble, init, circular );

		/* virtualdom/items/shared/utils/startsWith.js */
		var startsWith = function( startsWithKeypath ) {

			return function startsWith( target, keypath ) {
				return target === keypath || startsWithKeypath( target, keypath );
			};
		}( startsWithKeypath );

		/* virtualdom/items/shared/utils/assignNewKeypath.js */
		var assignNewKeypath = function( startsWith, getNewKeypath ) {

			return function assignNewKeypath( target, property, oldKeypath, newKeypath ) {
				var existingKeypath = target[ property ];
				if ( !existingKeypath || startsWith( existingKeypath, newKeypath ) || !startsWith( existingKeypath, oldKeypath ) ) {
					return;
				}
				target[ property ] = getNewKeypath( existingKeypath, oldKeypath, newKeypath );
			};
		}( startsWith, getNewKeypath );

		/* virtualdom/items/Element/prototype/rebind.js */
		var virtualdom_items_Element$rebind = function( assignNewKeypath ) {

			return function Element$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
				var i, storage, liveQueries, ractive;
				if ( this.attributes ) {
					this.attributes.forEach( rebind );
				}
				if ( this.conditionalAttributes ) {
					this.conditionalAttributes.forEach( rebind );
				}
				if ( this.eventHandlers ) {
					this.eventHandlers.forEach( rebind );
				}
				if ( this.decorator ) {
					rebind( this.decorator );
				}
				// rebind children
				if ( this.fragment ) {
					rebind( this.fragment );
				}
				// Update live queries, if necessary
				if ( liveQueries = this.liveQueries ) {
					ractive = this.root;
					i = liveQueries.length;
					while ( i-- ) {
						liveQueries[ i ]._makeDirty();
					}
				}
				if ( this.node && ( storage = this.node._ractive ) ) {
					// adjust keypath if needed
					assignNewKeypath( storage, 'keypath', oldKeypath, newKeypath );
					if ( indexRef != undefined ) {
						storage.index[ indexRef ] = newIndex;
					}
				}

				function rebind( thing ) {
					thing.rebind( indexRef, newIndex, oldKeypath, newKeypath );
				}
			};
		}( assignNewKeypath );

		/* virtualdom/items/Element/special/img/render.js */
		var render = function renderImage( img ) {
			var loadHandler;
			// if this is an <img>, and we're in a crap browser, we may need to prevent it
			// from overriding width and height when it loads the src
			if ( img.attributes.width || img.attributes.height ) {
				img.node.addEventListener( 'load', loadHandler = function() {
					var width = img.getAttribute( 'width' ),
						height = img.getAttribute( 'height' );
					if ( width !== undefined ) {
						img.node.setAttribute( 'width', width );
					}
					if ( height !== undefined ) {
						img.node.setAttribute( 'height', height );
					}
					img.node.removeEventListener( 'load', loadHandler, false );
				}, false );
			}
		};

		/* virtualdom/items/Element/Transition/prototype/init.js */
		var virtualdom_items_Element_Transition$init = function( log, config, circular ) {

			var Fragment, getValueOptions = {};
			// TODO what are the options?
			circular.push( function() {
				Fragment = circular.Fragment;
			} );
			return function Transition$init( element, template, isIntro ) {
				var t = this,
					ractive, name, fragment;
				t.element = element;
				t.root = ractive = element.root;
				t.isIntro = isIntro;
				name = template.n || template;
				if ( typeof name !== 'string' ) {
					fragment = new Fragment( {
						template: name,
						root: ractive,
						owner: element
					} );
					name = fragment.toString();
					fragment.unbind();
				}
				t.name = name;
				if ( template.a ) {
					t.params = template.a;
				} else if ( template.d ) {
					// TODO is there a way to interpret dynamic arguments without all the
					// 'dependency thrashing'?
					fragment = new Fragment( {
						template: template.d,
						root: ractive,
						owner: element
					} );
					t.params = fragment.getValue( getValueOptions );
					fragment.unbind();
				}
				t._fn = config.registries.transitions.find( ractive, name );
				if ( !t._fn ) {
					log.error( {
						debug: ractive.debug,
						message: 'missingPlugin',
						args: {
							plugin: 'transition',
							name: name
						}
					} );
					return;
				}
			};
		}( log, config, circular );

		/* utils/camelCase.js */
		var camelCase = function( hyphenatedStr ) {
			return hyphenatedStr.replace( /-([a-zA-Z])/g, function( match, $1 ) {
				return $1.toUpperCase();
			} );
		};

		/* virtualdom/items/Element/Transition/helpers/prefix.js */
		var prefix = function( isClient, vendors, createElement, camelCase ) {

			var prefix, prefixCache, testStyle;
			if ( !isClient ) {
				prefix = null;
			} else {
				prefixCache = {};
				testStyle = createElement( 'div' ).style;
				prefix = function( prop ) {
					var i, vendor, capped;
					prop = camelCase( prop );
					if ( !prefixCache[ prop ] ) {
						if ( testStyle[ prop ] !== undefined ) {
							prefixCache[ prop ] = prop;
						} else {
							// test vendors...
							capped = prop.charAt( 0 ).toUpperCase() + prop.substring( 1 );
							i = vendors.length;
							while ( i-- ) {
								vendor = vendors[ i ];
								if ( testStyle[ vendor + capped ] !== undefined ) {
									prefixCache[ prop ] = vendor + capped;
									break;
								}
							}
						}
					}
					return prefixCache[ prop ];
				};
			}
			return prefix;
		}( isClient, vendors, createElement, camelCase );

		/* virtualdom/items/Element/Transition/prototype/getStyle.js */
		var virtualdom_items_Element_Transition$getStyle = function( legacy, isClient, isArray, prefix ) {

			var getStyle, getComputedStyle;
			if ( !isClient ) {
				getStyle = null;
			} else {
				getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;
				getStyle = function( props ) {
					var computedStyle, styles, i, prop, value;
					computedStyle = getComputedStyle( this.node );
					if ( typeof props === 'string' ) {
						value = computedStyle[ prefix( props ) ];
						if ( value === '0px' ) {
							value = 0;
						}
						return value;
					}
					if ( !isArray( props ) ) {
						throw new Error( 'Transition$getStyle must be passed a string, or an array of strings representing CSS properties' );
					}
					styles = {};
					i = props.length;
					while ( i-- ) {
						prop = props[ i ];
						value = computedStyle[ prefix( prop ) ];
						if ( value === '0px' ) {
							value = 0;
						}
						styles[ prop ] = value;
					}
					return styles;
				};
			}
			return getStyle;
		}( legacy, isClient, isArray, prefix );

		/* virtualdom/items/Element/Transition/prototype/setStyle.js */
		var virtualdom_items_Element_Transition$setStyle = function( prefix ) {

			return function( style, value ) {
				var prop;
				if ( typeof style === 'string' ) {
					this.node.style[ prefix( style ) ] = value;
				} else {
					for ( prop in style ) {
						if ( style.hasOwnProperty( prop ) ) {
							this.node.style[ prefix( prop ) ] = style[ prop ];
						}
					}
				}
				return this;
			};
		}( prefix );

		/* shared/Ticker.js */
		var Ticker = function( warn, getTime, animations ) {

			var __export;
			var Ticker = function( options ) {
				var easing;
				this.duration = options.duration;
				this.step = options.step;
				this.complete = options.complete;
				// easing
				if ( typeof options.easing === 'string' ) {
					easing = options.root.easing[ options.easing ];
					if ( !easing ) {
						warn( 'Missing easing function ("' + options.easing + '"). You may need to download a plugin from [TODO]' );
						easing = linear;
					}
				} else if ( typeof options.easing === 'function' ) {
					easing = options.easing;
				} else {
					easing = linear;
				}
				this.easing = easing;
				this.start = getTime();
				this.end = this.start + this.duration;
				this.running = true;
				animations.add( this );
			};
			Ticker.prototype = {
				tick: function( now ) {
					var elapsed, eased;
					if ( !this.running ) {
						return false;
					}
					if ( now > this.end ) {
						if ( this.step ) {
							this.step( 1 );
						}
						if ( this.complete ) {
							this.complete( 1 );
						}
						return false;
					}
					elapsed = now - this.start;
					eased = this.easing( elapsed / this.duration );
					if ( this.step ) {
						this.step( eased );
					}
					return true;
				},
				stop: function() {
					if ( this.abort ) {
						this.abort();
					}
					this.running = false;
				}
			};
			__export = Ticker;

			function linear( t ) {
				return t;
			}
			return __export;
		}( warn, getTime, animations );

		/* virtualdom/items/Element/Transition/helpers/unprefix.js */
		var unprefix = function( vendors ) {

			var unprefixPattern = new RegExp( '^-(?:' + vendors.join( '|' ) + ')-' );
			return function( prop ) {
				return prop.replace( unprefixPattern, '' );
			};
		}( vendors );

		/* virtualdom/items/Element/Transition/helpers/hyphenate.js */
		var hyphenate = function( vendors ) {

			var vendorPattern = new RegExp( '^(?:' + vendors.join( '|' ) + ')([A-Z])' );
			return function( str ) {
				var hyphenated;
				if ( !str ) {
					return '';
				}
				if ( vendorPattern.test( str ) ) {
					str = '-' + str;
				}
				hyphenated = str.replace( /[A-Z]/g, function( match ) {
					return '-' + match.toLowerCase();
				} );
				return hyphenated;
			};
		}( vendors );

		/* virtualdom/items/Element/Transition/prototype/animateStyle/createTransitions.js */
		var virtualdom_items_Element_Transition$animateStyle_createTransitions = function( isClient, warn, createElement, camelCase, interpolate, Ticker, prefix, unprefix, hyphenate ) {

			var createTransitions, testStyle, TRANSITION, TRANSITIONEND, CSS_TRANSITIONS_ENABLED, TRANSITION_DURATION, TRANSITION_PROPERTY, TRANSITION_TIMING_FUNCTION, canUseCssTransitions = {},
				cannotUseCssTransitions = {};
			if ( !isClient ) {
				createTransitions = null;
			} else {
				testStyle = createElement( 'div' ).style;
				// determine some facts about our environment
				( function() {
					if ( testStyle.transition !== undefined ) {
						TRANSITION = 'transition';
						TRANSITIONEND = 'transitionend';
						CSS_TRANSITIONS_ENABLED = true;
					} else if ( testStyle.webkitTransition !== undefined ) {
						TRANSITION = 'webkitTransition';
						TRANSITIONEND = 'webkitTransitionEnd';
						CSS_TRANSITIONS_ENABLED = true;
					} else {
						CSS_TRANSITIONS_ENABLED = false;
					}
				}() );
				if ( TRANSITION ) {
					TRANSITION_DURATION = TRANSITION + 'Duration';
					TRANSITION_PROPERTY = TRANSITION + 'Property';
					TRANSITION_TIMING_FUNCTION = TRANSITION + 'TimingFunction';
				}
				createTransitions = function( t, to, options, changedProperties, resolve ) {
					// Wait a beat (otherwise the target styles will be applied immediately)
					// TODO use a fastdom-style mechanism?
					setTimeout( function() {
						var hashPrefix, jsTransitionsComplete, cssTransitionsComplete, checkComplete, transitionEndHandler;
						checkComplete = function() {
							if ( jsTransitionsComplete && cssTransitionsComplete ) {
								// will changes to events and fire have an unexpected consequence here?
								t.root.fire( t.name + ':end', t.node, t.isIntro );
								resolve();
							}
						};
						// this is used to keep track of which elements can use CSS to animate
						// which properties
						hashPrefix = ( t.node.namespaceURI || '' ) + t.node.tagName;
						t.node.style[ TRANSITION_PROPERTY ] = changedProperties.map( prefix ).map( hyphenate ).join( ',' );
						t.node.style[ TRANSITION_TIMING_FUNCTION ] = hyphenate( options.easing || 'linear' );
						t.node.style[ TRANSITION_DURATION ] = options.duration / 1000 + 's';
						transitionEndHandler = function( event ) {
							var index;
							index = changedProperties.indexOf( camelCase( unprefix( event.propertyName ) ) );
							if ( index !== -1 ) {
								changedProperties.splice( index, 1 );
							}
							if ( changedProperties.length ) {
								// still transitioning...
								return;
							}
							t.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );
							cssTransitionsComplete = true;
							checkComplete();
						};
						t.node.addEventListener( TRANSITIONEND, transitionEndHandler, false );
						setTimeout( function() {
							var i = changedProperties.length,
								hash, originalValue, index, propertiesToTransitionInJs = [],
								prop, suffix;
							while ( i-- ) {
								prop = changedProperties[ i ];
								hash = hashPrefix + prop;
								if ( CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[ hash ] ) {
									t.node.style[ prefix( prop ) ] = to[ prop ];
									// If we're not sure if CSS transitions are supported for
									// this tag/property combo, find out now
									if ( !canUseCssTransitions[ hash ] ) {
										originalValue = t.getStyle( prop );
										// if this property is transitionable in this browser,
										// the current style will be different from the target style
										canUseCssTransitions[ hash ] = t.getStyle( prop ) != to[ prop ];
										cannotUseCssTransitions[ hash ] = !canUseCssTransitions[ hash ];
										// Reset, if we're going to use timers after all
										if ( cannotUseCssTransitions[ hash ] ) {
											t.node.style[ prefix( prop ) ] = originalValue;
										}
									}
								}
								if ( !CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[ hash ] ) {
									// we need to fall back to timer-based stuff
									if ( originalValue === undefined ) {
										originalValue = t.getStyle( prop );
									}
									// need to remove this from changedProperties, otherwise transitionEndHandler
									// will get confused
									index = changedProperties.indexOf( prop );
									if ( index === -1 ) {
										warn( 'Something very strange happened with transitions. If you see this message, please let @RactiveJS know. Thanks!' );
									} else {
										changedProperties.splice( index, 1 );
									}
									// TODO Determine whether this property is animatable at all
									suffix = /[^\d]*$/.exec( to[ prop ] )[ 0 ];
									// ...then kick off a timer-based transition
									propertiesToTransitionInJs.push( {
										name: prefix( prop ),
										interpolator: interpolate( parseFloat( originalValue ), parseFloat( to[ prop ] ) ),
										suffix: suffix
									} );
								}
							}
							// javascript transitions
							if ( propertiesToTransitionInJs.length ) {
								new Ticker( {
									root: t.root,
									duration: options.duration,
									easing: camelCase( options.easing || '' ),
									step: function( pos ) {
										var prop, i;
										i = propertiesToTransitionInJs.length;
										while ( i-- ) {
											prop = propertiesToTransitionInJs[ i ];
											t.node.style[ prop.name ] = prop.interpolator( pos ) + prop.suffix;
										}
									},
									complete: function() {
										jsTransitionsComplete = true;
										checkComplete();
									}
								} );
							} else {
								jsTransitionsComplete = true;
							}
							if ( !changedProperties.length ) {
								// We need to cancel the transitionEndHandler, and deal with
								// the fact that it will never fire
								t.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );
								cssTransitionsComplete = true;
								checkComplete();
							}
						}, 0 );
					}, options.delay || 0 );
				};
			}
			return createTransitions;
		}( isClient, warn, createElement, camelCase, interpolate, Ticker, prefix, unprefix, hyphenate );

		/* virtualdom/items/Element/Transition/prototype/animateStyle/visibility.js */
		var virtualdom_items_Element_Transition$animateStyle_visibility = function( vendors ) {

			var hidden, vendor, prefix, i, visibility;
			if ( typeof document !== 'undefined' ) {
				hidden = 'hidden';
				visibility = {};
				if ( hidden in document ) {
					prefix = '';
				} else {
					i = vendors.length;
					while ( i-- ) {
						vendor = vendors[ i ];
						hidden = vendor + 'Hidden';
						if ( hidden in document ) {
							prefix = vendor;
						}
					}
				}
				if ( prefix !== undefined ) {
					document.addEventListener( prefix + 'visibilitychange', onChange );
					// initialise
					onChange();
				} else {
					// gah, we're in an old browser
					if ( 'onfocusout' in document ) {
						document.addEventListener( 'focusout', onHide );
						document.addEventListener( 'focusin', onShow );
					} else {
						window.addEventListener( 'pagehide', onHide );
						window.addEventListener( 'blur', onHide );
						window.addEventListener( 'pageshow', onShow );
						window.addEventListener( 'focus', onShow );
					}
					visibility.hidden = false;
				}
			}

			function onChange() {
				visibility.hidden = document[ hidden ];
			}

			function onHide() {
				visibility.hidden = true;
			}

			function onShow() {
				visibility.hidden = false;
			}
			return visibility;
		}( vendors );

		/* virtualdom/items/Element/Transition/prototype/animateStyle/_animateStyle.js */
		var virtualdom_items_Element_Transition$animateStyle__animateStyle = function( legacy, isClient, warn, Promise, prefix, createTransitions, visibility ) {

			var animateStyle, getComputedStyle, resolved;
			if ( !isClient ) {
				animateStyle = null;
			} else {
				getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;
				animateStyle = function( style, value, options, complete ) {
					var t = this,
						to;
					// Special case - page isn't visible. Don't animate anything, because
					// that way you'll never get CSS transitionend events
					if ( visibility.hidden ) {
						this.setStyle( style, value );
						return resolved || ( resolved = Promise.resolve() );
					}
					if ( typeof style === 'string' ) {
						to = {};
						to[ style ] = value;
					} else {
						to = style;
						// shuffle arguments
						complete = options;
						options = value;
					}
					// As of 0.3.9, transition authors should supply an `option` object with
					// `duration` and `easing` properties (and optional `delay`), plus a
					// callback function that gets called after the animation completes
					// TODO remove this check in a future version
					if ( !options ) {
						warn( 'The "' + t.name + '" transition does not supply an options object to `t.animateStyle()`. This will break in a future version of Ractive. For more info see https://github.com/RactiveJS/Ractive/issues/340' );
						options = t;
						complete = t.complete;
					}
					var promise = new Promise( function( resolve ) {
						var propertyNames, changedProperties, computedStyle, current, from, i, prop;
						// Edge case - if duration is zero, set style synchronously and complete
						if ( !options.duration ) {
							t.setStyle( to );
							resolve();
							return;
						}
						// Get a list of the properties we're animating
						propertyNames = Object.keys( to );
						changedProperties = [];
						// Store the current styles
						computedStyle = getComputedStyle( t.node );
						from = {};
						i = propertyNames.length;
						while ( i-- ) {
							prop = propertyNames[ i ];
							current = computedStyle[ prefix( prop ) ];
							if ( current === '0px' ) {
								current = 0;
							}
							// we need to know if we're actually changing anything
							if ( current != to[ prop ] ) {
								// use != instead of !==, so we can compare strings with numbers
								changedProperties.push( prop );
								// make the computed style explicit, so we can animate where
								// e.g. height='auto'
								t.node.style[ prefix( prop ) ] = current;
							}
						}
						// If we're not actually changing anything, the transitionend event
						// will never fire! So we complete early
						if ( !changedProperties.length ) {
							resolve();
							return;
						}
						createTransitions( t, to, options, changedProperties, resolve );
					} );
					// If a callback was supplied, do the honours
					// TODO remove this check in future
					if ( complete ) {
						warn( 't.animateStyle returns a Promise as of 0.4.0. Transition authors should do t.animateStyle(...).then(callback)' );
						promise.then( complete );
					}
					return promise;
				};
			}
			return animateStyle;
		}( legacy, isClient, warn, Promise, prefix, virtualdom_items_Element_Transition$animateStyle_createTransitions, virtualdom_items_Element_Transition$animateStyle_visibility );

		/* utils/fillGaps.js */
		var fillGaps = function( target ) {
			var SLICE$0 = Array.prototype.slice;
			var sources = SLICE$0.call( arguments, 1 );
			sources.forEach( function( s ) {
				for ( var key in s ) {
					if ( s.hasOwnProperty( key ) && !( key in target ) ) {
						target[ key ] = s[ key ];
					}
				}
			} );
			return target;
		};

		/* virtualdom/items/Element/Transition/prototype/processParams.js */
		var virtualdom_items_Element_Transition$processParams = function( fillGaps ) {

			return function( params, defaults ) {
				if ( typeof params === 'number' ) {
					params = {
						duration: params
					};
				} else if ( typeof params === 'string' ) {
					if ( params === 'slow' ) {
						params = {
							duration: 600
						};
					} else if ( params === 'fast' ) {
						params = {
							duration: 200
						};
					} else {
						params = {
							duration: 400
						};
					}
				} else if ( !params ) {
					params = {};
				}
				return fillGaps( {}, params, defaults );
			};
		}( fillGaps );

		/* virtualdom/items/Element/Transition/prototype/start.js */
		var virtualdom_items_Element_Transition$start = function() {

			var __export;
			__export = function Transition$start() {
				var t = this,
					node, originalStyle, completed;
				node = t.node = t.element.node;
				originalStyle = node.getAttribute( 'style' );
				// create t.complete() - we don't want this on the prototype,
				// because we don't want `this` silliness when passing it as
				// an argument
				t.complete = function( noReset ) {
					if ( completed ) {
						return;
					}
					if ( !noReset && t.isIntro ) {
						resetStyle( node, originalStyle );
					}
					node._ractive.transition = null;
					t._manager.remove( t );
					completed = true;
				};
				// If the transition function doesn't exist, abort
				if ( !t._fn ) {
					t.complete();
					return;
				}
				t._fn.apply( t.root, [ t ].concat( t.params ) );
			};

			function resetStyle( node, style ) {
				if ( style ) {
					node.setAttribute( 'style', style );
				} else {
					// Next line is necessary, to remove empty style attribute!
					// See http://stackoverflow.com/a/7167553
					node.getAttribute( 'style' );
					node.removeAttribute( 'style' );
				}
			}
			return __export;
		}();

		/* virtualdom/items/Element/Transition/_Transition.js */
		var Transition = function( init, getStyle, setStyle, animateStyle, processParams, start, circular ) {

			var Fragment, Transition;
			circular.push( function() {
				Fragment = circular.Fragment;
			} );
			Transition = function( owner, template, isIntro ) {
				this.init( owner, template, isIntro );
			};
			Transition.prototype = {
				init: init,
				start: start,
				getStyle: getStyle,
				setStyle: setStyle,
				animateStyle: animateStyle,
				processParams: processParams
			};
			return Transition;
		}( virtualdom_items_Element_Transition$init, virtualdom_items_Element_Transition$getStyle, virtualdom_items_Element_Transition$setStyle, virtualdom_items_Element_Transition$animateStyle__animateStyle, virtualdom_items_Element_Transition$processParams, virtualdom_items_Element_Transition$start, circular );

		/* virtualdom/items/Element/prototype/render.js */
		var virtualdom_items_Element$render = function( namespaces, isArray, warn, create, createElement, defineProperty, noop, runloop, getInnerContext, renderImage, Transition ) {

			var __export;
			var updateCss, updateScript;
			updateCss = function() {
				var node = this.node,
					content = this.fragment.toString( false );
				// IE8 has no styleSheet unless there's a type text/css
				if ( window && window.appearsToBeIELessEqual8 ) {
					node.type = 'text/css';
				}
				if ( node.styleSheet ) {
					node.styleSheet.cssText = content;
				} else {
					while ( node.hasChildNodes() ) {
						node.removeChild( node.firstChild );
					}
					node.appendChild( document.createTextNode( content ) );
				}
			};
			updateScript = function() {
				if ( !this.node.type || this.node.type === 'text/javascript' ) {
					warn( 'Script tag was updated. This does not cause the code to be re-evaluated!' );
				}
				this.node.text = this.fragment.toString( false );
			};
			__export = function Element$render() {
				var this$0 = this;
				var root = this.root,
					namespace, node;
				namespace = getNamespace( this );
				node = this.node = createElement( this.name, namespace );
				// Is this a top-level node of a component? If so, we may need to add
				// a data-rvcguid attribute, for CSS encapsulation
				// NOTE: css no longer copied to instance, so we check constructor.css -
				// we can enhance to handle instance, but this is more "correct" with current
				// functionality
				if ( root.constructor.css && this.parentFragment.getNode() === root.el ) {
					this.node.setAttribute( 'data-rvcguid', root.constructor._guid );
				}
				// Add _ractive property to the node - we use this object to store stuff
				// related to proxy events, two-way bindings etc
				defineProperty( this.node, '_ractive', {
					value: {
						proxy: this,
						keypath: getInnerContext( this.parentFragment ),
						index: this.parentFragment.indexRefs,
						events: create( null ),
						root: root
					}
				} );
				// Render attributes
				this.attributes.forEach( function( a ) {
					return a.render( node );
				} );
				this.conditionalAttributes.forEach( function( a ) {
					return a.render( node );
				} );
				// Render children
				if ( this.fragment ) {
					// Special case - <script> element
					if ( this.name === 'script' ) {
						this.bubble = updateScript;
						this.node.text = this.fragment.toString( false );
						// bypass warning initially
						this.fragment.unrender = noop;
					} else if ( this.name === 'style' ) {
						this.bubble = updateCss;
						this.bubble();
						this.fragment.unrender = noop;
					} else if ( this.binding && this.getAttribute( 'contenteditable' ) ) {
						this.fragment.unrender = noop;
					} else {
						this.node.appendChild( this.fragment.render() );
					}
				}
				// Add proxy event handlers
				if ( this.eventHandlers ) {
					this.eventHandlers.forEach( function( h ) {
						return h.render();
					} );
				}
				// deal with two-way bindings
				if ( this.binding ) {
					this.binding.render();
					this.node._ractive.binding = this.binding;
				}
				// Special case: if this is an <img>, and we're in a crap browser, we may
				// need to prevent it from overriding width and height when it loads the src
				if ( this.name === 'img' ) {
					renderImage( this );
				}
				// apply decorator(s)
				if ( this.decorator && this.decorator.fn ) {
					runloop.scheduleTask( function() {
						return this$0.decorator.init();
					}, true );
				}
				// trigger intro transition
				if ( root.transitionsEnabled && this.intro ) {
					var transition = new Transition( this, this.intro, true );
					runloop.registerTransition( transition );
					runloop.scheduleTask( function() {
						return transition.start();
					}, true );
					this.transition = transition;
				}
				if ( this.name === 'option' ) {
					processOption( this );
				}
				if ( this.node.autofocus ) {
					// Special case. Some browsers (*cough* Firefix *cough*) have a problem
					// with dynamically-generated elements having autofocus, and they won't
					// allow you to programmatically focus the element until it's in the DOM
					runloop.scheduleTask( function() {
						return this$0.node.focus();
					}, true );
				}
				updateLiveQueries( this );
				return this.node;
			};

			function getNamespace( element ) {
				var namespace, xmlns, parent;
				// Use specified namespace...
				if ( xmlns = element.getAttribute( 'xmlns' ) ) {
					namespace = xmlns;
				} else if ( element.name === 'svg' ) {
					namespace = namespaces.svg;
				} else if ( parent = element.parent ) {
					// ...or HTML, if the parent is a <foreignObject>
					if ( parent.name === 'foreignObject' ) {
						namespace = namespaces.html;
					} else {
						namespace = parent.node.namespaceURI;
					}
				} else {
					namespace = element.root.el.namespaceURI;
				}
				return namespace;
			}

			function processOption( option ) {
				var optionValue, selectValue, i;
				if ( !option.select ) {
					return;
				}
				selectValue = option.select.getAttribute( 'value' );
				if ( selectValue === undefined ) {
					return;
				}
				optionValue = option.getAttribute( 'value' );
				if ( option.select.node.multiple && isArray( selectValue ) ) {
					i = selectValue.length;
					while ( i-- ) {
						if ( optionValue == selectValue[ i ] ) {
							option.node.selected = true;
							break;
						}
					}
				} else {
					option.node.selected = optionValue == selectValue;
				}
			}

			function updateLiveQueries( element ) {
				var instance, liveQueries, i, selector, query;
				// Does this need to be added to any live queries?
				instance = element.root;
				do {
					liveQueries = instance._liveQueries;
					i = liveQueries.length;
					while ( i-- ) {
						selector = liveQueries[ i ];
						query = liveQueries[ '_' + selector ];
						if ( query._test( element ) ) {
							// keep register of applicable selectors, for when we teardown
							( element.liveQueries || ( element.liveQueries = [] ) ).push( query );
						}
					}
				} while ( instance = instance._parent );
			}
			return __export;
		}( namespaces, isArray, warn, create, createElement, defineProperty, noop, runloop, getInnerContext, render, Transition );

		/* virtualdom/items/Element/prototype/toString.js */
		var virtualdom_items_Element$toString = function( voidElementNames, isArray, escapeHtml ) {

			var __export;
			__export = function() {
				var str, escape;
				str = '<' + ( this.template.y ? '!DOCTYPE' : this.template.e );
				str += this.attributes.map( stringifyAttribute ).join( '' ) + this.conditionalAttributes.map( stringifyAttribute ).join( '' );
				// Special case - selected options
				if ( this.name === 'option' && optionIsSelected( this ) ) {
					str += ' selected';
				}
				// Special case - two-way radio name bindings
				if ( this.name === 'input' && inputIsCheckedRadio( this ) ) {
					str += ' checked';
				}
				str += '>';
				// Special case - textarea
				if ( this.name === 'textarea' && this.getAttribute( 'value' ) !== undefined ) {
					str += escapeHtml( this.getAttribute( 'value' ) );
				} else if ( this.getAttribute( 'contenteditable' ) !== undefined ) {
					str += this.getAttribute( 'value' );
				}
				if ( this.fragment ) {
					escape = this.name !== 'script' && this.name !== 'style';
					str += this.fragment.toString( escape );
				}
				// add a closing tag if this isn't a void element
				if ( !voidElementNames.test( this.template.e ) ) {
					str += '</' + this.template.e + '>';
				}
				return str;
			};

			function optionIsSelected( element ) {
				var optionValue, selectValue, i;
				optionValue = element.getAttribute( 'value' );
				if ( optionValue === undefined || !element.select ) {
					return false;
				}
				selectValue = element.select.getAttribute( 'value' );
				if ( selectValue == optionValue ) {
					return true;
				}
				if ( element.select.getAttribute( 'multiple' ) && isArray( selectValue ) ) {
					i = selectValue.length;
					while ( i-- ) {
						if ( selectValue[ i ] == optionValue ) {
							return true;
						}
					}
				}
			}

			function inputIsCheckedRadio( element ) {
				var attributes, typeAttribute, valueAttribute, nameAttribute;
				attributes = element.attributes;
				typeAttribute = attributes.type;
				valueAttribute = attributes.value;
				nameAttribute = attributes.name;
				if ( !typeAttribute || typeAttribute.value !== 'radio' || !valueAttribute || !nameAttribute.interpolator ) {
					return;
				}
				if ( valueAttribute.value === nameAttribute.interpolator.value ) {
					return true;
				}
			}

			function stringifyAttribute( attribute ) {
				var str = attribute.toString();
				return str ? ' ' + str : '';
			}
			return __export;
		}( voidElementNames, isArray, escapeHtml );

		/* virtualdom/items/Element/special/option/unbind.js */
		var virtualdom_items_Element_special_option_unbind = function( removeFromArray ) {

			return function unbindOption( option ) {
				if ( option.select ) {
					removeFromArray( option.select.options, option );
				}
			};
		}( removeFromArray );

		/* virtualdom/items/Element/prototype/unbind.js */
		var virtualdom_items_Element$unbind = function( unbindOption ) {

			var __export;
			__export = function Element$unbind() {
				if ( this.fragment ) {
					this.fragment.unbind();
				}
				if ( this.binding ) {
					this.binding.unbind();
				}
				if ( this.eventHandlers ) {
					this.eventHandlers.forEach( unbind );
				}
				// Special case - <option>
				if ( this.name === 'option' ) {
					unbindOption( this );
				}
				this.attributes.forEach( unbind );
				this.conditionalAttributes.forEach( unbind );
			};

			function unbind( x ) {
				x.unbind();
			}
			return __export;
		}( virtualdom_items_Element_special_option_unbind );

		/* virtualdom/items/Element/prototype/unrender.js */
		var virtualdom_items_Element$unrender = function( runloop, Transition ) {

			var __export;
			__export = function Element$unrender( shouldDestroy ) {
				var binding, bindings;
				if ( this.transition ) {
					this.transition.complete();
				}
				// Detach as soon as we can
				if ( this.name === 'option' ) {
					// <option> elements detach immediately, so that
					// their parent <select> element syncs correctly, and
					// since option elements can't have transitions anyway
					this.detach();
				} else if ( shouldDestroy ) {
					runloop.detachWhenReady( this );
				}
				// Children first. that way, any transitions on child elements will be
				// handled by the current transitionManager
				if ( this.fragment ) {
					this.fragment.unrender( false );
				}
				if ( binding = this.binding ) {
					this.binding.unrender();
					this.node._ractive.binding = null;
					bindings = this.root._twowayBindings[ binding.keypath ];
					bindings.splice( bindings.indexOf( binding ), 1 );
				}
				// Remove event handlers
				if ( this.eventHandlers ) {
					this.eventHandlers.forEach( function( h ) {
						return h.unrender();
					} );
				}
				if ( this.decorator ) {
					this.decorator.teardown();
				}
				// trigger outro transition if necessary
				if ( this.root.transitionsEnabled && this.outro ) {
					var transition = new Transition( this, this.outro, false );
					runloop.registerTransition( transition );
					runloop.scheduleTask( function() {
						return transition.start();
					} );
				}
				// Remove this node from any live queries
				if ( this.liveQueries ) {
					removeFromLiveQueries( this );
				}
			};

			function removeFromLiveQueries( element ) {
				var query, selector, i;
				i = element.liveQueries.length;
				while ( i-- ) {
					query = element.liveQueries[ i ];
					selector = query.selector;
					query._remove( element.node );
				}
			}
			return __export;
		}( runloop, Transition );

		/* virtualdom/items/Element/_Element.js */
		var Element = function( bubble, detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, getAttribute, init, rebind, render, toString, unbind, unrender ) {

			var Element = function( options ) {
				this.init( options );
			};
			Element.prototype = {
				bubble: bubble,
				detach: detach,
				find: find,
				findAll: findAll,
				findAllComponents: findAllComponents,
				findComponent: findComponent,
				findNextNode: findNextNode,
				firstNode: firstNode,
				getAttribute: getAttribute,
				init: init,
				rebind: rebind,
				render: render,
				toString: toString,
				unbind: unbind,
				unrender: unrender
			};
			return Element;
		}( virtualdom_items_Element$bubble, virtualdom_items_Element$detach, virtualdom_items_Element$find, virtualdom_items_Element$findAll, virtualdom_items_Element$findAllComponents, virtualdom_items_Element$findComponent, virtualdom_items_Element$findNextNode, virtualdom_items_Element$firstNode, virtualdom_items_Element$getAttribute, virtualdom_items_Element$init, virtualdom_items_Element$rebind, virtualdom_items_Element$render, virtualdom_items_Element$toString, virtualdom_items_Element$unbind, virtualdom_items_Element$unrender );

		/* virtualdom/items/Partial/deIndent.js */
		var deIndent = function() {

			var __export;
			var empty = /^\s*$/,
				leadingWhitespace = /^\s*/;
			__export = function( str ) {
				var lines, firstLine, lastLine, minIndent;
				lines = str.split( '\n' );
				// remove first and last line, if they only contain whitespace
				firstLine = lines[ 0 ];
				if ( firstLine !== undefined && empty.test( firstLine ) ) {
					lines.shift();
				}
				lastLine = lines[ lines.length - 1 ];
				if ( lastLine !== undefined && empty.test( lastLine ) ) {
					lines.pop();
				}
				minIndent = lines.reduce( reducer, null );
				if ( minIndent ) {
					str = lines.map( function( line ) {
						return line.replace( minIndent, '' );
					} ).join( '\n' );
				}
				return str;
			};

			function reducer( previous, line ) {
				var lineIndent = leadingWhitespace.exec( line )[ 0 ];
				if ( previous === null || lineIndent.length < previous.length ) {
					return lineIndent;
				}
				return previous;
			}
			return __export;
		}();

		/* virtualdom/items/Partial/getPartialTemplate.js */
		var getPartialTemplate = function( log, config, parser, deIndent ) {

			var __export;
			__export = function getPartialTemplate( ractive, name ) {
				var partial;
				// If the partial in instance or view heirarchy instances, great
				if ( partial = getPartialFromRegistry( ractive, name ) ) {
					return partial;
				}
				// Does it exist on the page as a script tag?
				partial = parser.fromId( name, {
					noThrow: true
				} );
				if ( partial ) {
					// is this necessary?
					partial = deIndent( partial );
					// parse and register to this ractive instance
					var parsed = parser.parse( partial, parser.getParseOptions( ractive ) );
					// register (and return main partial if there are others in the template)
					return ractive.partials[ name ] = parsed.t;
				}
			};

			function getPartialFromRegistry( ractive, name ) {
				var partials = config.registries.partials;
				// find first instance in the ractive or view hierarchy that has this partial
				var instance = partials.findInstance( ractive, name );
				if ( !instance ) {
					return;
				}
				var partial = instance.partials[ name ],
					fn;
				// partial is a function?
				if ( typeof partial === 'function' ) {
					fn = partial.bind( instance );
					fn.isOwner = instance.partials.hasOwnProperty( name );
					partial = fn( instance.data, parser );
				}
				if ( !partial ) {
					log.warn( {
						debug: ractive.debug,
						message: 'noRegistryFunctionReturn',
						args: {
							registry: 'partial',
							name: name
						}
					} );
					return;
				}
				// If this was added manually to the registry,
				// but hasn't been parsed, parse it now
				if ( !parser.isParsed( partial ) ) {
					// use the parseOptions of the ractive instance on which it was found
					var parsed = parser.parse( partial, parser.getParseOptions( instance ) );
					// Partials cannot contain nested partials!
					// TODO add a test for this
					if ( parsed.p ) {
						log.warn( {
							debug: ractive.debug,
							message: 'noNestedPartials',
							args: {
								rname: name
							}
						} );
					}
					// if fn, use instance to store result, otherwise needs to go
					// in the correct point in prototype chain on instance or constructor
					var target = fn ? instance : partials.findOwner( instance, name );
					// may be a template with partials, which need to be registered and main template extracted
					target.partials[ name ] = partial = parsed.t;
				}
				// store for reset
				if ( fn ) {
					partial._fn = fn;
				}
				return partial.v ? partial.t : partial;
			}
			return __export;
		}( log, config, parser, deIndent );

		/* virtualdom/items/Partial/applyIndent.js */
		var applyIndent = function( string, indent ) {
			var indented;
			if ( !indent ) {
				return string;
			}
			indented = string.split( '\n' ).map( function( line, notFirstLine ) {
				return notFirstLine ? indent + line : line;
			} ).join( '\n' );
			return indented;
		};

		/* virtualdom/items/Partial/_Partial.js */
		var Partial = function( log, types, getPartialTemplate, applyIndent, circular, runloop, Mustache, rebind, unbind ) {

			var Partial, Fragment;
			circular.push( function() {
				Fragment = circular.Fragment;
			} );
			Partial = function( options ) {
				var parentFragment, template;
				parentFragment = this.parentFragment = options.parentFragment;
				this.root = parentFragment.root;
				this.type = types.PARTIAL;
				this.index = options.index;
				this.name = options.template.r;
				this.fragment = this.fragmentToRender = this.fragmentToUnrender = null;
				Mustache.init( this, options );
				// If this didn't resolve, it most likely means we have a named partial
				// (i.e. `{{>foo}}` means 'use the foo partial', not 'use the partial
				// whose name is the value of `foo`')
				if ( !this.keypath && ( template = getPartialTemplate( this.root, this.name ) ) ) {
					unbind.call( this );
					// prevent any further changes
					this.isNamed = true;
					this.setTemplate( template );
				}
			};
			Partial.prototype = {
				bubble: function() {
					this.parentFragment.bubble();
				},
				detach: function() {
					return this.fragment.detach();
				},
				find: function( selector ) {
					return this.fragment.find( selector );
				},
				findAll: function( selector, query ) {
					return this.fragment.findAll( selector, query );
				},
				findComponent: function( selector ) {
					return this.fragment.findComponent( selector );
				},
				findAllComponents: function( selector, query ) {
					return this.fragment.findAllComponents( selector, query );
				},
				firstNode: function() {
					return this.fragment.firstNode();
				},
				findNextNode: function() {
					return this.parentFragment.findNextNode( this );
				},
				getValue: function() {
					return this.fragment.getValue();
				},
				rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
					rebind.call( this, indexRef, newIndex, oldKeypath, newKeypath );
					this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
				},
				render: function() {
					this.docFrag = document.createDocumentFragment();
					this.update();
					this.rendered = true;
					return this.docFrag;
				},
				resolve: Mustache.resolve,
				setValue: function( value ) {
					var template;
					if ( value !== undefined && value === this.value ) {
						// nothing has changed, so no work to be done
						return;
					}
					template = getPartialTemplate( this.root, '' + value );
					// we may be here if we have a partial like `{{>foo}}` and `foo` is the
					// name of both a data property (whose value ISN'T the name of a partial)
					// and a partial. In those cases, this becomes a named partial
					if ( !template && this.name && ( template = getPartialTemplate( this.root, this.name ) ) ) {
						unbind.call( this );
						this.isNamed = true;
					}
					if ( !template ) {
						log.error( {
							debug: this.root.debug,
							message: 'noTemplateForPartial',
							args: {
								name: this.name
							}
						} );
					}
					this.setTemplate( template || [] );
					this.value = value;
					this.bubble();
					if ( this.rendered ) {
						runloop.addView( this );
					}
				},
				setTemplate: function( template ) {
					if ( this.fragment ) {
						this.fragment.unbind();
						this.fragmentToUnrender = this.fragment;
					}
					this.fragment = new Fragment( {
						template: template,
						root: this.root,
						owner: this,
						pElement: this.parentFragment.pElement
					} );
					this.fragmentToRender = this.fragment;
				},
				toString: function( toString ) {
					var string, previousItem, lastLine, match;
					string = this.fragment.toString( toString );
					previousItem = this.parentFragment.items[ this.index - 1 ];
					if ( !previousItem || previousItem.type !== types.TEXT ) {
						return string;
					}
					lastLine = previousItem.text.split( '\n' ).pop();
					if ( match = /^\s+$/.exec( lastLine ) ) {
						return applyIndent( string, match[ 0 ] );
					}
					return string;
				},
				unbind: function() {
					if ( !this.isNamed ) {
						// dynamic partial - need to unbind self
						unbind.call( this );
					}
					if ( this.fragment ) {
						this.fragment.unbind();
					}
				},
				unrender: function( shouldDestroy ) {
					if ( this.rendered ) {
						if ( this.fragment ) {
							this.fragment.unrender( shouldDestroy );
						}
						this.rendered = false;
					}
				},
				update: function() {
					var target, anchor;
					if ( this.fragmentToUnrender ) {
						this.fragmentToUnrender.unrender( true );
						this.fragmentToUnrender = null;
					}
					if ( this.fragmentToRender ) {
						this.docFrag.appendChild( this.fragmentToRender.render() );
						this.fragmentToRender = null;
					}
					if ( this.rendered ) {
						target = this.parentFragment.getNode();
						anchor = this.parentFragment.findNextNode( this );
						target.insertBefore( this.docFrag, anchor );
					}
				}
			};
			return Partial;
		}( log, types, getPartialTemplate, applyIndent, circular, runloop, Mustache, rebind, unbind );

		/* virtualdom/items/Component/getComponent.js */
		var getComponent = function( config, log, circular ) {

			var Ractive;
			circular.push( function() {
				Ractive = circular.Ractive;
			} );
			// finds the component constructor in the registry or view hierarchy registries
			return function getComponent( ractive, name ) {
				var component, instance = config.registries.components.findInstance( ractive, name );
				if ( instance ) {
					component = instance.components[ name ];
					// best test we have for not Ractive.extend
					if ( !component._parent ) {
						// function option, execute and store for reset
						var fn = component.bind( instance );
						fn.isOwner = instance.components.hasOwnProperty( name );
						component = fn( instance.data );
						if ( !component ) {
							log.warn( {
								debug: ractive.debug,
								message: 'noRegistryFunctionReturn',
								args: {
									registry: 'component',
									name: name
								}
							} );
							return;
						}
						if ( typeof component === 'string' ) {
							//allow string lookup
							component = getComponent( ractive, component );
						}
						component._fn = fn;
						instance.components[ name ] = component;
					}
				}
				return component;
			};
		}( config, log, circular );

		/* virtualdom/items/Component/prototype/detach.js */
		var virtualdom_items_Component$detach = function( Hook ) {

			var detachHook = new Hook( 'detach' );
			return function Component$detach() {
				var detached = this.instance.fragment.detach();
				detachHook.fire( this.instance );
				return detached;
			};
		}( Ractive$shared_hooks_Hook );

		/* virtualdom/items/Component/prototype/find.js */
		var virtualdom_items_Component$find = function Component$find( selector ) {
			return this.instance.fragment.find( selector );
		};

		/* virtualdom/items/Component/prototype/findAll.js */
		var virtualdom_items_Component$findAll = function Component$findAll( selector, query ) {
			return this.instance.fragment.findAll( selector, query );
		};

		/* virtualdom/items/Component/prototype/findAllComponents.js */
		var virtualdom_items_Component$findAllComponents = function Component$findAllComponents( selector, query ) {
			query._test( this, true );
			if ( this.instance.fragment ) {
				this.instance.fragment.findAllComponents( selector, query );
			}
		};

		/* virtualdom/items/Component/prototype/findComponent.js */
		var virtualdom_items_Component$findComponent = function Component$findComponent( selector ) {
			if ( !selector || selector === this.name ) {
				return this.instance;
			}
			if ( this.instance.fragment ) {
				return this.instance.fragment.findComponent( selector );
			}
			return null;
		};

		/* virtualdom/items/Component/prototype/findNextNode.js */
		var virtualdom_items_Component$findNextNode = function Component$findNextNode() {
			return this.parentFragment.findNextNode( this );
		};

		/* virtualdom/items/Component/prototype/firstNode.js */
		var virtualdom_items_Component$firstNode = function Component$firstNode() {
			if ( this.rendered ) {
				return this.instance.fragment.firstNode();
			}
			return null;
		};

		/* virtualdom/items/Component/initialise/createModel/ComponentParameter.js */
		var ComponentParameter = function( runloop, circular ) {

			var Fragment, ComponentParameter;
			circular.push( function() {
				Fragment = circular.Fragment;
			} );
			ComponentParameter = function( component, key, value ) {
				this.parentFragment = component.parentFragment;
				this.component = component;
				this.key = key;
				this.fragment = new Fragment( {
					template: value,
					root: component.root,
					owner: this
				} );
				this.value = this.fragment.getValue();
			};
			ComponentParameter.prototype = {
				bubble: function() {
					if ( !this.dirty ) {
						this.dirty = true;
						runloop.addView( this );
					}
				},
				update: function() {
					var value = this.fragment.getValue();
					this.component.instance.viewmodel.set( this.key, value );
					runloop.addViewmodel( this.component.instance.viewmodel );
					this.value = value;
					this.dirty = false;
				},
				rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
					this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
				},
				unbind: function() {
					this.fragment.unbind();
				}
			};
			return ComponentParameter;
		}( runloop, circular );

		/* virtualdom/items/Component/initialise/createModel/ReferenceExpressionParameter.js */
		var ReferenceExpressionParameter = function( ReferenceExpressionResolver, createComponentBinding ) {

			var ReferenceExpressionParameter = function( component, childKeypath, template, toBind ) {
				var this$0 = this;
				this.root = component.root;
				this.parentFragment = component.parentFragment;
				this.ready = false;
				this.hash = null;
				this.resolver = new ReferenceExpressionResolver( this, template, function( keypath ) {
					// Are we updating an existing binding?
					if ( this$0.binding || ( this$0.binding = component.bindings[ this$0.hash ] ) ) {
						component.bindings[ this$0.hash ] = null;
						this$0.binding.rebind( keypath );
						this$0.hash = keypath + '=' + childKeypath;
						component.bindings[ this$0.hash ];
					} else {
						if ( !this$0.ready ) {
							// The child instance isn't created yet, we need to create the binding later
							toBind.push( {
								childKeypath: childKeypath,
								parentKeypath: keypath
							} );
						} else {
							createComponentBinding( component, component.root, keypath, childKeypath );
						}
					}
					this$0.value = component.root.viewmodel.get( keypath );
				} );
			};
			ReferenceExpressionParameter.prototype = {
				rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
					this.resolver.rebind( indexRef, newIndex, oldKeypath, newKeypath );
				},
				unbind: function() {
					this.resolver.unbind();
				}
			};
			return ReferenceExpressionParameter;
		}( ReferenceExpressionResolver, createComponentBinding );

		/* virtualdom/items/Component/initialise/createModel/_createModel.js */
		var createModel = function( types, parseJSON, resolveRef, ComponentParameter, ReferenceExpressionParameter ) {

			var __export;
			__export = function( component, defaultData, attributes, toBind ) {
				var data = {},
					key, value;
				// some parameters, e.g. foo="The value is {{bar}}", are 'complex' - in
				// other words, we need to construct a string fragment to watch
				// when they change. We store these so they can be torn down later
				component.complexParameters = [];
				for ( key in attributes ) {
					if ( attributes.hasOwnProperty( key ) ) {
						value = getValue( component, key, attributes[ key ], toBind );
						if ( value !== undefined || defaultData[ key ] === undefined ) {
							data[ key ] = value;
						}
					}
				}
				return data;
			};

			function getValue( component, key, template, toBind ) {
				var parameter, parsed, parentInstance, parentFragment, keypath, indexRef;
				parentInstance = component.root;
				parentFragment = component.parentFragment;
				// If this is a static value, great
				if ( typeof template === 'string' ) {
					parsed = parseJSON( template );
					if ( !parsed ) {
						return template;
					}
					return parsed.value;
				}
				// If null, we treat it as a boolean attribute (i.e. true)
				if ( template === null ) {
					return true;
				}
				// Single interpolator?
				if ( template.length === 1 && template[ 0 ].t === types.INTERPOLATOR ) {
					// If it's a regular interpolator, we bind to it
					if ( template[ 0 ].r ) {
						// Is it an index reference?
						if ( parentFragment.indexRefs && parentFragment.indexRefs[ indexRef = template[ 0 ].r ] !== undefined ) {
							component.indexRefBindings[ indexRef ] = key;
							return parentFragment.indexRefs[ indexRef ];
						}
						// TODO what about references that resolve late? Should these be considered?
						keypath = resolveRef( parentInstance, template[ 0 ].r, parentFragment ) || template[ 0 ].r;
						// We need to set up bindings between parent and child, but
						// we can't do it yet because the child instance doesn't exist
						// yet - so we make a note instead
						toBind.push( {
							childKeypath: key,
							parentKeypath: keypath
						} );
						return parentInstance.viewmodel.get( keypath );
					}
					// If it's a reference expression (e.g. `{{foo[bar]}}`), we need
					// to watch the keypath and create/destroy bindings
					if ( template[ 0 ].rx ) {
						parameter = new ReferenceExpressionParameter( component, key, template[ 0 ].rx, toBind );
						component.complexParameters.push( parameter );
						parameter.ready = true;
						return parameter.value;
					}
				}
				// We have a 'complex parameter' - we need to create a full-blown string
				// fragment in order to evaluate and observe its value
				parameter = new ComponentParameter( component, key, template );
				component.complexParameters.push( parameter );
				return parameter.value;
			}
			return __export;
		}( types, parseJSON, resolveRef, ComponentParameter, ReferenceExpressionParameter );

		/* virtualdom/items/Component/initialise/createInstance.js */
		var createInstance = function( log ) {

			return function( component, Component, data, contentDescriptor ) {
				var instance, parentFragment, partials, ractive;
				parentFragment = component.parentFragment;
				ractive = component.root;
				// Make contents available as a {{>content}} partial
				partials = {
					content: contentDescriptor || []
				};
				if ( Component.defaults.el ) {
					log.warn( {
						debug: ractive.debug,
						message: 'defaultElSpecified',
						args: {
							name: component.name
						}
					} );
				}
				instance = new Component( {
					el: null,
					append: true,
					data: data,
					partials: partials,
					magic: ractive.magic || Component.defaults.magic,
					modifyArrays: ractive.modifyArrays,
					_parent: ractive,
					_component: component,
					// need to inherit runtime parent adaptors
					adapt: ractive.adapt,
					yield: {
						template: contentDescriptor,
						instance: ractive
					}
				} );
				return instance;
			};
		}( log );

		/* virtualdom/items/Component/initialise/createBindings.js */
		var createBindings = function( createComponentBinding ) {

			return function createInitialComponentBindings( component, toBind ) {
				toBind.forEach( function createInitialComponentBinding( pair ) {
					var childValue, parentValue;
					createComponentBinding( component, component.root, pair.parentKeypath, pair.childKeypath );
					childValue = component.instance.viewmodel.get( pair.childKeypath );
					parentValue = component.root.viewmodel.get( pair.parentKeypath );
					if ( childValue !== undefined && parentValue === undefined ) {
						component.root.viewmodel.set( pair.parentKeypath, childValue );
					}
				} );
			};
		}( createComponentBinding );

		/* virtualdom/items/Component/initialise/propagateEvents.js */
		var propagateEvents = function( circular, fireEvent, log ) {

			var __export;
			var Fragment;
			circular.push( function() {
				Fragment = circular.Fragment;
			} );
			__export = function propagateEvents( component, eventsDescriptor ) {
				var eventName;
				for ( eventName in eventsDescriptor ) {
					if ( eventsDescriptor.hasOwnProperty( eventName ) ) {
						propagateEvent( component.instance, component.root, eventName, eventsDescriptor[ eventName ] );
					}
				}
			};

			function propagateEvent( childInstance, parentInstance, eventName, proxyEventName ) {
				if ( typeof proxyEventName !== 'string' ) {
					log.error( {
						debug: parentInstance.debug,
						message: 'noComponentEventArguments'
					} );
				}
				childInstance.on( eventName, function() {
					var event, args;
					// semi-weak test, but what else? tag the event obj ._isEvent ?
					if ( arguments.length && arguments[ 0 ] && arguments[ 0 ].node ) {
						event = Array.prototype.shift.call( arguments );
					}
					args = Array.prototype.slice.call( arguments );
					fireEvent( parentInstance, proxyEventName, {
						event: event,
						args: args
					} );
					// cancel bubbling
					return false;
				} );
			}
			return __export;
		}( circular, Ractive$shared_fireEvent, log );

		/* virtualdom/items/Component/initialise/updateLiveQueries.js */
		var updateLiveQueries = function( component ) {
			var ancestor, query;
			// If there's a live query for this component type, add it
			ancestor = component.root;
			while ( ancestor ) {
				if ( query = ancestor._liveComponentQueries[ '_' + component.name ] ) {
					query.push( component.instance );
				}
				ancestor = ancestor._parent;
			}
		};

		/* virtualdom/items/Component/prototype/init.js */
		var virtualdom_items_Component$init = function( types, warn, createModel, createInstance, createBindings, propagateEvents, updateLiveQueries ) {

			return function Component$init( options, Component ) {
				var parentFragment, root, data, toBind;
				parentFragment = this.parentFragment = options.parentFragment;
				root = parentFragment.root;
				this.root = root;
				this.type = types.COMPONENT;
				this.name = options.template.e;
				this.index = options.index;
				this.indexRefBindings = {};
				this.bindings = [];
				// even though only one yielder is allowed, we need to have an array of them
				// as it's possible to cause a yielder to be created before the last one
				// was destroyed in the same turn of the runloop
				this.yielders = [];
				if ( !Component ) {
					throw new Error( 'Component "' + this.name + '" not found' );
				}
				// First, we need to create a model for the component - e.g. if we
				// encounter <widget foo='bar'/> then we need to create a widget
				// with `data: { foo: 'bar' }`.
				//
				// This may involve setting up some bindings, but we can't do it
				// yet so we take some notes instead
				toBind = [];
				data = createModel( this, Component.defaults.data || {}, options.template.a, toBind );
				createInstance( this, Component, data, options.template.f );
				createBindings( this, toBind );
				propagateEvents( this, options.template.v );
				// intro, outro and decorator directives have no effect
				if ( options.template.t1 || options.template.t2 || options.template.o ) {
					warn( 'The "intro", "outro" and "decorator" directives have no effect on components' );
				}
				updateLiveQueries( this );
			};
		}( types, warn, createModel, createInstance, createBindings, propagateEvents, updateLiveQueries );

		/* virtualdom/items/Component/prototype/rebind.js */
		var virtualdom_items_Component$rebind = function( runloop, getNewKeypath ) {

			return function Component$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
				var childInstance = this.instance,
					parentInstance = childInstance._parent,
					indexRefAlias, query;
				this.bindings.forEach( function( binding ) {
					var updated;
					if ( binding.root !== parentInstance ) {
						return;
					}
					if ( updated = getNewKeypath( binding.keypath, oldKeypath, newKeypath ) ) {
						binding.rebind( updated );
					}
				} );
				this.complexParameters.forEach( rebind );
				if ( this.yielders[ 0 ] ) {
					rebind( this.yielders[ 0 ] );
				}
				if ( indexRefAlias = this.indexRefBindings[ indexRef ] ) {
					runloop.addViewmodel( childInstance.viewmodel );
					childInstance.viewmodel.set( indexRefAlias, newIndex );
				}
				if ( query = this.root._liveComponentQueries[ '_' + this.name ] ) {
					query._makeDirty();
				}

				function rebind( x ) {
					x.rebind( indexRef, newIndex, oldKeypath, newKeypath );
				}
			};
		}( runloop, getNewKeypath );

		/* virtualdom/items/Component/prototype/render.js */
		var virtualdom_items_Component$render = function Component$render() {
			var instance = this.instance;
			instance.render( this.parentFragment.getNode() );
			this.rendered = true;
			return instance.fragment.detach();
		};

		/* virtualdom/items/Component/prototype/toString.js */
		var virtualdom_items_Component$toString = function Component$toString() {
			return this.instance.fragment.toString();
		};

		/* virtualdom/items/Component/prototype/unbind.js */
		var virtualdom_items_Component$unbind = function( Hook, removeFromArray ) {

			var __export;
			var teardownHook = new Hook( 'teardown' );
			__export = function Component$unbind() {
				var instance = this.instance;
				this.complexParameters.forEach( unbind );
				this.bindings.forEach( unbind );
				removeFromLiveComponentQueries( this );
				// teardown the instance
				instance.fragment.unbind();
				instance.viewmodel.teardown();
				if ( instance.fragment.rendered && instance.el.__ractive_instances__ ) {
					removeFromArray( instance.el.__ractive_instances__, instance );
				}
				teardownHook.fire( instance );
			};

			function unbind( thing ) {
				thing.unbind();
			}

			function removeFromLiveComponentQueries( component ) {
				var instance, query;
				instance = component.root;
				do {
					if ( query = instance._liveComponentQueries[ '_' + component.name ] ) {
						query._remove( component );
					}
				} while ( instance = instance._parent );
			}
			return __export;
		}( Ractive$shared_hooks_Hook, removeFromArray );

		/* virtualdom/items/Component/prototype/unrender.js */
		var virtualdom_items_Component$unrender = function Component$unrender( shouldDestroy ) {
			this.shouldDestroy = shouldDestroy;
			this.instance.unrender();
		};

		/* virtualdom/items/Component/_Component.js */
		var Component = function( detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, init, rebind, render, toString, unbind, unrender ) {

			var Component = function( options, Constructor ) {
				this.init( options, Constructor );
			};
			Component.prototype = {
				detach: detach,
				find: find,
				findAll: findAll,
				findAllComponents: findAllComponents,
				findComponent: findComponent,
				findNextNode: findNextNode,
				firstNode: firstNode,
				init: init,
				rebind: rebind,
				render: render,
				toString: toString,
				unbind: unbind,
				unrender: unrender
			};
			return Component;
		}( virtualdom_items_Component$detach, virtualdom_items_Component$find, virtualdom_items_Component$findAll, virtualdom_items_Component$findAllComponents, virtualdom_items_Component$findComponent, virtualdom_items_Component$findNextNode, virtualdom_items_Component$firstNode, virtualdom_items_Component$init, virtualdom_items_Component$rebind, virtualdom_items_Component$render, virtualdom_items_Component$toString, virtualdom_items_Component$unbind, virtualdom_items_Component$unrender );

		/* virtualdom/items/Comment.js */
		var Comment = function( types, detach ) {

			var Comment = function( options ) {
				this.type = types.COMMENT;
				this.value = options.template.c;
			};
			Comment.prototype = {
				detach: detach,
				firstNode: function() {
					return this.node;
				},
				render: function() {
					if ( !this.node ) {
						this.node = document.createComment( this.value );
					}
					return this.node;
				},
				toString: function() {
					return '<!--' + this.value + '-->';
				},
				unrender: function( shouldDestroy ) {
					if ( shouldDestroy ) {
						this.node.parentNode.removeChild( this.node );
					}
				}
			};
			return Comment;
		}( types, detach );

		/* virtualdom/items/Yielder.js */
		var Yielder = function( runloop, removeFromArray, circular ) {

			var Fragment;
			circular.push( function() {
				Fragment = circular.Fragment;
			} );
			var Yielder = function( options ) {
				var componentInstance, component;
				componentInstance = options.parentFragment.root;
				this.component = component = componentInstance.component;
				this.surrogateParent = options.parentFragment;
				this.parentFragment = component.parentFragment;
				this.fragment = new Fragment( {
					owner: this,
					root: componentInstance.yield.instance,
					template: componentInstance.yield.template,
					pElement: this.surrogateParent.pElement
				} );
				component.yielders.push( this );
				runloop.scheduleTask( function() {
					if ( component.yielders.length > 1 ) {
						throw new Error( 'A component template can only have one {{yield}} declaration at a time' );
					}
				} );
			};
			Yielder.prototype = {
				detach: function() {
					return this.fragment.detach();
				},
				find: function( selector ) {
					return this.fragment.find( selector );
				},
				findAll: function( selector, query ) {
					return this.fragment.findAll( selector, query );
				},
				findComponent: function( selector ) {
					return this.fragment.findComponent( selector );
				},
				findAllComponents: function( selector, query ) {
					return this.fragment.findAllComponents( selector, query );
				},
				findNextNode: function() {
					return this.surrogateParent.findNextNode( this );
				},
				firstNode: function() {
					return this.fragment.firstNode();
				},
				getValue: function( options ) {
					return this.fragment.getValue( options );
				},
				render: function() {
					return this.fragment.render();
				},
				unbind: function() {
					this.fragment.unbind();
				},
				unrender: function( shouldDestroy ) {
					this.fragment.unrender( shouldDestroy );
					removeFromArray( this.component.yielders, this );
				},
				rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
					this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
				},
				toString: function() {
					return this.fragment.toString();
				}
			};
			return Yielder;
		}( runloop, removeFromArray, circular );

		/* virtualdom/Fragment/prototype/init/createItem.js */
		var virtualdom_Fragment$init_createItem = function( types, Text, Interpolator, Section, Triple, Element, Partial, getComponent, Component, Comment, Yielder ) {

			return function createItem( options ) {
				if ( typeof options.template === 'string' ) {
					return new Text( options );
				}
				switch ( options.template.t ) {
					case types.INTERPOLATOR:
						if ( options.template.r === 'yield' ) {
							return new Yielder( options );
						}
						return new Interpolator( options );
					case types.SECTION:
						return new Section( options );
					case types.TRIPLE:
						return new Triple( options );
					case types.ELEMENT:
						var constructor;
						if ( constructor = getComponent( options.parentFragment.root, options.template.e ) ) {
							return new Component( options, constructor );
						}
						return new Element( options );
					case types.PARTIAL:
						return new Partial( options );
					case types.COMMENT:
						return new Comment( options );
					default:
						throw new Error( 'Something very strange happened. Please file an issue at https://github.com/ractivejs/ractive/issues. Thanks!' );
				}
			};
		}( types, Text, Interpolator, Section, Triple, Element, Partial, getComponent, Component, Comment, Yielder );

		/* virtualdom/Fragment/prototype/init.js */
		var virtualdom_Fragment$init = function( types, create, createItem ) {

			return function Fragment$init( options ) {
				var this$0 = this;
				var parentFragment, parentRefs, ref;
				// The item that owns this fragment - an element, section, partial, or attribute
				this.owner = options.owner;
				parentFragment = this.parent = this.owner.parentFragment;
				// inherited properties
				this.root = options.root;
				this.pElement = options.pElement;
				this.context = options.context;
				// If parent item is a section, this may not be the only fragment
				// that belongs to it - we need to make a note of the index
				if ( this.owner.type === types.SECTION ) {
					this.index = options.index;
				}
				// index references (the 'i' in {{#section:i}}...{{/section}}) need to cascade
				// down the tree
				if ( parentFragment ) {
					parentRefs = parentFragment.indexRefs;
					if ( parentRefs ) {
						this.indexRefs = create( null );
						// avoids need for hasOwnProperty
						for ( ref in parentRefs ) {
							this.indexRefs[ ref ] = parentRefs[ ref ];
						}
					}
				}
				if ( options.indexRef ) {
					if ( !this.indexRefs ) {
						this.indexRefs = {};
					}
					this.indexRefs[ options.indexRef ] = options.index;
				}
				// Time to create this fragment's child items
				// TEMP should this be happening?
				if ( typeof options.template === 'string' ) {
					options.template = [ options.template ];
				} else if ( !options.template ) {
					options.template = [];
				}
				this.items = options.template.map( function( template, i ) {
					return createItem( {
						parentFragment: this$0,
						pElement: options.pElement,
						template: template,
						index: i
					} );
				} );
				this.value = this.argsList = null;
				this.dirtyArgs = this.dirtyValue = true;
				this.bound = true;
			};
		}( types, create, virtualdom_Fragment$init_createItem );

		/* virtualdom/Fragment/prototype/rebind.js */
		var virtualdom_Fragment$rebind = function( assignNewKeypath ) {

			return function Fragment$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
				this.index = newIndex;
				// assign new context keypath if needed
				assignNewKeypath( this, 'context', oldKeypath, newKeypath );
				if ( this.indexRefs && this.indexRefs[ indexRef ] !== undefined ) {
					this.indexRefs[ indexRef ] = newIndex;
				}
				this.items.forEach( function( item ) {
					if ( item.rebind ) {
						item.rebind( indexRef, newIndex, oldKeypath, newKeypath );
					}
				} );
			};
		}( assignNewKeypath );

		/* virtualdom/Fragment/prototype/render.js */
		var virtualdom_Fragment$render = function Fragment$render() {
			var result;
			if ( this.items.length === 1 ) {
				result = this.items[ 0 ].render();
			} else {
				result = document.createDocumentFragment();
				this.items.forEach( function( item ) {
					result.appendChild( item.render() );
				} );
			}
			this.rendered = true;
			return result;
		};

		/* virtualdom/Fragment/prototype/toString.js */
		var virtualdom_Fragment$toString = function Fragment$toString( escape ) {
			if ( !this.items ) {
				return '';
			}
			return this.items.map( function( item ) {
				return item.toString( escape );
			} ).join( '' );
		};

		/* virtualdom/Fragment/prototype/unbind.js */
		var virtualdom_Fragment$unbind = function() {

			var __export;
			__export = function Fragment$unbind() {
				if ( !this.bound ) {
					return;
				}
				this.items.forEach( unbindItem );
				this.bound = false;
			};

			function unbindItem( item ) {
				if ( item.unbind ) {
					item.unbind();
				}
			}
			return __export;
		}();

		/* virtualdom/Fragment/prototype/unrender.js */
		var virtualdom_Fragment$unrender = function Fragment$unrender( shouldDestroy ) {
			if ( !this.rendered ) {
				throw new Error( 'Attempted to unrender a fragment that was not rendered' );
			}
			this.items.forEach( function( i ) {
				return i.unrender( shouldDestroy );
			} );
			this.rendered = false;
		};

		/* virtualdom/Fragment.js */
		var Fragment = function( bubble, detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, getNode, getValue, init, rebind, render, toString, unbind, unrender, circular ) {

			var Fragment = function( options ) {
				this.init( options );
			};
			Fragment.prototype = {
				bubble: bubble,
				detach: detach,
				find: find,
				findAll: findAll,
				findAllComponents: findAllComponents,
				findComponent: findComponent,
				findNextNode: findNextNode,
				firstNode: firstNode,
				getNode: getNode,
				getValue: getValue,
				init: init,
				rebind: rebind,
				render: render,
				toString: toString,
				unbind: unbind,
				unrender: unrender
			};
			circular.Fragment = Fragment;
			return Fragment;
		}( virtualdom_Fragment$bubble, virtualdom_Fragment$detach, virtualdom_Fragment$find, virtualdom_Fragment$findAll, virtualdom_Fragment$findAllComponents, virtualdom_Fragment$findComponent, virtualdom_Fragment$findNextNode, virtualdom_Fragment$firstNode, virtualdom_Fragment$getNode, virtualdom_Fragment$getValue, virtualdom_Fragment$init, virtualdom_Fragment$rebind, virtualdom_Fragment$render, virtualdom_Fragment$toString, virtualdom_Fragment$unbind, virtualdom_Fragment$unrender, circular );

		/* Ractive/prototype/reset.js */
		var Ractive$reset = function( Hook, runloop, Fragment, config ) {

			var shouldRerender = [
					'template',
					'partials',
					'components',
					'decorators',
					'events'
				],
				resetHook = new Hook( 'reset' );
			return function Ractive$reset( data, callback ) {
				var promise, wrapper, changes, i, rerender;
				if ( typeof data === 'function' && !callback ) {
					callback = data;
					data = {};
				} else {
					data = data || {};
				}
				if ( typeof data !== 'object' ) {
					throw new Error( 'The reset method takes either no arguments, or an object containing new data' );
				}
				// If the root object is wrapped, try and use the wrapper's reset value
				if ( ( wrapper = this.viewmodel.wrapped[ '' ] ) && wrapper.reset ) {
					if ( wrapper.reset( data ) === false ) {
						// reset was rejected, we need to replace the object
						this.data = data;
					}
				} else {
					this.data = data;
				}
				// reset config items and track if need to rerender
				changes = config.reset( this );
				i = changes.length;
				while ( i-- ) {
					if ( shouldRerender.indexOf( changes[ i ] ) > -1 ) {
						rerender = true;
						break;
					}
				}
				if ( rerender ) {
					var component;
					this.viewmodel.mark( '' );
					// Is this is a component, we need to set the `shouldDestroy`
					// flag, otherwise it will assume by default that a parent node
					// will be detached, and therefore it doesn't need to bother
					// detaching its own nodes
					if ( component = this.component ) {
						component.shouldDestroy = true;
					}
					this.unrender();
					if ( component ) {
						component.shouldDestroy = false;
					}
					// If the template changed, we need to destroy the parallel DOM
					// TODO if we're here, presumably it did?
					if ( this.fragment.template !== this.template ) {
						this.fragment.unbind();
						this.fragment = new Fragment( {
							template: this.template,
							root: this,
							owner: this
						} );
					}
					promise = this.render( this.el, this.anchor );
				} else {
					promise = runloop.start( this, true );
					this.viewmodel.mark( '' );
					runloop.end();
				}
				resetHook.fire( this, data );
				if ( callback ) {
					promise.then( callback );
				}
				return promise;
			};
		}( Ractive$shared_hooks_Hook, runloop, Fragment, config );

		/* Ractive/prototype/resetTemplate.js */
		var Ractive$resetTemplate = function( config, Fragment ) {

			return function Ractive$resetTemplate( template ) {
				var transitionsEnabled, component;
				config.template.init( null, this, {
					template: template
				} );
				transitionsEnabled = this.transitionsEnabled;
				this.transitionsEnabled = false;
				// Is this is a component, we need to set the `shouldDestroy`
				// flag, otherwise it will assume by default that a parent node
				// will be detached, and therefore it doesn't need to bother
				// detaching its own nodes
				if ( component = this.component ) {
					component.shouldDestroy = true;
				}
				this.unrender();
				if ( component ) {
					component.shouldDestroy = false;
				}
				// remove existing fragment and create new one
				this.fragment.unbind();
				this.fragment = new Fragment( {
					template: this.template,
					root: this,
					owner: this
				} );
				this.render( this.el, this.anchor );
				this.transitionsEnabled = transitionsEnabled;
			};
		}( config, Fragment );

		/* Ractive/prototype/reverse.js */
		var Ractive$reverse = function( makeArrayMethod ) {

			return makeArrayMethod( 'reverse' );
		}( Ractive$shared_makeArrayMethod );

		/* Ractive/prototype/set.js */
		var Ractive$set = function( runloop, isObject, normaliseKeypath, getMatchingKeypaths ) {

			var wildcard = /\*/;
			return function Ractive$set( keypath, value, callback ) {
				var this$0 = this;
				var map, promise;
				promise = runloop.start( this, true );
				// Set multiple keypaths in one go
				if ( isObject( keypath ) ) {
					map = keypath;
					callback = value;
					for ( keypath in map ) {
						if ( map.hasOwnProperty( keypath ) ) {
							value = map[ keypath ];
							keypath = normaliseKeypath( keypath );
							this.viewmodel.set( keypath, value );
						}
					}
				} else {
					keypath = normaliseKeypath( keypath );
					if ( wildcard.test( keypath ) ) {
						getMatchingKeypaths( this, keypath ).forEach( function( keypath ) {
							this$0.viewmodel.set( keypath, value );
						} );
					} else {
						this.viewmodel.set( keypath, value );
					}
				}
				runloop.end();
				if ( callback ) {
					promise.then( callback.bind( this ) );
				}
				return promise;
			};
		}( runloop, isObject, normaliseKeypath, getMatchingKeypaths );

		/* Ractive/prototype/shift.js */
		var Ractive$shift = function( makeArrayMethod ) {

			return makeArrayMethod( 'shift' );
		}( Ractive$shared_makeArrayMethod );

		/* Ractive/prototype/sort.js */
		var Ractive$sort = function( makeArrayMethod ) {

			return makeArrayMethod( 'sort' );
		}( Ractive$shared_makeArrayMethod );

		/* Ractive/prototype/splice.js */
		var Ractive$splice = function( makeArrayMethod ) {

			return makeArrayMethod( 'splice' );
		}( Ractive$shared_makeArrayMethod );

		/* Ractive/prototype/subtract.js */
		var Ractive$subtract = function( add ) {

			return function Ractive$subtract( keypath, d ) {
				return add( this, keypath, d === undefined ? -1 : -d );
			};
		}( Ractive$shared_add );

		/* Ractive/prototype/teardown.js */
		var Ractive$teardown = function( Hook, Promise, removeFromArray ) {

			var teardownHook = new Hook( 'teardown' );
			// Teardown. This goes through the root fragment and all its children, removing observers
			// and generally cleaning up after itself
			return function Ractive$teardown( callback ) {
				var promise;
				this.fragment.unbind();
				this.viewmodel.teardown();
				if ( this.fragment.rendered && this.el.__ractive_instances__ ) {
					removeFromArray( this.el.__ractive_instances__, this );
				}
				this.shouldDestroy = true;
				promise = this.fragment.rendered ? this.unrender() : Promise.resolve();
				teardownHook.fire( this );
				if ( callback ) {
					// TODO deprecate this?
					promise.then( callback.bind( this ) );
				}
				return promise;
			};
		}( Ractive$shared_hooks_Hook, Promise, removeFromArray );

		/* Ractive/prototype/toggle.js */
		var Ractive$toggle = function( log ) {

			return function Ractive$toggle( keypath, callback ) {
				var value;
				if ( typeof keypath !== 'string' ) {
					log.errorOnly( {
						debug: this.debug,
						messsage: 'badArguments',
						arg: {
							arguments: keypath
						}
					} );
				}
				value = this.get( keypath );
				return this.set( keypath, !value, callback );
			};
		}( log );

		/* Ractive/prototype/toHTML.js */
		var Ractive$toHTML = function Ractive$toHTML() {
			return this.fragment.toString( true );
		};

		/* Ractive/prototype/unrender.js */
		var Ractive$unrender = function( css, Hook, log, Promise, removeFromArray, runloop ) {

			var unrenderHook = new Hook( 'unrender' );
			return function Ractive$unrender() {
				var this$0 = this;
				var promise, shouldDestroy;
				if ( !this.fragment.rendered ) {
					log.warn( {
						debug: this.debug,
						message: 'ractive.unrender() was called on a Ractive instance that was not rendered'
					} );
					return Promise.resolve();
				}
				promise = runloop.start( this, true );
				// If this is a component, and the component isn't marked for destruction,
				// don't detach nodes from the DOM unnecessarily
				shouldDestroy = !this.component || this.component.shouldDestroy || this.shouldDestroy;
				if ( this.constructor.css ) {
					promise.then( function() {
						css.remove( this$0.constructor );
					} );
				}
				// Cancel any animations in progress
				while ( this._animations[ 0 ] ) {
					this._animations[ 0 ].stop();
				}
				this.fragment.unrender( shouldDestroy );
				removeFromArray( this.el.__ractive_instances__, this );
				unrenderHook.fire( this );
				runloop.end();
				return promise;
			};
		}( global_css, Ractive$shared_hooks_Hook, log, Promise, removeFromArray, runloop );

		/* Ractive/prototype/unshift.js */
		var Ractive$unshift = function( makeArrayMethod ) {

			return makeArrayMethod( 'unshift' );
		}( Ractive$shared_makeArrayMethod );

		/* Ractive/prototype/update.js */
		var Ractive$update = function( Hook, runloop ) {

			var updateHook = new Hook( 'update' );
			return function Ractive$update( keypath, callback ) {
				var promise;
				if ( typeof keypath === 'function' ) {
					callback = keypath;
					keypath = '';
				} else {
					keypath = keypath || '';
				}
				promise = runloop.start( this, true );
				this.viewmodel.mark( keypath );
				runloop.end();
				updateHook.fire( this, keypath );
				if ( callback ) {
					promise.then( callback.bind( this ) );
				}
				return promise;
			};
		}( Ractive$shared_hooks_Hook, runloop );

		/* Ractive/prototype/updateModel.js */
		var Ractive$updateModel = function( arrayContentsMatch, isEqual ) {

			var __export;
			__export = function Ractive$updateModel( keypath, cascade ) {
				var values;
				if ( typeof keypath !== 'string' ) {
					keypath = '';
					cascade = true;
				}
				consolidateChangedValues( this, keypath, values = {}, cascade );
				return this.set( values );
			};

			function consolidateChangedValues( ractive, keypath, values, cascade ) {
				var bindings, childDeps, i, binding, oldValue, newValue, checkboxGroups = [];
				bindings = ractive._twowayBindings[ keypath ];
				if ( bindings && ( i = bindings.length ) ) {
					while ( i-- ) {
						binding = bindings[ i ];
						// special case - radio name bindings
						if ( binding.radioName && !binding.element.node.checked ) {
							continue;
						}
						// special case - checkbox name bindings come in groups, so
						// we want to get the value once at most
						if ( binding.checkboxName ) {
							if ( !checkboxGroups[ binding.keypath ] && !binding.changed() ) {
								checkboxGroups.push( binding.keypath );
								checkboxGroups[ binding.keypath ] = binding;
							}
							continue;
						}
						oldValue = binding.attribute.value;
						newValue = binding.getValue();
						if ( arrayContentsMatch( oldValue, newValue ) ) {
							continue;
						}
						if ( !isEqual( oldValue, newValue ) ) {
							values[ keypath ] = newValue;
						}
					}
				}
				// Handle groups of `<input type='checkbox' name='{{foo}}' ...>`
				if ( checkboxGroups.length ) {
					checkboxGroups.forEach( function( keypath ) {
						var binding, oldValue, newValue;
						binding = checkboxGroups[ keypath ];
						// one to represent the entire group
						oldValue = binding.attribute.value;
						newValue = binding.getValue();
						if ( !arrayContentsMatch( oldValue, newValue ) ) {
							values[ keypath ] = newValue;
						}
					} );
				}
				if ( !cascade ) {
					return;
				}
				// cascade
				childDeps = ractive.viewmodel.depsMap[ 'default' ][ keypath ];
				if ( childDeps ) {
					i = childDeps.length;
					while ( i-- ) {
						consolidateChangedValues( ractive, childDeps[ i ], values, cascade );
					}
				}
			}
			return __export;
		}( arrayContentsMatch, isEqual );

		/* Ractive/prototype.js */
		var prototype = function( add, animate, detach, find, findAll, findAllComponents, findComponent, fire, get, insert, merge, observe, off, on, pop, push, render, reset, resetTemplate, reverse, set, shift, sort, splice, subtract, teardown, toggle, toHTML, unrender, unshift, update, updateModel ) {

			return {
				add: add,
				animate: animate,
				detach: detach,
				find: find,
				findAll: findAll,
				findAllComponents: findAllComponents,
				findComponent: findComponent,
				fire: fire,
				get: get,
				insert: insert,
				merge: merge,
				observe: observe,
				off: off,
				on: on,
				pop: pop,
				push: push,
				render: render,
				reset: reset,
				resetTemplate: resetTemplate,
				reverse: reverse,
				set: set,
				shift: shift,
				sort: sort,
				splice: splice,
				subtract: subtract,
				teardown: teardown,
				toggle: toggle,
				toHTML: toHTML,
				unrender: unrender,
				unshift: unshift,
				update: update,
				updateModel: updateModel
			};
		}( Ractive$add, Ractive$animate, Ractive$detach, Ractive$find, Ractive$findAll, Ractive$findAllComponents, Ractive$findComponent, Ractive$fire, Ractive$get, Ractive$insert, Ractive$merge, Ractive$observe, Ractive$off, Ractive$on, Ractive$pop, Ractive$push, Ractive$render, Ractive$reset, Ractive$resetTemplate, Ractive$reverse, Ractive$set, Ractive$shift, Ractive$sort, Ractive$splice, Ractive$subtract, Ractive$teardown, Ractive$toggle, Ractive$toHTML, Ractive$unrender, Ractive$unshift, Ractive$update, Ractive$updateModel );

		/* utils/getGuid.js */
		var getGuid = function() {
			return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace( /[xy]/g, function( c ) {
				var r, v;
				r = Math.random() * 16 | 0;
				v = c == 'x' ? r : r & 3 | 8;
				return v.toString( 16 );
			} );
		};

		/* utils/getNextNumber.js */
		var getNextNumber = function() {

			var i = 0;
			return function() {
				return 'r-' + i++;
			};
		}();

		/* Ractive/prototype/shared/hooks/HookQueue.js */
		var Ractive$shared_hooks_HookQueue = function( Hook ) {

			function HookQueue( event ) {
				this.hook = new Hook( event );
				this.inProcess = {};
				this.queue = {};
			}
			HookQueue.prototype = {
				constructor: HookQueue,
				begin: function( ractive ) {
					this.inProcess[ ractive._guid ] = true;
				},
				end: function( ractive ) {
					var parent = ractive._parent;
					// If this is *isn't* a child of a component that's in process,
					// it should call methods or fire at this point
					if ( !parent || !this.inProcess[ parent._guid ] ) {
						fire( this, ractive );
					} else {
						getChildQueue( this.queue, parent ).push( ractive );
					}
					delete this.inProcess[ ractive._guid ];
				}
			};

			function getChildQueue( queue, ractive ) {
				return queue[ ractive._guid ] || ( queue[ ractive._guid ] = [] );
			}

			function fire( hookQueue, ractive ) {
				var childQueue = getChildQueue( hookQueue.queue, ractive );
				hookQueue.hook.fire( ractive );
				// queue is "live" because components can end up being
				// added while hooks fire on parents that modify data values.
				while ( childQueue.length ) {
					fire( hookQueue, childQueue.shift() );
				}
				delete hookQueue.queue[ ractive._guid ];
			}
			return HookQueue;
		}( Ractive$shared_hooks_Hook );

		/* viewmodel/prototype/get/arrayAdaptor/processWrapper.js */
		var viewmodel$get_arrayAdaptor_processWrapper = function( wrapper, array, methodName, newIndices ) {
			var root = wrapper.root,
				keypath = wrapper.keypath;
			// If this is a sort or reverse, we just do root.set()...
			// TODO use merge logic?
			if ( methodName === 'sort' || methodName === 'reverse' ) {
				root.viewmodel.set( keypath, array );
				return;
			}
			root.viewmodel.smartUpdate( keypath, array, newIndices );
		};

		/* viewmodel/prototype/get/arrayAdaptor/patch.js */
		var viewmodel$get_arrayAdaptor_patch = function( runloop, defineProperty, getNewIndices, processWrapper ) {

			var patchedArrayProto = [],
				mutatorMethods = [
					'pop',
					'push',
					'reverse',
					'shift',
					'sort',
					'splice',
					'unshift'
				],
				testObj, patchArrayMethods, unpatchArrayMethods;
			mutatorMethods.forEach( function( methodName ) {
				var method = function() {
					var SLICE$0 = Array.prototype.slice;
					var args = SLICE$0.call( arguments, 0 );
					var newIndices, result, wrapper, i;
					newIndices = getNewIndices( this, methodName, args );
					// apply the underlying method
					result = Array.prototype[ methodName ].apply( this, arguments );
					// trigger changes
					runloop.start();
					this._ractive.setting = true;
					i = this._ractive.wrappers.length;
					while ( i-- ) {
						wrapper = this._ractive.wrappers[ i ];
						runloop.addViewmodel( wrapper.root.viewmodel );
						processWrapper( wrapper, this, methodName, newIndices );
					}
					runloop.end();
					this._ractive.setting = false;
					return result;
				};
				defineProperty( patchedArrayProto, methodName, {
					value: method
				} );
			} );
			// can we use prototype chain injection?
			// http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/#wrappers_prototype_chain_injection
			testObj = {};
			if ( testObj.__proto__ ) {
				// yes, we can
				patchArrayMethods = function( array ) {
					array.__proto__ = patchedArrayProto;
				};
				unpatchArrayMethods = function( array ) {
					array.__proto__ = Array.prototype;
				};
			} else {
				// no, we can't
				patchArrayMethods = function( array ) {
					var i, methodName;
					i = mutatorMethods.length;
					while ( i-- ) {
						methodName = mutatorMethods[ i ];
						defineProperty( array, methodName, {
							value: patchedArrayProto[ methodName ],
							configurable: true
						} );
					}
				};
				unpatchArrayMethods = function( array ) {
					var i;
					i = mutatorMethods.length;
					while ( i-- ) {
						delete array[ mutatorMethods[ i ] ];
					}
				};
			}
			patchArrayMethods.unpatch = unpatchArrayMethods;
			return patchArrayMethods;
		}( runloop, defineProperty, getNewIndices, viewmodel$get_arrayAdaptor_processWrapper );

		/* viewmodel/prototype/get/arrayAdaptor.js */
		var viewmodel$get_arrayAdaptor = function( defineProperty, isArray, patch ) {

			var arrayAdaptor,
				// helpers
				ArrayWrapper, errorMessage;
			arrayAdaptor = {
				filter: function( object ) {
					// wrap the array if a) b) it's an array, and b) either it hasn't been wrapped already,
					// or the array didn't trigger the get() itself
					return isArray( object ) && ( !object._ractive || !object._ractive.setting );
				},
				wrap: function( ractive, array, keypath ) {
					return new ArrayWrapper( ractive, array, keypath );
				}
			};
			ArrayWrapper = function( ractive, array, keypath ) {
				this.root = ractive;
				this.value = array;
				this.keypath = keypath;
				// if this array hasn't already been ractified, ractify it
				if ( !array._ractive ) {
					// define a non-enumerable _ractive property to store the wrappers
					defineProperty( array, '_ractive', {
						value: {
							wrappers: [],
							instances: [],
							setting: false
						},
						configurable: true
					} );
					patch( array );
				}
				// store the ractive instance, so we can handle transitions later
				if ( !array._ractive.instances[ ractive._guid ] ) {
					array._ractive.instances[ ractive._guid ] = 0;
					array._ractive.instances.push( ractive );
				}
				array._ractive.instances[ ractive._guid ] += 1;
				array._ractive.wrappers.push( this );
			};
			ArrayWrapper.prototype = {
				get: function() {
					return this.value;
				},
				teardown: function() {
					var array, storage, wrappers, instances, index;
					array = this.value;
					storage = array._ractive;
					wrappers = storage.wrappers;
					instances = storage.instances;
					// if teardown() was invoked because we're clearing the cache as a result of
					// a change that the array itself triggered, we can save ourselves the teardown
					// and immediate setup
					if ( storage.setting ) {
						return false;
					}
					index = wrappers.indexOf( this );
					if ( index === -1 ) {
						throw new Error( errorMessage );
					}
					wrappers.splice( index, 1 );
					// if nothing else depends on this array, we can revert it to its
					// natural state
					if ( !wrappers.length ) {
						delete array._ractive;
						patch.unpatch( this.value );
					} else {
						// remove ractive instance if possible
						instances[ this.root._guid ] -= 1;
						if ( !instances[ this.root._guid ] ) {
							index = instances.indexOf( this.root );
							if ( index === -1 ) {
								throw new Error( errorMessage );
							}
							instances.splice( index, 1 );
						}
					}
				}
			};
			errorMessage = 'Something went wrong in a rather interesting way';
			return arrayAdaptor;
		}( defineProperty, isArray, viewmodel$get_arrayAdaptor_patch );

		/* viewmodel/prototype/get/magicArrayAdaptor.js */
		var viewmodel$get_magicArrayAdaptor = function( magicAdaptor, arrayAdaptor ) {

			var magicArrayAdaptor, MagicArrayWrapper;
			if ( magicAdaptor ) {
				magicArrayAdaptor = {
					filter: function( object, keypath, ractive ) {
						return magicAdaptor.filter( object, keypath, ractive ) && arrayAdaptor.filter( object );
					},
					wrap: function( ractive, array, keypath ) {
						return new MagicArrayWrapper( ractive, array, keypath );
					}
				};
				MagicArrayWrapper = function( ractive, array, keypath ) {
					this.value = array;
					this.magic = true;
					this.magicWrapper = magicAdaptor.wrap( ractive, array, keypath );
					this.arrayWrapper = arrayAdaptor.wrap( ractive, array, keypath );
				};
				MagicArrayWrapper.prototype = {
					get: function() {
						return this.value;
					},
					teardown: function() {
						this.arrayWrapper.teardown();
						this.magicWrapper.teardown();
					},
					reset: function( value ) {
						return this.magicWrapper.reset( value );
					}
				};
			}
			return magicArrayAdaptor;
		}( viewmodel$get_magicAdaptor, viewmodel$get_arrayAdaptor );

		/* viewmodel/prototype/adapt.js */
		var viewmodel$adapt = function( config, arrayAdaptor, log, magicAdaptor, magicArrayAdaptor ) {

			var __export;
			var prefixers = {};
			__export = function Viewmodel$adapt( keypath, value ) {
				var ractive = this.ractive,
					len, i, adaptor, wrapped;
				// Do we have an adaptor for this value?
				len = ractive.adapt.length;
				for ( i = 0; i < len; i += 1 ) {
					adaptor = ractive.adapt[ i ];
					// Adaptors can be specified as e.g. [ 'Backbone.Model', 'Backbone.Collection' ] -
					// we need to get the actual adaptor if that's the case
					if ( typeof adaptor === 'string' ) {
						var found = config.registries.adaptors.find( ractive, adaptor );
						if ( !found ) {
							// will throw. "return" for safety, if we downgrade :)
							return log.critical( {
								debug: ractive.debug,
								message: 'missingPlugin',
								args: {
									plugin: 'adaptor',
									name: adaptor
								}
							} );
						}
						adaptor = ractive.adapt[ i ] = found;
					}
					if ( adaptor.filter( value, keypath, ractive ) ) {
						wrapped = this.wrapped[ keypath ] = adaptor.wrap( ractive, value, keypath, getPrefixer( keypath ) );
						wrapped.value = value;
						return value;
					}
				}
				if ( ractive.magic ) {
					if ( magicArrayAdaptor.filter( value, keypath, ractive ) ) {
						this.wrapped[ keypath ] = magicArrayAdaptor.wrap( ractive, value, keypath );
					} else if ( magicAdaptor.filter( value, keypath, ractive ) ) {
						this.wrapped[ keypath ] = magicAdaptor.wrap( ractive, value, keypath );
					}
				} else if ( ractive.modifyArrays && arrayAdaptor.filter( value, keypath, ractive ) ) {
					this.wrapped[ keypath ] = arrayAdaptor.wrap( ractive, value, keypath );
				}
				return value;
			};

			function prefixKeypath( obj, prefix ) {
				var prefixed = {},
					key;
				if ( !prefix ) {
					return obj;
				}
				prefix += '.';
				for ( key in obj ) {
					if ( obj.hasOwnProperty( key ) ) {
						prefixed[ prefix + key ] = obj[ key ];
					}
				}
				return prefixed;
			}

			function getPrefixer( rootKeypath ) {
				var rootDot;
				if ( !prefixers[ rootKeypath ] ) {
					rootDot = rootKeypath ? rootKeypath + '.' : '';
					prefixers[ rootKeypath ] = function( relativeKeypath, value ) {
						var obj;
						if ( typeof relativeKeypath === 'string' ) {
							obj = {};
							obj[ rootDot + relativeKeypath ] = value;
							return obj;
						}
						if ( typeof relativeKeypath === 'object' ) {
							// 'relativeKeypath' is in fact a hash, not a keypath
							return rootDot ? prefixKeypath( relativeKeypath, rootKeypath ) : relativeKeypath;
						}
					};
				}
				return prefixers[ rootKeypath ];
			}
			return __export;
		}( config, viewmodel$get_arrayAdaptor, log, viewmodel$get_magicAdaptor, viewmodel$get_magicArrayAdaptor );

		/* viewmodel/helpers/getUpstreamChanges.js */
		var getUpstreamChanges = function getUpstreamChanges( changes ) {
			var upstreamChanges = [ '' ],
				i, keypath, keys, upstreamKeypath;
			i = changes.length;
			while ( i-- ) {
				keypath = changes[ i ];
				keys = keypath.split( '.' );
				while ( keys.length > 1 ) {
					keys.pop();
					upstreamKeypath = keys.join( '.' );
					if ( upstreamChanges.indexOf( upstreamKeypath ) === -1 ) {
						upstreamChanges.push( upstreamKeypath );
					}
				}
			}
			return upstreamChanges;
		};

		/* viewmodel/prototype/applyChanges/getPotentialWildcardMatches.js */
		var viewmodel$applyChanges_getPotentialWildcardMatches = function() {

			var __export;
			var starMaps = {};
			// This function takes a keypath such as 'foo.bar.baz', and returns
			// all the variants of that keypath that include a wildcard in place
			// of a key, such as 'foo.bar.*', 'foo.*.baz', 'foo.*.*' and so on.
			// These are then checked against the dependants map (ractive.viewmodel.depsMap)
			// to see if any pattern observers are downstream of one or more of
			// these wildcard keypaths (e.g. 'foo.bar.*.status')
			__export = function getPotentialWildcardMatches( keypath ) {
				var keys, starMap, mapper, result;
				keys = keypath.split( '.' );
				starMap = getStarMap( keys.length );
				mapper = function( star, i ) {
					return star ? '*' : keys[ i ];
				};
				result = starMap.map( function( mask ) {
					return mask.map( mapper ).join( '.' );
				} );
				return result;
			};
			// This function returns all the possible true/false combinations for
			// a given number - e.g. for two, the possible combinations are
			// [ true, true ], [ true, false ], [ false, true ], [ false, false ].
			// It does so by getting all the binary values between 0 and e.g. 11
			function getStarMap( length ) {
				var ones = '',
					max, binary, starMap, mapper, i;
				if ( !starMaps[ length ] ) {
					starMap = [];
					while ( ones.length < length ) {
						ones += 1;
					}
					max = parseInt( ones, 2 );
					mapper = function( digit ) {
						return digit === '1';
					};
					for ( i = 0; i <= max; i += 1 ) {
						binary = i.toString( 2 );
						while ( binary.length < length ) {
							binary = '0' + binary;
						}
						starMap[ i ] = Array.prototype.map.call( binary, mapper );
					}
					starMaps[ length ] = starMap;
				}
				return starMaps[ length ];
			}
			return __export;
		}();

		/* viewmodel/prototype/applyChanges/notifyPatternObservers.js */
		var viewmodel$applyChanges_notifyPatternObservers = function( getPotentialWildcardMatches ) {

			var __export;
			var lastKey = /[^\.]+$/;
			__export = notifyPatternObservers;

			function notifyPatternObservers( viewmodel, keypath, onlyDirect ) {
				var potentialWildcardMatches;
				updateMatchingPatternObservers( viewmodel, keypath );
				if ( onlyDirect ) {
					return;
				}
				potentialWildcardMatches = getPotentialWildcardMatches( keypath );
				potentialWildcardMatches.forEach( function( upstreamPattern ) {
					cascade( viewmodel, upstreamPattern, keypath );
				} );
			}

			function cascade( viewmodel, upstreamPattern, keypath ) {
				var group, map, actualChildKeypath;
				group = viewmodel.depsMap.patternObservers;
				map = group[ upstreamPattern ];
				if ( map ) {
					map.forEach( function( childKeypath ) {
						var key = lastKey.exec( childKeypath )[ 0 ];
						// 'baz'
						actualChildKeypath = keypath ? keypath + '.' + key : key;
						// 'foo.bar.baz'
						updateMatchingPatternObservers( viewmodel, actualChildKeypath );
						cascade( viewmodel, childKeypath, actualChildKeypath );
					} );
				}
			}

			function updateMatchingPatternObservers( viewmodel, keypath ) {
				viewmodel.patternObservers.forEach( function( observer ) {
					if ( observer.regex.test( keypath ) ) {
						observer.update( keypath );
					}
				} );
			}
			return __export;
		}( viewmodel$applyChanges_getPotentialWildcardMatches );

		/* viewmodel/prototype/applyChanges.js */
		var viewmodel$applyChanges = function( getUpstreamChanges, notifyPatternObservers ) {

			var __export;
			__export = function Viewmodel$applyChanges() {
				var this$0 = this;
				var self = this,
					changes, upstreamChanges, hash = {};
				changes = this.changes;
				if ( !changes.length ) {
					// TODO we end up here on initial render. Perhaps we shouldn't?
					return;
				}

				function cascade( keypath ) {
					var map, dependants, keys;
					if ( self.noCascade.hasOwnProperty( keypath ) ) {
						return;
					}
					if ( dependants = self.deps.computed[ keypath ] ) {
						dependants.forEach( invalidate );
						keys = dependants.map( getKey );
						keys.forEach( mark );
						keys.forEach( cascade );
					}
					if ( map = self.depsMap.computed[ keypath ] ) {
						map.forEach( cascade );
					}
				}

				function mark( keypath ) {
					self.mark( keypath );
				}
				changes.forEach( cascade );
				upstreamChanges = getUpstreamChanges( changes );
				upstreamChanges.forEach( function( keypath ) {
					var dependants, keys;
					if ( dependants = self.deps.computed[ keypath ] ) {
						dependants.forEach( invalidate );
						keys = dependants.map( getKey );
						keys.forEach( mark );
						keys.forEach( cascade );
					}
				} );
				this.changes = [];
				// Pattern observers are a weird special case
				if ( this.patternObservers.length ) {
					upstreamChanges.forEach( function( keypath ) {
						return notifyPatternObservers( this$0, keypath, true );
					} );
					changes.forEach( function( keypath ) {
						return notifyPatternObservers( this$0, keypath );
					} );
				}
				if ( this.deps.observers ) {
					upstreamChanges.forEach( function( keypath ) {
						return notifyUpstreamDependants( this$0, null, keypath, 'observers' );
					} );
					notifyAllDependants( this, changes, 'observers' );
				}
				if ( this.deps[ 'default' ] ) {
					var bindings = [];
					upstreamChanges.forEach( function( keypath ) {
						return notifyUpstreamDependants( this$0, bindings, keypath, 'default' );
					} );
					if ( bindings.length ) {
						notifyBindings( this, bindings, changes );
					}
					notifyAllDependants( this, changes, 'default' );
				}
				// Return a hash of keypaths to updated values
				changes.forEach( function( keypath ) {
					hash[ keypath ] = this$0.get( keypath );
				} );
				this.implicitChanges = {};
				this.noCascade = {};
				return hash;
			};

			function invalidate( computation ) {
				computation.invalidate();
			}

			function getKey( computation ) {
				return computation.key;
			}

			function notifyUpstreamDependants( viewmodel, bindings, keypath, groupName ) {
				var dependants, value;
				if ( dependants = findDependants( viewmodel, keypath, groupName ) ) {
					value = viewmodel.get( keypath );
					dependants.forEach( function( d ) {
						// don't "set" the parent value, refine it
						// i.e. not data = value, but data[foo] = fooValue
						if ( bindings && d.refineValue ) {
							bindings.push( d );
						} else {
							d.setValue( value );
						}
					} );
				}
			}

			function notifyBindings( viewmodel, bindings, changes ) {
				bindings.forEach( function( binding ) {
					var useSet = false,
						i = 0,
						length = changes.length,
						refinements = [];
					while ( i < length ) {
						var keypath = changes[ i ];
						if ( keypath === binding.keypath ) {
							useSet = true;
							break;
						}
						if ( keypath.slice( 0, binding.keypath.length ) === binding.keypath ) {
							refinements.push( keypath );
						}
						i++;
					}
					if ( useSet ) {
						binding.setValue( viewmodel.get( binding.keypath ) );
					}
					if ( refinements.length ) {
						binding.refineValue( refinements );
					}
				} );
			}

			function notifyAllDependants( viewmodel, keypaths, groupName ) {
				var queue = [];
				addKeypaths( keypaths );
				queue.forEach( dispatch );

				function addKeypaths( keypaths ) {
					keypaths.forEach( addKeypath );
					keypaths.forEach( cascade );
				}

				function addKeypath( keypath ) {
					var deps = findDependants( viewmodel, keypath, groupName );
					if ( deps ) {
						queue.push( {
							keypath: keypath,
							deps: deps
						} );
					}
				}

				function cascade( keypath ) {
					var childDeps;
					if ( childDeps = viewmodel.depsMap[ groupName ][ keypath ] ) {
						addKeypaths( childDeps );
					}
				}

				function dispatch( set ) {
					var value = viewmodel.get( set.keypath );
					set.deps.forEach( function( d ) {
						return d.setValue( value );
					} );
				}
			}

			function findDependants( viewmodel, keypath, groupName ) {
				var group = viewmodel.deps[ groupName ];
				return group ? group[ keypath ] : null;
			}
			return __export;
		}( getUpstreamChanges, viewmodel$applyChanges_notifyPatternObservers );

		/* viewmodel/prototype/capture.js */
		var viewmodel$capture = function Viewmodel$capture() {
			this.captureGroups.push( [] );
		};

		/* viewmodel/prototype/clearCache.js */
		var viewmodel$clearCache = function Viewmodel$clearCache( keypath, dontTeardownWrapper ) {
			var cacheMap, wrapper;
			if ( !dontTeardownWrapper ) {
				// Is there a wrapped property at this keypath?
				if ( wrapper = this.wrapped[ keypath ] ) {
					// Did we unwrap it?
					if ( wrapper.teardown() !== false ) {
						// Is this right?
						// What's the meaning of returning false from teardown?
						// Could there be a GC ramification if this is a "real" ractive.teardown()?
						this.wrapped[ keypath ] = null;
					}
				}
			}
			this.cache[ keypath ] = undefined;
			if ( cacheMap = this.cacheMap[ keypath ] ) {
				while ( cacheMap.length ) {
					this.clearCache( cacheMap.pop() );
				}
			}
		};

		/* viewmodel/Computation/getComputationSignature.js */
		var getComputationSignature = function() {

			var __export;
			var pattern = /\$\{([^\}]+)\}/g;
			__export = function( signature ) {
				if ( typeof signature === 'function' ) {
					return {
						get: signature
					};
				}
				if ( typeof signature === 'string' ) {
					return {
						get: createFunctionFromString( signature )
					};
				}
				if ( typeof signature === 'object' && typeof signature.get === 'string' ) {
					signature = {
						get: createFunctionFromString( signature.get ),
						set: signature.set
					};
				}
				return signature;
			};

			function createFunctionFromString( signature ) {
				var functionBody = 'var __ractive=this;return(' + signature.replace( pattern, function( match, keypath ) {
					return '__ractive.get("' + keypath + '")';
				} ) + ')';
				return new Function( functionBody );
			}
			return __export;
		}();

		/* viewmodel/Computation/Computation.js */
		var Computation = function( log, isEqual ) {

			var Computation = function( ractive, key, signature ) {
				var this$0 = this;
				this.ractive = ractive;
				this.viewmodel = ractive.viewmodel;
				this.key = key;
				this.getter = signature.get;
				this.setter = signature.set;
				this.hardDeps = signature.deps || [];
				this.softDeps = [];
				this.depValues = {};
				if ( this.hardDeps ) {
					this.hardDeps.forEach( function( d ) {
						return ractive.viewmodel.register( d, this$0, 'computed' );
					} );
				}
				this._dirty = this._firstRun = true;
			};
			Computation.prototype = {
				constructor: Computation,
				init: function() {
					var initial;
					this.bypass = true;
					initial = this.ractive.viewmodel.get( this.key );
					this.ractive.viewmodel.clearCache( this.key );
					this.bypass = false;
					if ( this.setter && initial !== undefined ) {
						this.set( initial );
					}
				},
				invalidate: function() {
					this._dirty = true;
				},
				get: function() {
					var this$0 = this;
					var ractive, newDeps, dependenciesChanged, dependencyValuesChanged = false;
					if ( this.getting ) {
						// prevent double-computation (e.g. caused by array mutation inside computation)
						return;
					}
					this.getting = true;
					if ( this._dirty ) {
						ractive = this.ractive;
						// determine whether the inputs have changed, in case this depends on
						// other computed values
						if ( this._firstRun || !this.hardDeps.length && !this.softDeps.length ) {
							dependencyValuesChanged = true;
						} else {
							[
								this.hardDeps,
								this.softDeps
							].forEach( function( deps ) {
								var keypath, value, i;
								if ( dependencyValuesChanged ) {
									return;
								}
								i = deps.length;
								while ( i-- ) {
									keypath = deps[ i ];
									value = ractive.viewmodel.get( keypath );
									if ( !isEqual( value, this$0.depValues[ keypath ] ) ) {
										this$0.depValues[ keypath ] = value;
										dependencyValuesChanged = true;
										return;
									}
								}
							} );
						}
						if ( dependencyValuesChanged ) {
							ractive.viewmodel.capture();
							try {
								this.value = this.getter.call( ractive );
							} catch ( err ) {
								log.warn( {
									debug: ractive.debug,
									message: 'failedComputation',
									args: {
										key: this.key,
										err: err.message || err
									}
								} );
								this.value = void 0;
							}
							newDeps = ractive.viewmodel.release();
							dependenciesChanged = this.updateDependencies( newDeps );
							if ( dependenciesChanged ) {
								[
									this.hardDeps,
									this.softDeps
								].forEach( function( deps ) {
									deps.forEach( function( keypath ) {
										this$0.depValues[ keypath ] = ractive.viewmodel.get( keypath );
									} );
								} );
							}
						}
						this._dirty = false;
					}
					this.getting = this._firstRun = false;
					return this.value;
				},
				set: function( value ) {
					if ( this.setting ) {
						this.value = value;
						return;
					}
					if ( !this.setter ) {
						throw new Error( 'Computed properties without setters are read-only. (This may change in a future version of Ractive!)' );
					}
					this.setter.call( this.ractive, value );
				},
				updateDependencies: function( newDeps ) {
					var i, oldDeps, keypath, dependenciesChanged;
					oldDeps = this.softDeps;
					// remove dependencies that are no longer used
					i = oldDeps.length;
					while ( i-- ) {
						keypath = oldDeps[ i ];
						if ( newDeps.indexOf( keypath ) === -1 ) {
							dependenciesChanged = true;
							this.viewmodel.unregister( keypath, this, 'computed' );
						}
					}
					// create references for any new dependencies
					i = newDeps.length;
					while ( i-- ) {
						keypath = newDeps[ i ];
						if ( oldDeps.indexOf( keypath ) === -1 && ( !this.hardDeps || this.hardDeps.indexOf( keypath ) === -1 ) ) {
							dependenciesChanged = true;
							this.viewmodel.register( keypath, this, 'computed' );
						}
					}
					if ( dependenciesChanged ) {
						this.softDeps = newDeps.slice();
					}
					return dependenciesChanged;
				}
			};
			return Computation;
		}( log, isEqual );

		/* viewmodel/prototype/compute.js */
		var viewmodel$compute = function( getComputationSignature, Computation ) {

			return function Viewmodel$compute( key, signature ) {
				signature = getComputationSignature( signature );
				return this.computations[ key ] = new Computation( this.ractive, key, signature );
			};
		}( getComputationSignature, Computation );

		/* viewmodel/prototype/get/FAILED_LOOKUP.js */
		var viewmodel$get_FAILED_LOOKUP = {
			FAILED_LOOKUP: true
		};

		/* viewmodel/prototype/get/UnresolvedImplicitDependency.js */
		var viewmodel$get_UnresolvedImplicitDependency = function( removeFromArray, runloop ) {

			var empty = {};
			var UnresolvedImplicitDependency = function( viewmodel, keypath ) {
				this.viewmodel = viewmodel;
				this.root = viewmodel.ractive;
				// TODO eliminate this
				this.ref = keypath;
				this.parentFragment = empty;
				viewmodel.unresolvedImplicitDependencies[ keypath ] = true;
				viewmodel.unresolvedImplicitDependencies.push( this );
				runloop.addUnresolved( this );
			};
			UnresolvedImplicitDependency.prototype = {
				resolve: function() {
					this.viewmodel.mark( this.ref );
					this.viewmodel.unresolvedImplicitDependencies[ this.ref ] = false;
					removeFromArray( this.viewmodel.unresolvedImplicitDependencies, this );
				},
				teardown: function() {
					runloop.removeUnresolved( this );
				}
			};
			return UnresolvedImplicitDependency;
		}( removeFromArray, runloop );

		/* viewmodel/prototype/get.js */
		var viewmodel$get = function( isNumeric, FAILED_LOOKUP, UnresolvedImplicitDependency ) {

			var __export;
			var empty = {};
			__export = function Viewmodel$get( keypath ) {
				var options = arguments[ 1 ];
				if ( options === void 0 )
					options = empty;
				var ractive = this.ractive,
					cache = this.cache,
					value, computation, wrapped, captureGroup;
				if ( keypath[ 0 ] === '@' ) {
					value = keypath.slice( 1 );
					return isNumeric( value ) ? +value : value;
				}
				if ( cache[ keypath ] === undefined ) {
					// Is this a computed property?
					if ( ( computation = this.computations[ keypath ] ) && !computation.bypass ) {
						value = computation.get();
						this.adapt( keypath, value );
					} else if ( wrapped = this.wrapped[ keypath ] ) {
						value = wrapped.value;
					} else if ( !keypath ) {
						this.adapt( '', ractive.data );
						value = ractive.data;
					} else {
						value = retrieve( this, keypath );
					}
					cache[ keypath ] = value;
				} else {
					value = cache[ keypath ];
				}
				if ( options.evaluateWrapped && ( wrapped = this.wrapped[ keypath ] ) ) {
					value = wrapped.get();
				}
				// capture the keypath, if we're inside a computation
				if ( options.capture && ( captureGroup = this.captureGroups[ this.captureGroups.length - 1 ] ) ) {
					if ( !~captureGroup.indexOf( keypath ) ) {
						captureGroup.push( keypath );
						// if we couldn't resolve the keypath, we need to make it as a failed
						// lookup, so that the computation updates correctly once we CAN
						// resolve the keypath
						if ( value === FAILED_LOOKUP && this.unresolvedImplicitDependencies[ keypath ] !== true ) {
							new UnresolvedImplicitDependency( this, keypath );
						}
					}
				}
				return value === FAILED_LOOKUP ? void 0 : value;
			};

			function retrieve( viewmodel, keypath ) {
				var keys, key, parentKeypath, parentValue, cacheMap, value, wrapped;
				keys = keypath.split( '.' );
				key = keys.pop();
				parentKeypath = keys.join( '.' );
				parentValue = viewmodel.get( parentKeypath );
				if ( wrapped = viewmodel.wrapped[ parentKeypath ] ) {
					parentValue = wrapped.get();
				}
				if ( parentValue === null || parentValue === undefined ) {
					return;
				}
				// update cache map
				if ( !( cacheMap = viewmodel.cacheMap[ parentKeypath ] ) ) {
					viewmodel.cacheMap[ parentKeypath ] = [ keypath ];
				} else {
					if ( cacheMap.indexOf( keypath ) === -1 ) {
						cacheMap.push( keypath );
					}
				}
				// If this property doesn't exist, we return a sentinel value
				// so that we know to query parent scope (if such there be)
				if ( typeof parentValue === 'object' && !( key in parentValue ) ) {
					return viewmodel.cache[ keypath ] = FAILED_LOOKUP;
				}
				value = parentValue[ key ];
				// Do we have an adaptor for this value?
				viewmodel.adapt( keypath, value, false );
				// Update cache
				viewmodel.cache[ keypath ] = value;
				return value;
			}
			return __export;
		}( isNumeric, viewmodel$get_FAILED_LOOKUP, viewmodel$get_UnresolvedImplicitDependency );

		/* viewmodel/prototype/init.js */
		var viewmodel$init = function() {

			var __export;
			__export = function Viewmodel$init() {
				var key, computation, computations = [];
				for ( key in this.ractive.computed ) {
					computation = this.compute( key, this.ractive.computed[ key ] );
					computations.push( computation );
				}
				computations.forEach( init );
			};

			function init( computation ) {
				computation.init();
			}
			return __export;
		}();

		/* viewmodel/prototype/mark.js */
		var viewmodel$mark = function Viewmodel$mark( keypath, options ) {
			var computation;
			// implicit changes (i.e. `foo.length` on `ractive.push('foo',42)`)
			// should not be picked up by pattern observers
			if ( options ) {
				if ( options.implicit ) {
					this.implicitChanges[ keypath ] = true;
				}
				if ( options.noCascade ) {
					this.noCascade[ keypath ] = true;
				}
			}
			if ( computation = this.computations[ keypath ] ) {
				computation.invalidate();
			}
			if ( this.changes.indexOf( keypath ) === -1 ) {
				this.changes.push( keypath );
			}
			this.clearCache( keypath );
		};

		/* viewmodel/prototype/merge/mapOldToNewIndex.js */
		var viewmodel$merge_mapOldToNewIndex = function( oldArray, newArray ) {
			var usedIndices, firstUnusedIndex, newIndices, changed;
			usedIndices = {};
			firstUnusedIndex = 0;
			newIndices = oldArray.map( function( item, i ) {
				var index, start, len;
				start = firstUnusedIndex;
				len = newArray.length;
				do {
					index = newArray.indexOf( item, start );
					if ( index === -1 ) {
						changed = true;
						return -1;
					}
					start = index + 1;
				} while ( usedIndices[ index ] && start < len );
				// keep track of the first unused index, so we don't search
				// the whole of newArray for each item in oldArray unnecessarily
				if ( index === firstUnusedIndex ) {
					firstUnusedIndex += 1;
				}
				if ( index !== i ) {
					changed = true;
				}
				usedIndices[ index ] = true;
				return index;
			} );
			return newIndices;
		};

		/* viewmodel/prototype/merge.js */
		var viewmodel$merge = function( warn, mapOldToNewIndex ) {

			var __export;
			var comparators = {};
			__export = function Viewmodel$merge( keypath, currentArray, array, options ) {
				var oldArray, newArray, comparator, newIndices;
				this.mark( keypath );
				if ( options && options.compare ) {
					comparator = getComparatorFunction( options.compare );
					try {
						oldArray = currentArray.map( comparator );
						newArray = array.map( comparator );
					} catch ( err ) {
						// fallback to an identity check - worst case scenario we have
						// to do more DOM manipulation than we thought...
						// ...unless we're in debug mode of course
						if ( this.debug ) {
							throw err;
						} else {
							warn( 'Merge operation: comparison failed. Falling back to identity checking' );
						}
						oldArray = currentArray;
						newArray = array;
					}
				} else {
					oldArray = currentArray;
					newArray = array;
				}
				// find new indices for members of oldArray
				newIndices = mapOldToNewIndex( oldArray, newArray );
				this.smartUpdate( keypath, array, newIndices, currentArray.length !== array.length );
			};

			function stringify( item ) {
				return JSON.stringify( item );
			}

			function getComparatorFunction( comparator ) {
				// If `compare` is `true`, we use JSON.stringify to compare
				// objects that are the same shape, but non-identical - i.e.
				// { foo: 'bar' } !== { foo: 'bar' }
				if ( comparator === true ) {
					return stringify;
				}
				if ( typeof comparator === 'string' ) {
					if ( !comparators[ comparator ] ) {
						comparators[ comparator ] = function( item ) {
							return item[ comparator ];
						};
					}
					return comparators[ comparator ];
				}
				if ( typeof comparator === 'function' ) {
					return comparator;
				}
				throw new Error( 'The `compare` option must be a function, or a string representing an identifying field (or `true` to use JSON.stringify)' );
			}
			return __export;
		}( warn, viewmodel$merge_mapOldToNewIndex );

		/* viewmodel/prototype/register.js */
		var viewmodel$register = function() {

			var __export;
			__export = function Viewmodel$register( keypath, dependant ) {
				var group = arguments[ 2 ];
				if ( group === void 0 )
					group = 'default';
				var depsByKeypath, deps;
				if ( dependant.isStatic ) {
					return;
				}
				depsByKeypath = this.deps[ group ] || ( this.deps[ group ] = {} );
				deps = depsByKeypath[ keypath ] || ( depsByKeypath[ keypath ] = [] );
				deps.push( dependant );
				if ( !keypath ) {
					return;
				}
				updateDependantsMap( this, keypath, group );
			};

			function updateDependantsMap( viewmodel, keypath, group ) {
				var keys, parentKeypath, map, parent;
				// update dependants map
				keys = keypath.split( '.' );
				while ( keys.length ) {
					keys.pop();
					parentKeypath = keys.join( '.' );
					map = viewmodel.depsMap[ group ] || ( viewmodel.depsMap[ group ] = {} );
					parent = map[ parentKeypath ] || ( map[ parentKeypath ] = [] );
					if ( parent[ keypath ] === undefined ) {
						parent[ keypath ] = 0;
						parent.push( keypath );
					}
					parent[ keypath ] += 1;
					keypath = parentKeypath;
				}
			}
			return __export;
		}();

		/* viewmodel/prototype/release.js */
		var viewmodel$release = function Viewmodel$release() {
			return this.captureGroups.pop();
		};

		/* viewmodel/prototype/set.js */
		var viewmodel$set = function( isEqual, createBranch ) {

			var __export;
			__export = function Viewmodel$set( keypath, value, silent ) {
				var computation, wrapper, dontTeardownWrapper;
				computation = this.computations[ keypath ];
				if ( computation ) {
					if ( computation.setting ) {
						// let the other computation set() handle things...
						return;
					}
					computation.set( value );
					value = computation.get();
				}
				if ( isEqual( this.cache[ keypath ], value ) ) {
					return;
				}
				wrapper = this.wrapped[ keypath ];
				// If we have a wrapper with a `reset()` method, we try and use it. If the
				// `reset()` method returns false, the wrapper should be torn down, and
				// (most likely) a new one should be created later
				if ( wrapper && wrapper.reset ) {
					dontTeardownWrapper = wrapper.reset( value ) !== false;
					if ( dontTeardownWrapper ) {
						value = wrapper.get();
					}
				}
				if ( !computation && !dontTeardownWrapper ) {
					resolveSet( this, keypath, value );
				}
				if ( !silent ) {
					this.mark( keypath );
				} else {
					// We're setting a parent of the original target keypath (i.e.
					// creating a fresh branch) - we need to clear the cache, but
					// not mark it as a change
					this.clearCache( keypath );
				}
			};

			function resolveSet( viewmodel, keypath, value ) {
				var keys, lastKey, parentKeypath, wrapper, parentValue, wrapperSet, valueSet;
				wrapperSet = function() {
					if ( wrapper.set ) {
						wrapper.set( lastKey, value );
					} else {
						parentValue = wrapper.get();
						valueSet();
					}
				};
				valueSet = function() {
					if ( !parentValue ) {
						parentValue = createBranch( lastKey );
						viewmodel.set( parentKeypath, parentValue, true );
					}
					parentValue[ lastKey ] = value;
				};
				keys = keypath.split( '.' );
				lastKey = keys.pop();
				parentKeypath = keys.join( '.' );
				wrapper = viewmodel.wrapped[ parentKeypath ];
				if ( wrapper ) {
					wrapperSet();
				} else {
					parentValue = viewmodel.get( parentKeypath );
					// may have been wrapped via the above .get()
					// call on viewmodel if this is first access via .set()!
					if ( wrapper = viewmodel.wrapped[ parentKeypath ] ) {
						wrapperSet();
					} else {
						valueSet();
					}
				}
			}
			return __export;
		}( isEqual, createBranch );

		/* viewmodel/prototype/smartUpdate.js */
		var viewmodel$smartUpdate = function() {

			var __export;
			var implicitOption = {
					implicit: true
				},
				noCascadeOption = {
					noCascade: true
				};
			__export = function Viewmodel$smartUpdate( keypath, array, newIndices ) {
				var this$0 = this;
				var dependants, oldLength;
				oldLength = newIndices.length;
				// Indices that are being removed should be marked as dirty
				newIndices.forEach( function( newIndex, oldIndex ) {
					if ( newIndex === -1 ) {
						this$0.mark( keypath + '.' + oldIndex, noCascadeOption );
					}
				} );
				// Update the model
				// TODO allow existing array to be updated in place, rather than replaced?
				this.set( keypath, array, true );
				if ( dependants = this.deps[ 'default' ][ keypath ] ) {
					dependants.filter( canShuffle ).forEach( function( d ) {
						return d.shuffle( newIndices, array );
					} );
				}
				if ( oldLength !== array.length ) {
					this.mark( keypath + '.length', implicitOption );
					for ( var i = oldLength; i < array.length; i += 1 ) {
						this.mark( keypath + '.' + i );
					}
					// don't allow removed indexes beyond end of new array to trigger recomputations
					for ( var i$0 = array.length; i$0 < oldLength; i$0 += 1 ) {
						this.mark( keypath + '.' + i$0, noCascadeOption );
					}
				}
			};

			function canShuffle( dependant ) {
				return typeof dependant.shuffle === 'function';
			}
			return __export;
		}();

		/* viewmodel/prototype/teardown.js */
		var viewmodel$teardown = function Viewmodel$teardown() {
			var this$0 = this;
			var unresolvedImplicitDependency;
			// Clear entire cache - this has the desired side-effect
			// of unwrapping adapted values (e.g. arrays)
			Object.keys( this.cache ).forEach( function( keypath ) {
				return this$0.clearCache( keypath );
			} );
			// Teardown any failed lookups - we don't need them to resolve any more
			while ( unresolvedImplicitDependency = this.unresolvedImplicitDependencies.pop() ) {
				unresolvedImplicitDependency.teardown();
			}
		};

		/* viewmodel/prototype/unregister.js */
		var viewmodel$unregister = function() {

			var __export;
			__export = function Viewmodel$unregister( keypath, dependant ) {
				var group = arguments[ 2 ];
				if ( group === void 0 )
					group = 'default';
				var deps, index;
				if ( dependant.isStatic ) {
					return;
				}
				deps = this.deps[ group ][ keypath ];
				index = deps.indexOf( dependant );
				if ( index === -1 ) {
					throw new Error( 'Attempted to remove a dependant that was no longer registered! This should not happen. If you are seeing this bug in development please raise an issue at https://github.com/RactiveJS/Ractive/issues - thanks' );
				}
				deps.splice( index, 1 );
				if ( !keypath ) {
					return;
				}
				updateDependantsMap( this, keypath, group );
			};

			function updateDependantsMap( viewmodel, keypath, group ) {
				var keys, parentKeypath, map, parent;
				// update dependants map
				keys = keypath.split( '.' );
				while ( keys.length ) {
					keys.pop();
					parentKeypath = keys.join( '.' );
					map = viewmodel.depsMap[ group ];
					parent = map[ parentKeypath ];
					parent[ keypath ] -= 1;
					if ( !parent[ keypath ] ) {
						// remove from parent deps map
						parent.splice( parent.indexOf( keypath ), 1 );
						parent[ keypath ] = undefined;
					}
					keypath = parentKeypath;
				}
			}
			return __export;
		}();

		/* viewmodel/adaptConfig.js */
		var adaptConfig = function() {

			// should this be combined with prototype/adapt.js?
			var configure = {
				lookup: function( target, adaptors ) {
					var i, adapt = target.adapt;
					if ( !adapt || !adapt.length ) {
						return adapt;
					}
					if ( adaptors && Object.keys( adaptors ).length && ( i = adapt.length ) ) {
						while ( i-- ) {
							var adaptor = adapt[ i ];
							if ( typeof adaptor === 'string' ) {
								adapt[ i ] = adaptors[ adaptor ] || adaptor;
							}
						}
					}
					return adapt;
				},
				combine: function( parent, adapt ) {
					// normalize 'Foo' to [ 'Foo' ]
					parent = arrayIfString( parent );
					adapt = arrayIfString( adapt );
					// no parent? return adapt
					if ( !parent || !parent.length ) {
						return adapt;
					}
					// no adapt? return 'copy' of parent
					if ( !adapt || !adapt.length ) {
						return parent.slice();
					}
					// add parent adaptors to options
					parent.forEach( function( a ) {
						// don't put in duplicates
						if ( adapt.indexOf( a ) === -1 ) {
							adapt.push( a );
						}
					} );
					return adapt;
				}
			};

			function arrayIfString( adapt ) {
				if ( typeof adapt === 'string' ) {
					adapt = [ adapt ];
				}
				return adapt;
			}
			return configure;
		}();

		/* viewmodel/Viewmodel.js */
		var Viewmodel = function( create, adapt, applyChanges, capture, clearCache, compute, get, init, mark, merge, register, release, set, smartUpdate, teardown, unregister, adaptConfig ) {

			var noMagic;
			try {
				Object.defineProperty( {}, 'test', {
					value: 0
				} );
			} catch ( err ) {
				noMagic = true;
			}
			var Viewmodel = function( ractive ) {
				this.ractive = ractive;
				// TODO eventually, we shouldn't need this reference
				Viewmodel.extend( ractive.constructor, ractive );
				this.cache = {};
				// we need to be able to use hasOwnProperty, so can't inherit from null
				this.cacheMap = create( null );
				this.deps = {
					computed: {},
					'default': {}
				};
				this.depsMap = {
					computed: {},
					'default': {}
				};
				this.patternObservers = [];
				this.wrapped = create( null );
				this.computations = create( null );
				this.captureGroups = [];
				this.unresolvedImplicitDependencies = [];
				this.changes = [];
				this.implicitChanges = {};
				this.noCascade = {};
			};
			Viewmodel.extend = function( Parent, instance ) {
				if ( instance.magic && noMagic ) {
					throw new Error( 'Getters and setters (magic mode) are not supported in this browser' );
				}
				instance.adapt = adaptConfig.combine( Parent.prototype.adapt, instance.adapt ) || [];
				instance.adapt = adaptConfig.lookup( instance, instance.adaptors );
			};
			Viewmodel.prototype = {
				adapt: adapt,
				applyChanges: applyChanges,
				capture: capture,
				clearCache: clearCache,
				compute: compute,
				get: get,
				init: init,
				mark: mark,
				merge: merge,
				register: register,
				release: release,
				set: set,
				smartUpdate: smartUpdate,
				teardown: teardown,
				unregister: unregister
			};
			return Viewmodel;
		}( create, viewmodel$adapt, viewmodel$applyChanges, viewmodel$capture, viewmodel$clearCache, viewmodel$compute, viewmodel$get, viewmodel$init, viewmodel$mark, viewmodel$merge, viewmodel$register, viewmodel$release, viewmodel$set, viewmodel$smartUpdate, viewmodel$teardown, viewmodel$unregister, adaptConfig );

		/* Ractive/initialise.js */
		var Ractive_initialise = function( config, create, Fragment, getElement, getNextNumber, Hook, HookQueue, Viewmodel ) {

			var __export;
			var constructHook = new Hook( 'construct' ),
				configHook = new Hook( 'config' ),
				initHook = new HookQueue( 'init' );
			__export = function initialiseRactiveInstance( ractive ) {
				var options = arguments[ 1 ];
				if ( options === void 0 )
					options = {};
				var el;
				initialiseProperties( ractive, options );
				// make this option do what would be expected if someone
				// did include it on a new Ractive() or new Component() call.
				// Silly to do so (put a hook on the very options being used),
				// but handle it correctly, consistent with the intent.
				constructHook.fire( config.getConstructTarget( ractive, options ), options );
				// init config from Parent and options
				config.init( ractive.constructor, ractive, options );
				configHook.fire( ractive );
				// Teardown any existing instances *before* trying to set up the new one -
				// avoids certain weird bugs
				if ( el = getElement( ractive.el ) ) {
					if ( !ractive.append ) {
						if ( el.__ractive_instances__ ) {
							try {
								el.__ractive_instances__.splice( 0, el.__ractive_instances__.length ).forEach( function( r ) {
									return r.teardown();
								} );
							} catch ( err ) {}
						}
						el.innerHTML = '';
					}
				}
				initHook.begin( ractive );
				// TEMPORARY. This is so we can implement Viewmodel gradually
				ractive.viewmodel = new Viewmodel( ractive );
				// hacky circular problem until we get this sorted out
				// if viewmodel immediately processes computed properties,
				// they may call ractive.get, which calls ractive.viewmodel,
				// which hasn't been set till line above finishes.
				ractive.viewmodel.init();
				// Render our *root fragment*
				if ( ractive.template ) {
					ractive.fragment = new Fragment( {
						template: ractive.template,
						root: ractive,
						owner: ractive
					} );
				}
				initHook.end( ractive );
				// render automatically ( if `el` is specified )
				if ( el ) {
					ractive.render( el, ractive.append );
				}
			};

			function initialiseProperties( ractive, options ) {
				// Generate a unique identifier, for places where you'd use a weak map if it
				// existed
				ractive._guid = getNextNumber();
				// events
				ractive._subs = create( null );
				// storage for item configuration from instantiation to reset,
				// like dynamic functions or original values
				ractive._config = {};
				// two-way bindings
				ractive._twowayBindings = create( null );
				// animations (so we can stop any in progress at teardown)
				ractive._animations = [];
				// nodes registry
				ractive.nodes = {};
				// live queries
				ractive._liveQueries = [];
				ractive._liveComponentQueries = [];
				// If this is a component, store a reference to the parent
				if ( options._parent && options._component ) {
					ractive._parent = options._parent;
					ractive.component = options._component;
					// And store a reference to the instance on the component
					options._component.instance = ractive;
				}
			}
			return __export;
		}( config, create, Fragment, getElement, getNextNumber, Ractive$shared_hooks_Hook, Ractive$shared_hooks_HookQueue, Viewmodel );

		/* extend/unwrapExtended.js */
		var unwrapExtended = function( wrap, config, circular ) {

			var __export;
			var Ractive;
			circular.push( function() {
				Ractive = circular.Ractive;
			} );
			__export = function unwrapExtended( Child ) {
				if ( !( Child.prototype instanceof Ractive ) ) {
					return Child;
				}
				var options = {};
				while ( Child ) {
					config.registries.forEach( function( r ) {
						addRegistry( r.useDefaults ? Child.prototype : Child, options, r.name );
					} );
					Object.keys( Child.prototype ).forEach( function( key ) {
						if ( key === 'computed' ) {
							return;
						}
						var value = Child.prototype[ key ];
						if ( !( key in options ) ) {
							options[ key ] = value._method ? value._method : value;
						} else if ( typeof options[ key ] === 'function' && typeof value === 'function' && options[ key ]._method ) {
							var result, needsSuper = value._method;
							if ( needsSuper ) {
								value = value._method;
							}
							// rewrap bound directly to parent fn
							result = wrap( options[ key ]._method, value );
							if ( needsSuper ) {
								result._method = result;
							}
							options[ key ] = result;
						}
					} );
					if ( Child._parent !== Ractive ) {
						Child = Child._parent;
					} else {
						Child = false;
					}
				}
				return options;
			};

			function addRegistry( target, options, name ) {
				var registry, keys = Object.keys( target[ name ] );
				if ( !keys.length ) {
					return;
				}
				if ( !( registry = options[ name ] ) ) {
					registry = options[ name ] = {};
				}
				keys.filter( function( key ) {
					return !( key in registry );
				} ).forEach( function( key ) {
					return registry[ key ] = target[ name ][ key ];
				} );
			}
			return __export;
		}( wrapMethod, config, circular );

		/* extend/_extend.js */
		var Ractive_extend = function( create, defineProperties, getGuid, config, initialise, Viewmodel, unwrap ) {

			return function extend() {
				var options = arguments[ 0 ];
				if ( options === void 0 )
					options = {};
				var Parent = this,
					Child, proto, staticProperties;
				// if we're extending with another Ractive instance, inherit its
				// prototype methods and default options as well
				options = unwrap( options );
				// create Child constructor
				Child = function( options ) {
					initialise( this, options );
				};
				proto = create( Parent.prototype );
				proto.constructor = Child;
				staticProperties = {
					// each component needs a guid, for managing CSS etc
					_guid: {
						value: getGuid()
					},
					// alias prototype as defaults
					defaults: {
						value: proto
					},
					// extendable
					extend: {
						value: extend,
						writable: true,
						configurable: true
					},
					// Parent - for IE8, can't use Object.getPrototypeOf
					_parent: {
						value: Parent
					}
				};
				defineProperties( Child, staticProperties );
				// extend configuration
				config.extend( Parent, proto, options );
				Viewmodel.extend( Parent, proto );
				Child.prototype = proto;
				return Child;
			};
		}( create, defineProperties, getGuid, config, Ractive_initialise, Viewmodel, unwrapExtended );

		/* Ractive.js */
		var Ractive = function( defaults, easing, interpolators, svg, magic, defineProperties, proto, Promise, extendObj, extend, parse, initialise, circular ) {

			var Ractive, properties;
			// Main Ractive required object
			Ractive = function( options ) {
				initialise( this, options );
			};
			// Ractive properties
			properties = {
				// static methods:
				extend: {
					value: extend
				},
				parse: {
					value: parse
				},
				// Namespaced constructors
				Promise: {
					value: Promise
				},
				// support
				svg: {
					value: svg
				},
				magic: {
					value: magic
				},
				// version
				VERSION: {
					value: '0.6.1'
				},
				// Plugins
				adaptors: {
					writable: true,
					value: {}
				},
				components: {
					writable: true,
					value: {}
				},
				decorators: {
					writable: true,
					value: {}
				},
				easing: {
					writable: true,
					value: easing
				},
				events: {
					writable: true,
					value: {}
				},
				interpolators: {
					writable: true,
					value: interpolators
				},
				partials: {
					writable: true,
					value: {}
				},
				transitions: {
					writable: true,
					value: {}
				}
			};
			// Ractive properties
			defineProperties( Ractive, properties );
			Ractive.prototype = extendObj( proto, defaults );
			Ractive.prototype.constructor = Ractive;
			// alias prototype as defaults
			Ractive.defaults = Ractive.prototype;
			// Certain modules have circular dependencies. If we were bundling a
			// module loader, e.g. almond.js, this wouldn't be a problem, but we're
			// not - we're using amdclean as part of the build process. Because of
			// this, we need to wait until all modules have loaded before those
			// circular dependencies can be required.
			circular.Ractive = Ractive;
			while ( circular.length ) {
				circular.pop()();
			}
			// Ractive.js makes liberal use of things like Array.prototype.indexOf. In
			// older browsers, these are made available via a shim - here, we do a quick
			// pre-flight check to make sure that either a) we're not in a shit browser,
			// or b) we're using a Ractive-legacy.js build
			var FUNCTION = 'function';
			if ( typeof Date.now !== FUNCTION || typeof String.prototype.trim !== FUNCTION || typeof Object.keys !== FUNCTION || typeof Array.prototype.indexOf !== FUNCTION || typeof Array.prototype.forEach !== FUNCTION || typeof Array.prototype.map !== FUNCTION || typeof Array.prototype.filter !== FUNCTION || typeof window !== 'undefined' && typeof window.addEventListener !== FUNCTION ) {
				throw new Error( 'It looks like you\'re attempting to use Ractive.js in an older browser. You\'ll need to use one of the \'legacy builds\' in order to continue - see http://docs.ractivejs.org/latest/legacy-builds for more information.' );
			}
			return Ractive;
		}( options, easing, interpolators, svg, magic, defineProperties, prototype, Promise, extend, Ractive_extend, parse, Ractive_initialise, circular );


		// export as Common JS module...
		if ( typeof module !== "undefined" && module.exports ) {
			module.exports = Ractive;
		}

		// ... or as AMD module
		else if ( true ) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return Ractive;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}

		// ... or as browser global
		global.Ractive = Ractive;

		Ractive.noConflict = function() {
			global.Ractive = noConflict;
			return Ractive;
		};

	}( typeof window !== 'undefined' ? window : this ) );


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/**
	 * @license
	 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
	 * Build: `lodash -o ./dist/lodash.compat.js`
	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <http://lodash.com/license>
	 */
	;(function() {

	  /** Used as a safe reference for `undefined` in pre ES5 environments */
	  var undefined;

	  /** Used to pool arrays and objects used internally */
	  var arrayPool = [],
	      objectPool = [];

	  /** Used to generate unique IDs */
	  var idCounter = 0;

	  /** Used internally to indicate various things */
	  var indicatorObject = {};

	  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
	  var keyPrefix = +new Date + '';

	  /** Used as the size when optimizations are enabled for large arrays */
	  var largeArraySize = 75;

	  /** Used as the max size of the `arrayPool` and `objectPool` */
	  var maxPoolSize = 40;

	  /** Used to detect and test whitespace */
	  var whitespace = (
	    // whitespace
	    ' \t\x0B\f\xA0\ufeff' +

	    // line terminators
	    '\n\r\u2028\u2029' +

	    // unicode category "Zs" space separators
	    '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
	  );

	  /** Used to match empty string literals in compiled template source */
	  var reEmptyStringLeading = /\b__p \+= '';/g,
	      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
	      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

	  /**
	   * Used to match ES6 template delimiters
	   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals
	   */
	  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

	  /** Used to match regexp flags from their coerced string values */
	  var reFlags = /\w*$/;

	  /** Used to detected named functions */
	  var reFuncName = /^\s*function[ \n\r\t]+\w/;

	  /** Used to match "interpolate" template delimiters */
	  var reInterpolate = /<%=([\s\S]+?)%>/g;

	  /** Used to match leading whitespace and zeros to be removed */
	  var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');

	  /** Used to ensure capturing order of template delimiters */
	  var reNoMatch = /($^)/;

	  /** Used to detect functions containing a `this` reference */
	  var reThis = /\bthis\b/;

	  /** Used to match unescaped characters in compiled string literals */
	  var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;

	  /** Used to assign default `context` object properties */
	  var contextProps = [
	    'Array', 'Boolean', 'Date', 'Error', 'Function', 'Math', 'Number', 'Object',
	    'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',
	    'parseInt', 'setTimeout'
	  ];

	  /** Used to fix the JScript [[DontEnum]] bug */
	  var shadowedProps = [
	    'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',
	    'toLocaleString', 'toString', 'valueOf'
	  ];

	  /** Used to make template sourceURLs easier to identify */
	  var templateCounter = 0;

	  /** `Object#toString` result shortcuts */
	  var argsClass = '[object Arguments]',
	      arrayClass = '[object Array]',
	      boolClass = '[object Boolean]',
	      dateClass = '[object Date]',
	      errorClass = '[object Error]',
	      funcClass = '[object Function]',
	      numberClass = '[object Number]',
	      objectClass = '[object Object]',
	      regexpClass = '[object RegExp]',
	      stringClass = '[object String]';

	  /** Used to identify object classifications that `_.clone` supports */
	  var cloneableClasses = {};
	  cloneableClasses[funcClass] = false;
	  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
	  cloneableClasses[boolClass] = cloneableClasses[dateClass] =
	  cloneableClasses[numberClass] = cloneableClasses[objectClass] =
	  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;

	  /** Used as an internal `_.debounce` options object */
	  var debounceOptions = {
	    'leading': false,
	    'maxWait': 0,
	    'trailing': false
	  };

	  /** Used as the property descriptor for `__bindData__` */
	  var descriptor = {
	    'configurable': false,
	    'enumerable': false,
	    'value': null,
	    'writable': false
	  };

	  /** Used as the data object for `iteratorTemplate` */
	  var iteratorData = {
	    'args': '',
	    'array': null,
	    'bottom': '',
	    'firstArg': '',
	    'init': '',
	    'keys': null,
	    'loop': '',
	    'shadowedProps': null,
	    'support': null,
	    'top': '',
	    'useHas': false
	  };

	  /** Used to determine if values are of the language type Object */
	  var objectTypes = {
	    'boolean': false,
	    'function': true,
	    'object': true,
	    'number': false,
	    'string': false,
	    'undefined': false
	  };

	  /** Used to escape characters for inclusion in compiled string literals */
	  var stringEscapes = {
	    '\\': '\\',
	    "'": "'",
	    '\n': 'n',
	    '\r': 'r',
	    '\t': 't',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  /** Used as a reference to the global object */
	  var root = (objectTypes[typeof window] && window) || this;

	  /** Detect free variable `exports` */
	  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

	  /** Detect free variable `module` */
	  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

	  /** Detect the popular CommonJS extension `module.exports` */
	  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

	  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
	  var freeGlobal = objectTypes[typeof global] && global;
	  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
	    root = freeGlobal;
	  }

	  /*--------------------------------------------------------------------------*/

	  /**
	   * The base implementation of `_.indexOf` without support for binary searches
	   * or `fromIndex` constraints.
	   *
	   * @private
	   * @param {Array} array The array to search.
	   * @param {*} value The value to search for.
	   * @param {number} [fromIndex=0] The index to search from.
	   * @returns {number} Returns the index of the matched value or `-1`.
	   */
	  function baseIndexOf(array, value, fromIndex) {
	    var index = (fromIndex || 0) - 1,
	        length = array ? array.length : 0;

	    while (++index < length) {
	      if (array[index] === value) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * An implementation of `_.contains` for cache objects that mimics the return
	   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
	   *
	   * @private
	   * @param {Object} cache The cache object to inspect.
	   * @param {*} value The value to search for.
	   * @returns {number} Returns `0` if `value` is found, else `-1`.
	   */
	  function cacheIndexOf(cache, value) {
	    var type = typeof value;
	    cache = cache.cache;

	    if (type == 'boolean' || value == null) {
	      return cache[value] ? 0 : -1;
	    }
	    if (type != 'number' && type != 'string') {
	      type = 'object';
	    }
	    var key = type == 'number' ? value : keyPrefix + value;
	    cache = (cache = cache[type]) && cache[key];

	    return type == 'object'
	      ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)
	      : (cache ? 0 : -1);
	  }

	  /**
	   * Adds a given value to the corresponding cache object.
	   *
	   * @private
	   * @param {*} value The value to add to the cache.
	   */
	  function cachePush(value) {
	    var cache = this.cache,
	        type = typeof value;

	    if (type == 'boolean' || value == null) {
	      cache[value] = true;
	    } else {
	      if (type != 'number' && type != 'string') {
	        type = 'object';
	      }
	      var key = type == 'number' ? value : keyPrefix + value,
	          typeCache = cache[type] || (cache[type] = {});

	      if (type == 'object') {
	        (typeCache[key] || (typeCache[key] = [])).push(value);
	      } else {
	        typeCache[key] = true;
	      }
	    }
	  }

	  /**
	   * Used by `_.max` and `_.min` as the default callback when a given
	   * collection is a string value.
	   *
	   * @private
	   * @param {string} value The character to inspect.
	   * @returns {number} Returns the code unit of given character.
	   */
	  function charAtCallback(value) {
	    return value.charCodeAt(0);
	  }

	  /**
	   * Used by `sortBy` to compare transformed `collection` elements, stable sorting
	   * them in ascending order.
	   *
	   * @private
	   * @param {Object} a The object to compare to `b`.
	   * @param {Object} b The object to compare to `a`.
	   * @returns {number} Returns the sort order indicator of `1` or `-1`.
	   */
	  function compareAscending(a, b) {
	    var ac = a.criteria,
	        bc = b.criteria,
	        index = -1,
	        length = ac.length;

	    while (++index < length) {
	      var value = ac[index],
	          other = bc[index];

	      if (value !== other) {
	        if (value > other || typeof value == 'undefined') {
	          return 1;
	        }
	        if (value < other || typeof other == 'undefined') {
	          return -1;
	        }
	      }
	    }
	    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
	    // that causes it, under certain circumstances, to return the same value for
	    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
	    //
	    // This also ensures a stable sort in V8 and other engines.
	    // See http://code.google.com/p/v8/issues/detail?id=90
	    return a.index - b.index;
	  }

	  /**
	   * Creates a cache object to optimize linear searches of large arrays.
	   *
	   * @private
	   * @param {Array} [array=[]] The array to search.
	   * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
	   */
	  function createCache(array) {
	    var index = -1,
	        length = array.length,
	        first = array[0],
	        mid = array[(length / 2) | 0],
	        last = array[length - 1];

	    if (first && typeof first == 'object' &&
	        mid && typeof mid == 'object' && last && typeof last == 'object') {
	      return false;
	    }
	    var cache = getObject();
	    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;

	    var result = getObject();
	    result.array = array;
	    result.cache = cache;
	    result.push = cachePush;

	    while (++index < length) {
	      result.push(array[index]);
	    }
	    return result;
	  }

	  /**
	   * Used by `template` to escape characters for inclusion in compiled
	   * string literals.
	   *
	   * @private
	   * @param {string} match The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  function escapeStringChar(match) {
	    return '\\' + stringEscapes[match];
	  }

	  /**
	   * Gets an array from the array pool or creates a new one if the pool is empty.
	   *
	   * @private
	   * @returns {Array} The array from the pool.
	   */
	  function getArray() {
	    return arrayPool.pop() || [];
	  }

	  /**
	   * Gets an object from the object pool or creates a new one if the pool is empty.
	   *
	   * @private
	   * @returns {Object} The object from the pool.
	   */
	  function getObject() {
	    return objectPool.pop() || {
	      'array': null,
	      'cache': null,
	      'criteria': null,
	      'false': false,
	      'index': 0,
	      'null': false,
	      'number': null,
	      'object': null,
	      'push': null,
	      'string': null,
	      'true': false,
	      'undefined': false,
	      'value': null
	    };
	  }

	  /**
	   * Checks if `value` is a DOM node in IE < 9.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if the `value` is a DOM node, else `false`.
	   */
	  function isNode(value) {
	    // IE < 9 presents DOM nodes as `Object` objects except they have `toString`
	    // methods that are `typeof` "string" and still can coerce nodes to strings
	    return typeof value.toString != 'function' && typeof (value + '') == 'string';
	  }

	  /**
	   * Releases the given array back to the array pool.
	   *
	   * @private
	   * @param {Array} [array] The array to release.
	   */
	  function releaseArray(array) {
	    array.length = 0;
	    if (arrayPool.length < maxPoolSize) {
	      arrayPool.push(array);
	    }
	  }

	  /**
	   * Releases the given object back to the object pool.
	   *
	   * @private
	   * @param {Object} [object] The object to release.
	   */
	  function releaseObject(object) {
	    var cache = object.cache;
	    if (cache) {
	      releaseObject(cache);
	    }
	    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
	    if (objectPool.length < maxPoolSize) {
	      objectPool.push(object);
	    }
	  }

	  /**
	   * Slices the `collection` from the `start` index up to, but not including,
	   * the `end` index.
	   *
	   * Note: This function is used instead of `Array#slice` to support node lists
	   * in IE < 9 and to ensure dense arrays are returned.
	   *
	   * @private
	   * @param {Array|Object|string} collection The collection to slice.
	   * @param {number} start The start index.
	   * @param {number} end The end index.
	   * @returns {Array} Returns the new array.
	   */
	  function slice(array, start, end) {
	    start || (start = 0);
	    if (typeof end == 'undefined') {
	      end = array ? array.length : 0;
	    }
	    var index = -1,
	        length = end - start || 0,
	        result = Array(length < 0 ? 0 : length);

	    while (++index < length) {
	      result[index] = array[start + index];
	    }
	    return result;
	  }

	  /*--------------------------------------------------------------------------*/

	  /**
	   * Create a new `lodash` function using the given context object.
	   *
	   * @static
	   * @memberOf _
	   * @category Utilities
	   * @param {Object} [context=root] The context object.
	   * @returns {Function} Returns the `lodash` function.
	   */
	  function runInContext(context) {
	    // Avoid issues with some ES3 environments that attempt to use values, named
	    // after built-in constructors like `Object`, for the creation of literals.
	    // ES5 clears this up by stating that literals must use built-in constructors.
	    // See http://es5.github.io/#x11.1.5.
	    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

	    /** Native constructor references */
	    var Array = context.Array,
	        Boolean = context.Boolean,
	        Date = context.Date,
	        Error = context.Error,
	        Function = context.Function,
	        Math = context.Math,
	        Number = context.Number,
	        Object = context.Object,
	        RegExp = context.RegExp,
	        String = context.String,
	        TypeError = context.TypeError;

	    /**
	     * Used for `Array` method references.
	     *
	     * Normally `Array.prototype` would suffice, however, using an array literal
	     * avoids issues in Narwhal.
	     */
	    var arrayRef = [];

	    /** Used for native method references */
	    var errorProto = Error.prototype,
	        objectProto = Object.prototype,
	        stringProto = String.prototype;

	    /** Used to restore the original `_` reference in `noConflict` */
	    var oldDash = context._;

	    /** Used to resolve the internal [[Class]] of values */
	    var toString = objectProto.toString;

	    /** Used to detect if a method is native */
	    var reNative = RegExp('^' +
	      String(toString)
	        .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
	        .replace(/toString| for [^\]]+/g, '.*?') + '$'
	    );

	    /** Native method shortcuts */
	    var ceil = Math.ceil,
	        clearTimeout = context.clearTimeout,
	        floor = Math.floor,
	        fnToString = Function.prototype.toString,
	        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
	        hasOwnProperty = objectProto.hasOwnProperty,
	        push = arrayRef.push,
	        propertyIsEnumerable = objectProto.propertyIsEnumerable,
	        setTimeout = context.setTimeout,
	        splice = arrayRef.splice,
	        unshift = arrayRef.unshift;

	    /** Used to set meta data on functions */
	    var defineProperty = (function() {
	      // IE 8 only accepts DOM elements
	      try {
	        var o = {},
	            func = isNative(func = Object.defineProperty) && func,
	            result = func(o, o, o) && func;
	      } catch(e) { }
	      return result;
	    }());

	    /* Native method shortcuts for methods with the same name as other `lodash` methods */
	    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
	        nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
	        nativeIsFinite = context.isFinite,
	        nativeIsNaN = context.isNaN,
	        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
	        nativeMax = Math.max,
	        nativeMin = Math.min,
	        nativeParseInt = context.parseInt,
	        nativeRandom = Math.random;

	    /** Used to lookup a built-in constructor by [[Class]] */
	    var ctorByClass = {};
	    ctorByClass[arrayClass] = Array;
	    ctorByClass[boolClass] = Boolean;
	    ctorByClass[dateClass] = Date;
	    ctorByClass[funcClass] = Function;
	    ctorByClass[objectClass] = Object;
	    ctorByClass[numberClass] = Number;
	    ctorByClass[regexpClass] = RegExp;
	    ctorByClass[stringClass] = String;

	    /** Used to avoid iterating non-enumerable properties in IE < 9 */
	    var nonEnumProps = {};
	    nonEnumProps[arrayClass] = nonEnumProps[dateClass] = nonEnumProps[numberClass] = { 'constructor': true, 'toLocaleString': true, 'toString': true, 'valueOf': true };
	    nonEnumProps[boolClass] = nonEnumProps[stringClass] = { 'constructor': true, 'toString': true, 'valueOf': true };
	    nonEnumProps[errorClass] = nonEnumProps[funcClass] = nonEnumProps[regexpClass] = { 'constructor': true, 'toString': true };
	    nonEnumProps[objectClass] = { 'constructor': true };

	    (function() {
	      var length = shadowedProps.length;
	      while (length--) {
	        var key = shadowedProps[length];
	        for (var className in nonEnumProps) {
	          if (hasOwnProperty.call(nonEnumProps, className) && !hasOwnProperty.call(nonEnumProps[className], key)) {
	            nonEnumProps[className][key] = false;
	          }
	        }
	      }
	    }());

	    /*--------------------------------------------------------------------------*/

	    /**
	     * Creates a `lodash` object which wraps the given value to enable intuitive
	     * method chaining.
	     *
	     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
	     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
	     * and `unshift`
	     *
	     * Chaining is supported in custom builds as long as the `value` method is
	     * implicitly or explicitly included in the build.
	     *
	     * The chainable wrapper functions are:
	     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
	     * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
	     * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
	     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
	     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
	     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
	     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
	     * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
	     * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
	     * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
	     * and `zip`
	     *
	     * The non-chainable wrapper functions are:
	     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
	     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
	     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
	     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
	     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
	     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
	     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
	     * `template`, `unescape`, `uniqueId`, and `value`
	     *
	     * The wrapper functions `first` and `last` return wrapped values when `n` is
	     * provided, otherwise they return unwrapped values.
	     *
	     * Explicit chaining can be enabled by using the `_.chain` method.
	     *
	     * @name _
	     * @constructor
	     * @category Chaining
	     * @param {*} value The value to wrap in a `lodash` instance.
	     * @returns {Object} Returns a `lodash` instance.
	     * @example
	     *
	     * var wrapped = _([1, 2, 3]);
	     *
	     * // returns an unwrapped value
	     * wrapped.reduce(function(sum, num) {
	     *   return sum + num;
	     * });
	     * // => 6
	     *
	     * // returns a wrapped value
	     * var squares = wrapped.map(function(num) {
	     *   return num * num;
	     * });
	     *
	     * _.isArray(squares);
	     * // => false
	     *
	     * _.isArray(squares.value());
	     * // => true
	     */
	    function lodash(value) {
	      // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
	      return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))
	       ? value
	       : new lodashWrapper(value);
	    }

	    /**
	     * A fast path for creating `lodash` wrapper objects.
	     *
	     * @private
	     * @param {*} value The value to wrap in a `lodash` instance.
	     * @param {boolean} chainAll A flag to enable chaining for all methods
	     * @returns {Object} Returns a `lodash` instance.
	     */
	    function lodashWrapper(value, chainAll) {
	      this.__chain__ = !!chainAll;
	      this.__wrapped__ = value;
	    }
	    // ensure `new lodashWrapper` is an instance of `lodash`
	    lodashWrapper.prototype = lodash.prototype;

	    /**
	     * An object used to flag environments features.
	     *
	     * @static
	     * @memberOf _
	     * @type Object
	     */
	    var support = lodash.support = {};

	    (function() {
	      var ctor = function() { this.x = 1; },
	          object = { '0': 1, 'length': 1 },
	          props = [];

	      ctor.prototype = { 'valueOf': 1, 'y': 1 };
	      for (var key in new ctor) { props.push(key); }
	      for (key in arguments) { }

	      /**
	       * Detect if an `arguments` object's [[Class]] is resolvable (all but Firefox < 4, IE < 9).
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.argsClass = toString.call(arguments) == argsClass;

	      /**
	       * Detect if `arguments` objects are `Object` objects (all but Narwhal and Opera < 10.5).
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.argsObject = arguments.constructor == Object && !(arguments instanceof Array);

	      /**
	       * Detect if `name` or `message` properties of `Error.prototype` are
	       * enumerable by default. (IE < 9, Safari < 5.1)
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') || propertyIsEnumerable.call(errorProto, 'name');

	      /**
	       * Detect if `prototype` properties are enumerable by default.
	       *
	       * Firefox < 3.6, Opera > 9.50 - Opera < 11.60, and Safari < 5.1
	       * (if the prototype or a property on the prototype has been set)
	       * incorrectly sets a function's `prototype` property [[Enumerable]]
	       * value to `true`.
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.enumPrototypes = propertyIsEnumerable.call(ctor, 'prototype');

	      /**
	       * Detect if functions can be decompiled by `Function#toString`
	       * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);

	      /**
	       * Detect if `Function#name` is supported (all but IE).
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.funcNames = typeof Function.name == 'string';

	      /**
	       * Detect if `arguments` object indexes are non-enumerable
	       * (Firefox < 4, IE < 9, PhantomJS, Safari < 5.1).
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.nonEnumArgs = key != 0;

	      /**
	       * Detect if properties shadowing those on `Object.prototype` are non-enumerable.
	       *
	       * In IE < 9 an objects own properties, shadowing non-enumerable ones, are
	       * made non-enumerable as well (a.k.a the JScript [[DontEnum]] bug).
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.nonEnumShadows = !/valueOf/.test(props);

	      /**
	       * Detect if own properties are iterated after inherited properties (all but IE < 9).
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.ownLast = props[0] != 'x';

	      /**
	       * Detect if `Array#shift` and `Array#splice` augment array-like objects correctly.
	       *
	       * Firefox < 10, IE compatibility mode, and IE < 9 have buggy Array `shift()`
	       * and `splice()` functions that fail to remove the last element, `value[0]`,
	       * of array-like objects even though the `length` property is set to `0`.
	       * The `shift()` method is buggy in IE 8 compatibility mode, while `splice()`
	       * is buggy regardless of mode in IE < 9 and buggy in compatibility mode in IE 9.
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.spliceObjects = (arrayRef.splice.call(object, 0, 1), !object[0]);

	      /**
	       * Detect lack of support for accessing string characters by index.
	       *
	       * IE < 8 can't access characters by index and IE 8 can only access
	       * characters by index on string literals.
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.unindexedChars = ('x'[0] + Object('x')[0]) != 'xx';

	      /**
	       * Detect if a DOM node's [[Class]] is resolvable (all but IE < 9)
	       * and that the JS engine errors when attempting to coerce an object to
	       * a string without a `toString` function.
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      try {
	        support.nodeClass = !(toString.call(document) == objectClass && !({ 'toString': 0 } + ''));
	      } catch(e) {
	        support.nodeClass = true;
	      }
	    }(1));

	    /**
	     * By default, the template delimiters used by Lo-Dash are similar to those in
	     * embedded Ruby (ERB). Change the following template settings to use alternative
	     * delimiters.
	     *
	     * @static
	     * @memberOf _
	     * @type Object
	     */
	    lodash.templateSettings = {

	      /**
	       * Used to detect `data` property values to be HTML-escaped.
	       *
	       * @memberOf _.templateSettings
	       * @type RegExp
	       */
	      'escape': /<%-([\s\S]+?)%>/g,

	      /**
	       * Used to detect code to be evaluated.
	       *
	       * @memberOf _.templateSettings
	       * @type RegExp
	       */
	      'evaluate': /<%([\s\S]+?)%>/g,

	      /**
	       * Used to detect `data` property values to inject.
	       *
	       * @memberOf _.templateSettings
	       * @type RegExp
	       */
	      'interpolate': reInterpolate,

	      /**
	       * Used to reference the data object in the template text.
	       *
	       * @memberOf _.templateSettings
	       * @type string
	       */
	      'variable': '',

	      /**
	       * Used to import variables into the compiled template.
	       *
	       * @memberOf _.templateSettings
	       * @type Object
	       */
	      'imports': {

	        /**
	         * A reference to the `lodash` function.
	         *
	         * @memberOf _.templateSettings.imports
	         * @type Function
	         */
	        '_': lodash
	      }
	    };

	    /*--------------------------------------------------------------------------*/

	    /**
	     * The template used to create iterator functions.
	     *
	     * @private
	     * @param {Object} data The data object used to populate the text.
	     * @returns {string} Returns the interpolated text.
	     */
	    var iteratorTemplate = function(obj) {

	      var __p = 'var index, iterable = ' +
	      (obj.firstArg) +
	      ', result = ' +
	      (obj.init) +
	      ';\nif (!iterable) return result;\n' +
	      (obj.top) +
	      ';';
	       if (obj.array) {
	      __p += '\nvar length = iterable.length; index = -1;\nif (' +
	      (obj.array) +
	      ') {  ';
	       if (support.unindexedChars) {
	      __p += '\n  if (isString(iterable)) {\n    iterable = iterable.split(\'\')\n  }  ';
	       }
	      __p += '\n  while (++index < length) {\n    ' +
	      (obj.loop) +
	      ';\n  }\n}\nelse {  ';
	       } else if (support.nonEnumArgs) {
	      __p += '\n  var length = iterable.length; index = -1;\n  if (length && isArguments(iterable)) {\n    while (++index < length) {\n      index += \'\';\n      ' +
	      (obj.loop) +
	      ';\n    }\n  } else {  ';
	       }

	       if (support.enumPrototypes) {
	      __p += '\n  var skipProto = typeof iterable == \'function\';\n  ';
	       }

	       if (support.enumErrorProps) {
	      __p += '\n  var skipErrorProps = iterable === errorProto || iterable instanceof Error;\n  ';
	       }

	          var conditions = [];    if (support.enumPrototypes) { conditions.push('!(skipProto && index == "prototype")'); }    if (support.enumErrorProps)  { conditions.push('!(skipErrorProps && (index == "message" || index == "name"))'); }

	       if (obj.useHas && obj.keys) {
	      __p += '\n  var ownIndex = -1,\n      ownProps = objectTypes[typeof iterable] && keys(iterable),\n      length = ownProps ? ownProps.length : 0;\n\n  while (++ownIndex < length) {\n    index = ownProps[ownIndex];\n';
	          if (conditions.length) {
	      __p += '    if (' +
	      (conditions.join(' && ')) +
	      ') {\n  ';
	       }
	      __p +=
	      (obj.loop) +
	      ';    ';
	       if (conditions.length) {
	      __p += '\n    }';
	       }
	      __p += '\n  }  ';
	       } else {
	      __p += '\n  for (index in iterable) {\n';
	          if (obj.useHas) { conditions.push("hasOwnProperty.call(iterable, index)"); }    if (conditions.length) {
	      __p += '    if (' +
	      (conditions.join(' && ')) +
	      ') {\n  ';
	       }
	      __p +=
	      (obj.loop) +
	      ';    ';
	       if (conditions.length) {
	      __p += '\n    }';
	       }
	      __p += '\n  }    ';
	       if (support.nonEnumShadows) {
	      __p += '\n\n  if (iterable !== objectProto) {\n    var ctor = iterable.constructor,\n        isProto = iterable === (ctor && ctor.prototype),\n        className = iterable === stringProto ? stringClass : iterable === errorProto ? errorClass : toString.call(iterable),\n        nonEnum = nonEnumProps[className];\n      ';
	       for (k = 0; k < 7; k++) {
	      __p += '\n    index = \'' +
	      (obj.shadowedProps[k]) +
	      '\';\n    if ((!(isProto && nonEnum[index]) && hasOwnProperty.call(iterable, index))';
	              if (!obj.useHas) {
	      __p += ' || (!nonEnum[index] && iterable[index] !== objectProto[index])';
	       }
	      __p += ') {\n      ' +
	      (obj.loop) +
	      ';\n    }      ';
	       }
	      __p += '\n  }    ';
	       }

	       }

	       if (obj.array || support.nonEnumArgs) {
	      __p += '\n}';
	       }
	      __p +=
	      (obj.bottom) +
	      ';\nreturn result';

	      return __p
	    };

	    /*--------------------------------------------------------------------------*/

	    /**
	     * The base implementation of `_.bind` that creates the bound function and
	     * sets its meta data.
	     *
	     * @private
	     * @param {Array} bindData The bind data array.
	     * @returns {Function} Returns the new bound function.
	     */
	    function baseBind(bindData) {
	      var func = bindData[0],
	          partialArgs = bindData[2],
	          thisArg = bindData[4];

	      function bound() {
	        // `Function#bind` spec
	        // http://es5.github.io/#x15.3.4.5
	        if (partialArgs) {
	          // avoid `arguments` object deoptimizations by using `slice` instead
	          // of `Array.prototype.slice.call` and not assigning `arguments` to a
	          // variable as a ternary expression
	          var args = slice(partialArgs);
	          push.apply(args, arguments);
	        }
	        // mimic the constructor's `return` behavior
	        // http://es5.github.io/#x13.2.2
	        if (this instanceof bound) {
	          // ensure `new bound` is an instance of `func`
	          var thisBinding = baseCreate(func.prototype),
	              result = func.apply(thisBinding, args || arguments);
	          return isObject(result) ? result : thisBinding;
	        }
	        return func.apply(thisArg, args || arguments);
	      }
	      setBindData(bound, bindData);
	      return bound;
	    }

	    /**
	     * The base implementation of `_.clone` without argument juggling or support
	     * for `thisArg` binding.
	     *
	     * @private
	     * @param {*} value The value to clone.
	     * @param {boolean} [isDeep=false] Specify a deep clone.
	     * @param {Function} [callback] The function to customize cloning values.
	     * @param {Array} [stackA=[]] Tracks traversed source objects.
	     * @param {Array} [stackB=[]] Associates clones with source counterparts.
	     * @returns {*} Returns the cloned value.
	     */
	    function baseClone(value, isDeep, callback, stackA, stackB) {
	      if (callback) {
	        var result = callback(value);
	        if (typeof result != 'undefined') {
	          return result;
	        }
	      }
	      // inspect [[Class]]
	      var isObj = isObject(value);
	      if (isObj) {
	        var className = toString.call(value);
	        if (!cloneableClasses[className] || (!support.nodeClass && isNode(value))) {
	          return value;
	        }
	        var ctor = ctorByClass[className];
	        switch (className) {
	          case boolClass:
	          case dateClass:
	            return new ctor(+value);

	          case numberClass:
	          case stringClass:
	            return new ctor(value);

	          case regexpClass:
	            result = ctor(value.source, reFlags.exec(value));
	            result.lastIndex = value.lastIndex;
	            return result;
	        }
	      } else {
	        return value;
	      }
	      var isArr = isArray(value);
	      if (isDeep) {
	        // check for circular references and return corresponding clone
	        var initedStack = !stackA;
	        stackA || (stackA = getArray());
	        stackB || (stackB = getArray());

	        var length = stackA.length;
	        while (length--) {
	          if (stackA[length] == value) {
	            return stackB[length];
	          }
	        }
	        result = isArr ? ctor(value.length) : {};
	      }
	      else {
	        result = isArr ? slice(value) : assign({}, value);
	      }
	      // add array properties assigned by `RegExp#exec`
	      if (isArr) {
	        if (hasOwnProperty.call(value, 'index')) {
	          result.index = value.index;
	        }
	        if (hasOwnProperty.call(value, 'input')) {
	          result.input = value.input;
	        }
	      }
	      // exit for shallow clone
	      if (!isDeep) {
	        return result;
	      }
	      // add the source value to the stack of traversed objects
	      // and associate it with its clone
	      stackA.push(value);
	      stackB.push(result);

	      // recursively populate clone (susceptible to call stack limits)
	      (isArr ? baseEach : forOwn)(value, function(objValue, key) {
	        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
	      });

	      if (initedStack) {
	        releaseArray(stackA);
	        releaseArray(stackB);
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.create` without support for assigning
	     * properties to the created object.
	     *
	     * @private
	     * @param {Object} prototype The object to inherit from.
	     * @returns {Object} Returns the new object.
	     */
	    function baseCreate(prototype, properties) {
	      return isObject(prototype) ? nativeCreate(prototype) : {};
	    }
	    // fallback for browsers without `Object.create`
	    if (!nativeCreate) {
	      baseCreate = (function() {
	        function Object() {}
	        return function(prototype) {
	          if (isObject(prototype)) {
	            Object.prototype = prototype;
	            var result = new Object;
	            Object.prototype = null;
	          }
	          return result || context.Object();
	        };
	      }());
	    }

	    /**
	     * The base implementation of `_.createCallback` without support for creating
	     * "_.pluck" or "_.where" style callbacks.
	     *
	     * @private
	     * @param {*} [func=identity] The value to convert to a callback.
	     * @param {*} [thisArg] The `this` binding of the created callback.
	     * @param {number} [argCount] The number of arguments the callback accepts.
	     * @returns {Function} Returns a callback function.
	     */
	    function baseCreateCallback(func, thisArg, argCount) {
	      if (typeof func != 'function') {
	        return identity;
	      }
	      // exit early for no `thisArg` or already bound by `Function#bind`
	      if (typeof thisArg == 'undefined' || !('prototype' in func)) {
	        return func;
	      }
	      var bindData = func.__bindData__;
	      if (typeof bindData == 'undefined') {
	        if (support.funcNames) {
	          bindData = !func.name;
	        }
	        bindData = bindData || !support.funcDecomp;
	        if (!bindData) {
	          var source = fnToString.call(func);
	          if (!support.funcNames) {
	            bindData = !reFuncName.test(source);
	          }
	          if (!bindData) {
	            // checks if `func` references the `this` keyword and stores the result
	            bindData = reThis.test(source);
	            setBindData(func, bindData);
	          }
	        }
	      }
	      // exit early if there are no `this` references or `func` is bound
	      if (bindData === false || (bindData !== true && bindData[1] & 1)) {
	        return func;
	      }
	      switch (argCount) {
	        case 1: return function(value) {
	          return func.call(thisArg, value);
	        };
	        case 2: return function(a, b) {
	          return func.call(thisArg, a, b);
	        };
	        case 3: return function(value, index, collection) {
	          return func.call(thisArg, value, index, collection);
	        };
	        case 4: return function(accumulator, value, index, collection) {
	          return func.call(thisArg, accumulator, value, index, collection);
	        };
	      }
	      return bind(func, thisArg);
	    }

	    /**
	     * The base implementation of `createWrapper` that creates the wrapper and
	     * sets its meta data.
	     *
	     * @private
	     * @param {Array} bindData The bind data array.
	     * @returns {Function} Returns the new function.
	     */
	    function baseCreateWrapper(bindData) {
	      var func = bindData[0],
	          bitmask = bindData[1],
	          partialArgs = bindData[2],
	          partialRightArgs = bindData[3],
	          thisArg = bindData[4],
	          arity = bindData[5];

	      var isBind = bitmask & 1,
	          isBindKey = bitmask & 2,
	          isCurry = bitmask & 4,
	          isCurryBound = bitmask & 8,
	          key = func;

	      function bound() {
	        var thisBinding = isBind ? thisArg : this;
	        if (partialArgs) {
	          var args = slice(partialArgs);
	          push.apply(args, arguments);
	        }
	        if (partialRightArgs || isCurry) {
	          args || (args = slice(arguments));
	          if (partialRightArgs) {
	            push.apply(args, partialRightArgs);
	          }
	          if (isCurry && args.length < arity) {
	            bitmask |= 16 & ~32;
	            return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
	          }
	        }
	        args || (args = arguments);
	        if (isBindKey) {
	          func = thisBinding[key];
	        }
	        if (this instanceof bound) {
	          thisBinding = baseCreate(func.prototype);
	          var result = func.apply(thisBinding, args);
	          return isObject(result) ? result : thisBinding;
	        }
	        return func.apply(thisBinding, args);
	      }
	      setBindData(bound, bindData);
	      return bound;
	    }

	    /**
	     * The base implementation of `_.difference` that accepts a single array
	     * of values to exclude.
	     *
	     * @private
	     * @param {Array} array The array to process.
	     * @param {Array} [values] The array of values to exclude.
	     * @returns {Array} Returns a new array of filtered values.
	     */
	    function baseDifference(array, values) {
	      var index = -1,
	          indexOf = getIndexOf(),
	          length = array ? array.length : 0,
	          isLarge = length >= largeArraySize && indexOf === baseIndexOf,
	          result = [];

	      if (isLarge) {
	        var cache = createCache(values);
	        if (cache) {
	          indexOf = cacheIndexOf;
	          values = cache;
	        } else {
	          isLarge = false;
	        }
	      }
	      while (++index < length) {
	        var value = array[index];
	        if (indexOf(values, value) < 0) {
	          result.push(value);
	        }
	      }
	      if (isLarge) {
	        releaseObject(values);
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.flatten` without support for callback
	     * shorthands or `thisArg` binding.
	     *
	     * @private
	     * @param {Array} array The array to flatten.
	     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
	     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
	     * @param {number} [fromIndex=0] The index to start from.
	     * @returns {Array} Returns a new flattened array.
	     */
	    function baseFlatten(array, isShallow, isStrict, fromIndex) {
	      var index = (fromIndex || 0) - 1,
	          length = array ? array.length : 0,
	          result = [];

	      while (++index < length) {
	        var value = array[index];

	        if (value && typeof value == 'object' && typeof value.length == 'number'
	            && (isArray(value) || isArguments(value))) {
	          // recursively flatten arrays (susceptible to call stack limits)
	          if (!isShallow) {
	            value = baseFlatten(value, isShallow, isStrict);
	          }
	          var valIndex = -1,
	              valLength = value.length,
	              resIndex = result.length;

	          result.length += valLength;
	          while (++valIndex < valLength) {
	            result[resIndex++] = value[valIndex];
	          }
	        } else if (!isStrict) {
	          result.push(value);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.isEqual`, without support for `thisArg` binding,
	     * that allows partial "_.where" style comparisons.
	     *
	     * @private
	     * @param {*} a The value to compare.
	     * @param {*} b The other value to compare.
	     * @param {Function} [callback] The function to customize comparing values.
	     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
	     * @param {Array} [stackA=[]] Tracks traversed `a` objects.
	     * @param {Array} [stackB=[]] Tracks traversed `b` objects.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     */
	    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
	      // used to indicate that when comparing objects, `a` has at least the properties of `b`
	      if (callback) {
	        var result = callback(a, b);
	        if (typeof result != 'undefined') {
	          return !!result;
	        }
	      }
	      // exit early for identical values
	      if (a === b) {
	        // treat `+0` vs. `-0` as not equal
	        return a !== 0 || (1 / a == 1 / b);
	      }
	      var type = typeof a,
	          otherType = typeof b;

	      // exit early for unlike primitive values
	      if (a === a &&
	          !(a && objectTypes[type]) &&
	          !(b && objectTypes[otherType])) {
	        return false;
	      }
	      // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
	      // http://es5.github.io/#x15.3.4.4
	      if (a == null || b == null) {
	        return a === b;
	      }
	      // compare [[Class]] names
	      var className = toString.call(a),
	          otherClass = toString.call(b);

	      if (className == argsClass) {
	        className = objectClass;
	      }
	      if (otherClass == argsClass) {
	        otherClass = objectClass;
	      }
	      if (className != otherClass) {
	        return false;
	      }
	      switch (className) {
	        case boolClass:
	        case dateClass:
	          // coerce dates and booleans to numbers, dates to milliseconds and booleans
	          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
	          return +a == +b;

	        case numberClass:
	          // treat `NaN` vs. `NaN` as equal
	          return (a != +a)
	            ? b != +b
	            // but treat `+0` vs. `-0` as not equal
	            : (a == 0 ? (1 / a == 1 / b) : a == +b);

	        case regexpClass:
	        case stringClass:
	          // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
	          // treat string primitives and their corresponding object instances as equal
	          return a == String(b);
	      }
	      var isArr = className == arrayClass;
	      if (!isArr) {
	        // unwrap any `lodash` wrapped values
	        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
	            bWrapped = hasOwnProperty.call(b, '__wrapped__');

	        if (aWrapped || bWrapped) {
	          return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
	        }
	        // exit for functions and DOM nodes
	        if (className != objectClass || (!support.nodeClass && (isNode(a) || isNode(b)))) {
	          return false;
	        }
	        // in older versions of Opera, `arguments` objects have `Array` constructors
	        var ctorA = !support.argsObject && isArguments(a) ? Object : a.constructor,
	            ctorB = !support.argsObject && isArguments(b) ? Object : b.constructor;

	        // non `Object` object instances with different constructors are not equal
	        if (ctorA != ctorB &&
	              !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
	              ('constructor' in a && 'constructor' in b)
	            ) {
	          return false;
	        }
	      }
	      // assume cyclic structures are equal
	      // the algorithm for detecting cyclic structures is adapted from ES 5.1
	      // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
	      var initedStack = !stackA;
	      stackA || (stackA = getArray());
	      stackB || (stackB = getArray());

	      var length = stackA.length;
	      while (length--) {
	        if (stackA[length] == a) {
	          return stackB[length] == b;
	        }
	      }
	      var size = 0;
	      result = true;

	      // add `a` and `b` to the stack of traversed objects
	      stackA.push(a);
	      stackB.push(b);

	      // recursively compare objects and arrays (susceptible to call stack limits)
	      if (isArr) {
	        // compare lengths to determine if a deep comparison is necessary
	        length = a.length;
	        size = b.length;
	        result = size == length;

	        if (result || isWhere) {
	          // deep compare the contents, ignoring non-numeric properties
	          while (size--) {
	            var index = length,
	                value = b[size];

	            if (isWhere) {
	              while (index--) {
	                if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
	                  break;
	                }
	              }
	            } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
	              break;
	            }
	          }
	        }
	      }
	      else {
	        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
	        // which, in this case, is more costly
	        forIn(b, function(value, key, b) {
	          if (hasOwnProperty.call(b, key)) {
	            // count the number of properties.
	            size++;
	            // deep compare each property value.
	            return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
	          }
	        });

	        if (result && !isWhere) {
	          // ensure both objects have the same number of properties
	          forIn(a, function(value, key, a) {
	            if (hasOwnProperty.call(a, key)) {
	              // `size` will be `-1` if `a` has more properties than `b`
	              return (result = --size > -1);
	            }
	          });
	        }
	      }
	      stackA.pop();
	      stackB.pop();

	      if (initedStack) {
	        releaseArray(stackA);
	        releaseArray(stackB);
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.merge` without argument juggling or support
	     * for `thisArg` binding.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {Function} [callback] The function to customize merging properties.
	     * @param {Array} [stackA=[]] Tracks traversed source objects.
	     * @param {Array} [stackB=[]] Associates values with source counterparts.
	     */
	    function baseMerge(object, source, callback, stackA, stackB) {
	      (isArray(source) ? forEach : forOwn)(source, function(source, key) {
	        var found,
	            isArr,
	            result = source,
	            value = object[key];

	        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
	          // avoid merging previously merged cyclic sources
	          var stackLength = stackA.length;
	          while (stackLength--) {
	            if ((found = stackA[stackLength] == source)) {
	              value = stackB[stackLength];
	              break;
	            }
	          }
	          if (!found) {
	            var isShallow;
	            if (callback) {
	              result = callback(value, source);
	              if ((isShallow = typeof result != 'undefined')) {
	                value = result;
	              }
	            }
	            if (!isShallow) {
	              value = isArr
	                ? (isArray(value) ? value : [])
	                : (isPlainObject(value) ? value : {});
	            }
	            // add `source` and associated `value` to the stack of traversed objects
	            stackA.push(source);
	            stackB.push(value);

	            // recursively merge objects and arrays (susceptible to call stack limits)
	            if (!isShallow) {
	              baseMerge(value, source, callback, stackA, stackB);
	            }
	          }
	        }
	        else {
	          if (callback) {
	            result = callback(value, source);
	            if (typeof result == 'undefined') {
	              result = source;
	            }
	          }
	          if (typeof result != 'undefined') {
	            value = result;
	          }
	        }
	        object[key] = value;
	      });
	    }

	    /**
	     * The base implementation of `_.random` without argument juggling or support
	     * for returning floating-point numbers.
	     *
	     * @private
	     * @param {number} min The minimum possible value.
	     * @param {number} max The maximum possible value.
	     * @returns {number} Returns a random number.
	     */
	    function baseRandom(min, max) {
	      return min + floor(nativeRandom() * (max - min + 1));
	    }

	    /**
	     * The base implementation of `_.uniq` without support for callback shorthands
	     * or `thisArg` binding.
	     *
	     * @private
	     * @param {Array} array The array to process.
	     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
	     * @param {Function} [callback] The function called per iteration.
	     * @returns {Array} Returns a duplicate-value-free array.
	     */
	    function baseUniq(array, isSorted, callback) {
	      var index = -1,
	          indexOf = getIndexOf(),
	          length = array ? array.length : 0,
	          result = [];

	      var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
	          seen = (callback || isLarge) ? getArray() : result;

	      if (isLarge) {
	        var cache = createCache(seen);
	        indexOf = cacheIndexOf;
	        seen = cache;
	      }
	      while (++index < length) {
	        var value = array[index],
	            computed = callback ? callback(value, index, array) : value;

	        if (isSorted
	              ? !index || seen[seen.length - 1] !== computed
	              : indexOf(seen, computed) < 0
	            ) {
	          if (callback || isLarge) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	      }
	      if (isLarge) {
	        releaseArray(seen.array);
	        releaseObject(seen);
	      } else if (callback) {
	        releaseArray(seen);
	      }
	      return result;
	    }

	    /**
	     * Creates a function that aggregates a collection, creating an object composed
	     * of keys generated from the results of running each element of the collection
	     * through a callback. The given `setter` function sets the keys and values
	     * of the composed object.
	     *
	     * @private
	     * @param {Function} setter The setter function.
	     * @returns {Function} Returns the new aggregator function.
	     */
	    function createAggregator(setter) {
	      return function(collection, callback, thisArg) {
	        var result = {};
	        callback = lodash.createCallback(callback, thisArg, 3);

	        if (isArray(collection)) {
	          var index = -1,
	              length = collection.length;

	          while (++index < length) {
	            var value = collection[index];
	            setter(result, value, callback(value, index, collection), collection);
	          }
	        } else {
	          baseEach(collection, function(value, key, collection) {
	            setter(result, value, callback(value, key, collection), collection);
	          });
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates a function that, when called, either curries or invokes `func`
	     * with an optional `this` binding and partially applied arguments.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to reference.
	     * @param {number} bitmask The bitmask of method flags to compose.
	     *  The bitmask may be composed of the following flags:
	     *  1 - `_.bind`
	     *  2 - `_.bindKey`
	     *  4 - `_.curry`
	     *  8 - `_.curry` (bound)
	     *  16 - `_.partial`
	     *  32 - `_.partialRight`
	     * @param {Array} [partialArgs] An array of arguments to prepend to those
	     *  provided to the new function.
	     * @param {Array} [partialRightArgs] An array of arguments to append to those
	     *  provided to the new function.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new function.
	     */
	    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
	      var isBind = bitmask & 1,
	          isBindKey = bitmask & 2,
	          isCurry = bitmask & 4,
	          isCurryBound = bitmask & 8,
	          isPartial = bitmask & 16,
	          isPartialRight = bitmask & 32;

	      if (!isBindKey && !isFunction(func)) {
	        throw new TypeError;
	      }
	      if (isPartial && !partialArgs.length) {
	        bitmask &= ~16;
	        isPartial = partialArgs = false;
	      }
	      if (isPartialRight && !partialRightArgs.length) {
	        bitmask &= ~32;
	        isPartialRight = partialRightArgs = false;
	      }
	      var bindData = func && func.__bindData__;
	      if (bindData && bindData !== true) {
	        // clone `bindData`
	        bindData = slice(bindData);
	        if (bindData[2]) {
	          bindData[2] = slice(bindData[2]);
	        }
	        if (bindData[3]) {
	          bindData[3] = slice(bindData[3]);
	        }
	        // set `thisBinding` is not previously bound
	        if (isBind && !(bindData[1] & 1)) {
	          bindData[4] = thisArg;
	        }
	        // set if previously bound but not currently (subsequent curried functions)
	        if (!isBind && bindData[1] & 1) {
	          bitmask |= 8;
	        }
	        // set curried arity if not yet set
	        if (isCurry && !(bindData[1] & 4)) {
	          bindData[5] = arity;
	        }
	        // append partial left arguments
	        if (isPartial) {
	          push.apply(bindData[2] || (bindData[2] = []), partialArgs);
	        }
	        // append partial right arguments
	        if (isPartialRight) {
	          unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
	        }
	        // merge flags
	        bindData[1] |= bitmask;
	        return createWrapper.apply(null, bindData);
	      }
	      // fast path for `_.bind`
	      var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
	      return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
	    }

	    /**
	     * Creates compiled iteration functions.
	     *
	     * @private
	     * @param {...Object} [options] The compile options object(s).
	     * @param {string} [options.array] Code to determine if the iterable is an array or array-like.
	     * @param {boolean} [options.useHas] Specify using `hasOwnProperty` checks in the object loop.
	     * @param {Function} [options.keys] A reference to `_.keys` for use in own property iteration.
	     * @param {string} [options.args] A comma separated string of iteration function arguments.
	     * @param {string} [options.top] Code to execute before the iteration branches.
	     * @param {string} [options.loop] Code to execute in the object loop.
	     * @param {string} [options.bottom] Code to execute after the iteration branches.
	     * @returns {Function} Returns the compiled function.
	     */
	    function createIterator() {
	      // data properties
	      iteratorData.shadowedProps = shadowedProps;

	      // iterator options
	      iteratorData.array = iteratorData.bottom = iteratorData.loop = iteratorData.top = '';
	      iteratorData.init = 'iterable';
	      iteratorData.useHas = true;

	      // merge options into a template data object
	      for (var object, index = 0; object = arguments[index]; index++) {
	        for (var key in object) {
	          iteratorData[key] = object[key];
	        }
	      }
	      var args = iteratorData.args;
	      iteratorData.firstArg = /^[^,]+/.exec(args)[0];

	      // create the function factory
	      var factory = Function(
	          'baseCreateCallback, errorClass, errorProto, hasOwnProperty, ' +
	          'indicatorObject, isArguments, isArray, isString, keys, objectProto, ' +
	          'objectTypes, nonEnumProps, stringClass, stringProto, toString',
	        'return function(' + args + ') {\n' + iteratorTemplate(iteratorData) + '\n}'
	      );

	      // return the compiled function
	      return factory(
	        baseCreateCallback, errorClass, errorProto, hasOwnProperty,
	        indicatorObject, isArguments, isArray, isString, iteratorData.keys, objectProto,
	        objectTypes, nonEnumProps, stringClass, stringProto, toString
	      );
	    }

	    /**
	     * Used by `escape` to convert characters to HTML entities.
	     *
	     * @private
	     * @param {string} match The matched character to escape.
	     * @returns {string} Returns the escaped character.
	     */
	    function escapeHtmlChar(match) {
	      return htmlEscapes[match];
	    }

	    /**
	     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
	     * customized, this method returns the custom method, otherwise it returns
	     * the `baseIndexOf` function.
	     *
	     * @private
	     * @returns {Function} Returns the "indexOf" function.
	     */
	    function getIndexOf() {
	      var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
	      return result;
	    }

	    /**
	     * Checks if `value` is a native function.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
	     */
	    function isNative(value) {
	      return typeof value == 'function' && reNative.test(value);
	    }

	    /**
	     * Sets `this` binding data on a given function.
	     *
	     * @private
	     * @param {Function} func The function to set data on.
	     * @param {Array} value The data array to set.
	     */
	    var setBindData = !defineProperty ? noop : function(func, value) {
	      descriptor.value = value;
	      defineProperty(func, '__bindData__', descriptor);
	    };

	    /**
	     * A fallback implementation of `isPlainObject` which checks if a given value
	     * is an object created by the `Object` constructor, assuming objects created
	     * by the `Object` constructor have no inherited enumerable properties and that
	     * there are no `Object.prototype` extensions.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	     */
	    function shimIsPlainObject(value) {
	      var ctor,
	          result;

	      // avoid non Object objects, `arguments` objects, and DOM elements
	      if (!(value && toString.call(value) == objectClass) ||
	          (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor)) ||
	          (!support.argsClass && isArguments(value)) ||
	          (!support.nodeClass && isNode(value))) {
	        return false;
	      }
	      // IE < 9 iterates inherited properties before own properties. If the first
	      // iterated property is an object's own property then there are no inherited
	      // enumerable properties.
	      if (support.ownLast) {
	        forIn(value, function(value, key, object) {
	          result = hasOwnProperty.call(object, key);
	          return false;
	        });
	        return result !== false;
	      }
	      // In most environments an object's own properties are iterated before
	      // its inherited properties. If the last iterated property is an object's
	      // own property then there are no inherited enumerable properties.
	      forIn(value, function(value, key) {
	        result = key;
	      });
	      return typeof result == 'undefined' || hasOwnProperty.call(value, result);
	    }

	    /**
	     * Used by `unescape` to convert HTML entities to characters.
	     *
	     * @private
	     * @param {string} match The matched character to unescape.
	     * @returns {string} Returns the unescaped character.
	     */
	    function unescapeHtmlChar(match) {
	      return htmlUnescapes[match];
	    }

	    /*--------------------------------------------------------------------------*/

	    /**
	     * Checks if `value` is an `arguments` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
	     * @example
	     *
	     * (function() { return _.isArguments(arguments); })(1, 2, 3);
	     * // => true
	     *
	     * _.isArguments([1, 2, 3]);
	     * // => false
	     */
	    function isArguments(value) {
	      return value && typeof value == 'object' && typeof value.length == 'number' &&
	        toString.call(value) == argsClass || false;
	    }
	    // fallback for browsers that can't detect `arguments` objects by [[Class]]
	    if (!support.argsClass) {
	      isArguments = function(value) {
	        return value && typeof value == 'object' && typeof value.length == 'number' &&
	          hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee') || false;
	      };
	    }

	    /**
	     * Checks if `value` is an array.
	     *
	     * @static
	     * @memberOf _
	     * @type Function
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
	     * @example
	     *
	     * (function() { return _.isArray(arguments); })();
	     * // => false
	     *
	     * _.isArray([1, 2, 3]);
	     * // => true
	     */
	    var isArray = nativeIsArray || function(value) {
	      return value && typeof value == 'object' && typeof value.length == 'number' &&
	        toString.call(value) == arrayClass || false;
	    };

	    /**
	     * A fallback implementation of `Object.keys` which produces an array of the
	     * given object's own enumerable property names.
	     *
	     * @private
	     * @type Function
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns an array of property names.
	     */
	    var shimKeys = createIterator({
	      'args': 'object',
	      'init': '[]',
	      'top': 'if (!(objectTypes[typeof object])) return result',
	      'loop': 'result.push(index)'
	    });

	    /**
	     * Creates an array composed of the own enumerable property names of an object.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns an array of property names.
	     * @example
	     *
	     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
	     * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
	     */
	    var keys = !nativeKeys ? shimKeys : function(object) {
	      if (!isObject(object)) {
	        return [];
	      }
	      if ((support.enumPrototypes && typeof object == 'function') ||
	          (support.nonEnumArgs && object.length && isArguments(object))) {
	        return shimKeys(object);
	      }
	      return nativeKeys(object);
	    };

	    /** Reusable iterator options shared by `each`, `forIn`, and `forOwn` */
	    var eachIteratorOptions = {
	      'args': 'collection, callback, thisArg',
	      'top': "callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3)",
	      'array': "typeof length == 'number'",
	      'keys': keys,
	      'loop': 'if (callback(iterable[index], index, collection) === false) return result'
	    };

	    /** Reusable iterator options for `assign` and `defaults` */
	    var defaultsIteratorOptions = {
	      'args': 'object, source, guard',
	      'top':
	        'var args = arguments,\n' +
	        '    argsIndex = 0,\n' +
	        "    argsLength = typeof guard == 'number' ? 2 : args.length;\n" +
	        'while (++argsIndex < argsLength) {\n' +
	        '  iterable = args[argsIndex];\n' +
	        '  if (iterable && objectTypes[typeof iterable]) {',
	      'keys': keys,
	      'loop': "if (typeof result[index] == 'undefined') result[index] = iterable[index]",
	      'bottom': '  }\n}'
	    };

	    /** Reusable iterator options for `forIn` and `forOwn` */
	    var forOwnIteratorOptions = {
	      'top': 'if (!objectTypes[typeof iterable]) return result;\n' + eachIteratorOptions.top,
	      'array': false
	    };

	    /**
	     * Used to convert characters to HTML entities:
	     *
	     * Though the `>` character is escaped for symmetry, characters like `>` and `/`
	     * don't require escaping in HTML and have no special meaning unless they're part
	     * of a tag or an unquoted attribute value.
	     * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
	     */
	    var htmlEscapes = {
	      '&': '&amp;',
	      '<': '&lt;',
	      '>': '&gt;',
	      '"': '&quot;',
	      "'": '&#39;'
	    };

	    /** Used to convert HTML entities to characters */
	    var htmlUnescapes = invert(htmlEscapes);

	    /** Used to match HTML entities and HTML characters */
	    var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
	        reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');

	    /**
	     * A function compiled to iterate `arguments` objects, arrays, objects, and
	     * strings consistenly across environments, executing the callback for each
	     * element in the collection. The callback is bound to `thisArg` and invoked
	     * with three arguments; (value, index|key, collection). Callbacks may exit
	     * iteration early by explicitly returning `false`.
	     *
	     * @private
	     * @type Function
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [callback=identity] The function called per iteration.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array|Object|string} Returns `collection`.
	     */
	    var baseEach = createIterator(eachIteratorOptions);

	    /*--------------------------------------------------------------------------*/

	    /**
	     * Assigns own enumerable properties of source object(s) to the destination
	     * object. Subsequent sources will overwrite property assignments of previous
	     * sources. If a callback is provided it will be executed to produce the
	     * assigned values. The callback is bound to `thisArg` and invoked with two
	     * arguments; (objectValue, sourceValue).
	     *
	     * @static
	     * @memberOf _
	     * @type Function
	     * @alias extend
	     * @category Objects
	     * @param {Object} object The destination object.
	     * @param {...Object} [source] The source objects.
	     * @param {Function} [callback] The function to customize assigning values.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Object} Returns the destination object.
	     * @example
	     *
	     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
	     * // => { 'name': 'fred', 'employer': 'slate' }
	     *
	     * var defaults = _.partialRight(_.assign, function(a, b) {
	     *   return typeof a == 'undefined' ? b : a;
	     * });
	     *
	     * var object = { 'name': 'barney' };
	     * defaults(object, { 'name': 'fred', 'employer': 'slate' });
	     * // => { 'name': 'barney', 'employer': 'slate' }
	     */
	    var assign = createIterator(defaultsIteratorOptions, {
	      'top':
	        defaultsIteratorOptions.top.replace(';',
	          ';\n' +
	          "if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {\n" +
	          '  var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);\n' +
	          "} else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {\n" +
	          '  callback = args[--argsLength];\n' +
	          '}'
	        ),
	      'loop': 'result[index] = callback ? callback(result[index], iterable[index]) : iterable[index]'
	    });

	    /**
	     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
	     * be cloned, otherwise they will be assigned by reference. If a callback
	     * is provided it will be executed to produce the cloned values. If the
	     * callback returns `undefined` cloning will be handled by the method instead.
	     * The callback is bound to `thisArg` and invoked with one argument; (value).
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to clone.
	     * @param {boolean} [isDeep=false] Specify a deep clone.
	     * @param {Function} [callback] The function to customize cloning values.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {*} Returns the cloned value.
	     * @example
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36 },
	     *   { 'name': 'fred',   'age': 40 }
	     * ];
	     *
	     * var shallow = _.clone(characters);
	     * shallow[0] === characters[0];
	     * // => true
	     *
	     * var deep = _.clone(characters, true);
	     * deep[0] === characters[0];
	     * // => false
	     *
	     * _.mixin({
	     *   'clone': _.partialRight(_.clone, function(value) {
	     *     return _.isElement(value) ? value.cloneNode(false) : undefined;
	     *   })
	     * });
	     *
	     * var clone = _.clone(document.body);
	     * clone.childNodes.length;
	     * // => 0
	     */
	    function clone(value, isDeep, callback, thisArg) {
	      // allows working with "Collections" methods without using their `index`
	      // and `collection` arguments for `isDeep` and `callback`
	      if (typeof isDeep != 'boolean' && isDeep != null) {
	        thisArg = callback;
	        callback = isDeep;
	        isDeep = false;
	      }
	      return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
	    }

	    /**
	     * Creates a deep clone of `value`. If a callback is provided it will be
	     * executed to produce the cloned values. If the callback returns `undefined`
	     * cloning will be handled by the method instead. The callback is bound to
	     * `thisArg` and invoked with one argument; (value).
	     *
	     * Note: This method is loosely based on the structured clone algorithm. Functions
	     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
	     * objects created by constructors other than `Object` are cloned to plain `Object` objects.
	     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to deep clone.
	     * @param {Function} [callback] The function to customize cloning values.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {*} Returns the deep cloned value.
	     * @example
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36 },
	     *   { 'name': 'fred',   'age': 40 }
	     * ];
	     *
	     * var deep = _.cloneDeep(characters);
	     * deep[0] === characters[0];
	     * // => false
	     *
	     * var view = {
	     *   'label': 'docs',
	     *   'node': element
	     * };
	     *
	     * var clone = _.cloneDeep(view, function(value) {
	     *   return _.isElement(value) ? value.cloneNode(true) : undefined;
	     * });
	     *
	     * clone.node == view.node;
	     * // => false
	     */
	    function cloneDeep(value, callback, thisArg) {
	      return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
	    }

	    /**
	     * Creates an object that inherits from the given `prototype` object. If a
	     * `properties` object is provided its own enumerable properties are assigned
	     * to the created object.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} prototype The object to inherit from.
	     * @param {Object} [properties] The properties to assign to the object.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * function Shape() {
	     *   this.x = 0;
	     *   this.y = 0;
	     * }
	     *
	     * function Circle() {
	     *   Shape.call(this);
	     * }
	     *
	     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
	     *
	     * var circle = new Circle;
	     * circle instanceof Circle;
	     * // => true
	     *
	     * circle instanceof Shape;
	     * // => true
	     */
	    function create(prototype, properties) {
	      var result = baseCreate(prototype);
	      return properties ? assign(result, properties) : result;
	    }

	    /**
	     * Assigns own enumerable properties of source object(s) to the destination
	     * object for all destination properties that resolve to `undefined`. Once a
	     * property is set, additional defaults of the same property will be ignored.
	     *
	     * @static
	     * @memberOf _
	     * @type Function
	     * @category Objects
	     * @param {Object} object The destination object.
	     * @param {...Object} [source] The source objects.
	     * @param- {Object} [guard] Allows working with `_.reduce` without using its
	     *  `key` and `object` arguments as sources.
	     * @returns {Object} Returns the destination object.
	     * @example
	     *
	     * var object = { 'name': 'barney' };
	     * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
	     * // => { 'name': 'barney', 'employer': 'slate' }
	     */
	    var defaults = createIterator(defaultsIteratorOptions);

	    /**
	     * This method is like `_.findIndex` except that it returns the key of the
	     * first element that passes the callback check, instead of the element itself.
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The object to search.
	     * @param {Function|Object|string} [callback=identity] The function called per
	     *  iteration. If a property name or object is provided it will be used to
	     *  create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
	     * @example
	     *
	     * var characters = {
	     *   'barney': {  'age': 36, 'blocked': false },
	     *   'fred': {    'age': 40, 'blocked': true },
	     *   'pebbles': { 'age': 1,  'blocked': false }
	     * };
	     *
	     * _.findKey(characters, function(chr) {
	     *   return chr.age < 40;
	     * });
	     * // => 'barney' (property order is not guaranteed across environments)
	     *
	     * // using "_.where" callback shorthand
	     * _.findKey(characters, { 'age': 1 });
	     * // => 'pebbles'
	     *
	     * // using "_.pluck" callback shorthand
	     * _.findKey(characters, 'blocked');
	     * // => 'fred'
	     */
	    function findKey(object, callback, thisArg) {
	      var result;
	      callback = lodash.createCallback(callback, thisArg, 3);
	      forOwn(object, function(value, key, object) {
	        if (callback(value, key, object)) {
	          result = key;
	          return false;
	        }
	      });
	      return result;
	    }

	    /**
	     * This method is like `_.findKey` except that it iterates over elements
	     * of a `collection` in the opposite order.
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The object to search.
	     * @param {Function|Object|string} [callback=identity] The function called per
	     *  iteration. If a property name or object is provided it will be used to
	     *  create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
	     * @example
	     *
	     * var characters = {
	     *   'barney': {  'age': 36, 'blocked': true },
	     *   'fred': {    'age': 40, 'blocked': false },
	     *   'pebbles': { 'age': 1,  'blocked': true }
	     * };
	     *
	     * _.findLastKey(characters, function(chr) {
	     *   return chr.age < 40;
	     * });
	     * // => returns `pebbles`, assuming `_.findKey` returns `barney`
	     *
	     * // using "_.where" callback shorthand
	     * _.findLastKey(characters, { 'age': 40 });
	     * // => 'fred'
	     *
	     * // using "_.pluck" callback shorthand
	     * _.findLastKey(characters, 'blocked');
	     * // => 'pebbles'
	     */
	    function findLastKey(object, callback, thisArg) {
	      var result;
	      callback = lodash.createCallback(callback, thisArg, 3);
	      forOwnRight(object, function(value, key, object) {
	        if (callback(value, key, object)) {
	          result = key;
	          return false;
	        }
	      });
	      return result;
	    }

	    /**
	     * Iterates over own and inherited enumerable properties of an object,
	     * executing the callback for each property. The callback is bound to `thisArg`
	     * and invoked with three arguments; (value, key, object). Callbacks may exit
	     * iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @type Function
	     * @category Objects
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [callback=identity] The function called per iteration.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Shape() {
	     *   this.x = 0;
	     *   this.y = 0;
	     * }
	     *
	     * Shape.prototype.move = function(x, y) {
	     *   this.x += x;
	     *   this.y += y;
	     * };
	     *
	     * _.forIn(new Shape, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
	     */
	    var forIn = createIterator(eachIteratorOptions, forOwnIteratorOptions, {
	      'useHas': false
	    });

	    /**
	     * This method is like `_.forIn` except that it iterates over elements
	     * of a `collection` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [callback=identity] The function called per iteration.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Shape() {
	     *   this.x = 0;
	     *   this.y = 0;
	     * }
	     *
	     * Shape.prototype.move = function(x, y) {
	     *   this.x += x;
	     *   this.y += y;
	     * };
	     *
	     * _.forInRight(new Shape, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'
	     */
	    function forInRight(object, callback, thisArg) {
	      var pairs = [];

	      forIn(object, function(value, key) {
	        pairs.push(key, value);
	      });

	      var length = pairs.length;
	      callback = baseCreateCallback(callback, thisArg, 3);
	      while (length--) {
	        if (callback(pairs[length--], pairs[length], object) === false) {
	          break;
	        }
	      }
	      return object;
	    }

	    /**
	     * Iterates over own enumerable properties of an object, executing the callback
	     * for each property. The callback is bound to `thisArg` and invoked with three
	     * arguments; (value, key, object). Callbacks may exit iteration early by
	     * explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @type Function
	     * @category Objects
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [callback=identity] The function called per iteration.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
	     *   console.log(key);
	     * });
	     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
	     */
	    var forOwn = createIterator(eachIteratorOptions, forOwnIteratorOptions);

	    /**
	     * This method is like `_.forOwn` except that it iterates over elements
	     * of a `collection` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [callback=identity] The function called per iteration.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
	     */
	    function forOwnRight(object, callback, thisArg) {
	      var props = keys(object),
	          length = props.length;

	      callback = baseCreateCallback(callback, thisArg, 3);
	      while (length--) {
	        var key = props[length];
	        if (callback(object[key], key, object) === false) {
	          break;
	        }
	      }
	      return object;
	    }

	    /**
	     * Creates a sorted array of property names of all enumerable properties,
	     * own and inherited, of `object` that have function values.
	     *
	     * @static
	     * @memberOf _
	     * @alias methods
	     * @category Objects
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns an array of property names that have function values.
	     * @example
	     *
	     * _.functions(_);
	     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
	     */
	    function functions(object) {
	      var result = [];
	      forIn(object, function(value, key) {
	        if (isFunction(value)) {
	          result.push(key);
	        }
	      });
	      return result.sort();
	    }

	    /**
	     * Checks if the specified property name exists as a direct property of `object`,
	     * instead of an inherited property.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The object to inspect.
	     * @param {string} key The name of the property to check.
	     * @returns {boolean} Returns `true` if key is a direct property, else `false`.
	     * @example
	     *
	     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
	     * // => true
	     */
	    function has(object, key) {
	      return object ? hasOwnProperty.call(object, key) : false;
	    }

	    /**
	     * Creates an object composed of the inverted keys and values of the given object.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The object to invert.
	     * @returns {Object} Returns the created inverted object.
	     * @example
	     *
	     * _.invert({ 'first': 'fred', 'second': 'barney' });
	     * // => { 'fred': 'first', 'barney': 'second' }
	     */
	    function invert(object) {
	      var index = -1,
	          props = keys(object),
	          length = props.length,
	          result = {};

	      while (++index < length) {
	        var key = props[index];
	        result[object[key]] = key;
	      }
	      return result;
	    }

	    /**
	     * Checks if `value` is a boolean value.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
	     * @example
	     *
	     * _.isBoolean(null);
	     * // => false
	     */
	    function isBoolean(value) {
	      return value === true || value === false ||
	        value && typeof value == 'object' && toString.call(value) == boolClass || false;
	    }

	    /**
	     * Checks if `value` is a date.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
	     * @example
	     *
	     * _.isDate(new Date);
	     * // => true
	     */
	    function isDate(value) {
	      return value && typeof value == 'object' && toString.call(value) == dateClass || false;
	    }

	    /**
	     * Checks if `value` is a DOM element.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
	     * @example
	     *
	     * _.isElement(document.body);
	     * // => true
	     */
	    function isElement(value) {
	      return value && value.nodeType === 1 || false;
	    }

	    /**
	     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
	     * length of `0` and objects with no own enumerable properties are considered
	     * "empty".
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Array|Object|string} value The value to inspect.
	     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
	     * @example
	     *
	     * _.isEmpty([1, 2, 3]);
	     * // => false
	     *
	     * _.isEmpty({});
	     * // => true
	     *
	     * _.isEmpty('');
	     * // => true
	     */
	    function isEmpty(value) {
	      var result = true;
	      if (!value) {
	        return result;
	      }
	      var className = toString.call(value),
	          length = value.length;

	      if ((className == arrayClass || className == stringClass ||
	          (support.argsClass ? className == argsClass : isArguments(value))) ||
	          (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
	        return !length;
	      }
	      forOwn(value, function() {
	        return (result = false);
	      });
	      return result;
	    }

	    /**
	     * Performs a deep comparison between two values to determine if they are
	     * equivalent to each other. If a callback is provided it will be executed
	     * to compare values. If the callback returns `undefined` comparisons will
	     * be handled by the method instead. The callback is bound to `thisArg` and
	     * invoked with two arguments; (a, b).
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} a The value to compare.
	     * @param {*} b The other value to compare.
	     * @param {Function} [callback] The function to customize comparing values.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * var object = { 'name': 'fred' };
	     * var copy = { 'name': 'fred' };
	     *
	     * object == copy;
	     * // => false
	     *
	     * _.isEqual(object, copy);
	     * // => true
	     *
	     * var words = ['hello', 'goodbye'];
	     * var otherWords = ['hi', 'goodbye'];
	     *
	     * _.isEqual(words, otherWords, function(a, b) {
	     *   var reGreet = /^(?:hello|hi)$/i,
	     *       aGreet = _.isString(a) && reGreet.test(a),
	     *       bGreet = _.isString(b) && reGreet.test(b);
	     *
	     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
	     * });
	     * // => true
	     */
	    function isEqual(a, b, callback, thisArg) {
	      return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
	    }

	    /**
	     * Checks if `value` is, or can be coerced to, a finite number.
	     *
	     * Note: This is not the same as native `isFinite` which will return true for
	     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
	     * @example
	     *
	     * _.isFinite(-101);
	     * // => true
	     *
	     * _.isFinite('10');
	     * // => true
	     *
	     * _.isFinite(true);
	     * // => false
	     *
	     * _.isFinite('');
	     * // => false
	     *
	     * _.isFinite(Infinity);
	     * // => false
	     */
	    function isFinite(value) {
	      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
	    }

	    /**
	     * Checks if `value` is a function.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
	     * @example
	     *
	     * _.isFunction(_);
	     * // => true
	     */
	    function isFunction(value) {
	      return typeof value == 'function';
	    }
	    // fallback for older versions of Chrome and Safari
	    if (isFunction(/x/)) {
	      isFunction = function(value) {
	        return typeof value == 'function' && toString.call(value) == funcClass;
	      };
	    }

	    /**
	     * Checks if `value` is the language type of Object.
	     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
	     * @example
	     *
	     * _.isObject({});
	     * // => true
	     *
	     * _.isObject([1, 2, 3]);
	     * // => true
	     *
	     * _.isObject(1);
	     * // => false
	     */
	    function isObject(value) {
	      // check if the value is the ECMAScript language type of Object
	      // http://es5.github.io/#x8
	      // and avoid a V8 bug
	      // http://code.google.com/p/v8/issues/detail?id=2291
	      return !!(value && objectTypes[typeof value]);
	    }

	    /**
	     * Checks if `value` is `NaN`.
	     *
	     * Note: This is not the same as native `isNaN` which will return `true` for
	     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
	     * @example
	     *
	     * _.isNaN(NaN);
	     * // => true
	     *
	     * _.isNaN(new Number(NaN));
	     * // => true
	     *
	     * isNaN(undefined);
	     * // => true
	     *
	     * _.isNaN(undefined);
	     * // => false
	     */
	    function isNaN(value) {
	      // `NaN` as a primitive is the only value that is not equal to itself
	      // (perform the [[Class]] check first to avoid errors with some host objects in IE)
	      return isNumber(value) && value != +value;
	    }

	    /**
	     * Checks if `value` is `null`.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
	     * @example
	     *
	     * _.isNull(null);
	     * // => true
	     *
	     * _.isNull(undefined);
	     * // => false
	     */
	    function isNull(value) {
	      return value === null;
	    }

	    /**
	     * Checks if `value` is a number.
	     *
	     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
	     * @example
	     *
	     * _.isNumber(8.4 * 5);
	     * // => true
	     */
	    function isNumber(value) {
	      return typeof value == 'number' ||
	        value && typeof value == 'object' && toString.call(value) == numberClass || false;
	    }

	    /**
	     * Checks if `value` is an object created by the `Object` constructor.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	     * @example
	     *
	     * function Shape() {
	     *   this.x = 0;
	     *   this.y = 0;
	     * }
	     *
	     * _.isPlainObject(new Shape);
	     * // => false
	     *
	     * _.isPlainObject([1, 2, 3]);
	     * // => false
	     *
	     * _.isPlainObject({ 'x': 0, 'y': 0 });
	     * // => true
	     */
	    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
	      if (!(value && toString.call(value) == objectClass) || (!support.argsClass && isArguments(value))) {
	        return false;
	      }
	      var valueOf = value.valueOf,
	          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

	      return objProto
	        ? (value == objProto || getPrototypeOf(value) == objProto)
	        : shimIsPlainObject(value);
	    };

	    /**
	     * Checks if `value` is a regular expression.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
	     * @example
	     *
	     * _.isRegExp(/fred/);
	     * // => true
	     */
	    function isRegExp(value) {
	      return value && objectTypes[typeof value] && toString.call(value) == regexpClass || false;
	    }

	    /**
	     * Checks if `value` is a string.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
	     * @example
	     *
	     * _.isString('fred');
	     * // => true
	     */
	    function isString(value) {
	      return typeof value == 'string' ||
	        value && typeof value == 'object' && toString.call(value) == stringClass || false;
	    }

	    /**
	     * Checks if `value` is `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
	     * @example
	     *
	     * _.isUndefined(void 0);
	     * // => true
	     */
	    function isUndefined(value) {
	      return typeof value == 'undefined';
	    }

	    /**
	     * Creates an object with the same keys as `object` and values generated by
	     * running each own enumerable property of `object` through the callback.
	     * The callback is bound to `thisArg` and invoked with three arguments;
	     * (value, key, object).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The object to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array} Returns a new object with values of the results of each `callback` execution.
	     * @example
	     *
	     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });
	     * // => { 'a': 3, 'b': 6, 'c': 9 }
	     *
	     * var characters = {
	     *   'fred': { 'name': 'fred', 'age': 40 },
	     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
	     * };
	     *
	     * // using "_.pluck" callback shorthand
	     * _.mapValues(characters, 'age');
	     * // => { 'fred': 40, 'pebbles': 1 }
	     */
	    function mapValues(object, callback, thisArg) {
	      var result = {};
	      callback = lodash.createCallback(callback, thisArg, 3);

	      forOwn(object, function(value, key, object) {
	        result[key] = callback(value, key, object);
	      });
	      return result;
	    }

	    /**
	     * Recursively merges own enumerable properties of the source object(s), that
	     * don't resolve to `undefined` into the destination object. Subsequent sources
	     * will overwrite property assignments of previous sources. If a callback is
	     * provided it will be executed to produce the merged values of the destination
	     * and source properties. If the callback returns `undefined` merging will
	     * be handled by the method instead. The callback is bound to `thisArg` and
	     * invoked with two arguments; (objectValue, sourceValue).
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The destination object.
	     * @param {...Object} [source] The source objects.
	     * @param {Function} [callback] The function to customize merging properties.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Object} Returns the destination object.
	     * @example
	     *
	     * var names = {
	     *   'characters': [
	     *     { 'name': 'barney' },
	     *     { 'name': 'fred' }
	     *   ]
	     * };
	     *
	     * var ages = {
	     *   'characters': [
	     *     { 'age': 36 },
	     *     { 'age': 40 }
	     *   ]
	     * };
	     *
	     * _.merge(names, ages);
	     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
	     *
	     * var food = {
	     *   'fruits': ['apple'],
	     *   'vegetables': ['beet']
	     * };
	     *
	     * var otherFood = {
	     *   'fruits': ['banana'],
	     *   'vegetables': ['carrot']
	     * };
	     *
	     * _.merge(food, otherFood, function(a, b) {
	     *   return _.isArray(a) ? a.concat(b) : undefined;
	     * });
	     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
	     */
	    function merge(object) {
	      var args = arguments,
	          length = 2;

	      if (!isObject(object)) {
	        return object;
	      }
	      // allows working with `_.reduce` and `_.reduceRight` without using
	      // their `index` and `collection` arguments
	      if (typeof args[2] != 'number') {
	        length = args.length;
	      }
	      if (length > 3 && typeof args[length - 2] == 'function') {
	        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
	      } else if (length > 2 && typeof args[length - 1] == 'function') {
	        callback = args[--length];
	      }
	      var sources = slice(arguments, 1, length),
	          index = -1,
	          stackA = getArray(),
	          stackB = getArray();

	      while (++index < length) {
	        baseMerge(object, sources[index], callback, stackA, stackB);
	      }
	      releaseArray(stackA);
	      releaseArray(stackB);
	      return object;
	    }

	    /**
	     * Creates a shallow clone of `object` excluding the specified properties.
	     * Property names may be specified as individual arguments or as arrays of
	     * property names. If a callback is provided it will be executed for each
	     * property of `object` omitting the properties the callback returns truey
	     * for. The callback is bound to `thisArg` and invoked with three arguments;
	     * (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The source object.
	     * @param {Function|...string|string[]} [callback] The properties to omit or the
	     *  function called per iteration.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Object} Returns an object without the omitted properties.
	     * @example
	     *
	     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
	     * // => { 'name': 'fred' }
	     *
	     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
	     *   return typeof value == 'number';
	     * });
	     * // => { 'name': 'fred' }
	     */
	    function omit(object, callback, thisArg) {
	      var result = {};
	      if (typeof callback != 'function') {
	        var props = [];
	        forIn(object, function(value, key) {
	          props.push(key);
	        });
	        props = baseDifference(props, baseFlatten(arguments, true, false, 1));

	        var index = -1,
	            length = props.length;

	        while (++index < length) {
	          var key = props[index];
	          result[key] = object[key];
	        }
	      } else {
	        callback = lodash.createCallback(callback, thisArg, 3);
	        forIn(object, function(value, key, object) {
	          if (!callback(value, key, object)) {
	            result[key] = value;
	          }
	        });
	      }
	      return result;
	    }

	    /**
	     * Creates a two dimensional array of an object's key-value pairs,
	     * i.e. `[[key1, value1], [key2, value2]]`.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns new array of key-value pairs.
	     * @example
	     *
	     * _.pairs({ 'barney': 36, 'fred': 40 });
	     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
	     */
	    function pairs(object) {
	      var index = -1,
	          props = keys(object),
	          length = props.length,
	          result = Array(length);

	      while (++index < length) {
	        var key = props[index];
	        result[index] = [key, object[key]];
	      }
	      return result;
	    }

	    /**
	     * Creates a shallow clone of `object` composed of the specified properties.
	     * Property names may be specified as individual arguments or as arrays of
	     * property names. If a callback is provided it will be executed for each
	     * property of `object` picking the properties the callback returns truey
	     * for. The callback is bound to `thisArg` and invoked with three arguments;
	     * (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The source object.
	     * @param {Function|...string|string[]} [callback] The function called per
	     *  iteration or property names to pick, specified as individual property
	     *  names or arrays of property names.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Object} Returns an object composed of the picked properties.
	     * @example
	     *
	     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
	     * // => { 'name': 'fred' }
	     *
	     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
	     *   return key.charAt(0) != '_';
	     * });
	     * // => { 'name': 'fred' }
	     */
	    function pick(object, callback, thisArg) {
	      var result = {};
	      if (typeof callback != 'function') {
	        var index = -1,
	            props = baseFlatten(arguments, true, false, 1),
	            length = isObject(object) ? props.length : 0;

	        while (++index < length) {
	          var key = props[index];
	          if (key in object) {
	            result[key] = object[key];
	          }
	        }
	      } else {
	        callback = lodash.createCallback(callback, thisArg, 3);
	        forIn(object, function(value, key, object) {
	          if (callback(value, key, object)) {
	            result[key] = value;
	          }
	        });
	      }
	      return result;
	    }

	    /**
	     * An alternative to `_.reduce` this method transforms `object` to a new
	     * `accumulator` object which is the result of running each of its own
	     * enumerable properties through a callback, with each callback execution
	     * potentially mutating the `accumulator` object. The callback is bound to
	     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).
	     * Callbacks may exit iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Array|Object} object The object to iterate over.
	     * @param {Function} [callback=identity] The function called per iteration.
	     * @param {*} [accumulator] The custom accumulator value.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
	     *   num *= num;
	     *   if (num % 2) {
	     *     return result.push(num) < 3;
	     *   }
	     * });
	     * // => [1, 9, 25]
	     *
	     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
	     *   result[key] = num * 3;
	     * });
	     * // => { 'a': 3, 'b': 6, 'c': 9 }
	     */
	    function transform(object, callback, accumulator, thisArg) {
	      var isArr = isArray(object);
	      if (accumulator == null) {
	        if (isArr) {
	          accumulator = [];
	        } else {
	          var ctor = object && object.constructor,
	              proto = ctor && ctor.prototype;

	          accumulator = baseCreate(proto);
	        }
	      }
	      if (callback) {
	        callback = lodash.createCallback(callback, thisArg, 4);
	        (isArr ? baseEach : forOwn)(object, function(value, index, object) {
	          return callback(accumulator, value, index, object);
	        });
	      }
	      return accumulator;
	    }

	    /**
	     * Creates an array composed of the own enumerable property values of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns an array of property values.
	     * @example
	     *
	     * _.values({ 'one': 1, 'two': 2, 'three': 3 });
	     * // => [1, 2, 3] (property order is not guaranteed across environments)
	     */
	    function values(object) {
	      var index = -1,
	          props = keys(object),
	          length = props.length,
	          result = Array(length);

	      while (++index < length) {
	        result[index] = object[props[index]];
	      }
	      return result;
	    }

	    /*--------------------------------------------------------------------------*/

	    /**
	     * Creates an array of elements from the specified indexes, or keys, of the
	     * `collection`. Indexes may be specified as individual arguments or as arrays
	     * of indexes.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
	     *   to retrieve, specified as individual indexes or arrays of indexes.
	     * @returns {Array} Returns a new array of elements corresponding to the
	     *  provided indexes.
	     * @example
	     *
	     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
	     * // => ['a', 'c', 'e']
	     *
	     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
	     * // => ['fred', 'pebbles']
	     */
	    function at(collection) {
	      var args = arguments,
	          index = -1,
	          props = baseFlatten(args, true, false, 1),
	          length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,
	          result = Array(length);

	      if (support.unindexedChars && isString(collection)) {
	        collection = collection.split('');
	      }
	      while(++index < length) {
	        result[index] = collection[props[index]];
	      }
	      return result;
	    }

	    /**
	     * Checks if a given value is present in a collection using strict equality
	     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
	     * offset from the end of the collection.
	     *
	     * @static
	     * @memberOf _
	     * @alias include
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {*} target The value to check for.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
	     * @example
	     *
	     * _.contains([1, 2, 3], 1);
	     * // => true
	     *
	     * _.contains([1, 2, 3], 1, 2);
	     * // => false
	     *
	     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
	     * // => true
	     *
	     * _.contains('pebbles', 'eb');
	     * // => true
	     */
	    function contains(collection, target, fromIndex) {
	      var index = -1,
	          indexOf = getIndexOf(),
	          length = collection ? collection.length : 0,
	          result = false;

	      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
	      if (isArray(collection)) {
	        result = indexOf(collection, target, fromIndex) > -1;
	      } else if (typeof length == 'number') {
	        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
	      } else {
	        baseEach(collection, function(value) {
	          if (++index >= fromIndex) {
	            return !(result = value === target);
	          }
	        });
	      }
	      return result;
	    }

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` through the callback. The corresponding value
	     * of each key is the number of times the key was returned by the callback.
	     * The callback is bound to `thisArg` and invoked with three arguments;
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
	     * // => { '4': 1, '6': 2 }
	     *
	     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
	     * // => { '4': 1, '6': 2 }
	     *
	     * _.countBy(['one', 'two', 'three'], 'length');
	     * // => { '3': 2, '5': 1 }
	     */
	    var countBy = createAggregator(function(result, value, key) {
	      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
	    });

	    /**
	     * Checks if the given callback returns truey value for **all** elements of
	     * a collection. The callback is bound to `thisArg` and invoked with three
	     * arguments; (value, index|key, collection).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias all
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {boolean} Returns `true` if all elements passed the callback check,
	     *  else `false`.
	     * @example
	     *
	     * _.every([true, 1, null, 'yes']);
	     * // => false
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36 },
	     *   { 'name': 'fred',   'age': 40 }
	     * ];
	     *
	     * // using "_.pluck" callback shorthand
	     * _.every(characters, 'age');
	     * // => true
	     *
	     * // using "_.where" callback shorthand
	     * _.every(characters, { 'age': 36 });
	     * // => false
	     */
	    function every(collection, callback, thisArg) {
	      var result = true;
	      callback = lodash.createCallback(callback, thisArg, 3);

	      if (isArray(collection)) {
	        var index = -1,
	            length = collection.length;

	        while (++index < length) {
	          if (!(result = !!callback(collection[index], index, collection))) {
	            break;
	          }
	        }
	      } else {
	        baseEach(collection, function(value, index, collection) {
	          return (result = !!callback(value, index, collection));
	        });
	      }
	      return result;
	    }

	    /**
	     * Iterates over elements of a collection, returning an array of all elements
	     * the callback returns truey for. The callback is bound to `thisArg` and
	     * invoked with three arguments; (value, index|key, collection).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias select
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array} Returns a new array of elements that passed the callback check.
	     * @example
	     *
	     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
	     * // => [2, 4, 6]
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36, 'blocked': false },
	     *   { 'name': 'fred',   'age': 40, 'blocked': true }
	     * ];
	     *
	     * // using "_.pluck" callback shorthand
	     * _.filter(characters, 'blocked');
	     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
	     *
	     * // using "_.where" callback shorthand
	     * _.filter(characters, { 'age': 36 });
	     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
	     */
	    function filter(collection, callback, thisArg) {
	      var result = [];
	      callback = lodash.createCallback(callback, thisArg, 3);

	      if (isArray(collection)) {
	        var index = -1,
	            length = collection.length;

	        while (++index < length) {
	          var value = collection[index];
	          if (callback(value, index, collection)) {
	            result.push(value);
	          }
	        }
	      } else {
	        baseEach(collection, function(value, index, collection) {
	          if (callback(value, index, collection)) {
	            result.push(value);
	          }
	        });
	      }
	      return result;
	    }

	    /**
	     * Iterates over elements of a collection, returning the first element that
	     * the callback returns truey for. The callback is bound to `thisArg` and
	     * invoked with three arguments; (value, index|key, collection).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias detect, findWhere
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {*} Returns the found element, else `undefined`.
	     * @example
	     *
	     * var characters = [
	     *   { 'name': 'barney',  'age': 36, 'blocked': false },
	     *   { 'name': 'fred',    'age': 40, 'blocked': true },
	     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
	     * ];
	     *
	     * _.find(characters, function(chr) {
	     *   return chr.age < 40;
	     * });
	     * // => { 'name': 'barney', 'age': 36, 'blocked': false }
	     *
	     * // using "_.where" callback shorthand
	     * _.find(characters, { 'age': 1 });
	     * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
	     *
	     * // using "_.pluck" callback shorthand
	     * _.find(characters, 'blocked');
	     * // => { 'name': 'fred', 'age': 40, 'blocked': true }
	     */
	    function find(collection, callback, thisArg) {
	      callback = lodash.createCallback(callback, thisArg, 3);

	      if (isArray(collection)) {
	        var index = -1,
	            length = collection.length;

	        while (++index < length) {
	          var value = collection[index];
	          if (callback(value, index, collection)) {
	            return value;
	          }
	        }
	      } else {
	        var result;
	        baseEach(collection, function(value, index, collection) {
	          if (callback(value, index, collection)) {
	            result = value;
	            return false;
	          }
	        });
	        return result;
	      }
	    }

	    /**
	     * This method is like `_.find` except that it iterates over elements
	     * of a `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {*} Returns the found element, else `undefined`.
	     * @example
	     *
	     * _.findLast([1, 2, 3, 4], function(num) {
	     *   return num % 2 == 1;
	     * });
	     * // => 3
	     */
	    function findLast(collection, callback, thisArg) {
	      var result;
	      callback = lodash.createCallback(callback, thisArg, 3);
	      forEachRight(collection, function(value, index, collection) {
	        if (callback(value, index, collection)) {
	          result = value;
	          return false;
	        }
	      });
	      return result;
	    }

	    /**
	     * Iterates over elements of a collection, executing the callback for each
	     * element. The callback is bound to `thisArg` and invoked with three arguments;
	     * (value, index|key, collection). Callbacks may exit iteration early by
	     * explicitly returning `false`.
	     *
	     * Note: As with other "Collections" methods, objects with a `length` property
	     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
	     * may be used for object iteration.
	     *
	     * @static
	     * @memberOf _
	     * @alias each
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [callback=identity] The function called per iteration.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array|Object|string} Returns `collection`.
	     * @example
	     *
	     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
	     * // => logs each number and returns '1,2,3'
	     *
	     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
	     * // => logs each number and returns the object (property order is not guaranteed across environments)
	     */
	    function forEach(collection, callback, thisArg) {
	      if (callback && typeof thisArg == 'undefined' && isArray(collection)) {
	        var index = -1,
	            length = collection.length;

	        while (++index < length) {
	          if (callback(collection[index], index, collection) === false) {
	            break;
	          }
	        }
	      } else {
	        baseEach(collection, callback, thisArg);
	      }
	      return collection;
	    }

	    /**
	     * This method is like `_.forEach` except that it iterates over elements
	     * of a `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @alias eachRight
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [callback=identity] The function called per iteration.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array|Object|string} Returns `collection`.
	     * @example
	     *
	     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
	     * // => logs each number from right to left and returns '3,2,1'
	     */
	    function forEachRight(collection, callback, thisArg) {
	      var iterable = collection,
	          length = collection ? collection.length : 0;

	      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
	      if (isArray(collection)) {
	        while (length--) {
	          if (callback(collection[length], length, collection) === false) {
	            break;
	          }
	        }
	      } else {
	        if (typeof length != 'number') {
	          var props = keys(collection);
	          length = props.length;
	        } else if (support.unindexedChars && isString(collection)) {
	          iterable = collection.split('');
	        }
	        baseEach(collection, function(value, key, collection) {
	          key = props ? props[--length] : --length;
	          return callback(iterable[key], key, collection);
	        });
	      }
	      return collection;
	    }

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of a collection through the callback. The corresponding value
	     * of each key is an array of the elements responsible for generating the key.
	     * The callback is bound to `thisArg` and invoked with three arguments;
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
	     * // => { '4': [4.2], '6': [6.1, 6.4] }
	     *
	     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
	     * // => { '4': [4.2], '6': [6.1, 6.4] }
	     *
	     * // using "_.pluck" callback shorthand
	     * _.groupBy(['one', 'two', 'three'], 'length');
	     * // => { '3': ['one', 'two'], '5': ['three'] }
	     */
	    var groupBy = createAggregator(function(result, value, key) {
	      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
	    });

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of the collection through the given callback. The corresponding
	     * value of each key is the last element responsible for generating the key.
	     * The callback is bound to `thisArg` and invoked with three arguments;
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * var keys = [
	     *   { 'dir': 'left', 'code': 97 },
	     *   { 'dir': 'right', 'code': 100 }
	     * ];
	     *
	     * _.indexBy(keys, 'dir');
	     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
	     *
	     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
	     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
	     *
	     * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
	     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
	     */
	    var indexBy = createAggregator(function(result, value, key) {
	      result[key] = value;
	    });

	    /**
	     * Invokes the method named by `methodName` on each element in the `collection`
	     * returning an array of the results of each invoked method. Additional arguments
	     * will be provided to each invoked method. If `methodName` is a function it
	     * will be invoked for, and `this` bound to, each element in the `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|string} methodName The name of the method to invoke or
	     *  the function invoked per iteration.
	     * @param {...*} [arg] Arguments to invoke the method with.
	     * @returns {Array} Returns a new array of the results of each invoked method.
	     * @example
	     *
	     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
	     * // => [[1, 5, 7], [1, 2, 3]]
	     *
	     * _.invoke([123, 456], String.prototype.split, '');
	     * // => [['1', '2', '3'], ['4', '5', '6']]
	     */
	    function invoke(collection, methodName) {
	      var args = slice(arguments, 2),
	          index = -1,
	          isFunc = typeof methodName == 'function',
	          length = collection ? collection.length : 0,
	          result = Array(typeof length == 'number' ? length : 0);

	      forEach(collection, function(value) {
	        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
	      });
	      return result;
	    }

	    /**
	     * Creates an array of values by running each element in the collection
	     * through the callback. The callback is bound to `thisArg` and invoked with
	     * three arguments; (value, index|key, collection).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias collect
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array} Returns a new array of the results of each `callback` execution.
	     * @example
	     *
	     * _.map([1, 2, 3], function(num) { return num * 3; });
	     * // => [3, 6, 9]
	     *
	     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
	     * // => [3, 6, 9] (property order is not guaranteed across environments)
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36 },
	     *   { 'name': 'fred',   'age': 40 }
	     * ];
	     *
	     * // using "_.pluck" callback shorthand
	     * _.map(characters, 'name');
	     * // => ['barney', 'fred']
	     */
	    function map(collection, callback, thisArg) {
	      var index = -1,
	          length = collection ? collection.length : 0,
	          result = Array(typeof length == 'number' ? length : 0);

	      callback = lodash.createCallback(callback, thisArg, 3);
	      if (isArray(collection)) {
	        while (++index < length) {
	          result[index] = callback(collection[index], index, collection);
	        }
	      } else {
	        baseEach(collection, function(value, key, collection) {
	          result[++index] = callback(value, key, collection);
	        });
	      }
	      return result;
	    }

	    /**
	     * Retrieves the maximum value of a collection. If the collection is empty or
	     * falsey `-Infinity` is returned. If a callback is provided it will be executed
	     * for each value in the collection to generate the criterion by which the value
	     * is ranked. The callback is bound to `thisArg` and invoked with three
	     * arguments; (value, index, collection).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {*} Returns the maximum value.
	     * @example
	     *
	     * _.max([4, 2, 8, 6]);
	     * // => 8
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36 },
	     *   { 'name': 'fred',   'age': 40 }
	     * ];
	     *
	     * _.max(characters, function(chr) { return chr.age; });
	     * // => { 'name': 'fred', 'age': 40 };
	     *
	     * // using "_.pluck" callback shorthand
	     * _.max(characters, 'age');
	     * // => { 'name': 'fred', 'age': 40 };
	     */
	    function max(collection, callback, thisArg) {
	      var computed = -Infinity,
	          result = computed;

	      // allows working with functions like `_.map` without using
	      // their `index` argument as a callback
	      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
	        callback = null;
	      }
	      if (callback == null && isArray(collection)) {
	        var index = -1,
	            length = collection.length;

	        while (++index < length) {
	          var value = collection[index];
	          if (value > result) {
	            result = value;
	          }
	        }
	      } else {
	        callback = (callback == null && isString(collection))
	          ? charAtCallback
	          : lodash.createCallback(callback, thisArg, 3);

	        baseEach(collection, function(value, index, collection) {
	          var current = callback(value, index, collection);
	          if (current > computed) {
	            computed = current;
	            result = value;
	          }
	        });
	      }
	      return result;
	    }

	    /**
	     * Retrieves the minimum value of a collection. If the collection is empty or
	     * falsey `Infinity` is returned. If a callback is provided it will be executed
	     * for each value in the collection to generate the criterion by which the value
	     * is ranked. The callback is bound to `thisArg` and invoked with three
	     * arguments; (value, index, collection).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {*} Returns the minimum value.
	     * @example
	     *
	     * _.min([4, 2, 8, 6]);
	     * // => 2
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36 },
	     *   { 'name': 'fred',   'age': 40 }
	     * ];
	     *
	     * _.min(characters, function(chr) { return chr.age; });
	     * // => { 'name': 'barney', 'age': 36 };
	     *
	     * // using "_.pluck" callback shorthand
	     * _.min(characters, 'age');
	     * // => { 'name': 'barney', 'age': 36 };
	     */
	    function min(collection, callback, thisArg) {
	      var computed = Infinity,
	          result = computed;

	      // allows working with functions like `_.map` without using
	      // their `index` argument as a callback
	      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
	        callback = null;
	      }
	      if (callback == null && isArray(collection)) {
	        var index = -1,
	            length = collection.length;

	        while (++index < length) {
	          var value = collection[index];
	          if (value < result) {
	            result = value;
	          }
	        }
	      } else {
	        callback = (callback == null && isString(collection))
	          ? charAtCallback
	          : lodash.createCallback(callback, thisArg, 3);

	        baseEach(collection, function(value, index, collection) {
	          var current = callback(value, index, collection);
	          if (current < computed) {
	            computed = current;
	            result = value;
	          }
	        });
	      }
	      return result;
	    }

	    /**
	     * Retrieves the value of a specified property from all elements in the collection.
	     *
	     * @static
	     * @memberOf _
	     * @type Function
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {string} property The name of the property to pluck.
	     * @returns {Array} Returns a new array of property values.
	     * @example
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36 },
	     *   { 'name': 'fred',   'age': 40 }
	     * ];
	     *
	     * _.pluck(characters, 'name');
	     * // => ['barney', 'fred']
	     */
	    var pluck = map;

	    /**
	     * Reduces a collection to a value which is the accumulated result of running
	     * each element in the collection through the callback, where each successive
	     * callback execution consumes the return value of the previous execution. If
	     * `accumulator` is not provided the first element of the collection will be
	     * used as the initial `accumulator` value. The callback is bound to `thisArg`
	     * and invoked with four arguments; (accumulator, value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @alias foldl, inject
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [callback=identity] The function called per iteration.
	     * @param {*} [accumulator] Initial value of the accumulator.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * var sum = _.reduce([1, 2, 3], function(sum, num) {
	     *   return sum + num;
	     * });
	     * // => 6
	     *
	     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
	     *   result[key] = num * 3;
	     *   return result;
	     * }, {});
	     * // => { 'a': 3, 'b': 6, 'c': 9 }
	     */
	    function reduce(collection, callback, accumulator, thisArg) {
	      var noaccum = arguments.length < 3;
	      callback = lodash.createCallback(callback, thisArg, 4);

	      if (isArray(collection)) {
	        var index = -1,
	            length = collection.length;

	        if (noaccum) {
	          accumulator = collection[++index];
	        }
	        while (++index < length) {
	          accumulator = callback(accumulator, collection[index], index, collection);
	        }
	      } else {
	        baseEach(collection, function(value, index, collection) {
	          accumulator = noaccum
	            ? (noaccum = false, value)
	            : callback(accumulator, value, index, collection)
	        });
	      }
	      return accumulator;
	    }

	    /**
	     * This method is like `_.reduce` except that it iterates over elements
	     * of a `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @alias foldr
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [callback=identity] The function called per iteration.
	     * @param {*} [accumulator] Initial value of the accumulator.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * var list = [[0, 1], [2, 3], [4, 5]];
	     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
	     * // => [4, 5, 2, 3, 0, 1]
	     */
	    function reduceRight(collection, callback, accumulator, thisArg) {
	      var noaccum = arguments.length < 3;
	      callback = lodash.createCallback(callback, thisArg, 4);
	      forEachRight(collection, function(value, index, collection) {
	        accumulator = noaccum
	          ? (noaccum = false, value)
	          : callback(accumulator, value, index, collection);
	      });
	      return accumulator;
	    }

	    /**
	     * The opposite of `_.filter` this method returns the elements of a
	     * collection that the callback does **not** return truey for.
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array} Returns a new array of elements that failed the callback check.
	     * @example
	     *
	     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
	     * // => [1, 3, 5]
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36, 'blocked': false },
	     *   { 'name': 'fred',   'age': 40, 'blocked': true }
	     * ];
	     *
	     * // using "_.pluck" callback shorthand
	     * _.reject(characters, 'blocked');
	     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
	     *
	     * // using "_.where" callback shorthand
	     * _.reject(characters, { 'age': 36 });
	     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
	     */
	    function reject(collection, callback, thisArg) {
	      callback = lodash.createCallback(callback, thisArg, 3);
	      return filter(collection, function(value, index, collection) {
	        return !callback(value, index, collection);
	      });
	    }

	    /**
	     * Retrieves a random element or `n` random elements from a collection.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to sample.
	     * @param {number} [n] The number of elements to sample.
	     * @param- {Object} [guard] Allows working with functions like `_.map`
	     *  without using their `index` arguments as `n`.
	     * @returns {Array} Returns the random sample(s) of `collection`.
	     * @example
	     *
	     * _.sample([1, 2, 3, 4]);
	     * // => 2
	     *
	     * _.sample([1, 2, 3, 4], 2);
	     * // => [3, 1]
	     */
	    function sample(collection, n, guard) {
	      if (collection && typeof collection.length != 'number') {
	        collection = values(collection);
	      } else if (support.unindexedChars && isString(collection)) {
	        collection = collection.split('');
	      }
	      if (n == null || guard) {
	        return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
	      }
	      var result = shuffle(collection);
	      result.length = nativeMin(nativeMax(0, n), result.length);
	      return result;
	    }

	    /**
	     * Creates an array of shuffled values, using a version of the Fisher-Yates
	     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to shuffle.
	     * @returns {Array} Returns a new shuffled collection.
	     * @example
	     *
	     * _.shuffle([1, 2, 3, 4, 5, 6]);
	     * // => [4, 1, 6, 3, 5, 2]
	     */
	    function shuffle(collection) {
	      var index = -1,
	          length = collection ? collection.length : 0,
	          result = Array(typeof length == 'number' ? length : 0);

	      forEach(collection, function(value) {
	        var rand = baseRandom(0, ++index);
	        result[index] = result[rand];
	        result[rand] = value;
	      });
	      return result;
	    }

	    /**
	     * Gets the size of the `collection` by returning `collection.length` for arrays
	     * and array-like objects or the number of own enumerable properties for objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to inspect.
	     * @returns {number} Returns `collection.length` or number of own enumerable properties.
	     * @example
	     *
	     * _.size([1, 2]);
	     * // => 2
	     *
	     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
	     * // => 3
	     *
	     * _.size('pebbles');
	     * // => 7
	     */
	    function size(collection) {
	      var length = collection ? collection.length : 0;
	      return typeof length == 'number' ? length : keys(collection).length;
	    }

	    /**
	     * Checks if the callback returns a truey value for **any** element of a
	     * collection. The function returns as soon as it finds a passing value and
	     * does not iterate over the entire collection. The callback is bound to
	     * `thisArg` and invoked with three arguments; (value, index|key, collection).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias any
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {boolean} Returns `true` if any element passed the callback check,
	     *  else `false`.
	     * @example
	     *
	     * _.some([null, 0, 'yes', false], Boolean);
	     * // => true
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36, 'blocked': false },
	     *   { 'name': 'fred',   'age': 40, 'blocked': true }
	     * ];
	     *
	     * // using "_.pluck" callback shorthand
	     * _.some(characters, 'blocked');
	     * // => true
	     *
	     * // using "_.where" callback shorthand
	     * _.some(characters, { 'age': 1 });
	     * // => false
	     */
	    function some(collection, callback, thisArg) {
	      var result;
	      callback = lodash.createCallback(callback, thisArg, 3);

	      if (isArray(collection)) {
	        var index = -1,
	            length = collection.length;

	        while (++index < length) {
	          if ((result = callback(collection[index], index, collection))) {
	            break;
	          }
	        }
	      } else {
	        baseEach(collection, function(value, index, collection) {
	          return !(result = callback(value, index, collection));
	        });
	      }
	      return !!result;
	    }

	    /**
	     * Creates an array of elements, sorted in ascending order by the results of
	     * running each element in a collection through the callback. This method
	     * performs a stable sort, that is, it will preserve the original sort order
	     * of equal elements. The callback is bound to `thisArg` and invoked with
	     * three arguments; (value, index|key, collection).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an array of property names is provided for `callback` the collection
	     * will be sorted by each property value.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Array|Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array} Returns a new array of sorted elements.
	     * @example
	     *
	     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
	     * // => [3, 1, 2]
	     *
	     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
	     * // => [3, 1, 2]
	     *
	     * var characters = [
	     *   { 'name': 'barney',  'age': 36 },
	     *   { 'name': 'fred',    'age': 40 },
	     *   { 'name': 'barney',  'age': 26 },
	     *   { 'name': 'fred',    'age': 30 }
	     * ];
	     *
	     * // using "_.pluck" callback shorthand
	     * _.map(_.sortBy(characters, 'age'), _.values);
	     * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
	     *
	     * // sorting by multiple properties
	     * _.map(_.sortBy(characters, ['name', 'age']), _.values);
	     * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
	     */
	    function sortBy(collection, callback, thisArg) {
	      var index = -1,
	          isArr = isArray(callback),
	          length = collection ? collection.length : 0,
	          result = Array(typeof length == 'number' ? length : 0);

	      if (!isArr) {
	        callback = lodash.createCallback(callback, thisArg, 3);
	      }
	      forEach(collection, function(value, key, collection) {
	        var object = result[++index] = getObject();
	        if (isArr) {
	          object.criteria = map(callback, function(key) { return value[key]; });
	        } else {
	          (object.criteria = getArray())[0] = callback(value, key, collection);
	        }
	        object.index = index;
	        object.value = value;
	      });

	      length = result.length;
	      result.sort(compareAscending);
	      while (length--) {
	        var object = result[length];
	        result[length] = object.value;
	        if (!isArr) {
	          releaseArray(object.criteria);
	        }
	        releaseObject(object);
	      }
	      return result;
	    }

	    /**
	     * Converts the `collection` to an array.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to convert.
	     * @returns {Array} Returns the new converted array.
	     * @example
	     *
	     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
	     * // => [2, 3, 4]
	     */
	    function toArray(collection) {
	      if (collection && typeof collection.length == 'number') {
	        return (support.unindexedChars && isString(collection))
	          ? collection.split('')
	          : slice(collection);
	      }
	      return values(collection);
	    }

	    /**
	     * Performs a deep comparison of each element in a `collection` to the given
	     * `properties` object, returning an array of all elements that have equivalent
	     * property values.
	     *
	     * @static
	     * @memberOf _
	     * @type Function
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Object} props The object of property values to filter by.
	     * @returns {Array} Returns a new array of elements that have the given properties.
	     * @example
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
	     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
	     * ];
	     *
	     * _.where(characters, { 'age': 36 });
	     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
	     *
	     * _.where(characters, { 'pets': ['dino'] });
	     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
	     */
	    var where = filter;

	    /*--------------------------------------------------------------------------*/

	    /**
	     * Creates an array with all falsey values removed. The values `false`, `null`,
	     * `0`, `""`, `undefined`, and `NaN` are all falsey.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to compact.
	     * @returns {Array} Returns a new array of filtered values.
	     * @example
	     *
	     * _.compact([0, 1, false, 2, '', 3]);
	     * // => [1, 2, 3]
	     */
	    function compact(array) {
	      var index = -1,
	          length = array ? array.length : 0,
	          result = [];

	      while (++index < length) {
	        var value = array[index];
	        if (value) {
	          result.push(value);
	        }
	      }
	      return result;
	    }

	    /**
	     * Creates an array excluding all values of the provided arrays using strict
	     * equality for comparisons, i.e. `===`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to process.
	     * @param {...Array} [values] The arrays of values to exclude.
	     * @returns {Array} Returns a new array of filtered values.
	     * @example
	     *
	     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
	     * // => [1, 3, 4]
	     */
	    function difference(array) {
	      return baseDifference(array, baseFlatten(arguments, true, true, 1));
	    }

	    /**
	     * This method is like `_.find` except that it returns the index of the first
	     * element that passes the callback check, instead of the element itself.
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to search.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var characters = [
	     *   { 'name': 'barney',  'age': 36, 'blocked': false },
	     *   { 'name': 'fred',    'age': 40, 'blocked': true },
	     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
	     * ];
	     *
	     * _.findIndex(characters, function(chr) {
	     *   return chr.age < 20;
	     * });
	     * // => 2
	     *
	     * // using "_.where" callback shorthand
	     * _.findIndex(characters, { 'age': 36 });
	     * // => 0
	     *
	     * // using "_.pluck" callback shorthand
	     * _.findIndex(characters, 'blocked');
	     * // => 1
	     */
	    function findIndex(array, callback, thisArg) {
	      var index = -1,
	          length = array ? array.length : 0;

	      callback = lodash.createCallback(callback, thisArg, 3);
	      while (++index < length) {
	        if (callback(array[index], index, array)) {
	          return index;
	        }
	      }
	      return -1;
	    }

	    /**
	     * This method is like `_.findIndex` except that it iterates over elements
	     * of a `collection` from right to left.
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to search.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var characters = [
	     *   { 'name': 'barney',  'age': 36, 'blocked': true },
	     *   { 'name': 'fred',    'age': 40, 'blocked': false },
	     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }
	     * ];
	     *
	     * _.findLastIndex(characters, function(chr) {
	     *   return chr.age > 30;
	     * });
	     * // => 1
	     *
	     * // using "_.where" callback shorthand
	     * _.findLastIndex(characters, { 'age': 36 });
	     * // => 0
	     *
	     * // using "_.pluck" callback shorthand
	     * _.findLastIndex(characters, 'blocked');
	     * // => 2
	     */
	    function findLastIndex(array, callback, thisArg) {
	      var length = array ? array.length : 0;
	      callback = lodash.createCallback(callback, thisArg, 3);
	      while (length--) {
	        if (callback(array[length], length, array)) {
	          return length;
	        }
	      }
	      return -1;
	    }

	    /**
	     * Gets the first element or first `n` elements of an array. If a callback
	     * is provided elements at the beginning of the array are returned as long
	     * as the callback returns truey. The callback is bound to `thisArg` and
	     * invoked with three arguments; (value, index, array).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias head, take
	     * @category Arrays
	     * @param {Array} array The array to query.
	     * @param {Function|Object|number|string} [callback] The function called
	     *  per element or the number of elements to return. If a property name or
	     *  object is provided it will be used to create a "_.pluck" or "_.where"
	     *  style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {*} Returns the first element(s) of `array`.
	     * @example
	     *
	     * _.first([1, 2, 3]);
	     * // => 1
	     *
	     * _.first([1, 2, 3], 2);
	     * // => [1, 2]
	     *
	     * _.first([1, 2, 3], function(num) {
	     *   return num < 3;
	     * });
	     * // => [1, 2]
	     *
	     * var characters = [
	     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
	     *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
	     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
	     * ];
	     *
	     * // using "_.pluck" callback shorthand
	     * _.first(characters, 'blocked');
	     * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
	     *
	     * // using "_.where" callback shorthand
	     * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
	     * // => ['barney', 'fred']
	     */
	    function first(array, callback, thisArg) {
	      var n = 0,
	          length = array ? array.length : 0;

	      if (typeof callback != 'number' && callback != null) {
	        var index = -1;
	        callback = lodash.createCallback(callback, thisArg, 3);
	        while (++index < length && callback(array[index], index, array)) {
	          n++;
	        }
	      } else {
	        n = callback;
	        if (n == null || thisArg) {
	          return array ? array[0] : undefined;
	        }
	      }
	      return slice(array, 0, nativeMin(nativeMax(0, n), length));
	    }

	    /**
	     * Flattens a nested array (the nesting can be to any depth). If `isShallow`
	     * is truey, the array will only be flattened a single level. If a callback
	     * is provided each element of the array is passed through the callback before
	     * flattening. The callback is bound to `thisArg` and invoked with three
	     * arguments; (value, index, array).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to flatten.
	     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array} Returns a new flattened array.
	     * @example
	     *
	     * _.flatten([1, [2], [3, [[4]]]]);
	     * // => [1, 2, 3, 4];
	     *
	     * _.flatten([1, [2], [3, [[4]]]], true);
	     * // => [1, 2, 3, [[4]]];
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
	     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
	     * ];
	     *
	     * // using "_.pluck" callback shorthand
	     * _.flatten(characters, 'pets');
	     * // => ['hoppy', 'baby puss', 'dino']
	     */
	    function flatten(array, isShallow, callback, thisArg) {
	      // juggle arguments
	      if (typeof isShallow != 'boolean' && isShallow != null) {
	        thisArg = callback;
	        callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
	        isShallow = false;
	      }
	      if (callback != null) {
	        array = map(array, callback, thisArg);
	      }
	      return baseFlatten(array, isShallow);
	    }

	    /**
	     * Gets the index at which the first occurrence of `value` is found using
	     * strict equality for comparisons, i.e. `===`. If the array is already sorted
	     * providing `true` for `fromIndex` will run a faster binary search.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to search.
	     * @param {*} value The value to search for.
	     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
	     *  to perform a binary search on a sorted array.
	     * @returns {number} Returns the index of the matched value or `-1`.
	     * @example
	     *
	     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
	     * // => 1
	     *
	     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
	     * // => 4
	     *
	     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
	     * // => 2
	     */
	    function indexOf(array, value, fromIndex) {
	      if (typeof fromIndex == 'number') {
	        var length = array ? array.length : 0;
	        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
	      } else if (fromIndex) {
	        var index = sortedIndex(array, value);
	        return array[index] === value ? index : -1;
	      }
	      return baseIndexOf(array, value, fromIndex);
	    }

	    /**
	     * Gets all but the last element or last `n` elements of an array. If a
	     * callback is provided elements at the end of the array are excluded from
	     * the result as long as the callback returns truey. The callback is bound
	     * to `thisArg` and invoked with three arguments; (value, index, array).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to query.
	     * @param {Function|Object|number|string} [callback=1] The function called
	     *  per element or the number of elements to exclude. If a property name or
	     *  object is provided it will be used to create a "_.pluck" or "_.where"
	     *  style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array} Returns a slice of `array`.
	     * @example
	     *
	     * _.initial([1, 2, 3]);
	     * // => [1, 2]
	     *
	     * _.initial([1, 2, 3], 2);
	     * // => [1]
	     *
	     * _.initial([1, 2, 3], function(num) {
	     *   return num > 1;
	     * });
	     * // => [1]
	     *
	     * var characters = [
	     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
	     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
	     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
	     * ];
	     *
	     * // using "_.pluck" callback shorthand
	     * _.initial(characters, 'blocked');
	     * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
	     *
	     * // using "_.where" callback shorthand
	     * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
	     * // => ['barney', 'fred']
	     */
	    function initial(array, callback, thisArg) {
	      var n = 0,
	          length = array ? array.length : 0;

	      if (typeof callback != 'number' && callback != null) {
	        var index = length;
	        callback = lodash.createCallback(callback, thisArg, 3);
	        while (index-- && callback(array[index], index, array)) {
	          n++;
	        }
	      } else {
	        n = (callback == null || thisArg) ? 1 : callback || n;
	      }
	      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
	    }

	    /**
	     * Creates an array of unique values present in all provided arrays using
	     * strict equality for comparisons, i.e. `===`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {...Array} [array] The arrays to inspect.
	     * @returns {Array} Returns an array of shared values.
	     * @example
	     *
	     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
	     * // => [1, 2]
	     */
	    function intersection() {
	      var args = [],
	          argsIndex = -1,
	          argsLength = arguments.length,
	          caches = getArray(),
	          indexOf = getIndexOf(),
	          trustIndexOf = indexOf === baseIndexOf,
	          seen = getArray();

	      while (++argsIndex < argsLength) {
	        var value = arguments[argsIndex];
	        if (isArray(value) || isArguments(value)) {
	          args.push(value);
	          caches.push(trustIndexOf && value.length >= largeArraySize &&
	            createCache(argsIndex ? args[argsIndex] : seen));
	        }
	      }
	      var array = args[0],
	          index = -1,
	          length = array ? array.length : 0,
	          result = [];

	      outer:
	      while (++index < length) {
	        var cache = caches[0];
	        value = array[index];

	        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
	          argsIndex = argsLength;
	          (cache || seen).push(value);
	          while (--argsIndex) {
	            cache = caches[argsIndex];
	            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
	              continue outer;
	            }
	          }
	          result.push(value);
	        }
	      }
	      while (argsLength--) {
	        cache = caches[argsLength];
	        if (cache) {
	          releaseObject(cache);
	        }
	      }
	      releaseArray(caches);
	      releaseArray(seen);
	      return result;
	    }

	    /**
	     * Gets the last element or last `n` elements of an array. If a callback is
	     * provided elements at the end of the array are returned as long as the
	     * callback returns truey. The callback is bound to `thisArg` and invoked
	     * with three arguments; (value, index, array).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to query.
	     * @param {Function|Object|number|string} [callback] The function called
	     *  per element or the number of elements to return. If a property name or
	     *  object is provided it will be used to create a "_.pluck" or "_.where"
	     *  style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {*} Returns the last element(s) of `array`.
	     * @example
	     *
	     * _.last([1, 2, 3]);
	     * // => 3
	     *
	     * _.last([1, 2, 3], 2);
	     * // => [2, 3]
	     *
	     * _.last([1, 2, 3], function(num) {
	     *   return num > 1;
	     * });
	     * // => [2, 3]
	     *
	     * var characters = [
	     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
	     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
	     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
	     * ];
	     *
	     * // using "_.pluck" callback shorthand
	     * _.pluck(_.last(characters, 'blocked'), 'name');
	     * // => ['fred', 'pebbles']
	     *
	     * // using "_.where" callback shorthand
	     * _.last(characters, { 'employer': 'na' });
	     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
	     */
	    function last(array, callback, thisArg) {
	      var n = 0,
	          length = array ? array.length : 0;

	      if (typeof callback != 'number' && callback != null) {
	        var index = length;
	        callback = lodash.createCallback(callback, thisArg, 3);
	        while (index-- && callback(array[index], index, array)) {
	          n++;
	        }
	      } else {
	        n = callback;
	        if (n == null || thisArg) {
	          return array ? array[length - 1] : undefined;
	        }
	      }
	      return slice(array, nativeMax(0, length - n));
	    }

	    /**
	     * Gets the index at which the last occurrence of `value` is found using strict
	     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
	     * as the offset from the end of the collection.
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to search.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=array.length-1] The index to search from.
	     * @returns {number} Returns the index of the matched value or `-1`.
	     * @example
	     *
	     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
	     * // => 4
	     *
	     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
	     * // => 1
	     */
	    function lastIndexOf(array, value, fromIndex) {
	      var index = array ? array.length : 0;
	      if (typeof fromIndex == 'number') {
	        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
	      }
	      while (index--) {
	        if (array[index] === value) {
	          return index;
	        }
	      }
	      return -1;
	    }

	    /**
	     * Removes all provided values from the given array using strict equality for
	     * comparisons, i.e. `===`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to modify.
	     * @param {...*} [value] The values to remove.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3, 1, 2, 3];
	     * _.pull(array, 2, 3);
	     * console.log(array);
	     * // => [1, 1]
	     */
	    function pull(array) {
	      var args = arguments,
	          argsIndex = 0,
	          argsLength = args.length,
	          length = array ? array.length : 0;

	      while (++argsIndex < argsLength) {
	        var index = -1,
	            value = args[argsIndex];
	        while (++index < length) {
	          if (array[index] === value) {
	            splice.call(array, index--, 1);
	            length--;
	          }
	        }
	      }
	      return array;
	    }

	    /**
	     * Creates an array of numbers (positive and/or negative) progressing from
	     * `start` up to but not including `end`. If `start` is less than `stop` a
	     * zero-length range is created unless a negative `step` is specified.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} [step=1] The value to increment or decrement by.
	     * @returns {Array} Returns a new range array.
	     * @example
	     *
	     * _.range(4);
	     * // => [0, 1, 2, 3]
	     *
	     * _.range(1, 5);
	     * // => [1, 2, 3, 4]
	     *
	     * _.range(0, 20, 5);
	     * // => [0, 5, 10, 15]
	     *
	     * _.range(0, -4, -1);
	     * // => [0, -1, -2, -3]
	     *
	     * _.range(1, 4, 0);
	     * // => [1, 1, 1]
	     *
	     * _.range(0);
	     * // => []
	     */
	    function range(start, end, step) {
	      start = +start || 0;
	      step = typeof step == 'number' ? step : (+step || 1);

	      if (end == null) {
	        end = start;
	        start = 0;
	      }
	      // use `Array(length)` so engines like Chakra and V8 avoid slower modes
	      // http://youtu.be/XAqIpGU8ZZk#t=17m25s
	      var index = -1,
	          length = nativeMax(0, ceil((end - start) / (step || 1))),
	          result = Array(length);

	      while (++index < length) {
	        result[index] = start;
	        start += step;
	      }
	      return result;
	    }

	    /**
	     * Removes all elements from an array that the callback returns truey for
	     * and returns an array of removed elements. The callback is bound to `thisArg`
	     * and invoked with three arguments; (value, index, array).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to modify.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array} Returns a new array of removed elements.
	     * @example
	     *
	     * var array = [1, 2, 3, 4, 5, 6];
	     * var evens = _.remove(array, function(num) { return num % 2 == 0; });
	     *
	     * console.log(array);
	     * // => [1, 3, 5]
	     *
	     * console.log(evens);
	     * // => [2, 4, 6]
	     */
	    function remove(array, callback, thisArg) {
	      var index = -1,
	          length = array ? array.length : 0,
	          result = [];

	      callback = lodash.createCallback(callback, thisArg, 3);
	      while (++index < length) {
	        var value = array[index];
	        if (callback(value, index, array)) {
	          result.push(value);
	          splice.call(array, index--, 1);
	          length--;
	        }
	      }
	      return result;
	    }

	    /**
	     * The opposite of `_.initial` this method gets all but the first element or
	     * first `n` elements of an array. If a callback function is provided elements
	     * at the beginning of the array are excluded from the result as long as the
	     * callback returns truey. The callback is bound to `thisArg` and invoked
	     * with three arguments; (value, index, array).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias drop, tail
	     * @category Arrays
	     * @param {Array} array The array to query.
	     * @param {Function|Object|number|string} [callback=1] The function called
	     *  per element or the number of elements to exclude. If a property name or
	     *  object is provided it will be used to create a "_.pluck" or "_.where"
	     *  style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array} Returns a slice of `array`.
	     * @example
	     *
	     * _.rest([1, 2, 3]);
	     * // => [2, 3]
	     *
	     * _.rest([1, 2, 3], 2);
	     * // => [3]
	     *
	     * _.rest([1, 2, 3], function(num) {
	     *   return num < 3;
	     * });
	     * // => [3]
	     *
	     * var characters = [
	     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
	     *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
	     *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
	     * ];
	     *
	     * // using "_.pluck" callback shorthand
	     * _.pluck(_.rest(characters, 'blocked'), 'name');
	     * // => ['fred', 'pebbles']
	     *
	     * // using "_.where" callback shorthand
	     * _.rest(characters, { 'employer': 'slate' });
	     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
	     */
	    function rest(array, callback, thisArg) {
	      if (typeof callback != 'number' && callback != null) {
	        var n = 0,
	            index = -1,
	            length = array ? array.length : 0;

	        callback = lodash.createCallback(callback, thisArg, 3);
	        while (++index < length && callback(array[index], index, array)) {
	          n++;
	        }
	      } else {
	        n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
	      }
	      return slice(array, n);
	    }

	    /**
	     * Uses a binary search to determine the smallest index at which a value
	     * should be inserted into a given sorted array in order to maintain the sort
	     * order of the array. If a callback is provided it will be executed for
	     * `value` and each element of `array` to compute their sort ranking. The
	     * callback is bound to `thisArg` and invoked with one argument; (value).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedIndex([20, 30, 50], 40);
	     * // => 2
	     *
	     * // using "_.pluck" callback shorthand
	     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
	     * // => 2
	     *
	     * var dict = {
	     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
	     * };
	     *
	     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
	     *   return dict.wordToNumber[word];
	     * });
	     * // => 2
	     *
	     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
	     *   return this.wordToNumber[word];
	     * }, dict);
	     * // => 2
	     */
	    function sortedIndex(array, value, callback, thisArg) {
	      var low = 0,
	          high = array ? array.length : low;

	      // explicitly reference `identity` for better inlining in Firefox
	      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
	      value = callback(value);

	      while (low < high) {
	        var mid = (low + high) >>> 1;
	        (callback(array[mid]) < value)
	          ? low = mid + 1
	          : high = mid;
	      }
	      return low;
	    }

	    /**
	     * Creates an array of unique values, in order, of the provided arrays using
	     * strict equality for comparisons, i.e. `===`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {...Array} [array] The arrays to inspect.
	     * @returns {Array} Returns an array of combined values.
	     * @example
	     *
	     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
	     * // => [1, 2, 3, 5, 4]
	     */
	    function union() {
	      return baseUniq(baseFlatten(arguments, true, true));
	    }

	    /**
	     * Creates a duplicate-value-free version of an array using strict equality
	     * for comparisons, i.e. `===`. If the array is sorted, providing
	     * `true` for `isSorted` will use a faster algorithm. If a callback is provided
	     * each element of `array` is passed through the callback before uniqueness
	     * is computed. The callback is bound to `thisArg` and invoked with three
	     * arguments; (value, index, array).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias unique
	     * @category Arrays
	     * @param {Array} array The array to process.
	     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array} Returns a duplicate-value-free array.
	     * @example
	     *
	     * _.uniq([1, 2, 1, 3, 1]);
	     * // => [1, 2, 3]
	     *
	     * _.uniq([1, 1, 2, 2, 3], true);
	     * // => [1, 2, 3]
	     *
	     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
	     * // => ['A', 'b', 'C']
	     *
	     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
	     * // => [1, 2.5, 3]
	     *
	     * // using "_.pluck" callback shorthand
	     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }, { 'x': 2 }]
	     */
	    function uniq(array, isSorted, callback, thisArg) {
	      // juggle arguments
	      if (typeof isSorted != 'boolean' && isSorted != null) {
	        thisArg = callback;
	        callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
	        isSorted = false;
	      }
	      if (callback != null) {
	        callback = lodash.createCallback(callback, thisArg, 3);
	      }
	      return baseUniq(array, isSorted, callback);
	    }

	    /**
	     * Creates an array excluding all provided values using strict equality for
	     * comparisons, i.e. `===`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to filter.
	     * @param {...*} [value] The values to exclude.
	     * @returns {Array} Returns a new array of filtered values.
	     * @example
	     *
	     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
	     * // => [2, 3, 4]
	     */
	    function without(array) {
	      return baseDifference(array, slice(arguments, 1));
	    }

	    /**
	     * Creates an array that is the symmetric difference of the provided arrays.
	     * See http://en.wikipedia.org/wiki/Symmetric_difference.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {...Array} [array] The arrays to inspect.
	     * @returns {Array} Returns an array of values.
	     * @example
	     *
	     * _.xor([1, 2, 3], [5, 2, 1, 4]);
	     * // => [3, 5, 4]
	     *
	     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
	     * // => [1, 4, 5]
	     */
	    function xor() {
	      var index = -1,
	          length = arguments.length;

	      while (++index < length) {
	        var array = arguments[index];
	        if (isArray(array) || isArguments(array)) {
	          var result = result
	            ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))
	            : array;
	        }
	      }
	      return result || [];
	    }

	    /**
	     * Creates an array of grouped elements, the first of which contains the first
	     * elements of the given arrays, the second of which contains the second
	     * elements of the given arrays, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @alias unzip
	     * @category Arrays
	     * @param {...Array} [array] Arrays to process.
	     * @returns {Array} Returns a new array of grouped elements.
	     * @example
	     *
	     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
	     * // => [['fred', 30, true], ['barney', 40, false]]
	     */
	    function zip() {
	      var array = arguments.length > 1 ? arguments : arguments[0],
	          index = -1,
	          length = array ? max(pluck(array, 'length')) : 0,
	          result = Array(length < 0 ? 0 : length);

	      while (++index < length) {
	        result[index] = pluck(array, index);
	      }
	      return result;
	    }

	    /**
	     * Creates an object composed from arrays of `keys` and `values`. Provide
	     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
	     * or two arrays, one of `keys` and one of corresponding `values`.
	     *
	     * @static
	     * @memberOf _
	     * @alias object
	     * @category Arrays
	     * @param {Array} keys The array of keys.
	     * @param {Array} [values=[]] The array of values.
	     * @returns {Object} Returns an object composed of the given keys and
	     *  corresponding values.
	     * @example
	     *
	     * _.zipObject(['fred', 'barney'], [30, 40]);
	     * // => { 'fred': 30, 'barney': 40 }
	     */
	    function zipObject(keys, values) {
	      var index = -1,
	          length = keys ? keys.length : 0,
	          result = {};

	      if (!values && length && !isArray(keys[0])) {
	        values = [];
	      }
	      while (++index < length) {
	        var key = keys[index];
	        if (values) {
	          result[key] = values[index];
	        } else if (key) {
	          result[key[0]] = key[1];
	        }
	      }
	      return result;
	    }

	    /*--------------------------------------------------------------------------*/

	    /**
	     * Creates a function that executes `func`, with  the `this` binding and
	     * arguments of the created function, only after being called `n` times.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {number} n The number of times the function must be called before
	     *  `func` is executed.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var saves = ['profile', 'settings'];
	     *
	     * var done = _.after(saves.length, function() {
	     *   console.log('Done saving!');
	     * });
	     *
	     * _.forEach(saves, function(type) {
	     *   asyncSave({ 'type': type, 'complete': done });
	     * });
	     * // => logs 'Done saving!', after all saves have completed
	     */
	    function after(n, func) {
	      if (!isFunction(func)) {
	        throw new TypeError;
	      }
	      return function() {
	        if (--n < 1) {
	          return func.apply(this, arguments);
	        }
	      };
	    }

	    /**
	     * Creates a function that, when called, invokes `func` with the `this`
	     * binding of `thisArg` and prepends any additional `bind` arguments to those
	     * provided to the bound function.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {Function} func The function to bind.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {...*} [arg] Arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * var func = function(greeting) {
	     *   return greeting + ' ' + this.name;
	     * };
	     *
	     * func = _.bind(func, { 'name': 'fred' }, 'hi');
	     * func();
	     * // => 'hi fred'
	     */
	    function bind(func, thisArg) {
	      return arguments.length > 2
	        ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
	        : createWrapper(func, 1, null, null, thisArg);
	    }

	    /**
	     * Binds methods of an object to the object itself, overwriting the existing
	     * method. Method names may be specified as individual arguments or as arrays
	     * of method names. If no method names are provided all the function properties
	     * of `object` will be bound.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {Object} object The object to bind and assign the bound methods to.
	     * @param {...string} [methodName] The object method names to
	     *  bind, specified as individual method names or arrays of method names.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var view = {
	     *   'label': 'docs',
	     *   'onClick': function() { console.log('clicked ' + this.label); }
	     * };
	     *
	     * _.bindAll(view);
	     * jQuery('#docs').on('click', view.onClick);
	     * // => logs 'clicked docs', when the button is clicked
	     */
	    function bindAll(object) {
	      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
	          index = -1,
	          length = funcs.length;

	      while (++index < length) {
	        var key = funcs[index];
	        object[key] = createWrapper(object[key], 1, null, null, object);
	      }
	      return object;
	    }

	    /**
	     * Creates a function that, when called, invokes the method at `object[key]`
	     * and prepends any additional `bindKey` arguments to those provided to the bound
	     * function. This method differs from `_.bind` by allowing bound functions to
	     * reference methods that will be redefined or don't yet exist.
	     * See http://michaux.ca/articles/lazy-function-definition-pattern.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {Object} object The object the method belongs to.
	     * @param {string} key The key of the method.
	     * @param {...*} [arg] Arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * var object = {
	     *   'name': 'fred',
	     *   'greet': function(greeting) {
	     *     return greeting + ' ' + this.name;
	     *   }
	     * };
	     *
	     * var func = _.bindKey(object, 'greet', 'hi');
	     * func();
	     * // => 'hi fred'
	     *
	     * object.greet = function(greeting) {
	     *   return greeting + 'ya ' + this.name + '!';
	     * };
	     *
	     * func();
	     * // => 'hiya fred!'
	     */
	    function bindKey(object, key) {
	      return arguments.length > 2
	        ? createWrapper(key, 19, slice(arguments, 2), null, object)
	        : createWrapper(key, 3, null, null, object);
	    }

	    /**
	     * Creates a function that is the composition of the provided functions,
	     * where each function consumes the return value of the function that follows.
	     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
	     * Each function is executed with the `this` binding of the composed function.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {...Function} [func] Functions to compose.
	     * @returns {Function} Returns the new composed function.
	     * @example
	     *
	     * var realNameMap = {
	     *   'pebbles': 'penelope'
	     * };
	     *
	     * var format = function(name) {
	     *   name = realNameMap[name.toLowerCase()] || name;
	     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
	     * };
	     *
	     * var greet = function(formatted) {
	     *   return 'Hiya ' + formatted + '!';
	     * };
	     *
	     * var welcome = _.compose(greet, format);
	     * welcome('pebbles');
	     * // => 'Hiya Penelope!'
	     */
	    function compose() {
	      var funcs = arguments,
	          length = funcs.length;

	      while (length--) {
	        if (!isFunction(funcs[length])) {
	          throw new TypeError;
	        }
	      }
	      return function() {
	        var args = arguments,
	            length = funcs.length;

	        while (length--) {
	          args = [funcs[length].apply(this, args)];
	        }
	        return args[0];
	      };
	    }

	    /**
	     * Creates a function which accepts one or more arguments of `func` that when
	     * invoked either executes `func` returning its result, if all `func` arguments
	     * have been provided, or returns a function that accepts one or more of the
	     * remaining `func` arguments, and so on. The arity of `func` can be specified
	     * if `func.length` is not sufficient.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var curried = _.curry(function(a, b, c) {
	     *   console.log(a + b + c);
	     * });
	     *
	     * curried(1)(2)(3);
	     * // => 6
	     *
	     * curried(1, 2)(3);
	     * // => 6
	     *
	     * curried(1, 2, 3);
	     * // => 6
	     */
	    function curry(func, arity) {
	      arity = typeof arity == 'number' ? arity : (+arity || func.length);
	      return createWrapper(func, 4, null, null, null, arity);
	    }

	    /**
	     * Creates a function that will delay the execution of `func` until after
	     * `wait` milliseconds have elapsed since the last time it was invoked.
	     * Provide an options object to indicate that `func` should be invoked on
	     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
	     * to the debounced function will return the result of the last `func` call.
	     *
	     * Note: If `leading` and `trailing` options are `true` `func` will be called
	     * on the trailing edge of the timeout only if the the debounced function is
	     * invoked more than once during the `wait` timeout.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {Function} func The function to debounce.
	     * @param {number} wait The number of milliseconds to delay.
	     * @param {Object} [options] The options object.
	     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
	     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
	     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
	     * @returns {Function} Returns the new debounced function.
	     * @example
	     *
	     * // avoid costly calculations while the window size is in flux
	     * var lazyLayout = _.debounce(calculateLayout, 150);
	     * jQuery(window).on('resize', lazyLayout);
	     *
	     * // execute `sendMail` when the click event is fired, debouncing subsequent calls
	     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
	     *   'leading': true,
	     *   'trailing': false
	     * });
	     *
	     * // ensure `batchLog` is executed once after 1 second of debounced calls
	     * var source = new EventSource('/stream');
	     * source.addEventListener('message', _.debounce(batchLog, 250, {
	     *   'maxWait': 1000
	     * }, false);
	     */
	    function debounce(func, wait, options) {
	      var args,
	          maxTimeoutId,
	          result,
	          stamp,
	          thisArg,
	          timeoutId,
	          trailingCall,
	          lastCalled = 0,
	          maxWait = false,
	          trailing = true;

	      if (!isFunction(func)) {
	        throw new TypeError;
	      }
	      wait = nativeMax(0, wait) || 0;
	      if (options === true) {
	        var leading = true;
	        trailing = false;
	      } else if (isObject(options)) {
	        leading = options.leading;
	        maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
	        trailing = 'trailing' in options ? options.trailing : trailing;
	      }
	      var delayed = function() {
	        var remaining = wait - (now() - stamp);
	        if (remaining <= 0) {
	          if (maxTimeoutId) {
	            clearTimeout(maxTimeoutId);
	          }
	          var isCalled = trailingCall;
	          maxTimeoutId = timeoutId = trailingCall = undefined;
	          if (isCalled) {
	            lastCalled = now();
	            result = func.apply(thisArg, args);
	            if (!timeoutId && !maxTimeoutId) {
	              args = thisArg = null;
	            }
	          }
	        } else {
	          timeoutId = setTimeout(delayed, remaining);
	        }
	      };

	      var maxDelayed = function() {
	        if (timeoutId) {
	          clearTimeout(timeoutId);
	        }
	        maxTimeoutId = timeoutId = trailingCall = undefined;
	        if (trailing || (maxWait !== wait)) {
	          lastCalled = now();
	          result = func.apply(thisArg, args);
	          if (!timeoutId && !maxTimeoutId) {
	            args = thisArg = null;
	          }
	        }
	      };

	      return function() {
	        args = arguments;
	        stamp = now();
	        thisArg = this;
	        trailingCall = trailing && (timeoutId || !leading);

	        if (maxWait === false) {
	          var leadingCall = leading && !timeoutId;
	        } else {
	          if (!maxTimeoutId && !leading) {
	            lastCalled = stamp;
	          }
	          var remaining = maxWait - (stamp - lastCalled),
	              isCalled = remaining <= 0;

	          if (isCalled) {
	            if (maxTimeoutId) {
	              maxTimeoutId = clearTimeout(maxTimeoutId);
	            }
	            lastCalled = stamp;
	            result = func.apply(thisArg, args);
	          }
	          else if (!maxTimeoutId) {
	            maxTimeoutId = setTimeout(maxDelayed, remaining);
	          }
	        }
	        if (isCalled && timeoutId) {
	          timeoutId = clearTimeout(timeoutId);
	        }
	        else if (!timeoutId && wait !== maxWait) {
	          timeoutId = setTimeout(delayed, wait);
	        }
	        if (leadingCall) {
	          isCalled = true;
	          result = func.apply(thisArg, args);
	        }
	        if (isCalled && !timeoutId && !maxTimeoutId) {
	          args = thisArg = null;
	        }
	        return result;
	      };
	    }

	    /**
	     * Defers executing the `func` function until the current call stack has cleared.
	     * Additional arguments will be provided to `func` when it is invoked.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {Function} func The function to defer.
	     * @param {...*} [arg] Arguments to invoke the function with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.defer(function(text) { console.log(text); }, 'deferred');
	     * // logs 'deferred' after one or more milliseconds
	     */
	    function defer(func) {
	      if (!isFunction(func)) {
	        throw new TypeError;
	      }
	      var args = slice(arguments, 1);
	      return setTimeout(function() { func.apply(undefined, args); }, 1);
	    }

	    /**
	     * Executes the `func` function after `wait` milliseconds. Additional arguments
	     * will be provided to `func` when it is invoked.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay execution.
	     * @param {...*} [arg] Arguments to invoke the function with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.delay(function(text) { console.log(text); }, 1000, 'later');
	     * // => logs 'later' after one second
	     */
	    function delay(func, wait) {
	      if (!isFunction(func)) {
	        throw new TypeError;
	      }
	      var args = slice(arguments, 2);
	      return setTimeout(function() { func.apply(undefined, args); }, wait);
	    }

	    /**
	     * Creates a function that memoizes the result of `func`. If `resolver` is
	     * provided it will be used to determine the cache key for storing the result
	     * based on the arguments provided to the memoized function. By default, the
	     * first argument provided to the memoized function is used as the cache key.
	     * The `func` is executed with the `this` binding of the memoized function.
	     * The result cache is exposed as the `cache` property on the memoized function.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {Function} func The function to have its output memoized.
	     * @param {Function} [resolver] A function used to resolve the cache key.
	     * @returns {Function} Returns the new memoizing function.
	     * @example
	     *
	     * var fibonacci = _.memoize(function(n) {
	     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
	     * });
	     *
	     * fibonacci(9)
	     * // => 34
	     *
	     * var data = {
	     *   'fred': { 'name': 'fred', 'age': 40 },
	     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
	     * };
	     *
	     * // modifying the result cache
	     * var get = _.memoize(function(name) { return data[name]; }, _.identity);
	     * get('pebbles');
	     * // => { 'name': 'pebbles', 'age': 1 }
	     *
	     * get.cache.pebbles.name = 'penelope';
	     * get('pebbles');
	     * // => { 'name': 'penelope', 'age': 1 }
	     */
	    function memoize(func, resolver) {
	      if (!isFunction(func)) {
	        throw new TypeError;
	      }
	      var memoized = function() {
	        var cache = memoized.cache,
	            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];

	        return hasOwnProperty.call(cache, key)
	          ? cache[key]
	          : (cache[key] = func.apply(this, arguments));
	      }
	      memoized.cache = {};
	      return memoized;
	    }

	    /**
	     * Creates a function that is restricted to execute `func` once. Repeat calls to
	     * the function will return the value of the first call. The `func` is executed
	     * with the `this` binding of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var initialize = _.once(createApplication);
	     * initialize();
	     * initialize();
	     * // `initialize` executes `createApplication` once
	     */
	    function once(func) {
	      var ran,
	          result;

	      if (!isFunction(func)) {
	        throw new TypeError;
	      }
	      return function() {
	        if (ran) {
	          return result;
	        }
	        ran = true;
	        result = func.apply(this, arguments);

	        // clear the `func` variable so the function may be garbage collected
	        func = null;
	        return result;
	      };
	    }

	    /**
	     * Creates a function that, when called, invokes `func` with any additional
	     * `partial` arguments prepended to those provided to the new function. This
	     * method is similar to `_.bind` except it does **not** alter the `this` binding.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [arg] Arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * var greet = function(greeting, name) { return greeting + ' ' + name; };
	     * var hi = _.partial(greet, 'hi');
	     * hi('fred');
	     * // => 'hi fred'
	     */
	    function partial(func) {
	      return createWrapper(func, 16, slice(arguments, 1));
	    }

	    /**
	     * This method is like `_.partial` except that `partial` arguments are
	     * appended to those provided to the new function.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [arg] Arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * var defaultsDeep = _.partialRight(_.merge, _.defaults);
	     *
	     * var options = {
	     *   'variable': 'data',
	     *   'imports': { 'jq': $ }
	     * };
	     *
	     * defaultsDeep(options, _.templateSettings);
	     *
	     * options.variable
	     * // => 'data'
	     *
	     * options.imports
	     * // => { '_': _, 'jq': $ }
	     */
	    function partialRight(func) {
	      return createWrapper(func, 32, null, slice(arguments, 1));
	    }

	    /**
	     * Creates a function that, when executed, will only call the `func` function
	     * at most once per every `wait` milliseconds. Provide an options object to
	     * indicate that `func` should be invoked on the leading and/or trailing edge
	     * of the `wait` timeout. Subsequent calls to the throttled function will
	     * return the result of the last `func` call.
	     *
	     * Note: If `leading` and `trailing` options are `true` `func` will be called
	     * on the trailing edge of the timeout only if the the throttled function is
	     * invoked more than once during the `wait` timeout.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {Function} func The function to throttle.
	     * @param {number} wait The number of milliseconds to throttle executions to.
	     * @param {Object} [options] The options object.
	     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
	     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
	     * @returns {Function} Returns the new throttled function.
	     * @example
	     *
	     * // avoid excessively updating the position while scrolling
	     * var throttled = _.throttle(updatePosition, 100);
	     * jQuery(window).on('scroll', throttled);
	     *
	     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
	     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
	     *   'trailing': false
	     * }));
	     */
	    function throttle(func, wait, options) {
	      var leading = true,
	          trailing = true;

	      if (!isFunction(func)) {
	        throw new TypeError;
	      }
	      if (options === false) {
	        leading = false;
	      } else if (isObject(options)) {
	        leading = 'leading' in options ? options.leading : leading;
	        trailing = 'trailing' in options ? options.trailing : trailing;
	      }
	      debounceOptions.leading = leading;
	      debounceOptions.maxWait = wait;
	      debounceOptions.trailing = trailing;

	      return debounce(func, wait, debounceOptions);
	    }

	    /**
	     * Creates a function that provides `value` to the wrapper function as its
	     * first argument. Additional arguments provided to the function are appended
	     * to those provided to the wrapper function. The wrapper is executed with
	     * the `this` binding of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {*} value The value to wrap.
	     * @param {Function} wrapper The wrapper function.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var p = _.wrap(_.escape, function(func, text) {
	     *   return '<p>' + func(text) + '</p>';
	     * });
	     *
	     * p('Fred, Wilma, & Pebbles');
	     * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
	     */
	    function wrap(value, wrapper) {
	      return createWrapper(wrapper, 16, [value]);
	    }

	    /*--------------------------------------------------------------------------*/

	    /**
	     * Creates a function that returns `value`.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {*} value The value to return from the new function.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var object = { 'name': 'fred' };
	     * var getter = _.constant(object);
	     * getter() === object;
	     * // => true
	     */
	    function constant(value) {
	      return function() {
	        return value;
	      };
	    }

	    /**
	     * Produces a callback bound to an optional `thisArg`. If `func` is a property
	     * name the created callback will return the property value for a given element.
	     * If `func` is an object the created callback will return `true` for elements
	     * that contain the equivalent object properties, otherwise it will return `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {*} [func=identity] The value to convert to a callback.
	     * @param {*} [thisArg] The `this` binding of the created callback.
	     * @param {number} [argCount] The number of arguments the callback accepts.
	     * @returns {Function} Returns a callback function.
	     * @example
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36 },
	     *   { 'name': 'fred',   'age': 40 }
	     * ];
	     *
	     * // wrap to create custom callback shorthands
	     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
	     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
	     *   return !match ? func(callback, thisArg) : function(object) {
	     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
	     *   };
	     * });
	     *
	     * _.filter(characters, 'age__gt38');
	     * // => [{ 'name': 'fred', 'age': 40 }]
	     */
	    function createCallback(func, thisArg, argCount) {
	      var type = typeof func;
	      if (func == null || type == 'function') {
	        return baseCreateCallback(func, thisArg, argCount);
	      }
	      // handle "_.pluck" style callback shorthands
	      if (type != 'object') {
	        return property(func);
	      }
	      var props = keys(func),
	          key = props[0],
	          a = func[key];

	      // handle "_.where" style callback shorthands
	      if (props.length == 1 && a === a && !isObject(a)) {
	        // fast path the common case of providing an object with a single
	        // property containing a primitive value
	        return function(object) {
	          var b = object[key];
	          return a === b && (a !== 0 || (1 / a == 1 / b));
	        };
	      }
	      return function(object) {
	        var length = props.length,
	            result = false;

	        while (length--) {
	          if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
	            break;
	          }
	        }
	        return result;
	      };
	    }

	    /**
	     * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
	     * corresponding HTML entities.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {string} string The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escape('Fred, Wilma, & Pebbles');
	     * // => 'Fred, Wilma, &amp; Pebbles'
	     */
	    function escape(string) {
	      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
	    }

	    /**
	     * This method returns the first argument provided to it.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {*} value Any value.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * var object = { 'name': 'fred' };
	     * _.identity(object) === object;
	     * // => true
	     */
	    function identity(value) {
	      return value;
	    }

	    /**
	     * Adds function properties of a source object to the destination object.
	     * If `object` is a function methods will be added to its prototype as well.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {Function|Object} [object=lodash] object The destination object.
	     * @param {Object} source The object of functions to add.
	     * @param {Object} [options] The options object.
	     * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
	     * @example
	     *
	     * function capitalize(string) {
	     *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
	     * }
	     *
	     * _.mixin({ 'capitalize': capitalize });
	     * _.capitalize('fred');
	     * // => 'Fred'
	     *
	     * _('fred').capitalize().value();
	     * // => 'Fred'
	     *
	     * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
	     * _('fred').capitalize();
	     * // => 'Fred'
	     */
	    function mixin(object, source, options) {
	      var chain = true,
	          methodNames = source && functions(source);

	      if (!source || (!options && !methodNames.length)) {
	        if (options == null) {
	          options = source;
	        }
	        ctor = lodashWrapper;
	        source = object;
	        object = lodash;
	        methodNames = functions(source);
	      }
	      if (options === false) {
	        chain = false;
	      } else if (isObject(options) && 'chain' in options) {
	        chain = options.chain;
	      }
	      var ctor = object,
	          isFunc = isFunction(ctor);

	      forEach(methodNames, function(methodName) {
	        var func = object[methodName] = source[methodName];
	        if (isFunc) {
	          ctor.prototype[methodName] = function() {
	            var chainAll = this.__chain__,
	                value = this.__wrapped__,
	                args = [value];

	            push.apply(args, arguments);
	            var result = func.apply(object, args);
	            if (chain || chainAll) {
	              if (value === result && isObject(result)) {
	                return this;
	              }
	              result = new ctor(result);
	              result.__chain__ = chainAll;
	            }
	            return result;
	          };
	        }
	      });
	    }

	    /**
	     * Reverts the '_' variable to its previous value and returns a reference to
	     * the `lodash` function.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @returns {Function} Returns the `lodash` function.
	     * @example
	     *
	     * var lodash = _.noConflict();
	     */
	    function noConflict() {
	      context._ = oldDash;
	      return this;
	    }

	    /**
	     * A no-operation function.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @example
	     *
	     * var object = { 'name': 'fred' };
	     * _.noop(object) === undefined;
	     * // => true
	     */
	    function noop() {
	      // no operation performed
	    }

	    /**
	     * Gets the number of milliseconds that have elapsed since the Unix epoch
	     * (1 January 1970 00:00:00 UTC).
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @example
	     *
	     * var stamp = _.now();
	     * _.defer(function() { console.log(_.now() - stamp); });
	     * // => logs the number of milliseconds it took for the deferred function to be called
	     */
	    var now = isNative(now = Date.now) && now || function() {
	      return new Date().getTime();
	    };

	    /**
	     * Converts the given value into an integer of the specified radix.
	     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the
	     * `value` is a hexadecimal, in which case a `radix` of `16` is used.
	     *
	     * Note: This method avoids differences in native ES3 and ES5 `parseInt`
	     * implementations. See http://es5.github.io/#E.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {string} value The value to parse.
	     * @param {number} [radix] The radix used to interpret the value to parse.
	     * @returns {number} Returns the new integer value.
	     * @example
	     *
	     * _.parseInt('08');
	     * // => 8
	     */
	    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {
	      // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`
	      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
	    };

	    /**
	     * Creates a "_.pluck" style function, which returns the `key` value of a
	     * given object.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {string} key The name of the property to retrieve.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var characters = [
	     *   { 'name': 'fred',   'age': 40 },
	     *   { 'name': 'barney', 'age': 36 }
	     * ];
	     *
	     * var getName = _.property('name');
	     *
	     * _.map(characters, getName);
	     * // => ['barney', 'fred']
	     *
	     * _.sortBy(characters, getName);
	     * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
	     */
	    function property(key) {
	      return function(object) {
	        return object[key];
	      };
	    }

	    /**
	     * Produces a random number between `min` and `max` (inclusive). If only one
	     * argument is provided a number between `0` and the given number will be
	     * returned. If `floating` is truey or either `min` or `max` are floats a
	     * floating-point number will be returned instead of an integer.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {number} [min=0] The minimum possible value.
	     * @param {number} [max=1] The maximum possible value.
	     * @param {boolean} [floating=false] Specify returning a floating-point number.
	     * @returns {number} Returns a random number.
	     * @example
	     *
	     * _.random(0, 5);
	     * // => an integer between 0 and 5
	     *
	     * _.random(5);
	     * // => also an integer between 0 and 5
	     *
	     * _.random(5, true);
	     * // => a floating-point number between 0 and 5
	     *
	     * _.random(1.2, 5.2);
	     * // => a floating-point number between 1.2 and 5.2
	     */
	    function random(min, max, floating) {
	      var noMin = min == null,
	          noMax = max == null;

	      if (floating == null) {
	        if (typeof min == 'boolean' && noMax) {
	          floating = min;
	          min = 1;
	        }
	        else if (!noMax && typeof max == 'boolean') {
	          floating = max;
	          noMax = true;
	        }
	      }
	      if (noMin && noMax) {
	        max = 1;
	      }
	      min = +min || 0;
	      if (noMax) {
	        max = min;
	        min = 0;
	      } else {
	        max = +max || 0;
	      }
	      if (floating || min % 1 || max % 1) {
	        var rand = nativeRandom();
	        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1)))), max);
	      }
	      return baseRandom(min, max);
	    }

	    /**
	     * Resolves the value of property `key` on `object`. If `key` is a function
	     * it will be invoked with the `this` binding of `object` and its result returned,
	     * else the property value is returned. If `object` is falsey then `undefined`
	     * is returned.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {Object} object The object to inspect.
	     * @param {string} key The name of the property to resolve.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = {
	     *   'cheese': 'crumpets',
	     *   'stuff': function() {
	     *     return 'nonsense';
	     *   }
	     * };
	     *
	     * _.result(object, 'cheese');
	     * // => 'crumpets'
	     *
	     * _.result(object, 'stuff');
	     * // => 'nonsense'
	     */
	    function result(object, key) {
	      if (object) {
	        var value = object[key];
	        return isFunction(value) ? object[key]() : value;
	      }
	    }

	    /**
	     * A micro-templating method that handles arbitrary delimiters, preserves
	     * whitespace, and correctly escapes quotes within interpolated code.
	     *
	     * Note: In the development build, `_.template` utilizes sourceURLs for easier
	     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
	     *
	     * For more information on precompiling templates see:
	     * http://lodash.com/custom-builds
	     *
	     * For more information on Chrome extension sandboxes see:
	     * http://developer.chrome.com/stable/extensions/sandboxingEval.html
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {string} text The template text.
	     * @param {Object} data The data object used to populate the text.
	     * @param {Object} [options] The options object.
	     * @param {RegExp} [options.escape] The "escape" delimiter.
	     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
	     * @param {Object} [options.imports] An object to import into the template as local variables.
	     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
	     * @param {string} [sourceURL] The sourceURL of the template's compiled source.
	     * @param {string} [variable] The data object variable name.
	     * @returns {Function|string} Returns a compiled function when no `data` object
	     *  is given, else it returns the interpolated text.
	     * @example
	     *
	     * // using the "interpolate" delimiter to create a compiled template
	     * var compiled = _.template('hello <%= name %>');
	     * compiled({ 'name': 'fred' });
	     * // => 'hello fred'
	     *
	     * // using the "escape" delimiter to escape HTML in data property values
	     * _.template('<b><%- value %></b>', { 'value': '<script>' });
	     * // => '<b>&lt;script&gt;</b>'
	     *
	     * // using the "evaluate" delimiter to generate HTML
	     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
	     * _.template(list, { 'people': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
	     * _.template('hello ${ name }', { 'name': 'pebbles' });
	     * // => 'hello pebbles'
	     *
	     * // using the internal `print` function in "evaluate" delimiters
	     * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
	     * // => 'hello barney!'
	     *
	     * // using a custom template delimiters
	     * _.templateSettings = {
	     *   'interpolate': /{{([\s\S]+?)}}/g
	     * };
	     *
	     * _.template('hello {{ name }}!', { 'name': 'mustache' });
	     * // => 'hello mustache!'
	     *
	     * // using the `imports` option to import jQuery
	     * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
	     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // using the `sourceURL` option to specify a custom sourceURL for the template
	     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
	     * compiled(data);
	     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
	     *
	     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
	     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
	     * compiled.source;
	     * // => function(data) {
	     *   var __t, __p = '', __e = _.escape;
	     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
	     *   return __p;
	     * }
	     *
	     * // using the `source` property to inline compiled templates for meaningful
	     * // line numbers in error messages and a stack trace
	     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
	     *   var JST = {\
	     *     "main": ' + _.template(mainText).source + '\
	     *   };\
	     * ');
	     */
	    function template(text, data, options) {
	      // based on John Resig's `tmpl` implementation
	      // http://ejohn.org/blog/javascript-micro-templating/
	      // and Laura Doktorova's doT.js
	      // https://github.com/olado/doT
	      var settings = lodash.templateSettings;
	      text = String(text || '');

	      // avoid missing dependencies when `iteratorTemplate` is not defined
	      options = defaults({}, options, settings);

	      var imports = defaults({}, options.imports, settings.imports),
	          importsKeys = keys(imports),
	          importsValues = values(imports);

	      var isEvaluating,
	          index = 0,
	          interpolate = options.interpolate || reNoMatch,
	          source = "__p += '";

	      // compile the regexp to match each delimiter
	      var reDelimiters = RegExp(
	        (options.escape || reNoMatch).source + '|' +
	        interpolate.source + '|' +
	        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
	        (options.evaluate || reNoMatch).source + '|$'
	      , 'g');

	      text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
	        interpolateValue || (interpolateValue = esTemplateValue);

	        // escape characters that cannot be included in string literals
	        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);

	        // replace delimiters with snippets
	        if (escapeValue) {
	          source += "' +\n__e(" + escapeValue + ") +\n'";
	        }
	        if (evaluateValue) {
	          isEvaluating = true;
	          source += "';\n" + evaluateValue + ";\n__p += '";
	        }
	        if (interpolateValue) {
	          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
	        }
	        index = offset + match.length;

	        // the JS engine embedded in Adobe products requires returning the `match`
	        // string in order to produce the correct `offset` value
	        return match;
	      });

	      source += "';\n";

	      // if `variable` is not specified, wrap a with-statement around the generated
	      // code to add the data object to the top of the scope chain
	      var variable = options.variable,
	          hasVariable = variable;

	      if (!hasVariable) {
	        variable = 'obj';
	        source = 'with (' + variable + ') {\n' + source + '\n}\n';
	      }
	      // cleanup code by stripping empty strings
	      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
	        .replace(reEmptyStringMiddle, '$1')
	        .replace(reEmptyStringTrailing, '$1;');

	      // frame code as the function body
	      source = 'function(' + variable + ') {\n' +
	        (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
	        "var __t, __p = '', __e = _.escape" +
	        (isEvaluating
	          ? ', __j = Array.prototype.join;\n' +
	            "function print() { __p += __j.call(arguments, '') }\n"
	          : ';\n'
	        ) +
	        source +
	        'return __p\n}';

	      // Use a sourceURL for easier debugging.
	      // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
	      var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';

	      try {
	        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
	      } catch(e) {
	        e.source = source;
	        throw e;
	      }
	      if (data) {
	        return result(data);
	      }
	      // provide the compiled function's source by its `toString` method, in
	      // supported environments, or the `source` property as a convenience for
	      // inlining compiled templates during the build process
	      result.source = source;
	      return result;
	    }

	    /**
	     * Executes the callback `n` times, returning an array of the results
	     * of each callback execution. The callback is bound to `thisArg` and invoked
	     * with one argument; (index).
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {number} n The number of times to execute the callback.
	     * @param {Function} callback The function called per iteration.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array} Returns an array of the results of each `callback` execution.
	     * @example
	     *
	     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
	     * // => [3, 6, 4]
	     *
	     * _.times(3, function(n) { mage.castSpell(n); });
	     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
	     *
	     * _.times(3, function(n) { this.cast(n); }, mage);
	     * // => also calls `mage.castSpell(n)` three times
	     */
	    function times(n, callback, thisArg) {
	      n = (n = +n) > -1 ? n : 0;
	      var index = -1,
	          result = Array(n);

	      callback = baseCreateCallback(callback, thisArg, 1);
	      while (++index < n) {
	        result[index] = callback(index);
	      }
	      return result;
	    }

	    /**
	     * The inverse of `_.escape` this method converts the HTML entities
	     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
	     * corresponding characters.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {string} string The string to unescape.
	     * @returns {string} Returns the unescaped string.
	     * @example
	     *
	     * _.unescape('Fred, Barney &amp; Pebbles');
	     * // => 'Fred, Barney & Pebbles'
	     */
	    function unescape(string) {
	      return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
	    }

	    /**
	     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {string} [prefix] The value to prefix the ID with.
	     * @returns {string} Returns the unique ID.
	     * @example
	     *
	     * _.uniqueId('contact_');
	     * // => 'contact_104'
	     *
	     * _.uniqueId();
	     * // => '105'
	     */
	    function uniqueId(prefix) {
	      var id = ++idCounter;
	      return String(prefix == null ? '' : prefix) + id;
	    }

	    /*--------------------------------------------------------------------------*/

	    /**
	     * Creates a `lodash` object that wraps the given value with explicit
	     * method chaining enabled.
	     *
	     * @static
	     * @memberOf _
	     * @category Chaining
	     * @param {*} value The value to wrap.
	     * @returns {Object} Returns the wrapper object.
	     * @example
	     *
	     * var characters = [
	     *   { 'name': 'barney',  'age': 36 },
	     *   { 'name': 'fred',    'age': 40 },
	     *   { 'name': 'pebbles', 'age': 1 }
	     * ];
	     *
	     * var youngest = _.chain(characters)
	     *     .sortBy('age')
	     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
	     *     .first()
	     *     .value();
	     * // => 'pebbles is 1'
	     */
	    function chain(value) {
	      value = new lodashWrapper(value);
	      value.__chain__ = true;
	      return value;
	    }

	    /**
	     * Invokes `interceptor` with the `value` as the first argument and then
	     * returns `value`. The purpose of this method is to "tap into" a method
	     * chain in order to perform operations on intermediate results within
	     * the chain.
	     *
	     * @static
	     * @memberOf _
	     * @category Chaining
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * _([1, 2, 3, 4])
	     *  .tap(function(array) { array.pop(); })
	     *  .reverse()
	     *  .value();
	     * // => [3, 2, 1]
	     */
	    function tap(value, interceptor) {
	      interceptor(value);
	      return value;
	    }

	    /**
	     * Enables explicit method chaining on the wrapper object.
	     *
	     * @name chain
	     * @memberOf _
	     * @category Chaining
	     * @returns {*} Returns the wrapper object.
	     * @example
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36 },
	     *   { 'name': 'fred',   'age': 40 }
	     * ];
	     *
	     * // without explicit chaining
	     * _(characters).first();
	     * // => { 'name': 'barney', 'age': 36 }
	     *
	     * // with explicit chaining
	     * _(characters).chain()
	     *   .first()
	     *   .pick('age')
	     *   .value();
	     * // => { 'age': 36 }
	     */
	    function wrapperChain() {
	      this.__chain__ = true;
	      return this;
	    }

	    /**
	     * Produces the `toString` result of the wrapped value.
	     *
	     * @name toString
	     * @memberOf _
	     * @category Chaining
	     * @returns {string} Returns the string result.
	     * @example
	     *
	     * _([1, 2, 3]).toString();
	     * // => '1,2,3'
	     */
	    function wrapperToString() {
	      return String(this.__wrapped__);
	    }

	    /**
	     * Extracts the wrapped value.
	     *
	     * @name valueOf
	     * @memberOf _
	     * @alias value
	     * @category Chaining
	     * @returns {*} Returns the wrapped value.
	     * @example
	     *
	     * _([1, 2, 3]).valueOf();
	     * // => [1, 2, 3]
	     */
	    function wrapperValueOf() {
	      return this.__wrapped__;
	    }

	    /*--------------------------------------------------------------------------*/

	    // add functions that return wrapped values when chaining
	    lodash.after = after;
	    lodash.assign = assign;
	    lodash.at = at;
	    lodash.bind = bind;
	    lodash.bindAll = bindAll;
	    lodash.bindKey = bindKey;
	    lodash.chain = chain;
	    lodash.compact = compact;
	    lodash.compose = compose;
	    lodash.constant = constant;
	    lodash.countBy = countBy;
	    lodash.create = create;
	    lodash.createCallback = createCallback;
	    lodash.curry = curry;
	    lodash.debounce = debounce;
	    lodash.defaults = defaults;
	    lodash.defer = defer;
	    lodash.delay = delay;
	    lodash.difference = difference;
	    lodash.filter = filter;
	    lodash.flatten = flatten;
	    lodash.forEach = forEach;
	    lodash.forEachRight = forEachRight;
	    lodash.forIn = forIn;
	    lodash.forInRight = forInRight;
	    lodash.forOwn = forOwn;
	    lodash.forOwnRight = forOwnRight;
	    lodash.functions = functions;
	    lodash.groupBy = groupBy;
	    lodash.indexBy = indexBy;
	    lodash.initial = initial;
	    lodash.intersection = intersection;
	    lodash.invert = invert;
	    lodash.invoke = invoke;
	    lodash.keys = keys;
	    lodash.map = map;
	    lodash.mapValues = mapValues;
	    lodash.max = max;
	    lodash.memoize = memoize;
	    lodash.merge = merge;
	    lodash.min = min;
	    lodash.omit = omit;
	    lodash.once = once;
	    lodash.pairs = pairs;
	    lodash.partial = partial;
	    lodash.partialRight = partialRight;
	    lodash.pick = pick;
	    lodash.pluck = pluck;
	    lodash.property = property;
	    lodash.pull = pull;
	    lodash.range = range;
	    lodash.reject = reject;
	    lodash.remove = remove;
	    lodash.rest = rest;
	    lodash.shuffle = shuffle;
	    lodash.sortBy = sortBy;
	    lodash.tap = tap;
	    lodash.throttle = throttle;
	    lodash.times = times;
	    lodash.toArray = toArray;
	    lodash.transform = transform;
	    lodash.union = union;
	    lodash.uniq = uniq;
	    lodash.values = values;
	    lodash.where = where;
	    lodash.without = without;
	    lodash.wrap = wrap;
	    lodash.xor = xor;
	    lodash.zip = zip;
	    lodash.zipObject = zipObject;

	    // add aliases
	    lodash.collect = map;
	    lodash.drop = rest;
	    lodash.each = forEach;
	    lodash.eachRight = forEachRight;
	    lodash.extend = assign;
	    lodash.methods = functions;
	    lodash.object = zipObject;
	    lodash.select = filter;
	    lodash.tail = rest;
	    lodash.unique = uniq;
	    lodash.unzip = zip;

	    // add functions to `lodash.prototype`
	    mixin(lodash);

	    /*--------------------------------------------------------------------------*/

	    // add functions that return unwrapped values when chaining
	    lodash.clone = clone;
	    lodash.cloneDeep = cloneDeep;
	    lodash.contains = contains;
	    lodash.escape = escape;
	    lodash.every = every;
	    lodash.find = find;
	    lodash.findIndex = findIndex;
	    lodash.findKey = findKey;
	    lodash.findLast = findLast;
	    lodash.findLastIndex = findLastIndex;
	    lodash.findLastKey = findLastKey;
	    lodash.has = has;
	    lodash.identity = identity;
	    lodash.indexOf = indexOf;
	    lodash.isArguments = isArguments;
	    lodash.isArray = isArray;
	    lodash.isBoolean = isBoolean;
	    lodash.isDate = isDate;
	    lodash.isElement = isElement;
	    lodash.isEmpty = isEmpty;
	    lodash.isEqual = isEqual;
	    lodash.isFinite = isFinite;
	    lodash.isFunction = isFunction;
	    lodash.isNaN = isNaN;
	    lodash.isNull = isNull;
	    lodash.isNumber = isNumber;
	    lodash.isObject = isObject;
	    lodash.isPlainObject = isPlainObject;
	    lodash.isRegExp = isRegExp;
	    lodash.isString = isString;
	    lodash.isUndefined = isUndefined;
	    lodash.lastIndexOf = lastIndexOf;
	    lodash.mixin = mixin;
	    lodash.noConflict = noConflict;
	    lodash.noop = noop;
	    lodash.now = now;
	    lodash.parseInt = parseInt;
	    lodash.random = random;
	    lodash.reduce = reduce;
	    lodash.reduceRight = reduceRight;
	    lodash.result = result;
	    lodash.runInContext = runInContext;
	    lodash.size = size;
	    lodash.some = some;
	    lodash.sortedIndex = sortedIndex;
	    lodash.template = template;
	    lodash.unescape = unescape;
	    lodash.uniqueId = uniqueId;

	    // add aliases
	    lodash.all = every;
	    lodash.any = some;
	    lodash.detect = find;
	    lodash.findWhere = find;
	    lodash.foldl = reduce;
	    lodash.foldr = reduceRight;
	    lodash.include = contains;
	    lodash.inject = reduce;

	    mixin(function() {
	      var source = {}
	      forOwn(lodash, function(func, methodName) {
	        if (!lodash.prototype[methodName]) {
	          source[methodName] = func;
	        }
	      });
	      return source;
	    }(), false);

	    /*--------------------------------------------------------------------------*/

	    // add functions capable of returning wrapped and unwrapped values when chaining
	    lodash.first = first;
	    lodash.last = last;
	    lodash.sample = sample;

	    // add aliases
	    lodash.take = first;
	    lodash.head = first;

	    forOwn(lodash, function(func, methodName) {
	      var callbackable = methodName !== 'sample';
	      if (!lodash.prototype[methodName]) {
	        lodash.prototype[methodName]= function(n, guard) {
	          var chainAll = this.__chain__,
	              result = func(this.__wrapped__, n, guard);

	          return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))
	            ? result
	            : new lodashWrapper(result, chainAll);
	        };
	      }
	    });

	    /*--------------------------------------------------------------------------*/

	    /**
	     * The semantic version number.
	     *
	     * @static
	     * @memberOf _
	     * @type string
	     */
	    lodash.VERSION = '2.4.1';

	    // add "Chaining" functions to the wrapper
	    lodash.prototype.chain = wrapperChain;
	    lodash.prototype.toString = wrapperToString;
	    lodash.prototype.value = wrapperValueOf;
	    lodash.prototype.valueOf = wrapperValueOf;

	    // add `Array` functions that return unwrapped values
	    baseEach(['join', 'pop', 'shift'], function(methodName) {
	      var func = arrayRef[methodName];
	      lodash.prototype[methodName] = function() {
	        var chainAll = this.__chain__,
	            result = func.apply(this.__wrapped__, arguments);

	        return chainAll
	          ? new lodashWrapper(result, chainAll)
	          : result;
	      };
	    });

	    // add `Array` functions that return the existing wrapped value
	    baseEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
	      var func = arrayRef[methodName];
	      lodash.prototype[methodName] = function() {
	        func.apply(this.__wrapped__, arguments);
	        return this;
	      };
	    });

	    // add `Array` functions that return new wrapped values
	    baseEach(['concat', 'slice', 'splice'], function(methodName) {
	      var func = arrayRef[methodName];
	      lodash.prototype[methodName] = function() {
	        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
	      };
	    });

	    // avoid array-like object bugs with `Array#shift` and `Array#splice`
	    // in IE < 9, Firefox < 10, Narwhal, and RingoJS
	    if (!support.spliceObjects) {
	      baseEach(['pop', 'shift', 'splice'], function(methodName) {
	        var func = arrayRef[methodName],
	            isSplice = methodName == 'splice';

	        lodash.prototype[methodName] = function() {
	          var chainAll = this.__chain__,
	              value = this.__wrapped__,
	              result = func.apply(value, arguments);

	          if (value.length === 0) {
	            delete value[0];
	          }
	          return (chainAll || isSplice)
	            ? new lodashWrapper(result, chainAll)
	            : result;
	        };
	      });
	    }

	    return lodash;
	  }

	  /*--------------------------------------------------------------------------*/

	  // expose Lo-Dash
	  var _ = runInContext();

	  // some AMD build optimizers like r.js check for condition patterns like the following:
	  if (true) {
	    // Expose Lo-Dash to the global object even when an AMD loader is present in
	    // case Lo-Dash is loaded with a RequireJS shim config.
	    // See http://requirejs.org/docs/api.html#config-shim
	    root._ = _;

	    // define as an anonymous module so, through path mapping, it can be
	    // referenced as the "underscore" module
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return _;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	  // check for `exports` after `define` in case a build optimizer adds an `exports` object
	  else if (freeExports && freeModule) {
	    // in Node.js or RingoJS
	    if (moduleExports) {
	      (freeModule.exports = _)._ = _;
	    }
	    // in Narwhal or Rhino -require
	    else {
	      freeExports._ = _;
	    }
	  }
	  else {
	    // in a browser or Rhino
	    root._ = _;
	  }
	}.call(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22)(module), (function() { return this; }())))

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var
	    jslex = __webpack_require__(20),
	    _ = __webpack_require__(14);



	var simpleType = function(name) {
	    return function() {
	        return {
	            type: name
	        };
	    }
	}

	var charCountInString = function(string, character) {
	    return string.split(character).length - 1;
	}

	var addSimpleStringInformationField = function(spec, key, type) {
	    spec.start[key + ": *([^\n]*)\n?"] = function(data) {
	        return {
	            type_class: "data",
	            type: type,
	            data: data
	        }
	    }
	}

	var spec = {
	    "start": {

	        // NOTES //
	        "([A-Ga-g])": function(note) {
	            return {
	                type: "note",
	                subType: "letter",
	                data: note
	            }
	        },

	        // RESTS //
	        "z": function() {
	            return {
	                type: "rest",
	                subType: "visible",
	                data: "short"
	            }
	        },
	        "x": function() {
	            return {
	                type: "rest",
	                subType: "invisible",
	                data: "short"
	            }
	        },
	        "Z": function() {
	            return {
	                type: "rest",
	                subType: "visible",
	                data: "long"
	            }
	        },
	        "X": function() {
	            return {
	                type: "rest",
	                subType: "invisible",
	                data: "long"
	            }
	        },

	        // NOTE AND REST DECORATIONS //
	        "([0-9]+)?/?([0-9]+)?": function(notelength, notedenom) {
	            return {
	                type: "note",
	                subType: "length",
	                data: notedenom && notedenom.length > 0 ? parseFloat(notelength) / parseFloat(notedenom) : parseInt(notelength),
	            }
	        },
	        "([',]*)": function(pitchModifier) {
	            return {
	                type: "note",
	                subType: "pitch",
	                data: charCountInString(pitchModifier, "'") - charCountInString(pitchModifier, ",")
	            }
	        },
	        "(_|\\^|=|__|\\^\\^)": function(accidental) {
	            return {
	                type: "note",
	                subType: "accidental",
	                data: accidental
	            }
	        },

	        "\"([^\"]+)\"": function(data) {
	            return {
	                type: "chord_annotation",
	                data: data
	            }
	        },

	        "!([^!]+)!": function(data) {
	            return {
	                type: "decoration",
	                data: data
	            }
	        },

	        // BAR LINES //
	        "\\|": function() {
	            return {
	                type: "barline"
	            }
	        },
	        "\\|\\]": function() {
	            return {
	                type: "barline"
	            }
	        },
	        "\\|\\|": function() {
	            return {
	                type: "barline"
	            }
	        },
	        "\\[\\|": function() {
	            return {
	                type: "barline"
	            }
	        },
	        ":\\|": function() {
	            return {
	                type: "barline"
	            }
	        },
	        "\\|:": function() {
	            return {
	                type: "barline"
	            }
	        },
	        "::": function() {
	            return {
	                type: "barline"
	            }
	        },


	        // NOTE GROUPS //
	        "\\[": function() {
	            return {
	                type: "chord_start"
	            }
	        },

	        "\\]": function() {
	            return {
	                type: "chord_stop"
	            }
	        },

	        "{": function() {
	            return {
	                type: "grace_start"
	            }
	        },
	        "}": function() {
	            return {
	                type: "grace_stop"
	            }
	        },

	        "\\(": function() {
	            return {
	                type: "slur_start"
	            }
	        },
	        "\\)": function() {
	            return {
	                type: "slur_stop"
	            }
	        },

	        "`": function() {
	            return {
	                type: "beam"
	            }
	        },

	        // OTHER //
	        " ": function() {
	            return {
	                type: "space"
	            }
	        }
	    }
	};

	addSimpleStringInformationField(spec, "B", "book");
	addSimpleStringInformationField(spec, "C", "composer");
	addSimpleStringInformationField(spec, "D", "discography");
	addSimpleStringInformationField(spec, "F", "file url");
	addSimpleStringInformationField(spec, "G", "group");
	addSimpleStringInformationField(spec, "H", "history");
	addSimpleStringInformationField(spec, "N", "notes");
	addSimpleStringInformationField(spec, "O", "origin");
	addSimpleStringInformationField(spec, "R", "rhythm");
	addSimpleStringInformationField(spec, "r", "remark");
	addSimpleStringInformationField(spec, "S", "source");
	addSimpleStringInformationField(spec, "T", "title");
	addSimpleStringInformationField(spec, "Z", "transcription");

	//not quite true..
	addSimpleStringInformationField(spec, "M", "meter");
	addSimpleStringInformationField(spec, "L", "length");
	addSimpleStringInformationField(spec, "K", "key");

	spec.start["(.)"] = function(data) {
	    return {
	        type: "err",
	        data: data
	    }
	}

	module.exports = jslex(spec);

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var data_tables = {};

	data_tables["notes"] = {
	    "C": {
	        octave: 4,
	        pitch: 60
	    },
	    "D": {
	        octave: 4,
	        pitch: 62
	    },
	    "E": {
	        octave: 4,
	        pitch: 64
	    },
	    "F": {
	        octave: 4,
	        pitch: 65
	    },
	    "G": {
	        octave: 4,
	        pitch: 67
	    },
	    "A": {
	        octave: 4,
	        pitch: 69
	    },
	    "B": {
	        octave: 4,
	        pitch: 71
	    },
	    "c": {
	        octave: 5,
	        pitch: 60
	    },
	    "d": {
	        octave: 5,
	        pitch: 62
	    },
	    "e": {
	        octave: 5,
	        pitch: 64
	    },
	    "f": {
	        octave: 5,
	        pitch: 65
	    },
	    "g": {
	        octave: 5,
	        pitch: 67
	    },
	    "a": {
	        octave: 5,
	        pitch: 69
	    },
	    "b": {
	        octave: 5,
	        pitch: 71
	    },
	}

	module.exports = data_tables;

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Toastr
	 * Copyright 2012-2014 John Papa and Hans Fjllemark.
	 * All Rights Reserved.
	 * Use, reproduction, distribution, and modification of this code is subject to the terms and
	 * conditions of the MIT license, available at http://www.opensource.org/licenses/mit-license.php
	 *
	 * Author: John Papa and Hans Fjllemark
	 * ARIA Support: Greta Krafsig
	 * Project: https://github.com/CodeSeven/toastr
	 */
	; (function (define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($) {
	        return (function () {
	            var $container;
	            var listener;
	            var toastId = 0;
	            var toastType = {
	                error: 'error',
	                info: 'info',
	                success: 'success',
	                warning: 'warning'
	            };

	            var toastr = {
	                clear: clear,
	                remove: remove,
	                error: error,
	                getContainer: getContainer,
	                info: info,
	                options: {},
	                subscribe: subscribe,
	                success: success,
	                version: '2.0.3',
	                warning: warning
	            };

	            return toastr;

	            //#region Accessible Methods
	            function error(message, title, optionsOverride) {
	                return notify({
	                    type: toastType.error,
	                    iconClass: getOptions().iconClasses.error,
	                    message: message,
	                    optionsOverride: optionsOverride,
	                    title: title
	                });
	            }

	            function getContainer(options, create) {
	                if (!options) { options = getOptions(); }
	                $container = $('#' + options.containerId);
	                if ($container.length) {
	                    return $container;
	                }
	                if(create) {
	                    $container = createContainer(options);
	                }
	                return $container;
	            }

	            function info(message, title, optionsOverride) {
	                return notify({
	                    type: toastType.info,
	                    iconClass: getOptions().iconClasses.info,
	                    message: message,
	                    optionsOverride: optionsOverride,
	                    title: title
	                });
	            }

	            function subscribe(callback) {
	                listener = callback;
	            }

	            function success(message, title, optionsOverride) {
	                return notify({
	                    type: toastType.success,
	                    iconClass: getOptions().iconClasses.success,
	                    message: message,
	                    optionsOverride: optionsOverride,
	                    title: title
	                });
	            }

	            function warning(message, title, optionsOverride) {
	                return notify({
	                    type: toastType.warning,
	                    iconClass: getOptions().iconClasses.warning,
	                    message: message,
	                    optionsOverride: optionsOverride,
	                    title: title
	                });
	            }

	            function clear($toastElement) {
	                var options = getOptions();
	                if (!$container) { getContainer(options); }
	                if (!clearToast($toastElement, options)) {
	                    clearContainer(options);
	                }
	            }

	            function remove($toastElement) {
	                var options = getOptions();
	                if (!$container) { getContainer(options); }
	                if ($toastElement && $(':focus', $toastElement).length === 0) {
	                    removeToast($toastElement);
	                    return;
	                }
	                if ($container.children().length) {
	                    $container.remove();
	                }
	            }
	            //#endregion

	            //#region Internal Methods

	            function clearContainer(options){
	                var toastsToClear = $container.children();
	                for (var i = toastsToClear.length - 1; i >= 0; i--) {
	                    clearToast($(toastsToClear[i]), options);
	                };
	            }

	            function clearToast($toastElement, options){
	                if ($toastElement && $(':focus', $toastElement).length === 0) {
	                    $toastElement[options.hideMethod]({
	                        duration: options.hideDuration,
	                        easing: options.hideEasing,
	                        complete: function () { removeToast($toastElement); }
	                    });
	                    return true;
	                }
	                return false;
	            }

	            function createContainer(options) {
	                $container = $('<div/>')
	                    .attr('id', options.containerId)
	                    .addClass(options.positionClass)
	                    .attr('aria-live', 'polite')
	                    .attr('role', 'alert');

	                $container.appendTo($(options.target));
	                return $container;
	            }

	            function getDefaults() {
	                return {
	                    tapToDismiss: true,
	                    toastClass: 'toast',
	                    containerId: 'toast-container',
	                    debug: false,

	                    showMethod: 'fadeIn', //fadeIn, slideDown, and show are built into jQuery
	                    showDuration: 300,
	                    showEasing: 'swing', //swing and linear are built into jQuery
	                    onShown: undefined,
	                    hideMethod: 'fadeOut',
	                    hideDuration: 1000,
	                    hideEasing: 'swing',
	                    onHidden: undefined,

	                    extendedTimeOut: 1000,
	                    iconClasses: {
	                        error: 'toast-error',
	                        info: 'toast-info',
	                        success: 'toast-success',
	                        warning: 'toast-warning'
	                    },
	                    iconClass: 'toast-info',
	                    positionClass: 'toast-top-right',
	                    timeOut: 5000, // Set timeOut and extendedTimeout to 0 to make it sticky
	                    titleClass: 'toast-title',
	                    messageClass: 'toast-message',
	                    target: 'body',
	                    closeHtml: '<button>&times;</button>',
	                    newestOnTop: true
	                };
	            }

	            function publish(args) {
	                if (!listener) { return; }
	                listener(args);
	            }

	            function notify(map) {
	                var options = getOptions(),
	                    iconClass = map.iconClass || options.iconClass;

	                if (typeof (map.optionsOverride) !== 'undefined') {
	                    options = $.extend(options, map.optionsOverride);
	                    iconClass = map.optionsOverride.iconClass || iconClass;
	                }

	                toastId++;

	                $container = getContainer(options, true);
	                var intervalId = null,
	                    $toastElement = $('<div/>'),
	                    $titleElement = $('<div/>'),
	                    $messageElement = $('<div/>'),
	                    $closeElement = $(options.closeHtml),
	                    response = {
	                        toastId: toastId,
	                        state: 'visible',
	                        startTime: new Date(),
	                        options: options,
	                        map: map
	                    };

	                if (map.iconClass) {
	                    $toastElement.addClass(options.toastClass).addClass(iconClass);
	                }

	                if (map.title) {
	                    $titleElement.append(map.title).addClass(options.titleClass);
	                    $toastElement.append($titleElement);
	                }

	                if (map.message) {
	                    $messageElement.append(map.message).addClass(options.messageClass);
	                    $toastElement.append($messageElement);
	                }

	                if (options.closeButton) {
	                    $closeElement.addClass('toast-close-button').attr("role", "button");
	                    $toastElement.prepend($closeElement);
	                }

	                $toastElement.hide();
	                if (options.newestOnTop) {
	                    $container.prepend($toastElement);
	                } else {
	                    $container.append($toastElement);
	                }


	                $toastElement[options.showMethod](
	                    { duration: options.showDuration, easing: options.showEasing, complete: options.onShown }
	                );

	                if (options.timeOut > 0) {
	                    intervalId = setTimeout(hideToast, options.timeOut);
	                }

	                $toastElement.hover(stickAround, delayedHideToast);
	                if (!options.onclick && options.tapToDismiss) {
	                    $toastElement.click(hideToast);
	                }

	                if (options.closeButton && $closeElement) {
	                    $closeElement.click(function (event) {
	                        if( event.stopPropagation ) {
	                            event.stopPropagation();
	                        } else if( event.cancelBubble !== undefined && event.cancelBubble !== true ) {
	                            event.cancelBubble = true;
	                        }
	                        hideToast(true);
	                    });
	                }

	                if (options.onclick) {
	                    $toastElement.click(function () {
	                        options.onclick();
	                        hideToast();
	                    });
	                }

	                publish(response);

	                if (options.debug && console) {
	                    console.log(response);
	                }

	                return $toastElement;

	                function hideToast(override) {
	                    if ($(':focus', $toastElement).length && !override) {
	                        return;
	                    }
	                    return $toastElement[options.hideMethod]({
	                        duration: options.hideDuration,
	                        easing: options.hideEasing,
	                        complete: function () {
	                            removeToast($toastElement);
	                            if (options.onHidden && response.state !== 'hidden') {
	                                options.onHidden();
	                            }
	                            response.state = 'hidden';
	                            response.endTime = new Date();
	                            publish(response);
	                        }
	                    });
	                }

	                function delayedHideToast() {
	                    if (options.timeOut > 0 || options.extendedTimeOut > 0) {
	                        intervalId = setTimeout(hideToast, options.extendedTimeOut);
	                    }
	                }

	                function stickAround() {
	                    clearTimeout(intervalId);
	                    $toastElement.stop(true, true)[options.showMethod](
	                        { duration: options.showDuration, easing: options.showEasing }
	                    );
	                }
	            }

	            function getOptions() {
	                return $.extend({}, getDefaults(), toastr.options);
	            }

	            function removeToast($toastElement) {
	                if (!$container) { $container = getContainer(); }
	                if ($toastElement.is(':visible')) {
	                    return;
	                }
	                $toastElement.remove();
	                $toastElement = null;
	                if ($container.children().length === 0) {
	                    $container.remove();
	                }
	            }
	            //#endregion

	        })();
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(__webpack_require__(23)));

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/* See LICENSE file for terms of use */

	/*
	 * Text diff implementation.
	 *
	 * This library supports the following APIS:
	 * JsDiff.diffChars: Character by character diff
	 * JsDiff.diffWords: Word (as defined by \b regex) diff which ignores whitespace
	 * JsDiff.diffLines: Line based diff
	 *
	 * JsDiff.diffCss: Diff targeted at CSS content
	 *
	 * These methods are based on the implementation proposed in
	 * "An O(ND) Difference Algorithm and its Variations" (Myers, 1986).
	 * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927
	 */
	var JsDiff = (function() {
	  /*jshint maxparams: 5*/
	  function clonePath(path) {
	    return { newPos: path.newPos, components: path.components.slice(0) };
	  }
	  function removeEmpty(array) {
	    var ret = [];
	    for (var i = 0; i < array.length; i++) {
	      if (array[i]) {
	        ret.push(array[i]);
	      }
	    }
	    return ret;
	  }
	  function escapeHTML(s) {
	    var n = s;
	    n = n.replace(/&/g, '&amp;');
	    n = n.replace(/</g, '&lt;');
	    n = n.replace(/>/g, '&gt;');
	    n = n.replace(/"/g, '&quot;');

	    return n;
	  }

	  var Diff = function(ignoreWhitespace) {
	    this.ignoreWhitespace = ignoreWhitespace;
	  };
	  Diff.prototype = {
	      diff: function(oldString, newString) {
	        // Handle the identity case (this is due to unrolling editLength == 0
	        if (newString === oldString) {
	          return [{ value: newString }];
	        }
	        if (!newString) {
	          return [{ value: oldString, removed: true }];
	        }
	        if (!oldString) {
	          return [{ value: newString, added: true }];
	        }

	        newString = this.tokenize(newString);
	        oldString = this.tokenize(oldString);

	        var newLen = newString.length, oldLen = oldString.length;
	        var maxEditLength = newLen + oldLen;
	        var bestPath = [{ newPos: -1, components: [] }];

	        // Seed editLength = 0
	        var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
	        if (bestPath[0].newPos+1 >= newLen && oldPos+1 >= oldLen) {
	          return bestPath[0].components;
	        }

	        for (var editLength = 1; editLength <= maxEditLength; editLength++) {
	          for (var diagonalPath = -1*editLength; diagonalPath <= editLength; diagonalPath+=2) {
	            var basePath;
	            var addPath = bestPath[diagonalPath-1],
	                removePath = bestPath[diagonalPath+1];
	            oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
	            if (addPath) {
	              // No one else is going to attempt to use this value, clear it
	              bestPath[diagonalPath-1] = undefined;
	            }

	            var canAdd = addPath && addPath.newPos+1 < newLen;
	            var canRemove = removePath && 0 <= oldPos && oldPos < oldLen;
	            if (!canAdd && !canRemove) {
	              bestPath[diagonalPath] = undefined;
	              continue;
	            }

	            // Select the diagonal that we want to branch from. We select the prior
	            // path whose position in the new string is the farthest from the origin
	            // and does not pass the bounds of the diff graph
	            if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {
	              basePath = clonePath(removePath);
	              this.pushComponent(basePath.components, oldString[oldPos], undefined, true);
	            } else {
	              basePath = clonePath(addPath);
	              basePath.newPos++;
	              this.pushComponent(basePath.components, newString[basePath.newPos], true, undefined);
	            }

	            var oldPos = this.extractCommon(basePath, newString, oldString, diagonalPath);

	            if (basePath.newPos+1 >= newLen && oldPos+1 >= oldLen) {
	              return basePath.components;
	            } else {
	              bestPath[diagonalPath] = basePath;
	            }
	          }
	        }
	      },

	      pushComponent: function(components, value, added, removed) {
	        var last = components[components.length-1];
	        if (last && last.added === added && last.removed === removed) {
	          // We need to clone here as the component clone operation is just
	          // as shallow array clone
	          components[components.length-1] =
	            {value: this.join(last.value, value), added: added, removed: removed };
	        } else {
	          components.push({value: value, added: added, removed: removed });
	        }
	      },
	      extractCommon: function(basePath, newString, oldString, diagonalPath) {
	        var newLen = newString.length,
	            oldLen = oldString.length,
	            newPos = basePath.newPos,
	            oldPos = newPos - diagonalPath;
	        while (newPos+1 < newLen && oldPos+1 < oldLen && this.equals(newString[newPos+1], oldString[oldPos+1])) {
	          newPos++;
	          oldPos++;

	          this.pushComponent(basePath.components, newString[newPos], undefined, undefined);
	        }
	        basePath.newPos = newPos;
	        return oldPos;
	      },

	      equals: function(left, right) {
	        var reWhitespace = /\S/;
	        if (this.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right)) {
	          return true;
	        } else {
	          return left === right;
	        }
	      },
	      join: function(left, right) {
	        return left + right;
	      },
	      tokenize: function(value) {
	        return value;
	      }
	  };

	  var CharDiff = new Diff();

	  var WordDiff = new Diff(true);
	  var WordWithSpaceDiff = new Diff();
	  WordDiff.tokenize = WordWithSpaceDiff.tokenize = function(value) {
	    return removeEmpty(value.split(/(\s+|\b)/));
	  };

	  var CssDiff = new Diff(true);
	  CssDiff.tokenize = function(value) {
	    return removeEmpty(value.split(/([{}:;,]|\s+)/));
	  };

	  var LineDiff = new Diff();
	  LineDiff.tokenize = function(value) {
	    var retLines = [],
	        lines = value.split(/^/m);

	    for(var i = 0; i < lines.length; i++) {
	      var line = lines[i],
	          lastLine = lines[i - 1];

	      // Merge lines that may contain windows new lines
	      if (line == '\n' && lastLine && lastLine[lastLine.length - 1] === '\r') {
	        retLines[retLines.length - 1] += '\n';
	      } else if (line) {
	        retLines.push(line);
	      }
	    }

	    return retLines;
	  };

	  return {
	    Diff: Diff,

	    diffChars: function(oldStr, newStr) { return CharDiff.diff(oldStr, newStr); },
	    diffWords: function(oldStr, newStr) { return WordDiff.diff(oldStr, newStr); },
	    diffWordsWithSpace: function(oldStr, newStr) { return WordWithSpaceDiff.diff(oldStr, newStr); },
	    diffLines: function(oldStr, newStr) { return LineDiff.diff(oldStr, newStr); },

	    diffCss: function(oldStr, newStr) { return CssDiff.diff(oldStr, newStr); },

	    createPatch: function(fileName, oldStr, newStr, oldHeader, newHeader) {
	      var ret = [];

	      ret.push('Index: ' + fileName);
	      ret.push('===================================================================');
	      ret.push('--- ' + fileName + (typeof oldHeader === 'undefined' ? '' : '\t' + oldHeader));
	      ret.push('+++ ' + fileName + (typeof newHeader === 'undefined' ? '' : '\t' + newHeader));

	      var diff = LineDiff.diff(oldStr, newStr);
	      if (!diff[diff.length-1].value) {
	        diff.pop();   // Remove trailing newline add
	      }
	      diff.push({value: '', lines: []});   // Append an empty value to make cleanup easier

	      function contextLines(lines) {
	        return lines.map(function(entry) { return ' ' + entry; });
	      }
	      function eofNL(curRange, i, current) {
	        var last = diff[diff.length-2],
	            isLast = i === diff.length-2,
	            isLastOfType = i === diff.length-3 && (current.added !== last.added || current.removed !== last.removed);

	        // Figure out if this is the last line for the given file and missing NL
	        if (!/\n$/.test(current.value) && (isLast || isLastOfType)) {
	          curRange.push('\\ No newline at end of file');
	        }
	      }

	      var oldRangeStart = 0, newRangeStart = 0, curRange = [],
	          oldLine = 1, newLine = 1;
	      for (var i = 0; i < diff.length; i++) {
	        var current = diff[i],
	            lines = current.lines || current.value.replace(/\n$/, '').split('\n');
	        current.lines = lines;

	        if (current.added || current.removed) {
	          if (!oldRangeStart) {
	            var prev = diff[i-1];
	            oldRangeStart = oldLine;
	            newRangeStart = newLine;

	            if (prev) {
	              curRange = contextLines(prev.lines.slice(-4));
	              oldRangeStart -= curRange.length;
	              newRangeStart -= curRange.length;
	            }
	          }
	          curRange.push.apply(curRange, lines.map(function(entry) { return (current.added?'+':'-') + entry; }));
	          eofNL(curRange, i, current);

	          if (current.added) {
	            newLine += lines.length;
	          } else {
	            oldLine += lines.length;
	          }
	        } else {
	          if (oldRangeStart) {
	            // Close out any changes that have been output (or join overlapping)
	            if (lines.length <= 8 && i < diff.length-2) {
	              // Overlapping
	              curRange.push.apply(curRange, contextLines(lines));
	            } else {
	              // end the range and output
	              var contextSize = Math.min(lines.length, 4);
	              ret.push(
	                  '@@ -' + oldRangeStart + ',' + (oldLine-oldRangeStart+contextSize)
	                  + ' +' + newRangeStart + ',' + (newLine-newRangeStart+contextSize)
	                  + ' @@');
	              ret.push.apply(ret, curRange);
	              ret.push.apply(ret, contextLines(lines.slice(0, contextSize)));
	              if (lines.length <= 4) {
	                eofNL(ret, i, current);
	              }

	              oldRangeStart = 0;  newRangeStart = 0; curRange = [];
	            }
	          }
	          oldLine += lines.length;
	          newLine += lines.length;
	        }
	      }

	      return ret.join('\n') + '\n';
	    },

	    applyPatch: function(oldStr, uniDiff) {
	      var diffstr = uniDiff.split('\n');
	      var diff = [];
	      var remEOFNL = false,
	          addEOFNL = false;

	      for (var i = (diffstr[0][0]==='I'?4:0); i < diffstr.length; i++) {
	        if(diffstr[i][0] === '@') {
	          var meh = diffstr[i].split(/@@ -(\d+),(\d+) \+(\d+),(\d+) @@/);
	          diff.unshift({
	            start:meh[3],
	            oldlength:meh[2],
	            oldlines:[],
	            newlength:meh[4],
	            newlines:[]
	          });
	        } else if(diffstr[i][0] === '+') {
	          diff[0].newlines.push(diffstr[i].substr(1));
	        } else if(diffstr[i][0] === '-') {
	          diff[0].oldlines.push(diffstr[i].substr(1));
	        } else if(diffstr[i][0] === ' ') {
	          diff[0].newlines.push(diffstr[i].substr(1));
	          diff[0].oldlines.push(diffstr[i].substr(1));
	        } else if(diffstr[i][0] === '\\') {
	          if (diffstr[i-1][0] === '+') {
	            remEOFNL = true;
	          } else if(diffstr[i-1][0] === '-') {
	            addEOFNL = true;
	          }
	        }
	      }

	      var str = oldStr.split('\n');
	      for (var i = diff.length - 1; i >= 0; i--) {
	        var d = diff[i];
	        for (var j = 0; j < d.oldlength; j++) {
	          if(str[d.start-1+j] !== d.oldlines[j]) {
	            return false;
	          }
	        }
	        Array.prototype.splice.apply(str,[d.start-1,+d.oldlength].concat(d.newlines));
	      }

	      if (remEOFNL) {
	        while (!str[str.length-1]) {
	          str.pop();
	        }
	      } else if (addEOFNL) {
	        str.push('');
	      }
	      return str.join('\n');
	    },

	    convertChangesToXML: function(changes){
	      var ret = [];
	      for ( var i = 0; i < changes.length; i++) {
	        var change = changes[i];
	        if (change.added) {
	          ret.push('<ins>');
	        } else if (change.removed) {
	          ret.push('<del>');
	        }

	        ret.push(escapeHTML(change.value));

	        if (change.added) {
	          ret.push('</ins>');
	        } else if (change.removed) {
	          ret.push('</del>');
	        }
	      }
	      return ret.join('');
	    },

	    // See: http://code.google.com/p/google-diff-match-patch/wiki/API
	    convertChangesToDMP: function(changes){
	      var ret = [], change;
	      for ( var i = 0; i < changes.length; i++) {
	        change = changes[i];
	        ret.push([(change.added ? 1 : change.removed ? -1 : 0), change.value]);
	      }
	      return ret;
	    }
	  };
	})();

	if (true) {
	    module.exports = JsDiff;
	}


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global, process) {// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.

	;(function (undefined) {

	  var objectTypes = {
	    'boolean': false,
	    'function': true,
	    'object': true,
	    'number': false,
	    'string': false,
	    'undefined': false
	  };

	  var root = (objectTypes[typeof window] && window) || this,
	    freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
	    freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
	    moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
	    freeGlobal = objectTypes[typeof global] && global;

	  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
	    root = freeGlobal;
	  }

	  var Rx = {
	      internals: {},
	      config: {
	        Promise: root.Promise // Detect if promise exists
	      },
	      helpers: { }
	  };

	  // Defaults
	  var noop = Rx.helpers.noop = function () { },
	    notDefined = Rx.helpers.notDefined = function (x) { return typeof x === 'undefined'; },
	    isScheduler = Rx.helpers.isScheduler = function (x) { return x instanceof Rx.Scheduler; },
	    identity = Rx.helpers.identity = function (x) { return x; },
	    pluck = Rx.helpers.pluck = function (property) { return function (x) { return x[property]; }; },
	    just = Rx.helpers.just = function (value) { return function () { return value; }; },
	    defaultNow = Rx.helpers.defaultNow = Date.now,
	    defaultComparer = Rx.helpers.defaultComparer = function (x, y) { return isEqual(x, y); },
	    defaultSubComparer = Rx.helpers.defaultSubComparer = function (x, y) { return x > y ? 1 : (x < y ? -1 : 0); },
	    defaultKeySerializer = Rx.helpers.defaultKeySerializer = function (x) { return x.toString(); },
	    defaultError = Rx.helpers.defaultError = function (err) { throw err; },
	    isPromise = Rx.helpers.isPromise = function (p) { return !!p && typeof p.then === 'function'; },
	    asArray = Rx.helpers.asArray = function () { return Array.prototype.slice.call(arguments); },
	    not = Rx.helpers.not = function (a) { return !a; },
	    isFunction = Rx.helpers.isFunction = (function () {

	      var isFn = function (value) {
	        return typeof value == 'function' || false;
	      }

	      // fallback for older versions of Chrome and Safari
	      if (isFn(/x/)) {
	        isFn = function(value) {
	          return typeof value == 'function' && toString.call(value) == '[object Function]';
	        };
	      }

	      return isFn;
	    }());

	  // Errors
	  var sequenceContainsNoElements = 'Sequence contains no elements.';
	  var argumentOutOfRange = 'Argument out of range';
	  var objectDisposed = 'Object has been disposed';
	  function checkDisposed() { if (this.isDisposed) { throw new Error(objectDisposed); } }

	  // Shim in iterator support
	  var $iterator$ = (typeof Symbol === 'function' && Symbol.iterator) ||
	    '_es6shim_iterator_';
	  // Bug for mozilla version
	  if (root.Set && typeof new root.Set()['@@iterator'] === 'function') {
	    $iterator$ = '@@iterator';
	  }

	  var doneEnumerator = Rx.doneEnumerator = { done: true, value: undefined };

	  Rx.iterator = $iterator$;

	  /** `Object#toString` result shortcuts */
	  var argsClass = '[object Arguments]',
	    arrayClass = '[object Array]',
	    boolClass = '[object Boolean]',
	    dateClass = '[object Date]',
	    errorClass = '[object Error]',
	    funcClass = '[object Function]',
	    numberClass = '[object Number]',
	    objectClass = '[object Object]',
	    regexpClass = '[object RegExp]',
	    stringClass = '[object String]';

	  var toString = Object.prototype.toString,
	    hasOwnProperty = Object.prototype.hasOwnProperty,
	    supportsArgsClass = toString.call(arguments) == argsClass, // For less <IE9 && FF<4
	    suportNodeClass,
	    errorProto = Error.prototype,
	    objectProto = Object.prototype,
	    propertyIsEnumerable = objectProto.propertyIsEnumerable;

	  try {
	    suportNodeClass = !(toString.call(document) == objectClass && !({ 'toString': 0 } + ''));
	  } catch(e) {
	    suportNodeClass = true;
	  }

	  var shadowedProps = [
	    'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'
	  ];

	  var nonEnumProps = {};
	  nonEnumProps[arrayClass] = nonEnumProps[dateClass] = nonEnumProps[numberClass] = { 'constructor': true, 'toLocaleString': true, 'toString': true, 'valueOf': true };
	  nonEnumProps[boolClass] = nonEnumProps[stringClass] = { 'constructor': true, 'toString': true, 'valueOf': true };
	  nonEnumProps[errorClass] = nonEnumProps[funcClass] = nonEnumProps[regexpClass] = { 'constructor': true, 'toString': true };
	  nonEnumProps[objectClass] = { 'constructor': true };

	  var support = {};
	  (function () {
	    var ctor = function() { this.x = 1; },
	      props = [];

	    ctor.prototype = { 'valueOf': 1, 'y': 1 };
	    for (var key in new ctor) { props.push(key); }
	    for (key in arguments) { }

	    // Detect if `name` or `message` properties of `Error.prototype` are enumerable by default.
	    support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') || propertyIsEnumerable.call(errorProto, 'name');

	    // Detect if `prototype` properties are enumerable by default.
	    support.enumPrototypes = propertyIsEnumerable.call(ctor, 'prototype');

	    // Detect if `arguments` object indexes are non-enumerable
	    support.nonEnumArgs = key != 0;

	    // Detect if properties shadowing those on `Object.prototype` are non-enumerable.
	    support.nonEnumShadows = !/valueOf/.test(props);
	  }(1));

	  function isObject(value) {
	    // check if the value is the ECMAScript language type of Object
	    // http://es5.github.io/#x8
	    // and avoid a V8 bug
	    // https://code.google.com/p/v8/issues/detail?id=2291
	    var type = typeof value;
	    return value && (type == 'function' || type == 'object') || false;
	  }

	  function keysIn(object) {
	    var result = [];
	    if (!isObject(object)) {
	      return result;
	    }
	    if (support.nonEnumArgs && object.length && isArguments(object)) {
	      object = slice.call(object);
	    }
	    var skipProto = support.enumPrototypes && typeof object == 'function',
	        skipErrorProps = support.enumErrorProps && (object === errorProto || object instanceof Error);

	    for (var key in object) {
	      if (!(skipProto && key == 'prototype') &&
	          !(skipErrorProps && (key == 'message' || key == 'name'))) {
	        result.push(key);
	      }
	    }

	    if (support.nonEnumShadows && object !== objectProto) {
	      var ctor = object.constructor,
	          index = -1,
	          length = shadowedProps.length;

	      if (object === (ctor && ctor.prototype)) {
	        var className = object === stringProto ? stringClass : object === errorProto ? errorClass : toString.call(object),
	            nonEnum = nonEnumProps[className];
	      }
	      while (++index < length) {
	        key = shadowedProps[index];
	        if (!(nonEnum && nonEnum[key]) && hasOwnProperty.call(object, key)) {
	          result.push(key);
	        }
	      }
	    }
	    return result;
	  }

	  function internalFor(object, callback, keysFunc) {
	    var index = -1,
	      props = keysFunc(object),
	      length = props.length;

	    while (++index < length) {
	      var key = props[index];
	      if (callback(object[key], key, object) === false) {
	        break;
	      }
	    }
	    return object;
	  }

	  function internalForIn(object, callback) {
	    return internalFor(object, callback, keysIn);
	  }

	  function isNode(value) {
	    // IE < 9 presents DOM nodes as `Object` objects except they have `toString`
	    // methods that are `typeof` "string" and still can coerce nodes to strings
	    return typeof value.toString != 'function' && typeof (value + '') == 'string';
	  }

	  function isArguments(value) {
	    return (value && typeof value == 'object') ? toString.call(value) == argsClass : false;
	  }

	  // fallback for browsers that can't detect `arguments` objects by [[Class]]
	  if (!supportsArgsClass) {
	    isArguments = function(value) {
	      return (value && typeof value == 'object') ? hasOwnProperty.call(value, 'callee') : false;
	    };
	  }

	  var isEqual = Rx.internals.isEqual = function (x, y) {
	    return deepEquals(x, y, [], []);
	  };

	  /** @private
	   * Used for deep comparison
	   **/
	  function deepEquals(a, b, stackA, stackB) {
	    // exit early for identical values
	    if (a === b) {
	      // treat `+0` vs. `-0` as not equal
	      return a !== 0 || (1 / a == 1 / b);
	    }

	    var type = typeof a,
	        otherType = typeof b;

	    // exit early for unlike primitive values
	    if (a === a && (a == null || b == null ||
	        (type != 'function' && type != 'object' && otherType != 'function' && otherType != 'object'))) {
	      return false;
	    }

	    // compare [[Class]] names
	    var className = toString.call(a),
	        otherClass = toString.call(b);

	    if (className == argsClass) {
	      className = objectClass;
	    }
	    if (otherClass == argsClass) {
	      otherClass = objectClass;
	    }
	    if (className != otherClass) {
	      return false;
	    }
	    switch (className) {
	      case boolClass:
	      case dateClass:
	        // coerce dates and booleans to numbers, dates to milliseconds and booleans
	        // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
	        return +a == +b;

	      case numberClass:
	        // treat `NaN` vs. `NaN` as equal
	        return (a != +a)
	          ? b != +b
	          // but treat `-0` vs. `+0` as not equal
	          : (a == 0 ? (1 / a == 1 / b) : a == +b);

	      case regexpClass:
	      case stringClass:
	        // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
	        // treat string primitives and their corresponding object instances as equal
	        return a == String(b);
	    }
	    var isArr = className == arrayClass;
	    if (!isArr) {

	      // exit for functions and DOM nodes
	      if (className != objectClass || (!support.nodeClass && (isNode(a) || isNode(b)))) {
	        return false;
	      }
	      // in older versions of Opera, `arguments` objects have `Array` constructors
	      var ctorA = !support.argsObject && isArguments(a) ? Object : a.constructor,
	          ctorB = !support.argsObject && isArguments(b) ? Object : b.constructor;

	      // non `Object` object instances with different constructors are not equal
	      if (ctorA != ctorB &&
	            !(hasOwnProperty.call(a, 'constructor') && hasOwnProperty.call(b, 'constructor')) &&
	            !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
	            ('constructor' in a && 'constructor' in b)
	          ) {
	        return false;
	      }
	    }
	    // assume cyclic structures are equal
	    // the algorithm for detecting cyclic structures is adapted from ES 5.1
	    // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
	    var initedStack = !stackA;
	    stackA || (stackA = []);
	    stackB || (stackB = []);

	    var length = stackA.length;
	    while (length--) {
	      if (stackA[length] == a) {
	        return stackB[length] == b;
	      }
	    }
	    var size = 0;
	    var result = true;

	    // add `a` and `b` to the stack of traversed objects
	    stackA.push(a);
	    stackB.push(b);

	    // recursively compare objects and arrays (susceptible to call stack limits)
	    if (isArr) {
	      // compare lengths to determine if a deep comparison is necessary
	      length = a.length;
	      size = b.length;
	      result = size == length;

	      if (result) {
	        // deep compare the contents, ignoring non-numeric properties
	        while (size--) {
	          var index = length,
	              value = b[size];

	          if (!(result = deepEquals(a[size], value, stackA, stackB))) {
	            break;
	          }
	        }
	      }
	    }
	    else {
	      // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
	      // which, in this case, is more costly
	      internalForIn(b, function(value, key, b) {
	        if (hasOwnProperty.call(b, key)) {
	          // count the number of properties.
	          size++;
	          // deep compare each property value.
	          return (result = hasOwnProperty.call(a, key) && deepEquals(a[key], value, stackA, stackB));
	        }
	      });

	      if (result) {
	        // ensure both objects have the same number of properties
	        internalForIn(a, function(value, key, a) {
	          if (hasOwnProperty.call(a, key)) {
	            // `size` will be `-1` if `a` has more properties than `b`
	            return (result = --size > -1);
	          }
	        });
	      }
	    }
	    stackA.pop();
	    stackB.pop();

	    return result;
	  }

	  var slice = Array.prototype.slice;
	  function argsOrArray(args, idx) {
	    return args.length === 1 && Array.isArray(args[idx]) ?
	      args[idx] :
	      slice.call(args);
	  }
	  var hasProp = {}.hasOwnProperty;

	  var inherits = this.inherits = Rx.internals.inherits = function (child, parent) {
	    function __() { this.constructor = child; }
	    __.prototype = parent.prototype;
	    child.prototype = new __();
	  };

	  var addProperties = Rx.internals.addProperties = function (obj) {
	    var sources = slice.call(arguments, 1);
	    for (var i = 0, len = sources.length; i < len; i++) {
	      var source = sources[i];
	      for (var prop in source) {
	        obj[prop] = source[prop];
	      }
	    }
	  };

	  // Rx Utils
	  var addRef = Rx.internals.addRef = function (xs, r) {
	    return new AnonymousObservable(function (observer) {
	      return new CompositeDisposable(r.getDisposable(), xs.subscribe(observer));
	    });
	  };

	  function arrayInitialize(count, factory) {
	    var a = new Array(count);
	    for (var i = 0; i < count; i++) {
	      a[i] = factory();
	    }
	    return a;
	  }

	  // Collections
	  function IndexedItem(id, value) {
	    this.id = id;
	    this.value = value;
	  }

	  IndexedItem.prototype.compareTo = function (other) {
	    var c = this.value.compareTo(other.value);
	    c === 0 && (c = this.id - other.id);
	    return c;
	  };

	  // Priority Queue for Scheduling
	  var PriorityQueue = Rx.internals.PriorityQueue = function (capacity) {
	    this.items = new Array(capacity);
	    this.length = 0;
	  };

	  var priorityProto = PriorityQueue.prototype;
	  priorityProto.isHigherPriority = function (left, right) {
	    return this.items[left].compareTo(this.items[right]) < 0;
	  };

	  priorityProto.percolate = function (index) {
	    if (index >= this.length || index < 0) { return; }
	    var parent = index - 1 >> 1;
	    if (parent < 0 || parent === index) { return; }
	    if (this.isHigherPriority(index, parent)) {
	      var temp = this.items[index];
	      this.items[index] = this.items[parent];
	      this.items[parent] = temp;
	      this.percolate(parent);
	    }
	  };

	  priorityProto.heapify = function (index) {
	    +index || (index = 0);
	    if (index >= this.length || index < 0) { return; }
	    var left = 2 * index + 1,
	        right = 2 * index + 2,
	        first = index;
	    if (left < this.length && this.isHigherPriority(left, first)) {
	      first = left;
	    }
	    if (right < this.length && this.isHigherPriority(right, first)) {
	      first = right;
	    }
	    if (first !== index) {
	      var temp = this.items[index];
	      this.items[index] = this.items[first];
	      this.items[first] = temp;
	      this.heapify(first);
	    }
	  };

	  priorityProto.peek = function () { return this.items[0].value; };

	  priorityProto.removeAt = function (index) {
	    this.items[index] = this.items[--this.length];
	    delete this.items[this.length];
	    this.heapify();
	  };

	  priorityProto.dequeue = function () {
	    var result = this.peek();
	    this.removeAt(0);
	    return result;
	  };

	  priorityProto.enqueue = function (item) {
	    var index = this.length++;
	    this.items[index] = new IndexedItem(PriorityQueue.count++, item);
	    this.percolate(index);
	  };

	  priorityProto.remove = function (item) {
	    for (var i = 0; i < this.length; i++) {
	      if (this.items[i].value === item) {
	        this.removeAt(i);
	        return true;
	      }
	    }
	    return false;
	  };
	  PriorityQueue.count = 0;

	  /**
	   * Represents a group of disposable resources that are disposed together.
	   * @constructor
	   */
	  var CompositeDisposable = Rx.CompositeDisposable = function () {
	    this.disposables = argsOrArray(arguments, 0);
	    this.isDisposed = false;
	    this.length = this.disposables.length;
	  };

	  var CompositeDisposablePrototype = CompositeDisposable.prototype;

	  /**
	   * Adds a disposable to the CompositeDisposable or disposes the disposable if the CompositeDisposable is disposed.
	   * @param {Mixed} item Disposable to add.
	   */
	  CompositeDisposablePrototype.add = function (item) {
	    if (this.isDisposed) {
	      item.dispose();
	    } else {
	      this.disposables.push(item);
	      this.length++;
	    }
	  };

	  /**
	   * Removes and disposes the first occurrence of a disposable from the CompositeDisposable.
	   * @param {Mixed} item Disposable to remove.
	   * @returns {Boolean} true if found; false otherwise.
	   */
	  CompositeDisposablePrototype.remove = function (item) {
	    var shouldDispose = false;
	    if (!this.isDisposed) {
	      var idx = this.disposables.indexOf(item);
	      if (idx !== -1) {
	        shouldDispose = true;
	        this.disposables.splice(idx, 1);
	        this.length--;
	        item.dispose();
	      }
	    }
	    return shouldDispose;
	  };

	  /**
	   *  Disposes all disposables in the group and removes them from the group.
	   */
	  CompositeDisposablePrototype.dispose = function () {
	    if (!this.isDisposed) {
	      this.isDisposed = true;
	      var currentDisposables = this.disposables.slice(0);
	      this.disposables = [];
	      this.length = 0;

	      for (var i = 0, len = currentDisposables.length; i < len; i++) {
	        currentDisposables[i].dispose();
	      }
	    }
	  };

	  /**
	   * Converts the existing CompositeDisposable to an array of disposables
	   * @returns {Array} An array of disposable objects.
	   */
	  CompositeDisposablePrototype.toArray = function () {
	    return this.disposables.slice(0);
	  };

	  /**
	   * Provides a set of static methods for creating Disposables.
	   *
	   * @constructor
	   * @param {Function} dispose Action to run during the first call to dispose. The action is guaranteed to be run at most once.
	   */
	  var Disposable = Rx.Disposable = function (action) {
	    this.isDisposed = false;
	    this.action = action || noop;
	  };

	  /** Performs the task of cleaning up resources. */
	  Disposable.prototype.dispose = function () {
	    if (!this.isDisposed) {
	      this.action();
	      this.isDisposed = true;
	    }
	  };

	  /**
	   * Creates a disposable object that invokes the specified action when disposed.
	   * @param {Function} dispose Action to run during the first call to dispose. The action is guaranteed to be run at most once.
	   * @return {Disposable} The disposable object that runs the given action upon disposal.
	   */
	  var disposableCreate = Disposable.create = function (action) { return new Disposable(action); };

	  /**
	   * Gets the disposable that does nothing when disposed.
	   */
	  var disposableEmpty = Disposable.empty = { dispose: noop };

	  var SingleAssignmentDisposable = Rx.SingleAssignmentDisposable = (function () {
	    function BooleanDisposable () {
	      this.isDisposed = false;
	      this.current = null;
	    }

	    var booleanDisposablePrototype = BooleanDisposable.prototype;

	    /**
	     * Gets the underlying disposable.
	     * @return The underlying disposable.
	     */
	    booleanDisposablePrototype.getDisposable = function () {
	      return this.current;
	    };

	    /**
	     * Sets the underlying disposable.
	     * @param {Disposable} value The new underlying disposable.
	     */
	    booleanDisposablePrototype.setDisposable = function (value) {
	      var shouldDispose = this.isDisposed, old;
	      if (!shouldDispose) {
	        old = this.current;
	        this.current = value;
	      }
	      old && old.dispose();
	      shouldDispose && value && value.dispose();
	    };

	    /**
	     * Disposes the underlying disposable as well as all future replacements.
	     */
	    booleanDisposablePrototype.dispose = function () {
	      var old;
	      if (!this.isDisposed) {
	        this.isDisposed = true;
	        old = this.current;
	        this.current = null;
	      }
	      old && old.dispose();
	    };

	    return BooleanDisposable;
	  }());
	  var SerialDisposable = Rx.SerialDisposable = SingleAssignmentDisposable;

	    /**
	     * Represents a disposable resource that only disposes its underlying disposable resource when all dependent disposable objects have been disposed.
	     */
	    var RefCountDisposable = Rx.RefCountDisposable = (function () {

	        function InnerDisposable(disposable) {
	            this.disposable = disposable;
	            this.disposable.count++;
	            this.isInnerDisposed = false;
	        }

	        InnerDisposable.prototype.dispose = function () {
	            if (!this.disposable.isDisposed) {
	                if (!this.isInnerDisposed) {
	                    this.isInnerDisposed = true;
	                    this.disposable.count--;
	                    if (this.disposable.count === 0 && this.disposable.isPrimaryDisposed) {
	                        this.disposable.isDisposed = true;
	                        this.disposable.underlyingDisposable.dispose();
	                    }
	                }
	            }
	        };

	        /**
	         * Initializes a new instance of the RefCountDisposable with the specified disposable.
	         * @constructor
	         * @param {Disposable} disposable Underlying disposable.
	          */
	        function RefCountDisposable(disposable) {
	            this.underlyingDisposable = disposable;
	            this.isDisposed = false;
	            this.isPrimaryDisposed = false;
	            this.count = 0;
	        }

	        /**
	         * Disposes the underlying disposable only when all dependent disposables have been disposed
	         */
	        RefCountDisposable.prototype.dispose = function () {
	            if (!this.isDisposed) {
	                if (!this.isPrimaryDisposed) {
	                    this.isPrimaryDisposed = true;
	                    if (this.count === 0) {
	                        this.isDisposed = true;
	                        this.underlyingDisposable.dispose();
	                    }
	                }
	            }
	        };

	        /**
	         * Returns a dependent disposable that when disposed decreases the refcount on the underlying disposable.
	         * @returns {Disposable} A dependent disposable contributing to the reference count that manages the underlying disposable's lifetime.
	         */
	        RefCountDisposable.prototype.getDisposable = function () {
	            return this.isDisposed ? disposableEmpty : new InnerDisposable(this);
	        };

	        return RefCountDisposable;
	    })();

	    function ScheduledDisposable(scheduler, disposable) {
	        this.scheduler = scheduler;
	        this.disposable = disposable;
	        this.isDisposed = false;
	    }

	    ScheduledDisposable.prototype.dispose = function () {
	        var parent = this;
	        this.scheduler.schedule(function () {
	            if (!parent.isDisposed) {
	                parent.isDisposed = true;
	                parent.disposable.dispose();
	            }
	        });
	    };

	  var ScheduledItem = Rx.internals.ScheduledItem = function (scheduler, state, action, dueTime, comparer) {
	    this.scheduler = scheduler;
	    this.state = state;
	    this.action = action;
	    this.dueTime = dueTime;
	    this.comparer = comparer || defaultSubComparer;
	    this.disposable = new SingleAssignmentDisposable();
	  }

	  ScheduledItem.prototype.invoke = function () {
	    this.disposable.setDisposable(this.invokeCore());
	  };

	  ScheduledItem.prototype.compareTo = function (other) {
	    return this.comparer(this.dueTime, other.dueTime);
	  };

	  ScheduledItem.prototype.isCancelled = function () {
	    return this.disposable.isDisposed;
	  };

	  ScheduledItem.prototype.invokeCore = function () {
	    return this.action(this.scheduler, this.state);
	  };

	  /** Provides a set of static properties to access commonly used schedulers. */
	  var Scheduler = Rx.Scheduler = (function () {

	    function Scheduler(now, schedule, scheduleRelative, scheduleAbsolute) {
	      this.now = now;
	      this._schedule = schedule;
	      this._scheduleRelative = scheduleRelative;
	      this._scheduleAbsolute = scheduleAbsolute;
	    }

	    function invokeAction(scheduler, action) {
	      action();
	      return disposableEmpty;
	    }

	    var schedulerProto = Scheduler.prototype;

	    /**
	     * Schedules an action to be executed.
	     * @param {Function} action Action to execute.
	     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
	     */
	    schedulerProto.schedule = function (action) {
	      return this._schedule(action, invokeAction);
	    };

	    /**
	     * Schedules an action to be executed.
	     * @param state State passed to the action to be executed.
	     * @param {Function} action Action to be executed.
	     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
	     */
	    schedulerProto.scheduleWithState = function (state, action) {
	      return this._schedule(state, action);
	    };

	    /**
	     * Schedules an action to be executed after the specified relative due time.
	     * @param {Function} action Action to execute.
	     * @param {Number} dueTime Relative time after which to execute the action.
	     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
	     */
	    schedulerProto.scheduleWithRelative = function (dueTime, action) {
	      return this._scheduleRelative(action, dueTime, invokeAction);
	    };

	    /**
	     * Schedules an action to be executed after dueTime.
	     * @param state State passed to the action to be executed.
	     * @param {Function} action Action to be executed.
	     * @param {Number} dueTime Relative time after which to execute the action.
	     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
	     */
	    schedulerProto.scheduleWithRelativeAndState = function (state, dueTime, action) {
	      return this._scheduleRelative(state, dueTime, action);
	    };

	    /**
	     * Schedules an action to be executed at the specified absolute due time.
	     * @param {Function} action Action to execute.
	     * @param {Number} dueTime Absolute time at which to execute the action.
	     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
	      */
	    schedulerProto.scheduleWithAbsolute = function (dueTime, action) {
	      return this._scheduleAbsolute(action, dueTime, invokeAction);
	    };

	    /**
	     * Schedules an action to be executed at dueTime.
	     * @param {Mixed} state State passed to the action to be executed.
	     * @param {Function} action Action to be executed.
	     * @param {Number}dueTime Absolute time at which to execute the action.
	     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
	     */
	    schedulerProto.scheduleWithAbsoluteAndState = function (state, dueTime, action) {
	      return this._scheduleAbsolute(state, dueTime, action);
	    };

	    /** Gets the current time according to the local machine's system clock. */
	    Scheduler.now = defaultNow;

	    /**
	     * Normalizes the specified TimeSpan value to a positive value.
	     * @param {Number} timeSpan The time span value to normalize.
	     * @returns {Number} The specified TimeSpan value if it is zero or positive; otherwise, 0
	     */
	    Scheduler.normalize = function (timeSpan) {
	      timeSpan < 0 && (timeSpan = 0);
	      return timeSpan;
	    };

	    return Scheduler;
	  }());

	  var normalizeTime = Scheduler.normalize;

	  (function (schedulerProto) {
	    function invokeRecImmediate(scheduler, pair) {
	      var state = pair.first, action = pair.second, group = new CompositeDisposable(),
	      recursiveAction = function (state1) {
	        action(state1, function (state2) {
	          var isAdded = false, isDone = false,
	          d = scheduler.scheduleWithState(state2, function (scheduler1, state3) {
	            if (isAdded) {
	              group.remove(d);
	            } else {
	              isDone = true;
	            }
	            recursiveAction(state3);
	            return disposableEmpty;
	          });
	          if (!isDone) {
	            group.add(d);
	            isAdded = true;
	          }
	        });
	      };
	      recursiveAction(state);
	      return group;
	    }

	    function invokeRecDate(scheduler, pair, method) {
	      var state = pair.first, action = pair.second, group = new CompositeDisposable(),
	      recursiveAction = function (state1) {
	        action(state1, function (state2, dueTime1) {
	          var isAdded = false, isDone = false,
	          d = scheduler[method].call(scheduler, state2, dueTime1, function (scheduler1, state3) {
	            if (isAdded) {
	              group.remove(d);
	            } else {
	              isDone = true;
	            }
	            recursiveAction(state3);
	            return disposableEmpty;
	          });
	          if (!isDone) {
	            group.add(d);
	            isAdded = true;
	          }
	        });
	      };
	      recursiveAction(state);
	      return group;
	    }

	    function scheduleInnerRecursive(action, self) {
	      action(function(dt) { self(action, dt); });
	    }

	    /**
	     * Schedules an action to be executed recursively.
	     * @param {Function} action Action to execute recursively. The parameter passed to the action is used to trigger recursive scheduling of the action.
	     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
	     */
	    schedulerProto.scheduleRecursive = function (action) {
	      return this.scheduleRecursiveWithState(action, function (_action, self) {
	        _action(function () { self(_action); }); });
	    };

	    /**
	     * Schedules an action to be executed recursively.
	     * @param {Mixed} state State passed to the action to be executed.
	     * @param {Function} action Action to execute recursively. The last parameter passed to the action is used to trigger recursive scheduling of the action, passing in recursive invocation state.
	     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
	     */
	    schedulerProto.scheduleRecursiveWithState = function (state, action) {
	      return this.scheduleWithState({ first: state, second: action }, invokeRecImmediate);
	    };

	    /**
	     * Schedules an action to be executed recursively after a specified relative due time.
	     * @param {Function} action Action to execute recursively. The parameter passed to the action is used to trigger recursive scheduling of the action at the specified relative time.
	     * @param {Number}dueTime Relative time after which to execute the action for the first time.
	     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
	     */
	    schedulerProto.scheduleRecursiveWithRelative = function (dueTime, action) {
	      return this.scheduleRecursiveWithRelativeAndState(action, dueTime, scheduleInnerRecursive);
	    };

	    /**
	     * Schedules an action to be executed recursively after a specified relative due time.
	     * @param {Mixed} state State passed to the action to be executed.
	     * @param {Function} action Action to execute recursively. The last parameter passed to the action is used to trigger recursive scheduling of the action, passing in the recursive due time and invocation state.
	     * @param {Number}dueTime Relative time after which to execute the action for the first time.
	     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
	     */
	    schedulerProto.scheduleRecursiveWithRelativeAndState = function (state, dueTime, action) {
	      return this._scheduleRelative({ first: state, second: action }, dueTime, function (s, p) {
	        return invokeRecDate(s, p, 'scheduleWithRelativeAndState');
	      });
	    };

	    /**
	     * Schedules an action to be executed recursively at a specified absolute due time.
	     * @param {Function} action Action to execute recursively. The parameter passed to the action is used to trigger recursive scheduling of the action at the specified absolute time.
	     * @param {Number}dueTime Absolute time at which to execute the action for the first time.
	     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
	     */
	    schedulerProto.scheduleRecursiveWithAbsolute = function (dueTime, action) {
	      return this.scheduleRecursiveWithAbsoluteAndState(action, dueTime, scheduleInnerRecursive);
	    };

	    /**
	     * Schedules an action to be executed recursively at a specified absolute due time.
	     * @param {Mixed} state State passed to the action to be executed.
	     * @param {Function} action Action to execute recursively. The last parameter passed to the action is used to trigger recursive scheduling of the action, passing in the recursive due time and invocation state.
	     * @param {Number}dueTime Absolute time at which to execute the action for the first time.
	     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
	     */
	    schedulerProto.scheduleRecursiveWithAbsoluteAndState = function (state, dueTime, action) {
	      return this._scheduleAbsolute({ first: state, second: action }, dueTime, function (s, p) {
	        return invokeRecDate(s, p, 'scheduleWithAbsoluteAndState');
	      });
	    };
	  }(Scheduler.prototype));

	  (function (schedulerProto) {

	    /**
	     * Schedules a periodic piece of work by dynamically discovering the scheduler's capabilities. The periodic task will be scheduled using window.setInterval for the base implementation.
	     * @param {Number} period Period for running the work periodically.
	     * @param {Function} action Action to be executed.
	     * @returns {Disposable} The disposable object used to cancel the scheduled recurring action (best effort).
	     */
	    Scheduler.prototype.schedulePeriodic = function (period, action) {
	      return this.schedulePeriodicWithState(null, period, action);
	    };

	    /**
	     * Schedules a periodic piece of work by dynamically discovering the scheduler's capabilities. The periodic task will be scheduled using window.setInterval for the base implementation.
	     * @param {Mixed} state Initial state passed to the action upon the first iteration.
	     * @param {Number} period Period for running the work periodically.
	     * @param {Function} action Action to be executed, potentially updating the state.
	     * @returns {Disposable} The disposable object used to cancel the scheduled recurring action (best effort).
	     */
	    Scheduler.prototype.schedulePeriodicWithState = function(state, period, action) {
	      if (typeof root.setInterval === 'undefined') { throw new Error('Periodic scheduling not supported.'); }
	      var s = state;

	      var id = root.setInterval(function () {
	        s = action(s);
	      }, period);

	      return disposableCreate(function () {
	        root.clearInterval(id);
	      });
	    };

	  }(Scheduler.prototype));

	  (function (schedulerProto) {
	    /**
	     * Returns a scheduler that wraps the original scheduler, adding exception handling for scheduled actions.
	     * @param {Function} handler Handler that's run if an exception is caught. The exception will be rethrown if the handler returns false.
	     * @returns {Scheduler} Wrapper around the original scheduler, enforcing exception handling.
	     */
	    schedulerProto.catchError = schedulerProto['catch'] = function (handler) {
	      return new CatchScheduler(this, handler);
	    };
	  }(Scheduler.prototype));

	  var SchedulePeriodicRecursive = Rx.internals.SchedulePeriodicRecursive = (function () {
	    function tick(command, recurse) {
	      recurse(0, this._period);
	      try {
	        this._state = this._action(this._state);
	      } catch (e) {
	        this._cancel.dispose();
	        throw e;
	      }
	    }

	    function SchedulePeriodicRecursive(scheduler, state, period, action) {
	      this._scheduler = scheduler;
	      this._state = state;
	      this._period = period;
	      this._action = action;
	    }

	    SchedulePeriodicRecursive.prototype.start = function () {
	      var d = new SingleAssignmentDisposable();
	      this._cancel = d;
	      d.setDisposable(this._scheduler.scheduleRecursiveWithRelativeAndState(0, this._period, tick.bind(this)));

	      return d;
	    };

	    return SchedulePeriodicRecursive;
	  }());

	  /**
	   * Gets a scheduler that schedules work immediately on the current thread.
	   */
	  var immediateScheduler = Scheduler.immediate = (function () {

	    function scheduleNow(state, action) { return action(this, state); }

	    function scheduleRelative(state, dueTime, action) {
	      var dt = normalizeTime(dt);
	      while (dt - this.now() > 0) { }
	      return action(this, state);
	    }

	    function scheduleAbsolute(state, dueTime, action) {
	      return this.scheduleWithRelativeAndState(state, dueTime - this.now(), action);
	    }

	    return new Scheduler(defaultNow, scheduleNow, scheduleRelative, scheduleAbsolute);
	  }());

	  /**
	   * Gets a scheduler that schedules work as soon as possible on the current thread.
	   */
	  var currentThreadScheduler = Scheduler.currentThread = (function () {
	    var queue;

	    function runTrampoline (q) {
	      var item;
	      while (q.length > 0) {
	        item = q.dequeue();
	        if (!item.isCancelled()) {
	          // Note, do not schedule blocking work!
	          while (item.dueTime - Scheduler.now() > 0) {
	          }
	          if (!item.isCancelled()) {
	            item.invoke();
	          }
	        }
	      }
	    }

	    function scheduleNow(state, action) {
	      return this.scheduleWithRelativeAndState(state, 0, action);
	    }

	    function scheduleRelative(state, dueTime, action) {
	      var dt = this.now() + Scheduler.normalize(dueTime),
	          si = new ScheduledItem(this, state, action, dt);

	      if (!queue) {
	        queue = new PriorityQueue(4);
	        queue.enqueue(si);
	        try {
	          runTrampoline(queue);
	        } catch (e) {
	          throw e;
	        } finally {
	          queue = null;
	        }
	      } else {
	        queue.enqueue(si);
	      }
	      return si.disposable;
	    }

	    function scheduleAbsolute(state, dueTime, action) {
	      return this.scheduleWithRelativeAndState(state, dueTime - this.now(), action);
	    }

	    var currentScheduler = new Scheduler(defaultNow, scheduleNow, scheduleRelative, scheduleAbsolute);

	    currentScheduler.scheduleRequired = function () { return !queue; };
	    currentScheduler.ensureTrampoline = function (action) {
	      if (!queue) { this.schedule(action); } else { action(); }
	    };

	    return currentScheduler;
	  }());

	  var scheduleMethod, clearMethod = noop;
	  var localTimer = (function () {
	    var localSetTimeout, localClearTimeout = noop;
	    if ('WScript' in this) {
	      localSetTimeout = function (fn, time) {
	        WScript.Sleep(time);
	        fn();
	      };
	    } else if (!!root.setTimeout) {
	      localSetTimeout = root.setTimeout;
	      localClearTimeout = root.clearTimeout;
	    } else {
	      throw new Error('No concurrency detected!');
	    }

	    return {
	      setTimeout: localSetTimeout,
	      clearTimeout: localClearTimeout
	    };
	  }());
	  var localSetTimeout = localTimer.setTimeout,
	    localClearTimeout = localTimer.clearTimeout;

	  (function () {

	    var reNative = RegExp('^' +
	      String(toString)
	        .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
	        .replace(/toString| for [^\]]+/g, '.*?') + '$'
	    );

	    var setImmediate = typeof (setImmediate = freeGlobal && moduleExports && freeGlobal.setImmediate) == 'function' &&
	      !reNative.test(setImmediate) && setImmediate,
	      clearImmediate = typeof (clearImmediate = freeGlobal && moduleExports && freeGlobal.clearImmediate) == 'function' &&
	      !reNative.test(clearImmediate) && clearImmediate;

	    function postMessageSupported () {
	      // Ensure not in a worker
	      if (!root.postMessage || root.importScripts) { return false; }
	      var isAsync = false,
	          oldHandler = root.onmessage;
	      // Test for async
	      root.onmessage = function () { isAsync = true; };
	      root.postMessage('','*');
	      root.onmessage = oldHandler;

	      return isAsync;
	    }

	    // Use in order, nextTick, setImmediate, postMessage, MessageChannel, script readystatechanged, setTimeout
	    if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
	      scheduleMethod = process.nextTick;
	    } else if (typeof setImmediate === 'function') {
	      scheduleMethod = setImmediate;
	      clearMethod = clearImmediate;
	    } else if (postMessageSupported()) {
	      var MSG_PREFIX = 'ms.rx.schedule' + Math.random(),
	        tasks = {},
	        taskId = 0;

	      function onGlobalPostMessage(event) {
	        // Only if we're a match to avoid any other global events
	        if (typeof event.data === 'string' && event.data.substring(0, MSG_PREFIX.length) === MSG_PREFIX) {
	          var handleId = event.data.substring(MSG_PREFIX.length),
	            action = tasks[handleId];
	          action();
	          delete tasks[handleId];
	        }
	      }

	      if (root.addEventListener) {
	        root.addEventListener('message', onGlobalPostMessage, false);
	      } else {
	        root.attachEvent('onmessage', onGlobalPostMessage, false);
	      }

	      scheduleMethod = function (action) {
	        var currentId = taskId++;
	        tasks[currentId] = action;
	        root.postMessage(MSG_PREFIX + currentId, '*');
	      };
	    } else if (!!root.MessageChannel) {
	      var channel = new root.MessageChannel(),
	        channelTasks = {},
	        channelTaskId = 0;

	      channel.port1.onmessage = function (event) {
	        var id = event.data,
	          action = channelTasks[id];
	        action();
	        delete channelTasks[id];
	      };

	      scheduleMethod = function (action) {
	        var id = channelTaskId++;
	        channelTasks[id] = action;
	        channel.port2.postMessage(id);
	      };
	    } else if ('document' in root && 'onreadystatechange' in root.document.createElement('script')) {

	      scheduleMethod = function (action) {
	        var scriptElement = root.document.createElement('script');
	        scriptElement.onreadystatechange = function () {
	          action();
	          scriptElement.onreadystatechange = null;
	          scriptElement.parentNode.removeChild(scriptElement);
	          scriptElement = null;
	        };
	        root.document.documentElement.appendChild(scriptElement);
	      };

	    } else {
	      scheduleMethod = function (action) { return localSetTimeout(action, 0); };
	      clearMethod = localClearTimeout;
	    }
	  }());

	  /**
	   * Gets a scheduler that schedules work via a timed callback based upon platform.
	   */
	  var timeoutScheduler = Scheduler.timeout = (function () {

	    function scheduleNow(state, action) {
	      var scheduler = this,
	        disposable = new SingleAssignmentDisposable();
	      var id = scheduleMethod(function () {
	        if (!disposable.isDisposed) {
	          disposable.setDisposable(action(scheduler, state));
	        }
	      });
	      return new CompositeDisposable(disposable, disposableCreate(function () {
	        clearMethod(id);
	      }));
	    }

	    function scheduleRelative(state, dueTime, action) {
	      var scheduler = this,
	        dt = Scheduler.normalize(dueTime);
	      if (dt === 0) {
	        return scheduler.scheduleWithState(state, action);
	      }
	      var disposable = new SingleAssignmentDisposable();
	      var id = localSetTimeout(function () {
	        if (!disposable.isDisposed) {
	          disposable.setDisposable(action(scheduler, state));
	        }
	      }, dt);
	      return new CompositeDisposable(disposable, disposableCreate(function () {
	        localClearTimeout(id);
	      }));
	    }

	    function scheduleAbsolute(state, dueTime, action) {
	      return this.scheduleWithRelativeAndState(state, dueTime - this.now(), action);
	    }

	    return new Scheduler(defaultNow, scheduleNow, scheduleRelative, scheduleAbsolute);
	  })();

	  var CatchScheduler = (function (__super__) {

	    function scheduleNow(state, action) {
	      return this._scheduler.scheduleWithState(state, this._wrap(action));
	    }

	    function scheduleRelative(state, dueTime, action) {
	      return this._scheduler.scheduleWithRelativeAndState(state, dueTime, this._wrap(action));
	    }

	    function scheduleAbsolute(state, dueTime, action) {
	      return this._scheduler.scheduleWithAbsoluteAndState(state, dueTime, this._wrap(action));
	    }

	    inherits(CatchScheduler, __super__);

	    function CatchScheduler(scheduler, handler) {
	      this._scheduler = scheduler;
	      this._handler = handler;
	      this._recursiveOriginal = null;
	      this._recursiveWrapper = null;
	      __super__.call(this, this._scheduler.now.bind(this._scheduler), scheduleNow, scheduleRelative, scheduleAbsolute);
	    }

	    CatchScheduler.prototype._clone = function (scheduler) {
	        return new CatchScheduler(scheduler, this._handler);
	    };

	    CatchScheduler.prototype._wrap = function (action) {
	      var parent = this;
	      return function (self, state) {
	        try {
	          return action(parent._getRecursiveWrapper(self), state);
	        } catch (e) {
	          if (!parent._handler(e)) { throw e; }
	          return disposableEmpty;
	        }
	      };
	    };

	    CatchScheduler.prototype._getRecursiveWrapper = function (scheduler) {
	      if (this._recursiveOriginal !== scheduler) {
	        this._recursiveOriginal = scheduler;
	        var wrapper = this._clone(scheduler);
	        wrapper._recursiveOriginal = scheduler;
	        wrapper._recursiveWrapper = wrapper;
	        this._recursiveWrapper = wrapper;
	      }
	      return this._recursiveWrapper;
	    };

	    CatchScheduler.prototype.schedulePeriodicWithState = function (state, period, action) {
	      var self = this, failed = false, d = new SingleAssignmentDisposable();

	      d.setDisposable(this._scheduler.schedulePeriodicWithState(state, period, function (state1) {
	        if (failed) { return null; }
	        try {
	          return action(state1);
	        } catch (e) {
	          failed = true;
	          if (!self._handler(e)) { throw e; }
	          d.dispose();
	          return null;
	        }
	      }));

	      return d;
	    };

	    return CatchScheduler;
	  }(Scheduler));

	  /**
	   *  Represents a notification to an observer.
	   */
	  var Notification = Rx.Notification = (function () {
	    function Notification(kind, hasValue) {
	      this.hasValue = hasValue == null ? false : hasValue;
	      this.kind = kind;
	    }

	    /**
	     * Invokes the delegate corresponding to the notification or the observer's method corresponding to the notification and returns the produced result.
	     *
	     * @memberOf Notification
	     * @param {Any} observerOrOnNext Delegate to invoke for an OnNext notification or Observer to invoke the notification on..
	     * @param {Function} onError Delegate to invoke for an OnError notification.
	     * @param {Function} onCompleted Delegate to invoke for an OnCompleted notification.
	     * @returns {Any} Result produced by the observation.
	     */
	    Notification.prototype.accept = function (observerOrOnNext, onError, onCompleted) {
	      return observerOrOnNext && typeof observerOrOnNext === 'object' ?
	        this._acceptObservable(observerOrOnNext) :
	        this._accept(observerOrOnNext, onError, onCompleted);
	    };

	    /**
	     * Returns an observable sequence with a single notification.
	     *
	     * @memberOf Notifications
	     * @param {Scheduler} [scheduler] Scheduler to send out the notification calls on.
	     * @returns {Observable} The observable sequence that surfaces the behavior of the notification upon subscription.
	     */
	    Notification.prototype.toObservable = function (scheduler) {
	      var notification = this;
	      isScheduler(scheduler) || (scheduler = immediateScheduler);
	      return new AnonymousObservable(function (observer) {
	        return scheduler.schedule(function () {
	          notification._acceptObservable(observer);
	          notification.kind === 'N' && observer.onCompleted();
	        });
	      });
	    };

	    return Notification;
	  })();

	  /**
	   * Creates an object that represents an OnNext notification to an observer.
	   * @param {Any} value The value contained in the notification.
	   * @returns {Notification} The OnNext notification containing the value.
	   */
	  var notificationCreateOnNext = Notification.createOnNext = (function () {

	      function _accept (onNext) { return onNext(this.value); }
	      function _acceptObservable(observer) { return observer.onNext(this.value); }
	      function toString () { return 'OnNext(' + this.value + ')'; }

	      return function (value) {
	        var notification = new Notification('N', true);
	        notification.value = value;
	        notification._accept = _accept;
	        notification._acceptObservable = _acceptObservable;
	        notification.toString = toString;
	        return notification;
	      };
	  }());

	  /**
	   * Creates an object that represents an OnError notification to an observer.
	   * @param {Any} error The exception contained in the notification.
	   * @returns {Notification} The OnError notification containing the exception.
	   */
	  var notificationCreateOnError = Notification.createOnError = (function () {

	    function _accept (onNext, onError) { return onError(this.exception); }
	    function _acceptObservable(observer) { return observer.onError(this.exception); }
	    function toString () { return 'OnError(' + this.exception + ')'; }

	    return function (e) {
	      var notification = new Notification('E');
	      notification.exception = e;
	      notification._accept = _accept;
	      notification._acceptObservable = _acceptObservable;
	      notification.toString = toString;
	      return notification;
	    };
	  }());

	  /**
	   * Creates an object that represents an OnCompleted notification to an observer.
	   * @returns {Notification} The OnCompleted notification.
	   */
	  var notificationCreateOnCompleted = Notification.createOnCompleted = (function () {

	    function _accept (onNext, onError, onCompleted) { return onCompleted(); }
	    function _acceptObservable(observer) { return observer.onCompleted(); }
	    function toString () { return 'OnCompleted()'; }

	    return function () {
	      var notification = new Notification('C');
	      notification._accept = _accept;
	      notification._acceptObservable = _acceptObservable;
	      notification.toString = toString;
	      return notification;
	    };
	  }());

	  var Enumerator = Rx.internals.Enumerator = function (next) {
	    this._next = next;
	  };

	  Enumerator.prototype.next = function () {
	    return this._next();
	  };

	  Enumerator.prototype[$iterator$] = function () { return this; }

	  var Enumerable = Rx.internals.Enumerable = function (iterator) {
	    this._iterator = iterator;
	  };

	  Enumerable.prototype[$iterator$] = function () {
	    return this._iterator();
	  };

	  Enumerable.prototype.concat = function () {
	    var sources = this;
	    return new AnonymousObservable(function (observer) {
	      var e;
	      try {
	        e = sources[$iterator$]();
	      } catch(err) {
	        observer.onError();
	        return;
	      }

	      var isDisposed,
	        subscription = new SerialDisposable();
	      var cancelable = immediateScheduler.scheduleRecursive(function (self) {
	        var currentItem;
	        if (isDisposed) { return; }

	        try {
	          currentItem = e.next();
	        } catch (ex) {
	          observer.onError(ex);
	          return;
	        }

	        if (currentItem.done) {
	          observer.onCompleted();
	          return;
	        }

	        // Check if promise
	        var currentValue = currentItem.value;
	        isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));

	        var d = new SingleAssignmentDisposable();
	        subscription.setDisposable(d);
	        d.setDisposable(currentValue.subscribe(
	          observer.onNext.bind(observer),
	          observer.onError.bind(observer),
	          function () { self(); })
	        );
	      });

	      return new CompositeDisposable(subscription, cancelable, disposableCreate(function () {
	        isDisposed = true;
	      }));
	    });
	  };

	  Enumerable.prototype.catchException = function () {
	    var sources = this;
	    return new AnonymousObservable(function (observer) {
	      var e;
	      try {
	        e = sources[$iterator$]();
	      } catch(err) {
	        observer.onError();
	        return;
	      }

	      var isDisposed,
	        lastException,
	        subscription = new SerialDisposable();
	      var cancelable = immediateScheduler.scheduleRecursive(function (self) {
	        if (isDisposed) { return; }

	        var currentItem;
	        try {
	          currentItem = e.next();
	        } catch (ex) {
	          observer.onError(ex);
	          return;
	        }

	        if (currentItem.done) {
	          if (lastException) {
	            observer.onError(lastException);
	          } else {
	            observer.onCompleted();
	          }
	          return;
	        }

	        // Check if promise
	        var currentValue = currentItem.value;
	        isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));

	        var d = new SingleAssignmentDisposable();
	        subscription.setDisposable(d);
	        d.setDisposable(currentValue.subscribe(
	          observer.onNext.bind(observer),
	          function (exn) {
	            lastException = exn;
	            self();
	          },
	          observer.onCompleted.bind(observer)));
	      });
	      return new CompositeDisposable(subscription, cancelable, disposableCreate(function () {
	        isDisposed = true;
	      }));
	    });
	  };

	  var enumerableRepeat = Enumerable.repeat = function (value, repeatCount) {
	    if (repeatCount == null) { repeatCount = -1; }
	    return new Enumerable(function () {
	      var left = repeatCount;
	      return new Enumerator(function () {
	        if (left === 0) { return doneEnumerator; }
	        if (left > 0) { left--; }
	        return { done: false, value: value };
	      });
	    });
	  };

	  var enumerableOf = Enumerable.of = function (source, selector, thisArg) {
	    selector || (selector = identity);
	    return new Enumerable(function () {
	      var index = -1;
	      return new Enumerator(
	        function () {
	          return ++index < source.length ?
	            { done: false, value: selector.call(thisArg, source[index], index, source) } :
	            doneEnumerator;
	        });
	    });
	  };

	  /**
	   * Supports push-style iteration over an observable sequence.
	   */
	  var Observer = Rx.Observer = function () { };

	  /**
	   *  Creates a notification callback from an observer.
	   * @returns The action that forwards its input notification to the underlying observer.
	   */
	  Observer.prototype.toNotifier = function () {
	    var observer = this;
	    return function (n) { return n.accept(observer); };
	  };

	  /**
	   *  Hides the identity of an observer.
	   * @returns An observer that hides the identity of the specified observer.
	   */
	  Observer.prototype.asObserver = function () {
	    return new AnonymousObserver(this.onNext.bind(this), this.onError.bind(this), this.onCompleted.bind(this));
	  };

	  /**
	   *  Checks access to the observer for grammar violations. This includes checking for multiple OnError or OnCompleted calls, as well as reentrancy in any of the observer methods.
	   *  If a violation is detected, an Error is thrown from the offending observer method call.
	   * @returns An observer that checks callbacks invocations against the observer grammar and, if the checks pass, forwards those to the specified observer.
	   */
	  Observer.prototype.checked = function () { return new CheckedObserver(this); };

	  /**
	   *  Creates an observer from the specified OnNext, along with optional OnError, and OnCompleted actions.
	   * @param {Function} [onNext] Observer's OnNext action implementation.
	   * @param {Function} [onError] Observer's OnError action implementation.
	   * @param {Function} [onCompleted] Observer's OnCompleted action implementation.
	   * @returns {Observer} The observer object implemented using the given actions.
	   */
	  var observerCreate = Observer.create = function (onNext, onError, onCompleted) {
	    onNext || (onNext = noop);
	    onError || (onError = defaultError);
	    onCompleted || (onCompleted = noop);
	    return new AnonymousObserver(onNext, onError, onCompleted);
	  };

	  /**
	   *  Creates an observer from a notification callback.
	   *
	   * @static
	   * @memberOf Observer
	   * @param {Function} handler Action that handles a notification.
	   * @returns The observer object that invokes the specified handler using a notification corresponding to each message it receives.
	   */
	  Observer.fromNotifier = function (handler, thisArg) {
	    return new AnonymousObserver(function (x) {
	      return handler.call(thisArg, notificationCreateOnNext(x));
	    }, function (e) {
	      return handler.call(thisArg, notificationCreateOnError(e));
	    }, function () {
	      return handler.call(thisArg, notificationCreateOnCompleted());
	    });
	  };

	  /**
	   * Schedules the invocation of observer methods on the given scheduler.
	   * @param {Scheduler} scheduler Scheduler to schedule observer messages on.
	   * @returns {Observer} Observer whose messages are scheduled on the given scheduler.
	   */
	  Observer.notifyOn = function (scheduler) {
	    return new ObserveOnObserver(scheduler, this);
	  };

	  /**
	   * Abstract base class for implementations of the Observer class.
	   * This base class enforces the grammar of observers where OnError and OnCompleted are terminal messages.
	   */
	  var AbstractObserver = Rx.internals.AbstractObserver = (function (__super__) {
	    inherits(AbstractObserver, __super__);

	    /**
	     * Creates a new observer in a non-stopped state.
	     */
	    function AbstractObserver() {
	      this.isStopped = false;
	      __super__.call(this);
	    }

	    /**
	     * Notifies the observer of a new element in the sequence.
	     * @param {Any} value Next element in the sequence.
	     */
	    AbstractObserver.prototype.onNext = function (value) {
	      if (!this.isStopped) { this.next(value); }
	    };

	    /**
	     * Notifies the observer that an exception has occurred.
	     * @param {Any} error The error that has occurred.
	     */
	    AbstractObserver.prototype.onError = function (error) {
	      if (!this.isStopped) {
	        this.isStopped = true;
	        this.error(error);
	      }
	    };

	    /**
	     * Notifies the observer of the end of the sequence.
	     */
	    AbstractObserver.prototype.onCompleted = function () {
	      if (!this.isStopped) {
	        this.isStopped = true;
	        this.completed();
	      }
	    };

	    /**
	     * Disposes the observer, causing it to transition to the stopped state.
	     */
	    AbstractObserver.prototype.dispose = function () {
	      this.isStopped = true;
	    };

	    AbstractObserver.prototype.fail = function (e) {
	      if (!this.isStopped) {
	        this.isStopped = true;
	        this.error(e);
	        return true;
	      }

	      return false;
	    };

	    return AbstractObserver;
	  }(Observer));

	  /**
	   * Class to create an Observer instance from delegate-based implementations of the on* methods.
	   */
	  var AnonymousObserver = Rx.AnonymousObserver = (function (__super__) {
	    inherits(AnonymousObserver, __super__);

	    /**
	     * Creates an observer from the specified OnNext, OnError, and OnCompleted actions.
	     * @param {Any} onNext Observer's OnNext action implementation.
	     * @param {Any} onError Observer's OnError action implementation.
	     * @param {Any} onCompleted Observer's OnCompleted action implementation.
	     */
	    function AnonymousObserver(onNext, onError, onCompleted) {
	      __super__.call(this);
	      this._onNext = onNext;
	      this._onError = onError;
	      this._onCompleted = onCompleted;
	    }

	    /**
	     * Calls the onNext action.
	     * @param {Any} value Next element in the sequence.
	     */
	    AnonymousObserver.prototype.next = function (value) {
	      this._onNext(value);
	    };

	    /**
	     * Calls the onError action.
	     * @param {Any} error The error that has occurred.
	     */
	    AnonymousObserver.prototype.error = function (error) {
	      this._onError(error);
	    };

	    /**
	     *  Calls the onCompleted action.
	     */
	    AnonymousObserver.prototype.completed = function () {
	      this._onCompleted();
	    };

	    return AnonymousObserver;
	  }(AbstractObserver));

	    var CheckedObserver = (function (_super) {
	        inherits(CheckedObserver, _super);

	        function CheckedObserver(observer) {
	            _super.call(this);
	            this._observer = observer;
	            this._state = 0; // 0 - idle, 1 - busy, 2 - done
	        }

	        var CheckedObserverPrototype = CheckedObserver.prototype;

	        CheckedObserverPrototype.onNext = function (value) {
	            this.checkAccess();
	            try {
	                this._observer.onNext(value);
	            } catch (e) {
	                throw e;
	            } finally {
	                this._state = 0;
	            }
	        };

	        CheckedObserverPrototype.onError = function (err) {
	            this.checkAccess();
	            try {
	                this._observer.onError(err);
	            } catch (e) {
	                throw e;
	            } finally {
	                this._state = 2;
	            }
	        };

	        CheckedObserverPrototype.onCompleted = function () {
	            this.checkAccess();
	            try {
	                this._observer.onCompleted();
	            } catch (e) {
	                throw e;
	            } finally {
	                this._state = 2;
	            }
	        };

	        CheckedObserverPrototype.checkAccess = function () {
	            if (this._state === 1) { throw new Error('Re-entrancy detected'); }
	            if (this._state === 2) { throw new Error('Observer completed'); }
	            if (this._state === 0) { this._state = 1; }
	        };

	        return CheckedObserver;
	    }(Observer));

	  var ScheduledObserver = Rx.internals.ScheduledObserver = (function (__super__) {
	    inherits(ScheduledObserver, __super__);

	    function ScheduledObserver(scheduler, observer) {
	      __super__.call(this);
	      this.scheduler = scheduler;
	      this.observer = observer;
	      this.isAcquired = false;
	      this.hasFaulted = false;
	      this.queue = [];
	      this.disposable = new SerialDisposable();
	    }

	    ScheduledObserver.prototype.next = function (value) {
	      var self = this;
	      this.queue.push(function () {
	        self.observer.onNext(value);
	      });
	    };

	    ScheduledObserver.prototype.error = function (err) {
	      var self = this;
	      this.queue.push(function () {
	        self.observer.onError(err);
	      });
	    };

	    ScheduledObserver.prototype.completed = function () {
	      var self = this;
	      this.queue.push(function () {
	        self.observer.onCompleted();
	      });
	    };

	    ScheduledObserver.prototype.ensureActive = function () {
	      var isOwner = false, parent = this;
	      if (!this.hasFaulted && this.queue.length > 0) {
	        isOwner = !this.isAcquired;
	        this.isAcquired = true;
	      }
	      if (isOwner) {
	        this.disposable.setDisposable(this.scheduler.scheduleRecursive(function (self) {
	          var work;
	          if (parent.queue.length > 0) {
	            work = parent.queue.shift();
	          } else {
	            parent.isAcquired = false;
	            return;
	          }
	          try {
	            work();
	          } catch (ex) {
	            parent.queue = [];
	            parent.hasFaulted = true;
	            throw ex;
	          }
	          self();
	        }));
	      }
	    };

	    ScheduledObserver.prototype.dispose = function () {
	      __super__.prototype.dispose.call(this);
	      this.disposable.dispose();
	    };

	    return ScheduledObserver;
	  }(AbstractObserver));

	  var ObserveOnObserver = (function (__super__) {
	    inherits(ObserveOnObserver, __super__);

	    function ObserveOnObserver() {
	      __super__.apply(this, arguments);
	    }

	    ObserveOnObserver.prototype.next = function (value) {
	      __super__.prototype.next.call(this, value);
	      this.ensureActive();
	    };

	    ObserveOnObserver.prototype.error = function (e) {
	      __super__.prototype.error.call(this, e);
	      this.ensureActive();
	    };

	    ObserveOnObserver.prototype.completed = function () {
	      __super__.prototype.completed.call(this);
	      this.ensureActive();
	    };

	    return ObserveOnObserver;
	  })(ScheduledObserver);

	  var observableProto;

	  /**
	   * Represents a push-style collection.
	   */
	  var Observable = Rx.Observable = (function () {

	    function Observable(subscribe) {
	      this._subscribe = subscribe;
	    }

	    observableProto = Observable.prototype;

	    /**
	     *  Subscribes an observer to the observable sequence.
	     *  @param {Mixed} [observerOrOnNext] The object that is to receive notifications or an action to invoke for each element in the observable sequence.
	     *  @param {Function} [onError] Action to invoke upon exceptional termination of the observable sequence.
	     *  @param {Function} [onCompleted] Action to invoke upon graceful termination of the observable sequence.
	     *  @returns {Diposable} A disposable handling the subscriptions and unsubscriptions.
	     */
	    observableProto.subscribe = observableProto.forEach = function (observerOrOnNext, onError, onCompleted) {
	      return this._subscribe(typeof observerOrOnNext === 'object' ?
	        observerOrOnNext :
	        observerCreate(observerOrOnNext, onError, onCompleted));
	    };

	    /**
	     * Subscribes to the next value in the sequence with an optional "this" argument.
	     * @param {Function} onNext The function to invoke on each element in the observable sequence.
	     * @param {Any} [thisArg] Object to use as this when executing callback.
	     * @returns {Disposable} A disposable handling the subscriptions and unsubscriptions.
	     */
	    observableProto.subscribeOnNext = function (onNext, thisArg) {
	      return this._subscribe(observerCreate(arguments.length === 2 ? function(x) { onNext.call(thisArg, x); } : onNext));
	    };

	    /**
	     * Subscribes to an exceptional condition in the sequence with an optional "this" argument.
	     * @param {Function} onError The function to invoke upon exceptional termination of the observable sequence.
	     * @param {Any} [thisArg] Object to use as this when executing callback.
	     * @returns {Disposable} A disposable handling the subscriptions and unsubscriptions.
	     */
	    observableProto.subscribeOnError = function (onError, thisArg) {
	      return this._subscribe(observerCreate(null, arguments.length === 2 ? function(e) { onError.call(thisArg, e); } : onError));
	    };

	    /**
	     * Subscribes to the next value in the sequence with an optional "this" argument.
	     * @param {Function} onCompleted The function to invoke upon graceful termination of the observable sequence.
	     * @param {Any} [thisArg] Object to use as this when executing callback.
	     * @returns {Disposable} A disposable handling the subscriptions and unsubscriptions.
	     */
	    observableProto.subscribeOnCompleted = function (onCompleted, thisArg) {
	      return this._subscribe(observerCreate(null, null, arguments.length === 2 ? function() { onCompleted.call(thisArg); } : onCompleted));
	    };

	    return Observable;
	  })();

	   /**
	   *  Wraps the source sequence in order to run its observer callbacks on the specified scheduler.
	   *
	   *  This only invokes observer callbacks on a scheduler. In case the subscription and/or unsubscription actions have side-effects
	   *  that require to be run on a scheduler, use subscribeOn.
	   *
	   *  @param {Scheduler} scheduler Scheduler to notify observers on.
	   *  @returns {Observable} The source sequence whose observations happen on the specified scheduler.
	   */
	  observableProto.observeOn = function (scheduler) {
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      return source.subscribe(new ObserveOnObserver(scheduler, observer));
	    });
	  };

	   /**
	   *  Wraps the source sequence in order to run its subscription and unsubscription logic on the specified scheduler. This operation is not commonly used;
	   *  see the remarks section for more information on the distinction between subscribeOn and observeOn.

	   *  This only performs the side-effects of subscription and unsubscription on the specified scheduler. In order to invoke observer
	   *  callbacks on a scheduler, use observeOn.

	   *  @param {Scheduler} scheduler Scheduler to perform subscription and unsubscription actions on.
	   *  @returns {Observable} The source sequence whose subscriptions and unsubscriptions happen on the specified scheduler.
	   */
	  observableProto.subscribeOn = function (scheduler) {
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      var m = new SingleAssignmentDisposable(), d = new SerialDisposable();
	      d.setDisposable(m);
	      m.setDisposable(scheduler.schedule(function () {
	        d.setDisposable(new ScheduledDisposable(scheduler, source.subscribe(observer)));
	      }));
	      return d;
	    });
	  };

	  /**
	   * Converts a Promise to an Observable sequence
	   * @param {Promise} An ES6 Compliant promise.
	   * @returns {Observable} An Observable sequence which wraps the existing promise success and failure.
	   */
	  var observableFromPromise = Observable.fromPromise = function (promise) {
	    return observableDefer(function () {
	      var subject = new Rx.AsyncSubject();

	      promise.then(
	        function (value) {
	          if (!subject.isDisposed) {
	            subject.onNext(value);
	            subject.onCompleted();
	          }
	        },
	        subject.onError.bind(subject));

	      return subject;
	    });
	  };

	  /*
	   * Converts an existing observable sequence to an ES6 Compatible Promise
	   * @example
	   * var promise = Rx.Observable.return(42).toPromise(RSVP.Promise);
	   *
	   * // With config
	   * Rx.config.Promise = RSVP.Promise;
	   * var promise = Rx.Observable.return(42).toPromise();
	   * @param {Function} [promiseCtor] The constructor of the promise. If not provided, it looks for it in Rx.config.Promise.
	   * @returns {Promise} An ES6 compatible promise with the last value from the observable sequence.
	   */
	  observableProto.toPromise = function (promiseCtor) {
	    promiseCtor || (promiseCtor = Rx.config.Promise);
	    if (!promiseCtor) { throw new TypeError('Promise type not provided nor in Rx.config.Promise'); }
	    var source = this;
	    return new promiseCtor(function (resolve, reject) {
	      // No cancellation can be done
	      var value, hasValue = false;
	      source.subscribe(function (v) {
	        value = v;
	        hasValue = true;
	      }, reject, function () {
	        hasValue && resolve(value);
	      });
	    });
	  };

	  /**
	   * Creates a list from an observable sequence.
	   * @returns An observable sequence containing a single element with a list containing all the elements of the source sequence.
	   */
	  observableProto.toArray = function () {
	    var self = this;
	    return new AnonymousObservable(function(observer) {
	      var arr = [];
	      return self.subscribe(
	        arr.push.bind(arr),
	        observer.onError.bind(observer),
	        function () {
	          observer.onNext(arr);
	          observer.onCompleted();
	        });
	    });
	  };

	  /**
	   *  Creates an observable sequence from a specified subscribe method implementation.
	   *
	   * @example
	   *  var res = Rx.Observable.create(function (observer) { return function () { } );
	   *  var res = Rx.Observable.create(function (observer) { return Rx.Disposable.empty; } );
	   *  var res = Rx.Observable.create(function (observer) { } );
	   *
	   * @param {Function} subscribe Implementation of the resulting observable sequence's subscribe method, returning a function that will be wrapped in a Disposable.
	   * @returns {Observable} The observable sequence with the specified implementation for the Subscribe method.
	   */
	  Observable.create = Observable.createWithDisposable = function (subscribe) {
	    return new AnonymousObservable(subscribe);
	  };

	  /**
	   *  Returns an observable sequence that invokes the specified factory function whenever a new observer subscribes.
	   *
	   * @example
	   *  var res = Rx.Observable.defer(function () { return Rx.Observable.fromArray([1,2,3]); });
	   * @param {Function} observableFactory Observable factory function to invoke for each observer that subscribes to the resulting sequence or Promise.
	   * @returns {Observable} An observable sequence whose observers trigger an invocation of the given observable factory function.
	   */
	  var observableDefer = Observable.defer = function (observableFactory) {
	    return new AnonymousObservable(function (observer) {
	      var result;
	      try {
	        result = observableFactory();
	      } catch (e) {
	        return observableThrow(e).subscribe(observer);
	      }
	      isPromise(result) && (result = observableFromPromise(result));
	      return result.subscribe(observer);
	    });
	  };

	  /**
	   *  Returns an empty observable sequence, using the specified scheduler to send out the single OnCompleted message.
	   *
	   * @example
	   *  var res = Rx.Observable.empty();
	   *  var res = Rx.Observable.empty(Rx.Scheduler.timeout);
	   * @param {Scheduler} [scheduler] Scheduler to send the termination call on.
	   * @returns {Observable} An observable sequence with no elements.
	   */
	  var observableEmpty = Observable.empty = function (scheduler) {
	    isScheduler(scheduler) || (scheduler = immediateScheduler);
	    return new AnonymousObservable(function (observer) {
	      return scheduler.schedule(function () {
	        observer.onCompleted();
	      });
	    });
	  };

	  var maxSafeInteger = Math.pow(2, 53) - 1;

	  function numberIsFinite(value) {
	    return typeof value === 'number' && root.isFinite(value);
	  }

	  function isNan(n) {
	    return n !== n;
	  }

	  function isIterable(o) {
	    return o[$iterator$] !== undefined;
	  }

	  function sign(value) {
	    var number = +value;
	    if (number === 0) { return number; }
	    if (isNaN(number)) { return number; }
	    return number < 0 ? -1 : 1;
	  }

	  function toLength(o) {
	    var len = +o.length;
	    if (isNaN(len)) { return 0; }
	    if (len === 0 || !numberIsFinite(len)) { return len; }
	    len = sign(len) * Math.floor(Math.abs(len));
	    if (len <= 0) { return 0; }
	    if (len > maxSafeInteger) { return maxSafeInteger; }
	    return len;
	  }

	  function isCallable(f) {
	    return Object.prototype.toString.call(f) === '[object Function]' && typeof f === 'function';
	  }

	  /**
	   * This method creates a new Observable sequence from an array-like or iterable object.
	   * @param {Any} arrayLike An array-like or iterable object to convert to an Observable sequence.
	   * @param {Function} [mapFn] Map function to call on every element of the array.
	   * @param {Any} [thisArg] The context to use calling the mapFn if provided.
	   * @param {Scheduler} [scheduler] Optional scheduler to use for scheduling.  If not provided, defaults to Scheduler.currentThread.
	   */
	  var observableFrom = Observable.from = function (iterable, mapFn, thisArg, scheduler) {
	    if (iterable == null) {
	      throw new Error('iterable cannot be null.')
	    }
	    if (mapFn && !isCallable(mapFn)) {
	      throw new Error('mapFn when provided must be a function');
	    }
	    isScheduler(scheduler) || (scheduler = currentThreadScheduler);
	    return new AnonymousObservable(function (observer) {
	      var list = Object(iterable),
	        objIsIterable = isIterable(list),
	        len = objIsIterable ? 0 : toLength(list),
	        it = objIsIterable ? list[$iterator$]() : null,
	        i = 0;
	      return scheduler.scheduleRecursive(function (self) {
	        if (i < len || objIsIterable) {
	          var result;
	          if (objIsIterable) {
	            var next;
	            try {
	              next = it.next();
	            } catch (e) {
	              observer.onError(e);
	              return;
	            }
	            if (next.done) {
	              observer.onCompleted();
	              return;
	            }

	            result = next.value;
	          } else {
	            result = !!list.charAt ? list.charAt(i) : list[i];
	          }

	          if (mapFn && isCallable(mapFn)) {
	            try {
	              result = thisArg ? mapFn.call(thisArg, result, i) : mapFn(result, i);
	            } catch (e) {
	              observer.onError(e);
	              return;
	            }
	          }

	          observer.onNext(result);
	          i++;
	          self();
	        } else {
	          observer.onCompleted();
	        }
	      });
	    });
	  };

	  /**
	   *  Converts an array to an observable sequence, using an optional scheduler to enumerate the array.
	   *
	   * @example
	   *  var res = Rx.Observable.fromArray([1,2,3]);
	   *  var res = Rx.Observable.fromArray([1,2,3], Rx.Scheduler.timeout);
	   * @param {Scheduler} [scheduler] Scheduler to run the enumeration of the input sequence on.
	   * @returns {Observable} The observable sequence whose elements are pulled from the given enumerable sequence.
	   */
	  var observableFromArray = Observable.fromArray = function (array, scheduler) {
	    isScheduler(scheduler) || (scheduler = currentThreadScheduler);
	    return new AnonymousObservable(function (observer) {
	      var count = 0, len = array.length;
	      return scheduler.scheduleRecursive(function (self) {
	        if (count < len) {
	          observer.onNext(array[count++]);
	          self();
	        } else {
	          observer.onCompleted();
	        }
	      });
	    });
	  };

	  /**
	   *  Generates an observable sequence by running a state-driven loop producing the sequence's elements, using the specified scheduler to send out observer messages.
	   *
	   * @example
	   *  var res = Rx.Observable.generate(0, function (x) { return x < 10; }, function (x) { return x + 1; }, function (x) { return x; });
	   *  var res = Rx.Observable.generate(0, function (x) { return x < 10; }, function (x) { return x + 1; }, function (x) { return x; }, Rx.Scheduler.timeout);
	   * @param {Mixed} initialState Initial state.
	   * @param {Function} condition Condition to terminate generation (upon returning false).
	   * @param {Function} iterate Iteration step function.
	   * @param {Function} resultSelector Selector function for results produced in the sequence.
	   * @param {Scheduler} [scheduler] Scheduler on which to run the generator loop. If not provided, defaults to Scheduler.currentThread.
	   * @returns {Observable} The generated sequence.
	   */
	  Observable.generate = function (initialState, condition, iterate, resultSelector, scheduler) {
	    isScheduler(scheduler) || (scheduler = currentThreadScheduler);
	    return new AnonymousObservable(function (observer) {
	      var first = true, state = initialState;
	      return scheduler.scheduleRecursive(function (self) {
	        var hasResult, result;
	        try {
	          if (first) {
	            first = false;
	          } else {
	            state = iterate(state);
	          }
	          hasResult = condition(state);
	          if (hasResult) {
	            result = resultSelector(state);
	          }
	        } catch (exception) {
	          observer.onError(exception);
	          return;
	        }
	        if (hasResult) {
	          observer.onNext(result);
	          self();
	        } else {
	          observer.onCompleted();
	        }
	      });
	    });
	  };

	  /**
	   *  This method creates a new Observable instance with a variable number of arguments, regardless of number or type of the arguments.
	   * @example
	   *  var res = Rx.Observable.of(1,2,3);
	   * @returns {Observable} The observable sequence whose elements are pulled from the given arguments.
	   */
	  Observable.of = function () {
	    var len = arguments.length, args = new Array(len);
	    for(var i = 0; i < len; i++) { args[i] = arguments[i]; }
	    return observableFromArray(args);
	  };

	  /**
	   *  This method creates a new Observable instance with a variable number of arguments, regardless of number or type of the arguments.
	   * @example
	   *  var res = Rx.Observable.of(1,2,3);
	   * @param {Scheduler} scheduler A scheduler to use for scheduling the arguments.
	   * @returns {Observable} The observable sequence whose elements are pulled from the given arguments.
	   */
	  var observableOf = Observable.ofWithScheduler = function (scheduler) {
	    var len = arguments.length - 1, args = new Array(len);
	    for(var i = 0; i < len; i++) { args[i] = arguments[i + 1]; }
	    return observableFromArray(args, scheduler);
	  };

	  /**
	   *  Returns a non-terminating observable sequence, which can be used to denote an infinite duration (e.g. when using reactive joins).
	   * @returns {Observable} An observable sequence whose observers will never get called.
	   */
	  var observableNever = Observable.never = function () {
	    return new AnonymousObservable(function () {
	      return disposableEmpty;
	    });
	  };

	  /**
	   *  Generates an observable sequence of integral numbers within a specified range, using the specified scheduler to send out observer messages.
	   *
	   * @example
	   *  var res = Rx.Observable.range(0, 10);
	   *  var res = Rx.Observable.range(0, 10, Rx.Scheduler.timeout);
	   * @param {Number} start The value of the first integer in the sequence.
	   * @param {Number} count The number of sequential integers to generate.
	   * @param {Scheduler} [scheduler] Scheduler to run the generator loop on. If not specified, defaults to Scheduler.currentThread.
	   * @returns {Observable} An observable sequence that contains a range of sequential integral numbers.
	   */
	  Observable.range = function (start, count, scheduler) {
	    isScheduler(scheduler) || (scheduler = currentThreadScheduler);
	    return new AnonymousObservable(function (observer) {
	      return scheduler.scheduleRecursiveWithState(0, function (i, self) {
	        if (i < count) {
	          observer.onNext(start + i);
	          self(i + 1);
	        } else {
	          observer.onCompleted();
	        }
	      });
	    });
	  };

	  /**
	   *  Generates an observable sequence that repeats the given element the specified number of times, using the specified scheduler to send out observer messages.
	   *
	   * @example
	   *  var res = Rx.Observable.repeat(42);
	   *  var res = Rx.Observable.repeat(42, 4);
	   *  3 - res = Rx.Observable.repeat(42, 4, Rx.Scheduler.timeout);
	   *  4 - res = Rx.Observable.repeat(42, null, Rx.Scheduler.timeout);
	   * @param {Mixed} value Element to repeat.
	   * @param {Number} repeatCount [Optiona] Number of times to repeat the element. If not specified, repeats indefinitely.
	   * @param {Scheduler} scheduler Scheduler to run the producer loop on. If not specified, defaults to Scheduler.immediate.
	   * @returns {Observable} An observable sequence that repeats the given element the specified number of times.
	   */
	  Observable.repeat = function (value, repeatCount, scheduler) {
	    isScheduler(scheduler) || (scheduler = currentThreadScheduler);
	    return observableReturn(value, scheduler).repeat(repeatCount == null ? -1 : repeatCount);
	  };

	  /**
	   *  Returns an observable sequence that contains a single element, using the specified scheduler to send out observer messages.
	   *  There is an alias called 'just', and 'returnValue' for browsers <IE9.
	   *
	   * @example
	   *  var res = Rx.Observable.return(42);
	   *  var res = Rx.Observable.return(42, Rx.Scheduler.timeout);
	   * @param {Mixed} value Single element in the resulting observable sequence.
	   * @param {Scheduler} scheduler Scheduler to send the single element on. If not specified, defaults to Scheduler.immediate.
	   * @returns {Observable} An observable sequence containing the single specified element.
	   */
	  var observableReturn = Observable['return'] = Observable.returnValue = Observable.just = function (value, scheduler) {
	    isScheduler(scheduler) || (scheduler = immediateScheduler);
	    return new AnonymousObservable(function (observer) {
	      return scheduler.schedule(function () {
	        observer.onNext(value);
	        observer.onCompleted();
	      });
	    });
	  };

	  /**
	   *  Returns an observable sequence that terminates with an exception, using the specified scheduler to send out the single onError message.
	   *  There is an alias to this method called 'throwError' for browsers <IE9.
	   * @param {Mixed} exception An object used for the sequence's termination.
	   * @param {Scheduler} scheduler Scheduler to send the exceptional termination call on. If not specified, defaults to Scheduler.immediate.
	   * @returns {Observable} The observable sequence that terminates exceptionally with the specified exception object.
	   */
	  var observableThrow = Observable['throw'] = Observable.throwException = Observable.throwError = function (exception, scheduler) {
	    isScheduler(scheduler) || (scheduler = immediateScheduler);
	    return new AnonymousObservable(function (observer) {
	      return scheduler.schedule(function () {
	        observer.onError(exception);
	      });
	    });
	  };

	  /**
	   * Constructs an observable sequence that depends on a resource object, whose lifetime is tied to the resulting observable sequence's lifetime.
	   * @param {Function} resourceFactory Factory function to obtain a resource object.
	   * @param {Function} observableFactory Factory function to obtain an observable sequence that depends on the obtained resource.
	   * @returns {Observable} An observable sequence whose lifetime controls the lifetime of the dependent resource object.
	   */
	  Observable.using = function (resourceFactory, observableFactory) {
	    return new AnonymousObservable(function (observer) {
	      var disposable = disposableEmpty, resource, source;
	      try {
	        resource = resourceFactory();
	        resource && (disposable = resource);
	        source = observableFactory(resource);
	      } catch (exception) {
	        return new CompositeDisposable(observableThrow(exception).subscribe(observer), disposable);
	      }
	      return new CompositeDisposable(source.subscribe(observer), disposable);
	    });
	  };

	  /**
	   * Propagates the observable sequence or Promise that reacts first.
	   * @param {Observable} rightSource Second observable sequence or Promise.
	   * @returns {Observable} {Observable} An observable sequence that surfaces either of the given sequences, whichever reacted first.
	   */
	  observableProto.amb = function (rightSource) {
	    var leftSource = this;
	    return new AnonymousObservable(function (observer) {
	      var choice,
	        leftChoice = 'L', rightChoice = 'R',
	        leftSubscription = new SingleAssignmentDisposable(),
	        rightSubscription = new SingleAssignmentDisposable();

	      isPromise(rightSource) && (rightSource = observableFromPromise(rightSource));

	      function choiceL() {
	        if (!choice) {
	          choice = leftChoice;
	          rightSubscription.dispose();
	        }
	      }

	      function choiceR() {
	        if (!choice) {
	          choice = rightChoice;
	          leftSubscription.dispose();
	        }
	      }

	      leftSubscription.setDisposable(leftSource.subscribe(function (left) {
	        choiceL();
	        if (choice === leftChoice) {
	          observer.onNext(left);
	        }
	      }, function (err) {
	        choiceL();
	        if (choice === leftChoice) {
	          observer.onError(err);
	        }
	      }, function () {
	        choiceL();
	        if (choice === leftChoice) {
	          observer.onCompleted();
	        }
	      }));

	      rightSubscription.setDisposable(rightSource.subscribe(function (right) {
	        choiceR();
	        if (choice === rightChoice) {
	          observer.onNext(right);
	        }
	      }, function (err) {
	        choiceR();
	        if (choice === rightChoice) {
	          observer.onError(err);
	        }
	      }, function () {
	        choiceR();
	        if (choice === rightChoice) {
	          observer.onCompleted();
	        }
	      }));

	      return new CompositeDisposable(leftSubscription, rightSubscription);
	    });
	  };

	  /**
	   * Propagates the observable sequence or Promise that reacts first.
	   *
	   * @example
	   * var = Rx.Observable.amb(xs, ys, zs);
	   * @returns {Observable} An observable sequence that surfaces any of the given sequences, whichever reacted first.
	   */
	  Observable.amb = function () {
	    var acc = observableNever(),
	      items = argsOrArray(arguments, 0);
	    function func(previous, current) {
	      return previous.amb(current);
	    }
	    for (var i = 0, len = items.length; i < len; i++) {
	      acc = func(acc, items[i]);
	    }
	    return acc;
	  };

	  function observableCatchHandler(source, handler) {
	    return new AnonymousObservable(function (observer) {
	      var d1 = new SingleAssignmentDisposable(), subscription = new SerialDisposable();
	      subscription.setDisposable(d1);
	      d1.setDisposable(source.subscribe(observer.onNext.bind(observer), function (exception) {
	        var d, result;
	        try {
	          result = handler(exception);
	        } catch (ex) {
	          observer.onError(ex);
	          return;
	        }
	        isPromise(result) && (result = observableFromPromise(result));

	        d = new SingleAssignmentDisposable();
	        subscription.setDisposable(d);
	        d.setDisposable(result.subscribe(observer));
	      }, observer.onCompleted.bind(observer)));

	      return subscription;
	    });
	  }

	  /**
	   * Continues an observable sequence that is terminated by an exception with the next observable sequence.
	   * @example
	   * 1 - xs.catchException(ys)
	   * 2 - xs.catchException(function (ex) { return ys(ex); })
	   * @param {Mixed} handlerOrSecond Exception handler function that returns an observable sequence given the error that occurred in the first sequence, or a second observable sequence used to produce results when an error occurred in the first sequence.
	   * @returns {Observable} An observable sequence containing the first sequence's elements, followed by the elements of the handler sequence in case an exception occurred.
	   */
	  observableProto['catch'] = observableProto.catchError = observableProto.catchException = function (handlerOrSecond) {
	    return typeof handlerOrSecond === 'function' ?
	      observableCatchHandler(this, handlerOrSecond) :
	      observableCatch([this, handlerOrSecond]);
	  };

	  /**
	   * Continues an observable sequence that is terminated by an exception with the next observable sequence.
	   * @param {Array | Arguments} args Arguments or an array to use as the next sequence if an error occurs.
	   * @returns {Observable} An observable sequence containing elements from consecutive source sequences until a source sequence terminates successfully.
	   */
	  var observableCatch = Observable.catchException = Observable.catchError = Observable['catch'] = function () {
	    return enumerableOf(argsOrArray(arguments, 0)).catchException();
	  };

	  /**
	   * Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences or Promises produces an element.
	   * This can be in the form of an argument list of observables or an array.
	   *
	   * @example
	   * 1 - obs = observable.combineLatest(obs1, obs2, obs3, function (o1, o2, o3) { return o1 + o2 + o3; });
	   * 2 - obs = observable.combineLatest([obs1, obs2, obs3], function (o1, o2, o3) { return o1 + o2 + o3; });
	   * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result selector function.
	   */
	  observableProto.combineLatest = function () {
	    var args = slice.call(arguments);
	    if (Array.isArray(args[0])) {
	      args[0].unshift(this);
	    } else {
	      args.unshift(this);
	    }
	    return combineLatest.apply(this, args);
	  };

	  /**
	   * Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences or Promises produces an element.
	   *
	   * @example
	   * 1 - obs = Rx.Observable.combineLatest(obs1, obs2, obs3, function (o1, o2, o3) { return o1 + o2 + o3; });
	   * 2 - obs = Rx.Observable.combineLatest([obs1, obs2, obs3], function (o1, o2, o3) { return o1 + o2 + o3; });
	   * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result selector function.
	   */
	  var combineLatest = Observable.combineLatest = function () {
	    var args = slice.call(arguments), resultSelector = args.pop();

	    if (Array.isArray(args[0])) {
	      args = args[0];
	    }

	    return new AnonymousObservable(function (observer) {
	      var falseFactory = function () { return false; },
	        n = args.length,
	        hasValue = arrayInitialize(n, falseFactory),
	        hasValueAll = false,
	        isDone = arrayInitialize(n, falseFactory),
	        values = new Array(n);

	      function next(i) {
	        var res;
	        hasValue[i] = true;
	        if (hasValueAll || (hasValueAll = hasValue.every(identity))) {
	          try {
	            res = resultSelector.apply(null, values);
	          } catch (ex) {
	            observer.onError(ex);
	            return;
	          }
	          observer.onNext(res);
	        } else if (isDone.filter(function (x, j) { return j !== i; }).every(identity)) {
	          observer.onCompleted();
	        }
	      }

	      function done (i) {
	        isDone[i] = true;
	        if (isDone.every(identity)) {
	          observer.onCompleted();
	        }
	      }

	      var subscriptions = new Array(n);
	      for (var idx = 0; idx < n; idx++) {
	        (function (i) {
	          var source = args[i], sad = new SingleAssignmentDisposable();
	          isPromise(source) && (source = observableFromPromise(source));
	          sad.setDisposable(source.subscribe(function (x) {
	            values[i] = x;
	            next(i);
	          }, observer.onError.bind(observer), function () {
	            done(i);
	          }));
	          subscriptions[i] = sad;
	        }(idx));
	      }

	      return new CompositeDisposable(subscriptions);
	    });
	  };

	    /**
	     * Concatenates all the observable sequences.  This takes in either an array or variable arguments to concatenate.
	     *
	     * @example
	     * 1 - concatenated = xs.concat(ys, zs);
	     * 2 - concatenated = xs.concat([ys, zs]);
	     * @returns {Observable} An observable sequence that contains the elements of each given sequence, in sequential order.
	     */
	    observableProto.concat = function () {
	        var items = slice.call(arguments, 0);
	        items.unshift(this);
	        return observableConcat.apply(this, items);
	    };

	  /**
	   * Concatenates all the observable sequences.
	   * @param {Array | Arguments} args Arguments or an array to concat to the observable sequence.
	   * @returns {Observable} An observable sequence that contains the elements of each given sequence, in sequential order.
	   */
	  var observableConcat = Observable.concat = function () {
	    return enumerableOf(argsOrArray(arguments, 0)).concat();
	  };

	    /**
	     * Concatenates an observable sequence of observable sequences.
	     * @returns {Observable} An observable sequence that contains the elements of each observed inner sequence, in sequential order.
	     */
	    observableProto.concatObservable = observableProto.concatAll =function () {
	        return this.merge(1);
	    };

	  /**
	   * Merges an observable sequence of observable sequences into an observable sequence, limiting the number of concurrent subscriptions to inner sequences.
	   * Or merges two observable sequences into a single observable sequence.
	   *
	   * @example
	   * 1 - merged = sources.merge(1);
	   * 2 - merged = source.merge(otherSource);
	   * @param {Mixed} [maxConcurrentOrOther] Maximum number of inner observable sequences being subscribed to concurrently or the second observable sequence.
	   * @returns {Observable} The observable sequence that merges the elements of the inner sequences.
	   */
	  observableProto.merge = function (maxConcurrentOrOther) {
	    if (typeof maxConcurrentOrOther !== 'number') { return observableMerge(this, maxConcurrentOrOther); }
	    var sources = this;
	    return new AnonymousObservable(function (observer) {
	      var activeCount = 0, group = new CompositeDisposable(), isStopped = false, q = [];

	      function subscribe(xs) {
	        var subscription = new SingleAssignmentDisposable();
	        group.add(subscription);

	        // Check for promises support
	        isPromise(xs) && (xs = observableFromPromise(xs));

	        subscription.setDisposable(xs.subscribe(observer.onNext.bind(observer), observer.onError.bind(observer), function () {
	          group.remove(subscription);
	          if (q.length > 0) {
	            subscribe(q.shift());
	          } else {
	            activeCount--;
	            isStopped && activeCount === 0 && observer.onCompleted();
	          }
	        }));
	      }
	      group.add(sources.subscribe(function (innerSource) {
	        if (activeCount < maxConcurrentOrOther) {
	          activeCount++;
	          subscribe(innerSource);
	        } else {
	          q.push(innerSource);
	        }
	      }, observer.onError.bind(observer), function () {
	        isStopped = true;
	        activeCount === 0 && observer.onCompleted();
	      }));
	      return group;
	    });
	  };

	    /**
	     * Merges all the observable sequences into a single observable sequence.
	     * The scheduler is optional and if not specified, the immediate scheduler is used.
	     *
	     * @example
	     * 1 - merged = Rx.Observable.merge(xs, ys, zs);
	     * 2 - merged = Rx.Observable.merge([xs, ys, zs]);
	     * 3 - merged = Rx.Observable.merge(scheduler, xs, ys, zs);
	     * 4 - merged = Rx.Observable.merge(scheduler, [xs, ys, zs]);
	     * @returns {Observable} The observable sequence that merges the elements of the observable sequences.
	     */
	    var observableMerge = Observable.merge = function () {
	        var scheduler, sources;
	        if (!arguments[0]) {
	            scheduler = immediateScheduler;
	            sources = slice.call(arguments, 1);
	        } else if (arguments[0].now) {
	            scheduler = arguments[0];
	            sources = slice.call(arguments, 1);
	        } else {
	            scheduler = immediateScheduler;
	            sources = slice.call(arguments, 0);
	        }
	        if (Array.isArray(sources[0])) {
	            sources = sources[0];
	        }
	        return observableFromArray(sources, scheduler).mergeObservable();
	    };

	  /**
	   * Merges an observable sequence of observable sequences into an observable sequence.
	   * @returns {Observable} The observable sequence that merges the elements of the inner sequences.
	   */
	  observableProto.mergeObservable = observableProto.mergeAll = function () {
	    var sources = this;
	    return new AnonymousObservable(function (observer) {
	      var group = new CompositeDisposable(),
	        isStopped = false,
	        m = new SingleAssignmentDisposable();

	      group.add(m);
	      m.setDisposable(sources.subscribe(function (innerSource) {
	        var innerSubscription = new SingleAssignmentDisposable();
	        group.add(innerSubscription);

	        // Check for promises support
	        isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));

	        innerSubscription.setDisposable(innerSource.subscribe(observer.onNext.bind(observer), observer.onError.bind(observer), function () {
	          group.remove(innerSubscription);
	          isStopped && group.length === 1 && observer.onCompleted();
	        }));
	      }, observer.onError.bind(observer), function () {
	        isStopped = true;
	        group.length === 1 && observer.onCompleted();
	      }));
	      return group;
	    });
	  };

	  /**
	   * Continues an observable sequence that is terminated normally or by an exception with the next observable sequence.
	   * @param {Observable} second Second observable sequence used to produce results after the first sequence terminates.
	   * @returns {Observable} An observable sequence that concatenates the first and second sequence, even if the first sequence terminates exceptionally.
	   */
	  observableProto.onErrorResumeNext = function (second) {
	    if (!second) { throw new Error('Second observable is required'); }
	    return onErrorResumeNext([this, second]);
	  };

	  /**
	   * Continues an observable sequence that is terminated normally or by an exception with the next observable sequence.
	   *
	   * @example
	   * 1 - res = Rx.Observable.onErrorResumeNext(xs, ys, zs);
	   * 1 - res = Rx.Observable.onErrorResumeNext([xs, ys, zs]);
	   * @returns {Observable} An observable sequence that concatenates the source sequences, even if a sequence terminates exceptionally.
	   */
	  var onErrorResumeNext = Observable.onErrorResumeNext = function () {
	    var sources = argsOrArray(arguments, 0);
	    return new AnonymousObservable(function (observer) {
	      var pos = 0, subscription = new SerialDisposable(),
	      cancelable = immediateScheduler.scheduleRecursive(function (self) {
	        var current, d;
	        if (pos < sources.length) {
	          current = sources[pos++];
	          isPromise(current) && (current = observableFromPromise(current));
	          d = new SingleAssignmentDisposable();
	          subscription.setDisposable(d);
	          d.setDisposable(current.subscribe(observer.onNext.bind(observer), self, self));
	        } else {
	          observer.onCompleted();
	        }
	      });
	      return new CompositeDisposable(subscription, cancelable);
	    });
	  };

	  /**
	   * Returns the values from the source observable sequence only after the other observable sequence produces a value.
	   * @param {Observable | Promise} other The observable sequence or Promise that triggers propagation of elements of the source sequence.
	   * @returns {Observable} An observable sequence containing the elements of the source sequence starting from the point the other sequence triggered propagation.
	   */
	  observableProto.skipUntil = function (other) {
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      var isOpen = false;
	      var disposables = new CompositeDisposable(source.subscribe(function (left) {
	        isOpen && observer.onNext(left);
	      }, observer.onError.bind(observer), function () {
	        isOpen && observer.onCompleted();
	      }));

	      isPromise(other) && (other = observableFromPromise(other));

	      var rightSubscription = new SingleAssignmentDisposable();
	      disposables.add(rightSubscription);
	      rightSubscription.setDisposable(other.subscribe(function () {
	        isOpen = true;
	        rightSubscription.dispose();
	      }, observer.onError.bind(observer), function () {
	        rightSubscription.dispose();
	      }));

	      return disposables;
	    });
	  };

	  /**
	   * Transforms an observable sequence of observable sequences into an observable sequence producing values only from the most recent observable sequence.
	   * @returns {Observable} The observable sequence that at any point in time produces the elements of the most recent inner observable sequence that has been received.
	   */
	  observableProto['switch'] = observableProto.switchLatest = function () {
	    var sources = this;
	    return new AnonymousObservable(function (observer) {
	      var hasLatest = false,
	        innerSubscription = new SerialDisposable(),
	        isStopped = false,
	        latest = 0,
	        subscription = sources.subscribe(
	          function (innerSource) {
	            var d = new SingleAssignmentDisposable(), id = ++latest;
	            hasLatest = true;
	            innerSubscription.setDisposable(d);

	            // Check if Promise or Observable
	            isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));

	            d.setDisposable(innerSource.subscribe(
	              function (x) { latest === id && observer.onNext(x); },
	              function (e) { latest === id && observer.onError(e); },
	              function () {
	                if (latest === id) {
	                  hasLatest = false;
	                  isStopped && observer.onCompleted();
	                }
	              }));
	          },
	          observer.onError.bind(observer),
	          function () {
	            isStopped = true;
	            !hasLatest && observer.onCompleted();
	          });
	      return new CompositeDisposable(subscription, innerSubscription);
	    });
	  };

	  /**
	   * Returns the values from the source observable sequence until the other observable sequence produces a value.
	   * @param {Observable | Promise} other Observable sequence or Promise that terminates propagation of elements of the source sequence.
	   * @returns {Observable} An observable sequence containing the elements of the source sequence up to the point the other sequence interrupted further propagation.
	   */
	  observableProto.takeUntil = function (other) {
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      isPromise(other) && (other = observableFromPromise(other));
	      return new CompositeDisposable(
	        source.subscribe(observer),
	        other.subscribe(observer.onCompleted.bind(observer), observer.onError.bind(observer), noop)
	      );
	    });
	  };

	  function zipArray(second, resultSelector) {
	    var first = this;
	    return new AnonymousObservable(function (observer) {
	      var index = 0, len = second.length;
	      return first.subscribe(function (left) {
	        if (index < len) {
	          var right = second[index++], result;
	          try {
	            result = resultSelector(left, right);
	          } catch (e) {
	            observer.onError(e);
	            return;
	          }
	          observer.onNext(result);
	        } else {
	          observer.onCompleted();
	        }
	      }, observer.onError.bind(observer), observer.onCompleted.bind(observer));
	    });
	  }

	  /**
	   * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences or an array have produced an element at a corresponding index.
	   * The last element in the arguments must be a function to invoke for each series of elements at corresponding indexes in the sources.
	   *
	   * @example
	   * 1 - res = obs1.zip(obs2, fn);
	   * 1 - res = x1.zip([1,2,3], fn);
	   * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result selector function.
	   */
	  observableProto.zip = function () {
	    if (Array.isArray(arguments[0])) {
	      return zipArray.apply(this, arguments);
	    }
	    var parent = this, sources = slice.call(arguments), resultSelector = sources.pop();
	    sources.unshift(parent);
	    return new AnonymousObservable(function (observer) {
	      var n = sources.length,
	        queues = arrayInitialize(n, function () { return []; }),
	        isDone = arrayInitialize(n, function () { return false; });

	      function next(i) {
	        var res, queuedValues;
	        if (queues.every(function (x) { return x.length > 0; })) {
	          try {
	            queuedValues = queues.map(function (x) { return x.shift(); });
	            res = resultSelector.apply(parent, queuedValues);
	          } catch (ex) {
	            observer.onError(ex);
	            return;
	          }
	          observer.onNext(res);
	        } else if (isDone.filter(function (x, j) { return j !== i; }).every(identity)) {
	          observer.onCompleted();
	        }
	      };

	      function done(i) {
	        isDone[i] = true;
	        if (isDone.every(function (x) { return x; })) {
	          observer.onCompleted();
	        }
	      }

	      var subscriptions = new Array(n);
	      for (var idx = 0; idx < n; idx++) {
	        (function (i) {
	          var source = sources[i], sad = new SingleAssignmentDisposable();
	          isPromise(source) && (source = observableFromPromise(source));
	          sad.setDisposable(source.subscribe(function (x) {
	            queues[i].push(x);
	            next(i);
	          }, observer.onError.bind(observer), function () {
	            done(i);
	          }));
	          subscriptions[i] = sad;
	        })(idx);
	      }

	      return new CompositeDisposable(subscriptions);
	    });
	  };

	  /**
	   * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
	   * @param arguments Observable sources.
	   * @param {Function} resultSelector Function to invoke for each series of elements at corresponding indexes in the sources.
	   * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result selector function.
	   */
	  Observable.zip = function () {
	    var args = slice.call(arguments, 0), first = args.shift();
	    return first.zip.apply(first, args);
	  };

	  /**
	   * Merges the specified observable sequences into one observable sequence by emitting a list with the elements of the observable sequences at corresponding indexes.
	   * @param arguments Observable sources.
	   * @returns {Observable} An observable sequence containing lists of elements at corresponding indexes.
	   */
	  Observable.zipArray = function () {
	    var sources = argsOrArray(arguments, 0);
	    return new AnonymousObservable(function (observer) {
	      var n = sources.length,
	        queues = arrayInitialize(n, function () { return []; }),
	        isDone = arrayInitialize(n, function () { return false; });

	      function next(i) {
	        if (queues.every(function (x) { return x.length > 0; })) {
	          var res = queues.map(function (x) { return x.shift(); });
	          observer.onNext(res);
	        } else if (isDone.filter(function (x, j) { return j !== i; }).every(identity)) {
	          observer.onCompleted();
	          return;
	        }
	      };

	      function done(i) {
	        isDone[i] = true;
	        if (isDone.every(identity)) {
	          observer.onCompleted();
	          return;
	        }
	      }

	      var subscriptions = new Array(n);
	      for (var idx = 0; idx < n; idx++) {
	        (function (i) {
	          subscriptions[i] = new SingleAssignmentDisposable();
	          subscriptions[i].setDisposable(sources[i].subscribe(function (x) {
	            queues[i].push(x);
	            next(i);
	          }, observer.onError.bind(observer), function () {
	            done(i);
	          }));
	        })(idx);
	      }

	      var compositeDisposable = new CompositeDisposable(subscriptions);
	      compositeDisposable.add(disposableCreate(function () {
	        for (var qIdx = 0, qLen = queues.length; qIdx < qLen; qIdx++) { queues[qIdx] = []; }
	      }));
	      return compositeDisposable;
	    });
	  };

	  /**
	   *  Hides the identity of an observable sequence.
	   * @returns {Observable} An observable sequence that hides the identity of the source sequence.
	   */
	  observableProto.asObservable = function () {
	    return new AnonymousObservable(this.subscribe.bind(this));
	  };

	  /**
	   *  Projects each element of an observable sequence into zero or more buffers which are produced based on element count information.
	   *
	   * @example
	   *  var res = xs.bufferWithCount(10);
	   *  var res = xs.bufferWithCount(10, 1);
	   * @param {Number} count Length of each buffer.
	   * @param {Number} [skip] Number of elements to skip between creation of consecutive buffers. If not provided, defaults to the count.
	   * @returns {Observable} An observable sequence of buffers.
	   */
	  observableProto.bufferWithCount = function (count, skip) {
	    if (typeof skip !== 'number') {
	      skip = count;
	    }
	    return this.windowWithCount(count, skip).selectMany(function (x) {
	      return x.toArray();
	    }).where(function (x) {
	      return x.length > 0;
	    });
	  };

	    /**
	     * Dematerializes the explicit notification values of an observable sequence as implicit notifications.
	     * @returns {Observable} An observable sequence exhibiting the behavior corresponding to the source sequence's notification values.
	     */
	    observableProto.dematerialize = function () {
	        var source = this;
	        return new AnonymousObservable(function (observer) {
	            return source.subscribe(function (x) {
	                return x.accept(observer);
	            }, observer.onError.bind(observer), observer.onCompleted.bind(observer));
	        });
	    };

	    /**
	     *  Returns an observable sequence that contains only distinct contiguous elements according to the keySelector and the comparer.
	     *
	     *  var obs = observable.distinctUntilChanged();
	     *  var obs = observable.distinctUntilChanged(function (x) { return x.id; });
	     *  var obs = observable.distinctUntilChanged(function (x) { return x.id; }, function (x, y) { return x === y; });
	     *
	     * @param {Function} [keySelector] A function to compute the comparison key for each element. If not provided, it projects the value.
	     * @param {Function} [comparer] Equality comparer for computed key values. If not provided, defaults to an equality comparer function.
	     * @returns {Observable} An observable sequence only containing the distinct contiguous elements, based on a computed key value, from the source sequence.
	     */
	    observableProto.distinctUntilChanged = function (keySelector, comparer) {
	        var source = this;
	        keySelector || (keySelector = identity);
	        comparer || (comparer = defaultComparer);
	        return new AnonymousObservable(function (observer) {
	            var hasCurrentKey = false, currentKey;
	            return source.subscribe(function (value) {
	                var comparerEquals = false, key;
	                try {
	                    key = keySelector(value);
	                } catch (exception) {
	                    observer.onError(exception);
	                    return;
	                }
	                if (hasCurrentKey) {
	                    try {
	                        comparerEquals = comparer(currentKey, key);
	                    } catch (exception) {
	                        observer.onError(exception);
	                        return;
	                    }
	                }
	                if (!hasCurrentKey || !comparerEquals) {
	                    hasCurrentKey = true;
	                    currentKey = key;
	                    observer.onNext(value);
	                }
	            }, observer.onError.bind(observer), observer.onCompleted.bind(observer));
	        });
	    };

	  /**
	   *  Invokes an action for each element in the observable sequence and invokes an action upon graceful or exceptional termination of the observable sequence.
	   *  This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.
	   * @param {Function | Observer} observerOrOnNext Action to invoke for each element in the observable sequence or an observer.
	   * @param {Function} [onError]  Action to invoke upon exceptional termination of the observable sequence. Used if only the observerOrOnNext parameter is also a function.
	   * @param {Function} [onCompleted]  Action to invoke upon graceful termination of the observable sequence. Used if only the observerOrOnNext parameter is also a function.
	   * @returns {Observable} The source sequence with the side-effecting behavior applied.
	   */
	  observableProto['do'] = observableProto.doAction = observableProto.tap = function (observerOrOnNext, onError, onCompleted) {
	    var source = this, onNextFunc;
	    if (typeof observerOrOnNext === 'function') {
	      onNextFunc = observerOrOnNext;
	    } else {
	      onNextFunc = observerOrOnNext.onNext.bind(observerOrOnNext);
	      onError = observerOrOnNext.onError.bind(observerOrOnNext);
	      onCompleted = observerOrOnNext.onCompleted.bind(observerOrOnNext);
	    }
	    return new AnonymousObservable(function (observer) {
	      return source.subscribe(function (x) {
	        try {
	          onNextFunc(x);
	        } catch (e) {
	          observer.onError(e);
	        }
	        observer.onNext(x);
	      }, function (err) {
	        if (onError) {
	          try {
	            onError(err);
	          } catch (e) {
	            observer.onError(e);
	          }
	        }
	        observer.onError(err);
	      }, function () {
	        if (onCompleted) {
	          try {
	            onCompleted();
	          } catch (e) {
	            observer.onError(e);
	          }
	        }
	        observer.onCompleted();
	      });
	    });
	  };

	  /**
	   *  Invokes an action for each element in the observable sequence.
	   *  This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.
	   * @param {Function} onNext Action to invoke for each element in the observable sequence.
	   * @param {Any} [thisArg] Object to use as this when executing callback.
	   * @returns {Observable} The source sequence with the side-effecting behavior applied.
	   */
	  observableProto.doOnNext = observableProto.tapOnNext = function (onNext, thisArg) {
	    return this.tap(arguments.length === 2 ? function (x) { onNext.call(thisArg, x); } : onNext);
	  };

	  /**
	   *  Invokes an action upon exceptional termination of the observable sequence.
	   *  This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.
	   * @param {Function} onError Action to invoke upon exceptional termination of the observable sequence.
	   * @param {Any} [thisArg] Object to use as this when executing callback.
	   * @returns {Observable} The source sequence with the side-effecting behavior applied.
	   */
	  observableProto.doOnError = observableProto.tapOnError = function (onError, thisArg) {
	    return this.tap(noop, arguments.length === 2 ? function (e) { onError.call(thisArg, e); } : onError);
	  };

	  /**
	   *  Invokes an action upon graceful termination of the observable sequence.
	   *  This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.
	   * @param {Function} onCompleted Action to invoke upon graceful termination of the observable sequence.
	   * @param {Any} [thisArg] Object to use as this when executing callback.
	   * @returns {Observable} The source sequence with the side-effecting behavior applied.
	   */
	  observableProto.doOnCompleted = observableProto.tapOnCompleted = function (onCompleted, thisArg) {
	    return this.tap(noop, null, arguments.length === 2 ? function () { onCompleted.call(thisArg); } : onCompleted);
	  };

	  /**
	   *  Invokes a specified action after the source observable sequence terminates gracefully or exceptionally.
	   *
	   * @example
	   *  var res = observable.finallyAction(function () { console.log('sequence ended'; });
	   * @param {Function} finallyAction Action to invoke after the source observable sequence terminates.
	   * @returns {Observable} Source sequence with the action-invoking termination behavior applied.
	   */
	  observableProto['finally'] = observableProto.finallyAction = function (action) {
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      var subscription;
	      try {
	        subscription = source.subscribe(observer);
	      } catch (e) {
	        action();
	        throw e;
	      }
	      return disposableCreate(function () {
	        try {
	          subscription.dispose();
	        } catch (e) {
	          throw e;
	        } finally {
	          action();
	        }
	      });
	    });
	  };

	  /**
	   *  Ignores all elements in an observable sequence leaving only the termination messages.
	   * @returns {Observable} An empty observable sequence that signals termination, successful or exceptional, of the source sequence.
	   */
	  observableProto.ignoreElements = function () {
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      return source.subscribe(noop, observer.onError.bind(observer), observer.onCompleted.bind(observer));
	    });
	  };

	  /**
	   *  Materializes the implicit notifications of an observable sequence as explicit notification values.
	   * @returns {Observable} An observable sequence containing the materialized notification values from the source sequence.
	   */
	  observableProto.materialize = function () {
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      return source.subscribe(function (value) {
	        observer.onNext(notificationCreateOnNext(value));
	      }, function (e) {
	        observer.onNext(notificationCreateOnError(e));
	        observer.onCompleted();
	      }, function () {
	        observer.onNext(notificationCreateOnCompleted());
	        observer.onCompleted();
	      });
	    });
	  };

	    /**
	     *  Repeats the observable sequence a specified number of times. If the repeat count is not specified, the sequence repeats indefinitely.
	     *
	     * @example
	     *  var res = repeated = source.repeat();
	     *  var res = repeated = source.repeat(42);
	     * @param {Number} [repeatCount]  Number of times to repeat the sequence. If not provided, repeats the sequence indefinitely.
	     * @returns {Observable} The observable sequence producing the elements of the given sequence repeatedly.
	     */
	    observableProto.repeat = function (repeatCount) {
	        return enumerableRepeat(this, repeatCount).concat();
	    };

	  /**
	   *  Repeats the source observable sequence the specified number of times or until it successfully terminates. If the retry count is not specified, it retries indefinitely.
	   *  Note if you encounter an error and want it to retry once, then you must use .retry(2);
	   *
	   * @example
	   *  var res = retried = retry.repeat();
	   *  var res = retried = retry.repeat(2);
	   * @param {Number} [retryCount]  Number of times to retry the sequence. If not provided, retry the sequence indefinitely.
	   * @returns {Observable} An observable sequence producing the elements of the given sequence repeatedly until it terminates successfully.
	   */
	  observableProto.retry = function (retryCount) {
	    return enumerableRepeat(this, retryCount).catchException();
	  };

	  /**
	   *  Applies an accumulator function over an observable sequence and returns each intermediate result. The optional seed value is used as the initial accumulator value.
	   *  For aggregation behavior with no intermediate results, see Observable.aggregate.
	   * @example
	   *  var res = source.scan(function (acc, x) { return acc + x; });
	   *  var res = source.scan(0, function (acc, x) { return acc + x; });
	   * @param {Mixed} [seed] The initial accumulator value.
	   * @param {Function} accumulator An accumulator function to be invoked on each element.
	   * @returns {Observable} An observable sequence containing the accumulated values.
	   */
	  observableProto.scan = function () {
	    var hasSeed = false, seed, accumulator, source = this;
	    if (arguments.length === 2) {
	      hasSeed = true;
	      seed = arguments[0];
	      accumulator = arguments[1];
	    } else {
	      accumulator = arguments[0];
	    }
	    return new AnonymousObservable(function (observer) {
	      var hasAccumulation, accumulation, hasValue;
	      return source.subscribe (
	        function (x) {
	          !hasValue && (hasValue = true);
	          try {
	            if (hasAccumulation) {
	              accumulation = accumulator(accumulation, x);
	            } else {
	              accumulation = hasSeed ? accumulator(seed, x) : x;
	              hasAccumulation = true;
	            }
	          } catch (e) {
	            observer.onError(e);
	            return;
	          }

	          observer.onNext(accumulation);
	        },
	        observer.onError.bind(observer),
	        function () {
	          !hasValue && hasSeed && observer.onNext(seed);
	          observer.onCompleted();
	        }
	      );
	    });
	  };

	  /**
	   *  Bypasses a specified number of elements at the end of an observable sequence.
	   * @description
	   *  This operator accumulates a queue with a length enough to store the first `count` elements. As more elements are
	   *  received, elements are taken from the front of the queue and produced on the result sequence. This causes elements to be delayed.
	   * @param count Number of elements to bypass at the end of the source sequence.
	   * @returns {Observable} An observable sequence containing the source sequence elements except for the bypassed ones at the end.
	   */
	  observableProto.skipLast = function (count) {
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      var q = [];
	      return source.subscribe(function (x) {
	        q.push(x);
	        q.length > count && observer.onNext(q.shift());
	      }, observer.onError.bind(observer), observer.onCompleted.bind(observer));
	    });
	  };

	  /**
	   *  Prepends a sequence of values to an observable sequence with an optional scheduler and an argument list of values to prepend.
	   *  @example
	   *  var res = source.startWith(1, 2, 3);
	   *  var res = source.startWith(Rx.Scheduler.timeout, 1, 2, 3);
	   * @param {Arguments} args The specified values to prepend to the observable sequence
	   * @returns {Observable} The source sequence prepended with the specified values.
	   */
	  observableProto.startWith = function () {
	    var values, scheduler, start = 0;
	    if (!!arguments.length && isScheduler(arguments[0])) {
	      scheduler = arguments[0];
	      start = 1;
	    } else {
	      scheduler = immediateScheduler;
	    }
	    values = slice.call(arguments, start);
	    return enumerableOf([observableFromArray(values, scheduler), this]).concat();
	  };

	  /**
	   *  Returns a specified number of contiguous elements from the end of an observable sequence.
	   * @description
	   *  This operator accumulates a buffer with a length enough to store elements count elements. Upon completion of
	   *  the source sequence, this buffer is drained on the result sequence. This causes the elements to be delayed.
	   * @param {Number} count Number of elements to take from the end of the source sequence.
	   * @returns {Observable} An observable sequence containing the specified number of elements from the end of the source sequence.
	   */
	  observableProto.takeLast = function (count) {
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      var q = [];
	      return source.subscribe(function (x) {
	        q.push(x);
	        q.length > count && q.shift();
	      }, observer.onError.bind(observer), function () {
	        while(q.length > 0) { observer.onNext(q.shift()); }
	        observer.onCompleted();
	      });
	    });
	  };

	  /**
	   *  Returns an array with the specified number of contiguous elements from the end of an observable sequence.
	   *
	   * @description
	   *  This operator accumulates a buffer with a length enough to store count elements. Upon completion of the
	   *  source sequence, this buffer is produced on the result sequence.
	   * @param {Number} count Number of elements to take from the end of the source sequence.
	   * @returns {Observable} An observable sequence containing a single array with the specified number of elements from the end of the source sequence.
	   */
	  observableProto.takeLastBuffer = function (count) {
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      var q = [];
	      return source.subscribe(function (x) {
	        q.push(x);
	        q.length > count && q.shift();
	      }, observer.onError.bind(observer), function () {
	        observer.onNext(q);
	        observer.onCompleted();
	      });
	    });
	  };

	  /**
	   *  Projects each element of an observable sequence into zero or more windows which are produced based on element count information.
	   *
	   *  var res = xs.windowWithCount(10);
	   *  var res = xs.windowWithCount(10, 1);
	   * @param {Number} count Length of each window.
	   * @param {Number} [skip] Number of elements to skip between creation of consecutive windows. If not specified, defaults to the count.
	   * @returns {Observable} An observable sequence of windows.
	   */
	  observableProto.windowWithCount = function (count, skip) {
	    var source = this;
	    +count || (count = 0);
	    Math.abs(count) === Infinity && (count = 0);
	    if (count <= 0) { throw new Error(argumentOutOfRange); }
	    skip == null && (skip = count);
	    +skip || (skip = 0);
	    Math.abs(skip) === Infinity && (skip = 0);

	    if (skip <= 0) { throw new Error(argumentOutOfRange); }
	    return new AnonymousObservable(function (observer) {
	      var m = new SingleAssignmentDisposable(),
	        refCountDisposable = new RefCountDisposable(m),
	        n = 0,
	        q = [];

	      function createWindow () {
	        var s = new Subject();
	        q.push(s);
	        observer.onNext(addRef(s, refCountDisposable));
	      }

	      createWindow();

	      m.setDisposable(source.subscribe(
	        function (x) {
	          for (var i = 0, len = q.length; i < len; i++) { q[i].onNext(x); }
	          var c = n - count + 1;
	          c >=0 && c % skip === 0 && q.shift().onCompleted();
	          ++n % skip === 0 && createWindow();
	        }, 
	        function (e) {
	          while (q.length > 0) { q.shift().onError(e); }
	          observer.onError(e);
	        }, 
	        function () {
	          while (q.length > 0) { q.shift().onCompleted(); }
	          observer.onCompleted();
	        }
	      ));
	      return refCountDisposable;
	    });
	  };

	  function concatMap(source, selector, thisArg) {
	    return source.map(function (x, i) {
	      var result = selector.call(thisArg, x, i, source);
	      isPromise(result) && (result = observableFromPromise(result));
	      (Array.isArray(result) || isIterable(result)) && (result = observableFrom(result));
	      return result;
	    }).concatAll();
	  }

	  /**
	   *  One of the Following:
	   *  Projects each element of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.
	   *
	   * @example
	   *  var res = source.concatMap(function (x) { return Rx.Observable.range(0, x); });
	   *  Or:
	   *  Projects each element of an observable sequence to an observable sequence, invokes the result selector for the source element and each of the corresponding inner sequence's elements, and merges the results into one observable sequence.
	   *
	   *  var res = source.concatMap(function (x) { return Rx.Observable.range(0, x); }, function (x, y) { return x + y; });
	   *  Or:
	   *  Projects each element of the source observable sequence to the other observable sequence and merges the resulting observable sequences into one observable sequence.
	   *
	   *  var res = source.concatMap(Rx.Observable.fromArray([1,2,3]));
	   * @param {Function} selector A transform function to apply to each element or an observable sequence to project each element from the
	   * source sequence onto which could be either an observable or Promise.
	   * @param {Function} [resultSelector]  A transform function to apply to each element of the intermediate sequence.
	   * @returns {Observable} An observable sequence whose elements are the result of invoking the one-to-many transform function collectionSelector on each element of the input sequence and then mapping each of those sequence elements and their corresponding source element to a result element.
	   */
	  observableProto.selectConcat = observableProto.concatMap = function (selector, resultSelector, thisArg) {
	    if (typeof selector === 'function' && typeof resultSelector === 'function') {
	      return this.concatMap(function (x, i) {
	        var selectorResult = selector(x, i);
	        isPromise(selectorResult) && (selectorResult = observableFromPromise(selectorResult));
	        (Array.isArray(selectorResult) || isIterable(selectorResult)) && (selectorResult = observableFrom(selectorResult));

	        return selectorResult.map(function (y, i2) {
	          return resultSelector(x, y, i, i2);
	        });
	      });
	    }
	    return typeof selector === 'function' ?
	      concatMap(this, selector, thisArg) :
	      concatMap(this, function () { return selector; });
	  };

	  /**
	   * Projects each notification of an observable sequence to an observable sequence and concats the resulting observable sequences into one observable sequence.
	   * @param {Function} onNext A transform function to apply to each element; the second parameter of the function represents the index of the source element.
	   * @param {Function} onError A transform function to apply when an error occurs in the source sequence.
	   * @param {Function} onCompleted A transform function to apply when the end of the source sequence is reached.
	   * @param {Any} [thisArg] An optional "this" to use to invoke each transform.
	   * @returns {Observable} An observable sequence whose elements are the result of invoking the one-to-many transform function corresponding to each notification in the input sequence.
	   */
	  observableProto.concatMapObserver = observableProto.selectConcatObserver = function(onNext, onError, onCompleted, thisArg) {
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      var index = 0;

	      return source.subscribe(
	        function (x) {
	          var result;
	          try {
	            result = onNext.call(thisArg, x, index++);
	          } catch (e) {
	            observer.onError(e);
	            return;
	          }
	          isPromise(result) && (result = observableFromPromise(result));
	          observer.onNext(result);
	        },
	        function (err) {
	          var result;
	          try {
	            result = onError.call(thisArg, err);
	          } catch (e) {
	            observer.onError(e);
	            return;
	          }
	          isPromise(result) && (result = observableFromPromise(result));
	          observer.onNext(result);
	          observer.onCompleted();
	        },
	        function () {
	          var result;
	          try {
	            result = onCompleted.call(thisArg);
	          } catch (e) {
	            observer.onError(e);
	            return;
	          }
	          isPromise(result) && (result = observableFromPromise(result));
	          observer.onNext(result);
	          observer.onCompleted();
	        });
	    }).concatAll();
	  };

	    /**
	     *  Returns the elements of the specified sequence or the specified value in a singleton sequence if the sequence is empty.
	     *
	     *  var res = obs = xs.defaultIfEmpty();
	     *  2 - obs = xs.defaultIfEmpty(false);
	     *
	     * @memberOf Observable#
	     * @param defaultValue The value to return if the sequence is empty. If not provided, this defaults to null.
	     * @returns {Observable} An observable sequence that contains the specified default value if the source is empty; otherwise, the elements of the source itself.
	     */
	    observableProto.defaultIfEmpty = function (defaultValue) {
	        var source = this;
	        if (defaultValue === undefined) {
	            defaultValue = null;
	        }
	        return new AnonymousObservable(function (observer) {
	            var found = false;
	            return source.subscribe(function (x) {
	                found = true;
	                observer.onNext(x);
	            }, observer.onError.bind(observer), function () {
	                if (!found) {
	                    observer.onNext(defaultValue);
	                }
	                observer.onCompleted();
	            });
	        });
	    };

	  // Swap out for Array.findIndex
	  function arrayIndexOfComparer(array, item, comparer) {
	    for (var i = 0, len = array.length; i < len; i++) {
	      if (comparer(array[i], item)) { return i; }
	    }
	    return -1;
	  }

	  function HashSet(comparer) {
	    this.comparer = comparer;
	    this.set = [];
	  }
	  HashSet.prototype.push = function(value) {
	    var retValue = arrayIndexOfComparer(this.set, value, this.comparer) === -1;
	    retValue && this.set.push(value);
	    return retValue;
	  };

	  /**
	   *  Returns an observable sequence that contains only distinct elements according to the keySelector and the comparer.
	   *  Usage of this operator should be considered carefully due to the maintenance of an internal lookup structure which can grow large.
	   *
	   * @example
	   *  var res = obs = xs.distinct();
	   *  2 - obs = xs.distinct(function (x) { return x.id; });
	   *  2 - obs = xs.distinct(function (x) { return x.id; }, function (a,b) { return a === b; });
	   * @param {Function} [keySelector]  A function to compute the comparison key for each element.
	   * @param {Function} [comparer]  Used to compare items in the collection.
	   * @returns {Observable} An observable sequence only containing the distinct elements, based on a computed key value, from the source sequence.
	   */
	  observableProto.distinct = function (keySelector, comparer) {
	    var source = this;
	    comparer || (comparer = defaultComparer);
	    return new AnonymousObservable(function (observer) {
	      var hashSet = new HashSet(comparer);
	      return source.subscribe(function (x) {
	        var key = x;

	        if (keySelector) {
	          try {
	            key = keySelector(x);
	          } catch (e) {
	            observer.onError(e);
	            return;
	          }
	        }
	        hashSet.push(key) && observer.onNext(x);
	      },
	      observer.onError.bind(observer),
	      observer.onCompleted.bind(observer));
	    });
	  };

	  /**
	   *  Groups the elements of an observable sequence according to a specified key selector function and comparer and selects the resulting elements by using a specified function.
	   *
	   * @example
	   *  var res = observable.groupBy(function (x) { return x.id; });
	   *  2 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; });
	   *  3 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; }, function (x) { return x.toString(); });
	   * @param {Function} keySelector A function to extract the key for each element.
	   * @param {Function} [elementSelector]  A function to map each source element to an element in an observable group.
	   * @param {Function} [comparer] Used to determine whether the objects are equal.
	   * @returns {Observable} A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.
	   */
	  observableProto.groupBy = function (keySelector, elementSelector, comparer) {
	    return this.groupByUntil(keySelector, elementSelector, observableNever, comparer);
	  };

	    /**
	     *  Groups the elements of an observable sequence according to a specified key selector function.
	     *  A duration selector function is used to control the lifetime of groups. When a group expires, it receives an OnCompleted notification. When a new element with the same
	     *  key value as a reclaimed group occurs, the group will be reborn with a new lifetime request.
	     *
	     * @example
	     *  var res = observable.groupByUntil(function (x) { return x.id; }, null,  function () { return Rx.Observable.never(); });
	     *  2 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; },  function () { return Rx.Observable.never(); });
	     *  3 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; },  function () { return Rx.Observable.never(); }, function (x) { return x.toString(); });
	     * @param {Function} keySelector A function to extract the key for each element.
	     * @param {Function} durationSelector A function to signal the expiration of a group.
	     * @param {Function} [comparer] Used to compare objects. When not specified, the default comparer is used.
	     * @returns {Observable}
	     *  A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.
	     *  If a group's lifetime expires, a new group with the same key value can be created once an element with such a key value is encoutered.
	     *
	     */
	    observableProto.groupByUntil = function (keySelector, elementSelector, durationSelector, comparer) {
	      var source = this;
	      elementSelector || (elementSelector = identity);
	      comparer || (comparer = defaultComparer);
	      return new AnonymousObservable(function (observer) {
	        function handleError(e) { return function (item) { item.onError(e); }; }
	        var map = new Dictionary(0, comparer),
	          groupDisposable = new CompositeDisposable(),
	          refCountDisposable = new RefCountDisposable(groupDisposable);

	        groupDisposable.add(source.subscribe(function (x) {
	          var key;
	          try {
	            key = keySelector(x);
	          } catch (e) {
	            map.getValues().forEach(handleError(e));
	            observer.onError(e);
	            return;
	          }

	          var fireNewMapEntry = false,
	            writer = map.tryGetValue(key);
	          if (!writer) {
	            writer = new Subject();
	            map.set(key, writer);
	            fireNewMapEntry = true;
	          }

	          if (fireNewMapEntry) {
	            var group = new GroupedObservable(key, writer, refCountDisposable),
	              durationGroup = new GroupedObservable(key, writer);
	            try {
	              duration = durationSelector(durationGroup);
	            } catch (e) {
	              map.getValues().forEach(handleError(e));
	              observer.onError(e);
	              return;
	            }

	            observer.onNext(group);

	            var md = new SingleAssignmentDisposable();
	            groupDisposable.add(md);

	            var expire = function () {
	              map.remove(key) && writer.onCompleted();
	              groupDisposable.remove(md);
	            };

	            md.setDisposable(duration.take(1).subscribe(
	              noop,
	              function (exn) {
	                map.getValues().forEach(handleError(exn));
	                observer.onError(exn);
	              },
	              expire)
	            );
	          }

	          var element;
	          try {
	            element = elementSelector(x);
	          } catch (e) {
	            map.getValues().forEach(handleError(e));
	            observer.onError(e);
	            return;
	          }

	          writer.onNext(element);
	      }, function (ex) {
	        map.getValues().forEach(handleError(ex));
	        observer.onError(ex);
	      }, function () {
	        map.getValues().forEach(function (item) { item.onCompleted(); });
	        observer.onCompleted();
	      }));

	      return refCountDisposable;
	    });
	  };

	  /**
	   *  Projects each element of an observable sequence into a new form by incorporating the element's index.
	   * @param {Function} selector A transform function to apply to each source element; the second parameter of the function represents the index of the source element.
	   * @param {Any} [thisArg] Object to use as this when executing callback.
	   * @returns {Observable} An observable sequence whose elements are the result of invoking the transform function on each element of source.
	   */
	  observableProto.select = observableProto.map = function (selector, thisArg) {
	    var parent = this;
	    return new AnonymousObservable(function (observer) {
	      var count = 0;
	      return parent.subscribe(function (value) {
	        var result;
	        try {
	          result = selector.call(thisArg, value, count++, parent);
	        } catch (e) {
	          observer.onError(e);
	          return;
	        }
	        observer.onNext(result);
	      }, observer.onError.bind(observer), observer.onCompleted.bind(observer));
	    });
	  };

	  /**
	   * Retrieves the value of a specified property from all elements in the Observable sequence.
	   * @param {String} prop The property to pluck.
	   * @returns {Observable} Returns a new Observable sequence of property values.
	   */
	  observableProto.pluck = function (prop) {
	    return this.map(function (x) { return x[prop]; });
	  };

	  function flatMap(source, selector, thisArg) {
	    return source.map(function (x, i) {
	      var result = selector.call(thisArg, x, i, source);
	      isPromise(result) && (result = observableFromPromise(result));
	      (Array.isArray(result) || isIterable(result)) && (result = observableFrom(result));
	      return result;
	    }).mergeObservable();
	  }

	  /**
	   *  One of the Following:
	   *  Projects each element of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.
	   *
	   * @example
	   *  var res = source.selectMany(function (x) { return Rx.Observable.range(0, x); });
	   *  Or:
	   *  Projects each element of an observable sequence to an observable sequence, invokes the result selector for the source element and each of the corresponding inner sequence's elements, and merges the results into one observable sequence.
	   *
	   *  var res = source.selectMany(function (x) { return Rx.Observable.range(0, x); }, function (x, y) { return x + y; });
	   *  Or:
	   *  Projects each element of the source observable sequence to the other observable sequence and merges the resulting observable sequences into one observable sequence.
	   *
	   *  var res = source.selectMany(Rx.Observable.fromArray([1,2,3]));
	   * @param {Function} selector A transform function to apply to each element or an observable sequence to project each element from the source sequence onto which could be either an observable or Promise.
	   * @param {Function} [resultSelector]  A transform function to apply to each element of the intermediate sequence.
	   * @param {Any} [thisArg] Object to use as this when executing callback.
	   * @returns {Observable} An observable sequence whose elements are the result of invoking the one-to-many transform function collectionSelector on each element of the input sequence and then mapping each of those sequence elements and their corresponding source element to a result element.
	   */
	  observableProto.selectMany = observableProto.flatMap = function (selector, resultSelector, thisArg) {
	    if (typeof selector === 'function' && typeof resultSelector === 'function') {
	      return this.flatMap(function (x, i) {
	        var selectorResult = selector(x, i);
	        isPromise(selectorResult) && (selectorResult = observableFromPromise(selectorResult));
	        (Array.isArray(selectorResult) || isIterable(selectorResult)) && (selectorResult = observableFrom(selectorResult));

	        return selectorResult.map(function (y, i2) {
	          return resultSelector(x, y, i, i2);
	        });
	      }, thisArg);
	    }
	    return typeof selector === 'function' ?
	      flatMap(this, selector, thisArg) :
	      flatMap(this, function () { return selector; });
	  };

	  /**
	   * Projects each notification of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.
	   * @param {Function} onNext A transform function to apply to each element; the second parameter of the function represents the index of the source element.
	   * @param {Function} onError A transform function to apply when an error occurs in the source sequence.
	   * @param {Function} onCompleted A transform function to apply when the end of the source sequence is reached.
	   * @param {Any} [thisArg] An optional "this" to use to invoke each transform.
	   * @returns {Observable} An observable sequence whose elements are the result of invoking the one-to-many transform function corresponding to each notification in the input sequence.
	   */
	  observableProto.flatMapObserver = observableProto.selectManyObserver = function (onNext, onError, onCompleted, thisArg) {
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      var index = 0;

	      return source.subscribe(
	        function (x) {
	          var result;
	          try {
	            result = onNext.call(thisArg, x, index++);
	          } catch (e) {
	            observer.onError(e);
	            return;
	          }
	          isPromise(result) && (result = observableFromPromise(result));
	          observer.onNext(result);
	        },
	        function (err) {
	          var result;
	          try {
	            result = onError.call(thisArg, err);
	          } catch (e) {
	            observer.onError(e);
	            return;
	          }
	          isPromise(result) && (result = observableFromPromise(result));
	          observer.onNext(result);
	          observer.onCompleted();
	        },
	        function () {
	          var result;
	          try {
	            result = onCompleted.call(thisArg);
	          } catch (e) {
	            observer.onError(e);
	            return;
	          }
	          isPromise(result) && (result = observableFromPromise(result));
	          observer.onNext(result);
	          observer.onCompleted();
	        });
	    }).mergeAll();
	  };

	  /**
	   *  Projects each element of an observable sequence into a new sequence of observable sequences by incorporating the element's index and then
	   *  transforms an observable sequence of observable sequences into an observable sequence producing values only from the most recent observable sequence.
	   * @param {Function} selector A transform function to apply to each source element; the second parameter of the function represents the index of the source element.
	   * @param {Any} [thisArg] Object to use as this when executing callback.
	   * @returns {Observable} An observable sequence whose elements are the result of invoking the transform function on each element of source producing an Observable of Observable sequences
	   *  and that at any point in time produces the elements of the most recent inner observable sequence that has been received.
	   */
	  observableProto.selectSwitch = observableProto.flatMapLatest = observableProto.switchMap = function (selector, thisArg) {
	    return this.select(selector, thisArg).switchLatest();
	  };

	  /**
	   * Bypasses a specified number of elements in an observable sequence and then returns the remaining elements.
	   * @param {Number} count The number of elements to skip before returning the remaining elements.
	   * @returns {Observable} An observable sequence that contains the elements that occur after the specified index in the input sequence.
	   */
	  observableProto.skip = function (count) {
	      if (count < 0) { throw new Error(argumentOutOfRange); }
	      var source = this;
	      return new AnonymousObservable(function (observer) {
	        var remaining = count;
	        return source.subscribe(function (x) {
	          if (remaining <= 0) {
	            observer.onNext(x);
	          } else {
	            remaining--;
	          }
	        }, observer.onError.bind(observer), observer.onCompleted.bind(observer));
	      });
	  };

	  /**
	   *  Bypasses elements in an observable sequence as long as a specified condition is true and then returns the remaining elements.
	   *  The element's index is used in the logic of the predicate function.
	   *
	   *  var res = source.skipWhile(function (value) { return value < 10; });
	   *  var res = source.skipWhile(function (value, index) { return value < 10 || index < 10; });
	   * @param {Function} predicate A function to test each element for a condition; the second parameter of the function represents the index of the source element.
	   * @param {Any} [thisArg] Object to use as this when executing callback.
	   * @returns {Observable} An observable sequence that contains the elements from the input sequence starting at the first element in the linear series that does not pass the test specified by predicate.
	   */
	  observableProto.skipWhile = function (predicate, thisArg) {
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      var i = 0, running = false;
	      return source.subscribe(function (x) {
	        if (!running) {
	          try {
	            running = !predicate.call(thisArg, x, i++, source);
	          } catch (e) {
	            observer.onError(e);
	            return;
	          }
	        }
	        running && observer.onNext(x);
	      }, observer.onError.bind(observer), observer.onCompleted.bind(observer));
	    });
	  };

	  /**
	   *  Returns a specified number of contiguous elements from the start of an observable sequence, using the specified scheduler for the edge case of take(0).
	   *
	   *  var res = source.take(5);
	   *  var res = source.take(0, Rx.Scheduler.timeout);
	   * @param {Number} count The number of elements to return.
	   * @param {Scheduler} [scheduler] Scheduler used to produce an OnCompleted message in case <paramref name="count count</paramref> is set to 0.
	   * @returns {Observable} An observable sequence that contains the specified number of elements from the start of the input sequence.
	   */
	  observableProto.take = function (count, scheduler) {
	      if (count < 0) { throw new RangeError(argumentOutOfRange); }
	      if (count === 0) { return observableEmpty(scheduler); }
	      var observable = this;
	      return new AnonymousObservable(function (observer) {
	        var remaining = count;
	        return observable.subscribe(function (x) {
	          if (remaining-- > 0) {
	            observer.onNext(x);
	            remaining === 0 && observer.onCompleted();
	          }
	        }, observer.onError.bind(observer), observer.onCompleted.bind(observer));
	      });
	  };

	  /**
	   *  Returns elements from an observable sequence as long as a specified condition is true.
	   *  The element's index is used in the logic of the predicate function.
	   * @param {Function} predicate A function to test each element for a condition; the second parameter of the function represents the index of the source element.
	   * @param {Any} [thisArg] Object to use as this when executing callback.
	   * @returns {Observable} An observable sequence that contains the elements from the input sequence that occur before the element at which the test no longer passes.
	   */
	  observableProto.takeWhile = function (predicate, thisArg) {
	    var observable = this;
	    return new AnonymousObservable(function (observer) {
	      var i = 0, running = true;
	      return observable.subscribe(function (x) {
	        if (running) {
	          try {
	            running = predicate.call(thisArg, x, i++, observable);
	          } catch (e) {
	            observer.onError(e);
	            return;
	          }
	          if (running) {
	            observer.onNext(x);
	          } else {
	            observer.onCompleted();
	          }
	        }
	      }, observer.onError.bind(observer), observer.onCompleted.bind(observer));
	    });
	  };

	  /**
	   *  Filters the elements of an observable sequence based on a predicate by incorporating the element's index.
	   *
	   * @example
	   *  var res = source.where(function (value) { return value < 10; });
	   *  var res = source.where(function (value, index) { return value < 10 || index < 10; });
	   * @param {Function} predicate A function to test each source element for a condition; the second parameter of the function represents the index of the source element.
	   * @param {Any} [thisArg] Object to use as this when executing callback.
	   * @returns {Observable} An observable sequence that contains elements from the input sequence that satisfy the condition.
	   */
	  observableProto.where = observableProto.filter = function (predicate, thisArg) {
	      var parent = this;
	      return new AnonymousObservable(function (observer) {
	        var count = 0;
	        return parent.subscribe(function (value) {
	          var shouldRun;
	          try {
	            shouldRun = predicate.call(thisArg, value, count++, parent);
	          } catch (e) {
	            observer.onError(e);
	            return;
	          }
	          shouldRun && observer.onNext(value);
	        }, observer.onError.bind(observer), observer.onCompleted.bind(observer));
	      });
	  };

	  observableProto.finalValue = function () {
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      var hasValue = false, value;
	      return source.subscribe(function (x) {
	        hasValue = true;
	        value = x;
	      }, observer.onError.bind(observer), function () {
	        if (!hasValue) {
	          observer.onError(new Error(sequenceContainsNoElements));
	        } else {
	          observer.onNext(value);
	          observer.onCompleted();
	        }
	      });
	    });
	  };

	  function extremaBy(source, keySelector, comparer) {
	    return new AnonymousObservable(function (observer) {
	      var hasValue = false, lastKey = null, list = [];
	      return source.subscribe(function (x) {
	        var comparison, key;
	        try {
	          key = keySelector(x);
	        } catch (ex) {
	          observer.onError(ex);
	          return;
	        }
	        comparison = 0;
	        if (!hasValue) {
	          hasValue = true;
	          lastKey = key;
	        } else {
	          try {
	            comparison = comparer(key, lastKey);
	          } catch (ex1) {
	            observer.onError(ex1);
	            return;
	          }
	        }
	        if (comparison > 0) {
	          lastKey = key;
	          list = [];
	        }
	        if (comparison >= 0) { list.push(x); }
	      }, observer.onError.bind(observer), function () {
	        observer.onNext(list);
	        observer.onCompleted();
	      });
	    });
	  }

	    function firstOnly(x) {
	        if (x.length === 0) {
	            throw new Error(sequenceContainsNoElements);
	        }
	        return x[0];
	    }

	  /**
	   * Applies an accumulator function over an observable sequence, returning the result of the aggregation as a single element in the result sequence. The specified seed value is used as the initial accumulator value.
	   * For aggregation behavior with incremental intermediate results, see Observable.scan.
	   * @param {Mixed} [seed] The initial accumulator value.
	   * @param {Function} accumulator An accumulator function to be invoked on each element.
	   * @returns {Observable} An observable sequence containing a single element with the final accumulator value.
	   */
	  observableProto.aggregate = function () {
	    var seed, hasSeed, accumulator;
	    if (arguments.length === 2) {
	      seed = arguments[0];
	      hasSeed = true;
	      accumulator = arguments[1];
	    } else {
	      accumulator = arguments[0];
	    }
	    return hasSeed ? this.scan(seed, accumulator).startWith(seed).finalValue() : this.scan(accumulator).finalValue();
	  };

	  /**
	   * Applies an accumulator function over an observable sequence, returning the result of the aggregation as a single element in the result sequence. The specified seed value is used as the initial accumulator value.
	   * For aggregation behavior with incremental intermediate results, see Observable.scan.
	   * @param {Function} accumulator An accumulator function to be invoked on each element.
	   * @param {Any} [seed] The initial accumulator value.
	   * @returns {Observable} An observable sequence containing a single element with the final accumulator value.
	   */
	  observableProto.reduce = function (accumulator) {
	    var seed, hasSeed;
	    if (arguments.length === 2) {
	      hasSeed = true;
	      seed = arguments[1];
	    }
	    return hasSeed ? this.scan(seed, accumulator).startWith(seed).finalValue() : this.scan(accumulator).finalValue();
	  };

	    /**
	     * Determines whether any element of an observable sequence satisfies a condition if present, else if any items are in the sequence.
	     * @example
	     * var result = source.any();
	     * var result = source.any(function (x) { return x > 3; });
	     * @param {Function} [predicate] A function to test each element for a condition.
	     * @returns {Observable} An observable sequence containing a single element determining whether any elements in the source sequence pass the test in the specified predicate if given, else if any items are in the sequence.
	     */
	    observableProto.some = observableProto.any = function (predicate, thisArg) {
	        var source = this;
	        return predicate ?
	            source.where(predicate, thisArg).any() :
	            new AnonymousObservable(function (observer) {
	                return source.subscribe(function () {
	                    observer.onNext(true);
	                    observer.onCompleted();
	                }, observer.onError.bind(observer), function () {
	                    observer.onNext(false);
	                    observer.onCompleted();
	                });
	            });
	    };

	  /**
	   * Determines whether an observable sequence is empty.
	   * @returns {Observable} An observable sequence containing a single element determining whether the source sequence is empty.
	   */
	  observableProto.isEmpty = function () {
	    return this.any().map(not);
	  };

	    /**
	     * Determines whether all elements of an observable sequence satisfy a condition.
	     *
	     * 1 - res = source.all(function (value) { return value.length > 3; });
	     * @memberOf Observable#
	     * @param {Function} [predicate] A function to test each element for a condition.
	     * @param {Any} [thisArg] Object to use as this when executing callback.
	     * @returns {Observable} An observable sequence containing a single element determining whether all elements in the source sequence pass the test in the specified predicate.
	     */
	    observableProto.every = observableProto.all = function (predicate, thisArg) {
	        return this.where(function (v) {
	            return !predicate(v);
	        }, thisArg).any().select(function (b) {
	            return !b;
	        });
	    };

	  /**
	   * Determines whether an observable sequence contains a specified element with an optional equality comparer.
	   * @param searchElement The value to locate in the source sequence.
	   * @param {Number} [fromIndex] An equality comparer to compare elements.
	   * @returns {Observable} An observable sequence containing a single element determining whether the source sequence contains an element that has the specified value from the given index.
	   */
	  observableProto.contains = function (searchElement, fromIndex) {
	    var source = this;
	    function comparer(a, b) {
	      return (a === 0 && b === 0) || (a === b || (isNaN(a) && isNaN(b)));
	    }
	    return new AnonymousObservable(function (observer) {
	      var i = 0, n = +fromIndex || 0;
	      Math.abs(n) === Infinity && (n = 0);
	      if (n < 0) {
	        observer.onNext(false);
	        observer.onCompleted();
	        return disposableEmpty;
	      }
	      return source.subscribe(
	        function (x) {
	          if (i++ >= n && comparer(x, searchElement)) {
	            observer.onNext(true);
	            observer.onCompleted();
	          }
	        },
	        observer.onError.bind(observer),
	        function () {
	          observer.onNext(false);
	          observer.onCompleted();
	        });
	    });
	  };

	    /**
	     * Returns an observable sequence containing a value that represents how many elements in the specified observable sequence satisfy a condition if provided, else the count of items.
	     * @example
	     * res = source.count();
	     * res = source.count(function (x) { return x > 3; });
	     * @param {Function} [predicate]A function to test each element for a condition.
	     * @param {Any} [thisArg] Object to use as this when executing callback.
	     * @returns {Observable} An observable sequence containing a single element with a number that represents how many elements in the input sequence satisfy the condition in the predicate function if provided, else the count of items in the sequence.
	     */
	    observableProto.count = function (predicate, thisArg) {
	        return predicate ?
	            this.where(predicate, thisArg).count() :
	            this.aggregate(0, function (count) {
	                return count + 1;
	            });
	    };

	  /**
	   * Returns the first index at which a given element can be found in the observable sequence, or -1 if it is not present.
	   * @param {Any} searchElement Element to locate in the array.
	   * @param {Number} [fromIndex] The index to start the search.  If not specified, defaults to 0.
	   * @returns {Observable} And observable sequence containing the first index at which a given element can be found in the observable sequence, or -1 if it is not present.
	   */
	  observableProto.indexOf = function(searchElement, fromIndex) {
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      var i = 0, n = +fromIndex || 0;
	      Math.abs(n) === Infinity && (n = 0);
	      if (n < 0) {
	        observer.onNext(-1);
	        observer.onCompleted();
	        return disposableEmpty;
	      }
	      return source.subscribe(
	        function (x) {
	          if (i >= n && x === searchElement) {
	            observer.onNext(i);
	            observer.onCompleted();
	          }
	          i++;
	        },
	        observer.onError.bind(observer),
	        function () {
	          observer.onNext(-1);
	          observer.onCompleted();
	        });
	    });
	  };
	  /**
	   * Computes the sum of a sequence of values that are obtained by invoking an optional transform function on each element of the input sequence, else if not specified computes the sum on each item in the sequence.
	   * @example
	   * var res = source.sum();
	   * var res = source.sum(function (x) { return x.value; });
	   * @param {Function} [selector] A transform function to apply to each element.
	   * @param {Any} [thisArg] Object to use as this when executing callback.
	   * @returns {Observable} An observable sequence containing a single element with the sum of the values in the source sequence.
	   */
	  observableProto.sum = function (keySelector, thisArg) {
	    return keySelector && isFunction(keySelector) ?
	      this.map(keySelector, thisArg).sum() :
	      this.aggregate(0, function (prev, curr) {
	        return prev + curr;
	      });
	  };

	    /**
	     * Returns the elements in an observable sequence with the minimum key value according to the specified comparer.
	     * @example
	     * var res = source.minBy(function (x) { return x.value; });
	     * var res = source.minBy(function (x) { return x.value; }, function (x, y) { return x - y; });
	     * @param {Function} keySelector Key selector function.
	     * @param {Function} [comparer] Comparer used to compare key values.
	     * @returns {Observable} An observable sequence containing a list of zero or more elements that have a minimum key value.
	     */
	    observableProto.minBy = function (keySelector, comparer) {
	        comparer || (comparer = defaultSubComparer);
	        return extremaBy(this, keySelector, function (x, y) {
	            return comparer(x, y) * -1;
	        });
	    };

	    /**
	     * Returns the minimum element in an observable sequence according to the optional comparer else a default greater than less than check.
	     * @example
	     * var res = source.min();
	     * var res = source.min(function (x, y) { return x.value - y.value; });
	     * @param {Function} [comparer] Comparer used to compare elements.
	     * @returns {Observable} An observable sequence containing a single element with the minimum element in the source sequence.
	     */
	    observableProto.min = function (comparer) {
	        return this.minBy(identity, comparer).select(function (x) {
	            return firstOnly(x);
	        });
	    };

	    /**
	     * Returns the elements in an observable sequence with the maximum  key value according to the specified comparer.
	     * @example
	     * var res = source.maxBy(function (x) { return x.value; });
	     * var res = source.maxBy(function (x) { return x.value; }, function (x, y) { return x - y;; });
	     * @param {Function} keySelector Key selector function.
	     * @param {Function} [comparer]  Comparer used to compare key values.
	     * @returns {Observable} An observable sequence containing a list of zero or more elements that have a maximum key value.
	     */
	    observableProto.maxBy = function (keySelector, comparer) {
	        comparer || (comparer = defaultSubComparer);
	        return extremaBy(this, keySelector, comparer);
	    };

	    /**
	     * Returns the maximum value in an observable sequence according to the specified comparer.
	     * @example
	     * var res = source.max();
	     * var res = source.max(function (x, y) { return x.value - y.value; });
	     * @param {Function} [comparer] Comparer used to compare elements.
	     * @returns {Observable} An observable sequence containing a single element with the maximum element in the source sequence.
	     */
	    observableProto.max = function (comparer) {
	        return this.maxBy(identity, comparer).select(function (x) {
	            return firstOnly(x);
	        });
	    };

	  /**
	   * Computes the average of an observable sequence of values that are in the sequence or obtained by invoking a transform function on each element of the input sequence if present.
	   * @param {Function} [selector] A transform function to apply to each element.
	   * @param {Any} [thisArg] Object to use as this when executing callback.
	   * @returns {Observable} An observable sequence containing a single element with the average of the sequence of values.
	   */
	  observableProto.average = function (keySelector, thisArg) {
	    return keySelector && isFunction(keySelector) ?
	      this.select(keySelector, thisArg).average() :
	      this.scan({sum: 0, count: 0 }, function (prev, cur) {
	        return {
	          sum: prev.sum + cur,
	          count: prev.count + 1
	        };
	      }).finalValue().map(function (s) {
	        if (s.count === 0) {
	          throw new Error('The input sequence was empty');
	        }
	        return s.sum / s.count;
	      });
	  };

	  function sequenceEqualArray(first, second, comparer) {
	    return new AnonymousObservable(function (observer) {
	      var count = 0, len = second.length;
	      return first.subscribe(function (value) {
	        var equal = false;
	        try {
	          count < len && (equal = comparer(value, second[count++]));
	        } catch (e) {
	          observer.onError(e);
	          return;
	        }
	        if (!equal) {
	          observer.onNext(false);
	          observer.onCompleted();
	        }
	      }, observer.onError.bind(observer), function () {
	        observer.onNext(count === len);
	        observer.onCompleted();
	      });
	    });
	  }

	  /**
	   *  Determines whether two sequences are equal by comparing the elements pairwise using a specified equality comparer.
	   *
	   * @example
	   * var res = res = source.sequenceEqual([1,2,3]);
	   * var res = res = source.sequenceEqual([{ value: 42 }], function (x, y) { return x.value === y.value; });
	   * 3 - res = source.sequenceEqual(Rx.Observable.returnValue(42));
	   * 4 - res = source.sequenceEqual(Rx.Observable.returnValue({ value: 42 }), function (x, y) { return x.value === y.value; });
	   * @param {Observable} second Second observable sequence or array to compare.
	   * @param {Function} [comparer] Comparer used to compare elements of both sequences.
	   * @returns {Observable} An observable sequence that contains a single element which indicates whether both sequences are of equal length and their corresponding elements are equal according to the specified equality comparer.
	   */
	  observableProto.sequenceEqual = function (second, comparer) {
	    var first = this;
	    comparer || (comparer = defaultComparer);
	    if (Array.isArray(second)) {
	      return sequenceEqualArray(first, second, comparer);
	    }
	    return new AnonymousObservable(function (observer) {
	      var donel = false, doner = false, ql = [], qr = [];
	      var subscription1 = first.subscribe(function (x) {
	        var equal, v;
	        if (qr.length > 0) {
	          v = qr.shift();
	          try {
	            equal = comparer(v, x);
	          } catch (e) {
	            observer.onError(e);
	            return;
	          }
	          if (!equal) {
	            observer.onNext(false);
	            observer.onCompleted();
	          }
	        } else if (doner) {
	          observer.onNext(false);
	          observer.onCompleted();
	        } else {
	          ql.push(x);
	        }
	      }, observer.onError.bind(observer), function () {
	        donel = true;
	        if (ql.length === 0) {
	          if (qr.length > 0) {
	            observer.onNext(false);
	            observer.onCompleted();
	          } else if (doner) {
	            observer.onNext(true);
	            observer.onCompleted();
	          }
	        }
	      });

	      isPromise(second) && (second = observableFromPromise(second));
	      var subscription2 = second.subscribe(function (x) {
	        var equal;
	        if (ql.length > 0) {
	          var v = ql.shift();
	          try {
	            equal = comparer(v, x);
	          } catch (exception) {
	            observer.onError(exception);
	            return;
	          }
	          if (!equal) {
	            observer.onNext(false);
	            observer.onCompleted();
	          }
	        } else if (donel) {
	          observer.onNext(false);
	          observer.onCompleted();
	        } else {
	          qr.push(x);
	        }
	      }, observer.onError.bind(observer), function () {
	        doner = true;
	        if (qr.length === 0) {
	          if (ql.length > 0) {
	            observer.onNext(false);
	            observer.onCompleted();
	          } else if (donel) {
	            observer.onNext(true);
	            observer.onCompleted();
	          }
	        }
	      });
	      return new CompositeDisposable(subscription1, subscription2);
	    });
	  };

	    function elementAtOrDefault(source, index, hasDefault, defaultValue) {
	        if (index < 0) {
	            throw new Error(argumentOutOfRange);
	        }
	        return new AnonymousObservable(function (observer) {
	            var i = index;
	            return source.subscribe(function (x) {
	                if (i === 0) {
	                    observer.onNext(x);
	                    observer.onCompleted();
	                }
	                i--;
	            }, observer.onError.bind(observer), function () {
	                if (!hasDefault) {
	                    observer.onError(new Error(argumentOutOfRange));
	                } else {
	                    observer.onNext(defaultValue);
	                    observer.onCompleted();
	                }
	            });
	        });
	    }

	    /**
	     * Returns the element at a specified index in a sequence.
	     * @example
	     * var res = source.elementAt(5);
	     * @param {Number} index The zero-based index of the element to retrieve.
	     * @returns {Observable} An observable sequence that produces the element at the specified position in the source sequence.
	     */
	    observableProto.elementAt =  function (index) {
	        return elementAtOrDefault(this, index, false);
	    };

	    /**
	     * Returns the element at a specified index in a sequence or a default value if the index is out of range.
	     * @example
	     * var res = source.elementAtOrDefault(5);
	     * var res = source.elementAtOrDefault(5, 0);
	     * @param {Number} index The zero-based index of the element to retrieve.
	     * @param [defaultValue] The default value if the index is outside the bounds of the source sequence.
	     * @returns {Observable} An observable sequence that produces the element at the specified position in the source sequence, or a default value if the index is outside the bounds of the source sequence.
	     */
	    observableProto.elementAtOrDefault = function (index, defaultValue) {
	        return elementAtOrDefault(this, index, true, defaultValue);
	    };

	  function singleOrDefaultAsync(source, hasDefault, defaultValue) {
	    return new AnonymousObservable(function (observer) {
	      var value = defaultValue, seenValue = false;
	      return source.subscribe(function (x) {
	        if (seenValue) {
	          observer.onError(new Error('Sequence contains more than one element'));
	        } else {
	          value = x;
	          seenValue = true;
	        }
	      }, observer.onError.bind(observer), function () {
	        if (!seenValue && !hasDefault) {
	          observer.onError(new Error(sequenceContainsNoElements));
	        } else {
	          observer.onNext(value);
	          observer.onCompleted();
	        }
	      });
	    });
	  }

	  /**
	   * Returns the only element of an observable sequence that satisfies the condition in the optional predicate, and reports an exception if there is not exactly one element in the observable sequence.
	   * @example
	   * var res = res = source.single();
	   * var res = res = source.single(function (x) { return x === 42; });
	   * @param {Function} [predicate] A predicate function to evaluate for elements in the source sequence.
	   * @param {Any} [thisArg] Object to use as `this` when executing the predicate.
	   * @returns {Observable} Sequence containing the single element in the observable sequence that satisfies the condition in the predicate.
	   */
	  observableProto.single = function (predicate, thisArg) {
	    return predicate && isFunction(predicate) ?
	      this.where(predicate, thisArg).single() :
	      singleOrDefaultAsync(this, false);
	  };

	  /**
	   * Returns the only element of an observable sequence that matches the predicate, or a default value if no such element exists; this method reports an exception if there is more than one element in the observable sequence.
	   * @example
	   * var res = res = source.singleOrDefault();
	   * var res = res = source.singleOrDefault(function (x) { return x === 42; });
	   * res = source.singleOrDefault(function (x) { return x === 42; }, 0);
	   * res = source.singleOrDefault(null, 0);
	   * @memberOf Observable#
	   * @param {Function} predicate A predicate function to evaluate for elements in the source sequence.
	   * @param [defaultValue] The default value if the index is outside the bounds of the source sequence.
	   * @param {Any} [thisArg] Object to use as `this` when executing the predicate.
	   * @returns {Observable} Sequence containing the single element in the observable sequence that satisfies the condition in the predicate, or a default value if no such element exists.
	   */
	  observableProto.singleOrDefault = function (predicate, defaultValue, thisArg) {
	    return predicate && isFunction(predicate) ?
	      this.where(predicate, thisArg).singleOrDefault(null, defaultValue) :
	      singleOrDefaultAsync(this, true, defaultValue);
	  };

	    function firstOrDefaultAsync(source, hasDefault, defaultValue) {
	        return new AnonymousObservable(function (observer) {
	            return source.subscribe(function (x) {
	                observer.onNext(x);
	                observer.onCompleted();
	            }, observer.onError.bind(observer), function () {
	                if (!hasDefault) {
	                    observer.onError(new Error(sequenceContainsNoElements));
	                } else {
	                    observer.onNext(defaultValue);
	                    observer.onCompleted();
	                }
	            });
	        });
	    }

	    /**
	     * Returns the first element of an observable sequence that satisfies the condition in the predicate if present else the first item in the sequence.
	     * @example
	     * var res = res = source.first();
	     * var res = res = source.first(function (x) { return x > 3; });
	     * @param {Function} [predicate] A predicate function to evaluate for elements in the source sequence.
	     * @param {Any} [thisArg] Object to use as `this` when executing the predicate.
	     * @returns {Observable} Sequence containing the first element in the observable sequence that satisfies the condition in the predicate if provided, else the first item in the sequence.
	     */
	    observableProto.first = function (predicate, thisArg) {
	        return predicate ?
	            this.where(predicate, thisArg).first() :
	            firstOrDefaultAsync(this, false);
	    };

	    /**
	     * Returns the first element of an observable sequence that satisfies the condition in the predicate, or a default value if no such element exists.
	     * @example
	     * var res = res = source.firstOrDefault();
	     * var res = res = source.firstOrDefault(function (x) { return x > 3; });
	     * var res = source.firstOrDefault(function (x) { return x > 3; }, 0);
	     * var res = source.firstOrDefault(null, 0);
	     * @param {Function} [predicate] A predicate function to evaluate for elements in the source sequence.
	     * @param {Any} [defaultValue] The default value if no such element exists.  If not specified, defaults to null.
	     * @param {Any} [thisArg] Object to use as `this` when executing the predicate.
	     * @returns {Observable} Sequence containing the first element in the observable sequence that satisfies the condition in the predicate, or a default value if no such element exists.
	     */
	    observableProto.firstOrDefault = function (predicate, defaultValue, thisArg) {
	        return predicate ?
	            this.where(predicate).firstOrDefault(null, defaultValue) :
	            firstOrDefaultAsync(this, true, defaultValue);
	    };

	    function lastOrDefaultAsync(source, hasDefault, defaultValue) {
	        return new AnonymousObservable(function (observer) {
	            var value = defaultValue, seenValue = false;
	            return source.subscribe(function (x) {
	                value = x;
	                seenValue = true;
	            }, observer.onError.bind(observer), function () {
	                if (!seenValue && !hasDefault) {
	                    observer.onError(new Error(sequenceContainsNoElements));
	                } else {
	                    observer.onNext(value);
	                    observer.onCompleted();
	                }
	            });
	        });
	    }

	    /**
	     * Returns the last element of an observable sequence that satisfies the condition in the predicate if specified, else the last element.
	     * @example
	     * var res = source.last();
	     * var res = source.last(function (x) { return x > 3; });
	     * @param {Function} [predicate] A predicate function to evaluate for elements in the source sequence.
	     * @param {Any} [thisArg] Object to use as `this` when executing the predicate.
	     * @returns {Observable} Sequence containing the last element in the observable sequence that satisfies the condition in the predicate.
	     */
	    observableProto.last = function (predicate, thisArg) {
	        return predicate ?
	            this.where(predicate, thisArg).last() :
	            lastOrDefaultAsync(this, false);
	    };

	    /**
	     * Returns the last element of an observable sequence that satisfies the condition in the predicate, or a default value if no such element exists.
	     * @example
	     * var res = source.lastOrDefault();
	     * var res = source.lastOrDefault(function (x) { return x > 3; });
	     * var res = source.lastOrDefault(function (x) { return x > 3; }, 0);
	     * var res = source.lastOrDefault(null, 0);
	     * @param {Function} [predicate] A predicate function to evaluate for elements in the source sequence.
	     * @param [defaultValue] The default value if no such element exists.  If not specified, defaults to null.
	     * @param {Any} [thisArg] Object to use as `this` when executing the predicate.
	     * @returns {Observable} Sequence containing the last element in the observable sequence that satisfies the condition in the predicate, or a default value if no such element exists.
	     */
	    observableProto.lastOrDefault = function (predicate, defaultValue, thisArg) {
	        return predicate ?
	            this.where(predicate, thisArg).lastOrDefault(null, defaultValue) :
	            lastOrDefaultAsync(this, true, defaultValue);
	    };

	    function findValue (source, predicate, thisArg, yieldIndex) {
	        return new AnonymousObservable(function (observer) {
	            var i = 0;
	            return source.subscribe(function (x) {
	                var shouldRun;
	                try {
	                    shouldRun = predicate.call(thisArg, x, i, source);
	                } catch(e) {
	                    observer.onError(e);
	                    return;
	                }
	                if (shouldRun) {
	                    observer.onNext(yieldIndex ? i : x);
	                    observer.onCompleted();
	                } else {
	                    i++;
	                }
	            }, observer.onError.bind(observer), function () {
	                observer.onNext(yieldIndex ? -1 : undefined);
	                observer.onCompleted();
	            });
	        });
	    }

	    /**
	     * Searches for an element that matches the conditions defined by the specified predicate, and returns the first occurrence within the entire Observable sequence.
	     * @param {Function} predicate The predicate that defines the conditions of the element to search for.
	     * @param {Any} [thisArg] Object to use as `this` when executing the predicate.
	     * @returns {Observable} An Observable sequence with the first element that matches the conditions defined by the specified predicate, if found; otherwise, undefined.
	     */
	    observableProto.find = function (predicate, thisArg) {
	        return findValue(this, predicate, thisArg, false);
	    };

	    /**
	     * Searches for an element that matches the conditions defined by the specified predicate, and returns
	     * an Observable sequence with the zero-based index of the first occurrence within the entire Observable sequence.
	     * @param {Function} predicate The predicate that defines the conditions of the element to search for.
	     * @param {Any} [thisArg] Object to use as `this` when executing the predicate.
	     * @returns {Observable} An Observable sequence with the zero-based index of the first occurrence of an element that matches the conditions defined by match, if found; otherwise, 1.
	    */
	    observableProto.findIndex = function (predicate, thisArg) {
	        return findValue(this, predicate, thisArg, true);
	    };

	  if (!!root.Set) {
	    /**
	     * Converts the observable sequence to a Set if it exists.
	     * @returns {Observable} An observable sequence with a single value of a Set containing the values from the observable sequence.
	     */
	    observableProto.toSet = function () {
	      var source = this;
	      return new AnonymousObservable(function (observer) {
	        var s = new root.Set();
	        return source.subscribe(
	          s.add.bind(s),
	          observer.onError.bind(observer),
	          function () {
	            observer.onNext(s);
	            observer.onCompleted();
	          });
	      });
	    };
	  }

	  if (!!root.Map) {
	    /**
	    * Converts the observable sequence to a Map if it exists.
	    * @param {Function} keySelector A function which produces the key for the Map.
	    * @param {Function} [elementSelector] An optional function which produces the element for the Map. If not present, defaults to the value from the observable sequence.
	    * @returns {Observable} An observable sequence with a single value of a Map containing the values from the observable sequence.
	    */
	    observableProto.toMap = function (keySelector, elementSelector) {
	      var source = this;
	      return new AnonymousObservable(function (observer) {
	        var m = new root.Map();
	        return source.subscribe(
	          function (x) {
	            var key;
	            try {
	              key = keySelector(x);
	            } catch (e) {
	              observer.onError(e);
	              return;
	            }

	            var element = x;
	            if (elementSelector) {
	              try {
	                element = elementSelector(x);
	              } catch (e) {
	                observer.onError(e);
	                return;
	              }
	            }

	            m.set(key, element);
	          },
	          observer.onError.bind(observer),
	          function () {
	            observer.onNext(m);
	            observer.onCompleted();
	          });
	      });
	    };
	  }

	  var fnString = 'function',
	      throwString = 'throw';

	  function toThunk(obj, ctx) {
	    if (Array.isArray(obj)) {  return objectToThunk.call(ctx, obj); }
	    if (isGeneratorFunction(obj)) { return observableSpawn(obj.call(ctx)); }
	    if (isGenerator(obj)) {  return observableSpawn(obj); }
	    if (isObservable(obj)) { return observableToThunk(obj); }
	    if (isPromise(obj)) { return promiseToThunk(obj); }
	    if (typeof obj === fnString) { return obj; }
	    if (isObject(obj) || Array.isArray(obj)) { return objectToThunk.call(ctx, obj); }

	    return obj;
	  }

	  function objectToThunk(obj) {
	    var ctx = this;

	    return function (done) {
	      var keys = Object.keys(obj),
	          pending = keys.length,
	          results = new obj.constructor(),
	          finished;

	      if (!pending) {
	        timeoutScheduler.schedule(function () { done(null, results); });
	        return;
	      }

	      for (var i = 0, len = keys.length; i < len; i++) {
	        run(obj[keys[i]], keys[i]);
	      }

	      function run(fn, key) {
	        if (finished) { return; }
	        try {
	          fn = toThunk(fn, ctx);

	          if (typeof fn !== fnString) {
	            results[key] = fn;
	            return --pending || done(null, results);
	          }

	          fn.call(ctx, function(err, res){
	            if (finished) { return; }

	            if (err) {
	              finished = true;
	              return done(err);
	            }

	            results[key] = res;
	            --pending || done(null, results);
	          });
	        } catch (e) {
	          finished = true;
	          done(e);
	        }
	      }
	    }
	  }

	  function observableToThunk(observable) {
	    return function (fn) {
	      var value, hasValue = false;
	      observable.subscribe(
	        function (v) {
	          value = v;
	          hasValue = true;
	        },
	        fn,
	        function () {
	          hasValue && fn(null, value);
	        });
	    }
	  }

	  function promiseToThunk(promise) {
	    return function(fn){
	      promise.then(function(res) {
	        fn(null, res);
	      }, fn);
	    }
	  }

	  function isObservable(obj) {
	    return obj && typeof obj.subscribe === fnString;
	  }

	  function isGeneratorFunction(obj) {
	    return obj && obj.constructor && obj.constructor.name === 'GeneratorFunction';
	  }

	  function isGenerator(obj) {
	    return obj && typeof obj.next === fnString && typeof obj[throwString] === fnString;
	  }

	  function isObject(val) {
	    return val && val.constructor === Object;
	  }

	  /*
	   * Spawns a generator function which allows for Promises, Observable sequences, Arrays, Objects, Generators and functions.
	   * @param {Function} The spawning function.
	   * @returns {Function} a function which has a done continuation.
	   */
	  var observableSpawn = Rx.spawn = function (fn) {
	    var isGenFun = isGeneratorFunction(fn);

	    return function (done) {
	      var ctx = this,
	        gen = fn;

	      if (isGenFun) {
	        var args = slice.call(arguments),
	          len = args.length,
	          hasCallback = len && typeof args[len - 1] === fnString;

	        done = hasCallback ? args.pop() : error;
	        gen = fn.apply(this, args);
	      } else {
	        done = done || error;
	      }

	      next();

	      function exit(err, res) {
	        timeoutScheduler.schedule(done.bind(ctx, err, res));
	      }

	      function next(err, res) {
	        var ret;

	        // multiple args
	        if (arguments.length > 2) res = slice.call(arguments, 1);

	        if (err) {
	          try {
	            ret = gen[throwString](err);
	          } catch (e) {
	            return exit(e);
	          }
	        }

	        if (!err) {
	          try {
	            ret = gen.next(res);
	          } catch (e) {
	            return exit(e);
	          }
	        }

	        if (ret.done)  {
	          return exit(null, ret.value);
	        }

	        ret.value = toThunk(ret.value, ctx);

	        if (typeof ret.value === fnString) {
	          var called = false;
	          try {
	            ret.value.call(ctx, function(){
	              if (called) {
	                return;
	              }

	              called = true;
	              next.apply(ctx, arguments);
	            });
	          } catch (e) {
	            timeoutScheduler.schedule(function () {
	              if (called) {
	                return;
	              }

	              called = true;
	              next.call(ctx, e);
	            });
	          }
	          return;
	        }

	        // Not supported
	        next(new TypeError('Rx.spawn only supports a function, Promise, Observable, Object or Array.'));
	      }
	    }
	  };

	  /**
	   * Takes a function with a callback and turns it into a thunk.
	   * @param {Function} A function with a callback such as fs.readFile
	   * @returns {Function} A function, when executed will continue the state machine.
	   */
	  Rx.denodify = function (fn) {
	    return function (){
	      var args = slice.call(arguments),
	        results,
	        called,
	        callback;

	      args.push(function(){
	        results = arguments;

	        if (callback && !called) {
	          called = true;
	          cb.apply(this, results);
	        }
	      });

	      fn.apply(this, args);

	      return function (fn){
	        callback = fn;

	        if (results && !called) {
	          called = true;
	          fn.apply(this, results);
	        }
	      }
	    }
	  };

	  function error(err) {
	    if (!err) { return; }
	    timeoutScheduler.schedule(function(){
	      throw err;
	    });
	  }

	  /**
	   * Invokes the specified function asynchronously on the specified scheduler, surfacing the result through an observable sequence.
	   *
	   * @example
	   * var res = Rx.Observable.start(function () { console.log('hello'); });
	   * var res = Rx.Observable.start(function () { console.log('hello'); }, Rx.Scheduler.timeout);
	   * var res = Rx.Observable.start(function () { this.log('hello'); }, Rx.Scheduler.timeout, console);
	   *
	   * @param {Function} func Function to run asynchronously.
	   * @param {Scheduler} [scheduler]  Scheduler to run the function on. If not specified, defaults to Scheduler.timeout.
	   * @param [context]  The context for the func parameter to be executed.  If not specified, defaults to undefined.
	   * @returns {Observable} An observable sequence exposing the function's result value, or an exception.
	   *
	   * Remarks
	   * * The function is called immediately, not during the subscription of the resulting sequence.
	   * * Multiple subscriptions to the resulting sequence can observe the function's result.
	   */
	  Observable.start = function (func, context, scheduler) {
	    return observableToAsync(func, context, scheduler)();
	  };

	  /**
	   * Converts the function into an asynchronous function. Each invocation of the resulting asynchronous function causes an invocation of the original synchronous function on the specified scheduler.
	   *
	   * @example
	   * var res = Rx.Observable.toAsync(function (x, y) { return x + y; })(4, 3);
	   * var res = Rx.Observable.toAsync(function (x, y) { return x + y; }, Rx.Scheduler.timeout)(4, 3);
	   * var res = Rx.Observable.toAsync(function (x) { this.log(x); }, Rx.Scheduler.timeout, console)('hello');
	   *
	   * @param {Function} function Function to convert to an asynchronous function.
	   * @param {Scheduler} [scheduler] Scheduler to run the function on. If not specified, defaults to Scheduler.timeout.
	   * @param {Mixed} [context] The context for the func parameter to be executed.  If not specified, defaults to undefined.
	   * @returns {Function} Asynchronous function.
	   */
	  var observableToAsync = Observable.toAsync = function (func, context, scheduler) {
	    isScheduler(scheduler) || (scheduler = timeoutScheduler);
	    return function () {
	      var args = arguments,
	        subject = new AsyncSubject();

	      scheduler.schedule(function () {
	        var result;
	        try {
	          result = func.apply(context, args);
	        } catch (e) {
	          subject.onError(e);
	          return;
	        }
	        subject.onNext(result);
	        subject.onCompleted();
	      });
	      return subject.asObservable();
	    };
	  };

	  /**
	   * Converts a callback function to an observable sequence.
	   *
	   * @param {Function} function Function with a callback as the last parameter to convert to an Observable sequence.
	   * @param {Mixed} [context] The context for the func parameter to be executed.  If not specified, defaults to undefined.
	   * @param {Function} [selector] A selector which takes the arguments from the callback to produce a single item to yield on next.
	   * @returns {Function} A function, when executed with the required parameters minus the callback, produces an Observable sequence with a single value of the arguments to the callback as an array.
	   */
	  Observable.fromCallback = function (func, context, selector) {
	    return function () {
	      var args = slice.call(arguments, 0);

	      return new AnonymousObservable(function (observer) {
	        function handler(e) {
	          var results = e;

	          if (selector) {
	            try {
	              results = selector(arguments);
	            } catch (err) {
	              observer.onError(err);
	              return;
	            }

	            observer.onNext(results);
	          } else {
	            if (results.length <= 1) {
	              observer.onNext.apply(observer, results);
	            } else {
	              observer.onNext(results);
	            }
	          }

	          observer.onCompleted();
	        }

	        args.push(handler);
	        func.apply(context, args);
	      }).publishLast().refCount();
	    };
	  };

	  /**
	   * Converts a Node.js callback style function to an observable sequence.  This must be in function (err, ...) format.
	   * @param {Function} func The function to call
	   * @param {Mixed} [context] The context for the func parameter to be executed.  If not specified, defaults to undefined.
	   * @param {Function} [selector] A selector which takes the arguments from the callback minus the error to produce a single item to yield on next.
	   * @returns {Function} An async function which when applied, returns an observable sequence with the callback arguments as an array.
	   */
	  Observable.fromNodeCallback = function (func, context, selector) {
	    return function () {
	      var args = slice.call(arguments, 0);

	      return new AnonymousObservable(function (observer) {
	        function handler(err) {
	          if (err) {
	            observer.onError(err);
	            return;
	          }

	          var results = slice.call(arguments, 1);

	          if (selector) {
	            try {
	              results = selector(results);
	            } catch (e) {
	              observer.onError(e);
	              return;
	            }
	            observer.onNext(results);
	          } else {
	            if (results.length <= 1) {
	              observer.onNext.apply(observer, results);
	            } else {
	              observer.onNext(results);
	            }
	          }

	          observer.onCompleted();
	        }

	        args.push(handler);
	        func.apply(context, args);
	      }).publishLast().refCount();
	    };
	  };

	  function createListener (element, name, handler) {
	    if (element.addEventListener) {
	      element.addEventListener(name, handler, false);
	      return disposableCreate(function () {
	        element.removeEventListener(name, handler, false);
	      });
	    }
	    throw new Error('No listener found');
	  }

	  function createEventListener (el, eventName, handler) {
	    var disposables = new CompositeDisposable();

	    // Asume NodeList
	    if (Object.prototype.toString.call(el) === '[object NodeList]') {
	      for (var i = 0, len = el.length; i < len; i++) {
	        disposables.add(createEventListener(el.item(i), eventName, handler));
	      }
	    } else if (el) {
	      disposables.add(createListener(el, eventName, handler));
	    }

	    return disposables;
	  }

	  /**
	   * Configuration option to determine whether to use native events only
	   */
	  Rx.config.useNativeEvents = false;

	  // Check for Angular/jQuery/Zepto support
	  var jq =
	   !!root.angular && !!angular.element ? angular.element :
	   (!!root.jQuery ? root.jQuery : (
	     !!root.Zepto ? root.Zepto : null));

	  // Check for ember
	  var ember = !!root.Ember && typeof root.Ember.addListener === 'function';

	  // Check for Backbone.Marionette. Note if using AMD add Marionette as a dependency of rxjs
	  // for proper loading order!
	  var marionette = !!root.Backbone && !!root.Backbone.Marionette;

	  /**
	   * Creates an observable sequence by adding an event listener to the matching DOMElement or each item in the NodeList.
	   *
	   * @example
	   *   var source = Rx.Observable.fromEvent(element, 'mouseup');
	   *
	   * @param {Object} element The DOMElement or NodeList to attach a listener.
	   * @param {String} eventName The event name to attach the observable sequence.
	   * @param {Function} [selector] A selector which takes the arguments from the event handler to produce a single item to yield on next.
	   * @returns {Observable} An observable sequence of events from the specified element and the specified event.
	   */
	  Observable.fromEvent = function (element, eventName, selector) {
	    // Node.js specific
	    if (element.addListener) {
	      return fromEventPattern(
	        function (h) { element.addListener(eventName, h); },
	        function (h) { element.removeListener(eventName, h); },
	        selector);
	    }

	    // Use only if non-native events are allowed
	    if (!Rx.config.useNativeEvents) {
	      if (marionette) {
	        return fromEventPattern(
	          function (h) { element.on(eventName, h); },
	          function (h) { element.off(eventName, h); },
	          selector);
	      }
	      if (ember) {
	        return fromEventPattern(
	          function (h) { Ember.addListener(element, eventName, h); },
	          function (h) { Ember.removeListener(element, eventName, h); },
	          selector);
	      }
	      if (jq) {
	        var $elem = jq(element);
	        return fromEventPattern(
	          function (h) { $elem.on(eventName, h); },
	          function (h) { $elem.off(eventName, h); },
	          selector);
	      }
	    }
	    return new AnonymousObservable(function (observer) {
	      return createEventListener(
	        element,
	        eventName,
	        function handler (e) {
	          var results = e;

	          if (selector) {
	            try {
	              results = selector(arguments);
	            } catch (err) {
	              observer.onError(err);
	              return
	            }
	          }

	          observer.onNext(results);
	        });
	    }).publish().refCount();
	  };

	  /**
	   * Creates an observable sequence from an event emitter via an addHandler/removeHandler pair.
	   * @param {Function} addHandler The function to add a handler to the emitter.
	   * @param {Function} [removeHandler] The optional function to remove a handler from an emitter.
	   * @param {Function} [selector] A selector which takes the arguments from the event handler to produce a single item to yield on next.
	   * @returns {Observable} An observable sequence which wraps an event from an event emitter
	   */
	  var fromEventPattern = Observable.fromEventPattern = function (addHandler, removeHandler, selector) {
	    return new AnonymousObservable(function (observer) {
	      function innerHandler (e) {
	        var result = e;
	        if (selector) {
	          try {
	            result = selector(arguments);
	          } catch (err) {
	            observer.onError(err);
	            return;
	          }
	        }
	        observer.onNext(result);
	      }

	      var returnValue = addHandler(innerHandler);
	      return disposableCreate(function () {
	        if (removeHandler) {
	          removeHandler(innerHandler, returnValue);
	        }
	      });
	    }).publish().refCount();
	  };

	  /**
	   * Invokes the asynchronous function, surfacing the result through an observable sequence.
	   * @param {Function} functionAsync Asynchronous function which returns a Promise to run.
	   * @returns {Observable} An observable sequence exposing the function's result value, or an exception.
	   */
	  Observable.startAsync = function (functionAsync) {
	    var promise;
	    try {
	      promise = functionAsync();
	    } catch (e) {
	      return observableThrow(e);
	    }
	    return observableFromPromise(promise);
	  }

	  var PausableObservable = (function (_super) {

	    inherits(PausableObservable, _super);

	    function subscribe(observer) {
	      var conn = this.source.publish(),
	        subscription = conn.subscribe(observer),
	        connection = disposableEmpty;

	      var pausable = this.pauser.distinctUntilChanged().subscribe(function (b) {
	        if (b) {
	          connection = conn.connect();
	        } else {
	          connection.dispose();
	          connection = disposableEmpty;
	        }
	      });

	      return new CompositeDisposable(subscription, connection, pausable);
	    }

	    function PausableObservable(source, pauser) {
	      this.source = source;
	      this.controller = new Subject();

	      if (pauser && pauser.subscribe) {
	        this.pauser = this.controller.merge(pauser);
	      } else {
	        this.pauser = this.controller;
	      }

	      _super.call(this, subscribe);
	    }

	    PausableObservable.prototype.pause = function () {
	      this.controller.onNext(false);
	    };

	    PausableObservable.prototype.resume = function () {
	      this.controller.onNext(true);
	    };

	    return PausableObservable;

	  }(Observable));

	  /**
	   * Pauses the underlying observable sequence based upon the observable sequence which yields true/false.
	   * @example
	   * var pauser = new Rx.Subject();
	   * var source = Rx.Observable.interval(100).pausable(pauser);
	   * @param {Observable} pauser The observable sequence used to pause the underlying sequence.
	   * @returns {Observable} The observable sequence which is paused based upon the pauser.
	   */
	  observableProto.pausable = function (pauser) {
	    return new PausableObservable(this, pauser);
	  };

	  function combineLatestSource(source, subject, resultSelector) {
	    return new AnonymousObservable(function (observer) {
	      var n = 2,
	        hasValue = [false, false],
	        hasValueAll = false,
	        isDone = false,
	        values = new Array(n);

	      function next(x, i) {
	        values[i] = x
	        var res;
	        hasValue[i] = true;
	        if (hasValueAll || (hasValueAll = hasValue.every(identity))) {
	          try {
	            res = resultSelector.apply(null, values);
	          } catch (ex) {
	            observer.onError(ex);
	            return;
	          }
	          observer.onNext(res);
	        } else if (isDone) {
	          observer.onCompleted();
	        }
	      }

	      return new CompositeDisposable(
	        source.subscribe(
	          function (x) {
	            next(x, 0);
	          },
	          observer.onError.bind(observer),
	          function () {
	            isDone = true;
	            observer.onCompleted();
	          }),
	        subject.subscribe(
	          function (x) {
	            next(x, 1);
	          },
	          observer.onError.bind(observer))
	        );
	    });
	  }

	  var PausableBufferedObservable = (function (_super) {

	    inherits(PausableBufferedObservable, _super);

	    function subscribe(observer) {
	      var q = [], previousShouldFire;

	      var subscription =
	        combineLatestSource(
	          this.source,
	          this.pauser.distinctUntilChanged().startWith(false),
	          function (data, shouldFire) {
	            return { data: data, shouldFire: shouldFire };
	          })
	          .subscribe(
	            function (results) {
	              if (previousShouldFire !== undefined && results.shouldFire != previousShouldFire) {
	                previousShouldFire = results.shouldFire;
	                // change in shouldFire
	                if (results.shouldFire) {
	                  while (q.length > 0) {
	                    observer.onNext(q.shift());
	                  }
	                }
	              } else {
	                previousShouldFire = results.shouldFire;
	                // new data
	                if (results.shouldFire) {
	                  observer.onNext(results.data);
	                } else {
	                  q.push(results.data);
	                }
	              }
	            },
	            function (err) {
	              // Empty buffer before sending error
	              while (q.length > 0) {
	                observer.onNext(q.shift());
	              }
	              observer.onError(err);
	            },
	            function () {
	              // Empty buffer before sending completion
	              while (q.length > 0) {
	                observer.onNext(q.shift());
	              }
	              observer.onCompleted();
	            }
	          );
	      return subscription;
	    }

	    function PausableBufferedObservable(source, pauser) {
	      this.source = source;
	      this.controller = new Subject();

	      if (pauser && pauser.subscribe) {
	        this.pauser = this.controller.merge(pauser);
	      } else {
	        this.pauser = this.controller;
	      }

	      _super.call(this, subscribe);
	    }

	    PausableBufferedObservable.prototype.pause = function () {
	      this.controller.onNext(false);
	    };

	    PausableBufferedObservable.prototype.resume = function () {
	      this.controller.onNext(true);
	    };

	    return PausableBufferedObservable;

	  }(Observable));

	  /**
	   * Pauses the underlying observable sequence based upon the observable sequence which yields true/false,
	   * and yields the values that were buffered while paused.
	   * @example
	   * var pauser = new Rx.Subject();
	   * var source = Rx.Observable.interval(100).pausableBuffered(pauser);
	   * @param {Observable} pauser The observable sequence used to pause the underlying sequence.
	   * @returns {Observable} The observable sequence which is paused based upon the pauser.
	   */
	  observableProto.pausableBuffered = function (subject) {
	    return new PausableBufferedObservable(this, subject);
	  };

	  /**
	   * Attaches a controller to the observable sequence with the ability to queue.
	   * @example
	   * var source = Rx.Observable.interval(100).controlled();
	   * source.request(3); // Reads 3 values
	   * @param {Observable} pauser The observable sequence used to pause the underlying sequence.
	   * @returns {Observable} The observable sequence which is paused based upon the pauser.
	   */
	  observableProto.controlled = function (enableQueue) {
	    if (enableQueue == null) {  enableQueue = true; }
	    return new ControlledObservable(this, enableQueue);
	  };

	  var ControlledObservable = (function (_super) {

	    inherits(ControlledObservable, _super);

	    function subscribe (observer) {
	      return this.source.subscribe(observer);
	    }

	    function ControlledObservable (source, enableQueue) {
	      _super.call(this, subscribe);
	      this.subject = new ControlledSubject(enableQueue);
	      this.source = source.multicast(this.subject).refCount();
	    }

	    ControlledObservable.prototype.request = function (numberOfItems) {
	      if (numberOfItems == null) { numberOfItems = -1; }
	      return this.subject.request(numberOfItems);
	    };

	    return ControlledObservable;

	  }(Observable));

	    var ControlledSubject = Rx.ControlledSubject = (function (_super) {

	        function subscribe (observer) {
	            return this.subject.subscribe(observer);
	        }

	        inherits(ControlledSubject, _super);

	        function ControlledSubject(enableQueue) {
	            if (enableQueue == null) {
	                enableQueue = true;
	            }

	            _super.call(this, subscribe);
	            this.subject = new Subject();
	            this.enableQueue = enableQueue;
	            this.queue = enableQueue ? [] : null;
	            this.requestedCount = 0;
	            this.requestedDisposable = disposableEmpty;
	            this.error = null;
	            this.hasFailed = false;
	            this.hasCompleted = false;
	            this.controlledDisposable = disposableEmpty;
	        }

	        addProperties(ControlledSubject.prototype, Observer, {
	            onCompleted: function () {
	                checkDisposed.call(this);
	                this.hasCompleted = true;

	                if (!this.enableQueue || this.queue.length === 0) {
	                    this.subject.onCompleted();
	                }
	            },
	            onError: function (error) {
	                checkDisposed.call(this);
	                this.hasFailed = true;
	                this.error = error;

	                if (!this.enableQueue || this.queue.length === 0) {
	                    this.subject.onError(error);
	                }
	            },
	            onNext: function (value) {
	                checkDisposed.call(this);
	                var hasRequested = false;

	                if (this.requestedCount === 0) {
	                    if (this.enableQueue) {
	                        this.queue.push(value);
	                    }
	                } else {
	                    if (this.requestedCount !== -1) {
	                        if (this.requestedCount-- === 0) {
	                            this.disposeCurrentRequest();
	                        }
	                    }
	                    hasRequested = true;
	                }

	                if (hasRequested) {
	                    this.subject.onNext(value);
	                }
	            },
	            _processRequest: function (numberOfItems) {
	                if (this.enableQueue) {
	                    //console.log('queue length', this.queue.length);

	                    while (this.queue.length >= numberOfItems && numberOfItems > 0) {
	                        //console.log('number of items', numberOfItems);
	                        this.subject.onNext(this.queue.shift());
	                        numberOfItems--;
	                    }

	                    if (this.queue.length !== 0) {
	                        return { numberOfItems: numberOfItems, returnValue: true };
	                    } else {
	                        return { numberOfItems: numberOfItems, returnValue: false };
	                    }
	                }

	                if (this.hasFailed) {
	                    this.subject.onError(this.error);
	                    this.controlledDisposable.dispose();
	                    this.controlledDisposable = disposableEmpty;
	                } else if (this.hasCompleted) {
	                    this.subject.onCompleted();
	                    this.controlledDisposable.dispose();
	                    this.controlledDisposable = disposableEmpty;
	                }

	                return { numberOfItems: numberOfItems, returnValue: false };
	            },
	            request: function (number) {
	                checkDisposed.call(this);
	                this.disposeCurrentRequest();
	                var self = this,
	                    r = this._processRequest(number);

	                number = r.numberOfItems;
	                if (!r.returnValue) {
	                    this.requestedCount = number;
	                    this.requestedDisposable = disposableCreate(function () {
	                        self.requestedCount = 0;
	                    });

	                    return this.requestedDisposable
	                } else {
	                    return disposableEmpty;
	                }
	            },
	            disposeCurrentRequest: function () {
	                this.requestedDisposable.dispose();
	                this.requestedDisposable = disposableEmpty;
	            },

	            dispose: function () {
	                this.isDisposed = true;
	                this.error = null;
	                this.subject.dispose();
	                this.requestedDisposable.dispose();
	            }
	        });

	        return ControlledSubject;
	    }(Observable));

	  /**
	   * Multicasts the source sequence notifications through an instantiated subject into all uses of the sequence within a selector function. Each
	   * subscription to the resulting sequence causes a separate multicast invocation, exposing the sequence resulting from the selector function's
	   * invocation. For specializations with fixed subject types, see Publish, PublishLast, and Replay.
	   *
	   * @example
	   * 1 - res = source.multicast(observable);
	   * 2 - res = source.multicast(function () { return new Subject(); }, function (x) { return x; });
	   *
	   * @param {Function|Subject} subjectOrSubjectSelector
	   * Factory function to create an intermediate subject through which the source sequence's elements will be multicast to the selector function.
	   * Or:
	   * Subject to push source elements into.
	   *
	   * @param {Function} [selector] Optional selector function which can use the multicasted source sequence subject to the policies enforced by the created subject. Specified only if <paramref name="subjectOrSubjectSelector" is a factory function.
	   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
	   */
	  observableProto.multicast = function (subjectOrSubjectSelector, selector) {
	    var source = this;
	    return typeof subjectOrSubjectSelector === 'function' ?
	      new AnonymousObservable(function (observer) {
	        var connectable = source.multicast(subjectOrSubjectSelector());
	        return new CompositeDisposable(selector(connectable).subscribe(observer), connectable.connect());
	      }) :
	      new ConnectableObservable(source, subjectOrSubjectSelector);
	  };

	  /**
	   * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence.
	   * This operator is a specialization of Multicast using a regular Subject.
	   *
	   * @example
	   * var resres = source.publish();
	   * var res = source.publish(function (x) { return x; });
	   *
	   * @param {Function} [selector] Selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive all notifications of the source from the time of the subscription on.
	   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
	   */
	  observableProto.publish = function (selector) {
	    return selector && isFunction(selector) ?
	      this.multicast(function () { return new Subject(); }, selector) :
	      this.multicast(new Subject());
	  };

	  /**
	   * Returns an observable sequence that shares a single subscription to the underlying sequence.
	   * This operator is a specialization of publish which creates a subscription when the number of observers goes from zero to one, then shares that subscription with all subsequent observers until the number of observers returns to zero, at which point the subscription is disposed.
	   *
	   * @example
	   * var res = source.share();
	   *
	   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence.
	   */
	  observableProto.share = function () {
	    return this.publish().refCount();
	  };

	  /**
	   * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence containing only the last notification.
	   * This operator is a specialization of Multicast using a AsyncSubject.
	   *
	   * @example
	   * var res = source.publishLast();
	   * var res = source.publishLast(function (x) { return x; });
	   *
	   * @param selector [Optional] Selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will only receive the last notification of the source.
	   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
	   */
	  observableProto.publishLast = function (selector) {
	    return selector && isFunction(selector) ?
	      this.multicast(function () { return new AsyncSubject(); }, selector) :
	      this.multicast(new AsyncSubject());
	  };

	  /**
	   * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence and starts with initialValue.
	   * This operator is a specialization of Multicast using a BehaviorSubject.
	   *
	   * @example
	   * var res = source.publishValue(42);
	   * var res = source.publishValue(function (x) { return x.select(function (y) { return y * y; }) }, 42);
	   *
	   * @param {Function} [selector] Optional selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive immediately receive the initial value, followed by all notifications of the source from the time of the subscription on.
	   * @param {Mixed} initialValue Initial value received by observers upon subscription.
	   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
	   */
	  observableProto.publishValue = function (initialValueOrSelector, initialValue) {
	    return arguments.length === 2 ?
	      this.multicast(function () {
	        return new BehaviorSubject(initialValue);
	      }, initialValueOrSelector) :
	      this.multicast(new BehaviorSubject(initialValueOrSelector));
	  };

	  /**
	   * Returns an observable sequence that shares a single subscription to the underlying sequence and starts with an initialValue.
	   * This operator is a specialization of publishValue which creates a subscription when the number of observers goes from zero to one, then shares that subscription with all subsequent observers until the number of observers returns to zero, at which point the subscription is disposed.
	   *
	   * @example
	   * var res = source.shareValue(42);
	   *
	   * @param {Mixed} initialValue Initial value received by observers upon subscription.
	   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence.
	   */
	  observableProto.shareValue = function (initialValue) {
	    return this.publishValue(initialValue).refCount();
	  };

	  /**
	   * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence replaying notifications subject to a maximum time length for the replay buffer.
	   * This operator is a specialization of Multicast using a ReplaySubject.
	   *
	   * @example
	   * var res = source.replay(null, 3);
	   * var res = source.replay(null, 3, 500);
	   * var res = source.replay(null, 3, 500, scheduler);
	   * var res = source.replay(function (x) { return x.take(6).repeat(); }, 3, 500, scheduler);
	   *
	   * @param selector [Optional] Selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive all the notifications of the source subject to the specified replay buffer trimming policy.
	   * @param bufferSize [Optional] Maximum element count of the replay buffer.
	   * @param window [Optional] Maximum time length of the replay buffer.
	   * @param scheduler [Optional] Scheduler where connected observers within the selector function will be invoked on.
	   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
	   */
	  observableProto.replay = function (selector, bufferSize, window, scheduler) {
	    return selector && isFunction(selector) ?
	      this.multicast(function () { return new ReplaySubject(bufferSize, window, scheduler); }, selector) :
	      this.multicast(new ReplaySubject(bufferSize, window, scheduler));
	  };

	  /**
	   * Returns an observable sequence that shares a single subscription to the underlying sequence replaying notifications subject to a maximum time length for the replay buffer.
	   * This operator is a specialization of replay which creates a subscription when the number of observers goes from zero to one, then shares that subscription with all subsequent observers until the number of observers returns to zero, at which point the subscription is disposed.
	   *
	   * @example
	   * var res = source.shareReplay(3);
	   * var res = source.shareReplay(3, 500);
	   * var res = source.shareReplay(3, 500, scheduler);
	   *

	   * @param bufferSize [Optional] Maximum element count of the replay buffer.
	   * @param window [Optional] Maximum time length of the replay buffer.
	   * @param scheduler [Optional] Scheduler where connected observers within the selector function will be invoked on.
	   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence.
	   */
	  observableProto.shareReplay = function (bufferSize, window, scheduler) {
	    return this.replay(null, bufferSize, window, scheduler).refCount();
	  };

	    /** @private */
	    var InnerSubscription = function (subject, observer) {
	        this.subject = subject;
	        this.observer = observer;
	    };

	    /**
	     * @private
	     * @memberOf InnerSubscription
	     */
	    InnerSubscription.prototype.dispose = function () {
	        if (!this.subject.isDisposed && this.observer !== null) {
	            var idx = this.subject.observers.indexOf(this.observer);
	            this.subject.observers.splice(idx, 1);
	            this.observer = null;
	        }
	    };

	  /**
	   *  Represents a value that changes over time.
	   *  Observers can subscribe to the subject to receive the last (or initial) value and all subsequent notifications.
	   */
	  var BehaviorSubject = Rx.BehaviorSubject = (function (__super__) {
	    function subscribe(observer) {
	      checkDisposed.call(this);
	      if (!this.isStopped) {
	        this.observers.push(observer);
	        observer.onNext(this.value);
	        return new InnerSubscription(this, observer);
	      }
	      var ex = this.exception;
	      if (ex) {
	        observer.onError(ex);
	      } else {
	        observer.onCompleted();
	      }
	      return disposableEmpty;
	    }

	    inherits(BehaviorSubject, __super__);

	    /**
	     * @constructor
	     *  Initializes a new instance of the BehaviorSubject class which creates a subject that caches its last value and starts with the specified value.
	     *  @param {Mixed} value Initial value sent to observers when no other value has been received by the subject yet.
	     */
	    function BehaviorSubject(value) {
	      __super__.call(this, subscribe);
	      this.value = value,
	      this.observers = [],
	      this.isDisposed = false,
	      this.isStopped = false,
	      this.exception = null;
	    }

	    addProperties(BehaviorSubject.prototype, Observer, {
	      /**
	       * Indicates whether the subject has observers subscribed to it.
	       * @returns {Boolean} Indicates whether the subject has observers subscribed to it.
	       */
	      hasObservers: function () {
	        return this.observers.length > 0;
	      },
	      /**
	       * Notifies all subscribed observers about the end of the sequence.
	       */
	      onCompleted: function () {
	        checkDisposed.call(this);
	        if (this.isStopped) { return; }
	        this.isStopped = true;
	        for (var i = 0, os = this.observers.slice(0), len = os.length; i < len; i++) {
	          os[i].onCompleted();
	        }

	        this.observers = [];
	      },
	      /**
	       * Notifies all subscribed observers about the exception.
	       * @param {Mixed} error The exception to send to all observers.
	       */
	      onError: function (error) {
	        checkDisposed.call(this);
	        if (this.isStopped) { return; }
	        this.isStopped = true;
	        this.exception = error;

	        for (var i = 0, os = this.observers.slice(0), len = os.length; i < len; i++) {
	          os[i].onError(error);
	        }

	        this.observers = [];
	      },
	      /**
	       * Notifies all subscribed observers about the arrival of the specified element in the sequence.
	       * @param {Mixed} value The value to send to all observers.
	       */
	      onNext: function (value) {
	        checkDisposed.call(this);
	        if (this.isStopped) { return; }
	        this.value = value;
	        for (var i = 0, os = this.observers.slice(0), len = os.length; i < len; i++) {
	          os[i].onNext(value);
	        }
	      },
	      /**
	       * Unsubscribe all observers and release resources.
	       */
	      dispose: function () {
	        this.isDisposed = true;
	        this.observers = null;
	        this.value = null;
	        this.exception = null;
	      }
	    });

	    return BehaviorSubject;
	  }(Observable));

	  /**
	   * Represents an object that is both an observable sequence as well as an observer.
	   * Each notification is broadcasted to all subscribed and future observers, subject to buffer trimming policies.
	   */
	  var ReplaySubject = Rx.ReplaySubject = (function (__super__) {

	    function createRemovableDisposable(subject, observer) {
	      return disposableCreate(function () {
	        observer.dispose();
	        !subject.isDisposed && subject.observers.splice(subject.observers.indexOf(observer), 1);
	      });
	    }

	    function subscribe(observer) {
	      var so = new ScheduledObserver(this.scheduler, observer),
	        subscription = createRemovableDisposable(this, so);
	      checkDisposed.call(this);
	      this._trim(this.scheduler.now());
	      this.observers.push(so);

	      var n = this.q.length;

	      for (var i = 0, len = this.q.length; i < len; i++) {
	        so.onNext(this.q[i].value);
	      }

	      if (this.hasError) {
	        n++;
	        so.onError(this.error);
	      } else if (this.isStopped) {
	        n++;
	        so.onCompleted();
	      }

	      so.ensureActive(n);
	      return subscription;
	    }

	    inherits(ReplaySubject, __super__);

	    /**
	     *  Initializes a new instance of the ReplaySubject class with the specified buffer size, window size and scheduler.
	     *  @param {Number} [bufferSize] Maximum element count of the replay buffer.
	     *  @param {Number} [windowSize] Maximum time length of the replay buffer.
	     *  @param {Scheduler} [scheduler] Scheduler the observers are invoked on.
	     */
	    function ReplaySubject(bufferSize, windowSize, scheduler) {
	      this.bufferSize = bufferSize == null ? Number.MAX_VALUE : bufferSize;
	      this.windowSize = windowSize == null ? Number.MAX_VALUE : windowSize;
	      this.scheduler = scheduler || currentThreadScheduler;
	      this.q = [];
	      this.observers = [];
	      this.isStopped = false;
	      this.isDisposed = false;
	      this.hasError = false;
	      this.error = null;
	      __super__.call(this, subscribe);
	    }

	    addProperties(ReplaySubject.prototype, Observer, {
	      /**
	       * Indicates whether the subject has observers subscribed to it.
	       * @returns {Boolean} Indicates whether the subject has observers subscribed to it.
	       */
	      hasObservers: function () {
	        return this.observers.length > 0;
	      },
	      _trim: function (now) {
	        while (this.q.length > this.bufferSize) {
	          this.q.shift();
	        }
	        while (this.q.length > 0 && (now - this.q[0].interval) > this.windowSize) {
	          this.q.shift();
	        }
	      },
	      /**
	       * Notifies all subscribed observers about the arrival of the specified element in the sequence.
	       * @param {Mixed} value The value to send to all observers.
	       */
	      onNext: function (value) {
	        checkDisposed.call(this);
	        if (this.isStopped) { return; }
	        var now = this.scheduler.now();
	        this.q.push({ interval: now, value: value });
	        this._trim(now);

	        var o = this.observers.slice(0);
	        for (var i = 0, len = o.length; i < len; i++) {
	          var observer = o[i];
	          observer.onNext(value);
	          observer.ensureActive();
	        }
	      },
	      /**
	       * Notifies all subscribed observers about the exception.
	       * @param {Mixed} error The exception to send to all observers.
	       */
	      onError: function (error) {
	        checkDisposed.call(this);
	        if (this.isStopped) { return; }
	        this.isStopped = true;
	        this.error = error;
	        this.hasError = true;
	        var now = this.scheduler.now();
	        this._trim(now);
	        var o = this.observers.slice(0);
	        for (var i = 0, len = o.length; i < len; i++) {
	          var observer = o[i];
	          observer.onError(error);
	          observer.ensureActive();
	        }
	        this.observers = [];
	      },
	      /**
	       * Notifies all subscribed observers about the end of the sequence.
	       */
	      onCompleted: function () {
	        checkDisposed.call(this);
	        if (this.isStopped) { return; }
	        this.isStopped = true;
	        var now = this.scheduler.now();
	        this._trim(now);
	        var o = this.observers.slice(0);
	        for (var i = 0, len = o.length; i < len; i++) {
	          var observer = o[i];
	          observer.onCompleted();
	          observer.ensureActive();
	        }
	        this.observers = [];
	      },
	      /**
	       * Unsubscribe all observers and release resources.
	       */
	      dispose: function () {
	        this.isDisposed = true;
	        this.observers = null;
	      }
	    });

	    return ReplaySubject;
	  }(Observable));

	  var ConnectableObservable = Rx.ConnectableObservable = (function (__super__) {
	    inherits(ConnectableObservable, __super__);

	    function ConnectableObservable(source, subject) {
	      var hasSubscription = false,
	        subscription,
	        sourceObservable = source.asObservable();

	      this.connect = function () {
	        if (!hasSubscription) {
	          hasSubscription = true;
	          subscription = new CompositeDisposable(sourceObservable.subscribe(subject), disposableCreate(function () {
	            hasSubscription = false;
	          }));
	        }
	        return subscription;
	      };

	      __super__.call(this, subject.subscribe.bind(subject));
	    }

	    ConnectableObservable.prototype.refCount = function () {
	      var connectableSubscription, count = 0, source = this;
	      return new AnonymousObservable(function (observer) {
	          var shouldConnect = ++count === 1,
	            subscription = source.subscribe(observer);
	          shouldConnect && (connectableSubscription = source.connect());
	          return function () {
	            subscription.dispose();
	            --count === 0 && connectableSubscription.dispose();
	          };
	      });
	    };

	    return ConnectableObservable;
	  }(Observable));

	  var Dictionary = (function () {

	    var primes = [1, 3, 7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381, 32749, 65521, 131071, 262139, 524287, 1048573, 2097143, 4194301, 8388593, 16777213, 33554393, 67108859, 134217689, 268435399, 536870909, 1073741789, 2147483647],
	      noSuchkey = "no such key",
	      duplicatekey = "duplicate key";

	    function isPrime(candidate) {
	      if (candidate & 1 === 0) { return candidate === 2; }
	      var num1 = Math.sqrt(candidate),
	        num2 = 3;
	      while (num2 <= num1) {
	        if (candidate % num2 === 0) { return false; }
	        num2 += 2;
	      }
	      return true;
	    }

	    function getPrime(min) {
	      var index, num, candidate;
	      for (index = 0; index < primes.length; ++index) {
	        num = primes[index];
	        if (num >= min) { return num; }
	      }
	      candidate = min | 1;
	      while (candidate < primes[primes.length - 1]) {
	        if (isPrime(candidate)) { return candidate; }
	        candidate += 2;
	      }
	      return min;
	    }

	    function stringHashFn(str) {
	      var hash = 757602046;
	      if (!str.length) { return hash; }
	      for (var i = 0, len = str.length; i < len; i++) {
	        var character = str.charCodeAt(i);
	        hash = ((hash<<5)-hash)+character;
	        hash = hash & hash;
	      }
	      return hash;
	    }

	    function numberHashFn(key) {
	      var c2 = 0x27d4eb2d;
	      key = (key ^ 61) ^ (key >>> 16);
	      key = key + (key << 3);
	      key = key ^ (key >>> 4);
	      key = key * c2;
	      key = key ^ (key >>> 15);
	      return key;
	    }

	    var getHashCode = (function () {
	      var uniqueIdCounter = 0;

	      return function (obj) {
	        if (obj == null) { throw new Error(noSuchkey); }

	        // Check for built-ins before tacking on our own for any object
	        if (typeof obj === 'string') { return stringHashFn(obj); }
	        if (typeof obj === 'number') { return numberHashFn(obj); }
	        if (typeof obj === 'boolean') { return obj === true ? 1 : 0; }
	        if (obj instanceof Date) { return numberHashFn(obj.valueOf()); }
	        if (obj instanceof RegExp) { return stringHashFn(obj.toString()); }
	        if (typeof obj.valueOf === 'function') {
	          // Hack check for valueOf
	          var valueOf = obj.valueOf();
	          if (typeof valueOf === 'number') { return numberHashFn(valueOf); }
	          if (typeof obj === 'string') { return stringHashFn(valueOf); }
	        }
	        if (obj.getHashCode) { return obj.getHashCode(); }

	        var id = 17 * uniqueIdCounter++;
	        obj.getHashCode = function () { return id; };
	        return id;
	      };
	    }());

	    function newEntry() {
	      return { key: null, value: null, next: 0, hashCode: 0 };
	    }

	    function Dictionary(capacity, comparer) {
	      if (capacity < 0) { throw new Error('out of range'); }
	      if (capacity > 0) { this._initialize(capacity); }

	      this.comparer = comparer || defaultComparer;
	      this.freeCount = 0;
	      this.size = 0;
	      this.freeList = -1;
	    }

	    var dictionaryProto = Dictionary.prototype;

	    dictionaryProto._initialize = function (capacity) {
	      var prime = getPrime(capacity), i;
	      this.buckets = new Array(prime);
	      this.entries = new Array(prime);
	      for (i = 0; i < prime; i++) {
	        this.buckets[i] = -1;
	        this.entries[i] = newEntry();
	      }
	      this.freeList = -1;
	    };

	    dictionaryProto.add = function (key, value) {
	      return this._insert(key, value, true);
	    };

	    dictionaryProto._insert = function (key, value, add) {
	      if (!this.buckets) { this._initialize(0); }
	      var index3,
	        num = getHashCode(key) & 2147483647,
	        index1 = num % this.buckets.length;
	      for (var index2 = this.buckets[index1]; index2 >= 0; index2 = this.entries[index2].next) {
	        if (this.entries[index2].hashCode === num && this.comparer(this.entries[index2].key, key)) {
	          if (add) { throw new Error(duplicatekey); }
	          this.entries[index2].value = value;
	          return;
	        }
	      }
	      if (this.freeCount > 0) {
	        index3 = this.freeList;
	        this.freeList = this.entries[index3].next;
	        --this.freeCount;
	      } else {
	        if (this.size === this.entries.length) {
	          this._resize();
	          index1 = num % this.buckets.length;
	        }
	        index3 = this.size;
	        ++this.size;
	      }
	      this.entries[index3].hashCode = num;
	      this.entries[index3].next = this.buckets[index1];
	      this.entries[index3].key = key;
	      this.entries[index3].value = value;
	      this.buckets[index1] = index3;
	    };

	    dictionaryProto._resize = function () {
	      var prime = getPrime(this.size * 2),
	        numArray = new Array(prime);
	      for (index = 0; index < numArray.length; ++index) {  numArray[index] = -1; }
	      var entryArray = new Array(prime);
	      for (index = 0; index < this.size; ++index) { entryArray[index] = this.entries[index]; }
	      for (var index = this.size; index < prime; ++index) { entryArray[index] = newEntry(); }
	      for (var index1 = 0; index1 < this.size; ++index1) {
	        var index2 = entryArray[index1].hashCode % prime;
	        entryArray[index1].next = numArray[index2];
	        numArray[index2] = index1;
	      }
	      this.buckets = numArray;
	      this.entries = entryArray;
	    };

	    dictionaryProto.remove = function (key) {
	      if (this.buckets) {
	        var num = getHashCode(key) & 2147483647,
	          index1 = num % this.buckets.length,
	          index2 = -1;
	        for (var index3 = this.buckets[index1]; index3 >= 0; index3 = this.entries[index3].next) {
	          if (this.entries[index3].hashCode === num && this.comparer(this.entries[index3].key, key)) {
	            if (index2 < 0) {
	              this.buckets[index1] = this.entries[index3].next;
	            } else {
	              this.entries[index2].next = this.entries[index3].next;
	            }
	            this.entries[index3].hashCode = -1;
	            this.entries[index3].next = this.freeList;
	            this.entries[index3].key = null;
	            this.entries[index3].value = null;
	            this.freeList = index3;
	            ++this.freeCount;
	            return true;
	          } else {
	            index2 = index3;
	          }
	        }
	      }
	      return false;
	    };

	    dictionaryProto.clear = function () {
	      var index, len;
	      if (this.size <= 0) { return; }
	      for (index = 0, len = this.buckets.length; index < len; ++index) {
	        this.buckets[index] = -1;
	      }
	      for (index = 0; index < this.size; ++index) {
	        this.entries[index] = newEntry();
	      }
	      this.freeList = -1;
	      this.size = 0;
	    };

	    dictionaryProto._findEntry = function (key) {
	      if (this.buckets) {
	        var num = getHashCode(key) & 2147483647;
	        for (var index = this.buckets[num % this.buckets.length]; index >= 0; index = this.entries[index].next) {
	          if (this.entries[index].hashCode === num && this.comparer(this.entries[index].key, key)) {
	            return index;
	          }
	        }
	      }
	      return -1;
	    };

	    dictionaryProto.count = function () {
	      return this.size - this.freeCount;
	    };

	    dictionaryProto.tryGetValue = function (key) {
	      var entry = this._findEntry(key);
	      return entry >= 0 ?
	        this.entries[entry].value :
	        undefined;
	    };

	    dictionaryProto.getValues = function () {
	      var index = 0, results = [];
	      if (this.entries) {
	        for (var index1 = 0; index1 < this.size; index1++) {
	          if (this.entries[index1].hashCode >= 0) {
	            results[index++] = this.entries[index1].value;
	          }
	        }
	      }
	      return results;
	    };

	    dictionaryProto.get = function (key) {
	      var entry = this._findEntry(key);
	      if (entry >= 0) { return this.entries[entry].value; }
	      throw new Error(noSuchkey);
	    };

	    dictionaryProto.set = function (key, value) {
	      this._insert(key, value, false);
	    };

	    dictionaryProto.containskey = function (key) {
	      return this._findEntry(key) >= 0;
	    };

	    return Dictionary;
	  }());

	  /**
	   *  Correlates the elements of two sequences based on overlapping durations.
	   *
	   *  @param {Observable} right The right observable sequence to join elements for.
	   *  @param {Function} leftDurationSelector A function to select the duration (expressed as an observable sequence) of each element of the left observable sequence, used to determine overlap.
	   *  @param {Function} rightDurationSelector A function to select the duration (expressed as an observable sequence) of each element of the right observable sequence, used to determine overlap.
	   *  @param {Function} resultSelector A function invoked to compute a result element for any two overlapping elements of the left and right observable sequences. The parameters passed to the function correspond with the elements from the left and right source sequences for which overlap occurs.
	   *  @returns {Observable} An observable sequence that contains result elements computed from source elements that have an overlapping duration.
	   */
	  observableProto.join = function (right, leftDurationSelector, rightDurationSelector, resultSelector) {
	    var left = this;
	    return new AnonymousObservable(function (observer) {
	      var group = new CompositeDisposable();
	      var leftDone = false, rightDone = false;
	      var leftId = 0, rightId = 0;
	      var leftMap = new Dictionary(), rightMap = new Dictionary();

	      group.add(left.subscribe(
	        function (value) {
	          var id = leftId++;
	          var md = new SingleAssignmentDisposable();

	          leftMap.add(id, value);
	          group.add(md);

	          var expire = function () {
	            leftMap.remove(id) && leftMap.count() === 0 && leftDone && observer.onCompleted();
	            group.remove(md);
	          };

	          var duration;
	          try {
	            duration = leftDurationSelector(value);
	          } catch (e) {
	            observer.onError(e);
	            return;
	          }

	          md.setDisposable(duration.take(1).subscribe(noop, observer.onError.bind(observer), expire));

	          rightMap.getValues().forEach(function (v) {
	            var result;
	            try {
	              result = resultSelector(value, v);
	            } catch (exn) {
	              observer.onError(exn);
	              return;
	            }

	            observer.onNext(result);
	          });
	        },
	        observer.onError.bind(observer),
	        function () {
	          leftDone = true;
	          (rightDone || leftMap.count() === 0) && observer.onCompleted();
	        })
	      );

	      group.add(right.subscribe(
	        function (value) {
	          var id = rightId++;
	          var md = new SingleAssignmentDisposable();

	          rightMap.add(id, value);
	          group.add(md);

	          var expire = function () {
	            rightMap.remove(id) && rightMap.count() === 0 && rightDone && observer.onCompleted();
	            group.remove(md);
	          };

	          var duration;
	          try {
	            duration = rightDurationSelector(value);
	          } catch (e) {
	            observer.onError(e);
	            return;
	          }

	          md.setDisposable(duration.take(1).subscribe(noop, observer.onError.bind(observer), expire));

	          leftMap.getValues().forEach(function (v) {
	            var result;
	            try {
	              result = resultSelector(v, value);
	            } catch(exn) {
	              observer.onError(exn);
	              return;
	            }

	            observer.onNext(result);
	          });
	        },
	        observer.onError.bind(observer),
	        function () {
	          rightDone = true;
	          (leftDone || rightMap.count() === 0) && observer.onCompleted();
	        })
	      );
	      return group;
	    });
	  };

	  /**
	   *  Correlates the elements of two sequences based on overlapping durations, and groups the results.
	   *
	   *  @param {Observable} right The right observable sequence to join elements for.
	   *  @param {Function} leftDurationSelector A function to select the duration (expressed as an observable sequence) of each element of the left observable sequence, used to determine overlap.
	   *  @param {Function} rightDurationSelector A function to select the duration (expressed as an observable sequence) of each element of the right observable sequence, used to determine overlap.
	   *  @param {Function} resultSelector A function invoked to compute a result element for any element of the left sequence with overlapping elements from the right observable sequence. The first parameter passed to the function is an element of the left sequence. The second parameter passed to the function is an observable sequence with elements from the right sequence that overlap with the left sequence's element.
	   *  @returns {Observable} An observable sequence that contains result elements computed from source elements that have an overlapping duration.
	   */
	  observableProto.groupJoin = function (right, leftDurationSelector, rightDurationSelector, resultSelector) {
	    var left = this;
	    return new AnonymousObservable(function (observer) {
	      var group = new CompositeDisposable();
	      var r = new RefCountDisposable(group);
	      var leftMap = new Dictionary(), rightMap = new Dictionary();
	      var leftId = 0, rightId = 0;

	      function handleError(e) { return function (v) { v.onError(e); }; };

	      group.add(left.subscribe(
	        function (value) {
	          var s = new Subject();
	          var id = leftId++;
	          leftMap.add(id, s);

	          var result;
	          try {
	            result = resultSelector(value, addRef(s, r));
	          } catch (e) {
	            leftMap.getValues().forEach(handleError(e));
	            observer.onError(e);
	            return;
	          }
	          observer.onNext(result);

	          rightMap.getValues().forEach(function (v) { s.onNext(v); });

	          var md = new SingleAssignmentDisposable();
	          group.add(md);

	          var expire = function () {
	            leftMap.remove(id) && s.onCompleted();
	            group.remove(md);
	          };

	          var duration;
	          try {
	            duration = leftDurationSelector(value);
	          } catch (e) {
	            leftMap.getValues().forEach(handleError(e));
	            observer.onError(e);
	            return;
	          }

	          md.setDisposable(duration.take(1).subscribe(
	            noop,
	            function (e) {
	              leftMap.getValues().forEach(handleError(e));
	              observer.onError(e);
	            },
	            expire)
	          );
	        },
	        function (e) {
	          leftMap.getValues().forEach(handleError(e));
	          observer.onError(e);
	        },
	        observer.onCompleted.bind(observer))
	      );

	      group.add(right.subscribe(
	        function (value) {
	          var id = rightId++;
	          rightMap.add(id, value);

	          var md = new SingleAssignmentDisposable();
	          group.add(md);

	          var expire = function () {
	            rightMap.remove(id);
	            group.remove(md);
	          };

	          var duration;
	          try {
	            duration = rightDurationSelector(value);
	          } catch (e) {
	            leftMap.getValues().forEach(handleError(e));
	            observer.onError(e);
	            return;
	          }
	          md.setDisposable(duration.take(1).subscribe(
	            noop,
	            function (e) {
	              leftMap.getValues().forEach(handleError(e));
	              observer.onError(e);
	            },
	            expire)
	          );

	          leftMap.getValues().forEach(function (v) { v.onNext(value); });
	        },
	        function (e) {
	          leftMap.getValues().forEach(handleError(e));
	          observer.onError(e);
	        })
	      );

	      return r;
	    });
	  };

	    /**
	     *  Projects each element of an observable sequence into zero or more buffers.
	     *
	     *  @param {Mixed} bufferOpeningsOrClosingSelector Observable sequence whose elements denote the creation of new windows, or, a function invoked to define the boundaries of the produced windows (a new window is started when the previous one is closed, resulting in non-overlapping windows).
	     *  @param {Function} [bufferClosingSelector] A function invoked to define the closing of each produced window. If a closing selector function is specified for the first parameter, this parameter is ignored.
	     *  @returns {Observable} An observable sequence of windows.
	     */
	    observableProto.buffer = function (bufferOpeningsOrClosingSelector, bufferClosingSelector) {
	        return this.window.apply(this, arguments).selectMany(function (x) { return x.toArray(); });
	    };

	  /**
	   *  Projects each element of an observable sequence into zero or more windows.
	   *
	   *  @param {Mixed} windowOpeningsOrClosingSelector Observable sequence whose elements denote the creation of new windows, or, a function invoked to define the boundaries of the produced windows (a new window is started when the previous one is closed, resulting in non-overlapping windows).
	   *  @param {Function} [windowClosingSelector] A function invoked to define the closing of each produced window. If a closing selector function is specified for the first parameter, this parameter is ignored.
	   *  @returns {Observable} An observable sequence of windows.
	   */
	  observableProto.window = function (windowOpeningsOrClosingSelector, windowClosingSelector) {
	    if (arguments.length === 1 && typeof arguments[0] !== 'function') {
	      return observableWindowWithBounaries.call(this, windowOpeningsOrClosingSelector);
	    }
	    return typeof windowOpeningsOrClosingSelector === 'function' ?
	      observableWindowWithClosingSelector.call(this, windowOpeningsOrClosingSelector) :
	      observableWindowWithOpenings.call(this, windowOpeningsOrClosingSelector, windowClosingSelector);
	  };

	  function observableWindowWithOpenings(windowOpenings, windowClosingSelector) {
	    return windowOpenings.groupJoin(this, windowClosingSelector, observableEmpty, function (_, win) {
	      return win;
	    });
	  }

	  function observableWindowWithBounaries(windowBoundaries) {
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      var win = new Subject(),
	        d = new CompositeDisposable(),
	        r = new RefCountDisposable(d);

	      observer.onNext(addRef(win, r));

	      d.add(source.subscribe(function (x) {
	        win.onNext(x);
	      }, function (err) {
	        win.onError(err);
	        observer.onError(err);
	      }, function () {
	        win.onCompleted();
	        observer.onCompleted();
	      }));

	      isPromise(windowBoundaries) && (windowBoundaries = observableFromPromise(windowBoundaries));

	      d.add(windowBoundaries.subscribe(function (w) {
	        win.onCompleted();
	        win = new Subject();
	        observer.onNext(addRef(win, r));
	      }, function (err) {
	        win.onError(err);
	        observer.onError(err);
	      }, function () {
	        win.onCompleted();
	        observer.onCompleted();
	      }));

	      return r;
	    });
	  }

	  function observableWindowWithClosingSelector(windowClosingSelector) {
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      var m = new SerialDisposable(),
	        d = new CompositeDisposable(m),
	        r = new RefCountDisposable(d),
	        win = new Subject();
	      observer.onNext(addRef(win, r));
	      d.add(source.subscribe(function (x) {
	          win.onNext(x);
	      }, function (err) {
	          win.onError(err);
	          observer.onError(err);
	      }, function () {
	          win.onCompleted();
	          observer.onCompleted();
	      }));
	      
	      function createWindowClose () {
	        var windowClose;
	        try {
	          windowClose = windowClosingSelector();
	        } catch (e) {
	          observer.onError(e);
	          return;
	        }

	        isPromise(windowClose) && (windowClose = observableFromPromise(windowClose));

	        var m1 = new SingleAssignmentDisposable();
	        m.setDisposable(m1);
	        m1.setDisposable(windowClose.take(1).subscribe(noop, function (err) {
	          win.onError(err);
	          observer.onError(err);
	        }, function () {
	          win.onCompleted();
	          win = new Subject();
	          observer.onNext(addRef(win, r));
	          createWindowClose();
	        }));
	      }

	      createWindowClose();
	      return r;
	    });
	  }

	  /**
	   * Returns a new observable that triggers on the second and subsequent triggerings of the input observable.
	   * The Nth triggering of the input observable passes the arguments from the N-1th and Nth triggering as a pair.
	   * The argument passed to the N-1th triggering is held in hidden internal state until the Nth triggering occurs.
	   * @returns {Observable} An observable that triggers on successive pairs of observations from the input observable as an array.
	   */
	  observableProto.pairwise = function () {
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      var previous, hasPrevious = false;
	      return source.subscribe(
	        function (x) {
	          if (hasPrevious) {
	            observer.onNext([previous, x]);
	          } else {
	            hasPrevious = true;
	          }
	          previous = x;
	        },
	        observer.onError.bind(observer),
	        observer.onCompleted.bind(observer));
	    });
	  };

	  /**
	   * Returns two observables which partition the observations of the source by the given function.
	   * The first will trigger observations for those values for which the predicate returns true.
	   * The second will trigger observations for those values where the predicate returns false.
	   * The predicate is executed once for each subscribed observer.
	   * Both also propagate all error observations arising from the source and each completes
	   * when the source completes.
	   * @param {Function} predicate
	   *    The function to determine which output Observable will trigger a particular observation.
	   * @returns {Array}
	   *    An array of observables. The first triggers when the predicate returns true,
	   *    and the second triggers when the predicate returns false.
	  */
	  observableProto.partition = function(predicate, thisArg) {
	    var published = this.publish().refCount();
	    return [
	      published.filter(predicate, thisArg),
	      published.filter(function (x, i, o) { return !predicate.call(thisArg, x, i, o); })
	    ];
	  };

	  function enumerableWhile(condition, source) {
	    return new Enumerable(function () {
	      return new Enumerator(function () {
	        return condition() ?
	          { done: false, value: source } :
	          { done: true, value: undefined };
	      });
	    });
	  }

	     /**
	     *  Returns an observable sequence that is the result of invoking the selector on the source sequence, without sharing subscriptions.
	     *  This operator allows for a fluent style of writing queries that use the same sequence multiple times.
	     *
	     * @param {Function} selector Selector function which can use the source sequence as many times as needed, without sharing subscriptions to the source sequence.
	     * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
	     */
	    observableProto.letBind = observableProto['let'] = function (func) {
	        return func(this);
	    };

	   /**
	   *  Determines whether an observable collection contains values. There is an alias for this method called 'ifThen' for browsers <IE9
	   *
	   * @example
	   *  1 - res = Rx.Observable.if(condition, obs1);
	   *  2 - res = Rx.Observable.if(condition, obs1, obs2);
	   *  3 - res = Rx.Observable.if(condition, obs1, scheduler);
	   * @param {Function} condition The condition which determines if the thenSource or elseSource will be run.
	   * @param {Observable} thenSource The observable sequence or Promise that will be run if the condition function returns true.
	   * @param {Observable} [elseSource] The observable sequence or Promise that will be run if the condition function returns false. If this is not provided, it defaults to Rx.Observabe.Empty with the specified scheduler.
	   * @returns {Observable} An observable sequence which is either the thenSource or elseSource.
	   */
	  Observable['if'] = Observable.ifThen = function (condition, thenSource, elseSourceOrScheduler) {
	    return observableDefer(function () {
	      elseSourceOrScheduler || (elseSourceOrScheduler = observableEmpty());

	      isPromise(thenSource) && (thenSource = observableFromPromise(thenSource));
	      isPromise(elseSourceOrScheduler) && (elseSourceOrScheduler = observableFromPromise(elseSourceOrScheduler));

	      // Assume a scheduler for empty only
	      typeof elseSourceOrScheduler.now === 'function' && (elseSourceOrScheduler = observableEmpty(elseSourceOrScheduler));
	      return condition() ? thenSource : elseSourceOrScheduler;
	    });
	  };

	   /**
	   *  Concatenates the observable sequences obtained by running the specified result selector for each element in source.
	   * There is an alias for this method called 'forIn' for browsers <IE9
	   * @param {Array} sources An array of values to turn into an observable sequence.
	   * @param {Function} resultSelector A function to apply to each item in the sources array to turn it into an observable sequence.
	   * @returns {Observable} An observable sequence from the concatenated observable sequences.
	   */
	  Observable['for'] = Observable.forIn = function (sources, resultSelector, thisArg) {
	    return enumerableOf(sources, resultSelector, thisArg).concat();
	  };

	   /**
	   *  Repeats source as long as condition holds emulating a while loop.
	   * There is an alias for this method called 'whileDo' for browsers <IE9
	   *
	   * @param {Function} condition The condition which determines if the source will be repeated.
	   * @param {Observable} source The observable sequence that will be run if the condition function returns true.
	   * @returns {Observable} An observable sequence which is repeated as long as the condition holds.
	   */
	  var observableWhileDo = Observable['while'] = Observable.whileDo = function (condition, source) {
	    isPromise(source) && (source = observableFromPromise(source));
	    return enumerableWhile(condition, source).concat();
	  };

	     /**
	     *  Repeats source as long as condition holds emulating a do while loop.
	     *
	     * @param {Function} condition The condition which determines if the source will be repeated.
	     * @param {Observable} source The observable sequence that will be run if the condition function returns true.
	     * @returns {Observable} An observable sequence which is repeated as long as the condition holds.
	     */
	    observableProto.doWhile = function (condition) {
	        return observableConcat([this, observableWhileDo(condition, this)]);
	    };

	   /**
	   *  Uses selector to determine which source in sources to use.
	   *  There is an alias 'switchCase' for browsers <IE9.
	   *
	   * @example
	   *  1 - res = Rx.Observable.case(selector, { '1': obs1, '2': obs2 });
	   *  1 - res = Rx.Observable.case(selector, { '1': obs1, '2': obs2 }, obs0);
	   *  1 - res = Rx.Observable.case(selector, { '1': obs1, '2': obs2 }, scheduler);
	   *
	   * @param {Function} selector The function which extracts the value for to test in a case statement.
	   * @param {Array} sources A object which has keys which correspond to the case statement labels.
	   * @param {Observable} [elseSource] The observable sequence or Promise that will be run if the sources are not matched. If this is not provided, it defaults to Rx.Observabe.empty with the specified scheduler.
	   *
	   * @returns {Observable} An observable sequence which is determined by a case statement.
	   */
	  Observable['case'] = Observable.switchCase = function (selector, sources, defaultSourceOrScheduler) {
	    return observableDefer(function () {
	      isPromise(defaultSourceOrScheduler) && (defaultSourceOrScheduler = observableFromPromise(defaultSourceOrScheduler));
	      defaultSourceOrScheduler || (defaultSourceOrScheduler = observableEmpty());

	      typeof defaultSourceOrScheduler.now === 'function' && (defaultSourceOrScheduler = observableEmpty(defaultSourceOrScheduler));

	      var result = sources[selector()];
	      isPromise(result) && (result = observableFromPromise(result));

	      return result || defaultSourceOrScheduler;
	    });
	  };

	   /**
	   *  Expands an observable sequence by recursively invoking selector.
	   *
	   * @param {Function} selector Selector function to invoke for each produced element, resulting in another sequence to which the selector will be invoked recursively again.
	   * @param {Scheduler} [scheduler] Scheduler on which to perform the expansion. If not provided, this defaults to the current thread scheduler.
	   * @returns {Observable} An observable sequence containing all the elements produced by the recursive expansion.
	   */
	  observableProto.expand = function (selector, scheduler) {
	    isScheduler(scheduler) || (scheduler = immediateScheduler);
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      var q = [],
	        m = new SerialDisposable(),
	        d = new CompositeDisposable(m),
	        activeCount = 0,
	        isAcquired = false;

	      var ensureActive = function () {
	        var isOwner = false;
	        if (q.length > 0) {
	            isOwner = !isAcquired;
	            isAcquired = true;
	        }
	        if (isOwner) {
	          m.setDisposable(scheduler.scheduleRecursive(function (self) {
	            var work;
	            if (q.length > 0) {
	              work = q.shift();
	            } else {
	              isAcquired = false;
	              return;
	            }
	            var m1 = new SingleAssignmentDisposable();
	            d.add(m1);
	            m1.setDisposable(work.subscribe(function (x) {
	              observer.onNext(x);
	              var result = null;
	              try {
	                result = selector(x);
	              } catch (e) {
	                observer.onError(e);
	              }
	              q.push(result);
	              activeCount++;
	              ensureActive();
	            }, observer.onError.bind(observer), function () {
	              d.remove(m1);
	              activeCount--;
	              if (activeCount === 0) {
	                observer.onCompleted();
	              }
	            }));
	            self();
	          }));
	        }
	      };

	      q.push(source);
	      activeCount++;
	      ensureActive();
	      return d;
	    });
	  };

	   /**
	   *  Runs all observable sequences in parallel and collect their last elements.
	   *
	   * @example
	   *  1 - res = Rx.Observable.forkJoin([obs1, obs2]);
	   *  1 - res = Rx.Observable.forkJoin(obs1, obs2, ...);
	   * @returns {Observable} An observable sequence with an array collecting the last elements of all the input sequences.
	   */
	  Observable.forkJoin = function () {
	    var allSources = argsOrArray(arguments, 0);
	    return new AnonymousObservable(function (subscriber) {
	      var count = allSources.length;
	      if (count === 0) {
	        subscriber.onCompleted();
	        return disposableEmpty;
	      }
	      var group = new CompositeDisposable(),
	        finished = false,
	        hasResults = new Array(count),
	        hasCompleted = new Array(count),
	        results = new Array(count);

	      for (var idx = 0; idx < count; idx++) {
	        (function (i) {
	          var source = allSources[i];
	          isPromise(source) && (source = observableFromPromise(source));
	          group.add(
	            source.subscribe(
	              function (value) {
	              if (!finished) {
	                hasResults[i] = true;
	                results[i] = value;
	              }
	            },
	            function (e) {
	              finished = true;
	              subscriber.onError(e);
	              group.dispose();
	            },
	            function () {
	              if (!finished) {
	                if (!hasResults[i]) {
	                    subscriber.onCompleted();
	                    return;
	                }
	                hasCompleted[i] = true;
	                for (var ix = 0; ix < count; ix++) {
	                  if (!hasCompleted[ix]) { return; }
	                }
	                finished = true;
	                subscriber.onNext(results);
	                subscriber.onCompleted();
	              }
	            }));
	        })(idx);
	      }

	      return group;
	    });
	  };

	   /**
	   *  Runs two observable sequences in parallel and combines their last elemenets.
	   *
	   * @param {Observable} second Second observable sequence.
	   * @param {Function} resultSelector Result selector function to invoke with the last elements of both sequences.
	   * @returns {Observable} An observable sequence with the result of calling the selector function with the last elements of both input sequences.
	   */
	  observableProto.forkJoin = function (second, resultSelector) {
	    var first = this;

	    return new AnonymousObservable(function (observer) {
	      var leftStopped = false, rightStopped = false,
	        hasLeft = false, hasRight = false,
	        lastLeft, lastRight,
	        leftSubscription = new SingleAssignmentDisposable(), rightSubscription = new SingleAssignmentDisposable();

	      isPromise(second) && (second = observableFromPromise(second));

	      leftSubscription.setDisposable(
	          first.subscribe(function (left) {
	            hasLeft = true;
	            lastLeft = left;
	          }, function (err) {
	            rightSubscription.dispose();
	            observer.onError(err);
	          }, function () {
	            leftStopped = true;
	            if (rightStopped) {
	              if (!hasLeft) {
	                  observer.onCompleted();
	              } else if (!hasRight) {
	                  observer.onCompleted();
	              } else {
	                var result;
	                try {
	                  result = resultSelector(lastLeft, lastRight);
	                } catch (e) {
	                  observer.onError(e);
	                  return;
	                }
	                observer.onNext(result);
	                observer.onCompleted();
	              }
	            }
	          })
	      );

	      rightSubscription.setDisposable(
	        second.subscribe(function (right) {
	          hasRight = true;
	          lastRight = right;
	        }, function (err) {
	          leftSubscription.dispose();
	          observer.onError(err);
	        }, function () {
	          rightStopped = true;
	          if (leftStopped) {
	            if (!hasLeft) {
	              observer.onCompleted();
	            } else if (!hasRight) {
	              observer.onCompleted();
	            } else {
	              var result;
	              try {
	                result = resultSelector(lastLeft, lastRight);
	              } catch (e) {
	                observer.onError(e);
	                return;
	              }
	              observer.onNext(result);
	              observer.onCompleted();
	            }
	          }
	        })
	      );

	      return new CompositeDisposable(leftSubscription, rightSubscription);
	    });
	  };

	  /**
	   * Comonadic bind operator.
	   * @param {Function} selector A transform function to apply to each element.
	   * @param {Object} scheduler Scheduler used to execute the operation. If not specified, defaults to the ImmediateScheduler.
	   * @returns {Observable} An observable sequence which results from the comonadic bind operation.
	   */
	  observableProto.manySelect = function (selector, scheduler) {
	    isScheduler(scheduler) || (scheduler = immediateScheduler);
	    var source = this;
	    return observableDefer(function () {
	      var chain;

	      return source
	        .map(function (x) {
	          var curr = new ChainObservable(x);

	          chain && chain.onNext(x);
	          chain = curr;

	          return curr;
	        })
	        .tap(
	          noop,
	          function (e) { chain && chain.onError(e); },
	          function () { chain && chain.onCompleted(); }
	        )
	        .observeOn(scheduler)
	        .map(selector);
	    });
	  };

	  var ChainObservable = (function (__super__) {

	    function subscribe (observer) {
	      var self = this, g = new CompositeDisposable();
	      g.add(currentThreadScheduler.schedule(function () {
	        observer.onNext(self.head);
	        g.add(self.tail.mergeObservable().subscribe(observer));
	      }));

	      return g;
	    }

	    inherits(ChainObservable, __super__);

	    function ChainObservable(head) {
	      __super__.call(this, subscribe);
	      this.head = head;
	      this.tail = new AsyncSubject();
	    }

	    addProperties(ChainObservable.prototype, Observer, {
	      onCompleted: function () {
	        this.onNext(Observable.empty());
	      },
	      onError: function (e) {
	        this.onNext(Observable.throwException(e));
	      },
	      onNext: function (v) {
	        this.tail.onNext(v);
	        this.tail.onCompleted();
	      }
	    });

	    return ChainObservable;

	  }(Observable));

	  /** @private */
	  var Map = root.Map || (function () {

	    function Map() {
	      this._keys = [];
	      this._values = [];
	    }

	    Map.prototype.get = function (key) {
	      var i = this._keys.indexOf(key);
	      return i !== -1 ? this._values[i] : undefined;
	    };

	    Map.prototype.set = function (key, value) {
	      var i = this._keys.indexOf(key);
	      i !== -1 && (this._values[i] = value);
	      this._values[this._keys.push(key) - 1] = value;
	    };

	    Map.prototype.forEach = function (callback, thisArg) {
	      for (var i = 0, len = this._keys.length; i < len; i++) {
	        callback.call(thisArg, this._values[i], this._keys[i]);
	      }
	    };

	    return Map;
	  }());

	  /**
	   * @constructor
	   * Represents a join pattern over observable sequences.
	   */
	  function Pattern(patterns) {
	    this.patterns = patterns;
	  }

	  /**
	   *  Creates a pattern that matches the current plan matches and when the specified observable sequences has an available value.
	   *  @param other Observable sequence to match in addition to the current pattern.
	   *  @return {Pattern} Pattern object that matches when all observable sequences in the pattern have an available value.
	   */
	  Pattern.prototype.and = function (other) {
	    return new Pattern(this.patterns.concat(other));
	  };

	  /**
	   *  Matches when all observable sequences in the pattern (specified using a chain of and operators) have an available value and projects the values.
	   *  @param {Function} selector Selector that will be invoked with available values from the source sequences, in the same order of the sequences in the pattern.
	   *  @return {Plan} Plan that produces the projected values, to be fed (with other plans) to the when operator.
	   */
	  Pattern.prototype.thenDo = function (selector) {
	    return new Plan(this, selector);
	  };

	  function Plan(expression, selector) {
	      this.expression = expression;
	      this.selector = selector;
	  }

	  Plan.prototype.activate = function (externalSubscriptions, observer, deactivate) {
	    var self = this;
	    var joinObservers = [];
	    for (var i = 0, len = this.expression.patterns.length; i < len; i++) {
	      joinObservers.push(planCreateObserver(externalSubscriptions, this.expression.patterns[i], observer.onError.bind(observer)));
	    }
	    var activePlan = new ActivePlan(joinObservers, function () {
	      var result;
	      try {
	        result = self.selector.apply(self, arguments);
	      } catch (e) {
	        observer.onError(e);
	        return;
	      }
	      observer.onNext(result);
	    }, function () {
	      for (var j = 0, jlen = joinObservers.length; j < jlen; j++) {
	        joinObservers[j].removeActivePlan(activePlan);
	      }
	      deactivate(activePlan);
	    });
	    for (i = 0, len = joinObservers.length; i < len; i++) {
	      joinObservers[i].addActivePlan(activePlan);
	    }
	    return activePlan;
	  };

	  function planCreateObserver(externalSubscriptions, observable, onError) {
	    var entry = externalSubscriptions.get(observable);
	    if (!entry) {
	      var observer = new JoinObserver(observable, onError);
	      externalSubscriptions.set(observable, observer);
	      return observer;
	    }
	    return entry;
	  }

	  function ActivePlan(joinObserverArray, onNext, onCompleted) {
	    this.joinObserverArray = joinObserverArray;
	    this.onNext = onNext;
	    this.onCompleted = onCompleted;
	    this.joinObservers = new Map();
	    for (var i = 0, len = this.joinObserverArray.length; i < len; i++) {
	      var joinObserver = this.joinObserverArray[i];
	      this.joinObservers.set(joinObserver, joinObserver);
	    }
	  }

	  ActivePlan.prototype.dequeue = function () {
	    this.joinObservers.forEach(function (v) { v.queue.shift(); });
	  };

	  ActivePlan.prototype.match = function () {
	    var i, len, hasValues = true;
	    for (i = 0, len = this.joinObserverArray.length; i < len; i++) {
	      if (this.joinObserverArray[i].queue.length === 0) {
	        hasValues = false;
	        break;
	      }
	    }
	    if (hasValues) {
	      var firstValues = [],
	          isCompleted = false;
	      for (i = 0, len = this.joinObserverArray.length; i < len; i++) {
	        firstValues.push(this.joinObserverArray[i].queue[0]);
	        this.joinObserverArray[i].queue[0].kind === 'C' && (isCompleted = true);
	      }
	      if (isCompleted) {
	        this.onCompleted();
	      } else {
	        this.dequeue();
	        var values = [];
	        for (i = 0, len = firstValues.length; i < firstValues.length; i++) {
	          values.push(firstValues[i].value);
	        }
	        this.onNext.apply(this, values);
	      }
	    }
	  };

	  var JoinObserver = (function (__super__) {

	    inherits(JoinObserver, __super__);

	    function JoinObserver(source, onError) {
	      __super__.call(this);
	      this.source = source;
	      this.onError = onError;
	      this.queue = [];
	      this.activePlans = [];
	      this.subscription = new SingleAssignmentDisposable();
	      this.isDisposed = false;
	    }

	    var JoinObserverPrototype = JoinObserver.prototype;

	    JoinObserverPrototype.next = function (notification) {
	      if (!this.isDisposed) {
	        if (notification.kind === 'E') {
	          this.onError(notification.exception);
	          return;
	        }
	        this.queue.push(notification);
	        var activePlans = this.activePlans.slice(0);
	        for (var i = 0, len = activePlans.length; i < len; i++) {
	          activePlans[i].match();
	        }
	      }
	    };

	    JoinObserverPrototype.error = noop;
	    JoinObserverPrototype.completed = noop;

	    JoinObserverPrototype.addActivePlan = function (activePlan) {
	      this.activePlans.push(activePlan);
	    };

	    JoinObserverPrototype.subscribe = function () {
	      this.subscription.setDisposable(this.source.materialize().subscribe(this));
	    };

	    JoinObserverPrototype.removeActivePlan = function (activePlan) {
	      this.activePlans.splice(this.activePlans.indexOf(activePlan), 1);
	      this.activePlans.length === 0 && this.dispose();
	    };

	    JoinObserverPrototype.dispose = function () {
	      __super__.prototype.dispose.call(this);
	      if (!this.isDisposed) {
	        this.isDisposed = true;
	        this.subscription.dispose();
	      }
	    };

	    return JoinObserver;
	  } (AbstractObserver));

	  /**
	   *  Creates a pattern that matches when both observable sequences have an available value.
	   *
	   *  @param right Observable sequence to match with the current sequence.
	   *  @return {Pattern} Pattern object that matches when both observable sequences have an available value.
	   */
	  observableProto.and = function (right) {
	    return new Pattern([this, right]);
	  };

	  /**
	   *  Matches when the observable sequence has an available value and projects the value.
	   *
	   *  @param selector Selector that will be invoked for values in the source sequence.
	   *  @returns {Plan} Plan that produces the projected values, to be fed (with other plans) to the when operator.
	   */
	  observableProto.thenDo = function (selector) {
	    return new Pattern([this]).thenDo(selector);
	  };

	  /**
	   *  Joins together the results from several patterns.
	   *
	   *  @param plans A series of plans (specified as an Array of as a series of arguments) created by use of the Then operator on patterns.
	   *  @returns {Observable} Observable sequence with the results form matching several patterns.
	   */
	  Observable.when = function () {
	    var plans = argsOrArray(arguments, 0);
	    return new AnonymousObservable(function (observer) {
	      var activePlans = [],
	          externalSubscriptions = new Map();
	      var outObserver = observerCreate(
	        observer.onNext.bind(observer),
	        function (err) {
	          externalSubscriptions.forEach(function (v) { v.onError(err); });
	          observer.onError(err);
	        },
	        observer.onCompleted.bind(observer)
	      );
	      try {
	        for (var i = 0, len = plans.length; i < len; i++) {
	          activePlans.push(plans[i].activate(externalSubscriptions, outObserver, function (activePlan) {
	            var idx = activePlans.indexOf(activePlan);
	            activePlans.splice(idx, 1);
	            activePlans.length === 0 && observer.onCompleted();
	          }));
	        }
	      } catch (e) {
	        observableThrow(e).subscribe(observer);
	      }
	      var group = new CompositeDisposable();
	      externalSubscriptions.forEach(function (joinObserver) {
	        joinObserver.subscribe();
	        group.add(joinObserver);
	      });

	      return group;
	    });
	  };

	  function observableTimerDate(dueTime, scheduler) {
	    return new AnonymousObservable(function (observer) {
	      return scheduler.scheduleWithAbsolute(dueTime, function () {
	        observer.onNext(0);
	        observer.onCompleted();
	      });
	    });
	  }

	  function observableTimerDateAndPeriod(dueTime, period, scheduler) {
	    return new AnonymousObservable(function (observer) {
	      var count = 0, d = dueTime, p = normalizeTime(period);
	      return scheduler.scheduleRecursiveWithAbsolute(d, function (self) {
	        if (p > 0) {
	          var now = scheduler.now();
	          d = d + p;
	          d <= now && (d = now + p);
	        }
	        observer.onNext(count++);
	        self(d);
	      });
	    });
	  }

	  function observableTimerTimeSpan(dueTime, scheduler) {
	    return new AnonymousObservable(function (observer) {
	      return scheduler.scheduleWithRelative(normalizeTime(dueTime), function () {
	        observer.onNext(0);
	        observer.onCompleted();
	      });
	    });
	  }

	  function observableTimerTimeSpanAndPeriod(dueTime, period, scheduler) {
	    return dueTime === period ?
	      new AnonymousObservable(function (observer) {
	        return scheduler.schedulePeriodicWithState(0, period, function (count) {
	          observer.onNext(count);
	          return count + 1;
	        });
	      }) :
	      observableDefer(function () {
	        return observableTimerDateAndPeriod(scheduler.now() + dueTime, period, scheduler);
	      });
	  }

	  /**
	   *  Returns an observable sequence that produces a value after each period.
	   *
	   * @example
	   *  1 - res = Rx.Observable.interval(1000);
	   *  2 - res = Rx.Observable.interval(1000, Rx.Scheduler.timeout);
	   *
	   * @param {Number} period Period for producing the values in the resulting sequence (specified as an integer denoting milliseconds).
	   * @param {Scheduler} [scheduler] Scheduler to run the timer on. If not specified, Rx.Scheduler.timeout is used.
	   * @returns {Observable} An observable sequence that produces a value after each period.
	   */
	  var observableinterval = Observable.interval = function (period, scheduler) {
	    return observableTimerTimeSpanAndPeriod(period, period, isScheduler(scheduler) ? scheduler : timeoutScheduler);
	  };

	  /**
	   *  Returns an observable sequence that produces a value after dueTime has elapsed and then after each period.
	   * @param {Number} dueTime Absolute (specified as a Date object) or relative time (specified as an integer denoting milliseconds) at which to produce the first value.
	   * @param {Mixed} [periodOrScheduler]  Period to produce subsequent values (specified as an integer denoting milliseconds), or the scheduler to run the timer on. If not specified, the resulting timer is not recurring.
	   * @param {Scheduler} [scheduler]  Scheduler to run the timer on. If not specified, the timeout scheduler is used.
	   * @returns {Observable} An observable sequence that produces a value after due time has elapsed and then each period.
	   */
	  var observableTimer = Observable.timer = function (dueTime, periodOrScheduler, scheduler) {
	    var period;
	    isScheduler(scheduler) || (scheduler = timeoutScheduler);
	    if (periodOrScheduler !== undefined && typeof periodOrScheduler === 'number') {
	      period = periodOrScheduler;
	    } else if (isScheduler(periodOrScheduler)) {
	      scheduler = periodOrScheduler;
	    }
	    if (dueTime instanceof Date && period === undefined) {
	      return observableTimerDate(dueTime.getTime(), scheduler);
	    }
	    if (dueTime instanceof Date && period !== undefined) {
	      period = periodOrScheduler;
	      return observableTimerDateAndPeriod(dueTime.getTime(), period, scheduler);
	    }
	    return period === undefined ?
	      observableTimerTimeSpan(dueTime, scheduler) :
	      observableTimerTimeSpanAndPeriod(dueTime, period, scheduler);
	  };

	  function observableDelayTimeSpan(source, dueTime, scheduler) {
	    return new AnonymousObservable(function (observer) {
	      var active = false,
	        cancelable = new SerialDisposable(),
	        exception = null,
	        q = [],
	        running = false,
	        subscription;
	      subscription = source.materialize().timestamp(scheduler).subscribe(function (notification) {
	        var d, shouldRun;
	        if (notification.value.kind === 'E') {
	          q = [];
	          q.push(notification);
	          exception = notification.value.exception;
	          shouldRun = !running;
	        } else {
	          q.push({ value: notification.value, timestamp: notification.timestamp + dueTime });
	          shouldRun = !active;
	          active = true;
	        }
	        if (shouldRun) {
	          if (exception !== null) {
	            observer.onError(exception);
	          } else {
	            d = new SingleAssignmentDisposable();
	            cancelable.setDisposable(d);
	            d.setDisposable(scheduler.scheduleRecursiveWithRelative(dueTime, function (self) {
	              var e, recurseDueTime, result, shouldRecurse;
	              if (exception !== null) {
	                return;
	              }
	              running = true;
	              do {
	                result = null;
	                if (q.length > 0 && q[0].timestamp - scheduler.now() <= 0) {
	                  result = q.shift().value;
	                }
	                if (result !== null) {
	                  result.accept(observer);
	                }
	              } while (result !== null);
	              shouldRecurse = false;
	              recurseDueTime = 0;
	              if (q.length > 0) {
	                shouldRecurse = true;
	                recurseDueTime = Math.max(0, q[0].timestamp - scheduler.now());
	              } else {
	                active = false;
	              }
	              e = exception;
	              running = false;
	              if (e !== null) {
	                observer.onError(e);
	              } else if (shouldRecurse) {
	                self(recurseDueTime);
	              }
	            }));
	          }
	        }
	      });
	      return new CompositeDisposable(subscription, cancelable);
	    });
	  }

	  function observableDelayDate(source, dueTime, scheduler) {
	    return observableDefer(function () {
	      return observableDelayTimeSpan(source, dueTime - scheduler.now(), scheduler);
	    });
	  }

	  /**
	   *  Time shifts the observable sequence by dueTime. The relative time intervals between the values are preserved.
	   *
	   * @example
	   *  1 - res = Rx.Observable.delay(new Date());
	   *  2 - res = Rx.Observable.delay(new Date(), Rx.Scheduler.timeout);
	   *
	   *  3 - res = Rx.Observable.delay(5000);
	   *  4 - res = Rx.Observable.delay(5000, 1000, Rx.Scheduler.timeout);
	   * @memberOf Observable#
	   * @param {Number} dueTime Absolute (specified as a Date object) or relative time (specified as an integer denoting milliseconds) by which to shift the observable sequence.
	   * @param {Scheduler} [scheduler] Scheduler to run the delay timers on. If not specified, the timeout scheduler is used.
	   * @returns {Observable} Time-shifted sequence.
	   */
	  observableProto.delay = function (dueTime, scheduler) {
	    isScheduler(scheduler) || (scheduler = timeoutScheduler);
	    return dueTime instanceof Date ?
	      observableDelayDate(this, dueTime.getTime(), scheduler) :
	      observableDelayTimeSpan(this, dueTime, scheduler);
	  };

	  /**
	   *  Ignores values from an observable sequence which are followed by another value before dueTime.
	   *
	   * @example
	   *  1 - res = source.throttle(5000); // 5 seconds
	   *  2 - res = source.throttle(5000, scheduler);
	   *
	   * @param {Number} dueTime Duration of the throttle period for each value (specified as an integer denoting milliseconds).
	   * @param {Scheduler} [scheduler]  Scheduler to run the throttle timers on. If not specified, the timeout scheduler is used.
	   * @returns {Observable} The throttled sequence.
	   */
	  observableProto.throttle = function (dueTime, scheduler) {
	    isScheduler(scheduler) || (scheduler = timeoutScheduler);
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      var cancelable = new SerialDisposable(), hasvalue = false, value, id = 0;
	      var subscription = source.subscribe(
	        function (x) {
	          hasvalue = true;
	          value = x;
	          id++;
	          var currentId = id,
	            d = new SingleAssignmentDisposable();
	          cancelable.setDisposable(d);
	          d.setDisposable(scheduler.scheduleWithRelative(dueTime, function () {
	            hasvalue && id === currentId && observer.onNext(value);
	            hasvalue = false;
	          }));
	        },
	        function (e) {
	          cancelable.dispose();
	          observer.onError(e);
	          hasvalue = false;
	          id++;
	        },
	        function () {
	          cancelable.dispose();
	          hasvalue && observer.onNext(value);
	          observer.onCompleted();
	          hasvalue = false;
	          id++;
	        });
	      return new CompositeDisposable(subscription, cancelable);
	    });
	  };

	  /**
	   *  Projects each element of an observable sequence into zero or more windows which are produced based on timing information.
	   * @param {Number} timeSpan Length of each window (specified as an integer denoting milliseconds).
	   * @param {Mixed} [timeShiftOrScheduler]  Interval between creation of consecutive windows (specified as an integer denoting milliseconds), or an optional scheduler parameter. If not specified, the time shift corresponds to the timeSpan parameter, resulting in non-overlapping adjacent windows.
	   * @param {Scheduler} [scheduler]  Scheduler to run windowing timers on. If not specified, the timeout scheduler is used.
	   * @returns {Observable} An observable sequence of windows.
	   */
	  observableProto.windowWithTime = function (timeSpan, timeShiftOrScheduler, scheduler) {
	    var source = this, timeShift;
	    timeShiftOrScheduler == null && (timeShift = timeSpan);
	    isScheduler(scheduler) || (scheduler = timeoutScheduler);
	    if (typeof timeShiftOrScheduler === 'number') {
	      timeShift = timeShiftOrScheduler;
	    } else if (isScheduler(timeShiftOrScheduler)) {
	      timeShift = timeSpan;
	      scheduler = timeShiftOrScheduler;
	    }
	    return new AnonymousObservable(function (observer) {
	      var groupDisposable,
	        nextShift = timeShift,
	        nextSpan = timeSpan,
	        q = [],
	        refCountDisposable,
	        timerD = new SerialDisposable(),
	        totalTime = 0;
	        groupDisposable = new CompositeDisposable(timerD),
	        refCountDisposable = new RefCountDisposable(groupDisposable);

	       function createTimer () {
	        var m = new SingleAssignmentDisposable(),
	          isSpan = false,
	          isShift = false;
	        timerD.setDisposable(m);
	        if (nextSpan === nextShift) {
	          isSpan = true;
	          isShift = true;
	        } else if (nextSpan < nextShift) {
	            isSpan = true;
	        } else {
	          isShift = true;
	        }
	        var newTotalTime = isSpan ? nextSpan : nextShift,
	          ts = newTotalTime - totalTime;
	        totalTime = newTotalTime;
	        if (isSpan) {
	          nextSpan += timeShift;
	        }
	        if (isShift) {
	          nextShift += timeShift;
	        }
	        m.setDisposable(scheduler.scheduleWithRelative(ts, function () {
	          if (isShift) {
	            var s = new Subject();
	            q.push(s);
	            observer.onNext(addRef(s, refCountDisposable));
	          }
	          isSpan && q.shift().onCompleted();
	          createTimer();
	        }));
	      };
	      q.push(new Subject());
	      observer.onNext(addRef(q[0], refCountDisposable));
	      createTimer();
	      groupDisposable.add(source.subscribe(
	        function (x) {
	          for (var i = 0, len = q.length; i < len; i++) { q[i].onNext(x); }
	        }, 
	        function (e) {
	          for (var i = 0, len = q.length; i < len; i++) { q[i].onError(e); }
	          observer.onError(e);
	        }, 
	        function () {
	          for (var i = 0, len = q.length; i < len; i++) { q[i].onCompleted(); }
	          observer.onCompleted();
	        }
	      ));
	      return refCountDisposable;
	    });
	  };

	  /**
	   *  Projects each element of an observable sequence into a window that is completed when either it's full or a given amount of time has elapsed.
	   * @param {Number} timeSpan Maximum time length of a window.
	   * @param {Number} count Maximum element count of a window.
	   * @param {Scheduler} [scheduler]  Scheduler to run windowing timers on. If not specified, the timeout scheduler is used.
	   * @returns {Observable} An observable sequence of windows.
	   */
	  observableProto.windowWithTimeOrCount = function (timeSpan, count, scheduler) {
	    var source = this;
	    isScheduler(scheduler) || (scheduler = timeoutScheduler);
	    return new AnonymousObservable(function (observer) {
	      var timerD = new SerialDisposable(),
	          groupDisposable = new CompositeDisposable(timerD),
	          refCountDisposable = new RefCountDisposable(groupDisposable),
	          n = 0,
	          windowId = 0,
	          s = new Subject();

	      function createTimer(id) {
	        var m = new SingleAssignmentDisposable();
	        timerD.setDisposable(m);
	        m.setDisposable(scheduler.scheduleWithRelative(timeSpan, function () {
	          if (id !== windowId) { return; }
	          n = 0;
	          var newId = ++windowId;
	          s.onCompleted();
	          s = new Subject();
	          observer.onNext(addRef(s, refCountDisposable));
	          createTimer(newId);
	        }));
	      }
	      
	      observer.onNext(addRef(s, refCountDisposable));
	      createTimer(0);

	      groupDisposable.add(source.subscribe(
	        function (x) {
	          var newId = 0, newWindow = false;
	          s.onNext(x);
	          if (++n === count) {
	            newWindow = true;
	            n = 0;
	            newId = ++windowId;
	            s.onCompleted();
	            s = new Subject();
	            observer.onNext(addRef(s, refCountDisposable));
	          }
	          newWindow && createTimer(newId);
	        }, 
	        function (e) {
	          s.onError(e);
	          observer.onError(e);
	        }, function () {
	          s.onCompleted();
	          observer.onCompleted();
	        }
	      ));
	      return refCountDisposable;
	    });
	  };

	    /**
	     *  Projects each element of an observable sequence into zero or more buffers which are produced based on timing information.
	     *
	     * @example
	     *  1 - res = xs.bufferWithTime(1000, scheduler); // non-overlapping segments of 1 second
	     *  2 - res = xs.bufferWithTime(1000, 500, scheduler; // segments of 1 second with time shift 0.5 seconds
	     *
	     * @param {Number} timeSpan Length of each buffer (specified as an integer denoting milliseconds).
	     * @param {Mixed} [timeShiftOrScheduler]  Interval between creation of consecutive buffers (specified as an integer denoting milliseconds), or an optional scheduler parameter. If not specified, the time shift corresponds to the timeSpan parameter, resulting in non-overlapping adjacent buffers.
	     * @param {Scheduler} [scheduler]  Scheduler to run buffer timers on. If not specified, the timeout scheduler is used.
	     * @returns {Observable} An observable sequence of buffers.
	     */
	    observableProto.bufferWithTime = function (timeSpan, timeShiftOrScheduler, scheduler) {
	        return this.windowWithTime.apply(this, arguments).selectMany(function (x) { return x.toArray(); });
	    };

	    /**
	     *  Projects each element of an observable sequence into a buffer that is completed when either it's full or a given amount of time has elapsed.
	     *
	     * @example
	     *  1 - res = source.bufferWithTimeOrCount(5000, 50); // 5s or 50 items in an array
	     *  2 - res = source.bufferWithTimeOrCount(5000, 50, scheduler); // 5s or 50 items in an array
	     *
	     * @param {Number} timeSpan Maximum time length of a buffer.
	     * @param {Number} count Maximum element count of a buffer.
	     * @param {Scheduler} [scheduler]  Scheduler to run bufferin timers on. If not specified, the timeout scheduler is used.
	     * @returns {Observable} An observable sequence of buffers.
	     */
	    observableProto.bufferWithTimeOrCount = function (timeSpan, count, scheduler) {
	        return this.windowWithTimeOrCount(timeSpan, count, scheduler).selectMany(function (x) {
	            return x.toArray();
	        });
	    };

	  /**
	   *  Records the time interval between consecutive values in an observable sequence.
	   *
	   * @example
	   *  1 - res = source.timeInterval();
	   *  2 - res = source.timeInterval(Rx.Scheduler.timeout);
	   *
	   * @param [scheduler]  Scheduler used to compute time intervals. If not specified, the timeout scheduler is used.
	   * @returns {Observable} An observable sequence with time interval information on values.
	   */
	  observableProto.timeInterval = function (scheduler) {
	    var source = this;
	    isScheduler(scheduler) || (scheduler = timeoutScheduler);
	    return observableDefer(function () {
	      var last = scheduler.now();
	      return source.map(function (x) {
	        var now = scheduler.now(), span = now - last;
	        last = now;
	        return { value: x, interval: span };
	      });
	    });
	  };

	  /**
	   *  Records the timestamp for each value in an observable sequence.
	   *
	   * @example
	   *  1 - res = source.timestamp(); // produces { value: x, timestamp: ts }
	   *  2 - res = source.timestamp(Rx.Scheduler.timeout);
	   *
	   * @param {Scheduler} [scheduler]  Scheduler used to compute timestamps. If not specified, the timeout scheduler is used.
	   * @returns {Observable} An observable sequence with timestamp information on values.
	   */
	  observableProto.timestamp = function (scheduler) {
	    isScheduler(scheduler) || (scheduler = timeoutScheduler);
	    return this.map(function (x) {
	      return { value: x, timestamp: scheduler.now() };
	    });
	  };

	  function sampleObservable(source, sampler) {

	    return new AnonymousObservable(function (observer) {
	      var atEnd, value, hasValue;

	      function sampleSubscribe() {
	        if (hasValue) {
	          hasValue = false;
	          observer.onNext(value);
	        }
	        atEnd && observer.onCompleted();
	      }

	      return new CompositeDisposable(
	        source.subscribe(function (newValue) {
	          hasValue = true;
	          value = newValue;
	        }, observer.onError.bind(observer), function () {
	          atEnd = true;
	        }),
	        sampler.subscribe(sampleSubscribe, observer.onError.bind(observer), sampleSubscribe)
	      );
	    });
	  }

	  /**
	   *  Samples the observable sequence at each interval.
	   *
	   * @example
	   *  1 - res = source.sample(sampleObservable); // Sampler tick sequence
	   *  2 - res = source.sample(5000); // 5 seconds
	   *  2 - res = source.sample(5000, Rx.Scheduler.timeout); // 5 seconds
	   *
	   * @param {Mixed} intervalOrSampler Interval at which to sample (specified as an integer denoting milliseconds) or Sampler Observable.
	   * @param {Scheduler} [scheduler]  Scheduler to run the sampling timer on. If not specified, the timeout scheduler is used.
	   * @returns {Observable} Sampled observable sequence.
	   */
	  observableProto.sample = function (intervalOrSampler, scheduler) {
	    isScheduler(scheduler) || (scheduler = timeoutScheduler);
	    return typeof intervalOrSampler === 'number' ?
	      sampleObservable(this, observableinterval(intervalOrSampler, scheduler)) :
	      sampleObservable(this, intervalOrSampler);
	  };

	  /**
	   *  Returns the source observable sequence or the other observable sequence if dueTime elapses.
	   * @param {Number} dueTime Absolute (specified as a Date object) or relative time (specified as an integer denoting milliseconds) when a timeout occurs.
	   * @param {Observable} [other]  Sequence to return in case of a timeout. If not specified, a timeout error throwing sequence will be used.
	   * @param {Scheduler} [scheduler]  Scheduler to run the timeout timers on. If not specified, the timeout scheduler is used.
	   * @returns {Observable} The source sequence switching to the other sequence in case of a timeout.
	   */
	  observableProto.timeout = function (dueTime, other, scheduler) {
	    (other == null || typeof other === 'string') && (other = observableThrow(new Error(other || 'Timeout')));
	    isScheduler(scheduler) || (scheduler = timeoutScheduler);

	    var source = this, schedulerMethod = dueTime instanceof Date ?
	      'scheduleWithAbsolute' :
	      'scheduleWithRelative';

	    return new AnonymousObservable(function (observer) {
	      var id = 0,
	        original = new SingleAssignmentDisposable(),
	        subscription = new SerialDisposable(),
	        switched = false,
	        timer = new SerialDisposable();

	      subscription.setDisposable(original);

	      function createTimer() {
	        var myId = id;
	        timer.setDisposable(scheduler[schedulerMethod](dueTime, function () {
	          if (id === myId) {
	            isPromise(other) && (other = observableFromPromise(other));
	            subscription.setDisposable(other.subscribe(observer));
	          }
	        }));
	      }

	      createTimer();

	      original.setDisposable(source.subscribe(function (x) {
	        if (!switched) {
	          id++;
	          observer.onNext(x);
	          createTimer();
	        }
	      }, function (e) {
	        if (!switched) {
	          id++;
	          observer.onError(e);
	        }
	      }, function () {
	        if (!switched) {
	          id++;
	          observer.onCompleted();
	        }
	      }));
	      return new CompositeDisposable(subscription, timer);
	    });
	  };

	  /**
	   *  Generates an observable sequence by iterating a state from an initial state until the condition fails.
	   *
	   * @example
	   *  res = source.generateWithAbsoluteTime(0,
	   *      function (x) { return return true; },
	   *      function (x) { return x + 1; },
	   *      function (x) { return x; },
	   *      function (x) { return new Date(); }
	   *  });
	   *
	   * @param {Mixed} initialState Initial state.
	   * @param {Function} condition Condition to terminate generation (upon returning false).
	   * @param {Function} iterate Iteration step function.
	   * @param {Function} resultSelector Selector function for results produced in the sequence.
	   * @param {Function} timeSelector Time selector function to control the speed of values being produced each iteration, returning Date values.
	   * @param {Scheduler} [scheduler]  Scheduler on which to run the generator loop. If not specified, the timeout scheduler is used.
	   * @returns {Observable} The generated sequence.
	   */
	  Observable.generateWithAbsoluteTime = function (initialState, condition, iterate, resultSelector, timeSelector, scheduler) {
	    isScheduler(scheduler) || (scheduler = timeoutScheduler);
	    return new AnonymousObservable(function (observer) {
	      var first = true,
	        hasResult = false,
	        result,
	        state = initialState,
	        time;
	      return scheduler.scheduleRecursiveWithAbsolute(scheduler.now(), function (self) {
	        hasResult && observer.onNext(result);

	        try {
	          if (first) {
	            first = false;
	          } else {
	            state = iterate(state);
	          }
	          hasResult = condition(state);
	          if (hasResult) {
	            result = resultSelector(state);
	            time = timeSelector(state);
	          }
	        } catch (e) {
	          observer.onError(e);
	          return;
	        }
	        if (hasResult) {
	          self(time);
	        } else {
	          observer.onCompleted();
	        }
	      });
	    });
	  };

	  /**
	   *  Generates an observable sequence by iterating a state from an initial state until the condition fails.
	   *
	   * @example
	   *  res = source.generateWithRelativeTime(0,
	   *      function (x) { return return true; },
	   *      function (x) { return x + 1; },
	   *      function (x) { return x; },
	   *      function (x) { return 500; }
	   *  );
	   *
	   * @param {Mixed} initialState Initial state.
	   * @param {Function} condition Condition to terminate generation (upon returning false).
	   * @param {Function} iterate Iteration step function.
	   * @param {Function} resultSelector Selector function for results produced in the sequence.
	   * @param {Function} timeSelector Time selector function to control the speed of values being produced each iteration, returning integer values denoting milliseconds.
	   * @param {Scheduler} [scheduler]  Scheduler on which to run the generator loop. If not specified, the timeout scheduler is used.
	   * @returns {Observable} The generated sequence.
	   */
	  Observable.generateWithRelativeTime = function (initialState, condition, iterate, resultSelector, timeSelector, scheduler) {
	    isScheduler(scheduler) || (scheduler = timeoutScheduler);
	    return new AnonymousObservable(function (observer) {
	      var first = true,
	        hasResult = false,
	        result,
	        state = initialState,
	        time;
	      return scheduler.scheduleRecursiveWithRelative(0, function (self) {
	        hasResult && observer.onNext(result);

	        try {
	          if (first) {
	            first = false;
	          } else {
	            state = iterate(state);
	          }
	          hasResult = condition(state);
	          if (hasResult) {
	            result = resultSelector(state);
	            time = timeSelector(state);
	          }
	        } catch (e) {
	          observer.onError(e);
	          return;
	        }
	        if (hasResult) {
	          self(time);
	        } else {
	          observer.onCompleted();
	        }
	      });
	    });
	  };

	  /**
	   *  Time shifts the observable sequence by delaying the subscription.
	   *
	   * @example
	   *  1 - res = source.delaySubscription(5000); // 5s
	   *  2 - res = source.delaySubscription(5000, Rx.Scheduler.timeout); // 5 seconds
	   *
	   * @param {Number} dueTime Absolute or relative time to perform the subscription at.
	   * @param {Scheduler} [scheduler]  Scheduler to run the subscription delay timer on. If not specified, the timeout scheduler is used.
	   * @returns {Observable} Time-shifted sequence.
	   */
	  observableProto.delaySubscription = function (dueTime, scheduler) {
	    return this.delayWithSelector(observableTimer(dueTime, isScheduler(scheduler) ? scheduler : timeoutScheduler), observableEmpty);
	  };

	    /**
	     *  Time shifts the observable sequence based on a subscription delay and a delay selector function for each element.
	     *
	     * @example
	     *  1 - res = source.delayWithSelector(function (x) { return Rx.Scheduler.timer(5000); }); // with selector only
	     *  1 - res = source.delayWithSelector(Rx.Observable.timer(2000), function (x) { return Rx.Observable.timer(x); }); // with delay and selector
	     *
	     * @param {Observable} [subscriptionDelay]  Sequence indicating the delay for the subscription to the source.
	     * @param {Function} delayDurationSelector Selector function to retrieve a sequence indicating the delay for each given element.
	     * @returns {Observable} Time-shifted sequence.
	     */
	    observableProto.delayWithSelector = function (subscriptionDelay, delayDurationSelector) {
	        var source = this, subDelay, selector;
	        if (typeof subscriptionDelay === 'function') {
	            selector = subscriptionDelay;
	        } else {
	            subDelay = subscriptionDelay;
	            selector = delayDurationSelector;
	        }
	        return new AnonymousObservable(function (observer) {
	            var delays = new CompositeDisposable(), atEnd = false, done = function () {
	                if (atEnd && delays.length === 0) {
	                    observer.onCompleted();
	                }
	            }, subscription = new SerialDisposable(), start = function () {
	                subscription.setDisposable(source.subscribe(function (x) {
	                    var delay;
	                    try {
	                        delay = selector(x);
	                    } catch (error) {
	                        observer.onError(error);
	                        return;
	                    }
	                    var d = new SingleAssignmentDisposable();
	                    delays.add(d);
	                    d.setDisposable(delay.subscribe(function () {
	                        observer.onNext(x);
	                        delays.remove(d);
	                        done();
	                    }, observer.onError.bind(observer), function () {
	                        observer.onNext(x);
	                        delays.remove(d);
	                        done();
	                    }));
	                }, observer.onError.bind(observer), function () {
	                    atEnd = true;
	                    subscription.dispose();
	                    done();
	                }));
	            };

	            if (!subDelay) {
	                start();
	            } else {
	                subscription.setDisposable(subDelay.subscribe(function () {
	                    start();
	                }, observer.onError.bind(observer), function () { start(); }));
	            }

	            return new CompositeDisposable(subscription, delays);
	        });
	    };

	    /**
	     *  Returns the source observable sequence, switching to the other observable sequence if a timeout is signaled.
	     * @param {Observable} [firstTimeout]  Observable sequence that represents the timeout for the first element. If not provided, this defaults to Observable.never().
	     * @param {Function} [timeoutDurationSelector] Selector to retrieve an observable sequence that represents the timeout between the current element and the next element.
	     * @param {Observable} [other]  Sequence to return in case of a timeout. If not provided, this is set to Observable.throwException().
	     * @returns {Observable} The source sequence switching to the other sequence in case of a timeout.
	     */
	    observableProto.timeoutWithSelector = function (firstTimeout, timeoutdurationSelector, other) {
	      if (arguments.length === 1) {
	          timeoutdurationSelector = firstTimeout;
	          firstTimeout = observableNever();
	      }
	      other || (other = observableThrow(new Error('Timeout')));
	      var source = this;
	      return new AnonymousObservable(function (observer) {
	        var subscription = new SerialDisposable(), timer = new SerialDisposable(), original = new SingleAssignmentDisposable();

	        subscription.setDisposable(original);

	        var id = 0, switched = false;

	        function setTimer(timeout) {
	          var myId = id;

	          function timerWins () {
	            return id === myId;
	          }

	          var d = new SingleAssignmentDisposable();
	          timer.setDisposable(d);
	          d.setDisposable(timeout.subscribe(function () {
	            timerWins() && subscription.setDisposable(other.subscribe(observer));
	            d.dispose();
	          }, function (e) {
	            timerWins() && observer.onError(e);
	          }, function () {
	            timerWins() && subscription.setDisposable(other.subscribe(observer));
	          }));
	        };

	        setTimer(firstTimeout);

	        function observerWins() {
	          var res = !switched;
	          if (res) { id++; }
	          return res;
	        }

	        original.setDisposable(source.subscribe(function (x) {
	          if (observerWins()) {
	            observer.onNext(x);
	            var timeout;
	            try {
	              timeout = timeoutdurationSelector(x);
	            } catch (e) {
	              observer.onError(e);
	              return;
	            }
	            setTimer(isPromise(timeout) ? observableFromPromise(timeout) : timeout);
	          }
	        }, function (e) {
	          observerWins() && observer.onError(e);
	        }, function () {
	          observerWins() && observer.onCompleted();
	        }));
	        return new CompositeDisposable(subscription, timer);
	      });
	    };

	  /**
	   *  Ignores values from an observable sequence which are followed by another value within a computed throttle duration.
	   *
	   * @example
	   *  1 - res = source.delayWithSelector(function (x) { return Rx.Scheduler.timer(x + x); });
	   *
	   * @param {Function} throttleDurationSelector Selector function to retrieve a sequence indicating the throttle duration for each given element.
	   * @returns {Observable} The throttled sequence.
	   */
	  observableProto.throttleWithSelector = function (throttleDurationSelector) {
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      var value, hasValue = false, cancelable = new SerialDisposable(), id = 0;
	      var subscription = source.subscribe(function (x) {
	        var throttle;
	        try {
	          throttle = throttleDurationSelector(x);
	        } catch (e) {
	          observer.onError(e);
	          return;
	        }

	        isPromise(throttle) && (throttle = observableFromPromise(throttle));

	        hasValue = true;
	        value = x;
	        id++;
	        var currentid = id, d = new SingleAssignmentDisposable();
	        cancelable.setDisposable(d);
	        d.setDisposable(throttle.subscribe(function () {
	          hasValue && id === currentid && observer.onNext(value);
	          hasValue = false;
	          d.dispose();
	        }, observer.onError.bind(observer), function () {
	          hasValue && id === currentid && observer.onNext(value);
	          hasValue = false;
	          d.dispose();
	        }));
	      }, function (e) {
	        cancelable.dispose();
	        observer.onError(e);
	        hasValue = false;
	        id++;
	      }, function () {
	        cancelable.dispose();
	        hasValue && observer.onNext(value);
	        observer.onCompleted();
	        hasValue = false;
	        id++;
	      });
	      return new CompositeDisposable(subscription, cancelable);
	    });
	  };

	  /**
	   *  Skips elements for the specified duration from the end of the observable source sequence, using the specified scheduler to run timers.
	   *
	   *  1 - res = source.skipLastWithTime(5000);
	   *  2 - res = source.skipLastWithTime(5000, scheduler);
	   *
	   * @description
	   *  This operator accumulates a queue with a length enough to store elements received during the initial duration window.
	   *  As more elements are received, elements older than the specified duration are taken from the queue and produced on the
	   *  result sequence. This causes elements to be delayed with duration.
	   * @param {Number} duration Duration for skipping elements from the end of the sequence.
	   * @param {Scheduler} [scheduler]  Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout
	   * @returns {Observable} An observable sequence with the elements skipped during the specified duration from the end of the source sequence.
	   */
	  observableProto.skipLastWithTime = function (duration, scheduler) {
	    isScheduler(scheduler) || (scheduler = timeoutScheduler);
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      var q = [];
	      return source.subscribe(function (x) {
	        var now = scheduler.now();
	        q.push({ interval: now, value: x });
	        while (q.length > 0 && now - q[0].interval >= duration) {
	          observer.onNext(q.shift().value);
	        }
	      }, observer.onError.bind(observer), function () {
	        var now = scheduler.now();
	        while (q.length > 0 && now - q[0].interval >= duration) {
	          observer.onNext(q.shift().value);
	        }
	        observer.onCompleted();
	      });
	    });
	  };

	  /**
	   *  Returns elements within the specified duration from the end of the observable source sequence, using the specified schedulers to run timers and to drain the collected elements.
	   * @description
	   *  This operator accumulates a queue with a length enough to store elements received during the initial duration window.
	   *  As more elements are received, elements older than the specified duration are taken from the queue and produced on the
	   *  result sequence. This causes elements to be delayed with duration.
	   * @param {Number} duration Duration for taking elements from the end of the sequence.
	   * @param {Scheduler} [scheduler]  Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.
	   * @returns {Observable} An observable sequence with the elements taken during the specified duration from the end of the source sequence.
	   */
	  observableProto.takeLastWithTime = function (duration, scheduler) {
	    var source = this;
	    isScheduler(scheduler) || (scheduler = timeoutScheduler);
	    return new AnonymousObservable(function (observer) {
	      var q = [];
	      return source.subscribe(function (x) {
	        var now = scheduler.now();
	        q.push({ interval: now, value: x });
	        while (q.length > 0 && now - q[0].interval >= duration) {
	          q.shift();
	        }
	      }, observer.onError.bind(observer), function () {
	        var now = scheduler.now();
	        while (q.length > 0) {
	          var next = q.shift();
	          if (now - next.interval <= duration) { observer.onNext(next.value); }
	        }
	        observer.onCompleted();
	      });
	    });
	  };

	  /**
	   *  Returns an array with the elements within the specified duration from the end of the observable source sequence, using the specified scheduler to run timers.
	   * @description
	   *  This operator accumulates a queue with a length enough to store elements received during the initial duration window.
	   *  As more elements are received, elements older than the specified duration are taken from the queue and produced on the
	   *  result sequence. This causes elements to be delayed with duration.
	   * @param {Number} duration Duration for taking elements from the end of the sequence.
	   * @param {Scheduler} scheduler Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.
	   * @returns {Observable} An observable sequence containing a single array with the elements taken during the specified duration from the end of the source sequence.
	   */
	  observableProto.takeLastBufferWithTime = function (duration, scheduler) {
	    var source = this;
	    isScheduler(scheduler) || (scheduler = timeoutScheduler);
	    return new AnonymousObservable(function (observer) {
	      var q = [];
	      return source.subscribe(function (x) {
	        var now = scheduler.now();
	        q.push({ interval: now, value: x });
	        while (q.length > 0 && now - q[0].interval >= duration) {
	          q.shift();
	        }
	      }, observer.onError.bind(observer), function () {
	        var now = scheduler.now(), res = [];
	        while (q.length > 0) {
	          var next = q.shift();
	          if (now - next.interval <= duration) { res.push(next.value); }
	        }
	        observer.onNext(res);
	        observer.onCompleted();
	      });
	    });
	  };

	  /**
	   *  Takes elements for the specified duration from the start of the observable source sequence, using the specified scheduler to run timers.
	   *
	   * @example
	   *  1 - res = source.takeWithTime(5000,  [optional scheduler]);
	   * @description
	   *  This operator accumulates a queue with a length enough to store elements received during the initial duration window.
	   *  As more elements are received, elements older than the specified duration are taken from the queue and produced on the
	   *  result sequence. This causes elements to be delayed with duration.
	   * @param {Number} duration Duration for taking elements from the start of the sequence.
	   * @param {Scheduler} scheduler Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.
	   * @returns {Observable} An observable sequence with the elements taken during the specified duration from the start of the source sequence.
	   */
	  observableProto.takeWithTime = function (duration, scheduler) {
	    var source = this;
	    isScheduler(scheduler) || (scheduler = timeoutScheduler);
	    return new AnonymousObservable(function (observer) {
	      return new CompositeDisposable(scheduler.scheduleWithRelative(duration, observer.onCompleted.bind(observer)), source.subscribe(observer));
	    });
	  };

	  /**
	   *  Skips elements for the specified duration from the start of the observable source sequence, using the specified scheduler to run timers.
	   *
	   * @example
	   *  1 - res = source.skipWithTime(5000, [optional scheduler]);
	   *
	   * @description
	   *  Specifying a zero value for duration doesn't guarantee no elements will be dropped from the start of the source sequence.
	   *  This is a side-effect of the asynchrony introduced by the scheduler, where the action that causes callbacks from the source sequence to be forwarded
	   *  may not execute immediately, despite the zero due time.
	   *
	   *  Errors produced by the source sequence are always forwarded to the result sequence, even if the error occurs before the duration.
	   * @param {Number} duration Duration for skipping elements from the start of the sequence.
	   * @param {Scheduler} scheduler Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.
	   * @returns {Observable} An observable sequence with the elements skipped during the specified duration from the start of the source sequence.
	   */
	  observableProto.skipWithTime = function (duration, scheduler) {
	    var source = this;
	    isScheduler(scheduler) || (scheduler = timeoutScheduler);
	    return new AnonymousObservable(function (observer) {
	      var open = false;
	      return new CompositeDisposable(
	        scheduler.scheduleWithRelative(duration, function () { open = true; }),
	        source.subscribe(function (x) { open && observer.onNext(x); }, observer.onError.bind(observer), observer.onCompleted.bind(observer)));
	    });
	  };

	  /**
	   *  Skips elements from the observable source sequence until the specified start time, using the specified scheduler to run timers.
	   *  Errors produced by the source sequence are always forwarded to the result sequence, even if the error occurs before the start time.
	   *
	   * @examples
	   *  1 - res = source.skipUntilWithTime(new Date(), [scheduler]);
	   *  2 - res = source.skipUntilWithTime(5000, [scheduler]);
	   * @param {Date|Number} startTime Time to start taking elements from the source sequence. If this value is less than or equal to Date(), no elements will be skipped.
	   * @param {Scheduler} [scheduler] Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.
	   * @returns {Observable} An observable sequence with the elements skipped until the specified start time.
	   */
	  observableProto.skipUntilWithTime = function (startTime, scheduler) {
	    isScheduler(scheduler) || (scheduler = timeoutScheduler);
	    var source = this, schedulerMethod = startTime instanceof Date ?
	      'scheduleWithAbsolute' :
	      'scheduleWithRelative';
	    return new AnonymousObservable(function (observer) {
	      var open = false;

	      return new CompositeDisposable(
	        scheduler[schedulerMethod](startTime, function () { open = true; }),
	        source.subscribe(
	          function (x) { open && observer.onNext(x); },
	          observer.onError.bind(observer),
	          observer.onCompleted.bind(observer)));
	    });
	  };

	  /**
	   *  Takes elements for the specified duration until the specified end time, using the specified scheduler to run timers.
	   * @param {Number | Date} endTime Time to stop taking elements from the source sequence. If this value is less than or equal to new Date(), the result stream will complete immediately.
	   * @param {Scheduler} [scheduler] Scheduler to run the timer on.
	   * @returns {Observable} An observable sequence with the elements taken until the specified end time.
	   */
	  observableProto.takeUntilWithTime = function (endTime, scheduler) {
	    isScheduler(scheduler) || (scheduler = timeoutScheduler);
	    var source = this, schedulerMethod = endTime instanceof Date ?
	      'scheduleWithAbsolute' :
	      'scheduleWithRelative';
	    return new AnonymousObservable(function (observer) {
	      return new CompositeDisposable(
	        scheduler[schedulerMethod](endTime, observer.onCompleted.bind(observer)),
	        source.subscribe(observer));
	    });
	  };

	  /**
	   * Executes a transducer to transform the observable sequence 
	   * @param {Transducer} transducer A transducer to execute
	   * @returns {Observable} An Observable sequence containing the results from the transducer.
	   */
	  observableProto.transduce = function(transducer) {
	    var source = this;

	    function transformForObserver(observer) {
	      return {
	        init: function() {
	          return observer;
	        },
	        step: function(obs, input) {
	          return obs.onNext(input);
	        },
	        result: function(obs) {
	          return obs.onCompleted();
	        }
	      };
	    }

	    return new AnonymousObservable(function(observer) {
	      var xform = transducer(transformForObserver(observer));
	      return source.subscribe(
	        function(v) { 
	          try {
	            xform.step(observer, v);
	          } catch (e) {
	            observer.onError(e);
	          }
	        }, 
	        observer.onError.bind(observer), 
	        function() { xform.result(observer); }
	      );
	    });
	  };

	  /*
	   * Performs a exclusive waiting for the first to finish before subscribing to another observable.
	   * Observables that come in between subscriptions will be dropped on the floor.
	   * @returns {Observable} A exclusive observable with only the results that happen when subscribed.
	   */
	  observableProto.exclusive = function () {
	    var sources = this;
	    return new AnonymousObservable(function (observer) {
	      var hasCurrent = false,
	        isStopped = false,
	        m = new SingleAssignmentDisposable(),
	        g = new CompositeDisposable();

	      g.add(m);

	      m.setDisposable(sources.subscribe(
	        function (innerSource) {
	          if (!hasCurrent) {
	            hasCurrent = true;

	            isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));

	            var innerSubscription = new SingleAssignmentDisposable();
	            g.add(innerSubscription);

	            innerSubscription.setDisposable(innerSource.subscribe(
	              observer.onNext.bind(observer),
	              observer.onError.bind(observer),
	              function () {
	                g.remove(innerSubscription);
	                hasCurrent = false;
	                if (isStopped && g.length === 1) {
	                  observer.onCompleted();
	                }
	            }));
	          }
	        },
	        observer.onError.bind(observer),
	        function () {
	          isStopped = true;
	          if (!hasCurrent && g.length === 1) {
	            observer.onCompleted();
	          }
	        }));

	      return g;
	    });
	  };

	  /*
	   * Performs a exclusive map waiting for the first to finish before subscribing to another observable.
	   * Observables that come in between subscriptions will be dropped on the floor.
	   * @param {Function} selector Selector to invoke for every item in the current subscription.
	   * @param {Any} [thisArg] An optional context to invoke with the selector parameter.
	   * @returns {Observable} An exclusive observable with only the results that happen when subscribed.
	   */
	  observableProto.exclusiveMap = function (selector, thisArg) {
	    var sources = this;
	    return new AnonymousObservable(function (observer) {
	      var index = 0,
	        hasCurrent = false,
	        isStopped = true,
	        m = new SingleAssignmentDisposable(),
	        g = new CompositeDisposable();

	      g.add(m);

	      m.setDisposable(sources.subscribe(
	        function (innerSource) {

	          if (!hasCurrent) {
	            hasCurrent = true;

	            innerSubscription = new SingleAssignmentDisposable();
	            g.add(innerSubscription);

	            isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));

	            innerSubscription.setDisposable(innerSource.subscribe(
	              function (x) {
	                var result;
	                try {
	                  result = selector.call(thisArg, x, index++, innerSource);
	                } catch (e) {
	                  observer.onError(e);
	                  return;
	                }

	                observer.onNext(result);
	              },
	              observer.onError.bind(observer),
	              function () {
	                g.remove(innerSubscription);
	                hasCurrent = false;

	                if (isStopped && g.length === 1) {
	                  observer.onCompleted();
	                }
	              }));
	          }
	        },
	        observer.onError.bind(observer),
	        function () {
	          isStopped = true;
	          if (g.length === 1 && !hasCurrent) {
	            observer.onCompleted();
	          }
	        }));
	      return g;
	    });
	  };

	  /** Provides a set of extension methods for virtual time scheduling. */
	  Rx.VirtualTimeScheduler = (function (__super__) {

	    function notImplemented() {
	        throw new Error('Not implemented');
	    }

	    function localNow() {
	      return this.toDateTimeOffset(this.clock);
	    }

	    function scheduleNow(state, action) {
	      return this.scheduleAbsoluteWithState(state, this.clock, action);
	    }

	    function scheduleRelative(state, dueTime, action) {
	      return this.scheduleRelativeWithState(state, this.toRelative(dueTime), action);
	    }

	    function scheduleAbsolute(state, dueTime, action) {
	      return this.scheduleRelativeWithState(state, this.toRelative(dueTime - this.now()), action);
	    }

	    function invokeAction(scheduler, action) {
	      action();
	      return disposableEmpty;
	    }

	    inherits(VirtualTimeScheduler, __super__);

	    /**
	     * Creates a new virtual time scheduler with the specified initial clock value and absolute time comparer.
	     *
	     * @constructor
	     * @param {Number} initialClock Initial value for the clock.
	     * @param {Function} comparer Comparer to determine causality of events based on absolute time.
	     */
	    function VirtualTimeScheduler(initialClock, comparer) {
	      this.clock = initialClock;
	      this.comparer = comparer;
	      this.isEnabled = false;
	      this.queue = new PriorityQueue(1024);
	      __super__.call(this, localNow, scheduleNow, scheduleRelative, scheduleAbsolute);
	    }

	    var VirtualTimeSchedulerPrototype = VirtualTimeScheduler.prototype;

	    /**
	     * Adds a relative time value to an absolute time value.
	     * @param {Number} absolute Absolute virtual time value.
	     * @param {Number} relative Relative virtual time value to add.
	     * @return {Number} Resulting absolute virtual time sum value.
	     */
	    VirtualTimeSchedulerPrototype.add = notImplemented;

	    /**
	     * Converts an absolute time to a number
	     * @param {Any} The absolute time.
	     * @returns {Number} The absolute time in ms
	     */
	    VirtualTimeSchedulerPrototype.toDateTimeOffset = notImplemented;

	    /**
	     * Converts the TimeSpan value to a relative virtual time value.
	     * @param {Number} timeSpan TimeSpan value to convert.
	     * @return {Number} Corresponding relative virtual time value.
	     */
	    VirtualTimeSchedulerPrototype.toRelative = notImplemented;

	    /**
	     * Schedules a periodic piece of work by dynamically discovering the scheduler's capabilities. The periodic task will be emulated using recursive scheduling.
	     * @param {Mixed} state Initial state passed to the action upon the first iteration.
	     * @param {Number} period Period for running the work periodically.
	     * @param {Function} action Action to be executed, potentially updating the state.
	     * @returns {Disposable} The disposable object used to cancel the scheduled recurring action (best effort).
	     */
	    VirtualTimeSchedulerPrototype.schedulePeriodicWithState = function (state, period, action) {
	      var s = new SchedulePeriodicRecursive(this, state, period, action);
	      return s.start();
	    };

	    /**
	     * Schedules an action to be executed after dueTime.
	     * @param {Mixed} state State passed to the action to be executed.
	     * @param {Number} dueTime Relative time after which to execute the action.
	     * @param {Function} action Action to be executed.
	     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
	     */
	    VirtualTimeSchedulerPrototype.scheduleRelativeWithState = function (state, dueTime, action) {
	      var runAt = this.add(this.clock, dueTime);
	      return this.scheduleAbsoluteWithState(state, runAt, action);
	    };

	    /**
	     * Schedules an action to be executed at dueTime.
	     * @param {Number} dueTime Relative time after which to execute the action.
	     * @param {Function} action Action to be executed.
	     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
	     */
	    VirtualTimeSchedulerPrototype.scheduleRelative = function (dueTime, action) {
	      return this.scheduleRelativeWithState(action, dueTime, invokeAction);
	    };

	    /**
	     * Starts the virtual time scheduler.
	     */
	    VirtualTimeSchedulerPrototype.start = function () {
	      if (!this.isEnabled) {
	        this.isEnabled = true;
	        do {
	          var next = this.getNext();
	          if (next !== null) {
	            this.comparer(next.dueTime, this.clock) > 0 && (this.clock = next.dueTime);
	            next.invoke();
	          } else {
	            this.isEnabled = false;
	          }
	        } while (this.isEnabled);
	      }
	    };

	    /**
	     * Stops the virtual time scheduler.
	     */
	    VirtualTimeSchedulerPrototype.stop = function () {
	      this.isEnabled = false;
	    };

	    /**
	     * Advances the scheduler's clock to the specified time, running all work till that point.
	     * @param {Number} time Absolute time to advance the scheduler's clock to.
	     */
	    VirtualTimeSchedulerPrototype.advanceTo = function (time) {
	      var dueToClock = this.comparer(this.clock, time);
	      if (this.comparer(this.clock, time) > 0) {
	        throw new Error(argumentOutOfRange);
	      }
	      if (dueToClock === 0) {
	        return;
	      }
	      if (!this.isEnabled) {
	        this.isEnabled = true;
	        do {
	          var next = this.getNext();
	          if (next !== null && this.comparer(next.dueTime, time) <= 0) {
	            this.comparer(next.dueTime, this.clock) > 0 && (this.clock = next.dueTime);
	            next.invoke();
	          } else {
	            this.isEnabled = false;
	          }
	        } while (this.isEnabled);
	        this.clock = time;
	      }
	    };

	    /**
	     * Advances the scheduler's clock by the specified relative time, running all work scheduled for that timespan.
	     * @param {Number} time Relative time to advance the scheduler's clock by.
	     */
	    VirtualTimeSchedulerPrototype.advanceBy = function (time) {
	      var dt = this.add(this.clock, time),
	          dueToClock = this.comparer(this.clock, dt);
	      if (dueToClock > 0) { throw new Error(argumentOutOfRange); }
	      if (dueToClock === 0) {  return; }

	      this.advanceTo(dt);
	    };

	    /**
	     * Advances the scheduler's clock by the specified relative time.
	     * @param {Number} time Relative time to advance the scheduler's clock by.
	     */
	    VirtualTimeSchedulerPrototype.sleep = function (time) {
	      var dt = this.add(this.clock, time);
	      if (this.comparer(this.clock, dt) >= 0) { throw new Error(argumentOutOfRange); }

	      this.clock = dt;
	    };

	    /**
	     * Gets the next scheduled item to be executed.
	     * @returns {ScheduledItem} The next scheduled item.
	     */
	    VirtualTimeSchedulerPrototype.getNext = function () {
	      while (this.queue.length > 0) {
	        var next = this.queue.peek();
	        if (next.isCancelled()) {
	          this.queue.dequeue();
	        } else {
	          return next;
	        }
	      }
	      return null;
	    };

	    /**
	     * Schedules an action to be executed at dueTime.
	     * @param {Scheduler} scheduler Scheduler to execute the action on.
	     * @param {Number} dueTime Absolute time at which to execute the action.
	     * @param {Function} action Action to be executed.
	     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
	     */
	    VirtualTimeSchedulerPrototype.scheduleAbsolute = function (dueTime, action) {
	      return this.scheduleAbsoluteWithState(action, dueTime, invokeAction);
	    };

	    /**
	     * Schedules an action to be executed at dueTime.
	     * @param {Mixed} state State passed to the action to be executed.
	     * @param {Number} dueTime Absolute time at which to execute the action.
	     * @param {Function} action Action to be executed.
	     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
	     */
	    VirtualTimeSchedulerPrototype.scheduleAbsoluteWithState = function (state, dueTime, action) {
	      var self = this;

	      function run(scheduler, state1) {
	        self.queue.remove(si);
	        return action(scheduler, state1);
	      }

	      var si = new ScheduledItem(this, state, run, dueTime, this.comparer);
	      this.queue.enqueue(si);

	      return si.disposable;
	    };

	    return VirtualTimeScheduler;
	  }(Scheduler));

	  /** Provides a virtual time scheduler that uses Date for absolute time and number for relative time. */
	  Rx.HistoricalScheduler = (function (__super__) {
	    inherits(HistoricalScheduler, __super__);

	    /**
	     * Creates a new historical scheduler with the specified initial clock value.
	     * @constructor
	     * @param {Number} initialClock Initial value for the clock.
	     * @param {Function} comparer Comparer to determine causality of events based on absolute time.
	     */
	    function HistoricalScheduler(initialClock, comparer) {
	      var clock = initialClock == null ? 0 : initialClock;
	      var cmp = comparer || defaultSubComparer;
	      __super__.call(this, clock, cmp);
	    }

	    var HistoricalSchedulerProto = HistoricalScheduler.prototype;

	    /**
	     * Adds a relative time value to an absolute time value.
	     * @param {Number} absolute Absolute virtual time value.
	     * @param {Number} relative Relative virtual time value to add.
	     * @return {Number} Resulting absolute virtual time sum value.
	     */
	    HistoricalSchedulerProto.add = function (absolute, relative) {
	      return absolute + relative;
	    };

	    HistoricalSchedulerProto.toDateTimeOffset = function (absolute) {
	      return new Date(absolute).getTime();
	    };

	    /**
	     * Converts the TimeSpan value to a relative virtual time value.
	     * @memberOf HistoricalScheduler
	     * @param {Number} timeSpan TimeSpan value to convert.
	     * @return {Number} Corresponding relative virtual time value.
	     */
	    HistoricalSchedulerProto.toRelative = function (timeSpan) {
	      return timeSpan;
	    };

	    return HistoricalScheduler;
	  }(Rx.VirtualTimeScheduler));

	  var AnonymousObservable = Rx.AnonymousObservable = (function (__super__) {
	    inherits(AnonymousObservable, __super__);

	    // Fix subscriber to check for undefined or function returned to decorate as Disposable
	    function fixSubscriber(subscriber) {
	      if (subscriber && typeof subscriber.dispose === 'function') { return subscriber; }

	      return typeof subscriber === 'function' ?
	        disposableCreate(subscriber) :
	        disposableEmpty;
	    }

	    function AnonymousObservable(subscribe) {
	      if (!(this instanceof AnonymousObservable)) {
	        return new AnonymousObservable(subscribe);
	      }

	      function s(observer) {
	        var setDisposable = function () {
	          try {
	            autoDetachObserver.setDisposable(fixSubscriber(subscribe(autoDetachObserver)));
	          } catch (e) {
	            if (!autoDetachObserver.fail(e)) {
	              throw e;
	            }
	          }
	        };

	        var autoDetachObserver = new AutoDetachObserver(observer);
	        if (currentThreadScheduler.scheduleRequired()) {
	          currentThreadScheduler.schedule(setDisposable);
	        } else {
	          setDisposable();
	        }

	        return autoDetachObserver;
	      }

	      __super__.call(this, s);
	    }

	    return AnonymousObservable;

	  }(Observable));

	    /** @private */
	    var AutoDetachObserver = (function (_super) {
	        inherits(AutoDetachObserver, _super);

	        function AutoDetachObserver(observer) {
	            _super.call(this);
	            this.observer = observer;
	            this.m = new SingleAssignmentDisposable();
	        }

	        var AutoDetachObserverPrototype = AutoDetachObserver.prototype;

	        AutoDetachObserverPrototype.next = function (value) {
	            var noError = false;
	            try {
	                this.observer.onNext(value);
	                noError = true;
	            } catch (e) {
	                throw e;
	            } finally {
	                if (!noError) {
	                    this.dispose();
	                }
	            }
	        };

	        AutoDetachObserverPrototype.error = function (exn) {
	            try {
	                this.observer.onError(exn);
	            } catch (e) {
	                throw e;
	            } finally {
	                this.dispose();
	            }
	        };

	        AutoDetachObserverPrototype.completed = function () {
	            try {
	                this.observer.onCompleted();
	            } catch (e) {
	                throw e;
	            } finally {
	                this.dispose();
	            }
	        };

	        AutoDetachObserverPrototype.setDisposable = function (value) { this.m.setDisposable(value); };
	        AutoDetachObserverPrototype.getDisposable = function (value) { return this.m.getDisposable(); };
	        /* @private */
	        AutoDetachObserverPrototype.disposable = function (value) {
	            return arguments.length ? this.getDisposable() : setDisposable(value);
	        };

	        AutoDetachObserverPrototype.dispose = function () {
	            _super.prototype.dispose.call(this);
	            this.m.dispose();
	        };

	        return AutoDetachObserver;
	    }(AbstractObserver));

	  var GroupedObservable = (function (__super__) {
	    inherits(GroupedObservable, __super__);

	    function subscribe(observer) {
	      return this.underlyingObservable.subscribe(observer);
	    }

	    function GroupedObservable(key, underlyingObservable, mergedDisposable) {
	      __super__.call(this, subscribe);
	      this.key = key;
	      this.underlyingObservable = !mergedDisposable ?
	        underlyingObservable :
	        new AnonymousObservable(function (observer) {
	          return new CompositeDisposable(mergedDisposable.getDisposable(), underlyingObservable.subscribe(observer));
	        });
	    }

	    return GroupedObservable;
	  }(Observable));

	    /**
	     *  Represents an object that is both an observable sequence as well as an observer.
	     *  Each notification is broadcasted to all subscribed observers.
	     */
	    var Subject = Rx.Subject = (function (_super) {
	        function subscribe(observer) {
	            checkDisposed.call(this);
	            if (!this.isStopped) {
	                this.observers.push(observer);
	                return new InnerSubscription(this, observer);
	            }
	            if (this.exception) {
	                observer.onError(this.exception);
	                return disposableEmpty;
	            }
	            observer.onCompleted();
	            return disposableEmpty;
	        }

	        inherits(Subject, _super);

	        /**
	         * Creates a subject.
	         * @constructor
	         */
	        function Subject() {
	            _super.call(this, subscribe);
	            this.isDisposed = false,
	            this.isStopped = false,
	            this.observers = [];
	        }

	        addProperties(Subject.prototype, Observer, {
	            /**
	             * Indicates whether the subject has observers subscribed to it.
	             * @returns {Boolean} Indicates whether the subject has observers subscribed to it.
	             */
	            hasObservers: function () {
	                return this.observers.length > 0;
	            },
	            /**
	             * Notifies all subscribed observers about the end of the sequence.
	             */
	            onCompleted: function () {
	                checkDisposed.call(this);
	                if (!this.isStopped) {
	                    var os = this.observers.slice(0);
	                    this.isStopped = true;
	                    for (var i = 0, len = os.length; i < len; i++) {
	                        os[i].onCompleted();
	                    }

	                    this.observers = [];
	                }
	            },
	            /**
	             * Notifies all subscribed observers about the exception.
	             * @param {Mixed} error The exception to send to all observers.
	             */
	            onError: function (exception) {
	                checkDisposed.call(this);
	                if (!this.isStopped) {
	                    var os = this.observers.slice(0);
	                    this.isStopped = true;
	                    this.exception = exception;
	                    for (var i = 0, len = os.length; i < len; i++) {
	                        os[i].onError(exception);
	                    }

	                    this.observers = [];
	                }
	            },
	            /**
	             * Notifies all subscribed observers about the arrival of the specified element in the sequence.
	             * @param {Mixed} value The value to send to all observers.
	             */
	            onNext: function (value) {
	                checkDisposed.call(this);
	                if (!this.isStopped) {
	                    var os = this.observers.slice(0);
	                    for (var i = 0, len = os.length; i < len; i++) {
	                        os[i].onNext(value);
	                    }
	                }
	            },
	            /**
	             * Unsubscribe all observers and release resources.
	             */
	            dispose: function () {
	                this.isDisposed = true;
	                this.observers = null;
	            }
	        });

	        /**
	         * Creates a subject from the specified observer and observable.
	         * @param {Observer} observer The observer used to send messages to the subject.
	         * @param {Observable} observable The observable used to subscribe to messages sent from the subject.
	         * @returns {Subject} Subject implemented using the given observer and observable.
	         */
	        Subject.create = function (observer, observable) {
	            return new AnonymousSubject(observer, observable);
	        };

	        return Subject;
	    }(Observable));

	  /**
	   *  Represents the result of an asynchronous operation.
	   *  The last value before the OnCompleted notification, or the error received through OnError, is sent to all subscribed observers.
	   */
	  var AsyncSubject = Rx.AsyncSubject = (function (__super__) {

	    function subscribe(observer) {
	      checkDisposed.call(this);

	      if (!this.isStopped) {
	        this.observers.push(observer);
	        return new InnerSubscription(this, observer);
	      }

	      var ex = this.exception,
	        hv = this.hasValue,
	        v = this.value;

	      if (ex) {
	        observer.onError(ex);
	      } else if (hv) {
	        observer.onNext(v);
	        observer.onCompleted();
	      } else {
	        observer.onCompleted();
	      }

	      return disposableEmpty;
	    }

	    inherits(AsyncSubject, __super__);

	    /**
	     * Creates a subject that can only receive one value and that value is cached for all future observations.
	     * @constructor
	     */
	    function AsyncSubject() {
	      __super__.call(this, subscribe);

	      this.isDisposed = false;
	      this.isStopped = false;
	      this.value = null;
	      this.hasValue = false;
	      this.observers = [];
	      this.exception = null;
	    }

	    addProperties(AsyncSubject.prototype, Observer, {
	      /**
	       * Indicates whether the subject has observers subscribed to it.
	       * @returns {Boolean} Indicates whether the subject has observers subscribed to it.
	       */
	      hasObservers: function () {
	        checkDisposed.call(this);
	        return this.observers.length > 0;
	      },
	      /**
	       * Notifies all subscribed observers about the end of the sequence, also causing the last received value to be sent out (if any).
	       */
	      onCompleted: function () {
	        var o, i, len;
	        checkDisposed.call(this);
	        if (!this.isStopped) {
	          this.isStopped = true;
	          var os = this.observers.slice(0),
	            v = this.value,
	            hv = this.hasValue;

	          if (hv) {
	            for (i = 0, len = os.length; i < len; i++) {
	              o = os[i];
	              o.onNext(v);
	              o.onCompleted();
	            }
	          } else {
	            for (i = 0, len = os.length; i < len; i++) {
	              os[i].onCompleted();
	            }
	          }

	          this.observers = [];
	        }
	      },
	      /**
	       * Notifies all subscribed observers about the error.
	       * @param {Mixed} error The Error to send to all observers.
	       */
	      onError: function (error) {
	        checkDisposed.call(this);
	        if (!this.isStopped) {
	          var os = this.observers.slice(0);
	          this.isStopped = true;
	          this.exception = error;

	          for (var i = 0, len = os.length; i < len; i++) {
	            os[i].onError(error);
	          }

	          this.observers = [];
	        }
	      },
	      /**
	       * Sends a value to the subject. The last value received before successful termination will be sent to all subscribed and future observers.
	       * @param {Mixed} value The value to store in the subject.
	       */
	      onNext: function (value) {
	        checkDisposed.call(this);
	        if (this.isStopped) { return; }
	        this.value = value;
	        this.hasValue = true;
	      },
	      /**
	       * Unsubscribe all observers and release resources.
	       */
	      dispose: function () {
	        this.isDisposed = true;
	        this.observers = null;
	        this.exception = null;
	        this.value = null;
	      }
	    });

	    return AsyncSubject;
	  }(Observable));

	  var AnonymousSubject = Rx.AnonymousSubject = (function (__super__) {
	    inherits(AnonymousSubject, __super__);

	    function AnonymousSubject(observer, observable) {
	      this.observer = observer;
	      this.observable = observable;
	      __super__.call(this, this.observable.subscribe.bind(this.observable));
	    }

	    addProperties(AnonymousSubject.prototype, Observer, {
	      onCompleted: function () {
	        this.observer.onCompleted();
	      },
	      onError: function (exception) {
	        this.observer.onError(exception);
	      },
	      onNext: function (value) {
	        this.observer.onNext(value);
	      }
	    });

	    return AnonymousSubject;
	  }(Observable));

	    if (true) {
	        root.Rx = Rx;

	        !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	            return Rx;
	        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (freeExports && freeModule) {
	        // in Node.js or RingoJS
	        if (moduleExports) {
	            (freeModule.exports = Rx).Rx = Rx;
	        } else {
	          freeExports.Rx = Rx;
	        }
	    } else {
	        // in a browser or Rhino
	        root.Rx = Rx;
	    }

	}.call(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22)(module), (function() { return this; }()), __webpack_require__(25)))

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * jslex - A lexer in JavaScript.
	 * @author Jim R. Wilson (jimbojw)
	 */

	var _ = __webpack_require__(14);
	    
	     /**
	     * jslex constructor.
	     * @param {object} spec Lexer specification.
	     * @return {object} 
	     */
	    function jslex( spec ) {

	        if (spec === undefined) {
	            throw "no specification supplied";
	        }
	        
	        var
	            
	            // jslex object
	            lexer = new JSLex(),
	                
	            // specification
	            specification = lexer.specification = {},
	            
	            // list of states
	            states = lexer.states = [];
	                    
	        
	        // establish list of states
	        for (var k in spec) {
	            states[states.length] = k;
	        }
	        
	        // build out internal representation of the provided spec
	        for (var i=0, l=states.length; i<l; i++) {

	            var
	                s = states[i],
	                state = spec[s];

	            if (specification[s]) {
	                throw "Duplicate state declaration encountered for state '" + s + "'";
	            }
	            
	            var rules = specification[s] = [];
	            
	            for (var k in state) {
	                try {
	                    var re = new RegExp('^' + k);
	                } catch(err) {
	                    throw "Invalid regexp '" + k + "' in state '" + s + "' (" + err.message + ")";
	                }
	                rules[rules.length] = {
	                    re: re,
	                    action: state[k]
	                };
	            }
	        }
	        
	        // return jslex object
	        return lexer;
	    }

	    // End of File marker
	    var EOF = {};

	    /**
	     * Utility function for comparing two matches.
	     * @param {object} m1 Left-hand side match.
	     * @param {object} m2 Right-hand side match.
	     * @return {int} Difference between the matches.
	     */
	    function matchcompare( m1, m2 ) {
	        return m2.len - m1.len || m1.index - m2.index;
	    }

	    /**
	     * JSLex prototype.
	     */
	    function JSLex() { }
	    JSLex.prototype = {

	        /**
	         * Scanner function - makes a new scanner object which is used to get tokens one at a time.
	         * @param {string} input Input text to tokenize.
	         * @param {function} Scanner function.
	         */
	        scanner: function scanner( input ) {
	        
	            var
	                
	                // avoid ambiguity between the lexer and the api object
	                lexer = this,
	                states = lexer.states,
	                specification = lexer.specification,
	                
	                // position within input stream
	                pos = 0,
	                
	                // current line number
	                line = 0,
	                
	                // curret column number
	                col = 0,
	                
	                offset,
	                less,
	                go,
	                newstate,
	                inputlen = input.length,
	                nlre = /\n/g,
	            
	                // initial state
	                state = states[0];            
	    
	            /**
	             * The api bject will be set to "this" when executing spec callbacks.
	             */ 
	            var api = {
	                
	                /**
	                 * Analogous to yytext and yyleng in lex - will be set during scan.
	                 */
	                text: null,
	                leng: null,
	            
	                /**
	                 * Position of in stream, line number and column number of match.
	                 */
	                pos: null,
	                line: null,
	                column: null,
	            
	                /**
	                 * Analogous to input() in lex.
	                 * @return {string} The next character in the stream.
	                 */
	                input: function(){
	                    return input.charAt(pos + this.leng + offset++);
	                },
	                
	                /**
	                 * Similar to unput() in lex, but does not allow modifying the stream.
	                 * @return {int} The offset position after the operation.
	                 */
	                unput: function(){
	                    return offset = offset > 0 ? offset-- : 0;
	                },
	                
	                /**
	                 * Analogous to yyless(n) in lex - retains the first n characters from this pattern, and returns 
	                 * the rest to the input stream, such that they will be used in the next pattern-matching operation.
	                 * @param {int} n Number of characters to retain.
	                 * @return {int} Length of the stream after the operation has completed.
	                 */
	                less: function(n) {
	                    less = n;
	                    offset = 0;
	                    this.text = this.text.substr(0, n);
	                    return this.leng = this.text.length;
	                },
	                
	                /**
	                 * Like less(), but instead of retaining the first n characters, it chops off the last n.
	                 * @param {int} n Number of characters to chop.
	                 * @return {int} Length of the stream after the operation has completed.
	                 */
	                pushback: function(n) {
	                    return this.less(this.leng - n);
	                },
	                
	                /**
	                 * Similar to REJECT in lex, except it doesn't break the current execution context.
	                 * TIP: reject() should be the last instruction in a spec callback.
	                 */
	                reject: function() {
	                    go = true;
	                },
	                
	                /**
	                 * Analogous to BEGIN in lex - sets the named state (start condition).
	                 * @param {string|int} state Name of state to switch to, or ordinal number (0 is first, etc).
	                 * @return {string} The new state on successful switch, throws exception on failure.
	                 */
	                begin: function(state) {
	                    if (specification[state]) {
	                        return newstate = state;
	                    }
	                    var s = states[parseInt(state)];
	                    if (s) {
	                        return newstate = s;
	                    }
	                    throw "Unknown state '" + state + "' requested";
	                },
	                
	                /**
	                 * Simple accessor for reading in the current state.
	                 * @return {string} The current state.
	                 */
	                state: function(){
	                    return state;
	                }
	                
	            };
	            
	            /**
	             * Scan method to be returned to caller - grabs the next token and fires appropriate calback.
	             * @return {string} The next token extracted from the stream.
	             */
	            function scan() {
	            
	                if (pos >= inputlen) {
	                    return EOF;
	                }
	                api.pos = pos;
	                api.line = line;
	                api.column = col;
	                var
	                    str = pos ? input.substr(pos) : input,
	                    rules = specification[state],
	                    matches = [];
	                for (var i=0, l=rules.length; i<l; i++) {
	                    var
	                        rule = rules[i],
	                        m = str.match(rule.re);
	                    if (m && m[0].length) {
	                        matches[matches.length] = {
	                            index: i,
	                            text: m[0],
	                            len: m[0].length,
	                            rule: rule,
	                            captureGroups: _.tail(m)
	                        };
	                    }
	                }
	                if (!matches.length) {
	                    var ch = str.charAt(0);
	                    pos++;
	                    if (ch=="\n") {
	                        line++;
	                        col = 0;
	                    } else {
	                        col++;
	                    }
	                    return ch;
	                }
	                matches.sort(matchcompare);
	                go = true;
	                for (var j=0, n=matches.length; j<n && go; j++) {
	                    var
	                        offset = 0,
	                        less = null,
	                        go = false,
	                        newstate = null,
	                        result,
	                        m = matches[j],
	                        action = m.rule.action;
	                    api.text = m.text;
	                    api.leng = m.len;
	                    if (!action) {
	                        break;
	                    }
	                    var result = action.apply(api, m.captureGroups);
	                    if (newstate && newstate != state) {
	                        state = newstate;
	                        break;
	                    }
	                }
	                var
	                    text = less===null ? m.text : m.text.substr(0, less),
	                    len = text.length;
	                pos += len + offset;
	                var nlm = text.match(nlre);
	                if (nlm) {
	                    line += nlm.length;
	                    col = len - text.lastIndexOf("\n") - 1;
	                } else {
	                    col += len;
	                }
	                if (result !== undefined) {
	                    return result;
	                }
	            }
	            
	            return scan;
	        },
	        
	        /**
	         * Similar to lex's yylex() function, consumes all input, calling calback for each token.
	         * @param {string} input Text to lex.
	         * @param {function} callback Function to execute for each token.
	         */
	        lex: function lex( input, callback ) {
	            var self = this;
	                var
	                    token,
	                    scanner = self.scanner(input);
	                while (true) {
	                    token = scanner();
	                    if (token === EOF) {
	                        return;
	                    }
	                    if (token !== undefined) {
	                        callback(token);
	                    }
	                }
	        },
	        
	        /**
	         * Consumes all input, collecting tokens along the way.
	         * @param {string} input Text to lex.
	         * @return {array} List of tokens, may contain an Error at the end.
	         */
	        collect: function collect( input ) {
	            var tokens = [];
	            function callback( token ) {
	                tokens[tokens.length] = token;
	            }
	            try {
	                this.lex(input, callback);
	            } catch (err) {
	                if (!(err instanceof Error)) {
	                    err = new Error(err + '');
	                }
	                tokens[tokens.length] = err;
	            }
	            return tokens;
	        }
	        
	    };
	        
	    module.exports = jslex;

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;;(function(root, factory) {

	  // Support AMD
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	  // Support CommonJS
	  } else if (typeof exports === 'object') {
	    var randomColor = factory();
	    
	    // Support NodeJS & Component, which allow module.exports to be a function
	    if (typeof module === 'object' && module && module.exports) {
	      exports = module.exports = randomColor;
	    }
	    
	    // Support CommonJS 1.1.1 spec
	    exports.randomColor = randomColor;
	  
	  // Support vanilla script loading
	  } else {
	    root.randomColor = factory();
	  };

	}(this, function() {

	  // Shared color dictionary
	  var colorDictionary = {};

	  // Populate the color dictionary
	  loadColorBounds();

	  var randomColor = function(options) {
	    options = options || {};

	    var H,S,B;

	    // Check if we need to generate multiple colors
	    if (options.count) {

	      var totalColors = options.count,
	          colors = [];

	      options.count = false;

	      while (totalColors > colors.length) {
	        colors.push(randomColor(options));
	      }

	      return colors;
	    }

	    // First we pick a hue (H)
	    H = pickHue(options);

	    // Then use H to determine saturation (S)
	    S = pickSaturation(H, options);

	    // Then use S and H to determine brightness (B).
	    B = pickBrightness(H, S, options);

	    // Then we return the HSB color in the desired format
	    return setFormat([H,S,B], options);
	  };

	  function pickHue (options) {

	    var hueRange = getHueRange(options.hue),
	        hue = randomWithin(hueRange);

	    // Instead of storing red as two seperate ranges,
	    // we group them, using negative numbers
	    if (hue < 0) {hue = 360 + hue}

	    return hue;

	  }

	  function pickSaturation (hue, options) {

	    if (options.luminosity === 'random') {
	      return randomWithin([0,100]);
	    }

	    if (options.hue === 'monochrome') {
	      return 0;
	    }

	    var saturationRange = getSaturationRange(hue);

	    var sMin = saturationRange[0],
	        sMax = saturationRange[1];

	    switch (options.luminosity) {

	      case 'bright':
	        sMin = 55;
	        break;

	      case 'dark':
	        sMin = sMax - 10;
	        break;

	      case 'light':
	        sMax = 55;
	        break;
	   }

	    return randomWithin([sMin, sMax]);

	  }

	  function pickBrightness (H, S, options) {

	    var brightness,
	        bMin = getMinimumBrightness(H, S),
	        bMax = 100;

	    switch (options.luminosity) {

	      case 'dark':
	        bMax = bMin + 20;
	        break;

	      case 'light':
	        bMin = (bMax + bMin)/2;
	        break;

	      case 'random':
	        bMin = 0;
	        bMax = 100;
	        break;
	    }

	    return randomWithin([bMin, bMax]);

	  }

	  function setFormat (hsv, options) {

	    switch (options.format) {

	      case 'hsvArray':
	        return hsv;

	      case 'hsv':
	        return colorString('hsv', hsv);

	      case 'rgbArray':
	        return HSVtoRGB(hsv);

	      case 'rgb':
	        return colorString('rgb', HSVtoRGB(hsv));

	      default:
	        return HSVtoHex(hsv);
	    }

	  }

	  function getMinimumBrightness(H, S) {

	    var lowerBounds = getColorInfo(H).lowerBounds;

	    for (var i = 0; i < lowerBounds.length - 1; i++) {

	      var s1 = lowerBounds[i][0],
	          v1 = lowerBounds[i][1];

	      var s2 = lowerBounds[i+1][0],
	          v2 = lowerBounds[i+1][1];

	      if (S >= s1 && S <= s2) {

	         var m = (v2 - v1)/(s2 - s1),
	             b = v1 - m*s1;

	         return m*S + b;
	      }

	    }

	    return 0;
	  }

	  function getHueRange (colorInput) {

	    if (typeof parseInt(colorInput) === 'number') {

	      var number = parseInt(colorInput);

	      if (number < 360 && number > 0) {
	        return [number, number];
	      }

	    }

	    if (typeof colorInput === 'string') {

	      if (colorDictionary[colorInput]) {
	        var color = colorDictionary[colorInput];
	        if (color.hueRange) {return color.hueRange}
	      }
	    }

	    return [0,360];

	  }

	  function getSaturationRange (hue) {
	    return getColorInfo(hue).saturationRange;
	  }

	  function getColorInfo (hue) {

	    // Maps red colors to make picking hue easier
	    if (hue >= 334 && hue <= 360) {
	      hue-= 360;
	    }

	    for (var colorName in colorDictionary) {
	       var color = colorDictionary[colorName];
	       if (color.hueRange &&
	           hue >= color.hueRange[0] &&
	           hue <= color.hueRange[1]) {
	          return colorDictionary[colorName];
	       }
	    } return 'Color not found';
	  }

	  function randomWithin (range) {
	    return Math.floor(range[0] + Math.random()*(range[1] + 1 - range[0]));
	  }

	  function shiftHue (h, degrees) {
	    return (h + degrees)%360;
	  }

	  function HSVtoHex (hsv){

	    var rgb = HSVtoRGB(hsv);

	    function componentToHex(c) {
	        var hex = c.toString(16);
	        return hex.length == 1 ? "0" + hex : hex;
	    }

	    var hex = "#" + componentToHex(rgb[0]) + componentToHex(rgb[1]) + componentToHex(rgb[2]);

	    return hex;

	  }

	  function defineColor (name, hueRange, lowerBounds) {

	    var sMin = lowerBounds[0][0],
	        sMax = lowerBounds[lowerBounds.length - 1][0],

	        bMin = lowerBounds[lowerBounds.length - 1][1],
	        bMax = lowerBounds[0][1];

	    colorDictionary[name] = {
	      hueRange: hueRange,
	      lowerBounds: lowerBounds,
	      saturationRange: [sMin, sMax],
	      brightnessRange: [bMin, bMax]
	    };

	  }

	  function loadColorBounds () {

	    defineColor(
	      'monochrome',
	      null,
	      [[0,0],[100,0]]
	    );

	    defineColor(
	      'red',
	      [-26,18],
	      [[20,100],[30,92],[40,89],[50,85],[60,78],[70,70],[80,60],[90,55],[100,50]]
	    );

	    defineColor(
	      'orange',
	      [19,46],
	      [[20,100],[30,93],[40,88],[50,86],[60,85],[70,70],[100,70]]
	    );

	    defineColor(
	      'yellow',
	      [47,62],
	      [[25,100],[40,94],[50,89],[60,86],[70,84],[80,82],[90,80],[100,75]]
	    );

	    defineColor(
	      'green',
	      [63,158],
	      [[30,100],[40,90],[50,85],[60,81],[70,74],[80,64],[90,50],[100,40]]
	    );

	    defineColor(
	      'blue',
	      [159, 257],
	      [[20,100],[30,86],[40,80],[50,74],[60,60],[70,52],[80,44],[90,39],[100,35]]
	    );

	    defineColor(
	      'purple',
	      [258, 282],
	      [[20,100],[30,87],[40,79],[50,70],[60,65],[70,59],[80,52],[90,45],[100,42]]
	    );

	    defineColor(
	      'pink',
	      [283, 334],
	      [[20,100],[30,90],[40,86],[60,84],[80,80],[90,75],[100,73]]
	    );

	  }

	  function HSVtoRGB (hsv) {

	    // this doesn't work for the values of 0 and 360
	    // here's the hacky fix
	    var h = hsv[0];
	    if (h === 0) {h = 1}
	    if (h === 360) {h = 359}

	    // Rebase the h,s,v values
	    h = h/360;
	    var s = hsv[1]/100,
	        v = hsv[2]/100;

	    var h_i = Math.floor(h*6),
	      f = h * 6 - h_i,
	      p = v * (1 - s),
	      q = v * (1 - f*s),
	      t = v * (1 - (1 - f)*s),
	      r = 256,
	      g = 256,
	      b = 256;

	    switch(h_i) {
	      case 0: r = v, g = t, b = p;  break;
	      case 1: r = q, g = v, b = p;  break;
	      case 2: r = p, g = v, b = t;  break;
	      case 3: r = p, g = q, b = v;  break;
	      case 4: r = t, g = p, b = v;  break;
	      case 5: r = v, g = p, b = q;  break;
	    }
	    var result = [Math.floor(r*255), Math.floor(g*255), Math.floor(b*255)];
	    return result;
	  }

	  function colorString (prefix, values) {
	    return prefix + '(' + values.join(', ') + ')';
	  }

	  return randomColor;
	}));

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_RESULT__;/* svg.js 1.0.1 - svg selector inventor polyfill regex default color array pointarray patharray number viewbox bbox rbox element parent container fx relative event defs group arrange mask clip gradient pattern doc shape symbol use rect ellipse line poly path image text textpath nested hyperlink marker sugar set data memory loader helpers - svgjs.com/license */
	;(function(root, factory) {
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports === 'object') {
	    module.exports = factory();
	  } else {
	    root.SVG = factory();
	  }
	}(this, function() {

	  var SVG = this.SVG = function(element) {
	    if (SVG.supported) {
	      element = new SVG.Doc(element)
	  
	      if (!SVG.parser)
	        SVG.prepare(element)
	  
	      return element
	    }
	  }
	  
	  // Default namespaces
	  SVG.ns    = 'http://www.w3.org/2000/svg'
	  SVG.xmlns = 'http://www.w3.org/2000/xmlns/'
	  SVG.xlink = 'http://www.w3.org/1999/xlink'
	  
	  // Element id sequence
	  SVG.did  = 1000
	  
	  // Get next named element id
	  SVG.eid = function(name) {
	    return 'Svgjs' + name.charAt(0).toUpperCase() + name.slice(1) + (SVG.did++)
	  }
	  
	  // Method for element creation
	  SVG.create = function(name) {
	    /* create element */
	    var element = document.createElementNS(this.ns, name)
	    
	    /* apply unique id */
	    element.setAttribute('id', this.eid(name))
	    
	    return element
	  }
	  
	  // Method for extending objects
	  SVG.extend = function() {
	    var modules, methods, key, i
	    
	    /* get list of modules */
	    modules = [].slice.call(arguments)
	    
	    /* get object with extensions */
	    methods = modules.pop()
	    
	    for (i = modules.length - 1; i >= 0; i--)
	      if (modules[i])
	        for (key in methods)
	          modules[i].prototype[key] = methods[key]
	  
	    /* make sure SVG.Set inherits any newly added methods */
	    if (SVG.Set && SVG.Set.inherit)
	      SVG.Set.inherit()
	  }
	  
	  // Initialize parsing element
	  SVG.prepare = function(element) {
	    /* select document body and create invisible svg element */
	    var body = document.getElementsByTagName('body')[0]
	      , draw = (body ? new SVG.Doc(body) : element.nested()).size(2, 0)
	      , path = SVG.create('path')
	  
	    /* insert parsers */
	    draw.node.appendChild(path)
	  
	    /* create parser object */
	    SVG.parser = {
	      body: body || element.parent
	    , draw: draw.style('opacity:0;position:fixed;left:100%;top:100%;overflow:hidden')
	    , poly: draw.polyline().node
	    , path: path
	    }
	  }
	  
	  // svg support test
	  SVG.supported = (function() {
	    return !! document.createElementNS &&
	           !! document.createElementNS(SVG.ns,'svg').createSVGRect
	  })()
	  
	  if (!SVG.supported) return false


	  SVG.get = function(id) {
	    var node = document.getElementById(idFromReference(id) || id)
	    if (node) return node.instance
	  }

	  SVG.invent = function(config) {
	  	/* create element initializer */
	  	var initializer = typeof config.create == 'function' ?
	  		config.create :
	  		function() {
	  			this.constructor.call(this, SVG.create(config.create))
	  		}
	  
	  	/* inherit prototype */
	  	if (config.inherit)
	  		initializer.prototype = new config.inherit
	  
	  	/* extend with methods */
	  	if (config.extend)
	  		SVG.extend(initializer, config.extend)
	  
	  	/* attach construct method to parent */
	  	if (config.construct)
	  		SVG.extend(config.parent || SVG.Container, config.construct)
	  
	  	return initializer
	  }

	  if (typeof CustomEvent !== 'function') {
	    // Code from: https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent
	    function CustomEvent (event, options) {
	      options = options || { bubbles: false, cancelable: false, detail: undefined }
	      var e = document.createEvent('CustomEvent')
	      e.initCustomEvent(event, options.bubbles, options.cancelable, options.detail)
	      return e
	    }
	  
	    CustomEvent.prototype = window.Event.prototype
	  
	    window.CustomEvent = CustomEvent
	  }

	  SVG.regex = {
	    /* parse unit value */
	    unit:         /^(-?[\d\.]+)([a-z%]{0,2})$/
	    
	    /* parse hex value */
	  , hex:          /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i
	    
	    /* parse rgb value */
	  , rgb:          /rgb\((\d+),(\d+),(\d+)\)/
	    
	    /* parse reference id */
	  , reference:    /#([a-z0-9\-_]+)/i
	  
	    /* test hex value */
	  , isHex:        /^#[a-f0-9]{3,6}$/i
	    
	    /* test rgb value */
	  , isRgb:        /^rgb\(/
	    
	    /* test css declaration */
	  , isCss:        /[^:]+:[^;]+;?/
	    
	    /* test for blank string */
	  , isBlank:      /^(\s+)?$/
	    
	    /* test for numeric string */
	  , isNumber:     /^-?[\d\.]+$/
	  
	    /* test for percent value */
	  , isPercent:    /^-?[\d\.]+%$/
	  
	    /* test for image url */
	  , isImage:      /\.(jpg|jpeg|png|gif)(\?[^=]+.*)?/i
	    
	    /* test for namespaced event */
	  , isEvent:      /^[\w]+:[\w]+$/
	  
	  }

	  SVG.defaults = {
	    // Default matrix
	    matrix:       '1 0 0 1 0 0'
	    
	    // Default attribute values
	  , attrs: {
	      /* fill and stroke */
	      'fill-opacity':     1
	    , 'stroke-opacity':   1
	    , 'stroke-width':     0
	    , 'stroke-linejoin':  'miter'
	    , 'stroke-linecap':   'butt'
	    , fill:               '#000000'
	    , stroke:             '#000000'
	    , opacity:            1
	      /* position */
	    , x:                  0
	    , y:                  0
	    , cx:                 0
	    , cy:                 0
	      /* size */  
	    , width:              0
	    , height:             0
	      /* radius */  
	    , r:                  0
	    , rx:                 0
	    , ry:                 0
	      /* gradient */  
	    , offset:             0
	    , 'stop-opacity':     1
	    , 'stop-color':       '#000000'
	      /* text */
	    , 'font-size':        16
	    , 'font-family':      'Helvetica, Arial, sans-serif'
	    , 'text-anchor':      'start'
	    }
	    
	    // Default transformation values
	  , trans: function() {
	      return {
	        /* translate */
	        x:        0
	      , y:        0
	        /* scale */
	      , scaleX:   1
	      , scaleY:   1
	        /* rotate */
	      , rotation: 0
	        /* skew */
	      , skewX:    0
	      , skewY:    0
	        /* matrix */
	      , matrix:   this.matrix
	      , a:        1
	      , b:        0
	      , c:        0
	      , d:        1
	      , e:        0
	      , f:        0
	      }
	    }
	    
	  }

	  SVG.Color = function(color) {
	    var match
	    
	    /* initialize defaults */
	    this.r = 0
	    this.g = 0
	    this.b = 0
	    
	    /* parse color */
	    if (typeof color === 'string') {
	      if (SVG.regex.isRgb.test(color)) {
	        /* get rgb values */
	        match = SVG.regex.rgb.exec(color.replace(/\s/g,''))
	        
	        /* parse numeric values */
	        this.r = parseInt(match[1])
	        this.g = parseInt(match[2])
	        this.b = parseInt(match[3])
	        
	      } else if (SVG.regex.isHex.test(color)) {
	        /* get hex values */
	        match = SVG.regex.hex.exec(fullHex(color))
	  
	        /* parse numeric values */
	        this.r = parseInt(match[1], 16)
	        this.g = parseInt(match[2], 16)
	        this.b = parseInt(match[3], 16)
	  
	      }
	      
	    } else if (typeof color === 'object') {
	      this.r = color.r
	      this.g = color.g
	      this.b = color.b
	      
	    }
	      
	  }
	  
	  SVG.extend(SVG.Color, {
	    // Default to hex conversion
	    toString: function() {
	      return this.toHex()
	    }
	    // Build hex value
	  , toHex: function() {
	      return '#'
	        + compToHex(this.r)
	        + compToHex(this.g)
	        + compToHex(this.b)
	    }
	    // Build rgb value
	  , toRgb: function() {
	      return 'rgb(' + [this.r, this.g, this.b].join() + ')'
	    }
	    // Calculate true brightness
	  , brightness: function() {
	      return (this.r / 255 * 0.30)
	           + (this.g / 255 * 0.59)
	           + (this.b / 255 * 0.11)
	    }
	    // Make color morphable
	  , morph: function(color) {
	      this.destination = new SVG.Color(color)
	  
	      return this
	    }
	    // Get morphed color at given position
	  , at: function(pos) {
	      /* make sure a destination is defined */
	      if (!this.destination) return this
	  
	      /* normalise pos */
	      pos = pos < 0 ? 0 : pos > 1 ? 1 : pos
	  
	      /* generate morphed color */
	      return new SVG.Color({
	        r: ~~(this.r + (this.destination.r - this.r) * pos)
	      , g: ~~(this.g + (this.destination.g - this.g) * pos)
	      , b: ~~(this.b + (this.destination.b - this.b) * pos)
	      })
	    }
	    
	  })
	  
	  // Testers
	  
	  // Test if given value is a color string
	  SVG.Color.test = function(color) {
	    color += ''
	    return SVG.regex.isHex.test(color)
	        || SVG.regex.isRgb.test(color)
	  }
	  
	  // Test if given value is a rgb object
	  SVG.Color.isRgb = function(color) {
	    return color && typeof color.r == 'number'
	                 && typeof color.g == 'number'
	                 && typeof color.b == 'number'
	  }
	  
	  // Test if given value is a color
	  SVG.Color.isColor = function(color) {
	    return SVG.Color.isRgb(color) || SVG.Color.test(color)
	  }

	  SVG.Array = function(array, fallback) {
	    array = (array || []).valueOf()
	  
	    /* if array is empty and fallback is provided, use fallback */
	    if (array.length == 0 && fallback)
	      array = fallback.valueOf()
	  
	    /* parse array */
	    this.value = this.parse(array)
	  }
	  
	  SVG.extend(SVG.Array, {
	    // Make array morphable
	    morph: function(array) {
	      this.destination = this.parse(array)
	  
	      /* normalize length of arrays */
	      if (this.value.length != this.destination.length) {
	        var lastValue       = this.value[this.value.length - 1]
	          , lastDestination = this.destination[this.destination.length - 1]
	  
	        while(this.value.length > this.destination.length)
	          this.destination.push(lastDestination)
	        while(this.value.length < this.destination.length)
	          this.value.push(lastValue)
	      }
	  
	      return this
	    }
	    // Clean up any duplicate points
	  , settle: function() {
	      /* find all unique values */
	      for (var i = 0, il = this.value.length, seen = []; i < il; i++)
	        if (seen.indexOf(this.value[i]) == -1)
	          seen.push(this.value[i])
	  
	      /* set new value */
	      return this.value = seen
	    }
	    // Get morphed array at given position
	  , at: function(pos) {
	      /* make sure a destination is defined */
	      if (!this.destination) return this
	  
	      /* generate morphed array */
	      for (var i = 0, il = this.value.length, array = []; i < il; i++)
	        array.push(this.value[i] + (this.destination[i] - this.value[i]) * pos)
	  
	      return new SVG.Array(array)
	    }
	    // Convert array to string
	  , toString: function() {
	      return this.value.join(' ')
	    }
	    // Real value
	  , valueOf: function() {
	      return this.value
	    }
	    // Parse whitespace separated string
	  , parse: function(array) {
	      array = array.valueOf()
	  
	      /* if already is an array, no need to parse it */
	      if (Array.isArray(array)) return array
	  
	      return this.split(array)
	    }
	    // Strip unnecessary whitespace
	  , split: function(string) {
	      return string.replace(/\s+/g, ' ').replace(/^\s+|\s+$/g,'').split(' ') 
	    }
	    // Reverse array
	  , reverse: function() {
	      this.value.reverse()
	  
	      return this
	    }
	  
	  })
	  


	  SVG.PointArray = function() {
	    this.constructor.apply(this, arguments)
	  }
	  
	  // Inherit from SVG.Array
	  SVG.PointArray.prototype = new SVG.Array
	  
	  SVG.extend(SVG.PointArray, {
	    // Convert array to string
	    toString: function() {
	      /* convert to a poly point string */
	      for (var i = 0, il = this.value.length, array = []; i < il; i++)
	        array.push(this.value[i].join(','))
	  
	      return array.join(' ')
	    }
	    // Get morphed array at given position
	  , at: function(pos) {
	      /* make sure a destination is defined */
	      if (!this.destination) return this
	  
	      /* generate morphed point string */
	      for (var i = 0, il = this.value.length, array = []; i < il; i++)
	        array.push([
	          this.value[i][0] + (this.destination[i][0] - this.value[i][0]) * pos
	        , this.value[i][1] + (this.destination[i][1] - this.value[i][1]) * pos
	        ])
	  
	      return new SVG.PointArray(array)
	    }
	    // Parse point string
	  , parse: function(array) {
	      array = array.valueOf()
	  
	      /* if already is an array, no need to parse it */
	      if (Array.isArray(array)) return array
	  
	      /* split points */
	      array = this.split(array)
	  
	      /* parse points */
	      for (var i = 0, il = array.length, p, points = []; i < il; i++) {
	        p = array[i].split(',')
	        points.push([parseFloat(p[0]), parseFloat(p[1])])
	      }
	  
	      return points
	    }
	    // Move point string
	  , move: function(x, y) {
	      var box = this.bbox()
	  
	      /* get relative offset */
	      x -= box.x
	      y -= box.y
	  
	      /* move every point */
	      if (!isNaN(x) && !isNaN(y))
	        for (var i = this.value.length - 1; i >= 0; i--)
	          this.value[i] = [this.value[i][0] + x, this.value[i][1] + y]
	  
	      return this
	    }
	    // Resize poly string
	  , size: function(width, height) {
	      var i, box = this.bbox()
	  
	      /* recalculate position of all points according to new size */
	      for (i = this.value.length - 1; i >= 0; i--) {
	        this.value[i][0] = ((this.value[i][0] - box.x) * width)  / box.width  + box.x
	        this.value[i][1] = ((this.value[i][1] - box.y) * height) / box.height + box.y
	      }
	  
	      return this
	    }
	    // Get bounding box of points
	  , bbox: function() {
	      SVG.parser.poly.setAttribute('points', this.toString())
	  
	      return SVG.parser.poly.getBBox()
	    }
	  
	  })

	  SVG.PathArray = function(array, fallback) {
	    this.constructor.call(this, array, fallback)
	  }
	  
	  // Inherit from SVG.Array
	  SVG.PathArray.prototype = new SVG.Array
	  
	  SVG.extend(SVG.PathArray, {
	    // Convert array to string
	    toString: function() {
	      return arrayToString(this.value)
	    }
	    // Move path string
	  , move: function(x, y) {
	  		/* get bounding box of current situation */
	  		var box = this.bbox()
	  		
	      /* get relative offset */
	      x -= box.x
	      y -= box.y
	  
	      if (!isNaN(x) && !isNaN(y)) {
	        /* move every point */
	        for (var l, i = this.value.length - 1; i >= 0; i--) {
	          l = this.value[i][0]
	  
	          if (l == 'M' || l == 'L' || l == 'T')  {
	            this.value[i][1] += x
	            this.value[i][2] += y
	  
	          } else if (l == 'H')  {
	            this.value[i][1] += x
	  
	          } else if (l == 'V')  {
	            this.value[i][1] += y
	  
	          } else if (l == 'C' || l == 'S' || l == 'Q')  {
	            this.value[i][1] += x
	            this.value[i][2] += y
	            this.value[i][3] += x
	            this.value[i][4] += y
	  
	            if (l == 'C')  {
	              this.value[i][5] += x
	              this.value[i][6] += y
	            }
	  
	          } else if (l == 'A')  {
	            this.value[i][6] += x
	            this.value[i][7] += y
	          }
	  
	        }
	      }
	  
	      return this
	    }
	    // Resize path string
	  , size: function(width, height) {
	  		/* get bounding box of current situation */
	  		var i, l, box = this.bbox()
	  
	      /* recalculate position of all points according to new size */
	      for (i = this.value.length - 1; i >= 0; i--) {
	        l = this.value[i][0]
	  
	        if (l == 'M' || l == 'L' || l == 'T')  {
	          this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x
	          this.value[i][2] = ((this.value[i][2] - box.y) * height) / box.height + box.y
	  
	        } else if (l == 'H')  {
	          this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x
	  
	        } else if (l == 'V')  {
	          this.value[i][1] = ((this.value[i][1] - box.y) * height) / box.height + box.y
	  
	        } else if (l == 'C' || l == 'S' || l == 'Q')  {
	          this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x
	          this.value[i][2] = ((this.value[i][2] - box.y) * height) / box.height + box.y
	          this.value[i][3] = ((this.value[i][3] - box.x) * width)  / box.width  + box.x
	          this.value[i][4] = ((this.value[i][4] - box.y) * height) / box.height + box.y
	  
	          if (l == 'C')  {
	            this.value[i][5] = ((this.value[i][5] - box.x) * width)  / box.width  + box.x
	            this.value[i][6] = ((this.value[i][6] - box.y) * height) / box.height + box.y
	          }
	  
	        } else if (l == 'A')  {
	          /* resize radii */
	          this.value[i][1] = (this.value[i][1] * width)  / box.width
	          this.value[i][2] = (this.value[i][2] * height) / box.height
	  
	          /* move position values */
	          this.value[i][6] = ((this.value[i][6] - box.x) * width)  / box.width  + box.x
	          this.value[i][7] = ((this.value[i][7] - box.y) * height) / box.height + box.y
	        }
	  
	      }
	  
	      return this
	    }
	    // Absolutize and parse path to array
	  , parse: function(array) {
	      /* if it's already is a patharray, no need to parse it */
	      if (array instanceof SVG.PathArray) return array.valueOf()
	  
	      /* prepare for parsing */
	      var i, il, x0, y0, x1, y1, x2, y2, s, seg, segs
	        , x = 0
	        , y = 0
	      
	      /* populate working path */
	      SVG.parser.path.setAttribute('d', typeof array === 'string' ? array : arrayToString(array))
	      
	      /* get segments */
	      segs = SVG.parser.path.pathSegList
	  
	      for (i = 0, il = segs.numberOfItems; i < il; ++i) {
	        seg = segs.getItem(i)
	        s = seg.pathSegTypeAsLetter
	  
	        /* yes, this IS quite verbose but also about 30 times faster than .test() with a precompiled regex */
	        if (s == 'M' || s == 'L' || s == 'H' || s == 'V' || s == 'C' || s == 'S' || s == 'Q' || s == 'T' || s == 'A') {
	          if ('x' in seg) x = seg.x
	          if ('y' in seg) y = seg.y
	  
	        } else {
	          if ('x1' in seg) x1 = x + seg.x1
	          if ('x2' in seg) x2 = x + seg.x2
	          if ('y1' in seg) y1 = y + seg.y1
	          if ('y2' in seg) y2 = y + seg.y2
	          if ('x'  in seg) x += seg.x
	          if ('y'  in seg) y += seg.y
	  
	          if (s == 'm')
	            segs.replaceItem(SVG.parser.path.createSVGPathSegMovetoAbs(x, y), i)
	          else if (s == 'l')
	            segs.replaceItem(SVG.parser.path.createSVGPathSegLinetoAbs(x, y), i)
	          else if (s == 'h')
	            segs.replaceItem(SVG.parser.path.createSVGPathSegLinetoHorizontalAbs(x), i)
	          else if (s == 'v')
	            segs.replaceItem(SVG.parser.path.createSVGPathSegLinetoVerticalAbs(y), i)
	          else if (s == 'c')
	            segs.replaceItem(SVG.parser.path.createSVGPathSegCurvetoCubicAbs(x, y, x1, y1, x2, y2), i)
	          else if (s == 's')
	            segs.replaceItem(SVG.parser.path.createSVGPathSegCurvetoCubicSmoothAbs(x, y, x2, y2), i)
	          else if (s == 'q')
	            segs.replaceItem(SVG.parser.path.createSVGPathSegCurvetoQuadraticAbs(x, y, x1, y1), i)
	          else if (s == 't')
	            segs.replaceItem(SVG.parser.path.createSVGPathSegCurvetoQuadraticSmoothAbs(x, y), i)
	          else if (s == 'a')
	            segs.replaceItem(SVG.parser.path.createSVGPathSegArcAbs(x, y, seg.r1, seg.r2, seg.angle, seg.largeArcFlag, seg.sweepFlag), i)
	          else if (s == 'z' || s == 'Z') {
	            x = x0
	            y = y0
	          }
	        }
	  
	        /* record the start of a subpath */
	        if (s == 'M' || s == 'm') {
	          x0 = x
	          y0 = y
	        }
	      }
	  
	      /* build internal representation */
	      array = []
	      segs  = SVG.parser.path.pathSegList
	      
	      for (i = 0, il = segs.numberOfItems; i < il; ++i) {
	        seg = segs.getItem(i)
	        s = seg.pathSegTypeAsLetter
	        x = [s]
	  
	        if (s == 'M' || s == 'L' || s == 'T')
	          x.push(seg.x, seg.y)
	        else if (s == 'H')
	          x.push(seg.x)
	        else if (s == 'V')
	          x.push(seg.y)
	        else if (s == 'C')
	          x.push(seg.x1, seg.y1, seg.x2, seg.y2, seg.x, seg.y)
	        else if (s == 'S')
	          x.push(seg.x2, seg.y2, seg.x, seg.y)
	        else if (s == 'Q')
	          x.push(seg.x1, seg.y1, seg.x, seg.y)
	        else if (s == 'A')
	          x.push(seg.r1, seg.r2, seg.angle, seg.largeArcFlag|0, seg.sweepFlag|0, seg.x, seg.y)
	  
	        /* store segment */
	        array.push(x)
	      }
	      
	      return array
	    }
	    // Get bounding box of path
	  , bbox: function() {
	      SVG.parser.path.setAttribute('d', this.toString())
	  
	      return SVG.parser.path.getBBox()
	    }
	  
	  })

	  SVG.Number = function(value) {
	  
	    /* initialize defaults */
	    this.value = 0
	    this.unit = ''
	  
	    /* parse value */
	    if (typeof value === 'number') {
	      /* ensure a valid numeric value */
	      this.value = isNaN(value) ? 0 : !isFinite(value) ? (value < 0 ? -3.4e+38 : +3.4e+38) : value
	  
	    } else if (typeof value === 'string') {
	      var match = value.match(SVG.regex.unit)
	  
	      if (match) {
	        /* make value numeric */
	        this.value = parseFloat(match[1])
	      
	        /* normalize percent value */
	        if (match[2] == '%')
	          this.value /= 100
	        else if (match[2] == 's')
	          this.value *= 1000
	      
	        /* store unit */
	        this.unit = match[2]
	      }
	  
	    } else {
	      if (value instanceof SVG.Number) {
	        this.value = value.value
	        this.unit  = value.unit
	      }
	    }
	  
	  }
	  
	  SVG.extend(SVG.Number, {
	    // Stringalize
	    toString: function() {
	      return (
	        this.unit == '%' ?
	          ~~(this.value * 1e8) / 1e6:
	        this.unit == 's' ?
	          this.value / 1e3 :
	          this.value
	      ) + this.unit
	    }
	  , // Convert to primitive
	    valueOf: function() {
	      return this.value
	    }
	    // Add number
	  , plus: function(number) {
	      this.value = this + new SVG.Number(number)
	  
	      return this
	    }
	    // Subtract number
	  , minus: function(number) {
	      return this.plus(-new SVG.Number(number))
	    }
	    // Multiply number
	  , times: function(number) {
	      this.value = this * new SVG.Number(number)
	  
	      return this
	    }
	    // Divide number
	  , divide: function(number) {
	      this.value = this / new SVG.Number(number)
	  
	      return this
	    }
	    // Convert to different unit
	  , to: function(unit) {
	      if (typeof unit === 'string')
	        this.unit = unit
	  
	      return this
	    }
	    // Make number morphable
	  , morph: function(number) {
	      this.destination = new SVG.Number(number)
	  
	      return this
	    }
	    // Get morphed number at given position
	  , at: function(pos) {
	      /* make sure a destination is defined */
	      if (!this.destination) return this
	  
	      /* generate new morphed number */
	      return new SVG.Number(this.destination)
	          .minus(this)
	          .times(pos)
	          .plus(this)
	    }
	  
	  })

	  SVG.ViewBox = function(element) {
	    var x, y, width, height
	      , wm   = 1 /* width multiplier */
	      , hm   = 1 /* height multiplier */
	      , box  = element.bbox()
	      , view = (element.attr('viewBox') || '').match(/-?[\d\.]+/g)
	      , we   = element
	      , he   = element
	  
	    /* get dimensions of current node */
	    width  = new SVG.Number(element.width())
	    height = new SVG.Number(element.height())
	  
	    /* find nearest non-percentual dimensions */
	    while (width.unit == '%') {
	      wm *= width.value
	      width = new SVG.Number(we instanceof SVG.Doc ? we.parent.offsetWidth : we.parent.width())
	      we = we.parent
	    }
	    while (height.unit == '%') {
	      hm *= height.value
	      height = new SVG.Number(he instanceof SVG.Doc ? he.parent.offsetHeight : he.parent.height())
	      he = he.parent
	    }
	    
	    /* ensure defaults */
	    this.x      = box.x
	    this.y      = box.y
	    this.width  = width  * wm
	    this.height = height * hm
	    this.zoom   = 1
	    
	    if (view) {
	      /* get width and height from viewbox */
	      x      = parseFloat(view[0])
	      y      = parseFloat(view[1])
	      width  = parseFloat(view[2])
	      height = parseFloat(view[3])
	      
	      /* calculate zoom accoring to viewbox */
	      this.zoom = ((this.width / this.height) > (width / height)) ?
	        this.height / height :
	        this.width  / width
	  
	      /* calculate real pixel dimensions on parent SVG.Doc element */
	      this.x      = x
	      this.y      = y
	      this.width  = width
	      this.height = height
	      
	    }
	    
	  }
	  
	  //
	  SVG.extend(SVG.ViewBox, {
	    // Parse viewbox to string
	    toString: function() {
	      return this.x + ' ' + this.y + ' ' + this.width + ' ' + this.height
	    }
	    
	  })

	  SVG.BBox = function(element) {
	    var box
	  
	    /* initialize zero box */
	    this.x      = 0
	    this.y      = 0
	    this.width  = 0
	    this.height = 0
	    
	    /* get values if element is given */
	    if (element) {
	      try {
	        /* actual, native bounding box */
	        box = element.node.getBBox()
	      } catch(e) {
	        /* fallback for some browsers */
	        box = {
	          x:      element.node.clientLeft
	        , y:      element.node.clientTop
	        , width:  element.node.clientWidth
	        , height: element.node.clientHeight
	        }
	      }
	      
	      /* include translations on x an y */
	      this.x = box.x + element.trans.x
	      this.y = box.y + element.trans.y
	      
	      /* plain width and height */
	      this.width  = box.width  * element.trans.scaleX
	      this.height = box.height * element.trans.scaleY
	    }
	  
	    /* add center, right and bottom */
	    boxProperties(this)
	    
	  }
	  
	  //
	  SVG.extend(SVG.BBox, {
	    // merge bounding box with another, return a new instance
	    merge: function(box) {
	      var b = new SVG.BBox()
	  
	      /* merge box */
	      b.x      = Math.min(this.x, box.x)
	      b.y      = Math.min(this.y, box.y)
	      b.width  = Math.max(this.x + this.width,  box.x + box.width)  - b.x
	      b.height = Math.max(this.y + this.height, box.y + box.height) - b.y
	  
	      /* add center, right and bottom */
	      boxProperties(b)
	  
	      return b
	    }
	  
	  })

	  SVG.RBox = function(element) {
	    var e, zoom
	      , box = {}
	  
	    /* initialize zero box */
	    this.x      = 0
	    this.y      = 0
	    this.width  = 0
	    this.height = 0
	    
	    if (element) {
	      e = element.doc().parent
	      zoom = element.doc().viewbox().zoom
	      
	      /* actual, native bounding box */
	      box = element.node.getBoundingClientRect()
	      
	      /* get screen offset */
	      this.x = box.left
	      this.y = box.top
	      
	      /* subtract parent offset */
	      this.x -= e.offsetLeft
	      this.y -= e.offsetTop
	      
	      while (e = e.offsetParent) {
	        this.x -= e.offsetLeft
	        this.y -= e.offsetTop
	      }
	      
	      /* calculate cumulative zoom from svg documents */
	      e = element
	      while (e = e.parent) {
	        if (e.type == 'svg' && e.viewbox) {
	          zoom *= e.viewbox().zoom
	          this.x -= e.x() || 0
	          this.y -= e.y() || 0
	        }
	      }
	    }
	    
	    /* recalculate viewbox distortion */
	    this.x /= zoom
	    this.y /= zoom
	    this.width  = box.width  /= zoom
	    this.height = box.height /= zoom
	    
	    /* offset by window scroll position, because getBoundingClientRect changes when window is scrolled */
	    this.x += typeof window.scrollX === 'number' ? window.scrollX : window.pageXOffset
	    this.y += typeof window.scrollY === 'number' ? window.scrollY : window.pageYOffset
	  
	    /* add center, right and bottom */
	    boxProperties(this)
	    
	  }
	  
	  //
	  SVG.extend(SVG.RBox, {
	    // merge rect box with another, return a new instance
	    merge: function(box) {
	      var b = new SVG.RBox()
	  
	      /* merge box */
	      b.x      = Math.min(this.x, box.x)
	      b.y      = Math.min(this.y, box.y)
	      b.width  = Math.max(this.x + this.width,  box.x + box.width)  - b.x
	      b.height = Math.max(this.y + this.height, box.y + box.height) - b.y
	  
	      /* add center, right and bottom */
	      boxProperties(b)
	  
	      return b
	    }
	  
	  })


	  SVG.Element = SVG.invent({
	    // Initialize node
	    create: function(node) {
	      /* make stroke value accessible dynamically */
	      this._stroke = SVG.defaults.attrs.stroke
	  
	      /* initialize transformation store with defaults */
	      this.trans = SVG.defaults.trans()
	      
	      /* create circular reference */
	      if (this.node = node) {
	        this.type = node.nodeName
	        this.node.instance = this
	      }
	    }
	  
	    // Add class methods
	  , extend: {
	      // Move over x-axis
	      x: function(x) {
	        if (x != null) {
	          x = new SVG.Number(x)
	          x.value /= this.trans.scaleX
	        }
	        return this.attr('x', x)
	      }
	      // Move over y-axis
	    , y: function(y) {
	        if (y != null) {
	          y = new SVG.Number(y)
	          y.value /= this.trans.scaleY
	        }
	        return this.attr('y', y)
	      }
	      // Move by center over x-axis
	    , cx: function(x) {
	        return x == null ? this.x() + this.width() / 2 : this.x(x - this.width() / 2)
	      }
	      // Move by center over y-axis
	    , cy: function(y) {
	        return y == null ? this.y() + this.height() / 2 : this.y(y - this.height() / 2)
	      }
	      // Move element to given x and y values
	    , move: function(x, y) {
	        return this.x(x).y(y)
	      }
	      // Move element by its center
	    , center: function(x, y) {
	        return this.cx(x).cy(y)
	      }
	      // Set width of element
	    , width: function(width) {
	        return this.attr('width', width)
	      }
	      // Set height of element
	    , height: function(height) {
	        return this.attr('height', height)
	      }
	      // Set element size to given width and height
	    , size: function(width, height) {
	        var p = proportionalSize(this.bbox(), width, height)
	  
	        return this
	          .width(new SVG.Number(p.width))
	          .height(new SVG.Number(p.height))
	      }
	      // Clone element
	    , clone: function() {
	        var clone , attr
	          , type = this.type
	        
	        /* invoke shape method with shape-specific arguments */
	        clone = type == 'rect' || type == 'ellipse' ?
	          this.parent[type](0,0) :
	        type == 'line' ?
	          this.parent[type](0,0,0,0) :
	        type == 'image' ?
	          this.parent[type](this.src) :
	        type == 'text' ?
	          this.parent[type](this.content) :
	        type == 'path' ?
	          this.parent[type](this.attr('d')) :
	        type == 'polyline' || type == 'polygon' ?
	          this.parent[type](this.attr('points')) :
	        type == 'g' ?
	          this.parent.group() :
	          this.parent[type]()
	        
	        /* apply attributes attributes */
	        attr = this.attr()
	        delete attr.id
	        clone.attr(attr)
	        
	        /* copy transformations */
	        clone.trans = this.trans
	        
	        /* apply attributes and translations */
	        return clone.transform({})
	      }
	      // Remove element
	    , remove: function() {
	        if (this.parent)
	          this.parent.removeElement(this)
	        
	        return this
	      }
	      // Replace element
	    , replace: function(element) {
	        this.after(element).remove()
	  
	        return element
	      }
	      // Add element to given container and return self
	    , addTo: function(parent) {
	        return parent.put(this)
	      }
	      // Add element to given container and return container
	    , putIn: function(parent) {
	        return parent.add(this)
	      }
	      // Get parent document
	    , doc: function(type) {
	        return this._parent(type || SVG.Doc)
	      }
	      // Set svg element attribute
	    , attr: function(a, v, n) {
	        if (a == null) {
	          /* get an object of attributes */
	          a = {}
	          v = this.node.attributes
	          for (n = v.length - 1; n >= 0; n--)
	            a[v[n].nodeName] = SVG.regex.isNumber.test(v[n].nodeValue) ? parseFloat(v[n].nodeValue) : v[n].nodeValue
	          
	          return a
	          
	        } else if (typeof a == 'object') {
	          /* apply every attribute individually if an object is passed */
	          for (v in a) this.attr(v, a[v])
	          
	        } else if (v === null) {
	            /* remove value */
	            this.node.removeAttribute(a)
	          
	        } else if (v == null) {
	          /* act as a getter if the first and only argument is not an object */
	          v = this.node.attributes[a]
	          return v == null ? 
	            SVG.defaults.attrs[a] :
	          SVG.regex.isNumber.test(v.nodeValue) ?
	            parseFloat(v.nodeValue) : v.nodeValue
	        
	        } else if (a == 'style') {
	          /* redirect to the style method */
	          return this.style(v)
	        
	        } else {
	          /* BUG FIX: some browsers will render a stroke if a color is given even though stroke width is 0 */
	          if (a == 'stroke-width')
	            this.attr('stroke', parseFloat(v) > 0 ? this._stroke : null)
	          else if (a == 'stroke')
	            this._stroke = v
	  
	          /* convert image fill and stroke to patterns */
	          if (a == 'fill' || a == 'stroke') {
	            if (SVG.regex.isImage.test(v))
	              v = this.doc().defs().image(v, 0, 0)
	  
	            if (v instanceof SVG.Image)
	              v = this.doc().defs().pattern(0, 0, function() {
	                this.add(v)
	              })
	          }
	          
	          /* ensure correct numeric values (also accepts NaN and Infinity) */
	          if (typeof v === 'number')
	            v = new SVG.Number(v)
	  
	          /* ensure full hex color */
	          else if (SVG.Color.isColor(v))
	            v = new SVG.Color(v)
	          
	          /* parse array values */
	          else if (Array.isArray(v))
	            v = new SVG.Array(v)
	  
	          /* if the passed attribute is leading... */
	          if (a == 'leading') {
	            /* ... call the leading method instead */
	            if (this.leading)
	              this.leading(v)
	          } else {
	            /* set given attribute on node */
	            typeof n === 'string' ?
	              this.node.setAttributeNS(n, a, v.toString()) :
	              this.node.setAttribute(a, v.toString())
	          }
	          
	          /* rebuild if required */
	          if (this.rebuild && (a == 'font-size' || a == 'x'))
	            this.rebuild(a, v)
	        }
	        
	        return this
	      }
	      // Manage transformations
	    , transform: function(o, v) {
	        
	        if (arguments.length == 0) {
	          /* act as a getter if no argument is given */
	          return this.trans
	          
	        } else if (typeof o === 'string') {
	          /* act as a getter if only one string argument is given */
	          if (arguments.length < 2)
	            return this.trans[o]
	          
	          /* apply transformations as object if key value arguments are given*/
	          var transform = {}
	          transform[o] = v
	          
	          return this.transform(transform)
	        }
	        
	        /* ... otherwise continue as a setter */
	        var transform = []
	        
	        /* parse matrix */
	        o = parseMatrix(o)
	        
	        /* merge values */
	        for (v in o)
	          if (o[v] != null)
	            this.trans[v] = o[v]
	        
	        /* compile matrix */
	        this.trans.matrix = this.trans.a
	                    + ' ' + this.trans.b
	                    + ' ' + this.trans.c
	                    + ' ' + this.trans.d
	                    + ' ' + this.trans.e
	                    + ' ' + this.trans.f
	        
	        /* alias current transformations */
	        o = this.trans
	        
	        /* add matrix */
	        if (o.matrix != SVG.defaults.matrix)
	          transform.push('matrix(' + o.matrix + ')')
	        
	        /* add rotation */
	        if (o.rotation != 0)
	          transform.push('rotate(' + o.rotation + ' ' + (o.cx == null ? this.bbox().cx : o.cx) + ' ' + (o.cy == null ? this.bbox().cy : o.cy) + ')')
	        
	        /* add scale */
	        if (o.scaleX != 1 || o.scaleY != 1)
	          transform.push('scale(' + o.scaleX + ' ' + o.scaleY + ')')
	        
	        /* add skew on x axis */
	        if (o.skewX != 0)
	          transform.push('skewX(' + o.skewX + ')')
	        
	        /* add skew on y axis */
	        if (o.skewY != 0)
	          transform.push('skewY(' + o.skewY + ')')
	        
	        /* add translation */
	        if (o.x != 0 || o.y != 0)
	          transform.push('translate(' + new SVG.Number(o.x / o.scaleX) + ' ' + new SVG.Number(o.y / o.scaleY) + ')')
	        
	        /* update transformations, even if there are none */
	        if (transform.length == 0)
	          this.node.removeAttribute('transform')
	        else
	          this.node.setAttribute('transform', transform.join(' '))
	        
	        return this
	      }
	      // Dynamic style generator
	    , style: function(s, v) {
	        if (arguments.length == 0) {
	          /* get full style */
	          return this.node.style.cssText || ''
	        
	        } else if (arguments.length < 2) {
	          /* apply every style individually if an object is passed */
	          if (typeof s == 'object') {
	            for (v in s) this.style(v, s[v])
	          
	          } else if (SVG.regex.isCss.test(s)) {
	            /* parse css string */
	            s = s.split(';')
	  
	            /* apply every definition individually */
	            for (var i = 0; i < s.length; i++) {
	              v = s[i].split(':')
	              this.style(v[0].replace(/\s+/g, ''), v[1])
	            }
	          } else {
	            /* act as a getter if the first and only argument is not an object */
	            return this.node.style[camelCase(s)]
	          }
	        
	        } else {
	          this.node.style[camelCase(s)] = v === null || SVG.regex.isBlank.test(v) ? '' : v
	        }
	        
	        return this
	      }
	      // Get / set id
	    , id: function(id) {
	        return this.attr('id', id)
	      }
	      // Get bounding box
	    , bbox: function() {
	        return new SVG.BBox(this)
	      }
	      // Get rect box
	    , rbox: function() {
	        return new SVG.RBox(this)
	      }
	      // Checks whether the given point inside the bounding box of the element
	    , inside: function(x, y) {
	        var box = this.bbox()
	        
	        return x > box.x
	            && y > box.y
	            && x < box.x + box.width
	            && y < box.y + box.height
	      }
	      // Show element
	    , show: function() {
	        return this.style('display', '')
	      }
	      // Hide element
	    , hide: function() {
	        return this.style('display', 'none')
	      }
	      // Is element visible?
	    , visible: function() {
	        return this.style('display') != 'none'
	      }
	      // Return id on string conversion
	    , toString: function() {
	        return this.attr('id')
	      }
	      // Return array of classes on the node
	    , classes: function() {
	        var classAttr = this.node.getAttribute('class')
	        if (classAttr === null) {
	          return []
	        } else {
	          return classAttr.trim().split(/\s+/)
	        }
	      }
	      // Return true if class exists on the node, false otherwise
	    , hasClass: function(className) {
	        return this.classes().indexOf(className) != -1
	      }
	      // Add class to the node
	    , addClass: function(className) {
	        var classArray
	        if (!(this.hasClass(className))) {
	          classArray = this.classes()
	          classArray.push(className)
	          this.node.setAttribute('class', classArray.join(' '))
	        }
	        return this
	      }
	      // Remove class from the node
	    , removeClass: function(className) {
	        var classArray
	        if (this.hasClass(className)) {
	          classArray = this.classes().filter(function(c) {
	            return c != className
	          })
	          this.node.setAttribute('class', classArray.join(' '))
	        }
	        return this
	      }
	      // Toggle the presence of a class on the node
	    , toggleClass: function(className) {
	        if (this.hasClass(className)) {
	          this.removeClass(className)
	        } else {
	          this.addClass(className)
	        }
	        return this
	      }
	      // Get referenced element form attribute value
	    , reference: function(attr) {
	        return SVG.get(this.attr()[attr])
	      }
	      // Private: find svg parent by instance
	    , _parent: function(parent) {
	        var element = this
	        
	        while (element != null && !(element instanceof parent))
	          element = element.parent
	  
	        return element
	      }
	    }
	  })


	  SVG.Parent = SVG.invent({
	    // Initialize node
	    create: function(element) {
	      this.constructor.call(this, element)
	    }
	  
	    // Inherit from
	  , inherit: SVG.Element
	  
	    // Add class methods
	  , extend: {
	      // Returns all child elements
	      children: function() {
	        return this._children || (this._children = [])
	      }
	      // Add given element at a position
	    , add: function(element, i) {
	        if (!this.has(element)) {
	          /* define insertion index if none given */
	          i = i == null ? this.children().length : i
	          
	          /* remove references from previous parent */
	          if (element.parent)
	            element.parent.children().splice(element.parent.index(element), 1)
	          
	          /* add element references */
	          this.children().splice(i, 0, element)
	          this.node.insertBefore(element.node, this.node.childNodes[i] || null)
	          element.parent = this
	        }
	  
	        /* reposition defs */
	        if (this._defs) {
	          this.node.removeChild(this._defs.node)
	          this.node.appendChild(this._defs.node)
	        }
	        
	        return this
	      }
	      // Basically does the same as `add()` but returns the added element instead
	    , put: function(element, i) {
	        this.add(element, i)
	        return element
	      }
	      // Checks if the given element is a child
	    , has: function(element) {
	        return this.index(element) >= 0
	      }
	      // Gets index of given element
	    , index: function(element) {
	        return this.children().indexOf(element)
	      }
	      // Get a element at the given index
	    , get: function(i) {
	        return this.children()[i]
	      }
	      // Get first child, skipping the defs node
	    , first: function() {
	        return this.children()[0]
	      }
	      // Get the last child
	    , last: function() {
	        return this.children()[this.children().length - 1]
	      }
	      // Iterates over all children and invokes a given block
	    , each: function(block, deep) {
	        var i, il
	          , children = this.children()
	        
	        for (i = 0, il = children.length; i < il; i++) {
	          if (children[i] instanceof SVG.Element)
	            block.apply(children[i], [i, children])
	  
	          if (deep && (children[i] instanceof SVG.Container))
	            children[i].each(block, deep)
	        }
	      
	        return this
	      }
	      // Remove a child element at a position
	    , removeElement: function(element) {
	        this.children().splice(this.index(element), 1)
	        this.node.removeChild(element.node)
	        element.parent = null
	        
	        return this
	      }
	      // Remove all elements in this container
	    , clear: function() {
	        /* remove children */
	        for (var i = this.children().length - 1; i >= 0; i--)
	          this.removeElement(this.children()[i])
	  
	        /* remove defs node */
	        if (this._defs)
	          this._defs.clear()
	  
	        return this
	      }
	     , // Get defs
	      defs: function() {
	        return this.doc().defs()
	      }
	    }
	    
	  })


	  SVG.Container = SVG.invent({
	    // Initialize node
	    create: function(element) {
	      this.constructor.call(this, element)
	    }
	  
	    // Inherit from
	  , inherit: SVG.Parent
	  
	    // Add class methods
	  , extend: {
	      // Get the viewBox and calculate the zoom value
	      viewbox: function(v) {
	        if (arguments.length == 0)
	          /* act as a getter if there are no arguments */
	          return new SVG.ViewBox(this)
	        
	        /* otherwise act as a setter */
	        v = arguments.length == 1 ?
	          [v.x, v.y, v.width, v.height] :
	          [].slice.call(arguments)
	        
	        return this.attr('viewBox', v)
	      }
	    }
	    
	  })

	  SVG.FX = SVG.invent({
	    // Initialize FX object
	    create: function(element) {
	      /* store target element */
	      this.target = element
	    }
	  
	    // Add class methods
	  , extend: {
	      // Add animation parameters and start animation
	      animate: function(d, ease, delay) {
	        var akeys, tkeys, skeys, key
	          , element = this.target
	          , fx = this
	        
	        /* dissect object if one is passed */
	        if (typeof d == 'object') {
	          delay = d.delay
	          ease = d.ease
	          d = d.duration
	        }
	  
	        /* ensure default duration and easing */
	        d = d == '=' ? d : d == null ? 1000 : new SVG.Number(d).valueOf()
	        ease = ease || '<>'
	  
	        /* process values */
	        fx.to = function(pos) {
	          var i
	  
	          /* normalise pos */
	          pos = pos < 0 ? 0 : pos > 1 ? 1 : pos
	  
	          /* collect attribute keys */
	          if (akeys == null) {
	            akeys = []
	            for (key in fx.attrs)
	              akeys.push(key)
	  
	            /* make sure morphable elements are scaled, translated and morphed all together */
	            if (element.morphArray && (fx._plot || akeys.indexOf('points') > -1)) {
	              /* get destination */
	              var box
	                , p = new element.morphArray(fx._plot || fx.attrs.points || element.array)
	  
	              /* add size */
	              if (fx._size) p.size(fx._size.width.to, fx._size.height.to)
	  
	              /* add movement */
	              box = p.bbox()
	              if (fx._x) p.move(fx._x.to, box.y)
	              else if (fx._cx) p.move(fx._cx.to - box.width / 2, box.y)
	  
	              box = p.bbox()
	              if (fx._y) p.move(box.x, fx._y.to)
	              else if (fx._cy) p.move(box.x, fx._cy.to - box.height / 2)
	  
	              /* delete element oriented changes */
	              delete fx._x
	              delete fx._y
	              delete fx._cx
	              delete fx._cy
	              delete fx._size
	  
	              fx._plot = element.array.morph(p)
	            }
	          }
	  
	          /* collect transformation keys */
	          if (tkeys == null) {
	            tkeys = []
	            for (key in fx.trans)
	              tkeys.push(key)
	          }
	  
	          /* collect style keys */
	          if (skeys == null) {
	            skeys = []
	            for (key in fx.styles)
	              skeys.push(key)
	          }
	  
	          /* apply easing */
	          pos = ease == '<>' ?
	            (-Math.cos(pos * Math.PI) / 2) + 0.5 :
	          ease == '>' ?
	            Math.sin(pos * Math.PI / 2) :
	          ease == '<' ?
	            -Math.cos(pos * Math.PI / 2) + 1 :
	          ease == '-' ?
	            pos :
	          typeof ease == 'function' ?
	            ease(pos) :
	            pos
	          
	          /* run plot function */
	          if (fx._plot) {
	            element.plot(fx._plot.at(pos))
	  
	          } else {
	            /* run all x-position properties */
	            if (fx._x)
	              element.x(fx._x.at(pos))
	            else if (fx._cx)
	              element.cx(fx._cx.at(pos))
	  
	            /* run all y-position properties */
	            if (fx._y)
	              element.y(fx._y.at(pos))
	            else if (fx._cy)
	              element.cy(fx._cy.at(pos))
	  
	            /* run all size properties */
	            if (fx._size)
	              element.size(fx._size.width.at(pos), fx._size.height.at(pos))
	          }
	  
	          /* run all viewbox properties */
	          if (fx._viewbox)
	            element.viewbox(
	              fx._viewbox.x.at(pos)
	            , fx._viewbox.y.at(pos)
	            , fx._viewbox.width.at(pos)
	            , fx._viewbox.height.at(pos)
	            )
	  
	          /* run leading property */
	          if (fx._leading)
	            element.leading(fx._leading.at(pos))
	  
	          /* animate attributes */
	          for (i = akeys.length - 1; i >= 0; i--)
	            element.attr(akeys[i], at(fx.attrs[akeys[i]], pos))
	  
	          /* animate transformations */
	          for (i = tkeys.length - 1; i >= 0; i--)
	            element.transform(tkeys[i], at(fx.trans[tkeys[i]], pos))
	  
	          /* animate styles */
	          for (i = skeys.length - 1; i >= 0; i--)
	            element.style(skeys[i], at(fx.styles[skeys[i]], pos))
	  
	          /* callback for each keyframe */
	          if (fx._during)
	            fx._during.call(element, pos, function(from, to) {
	              return at({ from: from, to: to }, pos)
	            })
	        }
	        
	        if (typeof d === 'number') {
	          /* delay animation */
	          this.timeout = setTimeout(function() {
	            var start = new Date().getTime()
	  
	            /* initialize situation object */
	            fx.situation = {
	              interval: 1000 / 60
	            , start:    start
	            , play:     true
	            , finish:   start + d
	            , duration: d
	            }
	  
	            /* render function */
	            fx.render = function() {
	              
	              if (fx.situation.play === true) {
	                // This code was borrowed from the emile.js micro framework by Thomas Fuchs, aka MadRobby.
	                var time = new Date().getTime()
	                  , pos = time > fx.situation.finish ? 1 : (time - fx.situation.start) / d
	                
	                /* process values */
	                fx.to(pos)
	                
	                /* finish off animation */
	                if (time > fx.situation.finish) {
	                  if (fx._plot)
	                    element.plot(new SVG.PointArray(fx._plot.destination).settle())
	  
	                  if (fx._loop === true || (typeof fx._loop == 'number' && fx._loop > 1)) {
	                    if (typeof fx._loop == 'number')
	                      --fx._loop
	                    fx.animate(d, ease, delay)
	                  } else {
	                    fx._after ? fx._after.apply(element, [fx]) : fx.stop()
	                  }
	  
	                } else {
	                  requestAnimFrame(fx.render)
	                }
	              } else {
	                requestAnimFrame(fx.render)
	              }
	              
	            }
	  
	            /* start animation */
	            fx.render()
	            
	          }, new SVG.Number(delay).valueOf())
	        }
	        
	        return this
	      }
	      // Get bounding box of target element
	    , bbox: function() {
	        return this.target.bbox()
	      }
	      // Add animatable attributes
	    , attr: function(a, v) {
	        if (typeof a == 'object') {
	          for (var key in a)
	            this.attr(key, a[key])
	        
	        } else {
	          var from = this.target.attr(a)
	  
	          this.attrs[a] = SVG.Color.isColor(from) ?
	            new SVG.Color(from).morph(v) :
	          SVG.regex.unit.test(from) ?
	            new SVG.Number(from).morph(v) :
	            { from: from, to: v }
	        }
	        
	        return this
	      }
	      // Add animatable transformations
	    , transform: function(o, v) {
	        if (arguments.length == 1) {
	          /* parse matrix string */
	          o = parseMatrix(o)
	          
	          /* dlete matrixstring from object */
	          delete o.matrix
	          
	          /* store matrix values */
	          for (v in o)
	            this.trans[v] = { from: this.target.trans[v], to: o[v] }
	          
	        } else {
	          /* apply transformations as object if key value arguments are given*/
	          var transform = {}
	          transform[o] = v
	          
	          this.transform(transform)
	        }
	        
	        return this
	      }
	      // Add animatable styles
	    , style: function(s, v) {
	        if (typeof s == 'object')
	          for (var key in s)
	            this.style(key, s[key])
	        
	        else
	          this.styles[s] = { from: this.target.style(s), to: v }
	        
	        return this
	      }
	      // Animatable x-axis
	    , x: function(x) {
	        this._x = new SVG.Number(this.target.x()).morph(x)
	        
	        return this
	      }
	      // Animatable y-axis
	    , y: function(y) {
	        this._y = new SVG.Number(this.target.y()).morph(y)
	        
	        return this
	      }
	      // Animatable center x-axis
	    , cx: function(x) {
	        this._cx = new SVG.Number(this.target.cx()).morph(x)
	        
	        return this
	      }
	      // Animatable center y-axis
	    , cy: function(y) {
	        this._cy = new SVG.Number(this.target.cy()).morph(y)
	        
	        return this
	      }
	      // Add animatable move
	    , move: function(x, y) {
	        return this.x(x).y(y)
	      }
	      // Add animatable center
	    , center: function(x, y) {
	        return this.cx(x).cy(y)
	      }
	      // Add animatable size
	    , size: function(width, height) {
	        if (this.target instanceof SVG.Text) {
	          /* animate font size for Text elements */
	          this.attr('font-size', width)
	          
	        } else {
	          /* animate bbox based size for all other elements */
	          var box = this.target.bbox()
	  
	          this._size = {
	            width:  new SVG.Number(box.width).morph(width)
	          , height: new SVG.Number(box.height).morph(height)
	          }
	        }
	        
	        return this
	      }
	      // Add animatable plot
	    , plot: function(p) {
	        this._plot = p
	  
	        return this
	      }
	      // Add leading method
	    , leading: function(value) {
	        if (this.target._leading)
	          this._leading = new SVG.Number(this.target._leading).morph(value)
	  
	        return this
	      }
	      // Add animatable viewbox
	    , viewbox: function(x, y, width, height) {
	        if (this.target instanceof SVG.Container) {
	          var box = this.target.viewbox()
	          
	          this._viewbox = {
	            x:      new SVG.Number(box.x).morph(x)
	          , y:      new SVG.Number(box.y).morph(y)
	          , width:  new SVG.Number(box.width).morph(width)
	          , height: new SVG.Number(box.height).morph(height)
	          }
	        }
	        
	        return this
	      }
	      // Add animateable gradient update
	    , update: function(o) {
	        if (this.target instanceof SVG.Stop) {
	          if (o.opacity != null) this.attr('stop-opacity', o.opacity)
	          if (o.color   != null) this.attr('stop-color', o.color)
	          if (o.offset  != null) this.attr('offset', new SVG.Number(o.offset))
	        }
	  
	        return this
	      }
	      // Add callback for each keyframe
	    , during: function(during) {
	        this._during = during
	        
	        return this
	      }
	      // Callback after animation
	    , after: function(after) {
	        this._after = after
	        
	        return this
	      }
	      // Make loopable
	    , loop: function(times) {
	        this._loop = times || true
	  
	        return this
	      }
	      // Stop running animation
	    , stop: function(fulfill) {
	        /* fulfill animation */
	        if (fulfill === true) {
	  
	          this.animate(0)
	  
	          if (this._after)
	            this._after.apply(this.target, [this])
	  
	        } else {
	          /* stop current animation */
	          clearTimeout(this.timeout)
	  
	          /* reset storage for properties that need animation */
	          this.attrs     = {}
	          this.trans     = {}
	          this.styles    = {}
	          this.situation = {}
	  
	          /* delete destinations */
	          delete this._x
	          delete this._y
	          delete this._cx
	          delete this._cy
	          delete this._size
	          delete this._plot
	          delete this._loop
	          delete this._after
	          delete this._during
	          delete this._leading
	          delete this._viewbox
	        }
	        
	        return this
	      }
	      // Pause running animation
	    , pause: function() {
	        if (this.situation.play === true) {
	          this.situation.play  = false
	          this.situation.pause = new Date().getTime()
	        }
	  
	        return this
	      }
	      // Play running animation
	    , play: function() {
	        if (this.situation.play === false) {
	          var pause = new Date().getTime() - this.situation.pause
	          
	          this.situation.finish += pause
	          this.situation.start  += pause
	          this.situation.play    = true
	        }
	  
	        return this
	      }
	      
	    }
	  
	    // Define parent class
	  , parent: SVG.Element
	  
	    // Add method to parent elements
	  , construct: {
	      // Get fx module or create a new one, then animate with given duration and ease
	      animate: function(d, ease, delay) {
	        return (this.fx || (this.fx = new SVG.FX(this))).stop().animate(d, ease, delay)
	      }
	      // Stop current animation; this is an alias to the fx instance
	    , stop: function(fulfill) {
	        if (this.fx)
	          this.fx.stop(fulfill)
	        
	        return this
	      }
	      // Pause current animation
	    , pause: function() {
	        if (this.fx)
	          this.fx.pause()
	  
	        return this
	      }
	      // Play paused current animation
	    , play: function() {
	        if (this.fx)
	          this.fx.play()
	  
	        return this
	      }
	      
	    }
	  })


	  SVG.extend(SVG.Element, SVG.FX, {
	    // Relative move over x axis
	    dx: function(x) {
	      return this.x((this.target || this).x() + x)
	    }
	    // Relative move over y axis
	  , dy: function(y) {
	      return this.y((this.target || this).y() + y)
	    }
	    // Relative move over x and y axes
	  , dmove: function(x, y) {
	      return this.dx(x).dy(y)
	    }
	  
	  })

	  ;[  'click'
	    , 'dblclick'
	    , 'mousedown'
	    , 'mouseup'
	    , 'mouseover'
	    , 'mouseout'
	    , 'mousemove'
	    // , 'mouseenter' -> not supported by IE
	    // , 'mouseleave' -> not supported by IE
	    , 'touchstart'
	    , 'touchmove'
	    , 'touchleave'
	    , 'touchend'
	    , 'touchcancel' ].forEach(function(event) {
	    
	    /* add event to SVG.Element */
	    SVG.Element.prototype[event] = function(f) {
	      var self = this
	      
	      /* bind event to element rather than element node */
	      this.node['on' + event] = typeof f == 'function' ?
	        function() { return f.apply(self, arguments) } : null
	      
	      return this
	    }
	    
	  })
	  
	  // Initialize events and listeners stack
	  SVG.events = {}
	  SVG.listeners = {}
	  
	  // Event constructor
	  SVG.registerEvent = function(event) {
	    if (!SVG.events[event])
	      SVG.events[event] = new CustomEvent(event)
	  }
	  
	  // Add event binder in the SVG namespace
	  SVG.on = function(node, event, listener) {
	    // create listener
	    var l = listener.bind(node.instance || node)
	  
	    // ensure reference objects
	    SVG.listeners[node]        = SVG.listeners[node]        || {}
	    SVG.listeners[node][event] = SVG.listeners[node][event] || {}
	  
	    // reference listener
	    SVG.listeners[node][event][listener] = l
	  
	    // add listener
	    node.addEventListener(event, l, false)
	  }
	  
	  // Add event unbinder in the SVG namespace
	  SVG.off = function(node, event, listener) {
	    if (listener) {
	      // remove listener reference
	      if (SVG.listeners[node] && SVG.listeners[node][event]) {
	        // remove listener
	        node.removeEventListener(event, SVG.listeners[node][event][listener], false)
	  
	        delete SVG.listeners[node][event][listener]
	      }
	  
	    } else if (event) {
	      // remove all listeners for the event
	      if (SVG.listeners[node][event]) {
	        for (listener in SVG.listeners[node][event])
	          SVG.off(node, event, listener)
	  
	        delete SVG.listeners[node][event]
	      }
	  
	    } else {
	      // remove all listeners on a given node
	      if (SVG.listeners[node]) {
	        for (event in SVG.listeners[node])
	          SVG.off(node, event)
	  
	        delete SVG.listeners[node]
	      }
	    }
	  }
	  
	  //
	  SVG.extend(SVG.Element, {
	    // Bind given event to listener
	    on: function(event, listener) {
	      SVG.on(this.node, event, listener)
	      
	      return this
	    }
	    // Unbind event from listener
	  , off: function(event, listener) {
	      SVG.off(this.node, event, listener)
	      
	      return this
	    }
	    // Fire given event
	  , fire: function(event, data) {
	      // Add detail data to event
	      SVG.events[event].detail = data
	      
	      // Dispatch event
	      this.node.dispatchEvent(SVG.events[event])
	  
	      // Remove detail
	      delete SVG.events[event].detail
	  
	      return this
	    }
	  })

	  SVG.Defs = SVG.invent({
	    // Initialize node
	    create: 'defs'
	  
	    // Inherit from
	  , inherit: SVG.Container
	    
	  })

	  SVG.G = SVG.invent({
	    // Initialize node
	    create: 'g'
	  
	    // Inherit from
	  , inherit: SVG.Container
	    
	    // Add class methods
	  , extend: {
	      // Move over x-axis
	      x: function(x) {
	        return x == null ? this.trans.x : this.transform('x', x)
	      }
	      // Move over y-axis
	    , y: function(y) {
	        return y == null ? this.trans.y : this.transform('y', y)
	      }
	      // Move by center over x-axis
	    , cx: function(x) {
	        return x == null ? this.bbox().cx : this.x(x - this.bbox().width / 2)
	      }
	      // Move by center over y-axis
	    , cy: function(y) {
	        return y == null ? this.bbox().cy : this.y(y - this.bbox().height / 2)
	      }
	    }
	    
	    // Add parent method
	  , construct: {
	      // Create a group element
	      group: function() {
	        return this.put(new SVG.G)
	      }
	    }
	  })

	  SVG.extend(SVG.Element, {
	    // Get all siblings, including myself
	    siblings: function() {
	      return this.parent.children()
	    }
	    // Get the curent position siblings
	  , position: function() {
	      return this.parent.index(this)
	    }
	    // Get the next element (will return null if there is none)
	  , next: function() {
	      return this.siblings()[this.position() + 1]
	    }
	    // Get the next element (will return null if there is none)
	  , previous: function() {
	      return this.siblings()[this.position() - 1]
	    }
	    // Send given element one step forward
	  , forward: function() {
	      var i = this.position()
	      return this.parent.removeElement(this).put(this, i + 1)
	    }
	    // Send given element one step backward
	  , backward: function() {
	      var i = this.position()
	      
	      if (i > 0)
	        this.parent.removeElement(this).add(this, i - 1)
	  
	      return this
	    }
	    // Send given element all the way to the front
	  , front: function() {
	      return this.parent.removeElement(this).put(this)
	    }
	    // Send given element all the way to the back
	  , back: function() {
	      if (this.position() > 0)
	        this.parent.removeElement(this).add(this, 0)
	      
	      return this
	    }
	    // Inserts a given element before the targeted element
	  , before: function(element) {
	      element.remove()
	  
	      var i = this.position()
	      
	      this.parent.add(element, i)
	  
	      return this
	    }
	    // Insters a given element after the targeted element
	  , after: function(element) {
	      element.remove()
	      
	      var i = this.position()
	      
	      this.parent.add(element, i + 1)
	  
	      return this
	    }
	  
	  })

	  SVG.Mask = SVG.invent({
	    // Initialize node
	    create: function() {
	      this.constructor.call(this, SVG.create('mask'))
	  
	      /* keep references to masked elements */
	      this.targets = []
	    }
	  
	    // Inherit from
	  , inherit: SVG.Container
	  
	    // Add class methods
	  , extend: {
	      // Unmask all masked elements and remove itself
	      remove: function() {
	        /* unmask all targets */
	        for (var i = this.targets.length - 1; i >= 0; i--)
	          if (this.targets[i])
	            this.targets[i].unmask()
	        delete this.targets
	  
	        /* remove mask from parent */
	        this.parent.removeElement(this)
	        
	        return this
	      }
	    }
	    
	    // Add parent method
	  , construct: {
	      // Create masking element
	      mask: function() {
	        return this.defs().put(new SVG.Mask)
	      }
	    }
	  })
	  
	  
	  SVG.extend(SVG.Element, {
	    // Distribute mask to svg element
	    maskWith: function(element) {
	      /* use given mask or create a new one */
	      this.masker = element instanceof SVG.Mask ? element : this.parent.mask().add(element)
	  
	      /* store reverence on self in mask */
	      this.masker.targets.push(this)
	      
	      /* apply mask */
	      return this.attr('mask', 'url("#' + this.masker.attr('id') + '")')
	    }
	    // Unmask element
	  , unmask: function() {
	      delete this.masker
	      return this.attr('mask', null)
	    }
	    
	  })


	  SVG.Clip = SVG.invent({
	    // Initialize node
	    create: function() {
	      this.constructor.call(this, SVG.create('clipPath'))
	  
	      /* keep references to clipped elements */
	      this.targets = []
	    }
	  
	    // Inherit from
	  , inherit: SVG.Container
	  
	    // Add class methods
	  , extend: {
	      // Unclip all clipped elements and remove itself
	      remove: function() {
	        /* unclip all targets */
	        for (var i = this.targets.length - 1; i >= 0; i--)
	          if (this.targets[i])
	            this.targets[i].unclip()
	        delete this.targets
	  
	        /* remove clipPath from parent */
	        this.parent.removeElement(this)
	        
	        return this
	      }
	    }
	    
	    // Add parent method
	  , construct: {
	      // Create clipping element
	      clip: function() {
	        return this.defs().put(new SVG.Clip)
	      }
	    }
	  })
	  
	  //
	  SVG.extend(SVG.Element, {
	    // Distribute clipPath to svg element
	    clipWith: function(element) {
	      /* use given clip or create a new one */
	      this.clipper = element instanceof SVG.Clip ? element : this.parent.clip().add(element)
	  
	      /* store reverence on self in mask */
	      this.clipper.targets.push(this)
	      
	      /* apply mask */
	      return this.attr('clip-path', 'url("#' + this.clipper.attr('id') + '")')
	    }
	    // Unclip element
	  , unclip: function() {
	      delete this.clipper
	      return this.attr('clip-path', null)
	    }
	    
	  })

	  SVG.Gradient = SVG.invent({
	    // Initialize node
	    create: function(type) {
	      this.constructor.call(this, SVG.create(type + 'Gradient'))
	      
	      /* store type */
	      this.type = type
	    }
	  
	    // Inherit from
	  , inherit: SVG.Container
	  
	    // Add class methods
	  , extend: {
	      // From position
	      from: function(x, y) {
	        return this.type == 'radial' ?
	          this.attr({ fx: new SVG.Number(x), fy: new SVG.Number(y) }) :
	          this.attr({ x1: new SVG.Number(x), y1: new SVG.Number(y) })
	      }
	      // To position
	    , to: function(x, y) {
	        return this.type == 'radial' ?
	          this.attr({ cx: new SVG.Number(x), cy: new SVG.Number(y) }) :
	          this.attr({ x2: new SVG.Number(x), y2: new SVG.Number(y) })
	      }
	      // Radius for radial gradient
	    , radius: function(r) {
	        return this.type == 'radial' ?
	          this.attr({ r: new SVG.Number(r) }) :
	          this
	      }
	      // Add a color stop
	    , at: function(offset, color, opacity) {
	        return this.put(new SVG.Stop).update(offset, color, opacity)
	      }
	      // Update gradient
	    , update: function(block) {
	        /* remove all stops */
	        this.clear()
	        
	        /* invoke passed block */
	        if (typeof block == 'function')
	          block.call(this, this)
	        
	        return this
	      }
	      // Return the fill id
	    , fill: function() {
	        return 'url(#' + this.id() + ')'
	      }
	      // Alias string convertion to fill
	    , toString: function() {
	        return this.fill()
	      }
	    }
	    
	    // Add parent method
	  , construct: {
	      // Create gradient element in defs
	      gradient: function(type, block) {
	        return this.defs().gradient(type, block)
	      }
	    }
	  })
	  
	  SVG.extend(SVG.Defs, {
	    // define gradient
	    gradient: function(type, block) {
	      return this.put(new SVG.Gradient(type)).update(block)
	    }
	    
	  })
	  
	  SVG.Stop = SVG.invent({
	    // Initialize node
	    create: 'stop'
	  
	    // Inherit from
	  , inherit: SVG.Element
	  
	    // Add class methods
	  , extend: {
	      // add color stops
	      update: function(o) {
	        if (typeof o == 'number' || o instanceof SVG.Number) {
	          o = {
	            offset:  arguments[0]
	          , color:   arguments[1]
	          , opacity: arguments[2]
	          }
	        }
	  
	        /* set attributes */
	        if (o.opacity != null) this.attr('stop-opacity', o.opacity)
	        if (o.color   != null) this.attr('stop-color', o.color)
	        if (o.offset  != null) this.attr('offset', new SVG.Number(o.offset))
	  
	        return this
	      }
	    }
	  
	  })


	  SVG.Pattern = SVG.invent({
	    // Initialize node
	    create: 'pattern'
	  
	    // Inherit from
	  , inherit: SVG.Container
	  
	    // Add class methods
	  , extend: {
	      // Return the fill id
	  	  fill: function() {
	  	    return 'url(#' + this.id() + ')'
	  	  }
	  	  // Update pattern by rebuilding
	  	, update: function(block) {
	  			/* remove content */
	        this.clear()
	        
	        /* invoke passed block */
	        if (typeof block == 'function')
	        	block.call(this, this)
	        
	        return this
	  		}
	  	  // Alias string convertion to fill
	  	, toString: function() {
	  	    return this.fill()
	  	  }
	    }
	    
	    // Add parent method
	  , construct: {
	      // Create pattern element in defs
	  	  pattern: function(width, height, block) {
	  	    return this.defs().pattern(width, height, block)
	  	  }
	    }
	  })
	  
	  SVG.extend(SVG.Defs, {
	    // Define gradient
	    pattern: function(width, height, block) {
	      return this.put(new SVG.Pattern).update(block).attr({
	        x:            0
	      , y:            0
	      , width:        width
	      , height:       height
	      , patternUnits: 'userSpaceOnUse'
	      })
	    }
	  
	  })

	  SVG.Doc = SVG.invent({
	    // Initialize node
	    create: function(element) {
	      /* ensure the presence of a html element */
	      this.parent = typeof element == 'string' ?
	        document.getElementById(element) :
	        element
	      
	      /* If the target is an svg element, use that element as the main wrapper.
	         This allows svg.js to work with svg documents as well. */
	      this.constructor
	        .call(this, this.parent.nodeName == 'svg' ? this.parent : SVG.create('svg'))
	      
	      /* set svg element attributes */
	      this
	        .attr({ xmlns: SVG.ns, version: '1.1', width: '100%', height: '100%' })
	        .attr('xmlns:xlink', SVG.xlink, SVG.xmlns)
	      
	      /* create the <defs> node */
	      this._defs = new SVG.Defs
	      this._defs.parent = this
	      this.node.appendChild(this._defs.node)
	  
	      /* turn off sub pixel offset by default */
	      this.doSpof = false
	      
	      /* ensure correct rendering */
	      if (this.parent != this.node)
	        this.stage()
	    }
	  
	    // Inherit from
	  , inherit: SVG.Container
	  
	    // Add class methods
	  , extend: {
	      /* enable drawing */
	      stage: function() {
	        var element = this
	  
	        /* insert element */
	        this.parent.appendChild(this.node)
	  
	        /* fix sub-pixel offset */
	        element.spof()
	        
	        /* make sure sub-pixel offset is fixed every time the window is resized */
	        SVG.on(window, 'resize', function() {
	          element.spof()
	        })
	  
	        return this
	      }
	  
	      // Creates and returns defs element
	    , defs: function() {
	        return this._defs
	      }
	  
	      // Fix for possible sub-pixel offset. See:
	      // https://bugzilla.mozilla.org/show_bug.cgi?id=608812
	    , spof: function() {
	        if (this.doSpof) {
	          var pos = this.node.getScreenCTM()
	          
	          if (pos)
	            this
	              .style('left', (-pos.e % 1) + 'px')
	              .style('top',  (-pos.f % 1) + 'px')
	        }
	        
	        return this
	      }
	  
	      // Enable sub-pixel offset
	    , fixSubPixelOffset: function() {
	        this.doSpof = true
	  
	        return this
	      }
	    }
	    
	  })


	  SVG.Shape = SVG.invent({
	    // Initialize node
	    create: function(element) {
	  	  this.constructor.call(this, element)
	  	}
	  
	    // Inherit from
	  , inherit: SVG.Element
	  
	  })

	  SVG.Symbol = SVG.invent({
	    // Initialize node
	    create: 'symbol'
	  
	    // Inherit from
	  , inherit: SVG.Container
	  
	    // Add parent method
	  , construct: {
	      // Create a new symbol
	      symbol: function() {
	        return this.defs().put(new SVG.Symbol)
	      }
	    }
	    
	  })

	  SVG.Use = SVG.invent({
	    // Initialize node
	    create: 'use'
	  
	    // Inherit from
	  , inherit: SVG.Shape
	  
	    // Add class methods
	  , extend: {
	      // Use element as a reference
	      element: function(element) {
	        /* store target element */
	        this.target = element
	  
	        /* set lined element */
	        return this.attr('href', '#' + element, SVG.xlink)
	      }
	    }
	    
	    // Add parent method
	  , construct: {
	      // Create a use element
	      use: function(element) {
	        return this.put(new SVG.Use).element(element)
	      }
	    }
	  })

	  SVG.Rect = SVG.invent({
	  	// Initialize node
	    create: 'rect'
	  
	  	// Inherit from
	  , inherit: SVG.Shape
	  	
	  	// Add parent method
	  , construct: {
	    	// Create a rect element
	    	rect: function(width, height) {
	    	  return this.put(new SVG.Rect().size(width, height))
	    	}
	    	
	  	}
	  	
	  })

	  SVG.Ellipse = SVG.invent({
	    // Initialize node
	    create: 'ellipse'
	  
	    // Inherit from
	  , inherit: SVG.Shape
	  
	    // Add class methods
	  , extend: {
	      // Move over x-axis
	      x: function(x) {
	        return x == null ? this.cx() - this.attr('rx') : this.cx(x + this.attr('rx'))
	      }
	      // Move over y-axis
	    , y: function(y) {
	        return y == null ? this.cy() - this.attr('ry') : this.cy(y + this.attr('ry'))
	      }
	      // Move by center over x-axis
	    , cx: function(x) {
	        return x == null ? this.attr('cx') : this.attr('cx', new SVG.Number(x).divide(this.trans.scaleX))
	      }
	      // Move by center over y-axis
	    , cy: function(y) {
	        return y == null ? this.attr('cy') : this.attr('cy', new SVG.Number(y).divide(this.trans.scaleY))
	      }
	      // Set width of element
	    , width: function(width) {
	        return width == null ? this.attr('rx') * 2 : this.attr('rx', new SVG.Number(width).divide(2))
	      }
	      // Set height of element
	    , height: function(height) {
	        return height == null ? this.attr('ry') * 2 : this.attr('ry', new SVG.Number(height).divide(2))
	      }
	      // Custom size function
	    , size: function(width, height) {
	        var p = proportionalSize(this.bbox(), width, height)
	  
	        return this.attr({
	          rx: new SVG.Number(p.width).divide(2)
	        , ry: new SVG.Number(p.height).divide(2)
	        })
	      }
	      
	    }
	  
	    // Add parent method
	  , construct: {
	      // Create circle element, based on ellipse
	      circle: function(size) {
	        return this.ellipse(size, size)
	      }
	      // Create an ellipse
	    , ellipse: function(width, height) {
	        return this.put(new SVG.Ellipse).size(width, height).move(0, 0)
	      }
	      
	    }
	  
	  })

	  SVG.Line = SVG.invent({
	    // Initialize node
	    create: 'line'
	  
	    // Inherit from
	  , inherit: SVG.Shape
	  
	    // Add class methods
	  , extend: {
	      // Move over x-axis
	      x: function(x) {
	        var b = this.bbox()
	        
	        return x == null ? b.x : this.attr({
	          x1: this.attr('x1') - b.x + x
	        , x2: this.attr('x2') - b.x + x
	        })
	      }
	      // Move over y-axis
	    , y: function(y) {
	        var b = this.bbox()
	        
	        return y == null ? b.y : this.attr({
	          y1: this.attr('y1') - b.y + y
	        , y2: this.attr('y2') - b.y + y
	        })
	      }
	      // Move by center over x-axis
	    , cx: function(x) {
	        var half = this.bbox().width / 2
	        return x == null ? this.x() + half : this.x(x - half)
	      }
	      // Move by center over y-axis
	    , cy: function(y) {
	        var half = this.bbox().height / 2
	        return y == null ? this.y() + half : this.y(y - half)
	      }
	      // Set width of element
	    , width: function(width) {
	        var b = this.bbox()
	  
	        return width == null ? b.width : this.attr(this.attr('x1') < this.attr('x2') ? 'x2' : 'x1', b.x + width)
	      }
	      // Set height of element
	    , height: function(height) {
	        var b = this.bbox()
	  
	        return height == null ? b.height : this.attr(this.attr('y1') < this.attr('y2') ? 'y2' : 'y1', b.y + height)
	      }
	      // Set line size by width and height
	    , size: function(width, height) {
	        var p = proportionalSize(this.bbox(), width, height)
	  
	        return this.width(p.width).height(p.height)
	      }
	      // Set path data
	    , plot: function(x1, y1, x2, y2) {
	        return this.attr({
	          x1: x1
	        , y1: y1
	        , x2: x2
	        , y2: y2
	        })
	      }
	    }
	    
	    // Add parent method
	  , construct: {
	      // Create a line element
	      line: function(x1, y1, x2, y2) {
	        return this.put(new SVG.Line().plot(x1, y1, x2, y2))
	      }
	    }
	  })


	  SVG.Polyline = SVG.invent({
	    // Initialize node
	    create: 'polyline'
	  
	    // Inherit from
	  , inherit: SVG.Shape
	    
	    // Add parent method
	  , construct: {
	      // Create a wrapped polyline element
	      polyline: function(p) {
	        return this.put(new SVG.Polyline).plot(p)
	      }
	    }
	  })
	  
	  SVG.Polygon = SVG.invent({
	    // Initialize node
	    create: 'polygon'
	  
	    // Inherit from
	  , inherit: SVG.Shape
	    
	    // Add parent method
	  , construct: {
	      // Create a wrapped polygon element
	      polygon: function(p) {
	        return this.put(new SVG.Polygon).plot(p)
	      }
	    }
	  })
	  
	  // Add polygon-specific functions
	  SVG.extend(SVG.Polyline, SVG.Polygon, {
	    // Define morphable array
	    morphArray:  SVG.PointArray
	    // Plot new path
	  , plot: function(p) {
	      return this.attr('points', (this.array = new SVG.PointArray(p, [[0,0]])))
	    }
	    // Move by left top corner
	  , move: function(x, y) {
	      return this.attr('points', this.array.move(x, y))
	    }
	    // Move by left top corner over x-axis
	  , x: function(x) {
	      return x == null ? this.bbox().x : this.move(x, this.bbox().y)
	    }
	    // Move by left top corner over y-axis
	  , y: function(y) {
	      return y == null ? this.bbox().y : this.move(this.bbox().x, y)
	    }
	    // Set width of element
	  , width: function(width) {
	      var b = this.bbox()
	  
	      return width == null ? b.width : this.size(width, b.height)
	    }
	    // Set height of element
	  , height: function(height) {
	      var b = this.bbox()
	  
	      return height == null ? b.height : this.size(b.width, height) 
	    }
	    // Set element size to given width and height
	  , size: function(width, height) {
	      var p = proportionalSize(this.bbox(), width, height)
	  
	      return this.attr('points', this.array.size(p.width, p.height))
	    }
	  
	  })

	  SVG.Path = SVG.invent({
	    // Initialize node
	    create: 'path'
	  
	    // Inherit from
	  , inherit: SVG.Shape
	  
	    // Add class methods
	  , extend: {
	      // Plot new poly points
	      plot: function(p) {
	        return this.attr('d', (this.array = new SVG.PathArray(p, [['M', 0, 0]])))
	      }
	      // Move by left top corner
	    , move: function(x, y) {
	        return this.attr('d', this.array.move(x, y))
	      }
	      // Move by left top corner over x-axis
	    , x: function(x) {
	        return x == null ? this.bbox().x : this.move(x, this.bbox().y)
	      }
	      // Move by left top corner over y-axis
	    , y: function(y) {
	        return y == null ? this.bbox().y : this.move(this.bbox().x, y)
	      }
	      // Set element size to given width and height
	    , size: function(width, height) {
	        var p = proportionalSize(this.bbox(), width, height)
	        
	        return this.attr('d', this.array.size(p.width, p.height))
	      }
	      // Set width of element
	    , width: function(width) {
	        return width == null ? this.bbox().width : this.size(width, this.bbox().height)
	      }
	      // Set height of element
	    , height: function(height) {
	        return height == null ? this.bbox().height : this.size(this.bbox().width, height)
	      }
	      
	    }
	    
	    // Add parent method
	  , construct: {
	      // Create a wrapped path element
	      path: function(d) {
	        return this.put(new SVG.Path).plot(d)
	      }
	    }
	  })

	  SVG.Image = SVG.invent({
	    // Initialize node
	    create: 'image'
	  
	    // Inherit from
	  , inherit: SVG.Shape
	  
	    // Add class methods
	  , extend: {
	      // (re)load image
	      load: function(url) {
	        if (!url) return this
	  
	        var self = this
	          , img  = document.createElement('img')
	        
	        /* preload image */
	        img.onload = function() {
	          var p = self.doc(SVG.Pattern)
	  
	          /* ensure image size */
	          if (self.width() == 0 && self.height() == 0)
	            self.size(img.width, img.height)
	  
	          /* ensure pattern size if not set */
	          if (p && p.width() == 0 && p.height() == 0)
	            p.size(self.width(), self.height())
	          
	          /* callback */
	          if (typeof self._loaded === 'function')
	            self._loaded.call(self, {
	              width:  img.width
	            , height: img.height
	            , ratio:  img.width / img.height
	            , url:    url
	            })
	        }
	  
	        return this.attr('href', (img.src = this.src = url), SVG.xlink)
	      }
	      // Add loade callback
	    , loaded: function(loaded) {
	        this._loaded = loaded
	        return this
	      }
	    }
	    
	    // Add parent method
	  , construct: {
	      // Create image element, load image and set its size
	      image: function(source, width, height) {
	        return this.put(new SVG.Image).load(source).size(width || 0, height || width || 0)
	      }
	    }
	  
	  })

	  SVG.Text = SVG.invent({
	    // Initialize node
	    create: function() {
	      this.constructor.call(this, SVG.create('text'))
	      
	      this._leading = new SVG.Number(1.3)    /* store leading value for rebuilding */
	      this._rebuild = true                   /* enable automatic updating of dy values */
	      this._build   = false                  /* disable build mode for adding multiple lines */
	  
	      /* set default font */
	      this.attr('font-family', SVG.defaults.attrs['font-family'])
	    }
	  
	    // Inherit from
	  , inherit: SVG.Shape
	  
	    // Add class methods
	  , extend: {
	      // Move over x-axis
	      x: function(x) {
	        /* act as getter */
	        if (x == null)
	          return this.attr('x')
	        
	        /* move lines as well if no textPath is present */
	        if (!this.textPath)
	          this.lines.each(function() { if (this.newLined) this.x(x) })
	  
	        return this.attr('x', x)
	      }
	      // Move over y-axis
	    , y: function(y) {
	        var oy = this.attr('y')
	          , o  = typeof oy === 'number' ? oy - this.bbox().y : 0
	  
	        /* act as getter */
	        if (y == null)
	          return typeof oy === 'number' ? oy - o : oy
	  
	        return this.attr('y', typeof y === 'number' ? y + o : y)
	      }
	      // Move center over x-axis
	    , cx: function(x) {
	        return x == null ? this.bbox().cx : this.x(x - this.bbox().width / 2)
	      }
	      // Move center over y-axis
	    , cy: function(y) {
	        return y == null ? this.bbox().cy : this.y(y - this.bbox().height / 2)
	      }
	      // Set the text content
	    , text: function(text) {
	        /* act as getter */
	        if (typeof text === 'undefined') return this.content
	        
	        /* remove existing content */
	        this.clear().build(true)
	        
	        if (typeof text === 'function') {
	          /* call block */
	          text.call(this, this)
	  
	        } else {
	          /* store text and make sure text is not blank */
	          text = (this.content = text).split('\n')
	          
	          /* build new lines */
	          for (var i = 0, il = text.length; i < il; i++)
	            this.tspan(text[i]).newLine()
	        }
	        
	        /* disable build mode and rebuild lines */
	        return this.build(false).rebuild()
	      }
	      // Set font size
	    , size: function(size) {
	        return this.attr('font-size', size).rebuild()
	      }
	      // Set / get leading
	    , leading: function(value) {
	        /* act as getter */
	        if (value == null)
	          return this._leading
	        
	        /* act as setter */
	        this._leading = new SVG.Number(value)
	        
	        return this.rebuild()
	      }
	      // Rebuild appearance type
	    , rebuild: function(rebuild) {
	        /* store new rebuild flag if given */
	        if (typeof rebuild == 'boolean')
	          this._rebuild = rebuild
	  
	        /* define position of all lines */
	        if (this._rebuild) {
	          var self = this
	          
	          this.lines.each(function() {
	            if (this.newLined) {
	              if (!this.textPath)
	                this.attr('x', self.attr('x'))
	              this.attr('dy', self._leading * new SVG.Number(self.attr('font-size'))) 
	            }
	          })
	  
	          this.fire('rebuild')
	        }
	  
	        return this
	      }
	      // Enable / disable build mode
	    , build: function(build) {
	        this._build = !!build
	        return this
	      }
	    }
	    
	    // Add parent method
	  , construct: {
	      // Create text element
	      text: function(text) {
	        return this.put(new SVG.Text).text(text)
	      }
	      // Create plain text element
	    , plain: function(text) {
	        return this.put(new SVG.Text).plain(text)
	      }
	    }
	  
	  })
	  
	  SVG.TSpan = SVG.invent({
	    // Initialize node
	    create: 'tspan'
	  
	    // Inherit from
	  , inherit: SVG.Shape
	  
	    // Add class methods
	  , extend: {
	      // Set text content
	      text: function(text) {
	        typeof text === 'function' ? text.call(this, this) : this.plain(text)
	  
	        return this
	      }
	      // Shortcut dx
	    , dx: function(dx) {
	        return this.attr('dx', dx)
	      }
	      // Shortcut dy
	    , dy: function(dy) {
	        return this.attr('dy', dy)
	      }
	      // Create new line
	    , newLine: function() {
	        /* fetch text parent */
	        var t = this.doc(SVG.Text)
	  
	        /* mark new line */
	        this.newLined = true
	  
	        /* apply new hyn */
	        return this.dy(t._leading * t.attr('font-size')).attr('x', t.x())
	      }
	    }
	    
	  })
	  
	  SVG.extend(SVG.Text, SVG.TSpan, {
	    // Create plain text node
	    plain: function(text) {
	      /* clear if build mode is disabled */
	      if (this._build === false)
	        this.clear()
	  
	      /* create text node */
	      this.node.appendChild(document.createTextNode((this.content = text)))
	      
	      return this
	    }
	    // Create a tspan
	  , tspan: function(text) {
	      var node  = (this.textPath || this).node
	        , tspan = new SVG.TSpan
	  
	      /* clear if build mode is disabled */
	      if (this._build === false)
	        this.clear()
	      
	      /* add new tspan and reference */
	      node.appendChild(tspan.node)
	      tspan.parent = this
	  
	      /* only first level tspans are considered to be "lines" */
	      if (this instanceof SVG.Text)
	        this.lines.add(tspan)
	  
	      return tspan.text(text)
	    }
	    // Clear all lines
	  , clear: function() {
	      var node = (this.textPath || this).node
	  
	      /* remove existing child nodes */
	      while (node.hasChildNodes())
	        node.removeChild(node.lastChild)
	      
	      /* reset content references  */
	      if (this instanceof SVG.Text) {
	        delete this.lines
	        this.lines = new SVG.Set
	        this.content = ''
	      }
	      
	      return this
	    }
	    // Get length of text element
	  , length: function() {
	      return this.node.getComputedTextLength()
	    }
	  })
	  
	  // Register rebuild event
	  SVG.registerEvent('rebuild')


	  SVG.TextPath = SVG.invent({
	    // Initialize node
	    create: 'textPath'
	  
	    // Inherit from
	  , inherit: SVG.Element
	  
	    // Define parent class
	  , parent: SVG.Text
	  
	    // Add parent method
	  , construct: {
	      // Create path for text to run on
	      path: function(d) {
	        /* create textPath element */
	        this.textPath = new SVG.TextPath
	  
	        /* move lines to textpath */
	        while(this.node.hasChildNodes())
	          this.textPath.node.appendChild(this.node.firstChild)
	  
	        /* add textPath element as child node */
	        this.node.appendChild(this.textPath.node)
	  
	        /* create path in defs */
	        this.track = this.doc().defs().path(d)
	  
	        /* create circular reference */
	        this.textPath.parent = this
	  
	        /* link textPath to path and add content */
	        this.textPath.attr('href', '#' + this.track, SVG.xlink)
	  
	        return this
	      }
	      // Plot path if any
	    , plot: function(d) {
	        if (this.track) this.track.plot(d)
	        return this
	      }
	    }
	  })

	  SVG.Nested = SVG.invent({
	    // Initialize node
	    create: function() {
	      this.constructor.call(this, SVG.create('svg'))
	      
	      this.style('overflow', 'visible')
	    }
	  
	    // Inherit from
	  , inherit: SVG.Container
	    
	    // Add parent method
	  , construct: {
	      // Create nested svg document
	      nested: function() {
	        return this.put(new SVG.Nested)
	      }
	    }
	  })

	  SVG.A = SVG.invent({
	    // Initialize node
	    create: 'a'
	  
	    // Inherit from
	  , inherit: SVG.Container
	  
	    // Add class methods
	  , extend: {
	      // Link url
	      to: function(url) {
	        return this.attr('href', url, SVG.xlink)
	      }
	      // Link show attribute
	    , show: function(target) {
	        return this.attr('show', target, SVG.xlink)
	      }
	      // Link target attribute
	    , target: function(target) {
	        return this.attr('target', target)
	      }
	    }
	    
	    // Add parent method
	  , construct: {
	      // Create a hyperlink element
	      link: function(url) {
	        return this.put(new SVG.A).to(url)
	      }
	    }
	  })
	  
	  SVG.extend(SVG.Element, {
	    // Create a hyperlink element
	    linkTo: function(url) {
	      var link = new SVG.A
	  
	      if (typeof url == 'function')
	        url.call(link, link)
	      else
	        link.to(url)
	  
	      return this.parent.put(link).put(this)
	    }
	    
	  })

	  SVG.Marker = SVG.invent({
	    // Initialize node
	    create: 'marker'
	  
	    // Inherit from
	  , inherit: SVG.Container
	  
	    // Add class methods
	  , extend: {
	      // Set width of element
	      width: function(width) {
	        return this.attr('markerWidth', width)
	      }
	      // Set height of element
	    , height: function(height) {
	        return this.attr('markerHeight', height)
	      }
	      // Set marker refX and refY
	    , ref: function(x, y) {
	        return this.attr('refX', x).attr('refY', y)
	      }
	      // Update marker
	    , update: function(block) {
	        /* remove all content */
	        this.clear()
	        
	        /* invoke passed block */
	        if (typeof block == 'function')
	          block.call(this, this)
	        
	        return this
	      }
	      // Return the fill id
	    , toString: function() {
	        return 'url(#' + this.id() + ')'
	      }
	    }
	  
	    // Add parent method
	  , construct: {
	      marker: function(width, height, block) {
	        // Create marker element in defs
	        return this.defs().marker(width, height, block)
	      }
	    }
	  
	  })
	  
	  SVG.extend(SVG.Defs, {
	    // Create marker
	    marker: function(width, height, block) {
	      // Set default viewbox to match the width and height, set ref to cx and cy and set orient to auto
	      return this.put(new SVG.Marker)
	        .size(width, height)
	        .ref(width / 2, height / 2)
	        .viewbox(0, 0, width, height)
	        .attr('orient', 'auto')
	        .update(block)
	    }
	    
	  })
	  
	  SVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, SVG.Path, {
	    // Create and attach markers
	    marker: function(marker, width, height, block) {
	      var attr = ['marker']
	  
	      // Build attribute name
	      if (marker != 'all') attr.push(marker)
	      attr = attr.join('-')
	  
	      // Set marker attribute
	      marker = arguments[1] instanceof SVG.Marker ?
	        arguments[1] :
	        this.doc().marker(width, height, block)
	      
	      return this.attr(attr, marker)
	    }
	    
	  })

	  var sugar = {
	    stroke: ['color', 'width', 'opacity', 'linecap', 'linejoin', 'miterlimit', 'dasharray', 'dashoffset']
	  , fill:   ['color', 'opacity', 'rule']
	  , prefix: function(t, a) {
	      return a == 'color' ? t : t + '-' + a
	    }
	  }
	  
	  /* Add sugar for fill and stroke */
	  ;['fill', 'stroke'].forEach(function(m) {
	    var i, extension = {}
	    
	    extension[m] = function(o) {
	      if (typeof o == 'string' || SVG.Color.isRgb(o) || (o && typeof o.fill === 'function'))
	        this.attr(m, o)
	  
	      else
	        /* set all attributes from sugar.fill and sugar.stroke list */
	        for (i = sugar[m].length - 1; i >= 0; i--)
	          if (o[sugar[m][i]] != null)
	            this.attr(sugar.prefix(m, sugar[m][i]), o[sugar[m][i]])
	      
	      return this
	    }
	    
	    SVG.extend(SVG.Element, SVG.FX, extension)
	    
	  })
	  
	  SVG.extend(SVG.Element, SVG.FX, {
	    // Rotation
	    rotate: function(deg, x, y) {
	      return this.transform({
	        rotation: deg || 0
	      , cx: x
	      , cy: y
	      })
	    }
	    // Skew
	  , skew: function(x, y) {
	      return this.transform({
	        skewX: x || 0
	      , skewY: y || 0
	      })
	    }
	    // Scale
	  , scale: function(x, y) {
	      return this.transform({
	        scaleX: x
	      , scaleY: y == null ? x : y
	      })
	    }
	    // Translate
	  , translate: function(x, y) {
	      return this.transform({
	        x: x
	      , y: y
	      })
	    }
	    // Matrix
	  , matrix: function(m) {
	      return this.transform({ matrix: m })
	    }
	    // Opacity
	  , opacity: function(value) {
	      return this.attr('opacity', value)
	    }
	  
	  })
	  
	  SVG.extend(SVG.Rect, SVG.Ellipse, SVG.FX, {
	    // Add x and y radius
	    radius: function(x, y) {
	      return this.attr({ rx: x, ry: y || x })
	    }
	  
	  })
	  
	  SVG.extend(SVG.Path, {
	    // Get path length
	    length: function() {
	      return this.node.getTotalLength()
	    }
	    // Get point at length
	  , pointAt: function(length) {
	      return this.node.getPointAtLength(length)
	    }
	  
	  })
	  
	  SVG.extend(SVG.Parent, SVG.Text, SVG.FX, {
	    // Set font 
	    font: function(o) {
	      for (var k in o)
	        k == 'leading' ?
	          this.leading(o[k]) :
	        k == 'anchor' ?
	          this.attr('text-anchor', o[k]) :
	        k == 'size' || k == 'family' || k == 'weight' || k == 'stretch' || k == 'variant' || k == 'style' ?
	          this.attr('font-'+ k, o[k]) :
	          this.attr(k, o[k])
	      
	      return this
	    }
	    
	  })
	  


	  SVG.Set = SVG.invent({
	    // Initialize
	    create: function() {
	      /* set initial state */
	      this.clear()
	    }
	  
	    // Add class methods
	  , extend: {
	      // Add element to set
	      add: function() {
	        var i, il, elements = [].slice.call(arguments)
	  
	        for (i = 0, il = elements.length; i < il; i++)
	          this.members.push(elements[i])
	        
	        return this
	      }
	      // Remove element from set
	    , remove: function(element) {
	        var i = this.index(element)
	        
	        /* remove given child */
	        if (i > -1)
	          this.members.splice(i, 1)
	  
	        return this
	      }
	      // Iterate over all members
	    , each: function(block) {
	        for (var i = 0, il = this.members.length; i < il; i++)
	          block.apply(this.members[i], [i, this.members])
	  
	        return this
	      }
	      // Restore to defaults
	    , clear: function() {
	        /* initialize store */
	        this.members = []
	  
	        return this
	      }
	      // Checks if a given element is present in set
	    , has: function(element) {
	        return this.index(element) >= 0
	      }
	      // retuns index of given element in set
	    , index: function(element) {
	        return this.members.indexOf(element)
	      }
	      // Get member at given index
	    , get: function(i) {
	        return this.members[i]
	      }
	      // Get first member
	    , first: function() {
	        return this.get(0)
	      }
	      // Get last member
	    , last: function() {
	        return this.get(this.members.length - 1)
	      }
	      // Default value
	    , valueOf: function() {
	        return this.members
	      }
	      // Get the bounding box of all members included or empty box if set has no items
	    , bbox: function(){
	        var box = new SVG.BBox()
	  
	        /* return an empty box of there are no members */
	        if (this.members.length == 0)
	          return box
	  
	        /* get the first rbox and update the target bbox */
	        var rbox = this.members[0].rbox()
	        box.x      = rbox.x
	        box.y      = rbox.y
	        box.width  = rbox.width
	        box.height = rbox.height
	  
	        this.each(function() {
	          /* user rbox for correct position and visual representation */
	          box = box.merge(this.rbox())
	        })
	  
	        return box
	      }
	    }
	    
	    // Add parent method
	  , construct: {
	      // Create a new set
	      set: function() {
	        return new SVG.Set
	      }
	    }
	  })
	  
	  SVG.SetFX = SVG.invent({
	    // Initialize node
	    create: function(set) {
	      /* store reference to set */
	      this.set = set
	    }
	  
	  })
	  
	  // Alias methods
	  SVG.Set.inherit = function() {
	    var m
	      , methods = []
	    
	    /* gather shape methods */
	    for(var m in SVG.Shape.prototype)
	      if (typeof SVG.Shape.prototype[m] == 'function' && typeof SVG.Set.prototype[m] != 'function')
	        methods.push(m)
	  
	    /* apply shape aliasses */
	    methods.forEach(function(method) {
	      SVG.Set.prototype[method] = function() {
	        for (var i = 0, il = this.members.length; i < il; i++)
	          if (this.members[i] && typeof this.members[i][method] == 'function')
	            this.members[i][method].apply(this.members[i], arguments)
	  
	        return method == 'animate' ? (this.fx || (this.fx = new SVG.SetFX(this))) : this
	      }
	    })
	  
	    /* clear methods for the next round */
	    methods = []
	  
	    /* gather fx methods */
	    for(var m in SVG.FX.prototype)
	      if (typeof SVG.FX.prototype[m] == 'function' && typeof SVG.SetFX.prototype[m] != 'function')
	        methods.push(m)
	  
	    /* apply fx aliasses */
	    methods.forEach(function(method) {
	      SVG.SetFX.prototype[method] = function() {
	        for (var i = 0, il = this.set.members.length; i < il; i++)
	          this.set.members[i].fx[method].apply(this.set.members[i].fx, arguments)
	  
	        return this
	      }
	    })
	  }
	  
	  


	  SVG.extend(SVG.Element, {
	  	// Store data values on svg nodes
	    data: function(a, v, r) {
	    	if (typeof a == 'object') {
	    		for (v in a)
	    			this.data(v, a[v])
	  
	      } else if (arguments.length < 2) {
	        try {
	          return JSON.parse(this.attr('data-' + a))
	        } catch(e) {
	          return this.attr('data-' + a)
	        }
	        
	      } else {
	        this.attr(
	          'data-' + a
	        , v === null ?
	            null :
	          r === true || typeof v === 'string' || typeof v === 'number' ?
	            v :
	            JSON.stringify(v)
	        )
	      }
	      
	      return this
	    }
	  })

	  SVG.extend(SVG.Element, {
	    // Remember arbitrary data
	    remember: function(k, v) {
	      /* remember every item in an object individually */
	      if (typeof arguments[0] == 'object')
	        for (var v in k)
	          this.remember(v, k[v])
	  
	      /* retrieve memory */
	      else if (arguments.length == 1)
	        return this.memory()[k]
	  
	      /* store memory */
	      else
	        this.memory()[k] = v
	  
	      return this
	    }
	  
	    // Erase a given memory
	  , forget: function() {
	      if (arguments.length == 0)
	        this._memory = {}
	      else
	        for (var i = arguments.length - 1; i >= 0; i--)
	          delete this.memory()[arguments[i]]
	  
	      return this
	    }
	  
	    // Initialize or return local memory object
	  , memory: function() {
	      return this._memory || (this._memory = {})
	    }
	  
	  })

	  if (true)
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return SVG }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
	  else if (typeof exports !== 'undefined')
	    exports.SVG = SVG

	  function camelCase(s) { 
	    return s.toLowerCase().replace(/-(.)/g, function(m, g) {
	      return g.toUpperCase()
	    })
	  }
	  
	  // Ensure to six-based hex 
	  function fullHex(hex) {
	    return hex.length == 4 ?
	      [ '#',
	        hex.substring(1, 2), hex.substring(1, 2)
	      , hex.substring(2, 3), hex.substring(2, 3)
	      , hex.substring(3, 4), hex.substring(3, 4)
	      ].join('') : hex
	  }
	  
	  // Component to hex value
	  function compToHex(comp) {
	    var hex = comp.toString(16)
	    return hex.length == 1 ? '0' + hex : hex
	  }
	  
	  // Calculate proportional width and height values when necessary
	  function proportionalSize(box, width, height) {
	    if (width == null || height == null) {
	      if (height == null)
	        height = box.height / box.width * width
	      else if (width == null)
	        width = box.width / box.height * height
	    }
	    
	    return {
	      width:  width
	    , height: height
	    }
	  }
	  
	  // Calculate position according to from and to
	  function at(o, pos) {
	    /* number recalculation (don't bother converting to SVG.Number for performance reasons) */
	    return typeof o.from == 'number' ?
	      o.from + (o.to - o.from) * pos :
	    
	    /* instance recalculation */
	    o instanceof SVG.Color || o instanceof SVG.Number ? o.at(pos) :
	    
	    /* for all other values wait until pos has reached 1 to return the final value */
	    pos < 1 ? o.from : o.to
	  }
	  
	  // PathArray Helpers
	  function arrayToString(a) {
	    for (var i = 0, il = a.length, s = ''; i < il; i++) {
	      s += a[i][0]
	  
	      if (a[i][1] != null) {
	        s += a[i][1]
	  
	        if (a[i][2] != null) {
	          s += ' '
	          s += a[i][2]
	  
	          if (a[i][3] != null) {
	            s += ' '
	            s += a[i][3]
	            s += ' '
	            s += a[i][4]
	  
	            if (a[i][5] != null) {
	              s += ' '
	              s += a[i][5]
	              s += ' '
	              s += a[i][6]
	  
	              if (a[i][7] != null) {
	                s += ' '
	                s += a[i][7]
	              }
	            }
	          }
	        }
	      }
	    }
	    
	    return s + ' '
	  }
	  
	  // Add more bounding box properties
	  function boxProperties(b) {
	    b.x2 = b.x + b.width
	    b.y2 = b.y + b.height
	    b.cx = b.x + b.width / 2
	    b.cy = b.y + b.height / 2
	  }
	  
	  // Parse a matrix string
	  function parseMatrix(o) {
	    if (o.matrix) {
	      /* split matrix string */
	      var m = o.matrix.replace(/\s/g, '').split(',')
	      
	      /* pasrse values */
	      if (m.length == 6) {
	        o.a = parseFloat(m[0])
	        o.b = parseFloat(m[1])
	        o.c = parseFloat(m[2])
	        o.d = parseFloat(m[3])
	        o.e = parseFloat(m[4])
	        o.f = parseFloat(m[5])
	      }
	    }
	    
	    return o
	  }
	  
	  // Get id from reference string
	  function idFromReference(url) {
	    var m = url.toString().match(SVG.regex.reference)
	  
	    if (m) return m[1]
	  }
	  
	  // Shim layer with setTimeout fallback by Paul Irish
	  window.requestAnimFrame = (function(){
	    return  window.requestAnimationFrame       ||
	            window.webkitRequestAnimationFrame ||
	            window.mozRequestAnimationFrame    ||
	            window.msRequestAnimationFrame     ||
	            function (c) { window.setTimeout(c, 1000 / 60) }
	  })()

	  return SVG
	}));


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	// shim for using process in browser

	var process = module.exports = {};

	process.nextTick = (function () {
	    var canSetImmediate = typeof window !== 'undefined'
	    && window.setImmediate;
	    var canPost = typeof window !== 'undefined'
	    && window.postMessage && window.addEventListener
	    ;

	    if (canSetImmediate) {
	        return function (f) { return window.setImmediate(f) };
	    }

	    if (canPost) {
	        var queue = [];
	        window.addEventListener('message', function (ev) {
	            var source = ev.source;
	            if ((source === window || source === null) && ev.data === 'process-tick') {
	                ev.stopPropagation();
	                if (queue.length > 0) {
	                    var fn = queue.shift();
	                    fn();
	                }
	            }
	        }, true);

	        return function nextTick(fn) {
	            queue.push(fn);
	            window.postMessage('process-tick', '*');
	        };
	    }

	    return function nextTick(fn) {
	        setTimeout(fn, 0);
	    };
	})();

	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	}

	// TODO(shtylman)
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};


/***/ }
/******/ ])