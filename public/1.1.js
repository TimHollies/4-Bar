webpackJsonp([1,2],[
/* 0 */,
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = {
		lodash: __webpack_require__(2),
		svgjs: __webpack_require__(7),
		lex: __webpack_require__(5),
		Ractive: __webpack_require__(6),
	    toastr: __webpack_require__(4),
	    Rx: __webpack_require__(9),
	    jquery: __webpack_require__(8)
	};

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/**
	 * @license
	 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
	 * Build: `lodash -o ./dist/lodash.compat.js`
	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <http://lodash.com/license>
	 */
	;(function() {
	
	  /** Used as a safe reference for `undefined` in pre ES5 environments */
	  var undefined;
	
	  /** Used to pool arrays and objects used internally */
	  var arrayPool = [],
	      objectPool = [];
	
	  /** Used to generate unique IDs */
	  var idCounter = 0;
	
	  /** Used internally to indicate various things */
	  var indicatorObject = {};
	
	  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
	  var keyPrefix = +new Date + '';
	
	  /** Used as the size when optimizations are enabled for large arrays */
	  var largeArraySize = 75;
	
	  /** Used as the max size of the `arrayPool` and `objectPool` */
	  var maxPoolSize = 40;
	
	  /** Used to detect and test whitespace */
	  var whitespace = (
	    // whitespace
	    ' \t\x0B\f\xA0\ufeff' +
	
	    // line terminators
	    '\n\r\u2028\u2029' +
	
	    // unicode category "Zs" space separators
	    '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
	  );
	
	  /** Used to match empty string literals in compiled template source */
	  var reEmptyStringLeading = /\b__p \+= '';/g,
	      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
	      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
	
	  /**
	   * Used to match ES6 template delimiters
	   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals
	   */
	  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
	
	  /** Used to match regexp flags from their coerced string values */
	  var reFlags = /\w*$/;
	
	  /** Used to detected named functions */
	  var reFuncName = /^\s*function[ \n\r\t]+\w/;
	
	  /** Used to match "interpolate" template delimiters */
	  var reInterpolate = /<%=([\s\S]+?)%>/g;
	
	  /** Used to match leading whitespace and zeros to be removed */
	  var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');
	
	  /** Used to ensure capturing order of template delimiters */
	  var reNoMatch = /($^)/;
	
	  /** Used to detect functions containing a `this` reference */
	  var reThis = /\bthis\b/;
	
	  /** Used to match unescaped characters in compiled string literals */
	  var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;
	
	  /** Used to assign default `context` object properties */
	  var contextProps = [
	    'Array', 'Boolean', 'Date', 'Error', 'Function', 'Math', 'Number', 'Object',
	    'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',
	    'parseInt', 'setTimeout'
	  ];
	
	  /** Used to fix the JScript [[DontEnum]] bug */
	  var shadowedProps = [
	    'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',
	    'toLocaleString', 'toString', 'valueOf'
	  ];
	
	  /** Used to make template sourceURLs easier to identify */
	  var templateCounter = 0;
	
	  /** `Object#toString` result shortcuts */
	  var argsClass = '[object Arguments]',
	      arrayClass = '[object Array]',
	      boolClass = '[object Boolean]',
	      dateClass = '[object Date]',
	      errorClass = '[object Error]',
	      funcClass = '[object Function]',
	      numberClass = '[object Number]',
	      objectClass = '[object Object]',
	      regexpClass = '[object RegExp]',
	      stringClass = '[object String]';
	
	  /** Used to identify object classifications that `_.clone` supports */
	  var cloneableClasses = {};
	  cloneableClasses[funcClass] = false;
	  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
	  cloneableClasses[boolClass] = cloneableClasses[dateClass] =
	  cloneableClasses[numberClass] = cloneableClasses[objectClass] =
	  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;
	
	  /** Used as an internal `_.debounce` options object */
	  var debounceOptions = {
	    'leading': false,
	    'maxWait': 0,
	    'trailing': false
	  };
	
	  /** Used as the property descriptor for `__bindData__` */
	  var descriptor = {
	    'configurable': false,
	    'enumerable': false,
	    'value': null,
	    'writable': false
	  };
	
	  /** Used as the data object for `iteratorTemplate` */
	  var iteratorData = {
	    'args': '',
	    'array': null,
	    'bottom': '',
	    'firstArg': '',
	    'init': '',
	    'keys': null,
	    'loop': '',
	    'shadowedProps': null,
	    'support': null,
	    'top': '',
	    'useHas': false
	  };
	
	  /** Used to determine if values are of the language type Object */
	  var objectTypes = {
	    'boolean': false,
	    'function': true,
	    'object': true,
	    'number': false,
	    'string': false,
	    'undefined': false
	  };
	
	  /** Used to escape characters for inclusion in compiled string literals */
	  var stringEscapes = {
	    '\\': '\\',
	    "'": "'",
	    '\n': 'n',
	    '\r': 'r',
	    '\t': 't',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };
	
	  /** Used as a reference to the global object */
	  var root = (objectTypes[typeof window] && window) || this;
	
	  /** Detect free variable `exports` */
	  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
	
	  /** Detect free variable `module` */
	  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
	
	  /** Detect the popular CommonJS extension `module.exports` */
	  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
	
	  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
	  var freeGlobal = objectTypes[typeof global] && global;
	  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
	    root = freeGlobal;
	  }
	
	  /*--------------------------------------------------------------------------*/
	
	  /**
	   * The base implementation of `_.indexOf` without support for binary searches
	   * or `fromIndex` constraints.
	   *
	   * @private
	   * @param {Array} array The array to search.
	   * @param {*} value The value to search for.
	   * @param {number} [fromIndex=0] The index to search from.
	   * @returns {number} Returns the index of the matched value or `-1`.
	   */
	  function baseIndexOf(array, value, fromIndex) {
	    var index = (fromIndex || 0) - 1,
	        length = array ? array.length : 0;
	
	    while (++index < length) {
	      if (array[index] === value) {
	        return index;
	      }
	    }
	    return -1;
	  }
	
	  /**
	   * An implementation of `_.contains` for cache objects that mimics the return
	   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
	   *
	   * @private
	   * @param {Object} cache The cache object to inspect.
	   * @param {*} value The value to search for.
	   * @returns {number} Returns `0` if `value` is found, else `-1`.
	   */
	  function cacheIndexOf(cache, value) {
	    var type = typeof value;
	    cache = cache.cache;
	
	    if (type == 'boolean' || value == null) {
	      return cache[value] ? 0 : -1;
	    }
	    if (type != 'number' && type != 'string') {
	      type = 'object';
	    }
	    var key = type == 'number' ? value : keyPrefix + value;
	    cache = (cache = cache[type]) && cache[key];
	
	    return type == 'object'
	      ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)
	      : (cache ? 0 : -1);
	  }
	
	  /**
	   * Adds a given value to the corresponding cache object.
	   *
	   * @private
	   * @param {*} value The value to add to the cache.
	   */
	  function cachePush(value) {
	    var cache = this.cache,
	        type = typeof value;
	
	    if (type == 'boolean' || value == null) {
	      cache[value] = true;
	    } else {
	      if (type != 'number' && type != 'string') {
	        type = 'object';
	      }
	      var key = type == 'number' ? value : keyPrefix + value,
	          typeCache = cache[type] || (cache[type] = {});
	
	      if (type == 'object') {
	        (typeCache[key] || (typeCache[key] = [])).push(value);
	      } else {
	        typeCache[key] = true;
	      }
	    }
	  }
	
	  /**
	   * Used by `_.max` and `_.min` as the default callback when a given
	   * collection is a string value.
	   *
	   * @private
	   * @param {string} value The character to inspect.
	   * @returns {number} Returns the code unit of given character.
	   */
	  function charAtCallback(value) {
	    return value.charCodeAt(0);
	  }
	
	  /**
	   * Used by `sortBy` to compare transformed `collection` elements, stable sorting
	   * them in ascending order.
	   *
	   * @private
	   * @param {Object} a The object to compare to `b`.
	   * @param {Object} b The object to compare to `a`.
	   * @returns {number} Returns the sort order indicator of `1` or `-1`.
	   */
	  function compareAscending(a, b) {
	    var ac = a.criteria,
	        bc = b.criteria,
	        index = -1,
	        length = ac.length;
	
	    while (++index < length) {
	      var value = ac[index],
	          other = bc[index];
	
	      if (value !== other) {
	        if (value > other || typeof value == 'undefined') {
	          return 1;
	        }
	        if (value < other || typeof other == 'undefined') {
	          return -1;
	        }
	      }
	    }
	    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
	    // that causes it, under certain circumstances, to return the same value for
	    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
	    //
	    // This also ensures a stable sort in V8 and other engines.
	    // See http://code.google.com/p/v8/issues/detail?id=90
	    return a.index - b.index;
	  }
	
	  /**
	   * Creates a cache object to optimize linear searches of large arrays.
	   *
	   * @private
	   * @param {Array} [array=[]] The array to search.
	   * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
	   */
	  function createCache(array) {
	    var index = -1,
	        length = array.length,
	        first = array[0],
	        mid = array[(length / 2) | 0],
	        last = array[length - 1];
	
	    if (first && typeof first == 'object' &&
	        mid && typeof mid == 'object' && last && typeof last == 'object') {
	      return false;
	    }
	    var cache = getObject();
	    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;
	
	    var result = getObject();
	    result.array = array;
	    result.cache = cache;
	    result.push = cachePush;
	
	    while (++index < length) {
	      result.push(array[index]);
	    }
	    return result;
	  }
	
	  /**
	   * Used by `template` to escape characters for inclusion in compiled
	   * string literals.
	   *
	   * @private
	   * @param {string} match The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  function escapeStringChar(match) {
	    return '\\' + stringEscapes[match];
	  }
	
	  /**
	   * Gets an array from the array pool or creates a new one if the pool is empty.
	   *
	   * @private
	   * @returns {Array} The array from the pool.
	   */
	  function getArray() {
	    return arrayPool.pop() || [];
	  }
	
	  /**
	   * Gets an object from the object pool or creates a new one if the pool is empty.
	   *
	   * @private
	   * @returns {Object} The object from the pool.
	   */
	  function getObject() {
	    return objectPool.pop() || {
	      'array': null,
	      'cache': null,
	      'criteria': null,
	      'false': false,
	      'index': 0,
	      'null': false,
	      'number': null,
	      'object': null,
	      'push': null,
	      'string': null,
	      'true': false,
	      'undefined': false,
	      'value': null
	    };
	  }
	
	  /**
	   * Checks if `value` is a DOM node in IE < 9.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if the `value` is a DOM node, else `false`.
	   */
	  function isNode(value) {
	    // IE < 9 presents DOM nodes as `Object` objects except they have `toString`
	    // methods that are `typeof` "string" and still can coerce nodes to strings
	    return typeof value.toString != 'function' && typeof (value + '') == 'string';
	  }
	
	  /**
	   * Releases the given array back to the array pool.
	   *
	   * @private
	   * @param {Array} [array] The array to release.
	   */
	  function releaseArray(array) {
	    array.length = 0;
	    if (arrayPool.length < maxPoolSize) {
	      arrayPool.push(array);
	    }
	  }
	
	  /**
	   * Releases the given object back to the object pool.
	   *
	   * @private
	   * @param {Object} [object] The object to release.
	   */
	  function releaseObject(object) {
	    var cache = object.cache;
	    if (cache) {
	      releaseObject(cache);
	    }
	    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
	    if (objectPool.length < maxPoolSize) {
	      objectPool.push(object);
	    }
	  }
	
	  /**
	   * Slices the `collection` from the `start` index up to, but not including,
	   * the `end` index.
	   *
	   * Note: This function is used instead of `Array#slice` to support node lists
	   * in IE < 9 and to ensure dense arrays are returned.
	   *
	   * @private
	   * @param {Array|Object|string} collection The collection to slice.
	   * @param {number} start The start index.
	   * @param {number} end The end index.
	   * @returns {Array} Returns the new array.
	   */
	  function slice(array, start, end) {
	    start || (start = 0);
	    if (typeof end == 'undefined') {
	      end = array ? array.length : 0;
	    }
	    var index = -1,
	        length = end - start || 0,
	        result = Array(length < 0 ? 0 : length);
	
	    while (++index < length) {
	      result[index] = array[start + index];
	    }
	    return result;
	  }
	
	  /*--------------------------------------------------------------------------*/
	
	  /**
	   * Create a new `lodash` function using the given context object.
	   *
	   * @static
	   * @memberOf _
	   * @category Utilities
	   * @param {Object} [context=root] The context object.
	   * @returns {Function} Returns the `lodash` function.
	   */
	  function runInContext(context) {
	    // Avoid issues with some ES3 environments that attempt to use values, named
	    // after built-in constructors like `Object`, for the creation of literals.
	    // ES5 clears this up by stating that literals must use built-in constructors.
	    // See http://es5.github.io/#x11.1.5.
	    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
	
	    /** Native constructor references */
	    var Array = context.Array,
	        Boolean = context.Boolean,
	        Date = context.Date,
	        Error = context.Error,
	        Function = context.Function,
	        Math = context.Math,
	        Number = context.Number,
	        Object = context.Object,
	        RegExp = context.RegExp,
	        String = context.String,
	        TypeError = context.TypeError;
	
	    /**
	     * Used for `Array` method references.
	     *
	     * Normally `Array.prototype` would suffice, however, using an array literal
	     * avoids issues in Narwhal.
	     */
	    var arrayRef = [];
	
	    /** Used for native method references */
	    var errorProto = Error.prototype,
	        objectProto = Object.prototype,
	        stringProto = String.prototype;
	
	    /** Used to restore the original `_` reference in `noConflict` */
	    var oldDash = context._;
	
	    /** Used to resolve the internal [[Class]] of values */
	    var toString = objectProto.toString;
	
	    /** Used to detect if a method is native */
	    var reNative = RegExp('^' +
	      String(toString)
	        .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
	        .replace(/toString| for [^\]]+/g, '.*?') + '$'
	    );
	
	    /** Native method shortcuts */
	    var ceil = Math.ceil,
	        clearTimeout = context.clearTimeout,
	        floor = Math.floor,
	        fnToString = Function.prototype.toString,
	        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
	        hasOwnProperty = objectProto.hasOwnProperty,
	        push = arrayRef.push,
	        propertyIsEnumerable = objectProto.propertyIsEnumerable,
	        setTimeout = context.setTimeout,
	        splice = arrayRef.splice,
	        unshift = arrayRef.unshift;
	
	    /** Used to set meta data on functions */
	    var defineProperty = (function() {
	      // IE 8 only accepts DOM elements
	      try {
	        var o = {},
	            func = isNative(func = Object.defineProperty) && func,
	            result = func(o, o, o) && func;
	      } catch(e) { }
	      return result;
	    }());
	
	    /* Native method shortcuts for methods with the same name as other `lodash` methods */
	    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
	        nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
	        nativeIsFinite = context.isFinite,
	        nativeIsNaN = context.isNaN,
	        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
	        nativeMax = Math.max,
	        nativeMin = Math.min,
	        nativeParseInt = context.parseInt,
	        nativeRandom = Math.random;
	
	    /** Used to lookup a built-in constructor by [[Class]] */
	    var ctorByClass = {};
	    ctorByClass[arrayClass] = Array;
	    ctorByClass[boolClass] = Boolean;
	    ctorByClass[dateClass] = Date;
	    ctorByClass[funcClass] = Function;
	    ctorByClass[objectClass] = Object;
	    ctorByClass[numberClass] = Number;
	    ctorByClass[regexpClass] = RegExp;
	    ctorByClass[stringClass] = String;
	
	    /** Used to avoid iterating non-enumerable properties in IE < 9 */
	    var nonEnumProps = {};
	    nonEnumProps[arrayClass] = nonEnumProps[dateClass] = nonEnumProps[numberClass] = { 'constructor': true, 'toLocaleString': true, 'toString': true, 'valueOf': true };
	    nonEnumProps[boolClass] = nonEnumProps[stringClass] = { 'constructor': true, 'toString': true, 'valueOf': true };
	    nonEnumProps[errorClass] = nonEnumProps[funcClass] = nonEnumProps[regexpClass] = { 'constructor': true, 'toString': true };
	    nonEnumProps[objectClass] = { 'constructor': true };
	
	    (function() {
	      var length = shadowedProps.length;
	      while (length--) {
	        var key = shadowedProps[length];
	        for (var className in nonEnumProps) {
	          if (hasOwnProperty.call(nonEnumProps, className) && !hasOwnProperty.call(nonEnumProps[className], key)) {
	            nonEnumProps[className][key] = false;
	          }
	        }
	      }
	    }());
	
	    /*--------------------------------------------------------------------------*/
	
	    /**
	     * Creates a `lodash` object which wraps the given value to enable intuitive
	     * method chaining.
	     *
	     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
	     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
	     * and `unshift`
	     *
	     * Chaining is supported in custom builds as long as the `value` method is
	     * implicitly or explicitly included in the build.
	     *
	     * The chainable wrapper functions are:
	     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
	     * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
	     * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
	     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
	     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
	     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
	     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
	     * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
	     * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
	     * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
	     * and `zip`
	     *
	     * The non-chainable wrapper functions are:
	     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
	     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
	     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
	     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
	     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
	     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
	     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
	     * `template`, `unescape`, `uniqueId`, and `value`
	     *
	     * The wrapper functions `first` and `last` return wrapped values when `n` is
	     * provided, otherwise they return unwrapped values.
	     *
	     * Explicit chaining can be enabled by using the `_.chain` method.
	     *
	     * @name _
	     * @constructor
	     * @category Chaining
	     * @param {*} value The value to wrap in a `lodash` instance.
	     * @returns {Object} Returns a `lodash` instance.
	     * @example
	     *
	     * var wrapped = _([1, 2, 3]);
	     *
	     * // returns an unwrapped value
	     * wrapped.reduce(function(sum, num) {
	     *   return sum + num;
	     * });
	     * // => 6
	     *
	     * // returns a wrapped value
	     * var squares = wrapped.map(function(num) {
	     *   return num * num;
	     * });
	     *
	     * _.isArray(squares);
	     * // => false
	     *
	     * _.isArray(squares.value());
	     * // => true
	     */
	    function lodash(value) {
	      // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
	      return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))
	       ? value
	       : new lodashWrapper(value);
	    }
	
	    /**
	     * A fast path for creating `lodash` wrapper objects.
	     *
	     * @private
	     * @param {*} value The value to wrap in a `lodash` instance.
	     * @param {boolean} chainAll A flag to enable chaining for all methods
	     * @returns {Object} Returns a `lodash` instance.
	     */
	    function lodashWrapper(value, chainAll) {
	      this.__chain__ = !!chainAll;
	      this.__wrapped__ = value;
	    }
	    // ensure `new lodashWrapper` is an instance of `lodash`
	    lodashWrapper.prototype = lodash.prototype;
	
	    /**
	     * An object used to flag environments features.
	     *
	     * @static
	     * @memberOf _
	     * @type Object
	     */
	    var support = lodash.support = {};
	
	    (function() {
	      var ctor = function() { this.x = 1; },
	          object = { '0': 1, 'length': 1 },
	          props = [];
	
	      ctor.prototype = { 'valueOf': 1, 'y': 1 };
	      for (var key in new ctor) { props.push(key); }
	      for (key in arguments) { }
	
	      /**
	       * Detect if an `arguments` object's [[Class]] is resolvable (all but Firefox < 4, IE < 9).
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.argsClass = toString.call(arguments) == argsClass;
	
	      /**
	       * Detect if `arguments` objects are `Object` objects (all but Narwhal and Opera < 10.5).
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.argsObject = arguments.constructor == Object && !(arguments instanceof Array);
	
	      /**
	       * Detect if `name` or `message` properties of `Error.prototype` are
	       * enumerable by default. (IE < 9, Safari < 5.1)
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') || propertyIsEnumerable.call(errorProto, 'name');
	
	      /**
	       * Detect if `prototype` properties are enumerable by default.
	       *
	       * Firefox < 3.6, Opera > 9.50 - Opera < 11.60, and Safari < 5.1
	       * (if the prototype or a property on the prototype has been set)
	       * incorrectly sets a function's `prototype` property [[Enumerable]]
	       * value to `true`.
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.enumPrototypes = propertyIsEnumerable.call(ctor, 'prototype');
	
	      /**
	       * Detect if functions can be decompiled by `Function#toString`
	       * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);
	
	      /**
	       * Detect if `Function#name` is supported (all but IE).
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.funcNames = typeof Function.name == 'string';
	
	      /**
	       * Detect if `arguments` object indexes are non-enumerable
	       * (Firefox < 4, IE < 9, PhantomJS, Safari < 5.1).
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.nonEnumArgs = key != 0;
	
	      /**
	       * Detect if properties shadowing those on `Object.prototype` are non-enumerable.
	       *
	       * In IE < 9 an objects own properties, shadowing non-enumerable ones, are
	       * made non-enumerable as well (a.k.a the JScript [[DontEnum]] bug).
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.nonEnumShadows = !/valueOf/.test(props);
	
	      /**
	       * Detect if own properties are iterated after inherited properties (all but IE < 9).
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.ownLast = props[0] != 'x';
	
	      /**
	       * Detect if `Array#shift` and `Array#splice` augment array-like objects correctly.
	       *
	       * Firefox < 10, IE compatibility mode, and IE < 9 have buggy Array `shift()`
	       * and `splice()` functions that fail to remove the last element, `value[0]`,
	       * of array-like objects even though the `length` property is set to `0`.
	       * The `shift()` method is buggy in IE 8 compatibility mode, while `splice()`
	       * is buggy regardless of mode in IE < 9 and buggy in compatibility mode in IE 9.
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.spliceObjects = (arrayRef.splice.call(object, 0, 1), !object[0]);
	
	      /**
	       * Detect lack of support for accessing string characters by index.
	       *
	       * IE < 8 can't access characters by index and IE 8 can only access
	       * characters by index on string literals.
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.unindexedChars = ('x'[0] + Object('x')[0]) != 'xx';
	
	      /**
	       * Detect if a DOM node's [[Class]] is resolvable (all but IE < 9)
	       * and that the JS engine errors when attempting to coerce an object to
	       * a string without a `toString` function.
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      try {
	        support.nodeClass = !(toString.call(document) == objectClass && !({ 'toString': 0 } + ''));
	      } catch(e) {
	        support.nodeClass = true;
	      }
	    }(1));
	
	    /**
	     * By default, the template delimiters used by Lo-Dash are similar to those in
	     * embedded Ruby (ERB). Change the following template settings to use alternative
	     * delimiters.
	     *
	     * @static
	     * @memberOf _
	     * @type Object
	     */
	    lodash.templateSettings = {
	
	      /**
	       * Used to detect `data` property values to be HTML-escaped.
	       *
	       * @memberOf _.templateSettings
	       * @type RegExp
	       */
	      'escape': /<%-([\s\S]+?)%>/g,
	
	      /**
	       * Used to detect code to be evaluated.
	       *
	       * @memberOf _.templateSettings
	       * @type RegExp
	       */
	      'evaluate': /<%([\s\S]+?)%>/g,
	
	      /**
	       * Used to detect `data` property values to inject.
	       *
	       * @memberOf _.templateSettings
	       * @type RegExp
	       */
	      'interpolate': reInterpolate,
	
	      /**
	       * Used to reference the data object in the template text.
	       *
	       * @memberOf _.templateSettings
	       * @type string
	       */
	      'variable': '',
	
	      /**
	       * Used to import variables into the compiled template.
	       *
	       * @memberOf _.templateSettings
	       * @type Object
	       */
	      'imports': {
	
	        /**
	         * A reference to the `lodash` function.
	         *
	         * @memberOf _.templateSettings.imports
	         * @type Function
	         */
	        '_': lodash
	      }
	    };
	
	    /*--------------------------------------------------------------------------*/
	
	    /**
	     * The template used to create iterator functions.
	     *
	     * @private
	     * @param {Object} data The data object used to populate the text.
	     * @returns {string} Returns the interpolated text.
	     */
	    var iteratorTemplate = function(obj) {
	
	      var __p = 'var index, iterable = ' +
	      (obj.firstArg) +
	      ', result = ' +
	      (obj.init) +
	      ';\nif (!iterable) return result;\n' +
	      (obj.top) +
	      ';';
	       if (obj.array) {
	      __p += '\nvar length = iterable.length; index = -1;\nif (' +
	      (obj.array) +
	      ') {  ';
	       if (support.unindexedChars) {
	      __p += '\n  if (isString(iterable)) {\n    iterable = iterable.split(\'\')\n  }  ';
	       }
	      __p += '\n  while (++index < length) {\n    ' +
	      (obj.loop) +
	      ';\n  }\n}\nelse {  ';
	       } else if (support.nonEnumArgs) {
	      __p += '\n  var length = iterable.length; index = -1;\n  if (length && isArguments(iterable)) {\n    while (++index < length) {\n      index += \'\';\n      ' +
	      (obj.loop) +
	      ';\n    }\n  } else {  ';
	       }
	
	       if (support.enumPrototypes) {
	      __p += '\n  var skipProto = typeof iterable == \'function\';\n  ';
	       }
	
	       if (support.enumErrorProps) {
	      __p += '\n  var skipErrorProps = iterable === errorProto || iterable instanceof Error;\n  ';
	       }
	
	          var conditions = [];    if (support.enumPrototypes) { conditions.push('!(skipProto && index == "prototype")'); }    if (support.enumErrorProps)  { conditions.push('!(skipErrorProps && (index == "message" || index == "name"))'); }
	
	       if (obj.useHas && obj.keys) {
	      __p += '\n  var ownIndex = -1,\n      ownProps = objectTypes[typeof iterable] && keys(iterable),\n      length = ownProps ? ownProps.length : 0;\n\n  while (++ownIndex < length) {\n    index = ownProps[ownIndex];\n';
	          if (conditions.length) {
	      __p += '    if (' +
	      (conditions.join(' && ')) +
	      ') {\n  ';
	       }
	      __p +=
	      (obj.loop) +
	      ';    ';
	       if (conditions.length) {
	      __p += '\n    }';
	       }
	      __p += '\n  }  ';
	       } else {
	      __p += '\n  for (index in iterable) {\n';
	          if (obj.useHas) { conditions.push("hasOwnProperty.call(iterable, index)"); }    if (conditions.length) {
	      __p += '    if (' +
	      (conditions.join(' && ')) +
	      ') {\n  ';
	       }
	      __p +=
	      (obj.loop) +
	      ';    ';
	       if (conditions.length) {
	      __p += '\n    }';
	       }
	      __p += '\n  }    ';
	       if (support.nonEnumShadows) {
	      __p += '\n\n  if (iterable !== objectProto) {\n    var ctor = iterable.constructor,\n        isProto = iterable === (ctor && ctor.prototype),\n        className = iterable === stringProto ? stringClass : iterable === errorProto ? errorClass : toString.call(iterable),\n        nonEnum = nonEnumProps[className];\n      ';
	       for (k = 0; k < 7; k++) {
	      __p += '\n    index = \'' +
	      (obj.shadowedProps[k]) +
	      '\';\n    if ((!(isProto && nonEnum[index]) && hasOwnProperty.call(iterable, index))';
	              if (!obj.useHas) {
	      __p += ' || (!nonEnum[index] && iterable[index] !== objectProto[index])';
	       }
	      __p += ') {\n      ' +
	      (obj.loop) +
	      ';\n    }      ';
	       }
	      __p += '\n  }    ';
	       }
	
	       }
	
	       if (obj.array || support.nonEnumArgs) {
	      __p += '\n}';
	       }
	      __p +=
	      (obj.bottom) +
	      ';\nreturn result';
	
	      return __p
	    };
	
	    /*--------------------------------------------------------------------------*/
	
	    /**
	     * The base implementation of `_.bind` that creates the bound function and
	     * sets its meta data.
	     *
	     * @private
	     * @param {Array} bindData The bind data array.
	     * @returns {Function} Returns the new bound function.
	     */
	    function baseBind(bindData) {
	      var func = bindData[0],
	          partialArgs = bindData[2],
	          thisArg = bindData[4];
	
	      function bound() {
	        // `Function#bind` spec
	        // http://es5.github.io/#x15.3.4.5
	        if (partialArgs) {
	          // avoid `arguments` object deoptimizations by using `slice` instead
	          // of `Array.prototype.slice.call` and not assigning `arguments` to a
	          // variable as a ternary expression
	          var args = slice(partialArgs);
	          push.apply(args, arguments);
	        }
	        // mimic the constructor's `return` behavior
	        // http://es5.github.io/#x13.2.2
	        if (this instanceof bound) {
	          // ensure `new bound` is an instance of `func`
	          var thisBinding = baseCreate(func.prototype),
	              result = func.apply(thisBinding, args || arguments);
	          return isObject(result) ? result : thisBinding;
	        }
	        return func.apply(thisArg, args || arguments);
	      }
	      setBindData(bound, bindData);
	      return bound;
	    }
	
	    /**
	     * The base implementation of `_.clone` without argument juggling or support
	     * for `thisArg` binding.
	     *
	     * @private
	     * @param {*} value The value to clone.
	     * @param {boolean} [isDeep=false] Specify a deep clone.
	     * @param {Function} [callback] The function to customize cloning values.
	     * @param {Array} [stackA=[]] Tracks traversed source objects.
	     * @param {Array} [stackB=[]] Associates clones with source counterparts.
	     * @returns {*} Returns the cloned value.
	     */
	    function baseClone(value, isDeep, callback, stackA, stackB) {
	      if (callback) {
	        var result = callback(value);
	        if (typeof result != 'undefined') {
	          return result;
	        }
	      }
	      // inspect [[Class]]
	      var isObj = isObject(value);
	      if (isObj) {
	        var className = toString.call(value);
	        if (!cloneableClasses[className] || (!support.nodeClass && isNode(value))) {
	          return value;
	        }
	        var ctor = ctorByClass[className];
	        switch (className) {
	          case boolClass:
	          case dateClass:
	            return new ctor(+value);
	
	          case numberClass:
	          case stringClass:
	            return new ctor(value);
	
	          case regexpClass:
	            result = ctor(value.source, reFlags.exec(value));
	            result.lastIndex = value.lastIndex;
	            return result;
	        }
	      } else {
	        return value;
	      }
	      var isArr = isArray(value);
	      if (isDeep) {
	        // check for circular references and return corresponding clone
	        var initedStack = !stackA;
	        stackA || (stackA = getArray());
	        stackB || (stackB = getArray());
	
	        var length = stackA.length;
	        while (length--) {
	          if (stackA[length] == value) {
	            return stackB[length];
	          }
	        }
	        result = isArr ? ctor(value.length) : {};
	      }
	      else {
	        result = isArr ? slice(value) : assign({}, value);
	      }
	      // add array properties assigned by `RegExp#exec`
	      if (isArr) {
	        if (hasOwnProperty.call(value, 'index')) {
	          result.index = value.index;
	        }
	        if (hasOwnProperty.call(value, 'input')) {
	          result.input = value.input;
	        }
	      }
	      // exit for shallow clone
	      if (!isDeep) {
	        return result;
	      }
	      // add the source value to the stack of traversed objects
	      // and associate it with its clone
	      stackA.push(value);
	      stackB.push(result);
	
	      // recursively populate clone (susceptible to call stack limits)
	      (isArr ? baseEach : forOwn)(value, function(objValue, key) {
	        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
	      });
	
	      if (initedStack) {
	        releaseArray(stackA);
	        releaseArray(stackB);
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.create` without support for assigning
	     * properties to the created object.
	     *
	     * @private
	     * @param {Object} prototype The object to inherit from.
	     * @returns {Object} Returns the new object.
	     */
	    function baseCreate(prototype, properties) {
	      return isObject(prototype) ? nativeCreate(prototype) : {};
	    }
	    // fallback for browsers without `Object.create`
	    if (!nativeCreate) {
	      baseCreate = (function() {
	        function Object() {}
	        return function(prototype) {
	          if (isObject(prototype)) {
	            Object.prototype = prototype;
	            var result = new Object;
	            Object.prototype = null;
	          }
	          return result || context.Object();
	        };
	      }());
	    }
	
	    /**
	     * The base implementation of `_.createCallback` without support for creating
	     * "_.pluck" or "_.where" style callbacks.
	     *
	     * @private
	     * @param {*} [func=identity] The value to convert to a callback.
	     * @param {*} [thisArg] The `this` binding of the created callback.
	     * @param {number} [argCount] The number of arguments the callback accepts.
	     * @returns {Function} Returns a callback function.
	     */
	    function baseCreateCallback(func, thisArg, argCount) {
	      if (typeof func != 'function') {
	        return identity;
	      }
	      // exit early for no `thisArg` or already bound by `Function#bind`
	      if (typeof thisArg == 'undefined' || !('prototype' in func)) {
	        return func;
	      }
	      var bindData = func.__bindData__;
	      if (typeof bindData == 'undefined') {
	        if (support.funcNames) {
	          bindData = !func.name;
	        }
	        bindData = bindData || !support.funcDecomp;
	        if (!bindData) {
	          var source = fnToString.call(func);
	          if (!support.funcNames) {
	            bindData = !reFuncName.test(source);
	          }
	          if (!bindData) {
	            // checks if `func` references the `this` keyword and stores the result
	            bindData = reThis.test(source);
	            setBindData(func, bindData);
	          }
	        }
	      }
	      // exit early if there are no `this` references or `func` is bound
	      if (bindData === false || (bindData !== true && bindData[1] & 1)) {
	        return func;
	      }
	      switch (argCount) {
	        case 1: return function(value) {
	          return func.call(thisArg, value);
	        };
	        case 2: return function(a, b) {
	          return func.call(thisArg, a, b);
	        };
	        case 3: return function(value, index, collection) {
	          return func.call(thisArg, value, index, collection);
	        };
	        case 4: return function(accumulator, value, index, collection) {
	          return func.call(thisArg, accumulator, value, index, collection);
	        };
	      }
	      return bind(func, thisArg);
	    }
	
	    /**
	     * The base implementation of `createWrapper` that creates the wrapper and
	     * sets its meta data.
	     *
	     * @private
	     * @param {Array} bindData The bind data array.
	     * @returns {Function} Returns the new function.
	     */
	    function baseCreateWrapper(bindData) {
	      var func = bindData[0],
	          bitmask = bindData[1],
	          partialArgs = bindData[2],
	          partialRightArgs = bindData[3],
	          thisArg = bindData[4],
	          arity = bindData[5];
	
	      var isBind = bitmask & 1,
	          isBindKey = bitmask & 2,
	          isCurry = bitmask & 4,
	          isCurryBound = bitmask & 8,
	          key = func;
	
	      function bound() {
	        var thisBinding = isBind ? thisArg : this;
	        if (partialArgs) {
	          var args = slice(partialArgs);
	          push.apply(args, arguments);
	        }
	        if (partialRightArgs || isCurry) {
	          args || (args = slice(arguments));
	          if (partialRightArgs) {
	            push.apply(args, partialRightArgs);
	          }
	          if (isCurry && args.length < arity) {
	            bitmask |= 16 & ~32;
	            return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
	          }
	        }
	        args || (args = arguments);
	        if (isBindKey) {
	          func = thisBinding[key];
	        }
	        if (this instanceof bound) {
	          thisBinding = baseCreate(func.prototype);
	          var result = func.apply(thisBinding, args);
	          return isObject(result) ? result : thisBinding;
	        }
	        return func.apply(thisBinding, args);
	      }
	      setBindData(bound, bindData);
	      return bound;
	    }
	
	    /**
	     * The base implementation of `_.difference` that accepts a single array
	     * of values to exclude.
	     *
	     * @private
	     * @param {Array} array The array to process.
	     * @param {Array} [values] The array of values to exclude.
	     * @returns {Array} Returns a new array of filtered values.
	     */
	    function baseDifference(array, values) {
	      var index = -1,
	          indexOf = getIndexOf(),
	          length = array ? array.length : 0,
	          isLarge = length >= largeArraySize && indexOf === baseIndexOf,
	          result = [];
	
	      if (isLarge) {
	        var cache = createCache(values);
	        if (cache) {
	          indexOf = cacheIndexOf;
	          values = cache;
	        } else {
	          isLarge = false;
	        }
	      }
	      while (++index < length) {
	        var value = array[index];
	        if (indexOf(values, value) < 0) {
	          result.push(value);
	        }
	      }
	      if (isLarge) {
	        releaseObject(values);
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.flatten` without support for callback
	     * shorthands or `thisArg` binding.
	     *
	     * @private
	     * @param {Array} array The array to flatten.
	     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
	     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
	     * @param {number} [fromIndex=0] The index to start from.
	     * @returns {Array} Returns a new flattened array.
	     */
	    function baseFlatten(array, isShallow, isStrict, fromIndex) {
	      var index = (fromIndex || 0) - 1,
	          length = array ? array.length : 0,
	          result = [];
	
	      while (++index < length) {
	        var value = array[index];
	
	        if (value && typeof value == 'object' && typeof value.length == 'number'
	            && (isArray(value) || isArguments(value))) {
	          // recursively flatten arrays (susceptible to call stack limits)
	          if (!isShallow) {
	            value = baseFlatten(value, isShallow, isStrict);
	          }
	          var valIndex = -1,
	              valLength = value.length,
	              resIndex = result.length;
	
	          result.length += valLength;
	          while (++valIndex < valLength) {
	            result[resIndex++] = value[valIndex];
	          }
	        } else if (!isStrict) {
	          result.push(value);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.isEqual`, without support for `thisArg` binding,
	     * that allows partial "_.where" style comparisons.
	     *
	     * @private
	     * @param {*} a The value to compare.
	     * @param {*} b The other value to compare.
	     * @param {Function} [callback] The function to customize comparing values.
	     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
	     * @param {Array} [stackA=[]] Tracks traversed `a` objects.
	     * @param {Array} [stackB=[]] Tracks traversed `b` objects.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     */
	    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
	      // used to indicate that when comparing objects, `a` has at least the properties of `b`
	      if (callback) {
	        var result = callback(a, b);
	        if (typeof result != 'undefined') {
	          return !!result;
	        }
	      }
	      // exit early for identical values
	      if (a === b) {
	        // treat `+0` vs. `-0` as not equal
	        return a !== 0 || (1 / a == 1 / b);
	      }
	      var type = typeof a,
	          otherType = typeof b;
	
	      // exit early for unlike primitive values
	      if (a === a &&
	          !(a && objectTypes[type]) &&
	          !(b && objectTypes[otherType])) {
	        return false;
	      }
	      // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
	      // http://es5.github.io/#x15.3.4.4
	      if (a == null || b == null) {
	        return a === b;
	      }
	      // compare [[Class]] names
	      var className = toString.call(a),
	          otherClass = toString.call(b);
	
	      if (className == argsClass) {
	        className = objectClass;
	      }
	      if (otherClass == argsClass) {
	        otherClass = objectClass;
	      }
	      if (className != otherClass) {
	        return false;
	      }
	      switch (className) {
	        case boolClass:
	        case dateClass:
	          // coerce dates and booleans to numbers, dates to milliseconds and booleans
	          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
	          return +a == +b;
	
	        case numberClass:
	          // treat `NaN` vs. `NaN` as equal
	          return (a != +a)
	            ? b != +b
	            // but treat `+0` vs. `-0` as not equal
	            : (a == 0 ? (1 / a == 1 / b) : a == +b);
	
	        case regexpClass:
	        case stringClass:
	          // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
	          // treat string primitives and their corresponding object instances as equal
	          return a == String(b);
	      }
	      var isArr = className == arrayClass;
	      if (!isArr) {
	        // unwrap any `lodash` wrapped values
	        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
	            bWrapped = hasOwnProperty.call(b, '__wrapped__');
	
	        if (aWrapped || bWrapped) {
	          return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
	        }
	        // exit for functions and DOM nodes
	        if (className != objectClass || (!support.nodeClass && (isNode(a) || isNode(b)))) {
	          return false;
	        }
	        // in older versions of Opera, `arguments` objects have `Array` constructors
	        var ctorA = !support.argsObject && isArguments(a) ? Object : a.constructor,
	            ctorB = !support.argsObject && isArguments(b) ? Object : b.constructor;
	
	        // non `Object` object instances with different constructors are not equal
	        if (ctorA != ctorB &&
	              !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
	              ('constructor' in a && 'constructor' in b)
	            ) {
	          return false;
	        }
	      }
	      // assume cyclic structures are equal
	      // the algorithm for detecting cyclic structures is adapted from ES 5.1
	      // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
	      var initedStack = !stackA;
	      stackA || (stackA = getArray());
	      stackB || (stackB = getArray());
	
	      var length = stackA.length;
	      while (length--) {
	        if (stackA[length] == a) {
	          return stackB[length] == b;
	        }
	      }
	      var size = 0;
	      result = true;
	
	      // add `a` and `b` to the stack of traversed objects
	      stackA.push(a);
	      stackB.push(b);
	
	      // recursively compare objects and arrays (susceptible to call stack limits)
	      if (isArr) {
	        // compare lengths to determine if a deep comparison is necessary
	        length = a.length;
	        size = b.length;
	        result = size == length;
	
	        if (result || isWhere) {
	          // deep compare the contents, ignoring non-numeric properties
	          while (size--) {
	            var index = length,
	                value = b[size];
	
	            if (isWhere) {
	              while (index--) {
	                if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
	                  break;
	                }
	              }
	            } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
	              break;
	            }
	          }
	        }
	      }
	      else {
	        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
	        // which, in this case, is more costly
	        forIn(b, function(value, key, b) {
	          if (hasOwnProperty.call(b, key)) {
	            // count the number of properties.
	            size++;
	            // deep compare each property value.
	            return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
	          }
	        });
	
	        if (result && !isWhere) {
	          // ensure both objects have the same number of properties
	          forIn(a, function(value, key, a) {
	            if (hasOwnProperty.call(a, key)) {
	              // `size` will be `-1` if `a` has more properties than `b`
	              return (result = --size > -1);
	            }
	          });
	        }
	      }
	      stackA.pop();
	      stackB.pop();
	
	      if (initedStack) {
	        releaseArray(stackA);
	        releaseArray(stackB);
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.merge` without argument juggling or support
	     * for `thisArg` binding.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {Function} [callback] The function to customize merging properties.
	     * @param {Array} [stackA=[]] Tracks traversed source objects.
	     * @param {Array} [stackB=[]] Associates values with source counterparts.
	     */
	    function baseMerge(object, source, callback, stackA, stackB) {
	      (isArray(source) ? forEach : forOwn)(source, function(source, key) {
	        var found,
	            isArr,
	            result = source,
	            value = object[key];
	
	        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
	          // avoid merging previously merged cyclic sources
	          var stackLength = stackA.length;
	          while (stackLength--) {
	            if ((found = stackA[stackLength] == source)) {
	              value = stackB[stackLength];
	              break;
	            }
	          }
	          if (!found) {
	            var isShallow;
	            if (callback) {
	              result = callback(value, source);
	              if ((isShallow = typeof result != 'undefined')) {
	                value = result;
	              }
	            }
	            if (!isShallow) {
	              value = isArr
	                ? (isArray(value) ? value : [])
	                : (isPlainObject(value) ? value : {});
	            }
	            // add `source` and associated `value` to the stack of traversed objects
	            stackA.push(source);
	            stackB.push(value);
	
	            // recursively merge objects and arrays (susceptible to call stack limits)
	            if (!isShallow) {
	              baseMerge(value, source, callback, stackA, stackB);
	            }
	          }
	        }
	        else {
	          if (callback) {
	            result = callback(value, source);
	            if (typeof result == 'undefined') {
	              result = source;
	            }
	          }
	          if (typeof result != 'undefined') {
	            value = result;
	          }
	        }
	        object[key] = value;
	      });
	    }
	
	    /**
	     * The base implementation of `_.random` without argument juggling or support
	     * for returning floating-point numbers.
	     *
	     * @private
	     * @param {number} min The minimum possible value.
	     * @param {number} max The maximum possible value.
	     * @returns {number} Returns a random number.
	     */
	    function baseRandom(min, max) {
	      return min + floor(nativeRandom() * (max - min + 1));
	    }
	
	    /**
	     * The base implementation of `_.uniq` without support for callback shorthands
	     * or `thisArg` binding.
	     *
	     * @private
	     * @param {Array} array The array to process.
	     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
	     * @param {Function} [callback] The function called per iteration.
	     * @returns {Array} Returns a duplicate-value-free array.
	     */
	    function baseUniq(array, isSorted, callback) {
	      var index = -1,
	          indexOf = getIndexOf(),
	          length = array ? array.length : 0,
	          result = [];
	
	      var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
	          seen = (callback || isLarge) ? getArray() : result;
	
	      if (isLarge) {
	        var cache = createCache(seen);
	        indexOf = cacheIndexOf;
	        seen = cache;
	      }
	      while (++index < length) {
	        var value = array[index],
	            computed = callback ? callback(value, index, array) : value;
	
	        if (isSorted
	              ? !index || seen[seen.length - 1] !== computed
	              : indexOf(seen, computed) < 0
	            ) {
	          if (callback || isLarge) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	      }
	      if (isLarge) {
	        releaseArray(seen.array);
	        releaseObject(seen);
	      } else if (callback) {
	        releaseArray(seen);
	      }
	      return result;
	    }
	
	    /**
	     * Creates a function that aggregates a collection, creating an object composed
	     * of keys generated from the results of running each element of the collection
	     * through a callback. The given `setter` function sets the keys and values
	     * of the composed object.
	     *
	     * @private
	     * @param {Function} setter The setter function.
	     * @returns {Function} Returns the new aggregator function.
	     */
	    function createAggregator(setter) {
	      return function(collection, callback, thisArg) {
	        var result = {};
	        callback = lodash.createCallback(callback, thisArg, 3);
	
	        if (isArray(collection)) {
	          var index = -1,
	              length = collection.length;
	
	          while (++index < length) {
	            var value = collection[index];
	            setter(result, value, callback(value, index, collection), collection);
	          }
	        } else {
	          baseEach(collection, function(value, key, collection) {
	            setter(result, value, callback(value, key, collection), collection);
	          });
	        }
	        return result;
	      };
	    }
	
	    /**
	     * Creates a function that, when called, either curries or invokes `func`
	     * with an optional `this` binding and partially applied arguments.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to reference.
	     * @param {number} bitmask The bitmask of method flags to compose.
	     *  The bitmask may be composed of the following flags:
	     *  1 - `_.bind`
	     *  2 - `_.bindKey`
	     *  4 - `_.curry`
	     *  8 - `_.curry` (bound)
	     *  16 - `_.partial`
	     *  32 - `_.partialRight`
	     * @param {Array} [partialArgs] An array of arguments to prepend to those
	     *  provided to the new function.
	     * @param {Array} [partialRightArgs] An array of arguments to append to those
	     *  provided to the new function.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new function.
	     */
	    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
	      var isBind = bitmask & 1,
	          isBindKey = bitmask & 2,
	          isCurry = bitmask & 4,
	          isCurryBound = bitmask & 8,
	          isPartial = bitmask & 16,
	          isPartialRight = bitmask & 32;
	
	      if (!isBindKey && !isFunction(func)) {
	        throw new TypeError;
	      }
	      if (isPartial && !partialArgs.length) {
	        bitmask &= ~16;
	        isPartial = partialArgs = false;
	      }
	      if (isPartialRight && !partialRightArgs.length) {
	        bitmask &= ~32;
	        isPartialRight = partialRightArgs = false;
	      }
	      var bindData = func && func.__bindData__;
	      if (bindData && bindData !== true) {
	        // clone `bindData`
	        bindData = slice(bindData);
	        if (bindData[2]) {
	          bindData[2] = slice(bindData[2]);
	        }
	        if (bindData[3]) {
	          bindData[3] = slice(bindData[3]);
	        }
	        // set `thisBinding` is not previously bound
	        if (isBind && !(bindData[1] & 1)) {
	          bindData[4] = thisArg;
	        }
	        // set if previously bound but not currently (subsequent curried functions)
	        if (!isBind && bindData[1] & 1) {
	          bitmask |= 8;
	        }
	        // set curried arity if not yet set
	        if (isCurry && !(bindData[1] & 4)) {
	          bindData[5] = arity;
	        }
	        // append partial left arguments
	        if (isPartial) {
	          push.apply(bindData[2] || (bindData[2] = []), partialArgs);
	        }
	        // append partial right arguments
	        if (isPartialRight) {
	          unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
	        }
	        // merge flags
	        bindData[1] |= bitmask;
	        return createWrapper.apply(null, bindData);
	      }
	      // fast path for `_.bind`
	      var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
	      return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
	    }
	
	    /**
	     * Creates compiled iteration functions.
	     *
	     * @private
	     * @param {...Object} [options] The compile options object(s).
	     * @param {string} [options.array] Code to determine if the iterable is an array or array-like.
	     * @param {boolean} [options.useHas] Specify using `hasOwnProperty` checks in the object loop.
	     * @param {Function} [options.keys] A reference to `_.keys` for use in own property iteration.
	     * @param {string} [options.args] A comma separated string of iteration function arguments.
	     * @param {string} [options.top] Code to execute before the iteration branches.
	     * @param {string} [options.loop] Code to execute in the object loop.
	     * @param {string} [options.bottom] Code to execute after the iteration branches.
	     * @returns {Function} Returns the compiled function.
	     */
	    function createIterator() {
	      // data properties
	      iteratorData.shadowedProps = shadowedProps;
	
	      // iterator options
	      iteratorData.array = iteratorData.bottom = iteratorData.loop = iteratorData.top = '';
	      iteratorData.init = 'iterable';
	      iteratorData.useHas = true;
	
	      // merge options into a template data object
	      for (var object, index = 0; object = arguments[index]; index++) {
	        for (var key in object) {
	          iteratorData[key] = object[key];
	        }
	      }
	      var args = iteratorData.args;
	      iteratorData.firstArg = /^[^,]+/.exec(args)[0];
	
	      // create the function factory
	      var factory = Function(
	          'baseCreateCallback, errorClass, errorProto, hasOwnProperty, ' +
	          'indicatorObject, isArguments, isArray, isString, keys, objectProto, ' +
	          'objectTypes, nonEnumProps, stringClass, stringProto, toString',
	        'return function(' + args + ') {\n' + iteratorTemplate(iteratorData) + '\n}'
	      );
	
	      // return the compiled function
	      return factory(
	        baseCreateCallback, errorClass, errorProto, hasOwnProperty,
	        indicatorObject, isArguments, isArray, isString, iteratorData.keys, objectProto,
	        objectTypes, nonEnumProps, stringClass, stringProto, toString
	      );
	    }
	
	    /**
	     * Used by `escape` to convert characters to HTML entities.
	     *
	     * @private
	     * @param {string} match The matched character to escape.
	     * @returns {string} Returns the escaped character.
	     */
	    function escapeHtmlChar(match) {
	      return htmlEscapes[match];
	    }
	
	    /**
	     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
	     * customized, this method returns the custom method, otherwise it returns
	     * the `baseIndexOf` function.
	     *
	     * @private
	     * @returns {Function} Returns the "indexOf" function.
	     */
	    function getIndexOf() {
	      var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
	      return result;
	    }
	
	    /**
	     * Checks if `value` is a native function.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
	     */
	    function isNative(value) {
	      return typeof value == 'function' && reNative.test(value);
	    }
	
	    /**
	     * Sets `this` binding data on a given function.
	     *
	     * @private
	     * @param {Function} func The function to set data on.
	     * @param {Array} value The data array to set.
	     */
	    var setBindData = !defineProperty ? noop : function(func, value) {
	      descriptor.value = value;
	      defineProperty(func, '__bindData__', descriptor);
	    };
	
	    /**
	     * A fallback implementation of `isPlainObject` which checks if a given value
	     * is an object created by the `Object` constructor, assuming objects created
	     * by the `Object` constructor have no inherited enumerable properties and that
	     * there are no `Object.prototype` extensions.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	     */
	    function shimIsPlainObject(value) {
	      var ctor,
	          result;
	
	      // avoid non Object objects, `arguments` objects, and DOM elements
	      if (!(value && toString.call(value) == objectClass) ||
	          (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor)) ||
	          (!support.argsClass && isArguments(value)) ||
	          (!support.nodeClass && isNode(value))) {
	        return false;
	      }
	      // IE < 9 iterates inherited properties before own properties. If the first
	      // iterated property is an object's own property then there are no inherited
	      // enumerable properties.
	      if (support.ownLast) {
	        forIn(value, function(value, key, object) {
	          result = hasOwnProperty.call(object, key);
	          return false;
	        });
	        return result !== false;
	      }
	      // In most environments an object's own properties are iterated before
	      // its inherited properties. If the last iterated property is an object's
	      // own property then there are no inherited enumerable properties.
	      forIn(value, function(value, key) {
	        result = key;
	      });
	      return typeof result == 'undefined' || hasOwnProperty.call(value, result);
	    }
	
	    /**
	     * Used by `unescape` to convert HTML entities to characters.
	     *
	     * @private
	     * @param {string} match The matched character to unescape.
	     * @returns {string} Returns the unescaped character.
	     */
	    function unescapeHtmlChar(match) {
	      return htmlUnescapes[match];
	    }
	
	    /*--------------------------------------------------------------------------*/
	
	    /**
	     * Checks if `value` is an `arguments` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
	     * @example
	     *
	     * (function() { return _.isArguments(arguments); })(1, 2, 3);
	     * // => true
	     *
	     * _.isArguments([1, 2, 3]);
	     * // => false
	     */
	    function isArguments(value) {
	      return value && typeof value == 'object' && typeof value.length == 'number' &&
	        toString.call(value) == argsClass || false;
	    }
	    // fallback for browsers that can't detect `arguments` objects by [[Class]]
	    if (!support.argsClass) {
	      isArguments = function(value) {
	        return value && typeof value == 'object' && typeof value.length == 'number' &&
	          hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee') || false;
	      };
	    }
	
	    /**
	     * Checks if `value` is an array.
	     *
	     * @static
	     * @memberOf _
	     * @type Function
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
	     * @example
	     *
	     * (function() { return _.isArray(arguments); })();
	     * // => false
	     *
	     * _.isArray([1, 2, 3]);
	     * // => true
	     */
	    var isArray = nativeIsArray || function(value) {
	      return value && typeof value == 'object' && typeof value.length == 'number' &&
	        toString.call(value) == arrayClass || false;
	    };
	
	    /**
	     * A fallback implementation of `Object.keys` which produces an array of the
	     * given object's own enumerable property names.
	     *
	     * @private
	     * @type Function
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns an array of property names.
	     */
	    var shimKeys = createIterator({
	      'args': 'object',
	      'init': '[]',
	      'top': 'if (!(objectTypes[typeof object])) return result',
	      'loop': 'result.push(index)'
	    });
	
	    /**
	     * Creates an array composed of the own enumerable property names of an object.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns an array of property names.
	     * @example
	     *
	     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
	     * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
	     */
	    var keys = !nativeKeys ? shimKeys : function(object) {
	      if (!isObject(object)) {
	        return [];
	      }
	      if ((support.enumPrototypes && typeof object == 'function') ||
	          (support.nonEnumArgs && object.length && isArguments(object))) {
	        return shimKeys(object);
	      }
	      return nativeKeys(object);
	    };
	
	    /** Reusable iterator options shared by `each`, `forIn`, and `forOwn` */
	    var eachIteratorOptions = {
	      'args': 'collection, callback, thisArg',
	      'top': "callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3)",
	      'array': "typeof length == 'number'",
	      'keys': keys,
	      'loop': 'if (callback(iterable[index], index, collection) === false) return result'
	    };
	
	    /** Reusable iterator options for `assign` and `defaults` */
	    var defaultsIteratorOptions = {
	      'args': 'object, source, guard',
	      'top':
	        'var args = arguments,\n' +
	        '    argsIndex = 0,\n' +
	        "    argsLength = typeof guard == 'number' ? 2 : args.length;\n" +
	        'while (++argsIndex < argsLength) {\n' +
	        '  iterable = args[argsIndex];\n' +
	        '  if (iterable && objectTypes[typeof iterable]) {',
	      'keys': keys,
	      'loop': "if (typeof result[index] == 'undefined') result[index] = iterable[index]",
	      'bottom': '  }\n}'
	    };
	
	    /** Reusable iterator options for `forIn` and `forOwn` */
	    var forOwnIteratorOptions = {
	      'top': 'if (!objectTypes[typeof iterable]) return result;\n' + eachIteratorOptions.top,
	      'array': false
	    };
	
	    /**
	     * Used to convert characters to HTML entities:
	     *
	     * Though the `>` character is escaped for symmetry, characters like `>` and `/`
	     * don't require escaping in HTML and have no special meaning unless they're part
	     * of a tag or an unquoted attribute value.
	     * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
	     */
	    var htmlEscapes = {
	      '&': '&amp;',
	      '<': '&lt;',
	      '>': '&gt;',
	      '"': '&quot;',
	      "'": '&#39;'
	    };
	
	    /** Used to convert HTML entities to characters */
	    var htmlUnescapes = invert(htmlEscapes);
	
	    /** Used to match HTML entities and HTML characters */
	    var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
	        reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');
	
	    /**
	     * A function compiled to iterate `arguments` objects, arrays, objects, and
	     * strings consistenly across environments, executing the callback for each
	     * element in the collection. The callback is bound to `thisArg` and invoked
	     * with three arguments; (value, index|key, collection). Callbacks may exit
	     * iteration early by explicitly returning `false`.
	     *
	     * @private
	     * @type Function
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [callback=identity] The function called per iteration.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array|Object|string} Returns `collection`.
	     */
	    var baseEach = createIterator(eachIteratorOptions);
	
	    /*--------------------------------------------------------------------------*/
	
	    /**
	     * Assigns own enumerable properties of source object(s) to the destination
	     * object. Subsequent sources will overwrite property assignments of previous
	     * sources. If a callback is provided it will be executed to produce the
	     * assigned values. The callback is bound to `thisArg` and invoked with two
	     * arguments; (objectValue, sourceValue).
	     *
	     * @static
	     * @memberOf _
	     * @type Function
	     * @alias extend
	     * @category Objects
	     * @param {Object} object The destination object.
	     * @param {...Object} [source] The source objects.
	     * @param {Function} [callback] The function to customize assigning values.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Object} Returns the destination object.
	     * @example
	     *
	     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
	     * // => { 'name': 'fred', 'employer': 'slate' }
	     *
	     * var defaults = _.partialRight(_.assign, function(a, b) {
	     *   return typeof a == 'undefined' ? b : a;
	     * });
	     *
	     * var object = { 'name': 'barney' };
	     * defaults(object, { 'name': 'fred', 'employer': 'slate' });
	     * // => { 'name': 'barney', 'employer': 'slate' }
	     */
	    var assign = createIterator(defaultsIteratorOptions, {
	      'top':
	        defaultsIteratorOptions.top.replace(';',
	          ';\n' +
	          "if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {\n" +
	          '  var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);\n' +
	          "} else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {\n" +
	          '  callback = args[--argsLength];\n' +
	          '}'
	        ),
	      'loop': 'result[index] = callback ? callback(result[index], iterable[index]) : iterable[index]'
	    });
	
	    /**
	     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
	     * be cloned, otherwise they will be assigned by reference. If a callback
	     * is provided it will be executed to produce the cloned values. If the
	     * callback returns `undefined` cloning will be handled by the method instead.
	     * The callback is bound to `thisArg` and invoked with one argument; (value).
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to clone.
	     * @param {boolean} [isDeep=false] Specify a deep clone.
	     * @param {Function} [callback] The function to customize cloning values.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {*} Returns the cloned value.
	     * @example
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36 },
	     *   { 'name': 'fred',   'age': 40 }
	     * ];
	     *
	     * var shallow = _.clone(characters);
	     * shallow[0] === characters[0];
	     * // => true
	     *
	     * var deep = _.clone(characters, true);
	     * deep[0] === characters[0];
	     * // => false
	     *
	     * _.mixin({
	     *   'clone': _.partialRight(_.clone, function(value) {
	     *     return _.isElement(value) ? value.cloneNode(false) : undefined;
	     *   })
	     * });
	     *
	     * var clone = _.clone(document.body);
	     * clone.childNodes.length;
	     * // => 0
	     */
	    function clone(value, isDeep, callback, thisArg) {
	      // allows working with "Collections" methods without using their `index`
	      // and `collection` arguments for `isDeep` and `callback`
	      if (typeof isDeep != 'boolean' && isDeep != null) {
	        thisArg = callback;
	        callback = isDeep;
	        isDeep = false;
	      }
	      return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
	    }
	
	    /**
	     * Creates a deep clone of `value`. If a callback is provided it will be
	     * executed to produce the cloned values. If the callback returns `undefined`
	     * cloning will be handled by the method instead. The callback is bound to
	     * `thisArg` and invoked with one argument; (value).
	     *
	     * Note: This method is loosely based on the structured clone algorithm. Functions
	     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
	     * objects created by constructors other than `Object` are cloned to plain `Object` objects.
	     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to deep clone.
	     * @param {Function} [callback] The function to customize cloning values.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {*} Returns the deep cloned value.
	     * @example
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36 },
	     *   { 'name': 'fred',   'age': 40 }
	     * ];
	     *
	     * var deep = _.cloneDeep(characters);
	     * deep[0] === characters[0];
	     * // => false
	     *
	     * var view = {
	     *   'label': 'docs',
	     *   'node': element
	     * };
	     *
	     * var clone = _.cloneDeep(view, function(value) {
	     *   return _.isElement(value) ? value.cloneNode(true) : undefined;
	     * });
	     *
	     * clone.node == view.node;
	     * // => false
	     */
	    function cloneDeep(value, callback, thisArg) {
	      return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
	    }
	
	    /**
	     * Creates an object that inherits from the given `prototype` object. If a
	     * `properties` object is provided its own enumerable properties are assigned
	     * to the created object.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} prototype The object to inherit from.
	     * @param {Object} [properties] The properties to assign to the object.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * function Shape() {
	     *   this.x = 0;
	     *   this.y = 0;
	     * }
	     *
	     * function Circle() {
	     *   Shape.call(this);
	     * }
	     *
	     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
	     *
	     * var circle = new Circle;
	     * circle instanceof Circle;
	     * // => true
	     *
	     * circle instanceof Shape;
	     * // => true
	     */
	    function create(prototype, properties) {
	      var result = baseCreate(prototype);
	      return properties ? assign(result, properties) : result;
	    }
	
	    /**
	     * Assigns own enumerable properties of source object(s) to the destination
	     * object for all destination properties that resolve to `undefined`. Once a
	     * property is set, additional defaults of the same property will be ignored.
	     *
	     * @static
	     * @memberOf _
	     * @type Function
	     * @category Objects
	     * @param {Object} object The destination object.
	     * @param {...Object} [source] The source objects.
	     * @param- {Object} [guard] Allows working with `_.reduce` without using its
	     *  `key` and `object` arguments as sources.
	     * @returns {Object} Returns the destination object.
	     * @example
	     *
	     * var object = { 'name': 'barney' };
	     * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
	     * // => { 'name': 'barney', 'employer': 'slate' }
	     */
	    var defaults = createIterator(defaultsIteratorOptions);
	
	    /**
	     * This method is like `_.findIndex` except that it returns the key of the
	     * first element that passes the callback check, instead of the element itself.
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The object to search.
	     * @param {Function|Object|string} [callback=identity] The function called per
	     *  iteration. If a property name or object is provided it will be used to
	     *  create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
	     * @example
	     *
	     * var characters = {
	     *   'barney': {  'age': 36, 'blocked': false },
	     *   'fred': {    'age': 40, 'blocked': true },
	     *   'pebbles': { 'age': 1,  'blocked': false }
	     * };
	     *
	     * _.findKey(characters, function(chr) {
	     *   return chr.age < 40;
	     * });
	     * // => 'barney' (property order is not guaranteed across environments)
	     *
	     * // using "_.where" callback shorthand
	     * _.findKey(characters, { 'age': 1 });
	     * // => 'pebbles'
	     *
	     * // using "_.pluck" callback shorthand
	     * _.findKey(characters, 'blocked');
	     * // => 'fred'
	     */
	    function findKey(object, callback, thisArg) {
	      var result;
	      callback = lodash.createCallback(callback, thisArg, 3);
	      forOwn(object, function(value, key, object) {
	        if (callback(value, key, object)) {
	          result = key;
	          return false;
	        }
	      });
	      return result;
	    }
	
	    /**
	     * This method is like `_.findKey` except that it iterates over elements
	     * of a `collection` in the opposite order.
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The object to search.
	     * @param {Function|Object|string} [callback=identity] The function called per
	     *  iteration. If a property name or object is provided it will be used to
	     *  create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
	     * @example
	     *
	     * var characters = {
	     *   'barney': {  'age': 36, 'blocked': true },
	     *   'fred': {    'age': 40, 'blocked': false },
	     *   'pebbles': { 'age': 1,  'blocked': true }
	     * };
	     *
	     * _.findLastKey(characters, function(chr) {
	     *   return chr.age < 40;
	     * });
	     * // => returns `pebbles`, assuming `_.findKey` returns `barney`
	     *
	     * // using "_.where" callback shorthand
	     * _.findLastKey(characters, { 'age': 40 });
	     * // => 'fred'
	     *
	     * // using "_.pluck" callback shorthand
	     * _.findLastKey(characters, 'blocked');
	     * // => 'pebbles'
	     */
	    function findLastKey(object, callback, thisArg) {
	      var result;
	      callback = lodash.createCallback(callback, thisArg, 3);
	      forOwnRight(object, function(value, key, object) {
	        if (callback(value, key, object)) {
	          result = key;
	          return false;
	        }
	      });
	      return result;
	    }
	
	    /**
	     * Iterates over own and inherited enumerable properties of an object,
	     * executing the callback for each property. The callback is bound to `thisArg`
	     * and invoked with three arguments; (value, key, object). Callbacks may exit
	     * iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @type Function
	     * @category Objects
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [callback=identity] The function called per iteration.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Shape() {
	     *   this.x = 0;
	     *   this.y = 0;
	     * }
	     *
	     * Shape.prototype.move = function(x, y) {
	     *   this.x += x;
	     *   this.y += y;
	     * };
	     *
	     * _.forIn(new Shape, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
	     */
	    var forIn = createIterator(eachIteratorOptions, forOwnIteratorOptions, {
	      'useHas': false
	    });
	
	    /**
	     * This method is like `_.forIn` except that it iterates over elements
	     * of a `collection` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [callback=identity] The function called per iteration.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Shape() {
	     *   this.x = 0;
	     *   this.y = 0;
	     * }
	     *
	     * Shape.prototype.move = function(x, y) {
	     *   this.x += x;
	     *   this.y += y;
	     * };
	     *
	     * _.forInRight(new Shape, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'
	     */
	    function forInRight(object, callback, thisArg) {
	      var pairs = [];
	
	      forIn(object, function(value, key) {
	        pairs.push(key, value);
	      });
	
	      var length = pairs.length;
	      callback = baseCreateCallback(callback, thisArg, 3);
	      while (length--) {
	        if (callback(pairs[length--], pairs[length], object) === false) {
	          break;
	        }
	      }
	      return object;
	    }
	
	    /**
	     * Iterates over own enumerable properties of an object, executing the callback
	     * for each property. The callback is bound to `thisArg` and invoked with three
	     * arguments; (value, key, object). Callbacks may exit iteration early by
	     * explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @type Function
	     * @category Objects
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [callback=identity] The function called per iteration.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
	     *   console.log(key);
	     * });
	     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
	     */
	    var forOwn = createIterator(eachIteratorOptions, forOwnIteratorOptions);
	
	    /**
	     * This method is like `_.forOwn` except that it iterates over elements
	     * of a `collection` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [callback=identity] The function called per iteration.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
	     */
	    function forOwnRight(object, callback, thisArg) {
	      var props = keys(object),
	          length = props.length;
	
	      callback = baseCreateCallback(callback, thisArg, 3);
	      while (length--) {
	        var key = props[length];
	        if (callback(object[key], key, object) === false) {
	          break;
	        }
	      }
	      return object;
	    }
	
	    /**
	     * Creates a sorted array of property names of all enumerable properties,
	     * own and inherited, of `object` that have function values.
	     *
	     * @static
	     * @memberOf _
	     * @alias methods
	     * @category Objects
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns an array of property names that have function values.
	     * @example
	     *
	     * _.functions(_);
	     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
	     */
	    function functions(object) {
	      var result = [];
	      forIn(object, function(value, key) {
	        if (isFunction(value)) {
	          result.push(key);
	        }
	      });
	      return result.sort();
	    }
	
	    /**
	     * Checks if the specified property name exists as a direct property of `object`,
	     * instead of an inherited property.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The object to inspect.
	     * @param {string} key The name of the property to check.
	     * @returns {boolean} Returns `true` if key is a direct property, else `false`.
	     * @example
	     *
	     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
	     * // => true
	     */
	    function has(object, key) {
	      return object ? hasOwnProperty.call(object, key) : false;
	    }
	
	    /**
	     * Creates an object composed of the inverted keys and values of the given object.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The object to invert.
	     * @returns {Object} Returns the created inverted object.
	     * @example
	     *
	     * _.invert({ 'first': 'fred', 'second': 'barney' });
	     * // => { 'fred': 'first', 'barney': 'second' }
	     */
	    function invert(object) {
	      var index = -1,
	          props = keys(object),
	          length = props.length,
	          result = {};
	
	      while (++index < length) {
	        var key = props[index];
	        result[object[key]] = key;
	      }
	      return result;
	    }
	
	    /**
	     * Checks if `value` is a boolean value.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
	     * @example
	     *
	     * _.isBoolean(null);
	     * // => false
	     */
	    function isBoolean(value) {
	      return value === true || value === false ||
	        value && typeof value == 'object' && toString.call(value) == boolClass || false;
	    }
	
	    /**
	     * Checks if `value` is a date.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
	     * @example
	     *
	     * _.isDate(new Date);
	     * // => true
	     */
	    function isDate(value) {
	      return value && typeof value == 'object' && toString.call(value) == dateClass || false;
	    }
	
	    /**
	     * Checks if `value` is a DOM element.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
	     * @example
	     *
	     * _.isElement(document.body);
	     * // => true
	     */
	    function isElement(value) {
	      return value && value.nodeType === 1 || false;
	    }
	
	    /**
	     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
	     * length of `0` and objects with no own enumerable properties are considered
	     * "empty".
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Array|Object|string} value The value to inspect.
	     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
	     * @example
	     *
	     * _.isEmpty([1, 2, 3]);
	     * // => false
	     *
	     * _.isEmpty({});
	     * // => true
	     *
	     * _.isEmpty('');
	     * // => true
	     */
	    function isEmpty(value) {
	      var result = true;
	      if (!value) {
	        return result;
	      }
	      var className = toString.call(value),
	          length = value.length;
	
	      if ((className == arrayClass || className == stringClass ||
	          (support.argsClass ? className == argsClass : isArguments(value))) ||
	          (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
	        return !length;
	      }
	      forOwn(value, function() {
	        return (result = false);
	      });
	      return result;
	    }
	
	    /**
	     * Performs a deep comparison between two values to determine if they are
	     * equivalent to each other. If a callback is provided it will be executed
	     * to compare values. If the callback returns `undefined` comparisons will
	     * be handled by the method instead. The callback is bound to `thisArg` and
	     * invoked with two arguments; (a, b).
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} a The value to compare.
	     * @param {*} b The other value to compare.
	     * @param {Function} [callback] The function to customize comparing values.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * var object = { 'name': 'fred' };
	     * var copy = { 'name': 'fred' };
	     *
	     * object == copy;
	     * // => false
	     *
	     * _.isEqual(object, copy);
	     * // => true
	     *
	     * var words = ['hello', 'goodbye'];
	     * var otherWords = ['hi', 'goodbye'];
	     *
	     * _.isEqual(words, otherWords, function(a, b) {
	     *   var reGreet = /^(?:hello|hi)$/i,
	     *       aGreet = _.isString(a) && reGreet.test(a),
	     *       bGreet = _.isString(b) && reGreet.test(b);
	     *
	     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
	     * });
	     * // => true
	     */
	    function isEqual(a, b, callback, thisArg) {
	      return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
	    }
	
	    /**
	     * Checks if `value` is, or can be coerced to, a finite number.
	     *
	     * Note: This is not the same as native `isFinite` which will return true for
	     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
	     * @example
	     *
	     * _.isFinite(-101);
	     * // => true
	     *
	     * _.isFinite('10');
	     * // => true
	     *
	     * _.isFinite(true);
	     * // => false
	     *
	     * _.isFinite('');
	     * // => false
	     *
	     * _.isFinite(Infinity);
	     * // => false
	     */
	    function isFinite(value) {
	      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
	    }
	
	    /**
	     * Checks if `value` is a function.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
	     * @example
	     *
	     * _.isFunction(_);
	     * // => true
	     */
	    function isFunction(value) {
	      return typeof value == 'function';
	    }
	    // fallback for older versions of Chrome and Safari
	    if (isFunction(/x/)) {
	      isFunction = function(value) {
	        return typeof value == 'function' && toString.call(value) == funcClass;
	      };
	    }
	
	    /**
	     * Checks if `value` is the language type of Object.
	     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
	     * @example
	     *
	     * _.isObject({});
	     * // => true
	     *
	     * _.isObject([1, 2, 3]);
	     * // => true
	     *
	     * _.isObject(1);
	     * // => false
	     */
	    function isObject(value) {
	      // check if the value is the ECMAScript language type of Object
	      // http://es5.github.io/#x8
	      // and avoid a V8 bug
	      // http://code.google.com/p/v8/issues/detail?id=2291
	      return !!(value && objectTypes[typeof value]);
	    }
	
	    /**
	     * Checks if `value` is `NaN`.
	     *
	     * Note: This is not the same as native `isNaN` which will return `true` for
	     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
	     * @example
	     *
	     * _.isNaN(NaN);
	     * // => true
	     *
	     * _.isNaN(new Number(NaN));
	     * // => true
	     *
	     * isNaN(undefined);
	     * // => true
	     *
	     * _.isNaN(undefined);
	     * // => false
	     */
	    function isNaN(value) {
	      // `NaN` as a primitive is the only value that is not equal to itself
	      // (perform the [[Class]] check first to avoid errors with some host objects in IE)
	      return isNumber(value) && value != +value;
	    }
	
	    /**
	     * Checks if `value` is `null`.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
	     * @example
	     *
	     * _.isNull(null);
	     * // => true
	     *
	     * _.isNull(undefined);
	     * // => false
	     */
	    function isNull(value) {
	      return value === null;
	    }
	
	    /**
	     * Checks if `value` is a number.
	     *
	     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
	     * @example
	     *
	     * _.isNumber(8.4 * 5);
	     * // => true
	     */
	    function isNumber(value) {
	      return typeof value == 'number' ||
	        value && typeof value == 'object' && toString.call(value) == numberClass || false;
	    }
	
	    /**
	     * Checks if `value` is an object created by the `Object` constructor.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	     * @example
	     *
	     * function Shape() {
	     *   this.x = 0;
	     *   this.y = 0;
	     * }
	     *
	     * _.isPlainObject(new Shape);
	     * // => false
	     *
	     * _.isPlainObject([1, 2, 3]);
	     * // => false
	     *
	     * _.isPlainObject({ 'x': 0, 'y': 0 });
	     * // => true
	     */
	    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
	      if (!(value && toString.call(value) == objectClass) || (!support.argsClass && isArguments(value))) {
	        return false;
	      }
	      var valueOf = value.valueOf,
	          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
	
	      return objProto
	        ? (value == objProto || getPrototypeOf(value) == objProto)
	        : shimIsPlainObject(value);
	    };
	
	    /**
	     * Checks if `value` is a regular expression.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
	     * @example
	     *
	     * _.isRegExp(/fred/);
	     * // => true
	     */
	    function isRegExp(value) {
	      return value && objectTypes[typeof value] && toString.call(value) == regexpClass || false;
	    }
	
	    /**
	     * Checks if `value` is a string.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
	     * @example
	     *
	     * _.isString('fred');
	     * // => true
	     */
	    function isString(value) {
	      return typeof value == 'string' ||
	        value && typeof value == 'object' && toString.call(value) == stringClass || false;
	    }
	
	    /**
	     * Checks if `value` is `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
	     * @example
	     *
	     * _.isUndefined(void 0);
	     * // => true
	     */
	    function isUndefined(value) {
	      return typeof value == 'undefined';
	    }
	
	    /**
	     * Creates an object with the same keys as `object` and values generated by
	     * running each own enumerable property of `object` through the callback.
	     * The callback is bound to `thisArg` and invoked with three arguments;
	     * (value, key, object).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The object to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array} Returns a new object with values of the results of each `callback` execution.
	     * @example
	     *
	     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });
	     * // => { 'a': 3, 'b': 6, 'c': 9 }
	     *
	     * var characters = {
	     *   'fred': { 'name': 'fred', 'age': 40 },
	     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
	     * };
	     *
	     * // using "_.pluck" callback shorthand
	     * _.mapValues(characters, 'age');
	     * // => { 'fred': 40, 'pebbles': 1 }
	     */
	    function mapValues(object, callback, thisArg) {
	      var result = {};
	      callback = lodash.createCallback(callback, thisArg, 3);
	
	      forOwn(object, function(value, key, object) {
	        result[key] = callback(value, key, object);
	      });
	      return result;
	    }
	
	    /**
	     * Recursively merges own enumerable properties of the source object(s), that
	     * don't resolve to `undefined` into the destination object. Subsequent sources
	     * will overwrite property assignments of previous sources. If a callback is
	     * provided it will be executed to produce the merged values of the destination
	     * and source properties. If the callback returns `undefined` merging will
	     * be handled by the method instead. The callback is bound to `thisArg` and
	     * invoked with two arguments; (objectValue, sourceValue).
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The destination object.
	     * @param {...Object} [source] The source objects.
	     * @param {Function} [callback] The function to customize merging properties.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Object} Returns the destination object.
	     * @example
	     *
	     * var names = {
	     *   'characters': [
	     *     { 'name': 'barney' },
	     *     { 'name': 'fred' }
	     *   ]
	     * };
	     *
	     * var ages = {
	     *   'characters': [
	     *     { 'age': 36 },
	     *     { 'age': 40 }
	     *   ]
	     * };
	     *
	     * _.merge(names, ages);
	     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
	     *
	     * var food = {
	     *   'fruits': ['apple'],
	     *   'vegetables': ['beet']
	     * };
	     *
	     * var otherFood = {
	     *   'fruits': ['banana'],
	     *   'vegetables': ['carrot']
	     * };
	     *
	     * _.merge(food, otherFood, function(a, b) {
	     *   return _.isArray(a) ? a.concat(b) : undefined;
	     * });
	     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
	     */
	    function merge(object) {
	      var args = arguments,
	          length = 2;
	
	      if (!isObject(object)) {
	        return object;
	      }
	      // allows working with `_.reduce` and `_.reduceRight` without using
	      // their `index` and `collection` arguments
	      if (typeof args[2] != 'number') {
	        length = args.length;
	      }
	      if (length > 3 && typeof args[length - 2] == 'function') {
	        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
	      } else if (length > 2 && typeof args[length - 1] == 'function') {
	        callback = args[--length];
	      }
	      var sources = slice(arguments, 1, length),
	          index = -1,
	          stackA = getArray(),
	          stackB = getArray();
	
	      while (++index < length) {
	        baseMerge(object, sources[index], callback, stackA, stackB);
	      }
	      releaseArray(stackA);
	      releaseArray(stackB);
	      return object;
	    }
	
	    /**
	     * Creates a shallow clone of `object` excluding the specified properties.
	     * Property names may be specified as individual arguments or as arrays of
	     * property names. If a callback is provided it will be executed for each
	     * property of `object` omitting the properties the callback returns truey
	     * for. The callback is bound to `thisArg` and invoked with three arguments;
	     * (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The source object.
	     * @param {Function|...string|string[]} [callback] The properties to omit or the
	     *  function called per iteration.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Object} Returns an object without the omitted properties.
	     * @example
	     *
	     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
	     * // => { 'name': 'fred' }
	     *
	     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
	     *   return typeof value == 'number';
	     * });
	     * // => { 'name': 'fred' }
	     */
	    function omit(object, callback, thisArg) {
	      var result = {};
	      if (typeof callback != 'function') {
	        var props = [];
	        forIn(object, function(value, key) {
	          props.push(key);
	        });
	        props = baseDifference(props, baseFlatten(arguments, true, false, 1));
	
	        var index = -1,
	            length = props.length;
	
	        while (++index < length) {
	          var key = props[index];
	          result[key] = object[key];
	        }
	      } else {
	        callback = lodash.createCallback(callback, thisArg, 3);
	        forIn(object, function(value, key, object) {
	          if (!callback(value, key, object)) {
	            result[key] = value;
	          }
	        });
	      }
	      return result;
	    }
	
	    /**
	     * Creates a two dimensional array of an object's key-value pairs,
	     * i.e. `[[key1, value1], [key2, value2]]`.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns new array of key-value pairs.
	     * @example
	     *
	     * _.pairs({ 'barney': 36, 'fred': 40 });
	     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
	     */
	    function pairs(object) {
	      var index = -1,
	          props = keys(object),
	          length = props.length,
	          result = Array(length);
	
	      while (++index < length) {
	        var key = props[index];
	        result[index] = [key, object[key]];
	      }
	      return result;
	    }
	
	    /**
	     * Creates a shallow clone of `object` composed of the specified properties.
	     * Property names may be specified as individual arguments or as arrays of
	     * property names. If a callback is provided it will be executed for each
	     * property of `object` picking the properties the callback returns truey
	     * for. The callback is bound to `thisArg` and invoked with three arguments;
	     * (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The source object.
	     * @param {Function|...string|string[]} [callback] The function called per
	     *  iteration or property names to pick, specified as individual property
	     *  names or arrays of property names.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Object} Returns an object composed of the picked properties.
	     * @example
	     *
	     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
	     * // => { 'name': 'fred' }
	     *
	     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
	     *   return key.charAt(0) != '_';
	     * });
	     * // => { 'name': 'fred' }
	     */
	    function pick(object, callback, thisArg) {
	      var result = {};
	      if (typeof callback != 'function') {
	        var index = -1,
	            props = baseFlatten(arguments, true, false, 1),
	            length = isObject(object) ? props.length : 0;
	
	        while (++index < length) {
	          var key = props[index];
	          if (key in object) {
	            result[key] = object[key];
	          }
	        }
	      } else {
	        callback = lodash.createCallback(callback, thisArg, 3);
	        forIn(object, function(value, key, object) {
	          if (callback(value, key, object)) {
	            result[key] = value;
	          }
	        });
	      }
	      return result;
	    }
	
	    /**
	     * An alternative to `_.reduce` this method transforms `object` to a new
	     * `accumulator` object which is the result of running each of its own
	     * enumerable properties through a callback, with each callback execution
	     * potentially mutating the `accumulator` object. The callback is bound to
	     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).
	     * Callbacks may exit iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Array|Object} object The object to iterate over.
	     * @param {Function} [callback=identity] The function called per iteration.
	     * @param {*} [accumulator] The custom accumulator value.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
	     *   num *= num;
	     *   if (num % 2) {
	     *     return result.push(num) < 3;
	     *   }
	     * });
	     * // => [1, 9, 25]
	     *
	     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
	     *   result[key] = num * 3;
	     * });
	     * // => { 'a': 3, 'b': 6, 'c': 9 }
	     */
	    function transform(object, callback, accumulator, thisArg) {
	      var isArr = isArray(object);
	      if (accumulator == null) {
	        if (isArr) {
	          accumulator = [];
	        } else {
	          var ctor = object && object.constructor,
	              proto = ctor && ctor.prototype;
	
	          accumulator = baseCreate(proto);
	        }
	      }
	      if (callback) {
	        callback = lodash.createCallback(callback, thisArg, 4);
	        (isArr ? baseEach : forOwn)(object, function(value, index, object) {
	          return callback(accumulator, value, index, object);
	        });
	      }
	      return accumulator;
	    }
	
	    /**
	     * Creates an array composed of the own enumerable property values of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @category Objects
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns an array of property values.
	     * @example
	     *
	     * _.values({ 'one': 1, 'two': 2, 'three': 3 });
	     * // => [1, 2, 3] (property order is not guaranteed across environments)
	     */
	    function values(object) {
	      var index = -1,
	          props = keys(object),
	          length = props.length,
	          result = Array(length);
	
	      while (++index < length) {
	        result[index] = object[props[index]];
	      }
	      return result;
	    }
	
	    /*--------------------------------------------------------------------------*/
	
	    /**
	     * Creates an array of elements from the specified indexes, or keys, of the
	     * `collection`. Indexes may be specified as individual arguments or as arrays
	     * of indexes.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
	     *   to retrieve, specified as individual indexes or arrays of indexes.
	     * @returns {Array} Returns a new array of elements corresponding to the
	     *  provided indexes.
	     * @example
	     *
	     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
	     * // => ['a', 'c', 'e']
	     *
	     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
	     * // => ['fred', 'pebbles']
	     */
	    function at(collection) {
	      var args = arguments,
	          index = -1,
	          props = baseFlatten(args, true, false, 1),
	          length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,
	          result = Array(length);
	
	      if (support.unindexedChars && isString(collection)) {
	        collection = collection.split('');
	      }
	      while(++index < length) {
	        result[index] = collection[props[index]];
	      }
	      return result;
	    }
	
	    /**
	     * Checks if a given value is present in a collection using strict equality
	     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
	     * offset from the end of the collection.
	     *
	     * @static
	     * @memberOf _
	     * @alias include
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {*} target The value to check for.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
	     * @example
	     *
	     * _.contains([1, 2, 3], 1);
	     * // => true
	     *
	     * _.contains([1, 2, 3], 1, 2);
	     * // => false
	     *
	     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
	     * // => true
	     *
	     * _.contains('pebbles', 'eb');
	     * // => true
	     */
	    function contains(collection, target, fromIndex) {
	      var index = -1,
	          indexOf = getIndexOf(),
	          length = collection ? collection.length : 0,
	          result = false;
	
	      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
	      if (isArray(collection)) {
	        result = indexOf(collection, target, fromIndex) > -1;
	      } else if (typeof length == 'number') {
	        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
	      } else {
	        baseEach(collection, function(value) {
	          if (++index >= fromIndex) {
	            return !(result = value === target);
	          }
	        });
	      }
	      return result;
	    }
	
	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` through the callback. The corresponding value
	     * of each key is the number of times the key was returned by the callback.
	     * The callback is bound to `thisArg` and invoked with three arguments;
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
	     * // => { '4': 1, '6': 2 }
	     *
	     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
	     * // => { '4': 1, '6': 2 }
	     *
	     * _.countBy(['one', 'two', 'three'], 'length');
	     * // => { '3': 2, '5': 1 }
	     */
	    var countBy = createAggregator(function(result, value, key) {
	      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
	    });
	
	    /**
	     * Checks if the given callback returns truey value for **all** elements of
	     * a collection. The callback is bound to `thisArg` and invoked with three
	     * arguments; (value, index|key, collection).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias all
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {boolean} Returns `true` if all elements passed the callback check,
	     *  else `false`.
	     * @example
	     *
	     * _.every([true, 1, null, 'yes']);
	     * // => false
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36 },
	     *   { 'name': 'fred',   'age': 40 }
	     * ];
	     *
	     * // using "_.pluck" callback shorthand
	     * _.every(characters, 'age');
	     * // => true
	     *
	     * // using "_.where" callback shorthand
	     * _.every(characters, { 'age': 36 });
	     * // => false
	     */
	    function every(collection, callback, thisArg) {
	      var result = true;
	      callback = lodash.createCallback(callback, thisArg, 3);
	
	      if (isArray(collection)) {
	        var index = -1,
	            length = collection.length;
	
	        while (++index < length) {
	          if (!(result = !!callback(collection[index], index, collection))) {
	            break;
	          }
	        }
	      } else {
	        baseEach(collection, function(value, index, collection) {
	          return (result = !!callback(value, index, collection));
	        });
	      }
	      return result;
	    }
	
	    /**
	     * Iterates over elements of a collection, returning an array of all elements
	     * the callback returns truey for. The callback is bound to `thisArg` and
	     * invoked with three arguments; (value, index|key, collection).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias select
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array} Returns a new array of elements that passed the callback check.
	     * @example
	     *
	     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
	     * // => [2, 4, 6]
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36, 'blocked': false },
	     *   { 'name': 'fred',   'age': 40, 'blocked': true }
	     * ];
	     *
	     * // using "_.pluck" callback shorthand
	     * _.filter(characters, 'blocked');
	     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
	     *
	     * // using "_.where" callback shorthand
	     * _.filter(characters, { 'age': 36 });
	     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
	     */
	    function filter(collection, callback, thisArg) {
	      var result = [];
	      callback = lodash.createCallback(callback, thisArg, 3);
	
	      if (isArray(collection)) {
	        var index = -1,
	            length = collection.length;
	
	        while (++index < length) {
	          var value = collection[index];
	          if (callback(value, index, collection)) {
	            result.push(value);
	          }
	        }
	      } else {
	        baseEach(collection, function(value, index, collection) {
	          if (callback(value, index, collection)) {
	            result.push(value);
	          }
	        });
	      }
	      return result;
	    }
	
	    /**
	     * Iterates over elements of a collection, returning the first element that
	     * the callback returns truey for. The callback is bound to `thisArg` and
	     * invoked with three arguments; (value, index|key, collection).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias detect, findWhere
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {*} Returns the found element, else `undefined`.
	     * @example
	     *
	     * var characters = [
	     *   { 'name': 'barney',  'age': 36, 'blocked': false },
	     *   { 'name': 'fred',    'age': 40, 'blocked': true },
	     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
	     * ];
	     *
	     * _.find(characters, function(chr) {
	     *   return chr.age < 40;
	     * });
	     * // => { 'name': 'barney', 'age': 36, 'blocked': false }
	     *
	     * // using "_.where" callback shorthand
	     * _.find(characters, { 'age': 1 });
	     * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
	     *
	     * // using "_.pluck" callback shorthand
	     * _.find(characters, 'blocked');
	     * // => { 'name': 'fred', 'age': 40, 'blocked': true }
	     */
	    function find(collection, callback, thisArg) {
	      callback = lodash.createCallback(callback, thisArg, 3);
	
	      if (isArray(collection)) {
	        var index = -1,
	            length = collection.length;
	
	        while (++index < length) {
	          var value = collection[index];
	          if (callback(value, index, collection)) {
	            return value;
	          }
	        }
	      } else {
	        var result;
	        baseEach(collection, function(value, index, collection) {
	          if (callback(value, index, collection)) {
	            result = value;
	            return false;
	          }
	        });
	        return result;
	      }
	    }
	
	    /**
	     * This method is like `_.find` except that it iterates over elements
	     * of a `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {*} Returns the found element, else `undefined`.
	     * @example
	     *
	     * _.findLast([1, 2, 3, 4], function(num) {
	     *   return num % 2 == 1;
	     * });
	     * // => 3
	     */
	    function findLast(collection, callback, thisArg) {
	      var result;
	      callback = lodash.createCallback(callback, thisArg, 3);
	      forEachRight(collection, function(value, index, collection) {
	        if (callback(value, index, collection)) {
	          result = value;
	          return false;
	        }
	      });
	      return result;
	    }
	
	    /**
	     * Iterates over elements of a collection, executing the callback for each
	     * element. The callback is bound to `thisArg` and invoked with three arguments;
	     * (value, index|key, collection). Callbacks may exit iteration early by
	     * explicitly returning `false`.
	     *
	     * Note: As with other "Collections" methods, objects with a `length` property
	     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
	     * may be used for object iteration.
	     *
	     * @static
	     * @memberOf _
	     * @alias each
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [callback=identity] The function called per iteration.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array|Object|string} Returns `collection`.
	     * @example
	     *
	     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
	     * // => logs each number and returns '1,2,3'
	     *
	     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
	     * // => logs each number and returns the object (property order is not guaranteed across environments)
	     */
	    function forEach(collection, callback, thisArg) {
	      if (callback && typeof thisArg == 'undefined' && isArray(collection)) {
	        var index = -1,
	            length = collection.length;
	
	        while (++index < length) {
	          if (callback(collection[index], index, collection) === false) {
	            break;
	          }
	        }
	      } else {
	        baseEach(collection, callback, thisArg);
	      }
	      return collection;
	    }
	
	    /**
	     * This method is like `_.forEach` except that it iterates over elements
	     * of a `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @alias eachRight
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [callback=identity] The function called per iteration.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array|Object|string} Returns `collection`.
	     * @example
	     *
	     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
	     * // => logs each number from right to left and returns '3,2,1'
	     */
	    function forEachRight(collection, callback, thisArg) {
	      var iterable = collection,
	          length = collection ? collection.length : 0;
	
	      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
	      if (isArray(collection)) {
	        while (length--) {
	          if (callback(collection[length], length, collection) === false) {
	            break;
	          }
	        }
	      } else {
	        if (typeof length != 'number') {
	          var props = keys(collection);
	          length = props.length;
	        } else if (support.unindexedChars && isString(collection)) {
	          iterable = collection.split('');
	        }
	        baseEach(collection, function(value, key, collection) {
	          key = props ? props[--length] : --length;
	          return callback(iterable[key], key, collection);
	        });
	      }
	      return collection;
	    }
	
	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of a collection through the callback. The corresponding value
	     * of each key is an array of the elements responsible for generating the key.
	     * The callback is bound to `thisArg` and invoked with three arguments;
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
	     * // => { '4': [4.2], '6': [6.1, 6.4] }
	     *
	     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
	     * // => { '4': [4.2], '6': [6.1, 6.4] }
	     *
	     * // using "_.pluck" callback shorthand
	     * _.groupBy(['one', 'two', 'three'], 'length');
	     * // => { '3': ['one', 'two'], '5': ['three'] }
	     */
	    var groupBy = createAggregator(function(result, value, key) {
	      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
	    });
	
	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of the collection through the given callback. The corresponding
	     * value of each key is the last element responsible for generating the key.
	     * The callback is bound to `thisArg` and invoked with three arguments;
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * var keys = [
	     *   { 'dir': 'left', 'code': 97 },
	     *   { 'dir': 'right', 'code': 100 }
	     * ];
	     *
	     * _.indexBy(keys, 'dir');
	     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
	     *
	     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
	     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
	     *
	     * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
	     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
	     */
	    var indexBy = createAggregator(function(result, value, key) {
	      result[key] = value;
	    });
	
	    /**
	     * Invokes the method named by `methodName` on each element in the `collection`
	     * returning an array of the results of each invoked method. Additional arguments
	     * will be provided to each invoked method. If `methodName` is a function it
	     * will be invoked for, and `this` bound to, each element in the `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|string} methodName The name of the method to invoke or
	     *  the function invoked per iteration.
	     * @param {...*} [arg] Arguments to invoke the method with.
	     * @returns {Array} Returns a new array of the results of each invoked method.
	     * @example
	     *
	     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
	     * // => [[1, 5, 7], [1, 2, 3]]
	     *
	     * _.invoke([123, 456], String.prototype.split, '');
	     * // => [['1', '2', '3'], ['4', '5', '6']]
	     */
	    function invoke(collection, methodName) {
	      var args = slice(arguments, 2),
	          index = -1,
	          isFunc = typeof methodName == 'function',
	          length = collection ? collection.length : 0,
	          result = Array(typeof length == 'number' ? length : 0);
	
	      forEach(collection, function(value) {
	        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
	      });
	      return result;
	    }
	
	    /**
	     * Creates an array of values by running each element in the collection
	     * through the callback. The callback is bound to `thisArg` and invoked with
	     * three arguments; (value, index|key, collection).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias collect
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array} Returns a new array of the results of each `callback` execution.
	     * @example
	     *
	     * _.map([1, 2, 3], function(num) { return num * 3; });
	     * // => [3, 6, 9]
	     *
	     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
	     * // => [3, 6, 9] (property order is not guaranteed across environments)
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36 },
	     *   { 'name': 'fred',   'age': 40 }
	     * ];
	     *
	     * // using "_.pluck" callback shorthand
	     * _.map(characters, 'name');
	     * // => ['barney', 'fred']
	     */
	    function map(collection, callback, thisArg) {
	      var index = -1,
	          length = collection ? collection.length : 0,
	          result = Array(typeof length == 'number' ? length : 0);
	
	      callback = lodash.createCallback(callback, thisArg, 3);
	      if (isArray(collection)) {
	        while (++index < length) {
	          result[index] = callback(collection[index], index, collection);
	        }
	      } else {
	        baseEach(collection, function(value, key, collection) {
	          result[++index] = callback(value, key, collection);
	        });
	      }
	      return result;
	    }
	
	    /**
	     * Retrieves the maximum value of a collection. If the collection is empty or
	     * falsey `-Infinity` is returned. If a callback is provided it will be executed
	     * for each value in the collection to generate the criterion by which the value
	     * is ranked. The callback is bound to `thisArg` and invoked with three
	     * arguments; (value, index, collection).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {*} Returns the maximum value.
	     * @example
	     *
	     * _.max([4, 2, 8, 6]);
	     * // => 8
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36 },
	     *   { 'name': 'fred',   'age': 40 }
	     * ];
	     *
	     * _.max(characters, function(chr) { return chr.age; });
	     * // => { 'name': 'fred', 'age': 40 };
	     *
	     * // using "_.pluck" callback shorthand
	     * _.max(characters, 'age');
	     * // => { 'name': 'fred', 'age': 40 };
	     */
	    function max(collection, callback, thisArg) {
	      var computed = -Infinity,
	          result = computed;
	
	      // allows working with functions like `_.map` without using
	      // their `index` argument as a callback
	      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
	        callback = null;
	      }
	      if (callback == null && isArray(collection)) {
	        var index = -1,
	            length = collection.length;
	
	        while (++index < length) {
	          var value = collection[index];
	          if (value > result) {
	            result = value;
	          }
	        }
	      } else {
	        callback = (callback == null && isString(collection))
	          ? charAtCallback
	          : lodash.createCallback(callback, thisArg, 3);
	
	        baseEach(collection, function(value, index, collection) {
	          var current = callback(value, index, collection);
	          if (current > computed) {
	            computed = current;
	            result = value;
	          }
	        });
	      }
	      return result;
	    }
	
	    /**
	     * Retrieves the minimum value of a collection. If the collection is empty or
	     * falsey `Infinity` is returned. If a callback is provided it will be executed
	     * for each value in the collection to generate the criterion by which the value
	     * is ranked. The callback is bound to `thisArg` and invoked with three
	     * arguments; (value, index, collection).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {*} Returns the minimum value.
	     * @example
	     *
	     * _.min([4, 2, 8, 6]);
	     * // => 2
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36 },
	     *   { 'name': 'fred',   'age': 40 }
	     * ];
	     *
	     * _.min(characters, function(chr) { return chr.age; });
	     * // => { 'name': 'barney', 'age': 36 };
	     *
	     * // using "_.pluck" callback shorthand
	     * _.min(characters, 'age');
	     * // => { 'name': 'barney', 'age': 36 };
	     */
	    function min(collection, callback, thisArg) {
	      var computed = Infinity,
	          result = computed;
	
	      // allows working with functions like `_.map` without using
	      // their `index` argument as a callback
	      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
	        callback = null;
	      }
	      if (callback == null && isArray(collection)) {
	        var index = -1,
	            length = collection.length;
	
	        while (++index < length) {
	          var value = collection[index];
	          if (value < result) {
	            result = value;
	          }
	        }
	      } else {
	        callback = (callback == null && isString(collection))
	          ? charAtCallback
	          : lodash.createCallback(callback, thisArg, 3);
	
	        baseEach(collection, function(value, index, collection) {
	          var current = callback(value, index, collection);
	          if (current < computed) {
	            computed = current;
	            result = value;
	          }
	        });
	      }
	      return result;
	    }
	
	    /**
	     * Retrieves the value of a specified property from all elements in the collection.
	     *
	     * @static
	     * @memberOf _
	     * @type Function
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {string} property The name of the property to pluck.
	     * @returns {Array} Returns a new array of property values.
	     * @example
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36 },
	     *   { 'name': 'fred',   'age': 40 }
	     * ];
	     *
	     * _.pluck(characters, 'name');
	     * // => ['barney', 'fred']
	     */
	    var pluck = map;
	
	    /**
	     * Reduces a collection to a value which is the accumulated result of running
	     * each element in the collection through the callback, where each successive
	     * callback execution consumes the return value of the previous execution. If
	     * `accumulator` is not provided the first element of the collection will be
	     * used as the initial `accumulator` value. The callback is bound to `thisArg`
	     * and invoked with four arguments; (accumulator, value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @alias foldl, inject
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [callback=identity] The function called per iteration.
	     * @param {*} [accumulator] Initial value of the accumulator.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * var sum = _.reduce([1, 2, 3], function(sum, num) {
	     *   return sum + num;
	     * });
	     * // => 6
	     *
	     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
	     *   result[key] = num * 3;
	     *   return result;
	     * }, {});
	     * // => { 'a': 3, 'b': 6, 'c': 9 }
	     */
	    function reduce(collection, callback, accumulator, thisArg) {
	      var noaccum = arguments.length < 3;
	      callback = lodash.createCallback(callback, thisArg, 4);
	
	      if (isArray(collection)) {
	        var index = -1,
	            length = collection.length;
	
	        if (noaccum) {
	          accumulator = collection[++index];
	        }
	        while (++index < length) {
	          accumulator = callback(accumulator, collection[index], index, collection);
	        }
	      } else {
	        baseEach(collection, function(value, index, collection) {
	          accumulator = noaccum
	            ? (noaccum = false, value)
	            : callback(accumulator, value, index, collection)
	        });
	      }
	      return accumulator;
	    }
	
	    /**
	     * This method is like `_.reduce` except that it iterates over elements
	     * of a `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @alias foldr
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [callback=identity] The function called per iteration.
	     * @param {*} [accumulator] Initial value of the accumulator.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * var list = [[0, 1], [2, 3], [4, 5]];
	     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
	     * // => [4, 5, 2, 3, 0, 1]
	     */
	    function reduceRight(collection, callback, accumulator, thisArg) {
	      var noaccum = arguments.length < 3;
	      callback = lodash.createCallback(callback, thisArg, 4);
	      forEachRight(collection, function(value, index, collection) {
	        accumulator = noaccum
	          ? (noaccum = false, value)
	          : callback(accumulator, value, index, collection);
	      });
	      return accumulator;
	    }
	
	    /**
	     * The opposite of `_.filter` this method returns the elements of a
	     * collection that the callback does **not** return truey for.
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array} Returns a new array of elements that failed the callback check.
	     * @example
	     *
	     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
	     * // => [1, 3, 5]
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36, 'blocked': false },
	     *   { 'name': 'fred',   'age': 40, 'blocked': true }
	     * ];
	     *
	     * // using "_.pluck" callback shorthand
	     * _.reject(characters, 'blocked');
	     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
	     *
	     * // using "_.where" callback shorthand
	     * _.reject(characters, { 'age': 36 });
	     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
	     */
	    function reject(collection, callback, thisArg) {
	      callback = lodash.createCallback(callback, thisArg, 3);
	      return filter(collection, function(value, index, collection) {
	        return !callback(value, index, collection);
	      });
	    }
	
	    /**
	     * Retrieves a random element or `n` random elements from a collection.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to sample.
	     * @param {number} [n] The number of elements to sample.
	     * @param- {Object} [guard] Allows working with functions like `_.map`
	     *  without using their `index` arguments as `n`.
	     * @returns {Array} Returns the random sample(s) of `collection`.
	     * @example
	     *
	     * _.sample([1, 2, 3, 4]);
	     * // => 2
	     *
	     * _.sample([1, 2, 3, 4], 2);
	     * // => [3, 1]
	     */
	    function sample(collection, n, guard) {
	      if (collection && typeof collection.length != 'number') {
	        collection = values(collection);
	      } else if (support.unindexedChars && isString(collection)) {
	        collection = collection.split('');
	      }
	      if (n == null || guard) {
	        return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
	      }
	      var result = shuffle(collection);
	      result.length = nativeMin(nativeMax(0, n), result.length);
	      return result;
	    }
	
	    /**
	     * Creates an array of shuffled values, using a version of the Fisher-Yates
	     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to shuffle.
	     * @returns {Array} Returns a new shuffled collection.
	     * @example
	     *
	     * _.shuffle([1, 2, 3, 4, 5, 6]);
	     * // => [4, 1, 6, 3, 5, 2]
	     */
	    function shuffle(collection) {
	      var index = -1,
	          length = collection ? collection.length : 0,
	          result = Array(typeof length == 'number' ? length : 0);
	
	      forEach(collection, function(value) {
	        var rand = baseRandom(0, ++index);
	        result[index] = result[rand];
	        result[rand] = value;
	      });
	      return result;
	    }
	
	    /**
	     * Gets the size of the `collection` by returning `collection.length` for arrays
	     * and array-like objects or the number of own enumerable properties for objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to inspect.
	     * @returns {number} Returns `collection.length` or number of own enumerable properties.
	     * @example
	     *
	     * _.size([1, 2]);
	     * // => 2
	     *
	     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
	     * // => 3
	     *
	     * _.size('pebbles');
	     * // => 7
	     */
	    function size(collection) {
	      var length = collection ? collection.length : 0;
	      return typeof length == 'number' ? length : keys(collection).length;
	    }
	
	    /**
	     * Checks if the callback returns a truey value for **any** element of a
	     * collection. The function returns as soon as it finds a passing value and
	     * does not iterate over the entire collection. The callback is bound to
	     * `thisArg` and invoked with three arguments; (value, index|key, collection).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias any
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {boolean} Returns `true` if any element passed the callback check,
	     *  else `false`.
	     * @example
	     *
	     * _.some([null, 0, 'yes', false], Boolean);
	     * // => true
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36, 'blocked': false },
	     *   { 'name': 'fred',   'age': 40, 'blocked': true }
	     * ];
	     *
	     * // using "_.pluck" callback shorthand
	     * _.some(characters, 'blocked');
	     * // => true
	     *
	     * // using "_.where" callback shorthand
	     * _.some(characters, { 'age': 1 });
	     * // => false
	     */
	    function some(collection, callback, thisArg) {
	      var result;
	      callback = lodash.createCallback(callback, thisArg, 3);
	
	      if (isArray(collection)) {
	        var index = -1,
	            length = collection.length;
	
	        while (++index < length) {
	          if ((result = callback(collection[index], index, collection))) {
	            break;
	          }
	        }
	      } else {
	        baseEach(collection, function(value, index, collection) {
	          return !(result = callback(value, index, collection));
	        });
	      }
	      return !!result;
	    }
	
	    /**
	     * Creates an array of elements, sorted in ascending order by the results of
	     * running each element in a collection through the callback. This method
	     * performs a stable sort, that is, it will preserve the original sort order
	     * of equal elements. The callback is bound to `thisArg` and invoked with
	     * three arguments; (value, index|key, collection).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an array of property names is provided for `callback` the collection
	     * will be sorted by each property value.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Array|Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array} Returns a new array of sorted elements.
	     * @example
	     *
	     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
	     * // => [3, 1, 2]
	     *
	     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
	     * // => [3, 1, 2]
	     *
	     * var characters = [
	     *   { 'name': 'barney',  'age': 36 },
	     *   { 'name': 'fred',    'age': 40 },
	     *   { 'name': 'barney',  'age': 26 },
	     *   { 'name': 'fred',    'age': 30 }
	     * ];
	     *
	     * // using "_.pluck" callback shorthand
	     * _.map(_.sortBy(characters, 'age'), _.values);
	     * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
	     *
	     * // sorting by multiple properties
	     * _.map(_.sortBy(characters, ['name', 'age']), _.values);
	     * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
	     */
	    function sortBy(collection, callback, thisArg) {
	      var index = -1,
	          isArr = isArray(callback),
	          length = collection ? collection.length : 0,
	          result = Array(typeof length == 'number' ? length : 0);
	
	      if (!isArr) {
	        callback = lodash.createCallback(callback, thisArg, 3);
	      }
	      forEach(collection, function(value, key, collection) {
	        var object = result[++index] = getObject();
	        if (isArr) {
	          object.criteria = map(callback, function(key) { return value[key]; });
	        } else {
	          (object.criteria = getArray())[0] = callback(value, key, collection);
	        }
	        object.index = index;
	        object.value = value;
	      });
	
	      length = result.length;
	      result.sort(compareAscending);
	      while (length--) {
	        var object = result[length];
	        result[length] = object.value;
	        if (!isArr) {
	          releaseArray(object.criteria);
	        }
	        releaseObject(object);
	      }
	      return result;
	    }
	
	    /**
	     * Converts the `collection` to an array.
	     *
	     * @static
	     * @memberOf _
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to convert.
	     * @returns {Array} Returns the new converted array.
	     * @example
	     *
	     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
	     * // => [2, 3, 4]
	     */
	    function toArray(collection) {
	      if (collection && typeof collection.length == 'number') {
	        return (support.unindexedChars && isString(collection))
	          ? collection.split('')
	          : slice(collection);
	      }
	      return values(collection);
	    }
	
	    /**
	     * Performs a deep comparison of each element in a `collection` to the given
	     * `properties` object, returning an array of all elements that have equivalent
	     * property values.
	     *
	     * @static
	     * @memberOf _
	     * @type Function
	     * @category Collections
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Object} props The object of property values to filter by.
	     * @returns {Array} Returns a new array of elements that have the given properties.
	     * @example
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
	     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
	     * ];
	     *
	     * _.where(characters, { 'age': 36 });
	     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
	     *
	     * _.where(characters, { 'pets': ['dino'] });
	     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
	     */
	    var where = filter;
	
	    /*--------------------------------------------------------------------------*/
	
	    /**
	     * Creates an array with all falsey values removed. The values `false`, `null`,
	     * `0`, `""`, `undefined`, and `NaN` are all falsey.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to compact.
	     * @returns {Array} Returns a new array of filtered values.
	     * @example
	     *
	     * _.compact([0, 1, false, 2, '', 3]);
	     * // => [1, 2, 3]
	     */
	    function compact(array) {
	      var index = -1,
	          length = array ? array.length : 0,
	          result = [];
	
	      while (++index < length) {
	        var value = array[index];
	        if (value) {
	          result.push(value);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * Creates an array excluding all values of the provided arrays using strict
	     * equality for comparisons, i.e. `===`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to process.
	     * @param {...Array} [values] The arrays of values to exclude.
	     * @returns {Array} Returns a new array of filtered values.
	     * @example
	     *
	     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
	     * // => [1, 3, 4]
	     */
	    function difference(array) {
	      return baseDifference(array, baseFlatten(arguments, true, true, 1));
	    }
	
	    /**
	     * This method is like `_.find` except that it returns the index of the first
	     * element that passes the callback check, instead of the element itself.
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to search.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var characters = [
	     *   { 'name': 'barney',  'age': 36, 'blocked': false },
	     *   { 'name': 'fred',    'age': 40, 'blocked': true },
	     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
	     * ];
	     *
	     * _.findIndex(characters, function(chr) {
	     *   return chr.age < 20;
	     * });
	     * // => 2
	     *
	     * // using "_.where" callback shorthand
	     * _.findIndex(characters, { 'age': 36 });
	     * // => 0
	     *
	     * // using "_.pluck" callback shorthand
	     * _.findIndex(characters, 'blocked');
	     * // => 1
	     */
	    function findIndex(array, callback, thisArg) {
	      var index = -1,
	          length = array ? array.length : 0;
	
	      callback = lodash.createCallback(callback, thisArg, 3);
	      while (++index < length) {
	        if (callback(array[index], index, array)) {
	          return index;
	        }
	      }
	      return -1;
	    }
	
	    /**
	     * This method is like `_.findIndex` except that it iterates over elements
	     * of a `collection` from right to left.
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to search.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var characters = [
	     *   { 'name': 'barney',  'age': 36, 'blocked': true },
	     *   { 'name': 'fred',    'age': 40, 'blocked': false },
	     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }
	     * ];
	     *
	     * _.findLastIndex(characters, function(chr) {
	     *   return chr.age > 30;
	     * });
	     * // => 1
	     *
	     * // using "_.where" callback shorthand
	     * _.findLastIndex(characters, { 'age': 36 });
	     * // => 0
	     *
	     * // using "_.pluck" callback shorthand
	     * _.findLastIndex(characters, 'blocked');
	     * // => 2
	     */
	    function findLastIndex(array, callback, thisArg) {
	      var length = array ? array.length : 0;
	      callback = lodash.createCallback(callback, thisArg, 3);
	      while (length--) {
	        if (callback(array[length], length, array)) {
	          return length;
	        }
	      }
	      return -1;
	    }
	
	    /**
	     * Gets the first element or first `n` elements of an array. If a callback
	     * is provided elements at the beginning of the array are returned as long
	     * as the callback returns truey. The callback is bound to `thisArg` and
	     * invoked with three arguments; (value, index, array).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias head, take
	     * @category Arrays
	     * @param {Array} array The array to query.
	     * @param {Function|Object|number|string} [callback] The function called
	     *  per element or the number of elements to return. If a property name or
	     *  object is provided it will be used to create a "_.pluck" or "_.where"
	     *  style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {*} Returns the first element(s) of `array`.
	     * @example
	     *
	     * _.first([1, 2, 3]);
	     * // => 1
	     *
	     * _.first([1, 2, 3], 2);
	     * // => [1, 2]
	     *
	     * _.first([1, 2, 3], function(num) {
	     *   return num < 3;
	     * });
	     * // => [1, 2]
	     *
	     * var characters = [
	     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
	     *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
	     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
	     * ];
	     *
	     * // using "_.pluck" callback shorthand
	     * _.first(characters, 'blocked');
	     * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
	     *
	     * // using "_.where" callback shorthand
	     * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
	     * // => ['barney', 'fred']
	     */
	    function first(array, callback, thisArg) {
	      var n = 0,
	          length = array ? array.length : 0;
	
	      if (typeof callback != 'number' && callback != null) {
	        var index = -1;
	        callback = lodash.createCallback(callback, thisArg, 3);
	        while (++index < length && callback(array[index], index, array)) {
	          n++;
	        }
	      } else {
	        n = callback;
	        if (n == null || thisArg) {
	          return array ? array[0] : undefined;
	        }
	      }
	      return slice(array, 0, nativeMin(nativeMax(0, n), length));
	    }
	
	    /**
	     * Flattens a nested array (the nesting can be to any depth). If `isShallow`
	     * is truey, the array will only be flattened a single level. If a callback
	     * is provided each element of the array is passed through the callback before
	     * flattening. The callback is bound to `thisArg` and invoked with three
	     * arguments; (value, index, array).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to flatten.
	     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array} Returns a new flattened array.
	     * @example
	     *
	     * _.flatten([1, [2], [3, [[4]]]]);
	     * // => [1, 2, 3, 4];
	     *
	     * _.flatten([1, [2], [3, [[4]]]], true);
	     * // => [1, 2, 3, [[4]]];
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
	     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
	     * ];
	     *
	     * // using "_.pluck" callback shorthand
	     * _.flatten(characters, 'pets');
	     * // => ['hoppy', 'baby puss', 'dino']
	     */
	    function flatten(array, isShallow, callback, thisArg) {
	      // juggle arguments
	      if (typeof isShallow != 'boolean' && isShallow != null) {
	        thisArg = callback;
	        callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
	        isShallow = false;
	      }
	      if (callback != null) {
	        array = map(array, callback, thisArg);
	      }
	      return baseFlatten(array, isShallow);
	    }
	
	    /**
	     * Gets the index at which the first occurrence of `value` is found using
	     * strict equality for comparisons, i.e. `===`. If the array is already sorted
	     * providing `true` for `fromIndex` will run a faster binary search.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to search.
	     * @param {*} value The value to search for.
	     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
	     *  to perform a binary search on a sorted array.
	     * @returns {number} Returns the index of the matched value or `-1`.
	     * @example
	     *
	     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
	     * // => 1
	     *
	     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
	     * // => 4
	     *
	     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
	     * // => 2
	     */
	    function indexOf(array, value, fromIndex) {
	      if (typeof fromIndex == 'number') {
	        var length = array ? array.length : 0;
	        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
	      } else if (fromIndex) {
	        var index = sortedIndex(array, value);
	        return array[index] === value ? index : -1;
	      }
	      return baseIndexOf(array, value, fromIndex);
	    }
	
	    /**
	     * Gets all but the last element or last `n` elements of an array. If a
	     * callback is provided elements at the end of the array are excluded from
	     * the result as long as the callback returns truey. The callback is bound
	     * to `thisArg` and invoked with three arguments; (value, index, array).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to query.
	     * @param {Function|Object|number|string} [callback=1] The function called
	     *  per element or the number of elements to exclude. If a property name or
	     *  object is provided it will be used to create a "_.pluck" or "_.where"
	     *  style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array} Returns a slice of `array`.
	     * @example
	     *
	     * _.initial([1, 2, 3]);
	     * // => [1, 2]
	     *
	     * _.initial([1, 2, 3], 2);
	     * // => [1]
	     *
	     * _.initial([1, 2, 3], function(num) {
	     *   return num > 1;
	     * });
	     * // => [1]
	     *
	     * var characters = [
	     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
	     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
	     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
	     * ];
	     *
	     * // using "_.pluck" callback shorthand
	     * _.initial(characters, 'blocked');
	     * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
	     *
	     * // using "_.where" callback shorthand
	     * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
	     * // => ['barney', 'fred']
	     */
	    function initial(array, callback, thisArg) {
	      var n = 0,
	          length = array ? array.length : 0;
	
	      if (typeof callback != 'number' && callback != null) {
	        var index = length;
	        callback = lodash.createCallback(callback, thisArg, 3);
	        while (index-- && callback(array[index], index, array)) {
	          n++;
	        }
	      } else {
	        n = (callback == null || thisArg) ? 1 : callback || n;
	      }
	      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
	    }
	
	    /**
	     * Creates an array of unique values present in all provided arrays using
	     * strict equality for comparisons, i.e. `===`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {...Array} [array] The arrays to inspect.
	     * @returns {Array} Returns an array of shared values.
	     * @example
	     *
	     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
	     * // => [1, 2]
	     */
	    function intersection() {
	      var args = [],
	          argsIndex = -1,
	          argsLength = arguments.length,
	          caches = getArray(),
	          indexOf = getIndexOf(),
	          trustIndexOf = indexOf === baseIndexOf,
	          seen = getArray();
	
	      while (++argsIndex < argsLength) {
	        var value = arguments[argsIndex];
	        if (isArray(value) || isArguments(value)) {
	          args.push(value);
	          caches.push(trustIndexOf && value.length >= largeArraySize &&
	            createCache(argsIndex ? args[argsIndex] : seen));
	        }
	      }
	      var array = args[0],
	          index = -1,
	          length = array ? array.length : 0,
	          result = [];
	
	      outer:
	      while (++index < length) {
	        var cache = caches[0];
	        value = array[index];
	
	        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
	          argsIndex = argsLength;
	          (cache || seen).push(value);
	          while (--argsIndex) {
	            cache = caches[argsIndex];
	            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
	              continue outer;
	            }
	          }
	          result.push(value);
	        }
	      }
	      while (argsLength--) {
	        cache = caches[argsLength];
	        if (cache) {
	          releaseObject(cache);
	        }
	      }
	      releaseArray(caches);
	      releaseArray(seen);
	      return result;
	    }
	
	    /**
	     * Gets the last element or last `n` elements of an array. If a callback is
	     * provided elements at the end of the array are returned as long as the
	     * callback returns truey. The callback is bound to `thisArg` and invoked
	     * with three arguments; (value, index, array).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to query.
	     * @param {Function|Object|number|string} [callback] The function called
	     *  per element or the number of elements to return. If a property name or
	     *  object is provided it will be used to create a "_.pluck" or "_.where"
	     *  style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {*} Returns the last element(s) of `array`.
	     * @example
	     *
	     * _.last([1, 2, 3]);
	     * // => 3
	     *
	     * _.last([1, 2, 3], 2);
	     * // => [2, 3]
	     *
	     * _.last([1, 2, 3], function(num) {
	     *   return num > 1;
	     * });
	     * // => [2, 3]
	     *
	     * var characters = [
	     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
	     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
	     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
	     * ];
	     *
	     * // using "_.pluck" callback shorthand
	     * _.pluck(_.last(characters, 'blocked'), 'name');
	     * // => ['fred', 'pebbles']
	     *
	     * // using "_.where" callback shorthand
	     * _.last(characters, { 'employer': 'na' });
	     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
	     */
	    function last(array, callback, thisArg) {
	      var n = 0,
	          length = array ? array.length : 0;
	
	      if (typeof callback != 'number' && callback != null) {
	        var index = length;
	        callback = lodash.createCallback(callback, thisArg, 3);
	        while (index-- && callback(array[index], index, array)) {
	          n++;
	        }
	      } else {
	        n = callback;
	        if (n == null || thisArg) {
	          return array ? array[length - 1] : undefined;
	        }
	      }
	      return slice(array, nativeMax(0, length - n));
	    }
	
	    /**
	     * Gets the index at which the last occurrence of `value` is found using strict
	     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
	     * as the offset from the end of the collection.
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to search.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=array.length-1] The index to search from.
	     * @returns {number} Returns the index of the matched value or `-1`.
	     * @example
	     *
	     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
	     * // => 4
	     *
	     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
	     * // => 1
	     */
	    function lastIndexOf(array, value, fromIndex) {
	      var index = array ? array.length : 0;
	      if (typeof fromIndex == 'number') {
	        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
	      }
	      while (index--) {
	        if (array[index] === value) {
	          return index;
	        }
	      }
	      return -1;
	    }
	
	    /**
	     * Removes all provided values from the given array using strict equality for
	     * comparisons, i.e. `===`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to modify.
	     * @param {...*} [value] The values to remove.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3, 1, 2, 3];
	     * _.pull(array, 2, 3);
	     * console.log(array);
	     * // => [1, 1]
	     */
	    function pull(array) {
	      var args = arguments,
	          argsIndex = 0,
	          argsLength = args.length,
	          length = array ? array.length : 0;
	
	      while (++argsIndex < argsLength) {
	        var index = -1,
	            value = args[argsIndex];
	        while (++index < length) {
	          if (array[index] === value) {
	            splice.call(array, index--, 1);
	            length--;
	          }
	        }
	      }
	      return array;
	    }
	
	    /**
	     * Creates an array of numbers (positive and/or negative) progressing from
	     * `start` up to but not including `end`. If `start` is less than `stop` a
	     * zero-length range is created unless a negative `step` is specified.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} [step=1] The value to increment or decrement by.
	     * @returns {Array} Returns a new range array.
	     * @example
	     *
	     * _.range(4);
	     * // => [0, 1, 2, 3]
	     *
	     * _.range(1, 5);
	     * // => [1, 2, 3, 4]
	     *
	     * _.range(0, 20, 5);
	     * // => [0, 5, 10, 15]
	     *
	     * _.range(0, -4, -1);
	     * // => [0, -1, -2, -3]
	     *
	     * _.range(1, 4, 0);
	     * // => [1, 1, 1]
	     *
	     * _.range(0);
	     * // => []
	     */
	    function range(start, end, step) {
	      start = +start || 0;
	      step = typeof step == 'number' ? step : (+step || 1);
	
	      if (end == null) {
	        end = start;
	        start = 0;
	      }
	      // use `Array(length)` so engines like Chakra and V8 avoid slower modes
	      // http://youtu.be/XAqIpGU8ZZk#t=17m25s
	      var index = -1,
	          length = nativeMax(0, ceil((end - start) / (step || 1))),
	          result = Array(length);
	
	      while (++index < length) {
	        result[index] = start;
	        start += step;
	      }
	      return result;
	    }
	
	    /**
	     * Removes all elements from an array that the callback returns truey for
	     * and returns an array of removed elements. The callback is bound to `thisArg`
	     * and invoked with three arguments; (value, index, array).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to modify.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array} Returns a new array of removed elements.
	     * @example
	     *
	     * var array = [1, 2, 3, 4, 5, 6];
	     * var evens = _.remove(array, function(num) { return num % 2 == 0; });
	     *
	     * console.log(array);
	     * // => [1, 3, 5]
	     *
	     * console.log(evens);
	     * // => [2, 4, 6]
	     */
	    function remove(array, callback, thisArg) {
	      var index = -1,
	          length = array ? array.length : 0,
	          result = [];
	
	      callback = lodash.createCallback(callback, thisArg, 3);
	      while (++index < length) {
	        var value = array[index];
	        if (callback(value, index, array)) {
	          result.push(value);
	          splice.call(array, index--, 1);
	          length--;
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The opposite of `_.initial` this method gets all but the first element or
	     * first `n` elements of an array. If a callback function is provided elements
	     * at the beginning of the array are excluded from the result as long as the
	     * callback returns truey. The callback is bound to `thisArg` and invoked
	     * with three arguments; (value, index, array).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias drop, tail
	     * @category Arrays
	     * @param {Array} array The array to query.
	     * @param {Function|Object|number|string} [callback=1] The function called
	     *  per element or the number of elements to exclude. If a property name or
	     *  object is provided it will be used to create a "_.pluck" or "_.where"
	     *  style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array} Returns a slice of `array`.
	     * @example
	     *
	     * _.rest([1, 2, 3]);
	     * // => [2, 3]
	     *
	     * _.rest([1, 2, 3], 2);
	     * // => [3]
	     *
	     * _.rest([1, 2, 3], function(num) {
	     *   return num < 3;
	     * });
	     * // => [3]
	     *
	     * var characters = [
	     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
	     *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
	     *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
	     * ];
	     *
	     * // using "_.pluck" callback shorthand
	     * _.pluck(_.rest(characters, 'blocked'), 'name');
	     * // => ['fred', 'pebbles']
	     *
	     * // using "_.where" callback shorthand
	     * _.rest(characters, { 'employer': 'slate' });
	     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
	     */
	    function rest(array, callback, thisArg) {
	      if (typeof callback != 'number' && callback != null) {
	        var n = 0,
	            index = -1,
	            length = array ? array.length : 0;
	
	        callback = lodash.createCallback(callback, thisArg, 3);
	        while (++index < length && callback(array[index], index, array)) {
	          n++;
	        }
	      } else {
	        n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
	      }
	      return slice(array, n);
	    }
	
	    /**
	     * Uses a binary search to determine the smallest index at which a value
	     * should be inserted into a given sorted array in order to maintain the sort
	     * order of the array. If a callback is provided it will be executed for
	     * `value` and each element of `array` to compute their sort ranking. The
	     * callback is bound to `thisArg` and invoked with one argument; (value).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedIndex([20, 30, 50], 40);
	     * // => 2
	     *
	     * // using "_.pluck" callback shorthand
	     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
	     * // => 2
	     *
	     * var dict = {
	     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
	     * };
	     *
	     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
	     *   return dict.wordToNumber[word];
	     * });
	     * // => 2
	     *
	     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
	     *   return this.wordToNumber[word];
	     * }, dict);
	     * // => 2
	     */
	    function sortedIndex(array, value, callback, thisArg) {
	      var low = 0,
	          high = array ? array.length : low;
	
	      // explicitly reference `identity` for better inlining in Firefox
	      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
	      value = callback(value);
	
	      while (low < high) {
	        var mid = (low + high) >>> 1;
	        (callback(array[mid]) < value)
	          ? low = mid + 1
	          : high = mid;
	      }
	      return low;
	    }
	
	    /**
	     * Creates an array of unique values, in order, of the provided arrays using
	     * strict equality for comparisons, i.e. `===`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {...Array} [array] The arrays to inspect.
	     * @returns {Array} Returns an array of combined values.
	     * @example
	     *
	     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
	     * // => [1, 2, 3, 5, 4]
	     */
	    function union() {
	      return baseUniq(baseFlatten(arguments, true, true));
	    }
	
	    /**
	     * Creates a duplicate-value-free version of an array using strict equality
	     * for comparisons, i.e. `===`. If the array is sorted, providing
	     * `true` for `isSorted` will use a faster algorithm. If a callback is provided
	     * each element of `array` is passed through the callback before uniqueness
	     * is computed. The callback is bound to `thisArg` and invoked with three
	     * arguments; (value, index, array).
	     *
	     * If a property name is provided for `callback` the created "_.pluck" style
	     * callback will return the property value of the given element.
	     *
	     * If an object is provided for `callback` the created "_.where" style callback
	     * will return `true` for elements that have the properties of the given object,
	     * else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias unique
	     * @category Arrays
	     * @param {Array} array The array to process.
	     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
	     * @param {Function|Object|string} [callback=identity] The function called
	     *  per iteration. If a property name or object is provided it will be used
	     *  to create a "_.pluck" or "_.where" style callback, respectively.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array} Returns a duplicate-value-free array.
	     * @example
	     *
	     * _.uniq([1, 2, 1, 3, 1]);
	     * // => [1, 2, 3]
	     *
	     * _.uniq([1, 1, 2, 2, 3], true);
	     * // => [1, 2, 3]
	     *
	     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
	     * // => ['A', 'b', 'C']
	     *
	     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
	     * // => [1, 2.5, 3]
	     *
	     * // using "_.pluck" callback shorthand
	     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }, { 'x': 2 }]
	     */
	    function uniq(array, isSorted, callback, thisArg) {
	      // juggle arguments
	      if (typeof isSorted != 'boolean' && isSorted != null) {
	        thisArg = callback;
	        callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
	        isSorted = false;
	      }
	      if (callback != null) {
	        callback = lodash.createCallback(callback, thisArg, 3);
	      }
	      return baseUniq(array, isSorted, callback);
	    }
	
	    /**
	     * Creates an array excluding all provided values using strict equality for
	     * comparisons, i.e. `===`.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {Array} array The array to filter.
	     * @param {...*} [value] The values to exclude.
	     * @returns {Array} Returns a new array of filtered values.
	     * @example
	     *
	     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
	     * // => [2, 3, 4]
	     */
	    function without(array) {
	      return baseDifference(array, slice(arguments, 1));
	    }
	
	    /**
	     * Creates an array that is the symmetric difference of the provided arrays.
	     * See http://en.wikipedia.org/wiki/Symmetric_difference.
	     *
	     * @static
	     * @memberOf _
	     * @category Arrays
	     * @param {...Array} [array] The arrays to inspect.
	     * @returns {Array} Returns an array of values.
	     * @example
	     *
	     * _.xor([1, 2, 3], [5, 2, 1, 4]);
	     * // => [3, 5, 4]
	     *
	     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
	     * // => [1, 4, 5]
	     */
	    function xor() {
	      var index = -1,
	          length = arguments.length;
	
	      while (++index < length) {
	        var array = arguments[index];
	        if (isArray(array) || isArguments(array)) {
	          var result = result
	            ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))
	            : array;
	        }
	      }
	      return result || [];
	    }
	
	    /**
	     * Creates an array of grouped elements, the first of which contains the first
	     * elements of the given arrays, the second of which contains the second
	     * elements of the given arrays, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @alias unzip
	     * @category Arrays
	     * @param {...Array} [array] Arrays to process.
	     * @returns {Array} Returns a new array of grouped elements.
	     * @example
	     *
	     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
	     * // => [['fred', 30, true], ['barney', 40, false]]
	     */
	    function zip() {
	      var array = arguments.length > 1 ? arguments : arguments[0],
	          index = -1,
	          length = array ? max(pluck(array, 'length')) : 0,
	          result = Array(length < 0 ? 0 : length);
	
	      while (++index < length) {
	        result[index] = pluck(array, index);
	      }
	      return result;
	    }
	
	    /**
	     * Creates an object composed from arrays of `keys` and `values`. Provide
	     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
	     * or two arrays, one of `keys` and one of corresponding `values`.
	     *
	     * @static
	     * @memberOf _
	     * @alias object
	     * @category Arrays
	     * @param {Array} keys The array of keys.
	     * @param {Array} [values=[]] The array of values.
	     * @returns {Object} Returns an object composed of the given keys and
	     *  corresponding values.
	     * @example
	     *
	     * _.zipObject(['fred', 'barney'], [30, 40]);
	     * // => { 'fred': 30, 'barney': 40 }
	     */
	    function zipObject(keys, values) {
	      var index = -1,
	          length = keys ? keys.length : 0,
	          result = {};
	
	      if (!values && length && !isArray(keys[0])) {
	        values = [];
	      }
	      while (++index < length) {
	        var key = keys[index];
	        if (values) {
	          result[key] = values[index];
	        } else if (key) {
	          result[key[0]] = key[1];
	        }
	      }
	      return result;
	    }
	
	    /*--------------------------------------------------------------------------*/
	
	    /**
	     * Creates a function that executes `func`, with  the `this` binding and
	     * arguments of the created function, only after being called `n` times.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {number} n The number of times the function must be called before
	     *  `func` is executed.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var saves = ['profile', 'settings'];
	     *
	     * var done = _.after(saves.length, function() {
	     *   console.log('Done saving!');
	     * });
	     *
	     * _.forEach(saves, function(type) {
	     *   asyncSave({ 'type': type, 'complete': done });
	     * });
	     * // => logs 'Done saving!', after all saves have completed
	     */
	    function after(n, func) {
	      if (!isFunction(func)) {
	        throw new TypeError;
	      }
	      return function() {
	        if (--n < 1) {
	          return func.apply(this, arguments);
	        }
	      };
	    }
	
	    /**
	     * Creates a function that, when called, invokes `func` with the `this`
	     * binding of `thisArg` and prepends any additional `bind` arguments to those
	     * provided to the bound function.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {Function} func The function to bind.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {...*} [arg] Arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * var func = function(greeting) {
	     *   return greeting + ' ' + this.name;
	     * };
	     *
	     * func = _.bind(func, { 'name': 'fred' }, 'hi');
	     * func();
	     * // => 'hi fred'
	     */
	    function bind(func, thisArg) {
	      return arguments.length > 2
	        ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
	        : createWrapper(func, 1, null, null, thisArg);
	    }
	
	    /**
	     * Binds methods of an object to the object itself, overwriting the existing
	     * method. Method names may be specified as individual arguments or as arrays
	     * of method names. If no method names are provided all the function properties
	     * of `object` will be bound.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {Object} object The object to bind and assign the bound methods to.
	     * @param {...string} [methodName] The object method names to
	     *  bind, specified as individual method names or arrays of method names.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var view = {
	     *   'label': 'docs',
	     *   'onClick': function() { console.log('clicked ' + this.label); }
	     * };
	     *
	     * _.bindAll(view);
	     * jQuery('#docs').on('click', view.onClick);
	     * // => logs 'clicked docs', when the button is clicked
	     */
	    function bindAll(object) {
	      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
	          index = -1,
	          length = funcs.length;
	
	      while (++index < length) {
	        var key = funcs[index];
	        object[key] = createWrapper(object[key], 1, null, null, object);
	      }
	      return object;
	    }
	
	    /**
	     * Creates a function that, when called, invokes the method at `object[key]`
	     * and prepends any additional `bindKey` arguments to those provided to the bound
	     * function. This method differs from `_.bind` by allowing bound functions to
	     * reference methods that will be redefined or don't yet exist.
	     * See http://michaux.ca/articles/lazy-function-definition-pattern.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {Object} object The object the method belongs to.
	     * @param {string} key The key of the method.
	     * @param {...*} [arg] Arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * var object = {
	     *   'name': 'fred',
	     *   'greet': function(greeting) {
	     *     return greeting + ' ' + this.name;
	     *   }
	     * };
	     *
	     * var func = _.bindKey(object, 'greet', 'hi');
	     * func();
	     * // => 'hi fred'
	     *
	     * object.greet = function(greeting) {
	     *   return greeting + 'ya ' + this.name + '!';
	     * };
	     *
	     * func();
	     * // => 'hiya fred!'
	     */
	    function bindKey(object, key) {
	      return arguments.length > 2
	        ? createWrapper(key, 19, slice(arguments, 2), null, object)
	        : createWrapper(key, 3, null, null, object);
	    }
	
	    /**
	     * Creates a function that is the composition of the provided functions,
	     * where each function consumes the return value of the function that follows.
	     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
	     * Each function is executed with the `this` binding of the composed function.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {...Function} [func] Functions to compose.
	     * @returns {Function} Returns the new composed function.
	     * @example
	     *
	     * var realNameMap = {
	     *   'pebbles': 'penelope'
	     * };
	     *
	     * var format = function(name) {
	     *   name = realNameMap[name.toLowerCase()] || name;
	     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
	     * };
	     *
	     * var greet = function(formatted) {
	     *   return 'Hiya ' + formatted + '!';
	     * };
	     *
	     * var welcome = _.compose(greet, format);
	     * welcome('pebbles');
	     * // => 'Hiya Penelope!'
	     */
	    function compose() {
	      var funcs = arguments,
	          length = funcs.length;
	
	      while (length--) {
	        if (!isFunction(funcs[length])) {
	          throw new TypeError;
	        }
	      }
	      return function() {
	        var args = arguments,
	            length = funcs.length;
	
	        while (length--) {
	          args = [funcs[length].apply(this, args)];
	        }
	        return args[0];
	      };
	    }
	
	    /**
	     * Creates a function which accepts one or more arguments of `func` that when
	     * invoked either executes `func` returning its result, if all `func` arguments
	     * have been provided, or returns a function that accepts one or more of the
	     * remaining `func` arguments, and so on. The arity of `func` can be specified
	     * if `func.length` is not sufficient.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var curried = _.curry(function(a, b, c) {
	     *   console.log(a + b + c);
	     * });
	     *
	     * curried(1)(2)(3);
	     * // => 6
	     *
	     * curried(1, 2)(3);
	     * // => 6
	     *
	     * curried(1, 2, 3);
	     * // => 6
	     */
	    function curry(func, arity) {
	      arity = typeof arity == 'number' ? arity : (+arity || func.length);
	      return createWrapper(func, 4, null, null, null, arity);
	    }
	
	    /**
	     * Creates a function that will delay the execution of `func` until after
	     * `wait` milliseconds have elapsed since the last time it was invoked.
	     * Provide an options object to indicate that `func` should be invoked on
	     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
	     * to the debounced function will return the result of the last `func` call.
	     *
	     * Note: If `leading` and `trailing` options are `true` `func` will be called
	     * on the trailing edge of the timeout only if the the debounced function is
	     * invoked more than once during the `wait` timeout.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {Function} func The function to debounce.
	     * @param {number} wait The number of milliseconds to delay.
	     * @param {Object} [options] The options object.
	     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
	     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
	     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
	     * @returns {Function} Returns the new debounced function.
	     * @example
	     *
	     * // avoid costly calculations while the window size is in flux
	     * var lazyLayout = _.debounce(calculateLayout, 150);
	     * jQuery(window).on('resize', lazyLayout);
	     *
	     * // execute `sendMail` when the click event is fired, debouncing subsequent calls
	     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
	     *   'leading': true,
	     *   'trailing': false
	     * });
	     *
	     * // ensure `batchLog` is executed once after 1 second of debounced calls
	     * var source = new EventSource('/stream');
	     * source.addEventListener('message', _.debounce(batchLog, 250, {
	     *   'maxWait': 1000
	     * }, false);
	     */
	    function debounce(func, wait, options) {
	      var args,
	          maxTimeoutId,
	          result,
	          stamp,
	          thisArg,
	          timeoutId,
	          trailingCall,
	          lastCalled = 0,
	          maxWait = false,
	          trailing = true;
	
	      if (!isFunction(func)) {
	        throw new TypeError;
	      }
	      wait = nativeMax(0, wait) || 0;
	      if (options === true) {
	        var leading = true;
	        trailing = false;
	      } else if (isObject(options)) {
	        leading = options.leading;
	        maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
	        trailing = 'trailing' in options ? options.trailing : trailing;
	      }
	      var delayed = function() {
	        var remaining = wait - (now() - stamp);
	        if (remaining <= 0) {
	          if (maxTimeoutId) {
	            clearTimeout(maxTimeoutId);
	          }
	          var isCalled = trailingCall;
	          maxTimeoutId = timeoutId = trailingCall = undefined;
	          if (isCalled) {
	            lastCalled = now();
	            result = func.apply(thisArg, args);
	            if (!timeoutId && !maxTimeoutId) {
	              args = thisArg = null;
	            }
	          }
	        } else {
	          timeoutId = setTimeout(delayed, remaining);
	        }
	      };
	
	      var maxDelayed = function() {
	        if (timeoutId) {
	          clearTimeout(timeoutId);
	        }
	        maxTimeoutId = timeoutId = trailingCall = undefined;
	        if (trailing || (maxWait !== wait)) {
	          lastCalled = now();
	          result = func.apply(thisArg, args);
	          if (!timeoutId && !maxTimeoutId) {
	            args = thisArg = null;
	          }
	        }
	      };
	
	      return function() {
	        args = arguments;
	        stamp = now();
	        thisArg = this;
	        trailingCall = trailing && (timeoutId || !leading);
	
	        if (maxWait === false) {
	          var leadingCall = leading && !timeoutId;
	        } else {
	          if (!maxTimeoutId && !leading) {
	            lastCalled = stamp;
	          }
	          var remaining = maxWait - (stamp - lastCalled),
	              isCalled = remaining <= 0;
	
	          if (isCalled) {
	            if (maxTimeoutId) {
	              maxTimeoutId = clearTimeout(maxTimeoutId);
	            }
	            lastCalled = stamp;
	            result = func.apply(thisArg, args);
	          }
	          else if (!maxTimeoutId) {
	            maxTimeoutId = setTimeout(maxDelayed, remaining);
	          }
	        }
	        if (isCalled && timeoutId) {
	          timeoutId = clearTimeout(timeoutId);
	        }
	        else if (!timeoutId && wait !== maxWait) {
	          timeoutId = setTimeout(delayed, wait);
	        }
	        if (leadingCall) {
	          isCalled = true;
	          result = func.apply(thisArg, args);
	        }
	        if (isCalled && !timeoutId && !maxTimeoutId) {
	          args = thisArg = null;
	        }
	        return result;
	      };
	    }
	
	    /**
	     * Defers executing the `func` function until the current call stack has cleared.
	     * Additional arguments will be provided to `func` when it is invoked.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {Function} func The function to defer.
	     * @param {...*} [arg] Arguments to invoke the function with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.defer(function(text) { console.log(text); }, 'deferred');
	     * // logs 'deferred' after one or more milliseconds
	     */
	    function defer(func) {
	      if (!isFunction(func)) {
	        throw new TypeError;
	      }
	      var args = slice(arguments, 1);
	      return setTimeout(function() { func.apply(undefined, args); }, 1);
	    }
	
	    /**
	     * Executes the `func` function after `wait` milliseconds. Additional arguments
	     * will be provided to `func` when it is invoked.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay execution.
	     * @param {...*} [arg] Arguments to invoke the function with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.delay(function(text) { console.log(text); }, 1000, 'later');
	     * // => logs 'later' after one second
	     */
	    function delay(func, wait) {
	      if (!isFunction(func)) {
	        throw new TypeError;
	      }
	      var args = slice(arguments, 2);
	      return setTimeout(function() { func.apply(undefined, args); }, wait);
	    }
	
	    /**
	     * Creates a function that memoizes the result of `func`. If `resolver` is
	     * provided it will be used to determine the cache key for storing the result
	     * based on the arguments provided to the memoized function. By default, the
	     * first argument provided to the memoized function is used as the cache key.
	     * The `func` is executed with the `this` binding of the memoized function.
	     * The result cache is exposed as the `cache` property on the memoized function.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {Function} func The function to have its output memoized.
	     * @param {Function} [resolver] A function used to resolve the cache key.
	     * @returns {Function} Returns the new memoizing function.
	     * @example
	     *
	     * var fibonacci = _.memoize(function(n) {
	     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
	     * });
	     *
	     * fibonacci(9)
	     * // => 34
	     *
	     * var data = {
	     *   'fred': { 'name': 'fred', 'age': 40 },
	     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
	     * };
	     *
	     * // modifying the result cache
	     * var get = _.memoize(function(name) { return data[name]; }, _.identity);
	     * get('pebbles');
	     * // => { 'name': 'pebbles', 'age': 1 }
	     *
	     * get.cache.pebbles.name = 'penelope';
	     * get('pebbles');
	     * // => { 'name': 'penelope', 'age': 1 }
	     */
	    function memoize(func, resolver) {
	      if (!isFunction(func)) {
	        throw new TypeError;
	      }
	      var memoized = function() {
	        var cache = memoized.cache,
	            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];
	
	        return hasOwnProperty.call(cache, key)
	          ? cache[key]
	          : (cache[key] = func.apply(this, arguments));
	      }
	      memoized.cache = {};
	      return memoized;
	    }
	
	    /**
	     * Creates a function that is restricted to execute `func` once. Repeat calls to
	     * the function will return the value of the first call. The `func` is executed
	     * with the `this` binding of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var initialize = _.once(createApplication);
	     * initialize();
	     * initialize();
	     * // `initialize` executes `createApplication` once
	     */
	    function once(func) {
	      var ran,
	          result;
	
	      if (!isFunction(func)) {
	        throw new TypeError;
	      }
	      return function() {
	        if (ran) {
	          return result;
	        }
	        ran = true;
	        result = func.apply(this, arguments);
	
	        // clear the `func` variable so the function may be garbage collected
	        func = null;
	        return result;
	      };
	    }
	
	    /**
	     * Creates a function that, when called, invokes `func` with any additional
	     * `partial` arguments prepended to those provided to the new function. This
	     * method is similar to `_.bind` except it does **not** alter the `this` binding.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [arg] Arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * var greet = function(greeting, name) { return greeting + ' ' + name; };
	     * var hi = _.partial(greet, 'hi');
	     * hi('fred');
	     * // => 'hi fred'
	     */
	    function partial(func) {
	      return createWrapper(func, 16, slice(arguments, 1));
	    }
	
	    /**
	     * This method is like `_.partial` except that `partial` arguments are
	     * appended to those provided to the new function.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [arg] Arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * var defaultsDeep = _.partialRight(_.merge, _.defaults);
	     *
	     * var options = {
	     *   'variable': 'data',
	     *   'imports': { 'jq': $ }
	     * };
	     *
	     * defaultsDeep(options, _.templateSettings);
	     *
	     * options.variable
	     * // => 'data'
	     *
	     * options.imports
	     * // => { '_': _, 'jq': $ }
	     */
	    function partialRight(func) {
	      return createWrapper(func, 32, null, slice(arguments, 1));
	    }
	
	    /**
	     * Creates a function that, when executed, will only call the `func` function
	     * at most once per every `wait` milliseconds. Provide an options object to
	     * indicate that `func` should be invoked on the leading and/or trailing edge
	     * of the `wait` timeout. Subsequent calls to the throttled function will
	     * return the result of the last `func` call.
	     *
	     * Note: If `leading` and `trailing` options are `true` `func` will be called
	     * on the trailing edge of the timeout only if the the throttled function is
	     * invoked more than once during the `wait` timeout.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {Function} func The function to throttle.
	     * @param {number} wait The number of milliseconds to throttle executions to.
	     * @param {Object} [options] The options object.
	     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
	     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
	     * @returns {Function} Returns the new throttled function.
	     * @example
	     *
	     * // avoid excessively updating the position while scrolling
	     * var throttled = _.throttle(updatePosition, 100);
	     * jQuery(window).on('scroll', throttled);
	     *
	     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
	     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
	     *   'trailing': false
	     * }));
	     */
	    function throttle(func, wait, options) {
	      var leading = true,
	          trailing = true;
	
	      if (!isFunction(func)) {
	        throw new TypeError;
	      }
	      if (options === false) {
	        leading = false;
	      } else if (isObject(options)) {
	        leading = 'leading' in options ? options.leading : leading;
	        trailing = 'trailing' in options ? options.trailing : trailing;
	      }
	      debounceOptions.leading = leading;
	      debounceOptions.maxWait = wait;
	      debounceOptions.trailing = trailing;
	
	      return debounce(func, wait, debounceOptions);
	    }
	
	    /**
	     * Creates a function that provides `value` to the wrapper function as its
	     * first argument. Additional arguments provided to the function are appended
	     * to those provided to the wrapper function. The wrapper is executed with
	     * the `this` binding of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @category Functions
	     * @param {*} value The value to wrap.
	     * @param {Function} wrapper The wrapper function.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var p = _.wrap(_.escape, function(func, text) {
	     *   return '<p>' + func(text) + '</p>';
	     * });
	     *
	     * p('Fred, Wilma, & Pebbles');
	     * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
	     */
	    function wrap(value, wrapper) {
	      return createWrapper(wrapper, 16, [value]);
	    }
	
	    /*--------------------------------------------------------------------------*/
	
	    /**
	     * Creates a function that returns `value`.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {*} value The value to return from the new function.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var object = { 'name': 'fred' };
	     * var getter = _.constant(object);
	     * getter() === object;
	     * // => true
	     */
	    function constant(value) {
	      return function() {
	        return value;
	      };
	    }
	
	    /**
	     * Produces a callback bound to an optional `thisArg`. If `func` is a property
	     * name the created callback will return the property value for a given element.
	     * If `func` is an object the created callback will return `true` for elements
	     * that contain the equivalent object properties, otherwise it will return `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {*} [func=identity] The value to convert to a callback.
	     * @param {*} [thisArg] The `this` binding of the created callback.
	     * @param {number} [argCount] The number of arguments the callback accepts.
	     * @returns {Function} Returns a callback function.
	     * @example
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36 },
	     *   { 'name': 'fred',   'age': 40 }
	     * ];
	     *
	     * // wrap to create custom callback shorthands
	     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
	     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
	     *   return !match ? func(callback, thisArg) : function(object) {
	     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
	     *   };
	     * });
	     *
	     * _.filter(characters, 'age__gt38');
	     * // => [{ 'name': 'fred', 'age': 40 }]
	     */
	    function createCallback(func, thisArg, argCount) {
	      var type = typeof func;
	      if (func == null || type == 'function') {
	        return baseCreateCallback(func, thisArg, argCount);
	      }
	      // handle "_.pluck" style callback shorthands
	      if (type != 'object') {
	        return property(func);
	      }
	      var props = keys(func),
	          key = props[0],
	          a = func[key];
	
	      // handle "_.where" style callback shorthands
	      if (props.length == 1 && a === a && !isObject(a)) {
	        // fast path the common case of providing an object with a single
	        // property containing a primitive value
	        return function(object) {
	          var b = object[key];
	          return a === b && (a !== 0 || (1 / a == 1 / b));
	        };
	      }
	      return function(object) {
	        var length = props.length,
	            result = false;
	
	        while (length--) {
	          if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
	            break;
	          }
	        }
	        return result;
	      };
	    }
	
	    /**
	     * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
	     * corresponding HTML entities.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {string} string The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escape('Fred, Wilma, & Pebbles');
	     * // => 'Fred, Wilma, &amp; Pebbles'
	     */
	    function escape(string) {
	      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
	    }
	
	    /**
	     * This method returns the first argument provided to it.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {*} value Any value.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * var object = { 'name': 'fred' };
	     * _.identity(object) === object;
	     * // => true
	     */
	    function identity(value) {
	      return value;
	    }
	
	    /**
	     * Adds function properties of a source object to the destination object.
	     * If `object` is a function methods will be added to its prototype as well.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {Function|Object} [object=lodash] object The destination object.
	     * @param {Object} source The object of functions to add.
	     * @param {Object} [options] The options object.
	     * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
	     * @example
	     *
	     * function capitalize(string) {
	     *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
	     * }
	     *
	     * _.mixin({ 'capitalize': capitalize });
	     * _.capitalize('fred');
	     * // => 'Fred'
	     *
	     * _('fred').capitalize().value();
	     * // => 'Fred'
	     *
	     * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
	     * _('fred').capitalize();
	     * // => 'Fred'
	     */
	    function mixin(object, source, options) {
	      var chain = true,
	          methodNames = source && functions(source);
	
	      if (!source || (!options && !methodNames.length)) {
	        if (options == null) {
	          options = source;
	        }
	        ctor = lodashWrapper;
	        source = object;
	        object = lodash;
	        methodNames = functions(source);
	      }
	      if (options === false) {
	        chain = false;
	      } else if (isObject(options) && 'chain' in options) {
	        chain = options.chain;
	      }
	      var ctor = object,
	          isFunc = isFunction(ctor);
	
	      forEach(methodNames, function(methodName) {
	        var func = object[methodName] = source[methodName];
	        if (isFunc) {
	          ctor.prototype[methodName] = function() {
	            var chainAll = this.__chain__,
	                value = this.__wrapped__,
	                args = [value];
	
	            push.apply(args, arguments);
	            var result = func.apply(object, args);
	            if (chain || chainAll) {
	              if (value === result && isObject(result)) {
	                return this;
	              }
	              result = new ctor(result);
	              result.__chain__ = chainAll;
	            }
	            return result;
	          };
	        }
	      });
	    }
	
	    /**
	     * Reverts the '_' variable to its previous value and returns a reference to
	     * the `lodash` function.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @returns {Function} Returns the `lodash` function.
	     * @example
	     *
	     * var lodash = _.noConflict();
	     */
	    function noConflict() {
	      context._ = oldDash;
	      return this;
	    }
	
	    /**
	     * A no-operation function.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @example
	     *
	     * var object = { 'name': 'fred' };
	     * _.noop(object) === undefined;
	     * // => true
	     */
	    function noop() {
	      // no operation performed
	    }
	
	    /**
	     * Gets the number of milliseconds that have elapsed since the Unix epoch
	     * (1 January 1970 00:00:00 UTC).
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @example
	     *
	     * var stamp = _.now();
	     * _.defer(function() { console.log(_.now() - stamp); });
	     * // => logs the number of milliseconds it took for the deferred function to be called
	     */
	    var now = isNative(now = Date.now) && now || function() {
	      return new Date().getTime();
	    };
	
	    /**
	     * Converts the given value into an integer of the specified radix.
	     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the
	     * `value` is a hexadecimal, in which case a `radix` of `16` is used.
	     *
	     * Note: This method avoids differences in native ES3 and ES5 `parseInt`
	     * implementations. See http://es5.github.io/#E.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {string} value The value to parse.
	     * @param {number} [radix] The radix used to interpret the value to parse.
	     * @returns {number} Returns the new integer value.
	     * @example
	     *
	     * _.parseInt('08');
	     * // => 8
	     */
	    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {
	      // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`
	      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
	    };
	
	    /**
	     * Creates a "_.pluck" style function, which returns the `key` value of a
	     * given object.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {string} key The name of the property to retrieve.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var characters = [
	     *   { 'name': 'fred',   'age': 40 },
	     *   { 'name': 'barney', 'age': 36 }
	     * ];
	     *
	     * var getName = _.property('name');
	     *
	     * _.map(characters, getName);
	     * // => ['barney', 'fred']
	     *
	     * _.sortBy(characters, getName);
	     * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
	     */
	    function property(key) {
	      return function(object) {
	        return object[key];
	      };
	    }
	
	    /**
	     * Produces a random number between `min` and `max` (inclusive). If only one
	     * argument is provided a number between `0` and the given number will be
	     * returned. If `floating` is truey or either `min` or `max` are floats a
	     * floating-point number will be returned instead of an integer.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {number} [min=0] The minimum possible value.
	     * @param {number} [max=1] The maximum possible value.
	     * @param {boolean} [floating=false] Specify returning a floating-point number.
	     * @returns {number} Returns a random number.
	     * @example
	     *
	     * _.random(0, 5);
	     * // => an integer between 0 and 5
	     *
	     * _.random(5);
	     * // => also an integer between 0 and 5
	     *
	     * _.random(5, true);
	     * // => a floating-point number between 0 and 5
	     *
	     * _.random(1.2, 5.2);
	     * // => a floating-point number between 1.2 and 5.2
	     */
	    function random(min, max, floating) {
	      var noMin = min == null,
	          noMax = max == null;
	
	      if (floating == null) {
	        if (typeof min == 'boolean' && noMax) {
	          floating = min;
	          min = 1;
	        }
	        else if (!noMax && typeof max == 'boolean') {
	          floating = max;
	          noMax = true;
	        }
	      }
	      if (noMin && noMax) {
	        max = 1;
	      }
	      min = +min || 0;
	      if (noMax) {
	        max = min;
	        min = 0;
	      } else {
	        max = +max || 0;
	      }
	      if (floating || min % 1 || max % 1) {
	        var rand = nativeRandom();
	        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1)))), max);
	      }
	      return baseRandom(min, max);
	    }
	
	    /**
	     * Resolves the value of property `key` on `object`. If `key` is a function
	     * it will be invoked with the `this` binding of `object` and its result returned,
	     * else the property value is returned. If `object` is falsey then `undefined`
	     * is returned.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {Object} object The object to inspect.
	     * @param {string} key The name of the property to resolve.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = {
	     *   'cheese': 'crumpets',
	     *   'stuff': function() {
	     *     return 'nonsense';
	     *   }
	     * };
	     *
	     * _.result(object, 'cheese');
	     * // => 'crumpets'
	     *
	     * _.result(object, 'stuff');
	     * // => 'nonsense'
	     */
	    function result(object, key) {
	      if (object) {
	        var value = object[key];
	        return isFunction(value) ? object[key]() : value;
	      }
	    }
	
	    /**
	     * A micro-templating method that handles arbitrary delimiters, preserves
	     * whitespace, and correctly escapes quotes within interpolated code.
	     *
	     * Note: In the development build, `_.template` utilizes sourceURLs for easier
	     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
	     *
	     * For more information on precompiling templates see:
	     * http://lodash.com/custom-builds
	     *
	     * For more information on Chrome extension sandboxes see:
	     * http://developer.chrome.com/stable/extensions/sandboxingEval.html
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {string} text The template text.
	     * @param {Object} data The data object used to populate the text.
	     * @param {Object} [options] The options object.
	     * @param {RegExp} [options.escape] The "escape" delimiter.
	     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
	     * @param {Object} [options.imports] An object to import into the template as local variables.
	     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
	     * @param {string} [sourceURL] The sourceURL of the template's compiled source.
	     * @param {string} [variable] The data object variable name.
	     * @returns {Function|string} Returns a compiled function when no `data` object
	     *  is given, else it returns the interpolated text.
	     * @example
	     *
	     * // using the "interpolate" delimiter to create a compiled template
	     * var compiled = _.template('hello <%= name %>');
	     * compiled({ 'name': 'fred' });
	     * // => 'hello fred'
	     *
	     * // using the "escape" delimiter to escape HTML in data property values
	     * _.template('<b><%- value %></b>', { 'value': '<script>' });
	     * // => '<b>&lt;script&gt;</b>'
	     *
	     * // using the "evaluate" delimiter to generate HTML
	     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
	     * _.template(list, { 'people': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
	     * _.template('hello ${ name }', { 'name': 'pebbles' });
	     * // => 'hello pebbles'
	     *
	     * // using the internal `print` function in "evaluate" delimiters
	     * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
	     * // => 'hello barney!'
	     *
	     * // using a custom template delimiters
	     * _.templateSettings = {
	     *   'interpolate': /{{([\s\S]+?)}}/g
	     * };
	     *
	     * _.template('hello {{ name }}!', { 'name': 'mustache' });
	     * // => 'hello mustache!'
	     *
	     * // using the `imports` option to import jQuery
	     * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
	     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // using the `sourceURL` option to specify a custom sourceURL for the template
	     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
	     * compiled(data);
	     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
	     *
	     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
	     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
	     * compiled.source;
	     * // => function(data) {
	     *   var __t, __p = '', __e = _.escape;
	     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
	     *   return __p;
	     * }
	     *
	     * // using the `source` property to inline compiled templates for meaningful
	     * // line numbers in error messages and a stack trace
	     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
	     *   var JST = {\
	     *     "main": ' + _.template(mainText).source + '\
	     *   };\
	     * ');
	     */
	    function template(text, data, options) {
	      // based on John Resig's `tmpl` implementation
	      // http://ejohn.org/blog/javascript-micro-templating/
	      // and Laura Doktorova's doT.js
	      // https://github.com/olado/doT
	      var settings = lodash.templateSettings;
	      text = String(text || '');
	
	      // avoid missing dependencies when `iteratorTemplate` is not defined
	      options = defaults({}, options, settings);
	
	      var imports = defaults({}, options.imports, settings.imports),
	          importsKeys = keys(imports),
	          importsValues = values(imports);
	
	      var isEvaluating,
	          index = 0,
	          interpolate = options.interpolate || reNoMatch,
	          source = "__p += '";
	
	      // compile the regexp to match each delimiter
	      var reDelimiters = RegExp(
	        (options.escape || reNoMatch).source + '|' +
	        interpolate.source + '|' +
	        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
	        (options.evaluate || reNoMatch).source + '|$'
	      , 'g');
	
	      text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
	        interpolateValue || (interpolateValue = esTemplateValue);
	
	        // escape characters that cannot be included in string literals
	        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);
	
	        // replace delimiters with snippets
	        if (escapeValue) {
	          source += "' +\n__e(" + escapeValue + ") +\n'";
	        }
	        if (evaluateValue) {
	          isEvaluating = true;
	          source += "';\n" + evaluateValue + ";\n__p += '";
	        }
	        if (interpolateValue) {
	          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
	        }
	        index = offset + match.length;
	
	        // the JS engine embedded in Adobe products requires returning the `match`
	        // string in order to produce the correct `offset` value
	        return match;
	      });
	
	      source += "';\n";
	
	      // if `variable` is not specified, wrap a with-statement around the generated
	      // code to add the data object to the top of the scope chain
	      var variable = options.variable,
	          hasVariable = variable;
	
	      if (!hasVariable) {
	        variable = 'obj';
	        source = 'with (' + variable + ') {\n' + source + '\n}\n';
	      }
	      // cleanup code by stripping empty strings
	      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
	        .replace(reEmptyStringMiddle, '$1')
	        .replace(reEmptyStringTrailing, '$1;');
	
	      // frame code as the function body
	      source = 'function(' + variable + ') {\n' +
	        (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
	        "var __t, __p = '', __e = _.escape" +
	        (isEvaluating
	          ? ', __j = Array.prototype.join;\n' +
	            "function print() { __p += __j.call(arguments, '') }\n"
	          : ';\n'
	        ) +
	        source +
	        'return __p\n}';
	
	      // Use a sourceURL for easier debugging.
	      // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
	      var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';
	
	      try {
	        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
	      } catch(e) {
	        e.source = source;
	        throw e;
	      }
	      if (data) {
	        return result(data);
	      }
	      // provide the compiled function's source by its `toString` method, in
	      // supported environments, or the `source` property as a convenience for
	      // inlining compiled templates during the build process
	      result.source = source;
	      return result;
	    }
	
	    /**
	     * Executes the callback `n` times, returning an array of the results
	     * of each callback execution. The callback is bound to `thisArg` and invoked
	     * with one argument; (index).
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {number} n The number of times to execute the callback.
	     * @param {Function} callback The function called per iteration.
	     * @param {*} [thisArg] The `this` binding of `callback`.
	     * @returns {Array} Returns an array of the results of each `callback` execution.
	     * @example
	     *
	     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
	     * // => [3, 6, 4]
	     *
	     * _.times(3, function(n) { mage.castSpell(n); });
	     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
	     *
	     * _.times(3, function(n) { this.cast(n); }, mage);
	     * // => also calls `mage.castSpell(n)` three times
	     */
	    function times(n, callback, thisArg) {
	      n = (n = +n) > -1 ? n : 0;
	      var index = -1,
	          result = Array(n);
	
	      callback = baseCreateCallback(callback, thisArg, 1);
	      while (++index < n) {
	        result[index] = callback(index);
	      }
	      return result;
	    }
	
	    /**
	     * The inverse of `_.escape` this method converts the HTML entities
	     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
	     * corresponding characters.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {string} string The string to unescape.
	     * @returns {string} Returns the unescaped string.
	     * @example
	     *
	     * _.unescape('Fred, Barney &amp; Pebbles');
	     * // => 'Fred, Barney & Pebbles'
	     */
	    function unescape(string) {
	      return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
	    }
	
	    /**
	     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
	     *
	     * @static
	     * @memberOf _
	     * @category Utilities
	     * @param {string} [prefix] The value to prefix the ID with.
	     * @returns {string} Returns the unique ID.
	     * @example
	     *
	     * _.uniqueId('contact_');
	     * // => 'contact_104'
	     *
	     * _.uniqueId();
	     * // => '105'
	     */
	    function uniqueId(prefix) {
	      var id = ++idCounter;
	      return String(prefix == null ? '' : prefix) + id;
	    }
	
	    /*--------------------------------------------------------------------------*/
	
	    /**
	     * Creates a `lodash` object that wraps the given value with explicit
	     * method chaining enabled.
	     *
	     * @static
	     * @memberOf _
	     * @category Chaining
	     * @param {*} value The value to wrap.
	     * @returns {Object} Returns the wrapper object.
	     * @example
	     *
	     * var characters = [
	     *   { 'name': 'barney',  'age': 36 },
	     *   { 'name': 'fred',    'age': 40 },
	     *   { 'name': 'pebbles', 'age': 1 }
	     * ];
	     *
	     * var youngest = _.chain(characters)
	     *     .sortBy('age')
	     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
	     *     .first()
	     *     .value();
	     * // => 'pebbles is 1'
	     */
	    function chain(value) {
	      value = new lodashWrapper(value);
	      value.__chain__ = true;
	      return value;
	    }
	
	    /**
	     * Invokes `interceptor` with the `value` as the first argument and then
	     * returns `value`. The purpose of this method is to "tap into" a method
	     * chain in order to perform operations on intermediate results within
	     * the chain.
	     *
	     * @static
	     * @memberOf _
	     * @category Chaining
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * _([1, 2, 3, 4])
	     *  .tap(function(array) { array.pop(); })
	     *  .reverse()
	     *  .value();
	     * // => [3, 2, 1]
	     */
	    function tap(value, interceptor) {
	      interceptor(value);
	      return value;
	    }
	
	    /**
	     * Enables explicit method chaining on the wrapper object.
	     *
	     * @name chain
	     * @memberOf _
	     * @category Chaining
	     * @returns {*} Returns the wrapper object.
	     * @example
	     *
	     * var characters = [
	     *   { 'name': 'barney', 'age': 36 },
	     *   { 'name': 'fred',   'age': 40 }
	     * ];
	     *
	     * // without explicit chaining
	     * _(characters).first();
	     * // => { 'name': 'barney', 'age': 36 }
	     *
	     * // with explicit chaining
	     * _(characters).chain()
	     *   .first()
	     *   .pick('age')
	     *   .value();
	     * // => { 'age': 36 }
	     */
	    function wrapperChain() {
	      this.__chain__ = true;
	      return this;
	    }
	
	    /**
	     * Produces the `toString` result of the wrapped value.
	     *
	     * @name toString
	     * @memberOf _
	     * @category Chaining
	     * @returns {string} Returns the string result.
	     * @example
	     *
	     * _([1, 2, 3]).toString();
	     * // => '1,2,3'
	     */
	    function wrapperToString() {
	      return String(this.__wrapped__);
	    }
	
	    /**
	     * Extracts the wrapped value.
	     *
	     * @name valueOf
	     * @memberOf _
	     * @alias value
	     * @category Chaining
	     * @returns {*} Returns the wrapped value.
	     * @example
	     *
	     * _([1, 2, 3]).valueOf();
	     * // => [1, 2, 3]
	     */
	    function wrapperValueOf() {
	      return this.__wrapped__;
	    }
	
	    /*--------------------------------------------------------------------------*/
	
	    // add functions that return wrapped values when chaining
	    lodash.after = after;
	    lodash.assign = assign;
	    lodash.at = at;
	    lodash.bind = bind;
	    lodash.bindAll = bindAll;
	    lodash.bindKey = bindKey;
	    lodash.chain = chain;
	    lodash.compact = compact;
	    lodash.compose = compose;
	    lodash.constant = constant;
	    lodash.countBy = countBy;
	    lodash.create = create;
	    lodash.createCallback = createCallback;
	    lodash.curry = curry;
	    lodash.debounce = debounce;
	    lodash.defaults = defaults;
	    lodash.defer = defer;
	    lodash.delay = delay;
	    lodash.difference = difference;
	    lodash.filter = filter;
	    lodash.flatten = flatten;
	    lodash.forEach = forEach;
	    lodash.forEachRight = forEachRight;
	    lodash.forIn = forIn;
	    lodash.forInRight = forInRight;
	    lodash.forOwn = forOwn;
	    lodash.forOwnRight = forOwnRight;
	    lodash.functions = functions;
	    lodash.groupBy = groupBy;
	    lodash.indexBy = indexBy;
	    lodash.initial = initial;
	    lodash.intersection = intersection;
	    lodash.invert = invert;
	    lodash.invoke = invoke;
	    lodash.keys = keys;
	    lodash.map = map;
	    lodash.mapValues = mapValues;
	    lodash.max = max;
	    lodash.memoize = memoize;
	    lodash.merge = merge;
	    lodash.min = min;
	    lodash.omit = omit;
	    lodash.once = once;
	    lodash.pairs = pairs;
	    lodash.partial = partial;
	    lodash.partialRight = partialRight;
	    lodash.pick = pick;
	    lodash.pluck = pluck;
	    lodash.property = property;
	    lodash.pull = pull;
	    lodash.range = range;
	    lodash.reject = reject;
	    lodash.remove = remove;
	    lodash.rest = rest;
	    lodash.shuffle = shuffle;
	    lodash.sortBy = sortBy;
	    lodash.tap = tap;
	    lodash.throttle = throttle;
	    lodash.times = times;
	    lodash.toArray = toArray;
	    lodash.transform = transform;
	    lodash.union = union;
	    lodash.uniq = uniq;
	    lodash.values = values;
	    lodash.where = where;
	    lodash.without = without;
	    lodash.wrap = wrap;
	    lodash.xor = xor;
	    lodash.zip = zip;
	    lodash.zipObject = zipObject;
	
	    // add aliases
	    lodash.collect = map;
	    lodash.drop = rest;
	    lodash.each = forEach;
	    lodash.eachRight = forEachRight;
	    lodash.extend = assign;
	    lodash.methods = functions;
	    lodash.object = zipObject;
	    lodash.select = filter;
	    lodash.tail = rest;
	    lodash.unique = uniq;
	    lodash.unzip = zip;
	
	    // add functions to `lodash.prototype`
	    mixin(lodash);
	
	    /*--------------------------------------------------------------------------*/
	
	    // add functions that return unwrapped values when chaining
	    lodash.clone = clone;
	    lodash.cloneDeep = cloneDeep;
	    lodash.contains = contains;
	    lodash.escape = escape;
	    lodash.every = every;
	    lodash.find = find;
	    lodash.findIndex = findIndex;
	    lodash.findKey = findKey;
	    lodash.findLast = findLast;
	    lodash.findLastIndex = findLastIndex;
	    lodash.findLastKey = findLastKey;
	    lodash.has = has;
	    lodash.identity = identity;
	    lodash.indexOf = indexOf;
	    lodash.isArguments = isArguments;
	    lodash.isArray = isArray;
	    lodash.isBoolean = isBoolean;
	    lodash.isDate = isDate;
	    lodash.isElement = isElement;
	    lodash.isEmpty = isEmpty;
	    lodash.isEqual = isEqual;
	    lodash.isFinite = isFinite;
	    lodash.isFunction = isFunction;
	    lodash.isNaN = isNaN;
	    lodash.isNull = isNull;
	    lodash.isNumber = isNumber;
	    lodash.isObject = isObject;
	    lodash.isPlainObject = isPlainObject;
	    lodash.isRegExp = isRegExp;
	    lodash.isString = isString;
	    lodash.isUndefined = isUndefined;
	    lodash.lastIndexOf = lastIndexOf;
	    lodash.mixin = mixin;
	    lodash.noConflict = noConflict;
	    lodash.noop = noop;
	    lodash.now = now;
	    lodash.parseInt = parseInt;
	    lodash.random = random;
	    lodash.reduce = reduce;
	    lodash.reduceRight = reduceRight;
	    lodash.result = result;
	    lodash.runInContext = runInContext;
	    lodash.size = size;
	    lodash.some = some;
	    lodash.sortedIndex = sortedIndex;
	    lodash.template = template;
	    lodash.unescape = unescape;
	    lodash.uniqueId = uniqueId;
	
	    // add aliases
	    lodash.all = every;
	    lodash.any = some;
	    lodash.detect = find;
	    lodash.findWhere = find;
	    lodash.foldl = reduce;
	    lodash.foldr = reduceRight;
	    lodash.include = contains;
	    lodash.inject = reduce;
	
	    mixin(function() {
	      var source = {}
	      forOwn(lodash, function(func, methodName) {
	        if (!lodash.prototype[methodName]) {
	          source[methodName] = func;
	        }
	      });
	      return source;
	    }(), false);
	
	    /*--------------------------------------------------------------------------*/
	
	    // add functions capable of returning wrapped and unwrapped values when chaining
	    lodash.first = first;
	    lodash.last = last;
	    lodash.sample = sample;
	
	    // add aliases
	    lodash.take = first;
	    lodash.head = first;
	
	    forOwn(lodash, function(func, methodName) {
	      var callbackable = methodName !== 'sample';
	      if (!lodash.prototype[methodName]) {
	        lodash.prototype[methodName]= function(n, guard) {
	          var chainAll = this.__chain__,
	              result = func(this.__wrapped__, n, guard);
	
	          return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))
	            ? result
	            : new lodashWrapper(result, chainAll);
	        };
	      }
	    });
	
	    /*--------------------------------------------------------------------------*/
	
	    /**
	     * The semantic version number.
	     *
	     * @static
	     * @memberOf _
	     * @type string
	     */
	    lodash.VERSION = '2.4.1';
	
	    // add "Chaining" functions to the wrapper
	    lodash.prototype.chain = wrapperChain;
	    lodash.prototype.toString = wrapperToString;
	    lodash.prototype.value = wrapperValueOf;
	    lodash.prototype.valueOf = wrapperValueOf;
	
	    // add `Array` functions that return unwrapped values
	    baseEach(['join', 'pop', 'shift'], function(methodName) {
	      var func = arrayRef[methodName];
	      lodash.prototype[methodName] = function() {
	        var chainAll = this.__chain__,
	            result = func.apply(this.__wrapped__, arguments);
	
	        return chainAll
	          ? new lodashWrapper(result, chainAll)
	          : result;
	      };
	    });
	
	    // add `Array` functions that return the existing wrapped value
	    baseEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
	      var func = arrayRef[methodName];
	      lodash.prototype[methodName] = function() {
	        func.apply(this.__wrapped__, arguments);
	        return this;
	      };
	    });
	
	    // add `Array` functions that return new wrapped values
	    baseEach(['concat', 'slice', 'splice'], function(methodName) {
	      var func = arrayRef[methodName];
	      lodash.prototype[methodName] = function() {
	        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
	      };
	    });
	
	    // avoid array-like object bugs with `Array#shift` and `Array#splice`
	    // in IE < 9, Firefox < 10, Narwhal, and RingoJS
	    if (!support.spliceObjects) {
	      baseEach(['pop', 'shift', 'splice'], function(methodName) {
	        var func = arrayRef[methodName],
	            isSplice = methodName == 'splice';
	
	        lodash.prototype[methodName] = function() {
	          var chainAll = this.__chain__,
	              value = this.__wrapped__,
	              result = func.apply(value, arguments);
	
	          if (value.length === 0) {
	            delete value[0];
	          }
	          return (chainAll || isSplice)
	            ? new lodashWrapper(result, chainAll)
	            : result;
	        };
	      });
	    }
	
	    return lodash;
	  }
	
	  /*--------------------------------------------------------------------------*/
	
	  // expose Lo-Dash
	  var _ = runInContext();
	
	  // some AMD build optimizers like r.js check for condition patterns like the following:
	  if (true) {
	    // Expose Lo-Dash to the global object even when an AMD loader is present in
	    // case Lo-Dash is loaded with a RequireJS shim config.
	    // See http://requirejs.org/docs/api.html#config-shim
	    root._ = _;
	
	    // define as an anonymous module so, through path mapping, it can be
	    // referenced as the "underscore" module
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return _;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	  // check for `exports` after `define` in case a build optimizer adds an `exports` object
	  else if (freeExports && freeModule) {
	    // in Node.js or RingoJS
	    if (moduleExports) {
	      (freeModule.exports = _)._ = _;
	    }
	    // in Narwhal or Rhino -require
	    else {
	      freeExports._ = _;
	    }
	  }
	  else {
	    // in a browser or Rhino
	    root._ = _;
	  }
	}.call(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)(module), (function() { return this; }())))

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var
	    home = __webpack_require__(13),
	    editor = __webpack_require__(11);
	
	module.exports = {
	    "": {
	        template: __webpack_require__(17),
	        model: home
	    },
	    editor: {
	        template: __webpack_require__(16),
	        model: editor
	    },
	    dog: {
	        template: "home",
	        model: {
	            title: "Test Title 2",
	            body: "WOOOOOOOOOOOOOOOOOOOOOOOooooooooooooooooooooooooooooWWWWWWWWWWWWWWWWoooooooooooooooo"
	        }
	    }
	};

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Toastr
	 * Copyright 2012-2014 John Papa and Hans Fjllemark.
	 * All Rights Reserved.
	 * Use, reproduction, distribution, and modification of this code is subject to the terms and
	 * conditions of the MIT license, available at http://www.opensource.org/licenses/mit-license.php
	 *
	 * Author: John Papa and Hans Fjllemark
	 * ARIA Support: Greta Krafsig
	 * Project: https://github.com/CodeSeven/toastr
	 */
	; (function (define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(8)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($) {
	        return (function () {
	            var $container;
	            var listener;
	            var toastId = 0;
	            var toastType = {
	                error: 'error',
	                info: 'info',
	                success: 'success',
	                warning: 'warning'
	            };
	
	            var toastr = {
	                clear: clear,
	                remove: remove,
	                error: error,
	                getContainer: getContainer,
	                info: info,
	                options: {},
	                subscribe: subscribe,
	                success: success,
	                version: '2.0.3',
	                warning: warning
	            };
	
	            return toastr;
	
	            //#region Accessible Methods
	            function error(message, title, optionsOverride) {
	                return notify({
	                    type: toastType.error,
	                    iconClass: getOptions().iconClasses.error,
	                    message: message,
	                    optionsOverride: optionsOverride,
	                    title: title
	                });
	            }
	
	            function getContainer(options, create) {
	                if (!options) { options = getOptions(); }
	                $container = $('#' + options.containerId);
	                if ($container.length) {
	                    return $container;
	                }
	                if(create) {
	                    $container = createContainer(options);
	                }
	                return $container;
	            }
	
	            function info(message, title, optionsOverride) {
	                return notify({
	                    type: toastType.info,
	                    iconClass: getOptions().iconClasses.info,
	                    message: message,
	                    optionsOverride: optionsOverride,
	                    title: title
	                });
	            }
	
	            function subscribe(callback) {
	                listener = callback;
	            }
	
	            function success(message, title, optionsOverride) {
	                return notify({
	                    type: toastType.success,
	                    iconClass: getOptions().iconClasses.success,
	                    message: message,
	                    optionsOverride: optionsOverride,
	                    title: title
	                });
	            }
	
	            function warning(message, title, optionsOverride) {
	                return notify({
	                    type: toastType.warning,
	                    iconClass: getOptions().iconClasses.warning,
	                    message: message,
	                    optionsOverride: optionsOverride,
	                    title: title
	                });
	            }
	
	            function clear($toastElement) {
	                var options = getOptions();
	                if (!$container) { getContainer(options); }
	                if (!clearToast($toastElement, options)) {
	                    clearContainer(options);
	                }
	            }
	
	            function remove($toastElement) {
	                var options = getOptions();
	                if (!$container) { getContainer(options); }
	                if ($toastElement && $(':focus', $toastElement).length === 0) {
	                    removeToast($toastElement);
	                    return;
	                }
	                if ($container.children().length) {
	                    $container.remove();
	                }
	            }
	            //#endregion
	
	            //#region Internal Methods
	
	            function clearContainer(options){
	                var toastsToClear = $container.children();
	                for (var i = toastsToClear.length - 1; i >= 0; i--) {
	                    clearToast($(toastsToClear[i]), options);
	                };
	            }
	
	            function clearToast($toastElement, options){
	                if ($toastElement && $(':focus', $toastElement).length === 0) {
	                    $toastElement[options.hideMethod]({
	                        duration: options.hideDuration,
	                        easing: options.hideEasing,
	                        complete: function () { removeToast($toastElement); }
	                    });
	                    return true;
	                }
	                return false;
	            }
	
	            function createContainer(options) {
	                $container = $('<div/>')
	                    .attr('id', options.containerId)
	                    .addClass(options.positionClass)
	                    .attr('aria-live', 'polite')
	                    .attr('role', 'alert');
	
	                $container.appendTo($(options.target));
	                return $container;
	            }
	
	            function getDefaults() {
	                return {
	                    tapToDismiss: true,
	                    toastClass: 'toast',
	                    containerId: 'toast-container',
	                    debug: false,
	
	                    showMethod: 'fadeIn', //fadeIn, slideDown, and show are built into jQuery
	                    showDuration: 300,
	                    showEasing: 'swing', //swing and linear are built into jQuery
	                    onShown: undefined,
	                    hideMethod: 'fadeOut',
	                    hideDuration: 1000,
	                    hideEasing: 'swing',
	                    onHidden: undefined,
	
	                    extendedTimeOut: 1000,
	                    iconClasses: {
	                        error: 'toast-error',
	                        info: 'toast-info',
	                        success: 'toast-success',
	                        warning: 'toast-warning'
	                    },
	                    iconClass: 'toast-info',
	                    positionClass: 'toast-top-right',
	                    timeOut: 5000, // Set timeOut and extendedTimeout to 0 to make it sticky
	                    titleClass: 'toast-title',
	                    messageClass: 'toast-message',
	                    target: 'body',
	                    closeHtml: '<button>&times;</button>',
	                    newestOnTop: true
	                };
	            }
	
	            function publish(args) {
	                if (!listener) { return; }
	                listener(args);
	            }
	
	            function notify(map) {
	                var options = getOptions(),
	                    iconClass = map.iconClass || options.iconClass;
	
	                if (typeof (map.optionsOverride) !== 'undefined') {
	                    options = $.extend(options, map.optionsOverride);
	                    iconClass = map.optionsOverride.iconClass || iconClass;
	                }
	
	                toastId++;
	
	                $container = getContainer(options, true);
	                var intervalId = null,
	                    $toastElement = $('<div/>'),
	                    $titleElement = $('<div/>'),
	                    $messageElement = $('<div/>'),
	                    $closeElement = $(options.closeHtml),
	                    response = {
	                        toastId: toastId,
	                        state: 'visible',
	                        startTime: new Date(),
	                        options: options,
	                        map: map
	                    };
	
	                if (map.iconClass) {
	                    $toastElement.addClass(options.toastClass).addClass(iconClass);
	                }
	
	                if (map.title) {
	                    $titleElement.append(map.title).addClass(options.titleClass);
	                    $toastElement.append($titleElement);
	                }
	
	                if (map.message) {
	                    $messageElement.append(map.message).addClass(options.messageClass);
	                    $toastElement.append($messageElement);
	                }
	
	                if (options.closeButton) {
	                    $closeElement.addClass('toast-close-button').attr("role", "button");
	                    $toastElement.prepend($closeElement);
	                }
	
	                $toastElement.hide();
	                if (options.newestOnTop) {
	                    $container.prepend($toastElement);
	                } else {
	                    $container.append($toastElement);
	                }
	
	
	                $toastElement[options.showMethod](
	                    { duration: options.showDuration, easing: options.showEasing, complete: options.onShown }
	                );
	
	                if (options.timeOut > 0) {
	                    intervalId = setTimeout(hideToast, options.timeOut);
	                }
	
	                $toastElement.hover(stickAround, delayedHideToast);
	                if (!options.onclick && options.tapToDismiss) {
	                    $toastElement.click(hideToast);
	                }
	
	                if (options.closeButton && $closeElement) {
	                    $closeElement.click(function (event) {
	                        if( event.stopPropagation ) {
	                            event.stopPropagation();
	                        } else if( event.cancelBubble !== undefined && event.cancelBubble !== true ) {
	                            event.cancelBubble = true;
	                        }
	                        hideToast(true);
	                    });
	                }
	
	                if (options.onclick) {
	                    $toastElement.click(function () {
	                        options.onclick();
	                        hideToast();
	                    });
	                }
	
	                publish(response);
	
	                if (options.debug && console) {
	                    console.log(response);
	                }
	
	                return $toastElement;
	
	                function hideToast(override) {
	                    if ($(':focus', $toastElement).length && !override) {
	                        return;
	                    }
	                    return $toastElement[options.hideMethod]({
	                        duration: options.hideDuration,
	                        easing: options.hideEasing,
	                        complete: function () {
	                            removeToast($toastElement);
	                            if (options.onHidden && response.state !== 'hidden') {
	                                options.onHidden();
	                            }
	                            response.state = 'hidden';
	                            response.endTime = new Date();
	                            publish(response);
	                        }
	                    });
	                }
	
	                function delayedHideToast() {
	                    if (options.timeOut > 0 || options.extendedTimeOut > 0) {
	                        intervalId = setTimeout(hideToast, options.extendedTimeOut);
	                    }
	                }
	
	                function stickAround() {
	                    clearTimeout(intervalId);
	                    $toastElement.stop(true, true)[options.showMethod](
	                        { duration: options.showDuration, easing: options.showEasing }
	                    );
	                }
	            }
	
	            function getOptions() {
	                return $.extend({}, getDefaults(), toastr.options);
	            }
	
	            function removeToast($toastElement) {
	                if (!$container) { $container = getContainer(); }
	                if ($toastElement.is(':visible')) {
	                    return;
	                }
	                $toastElement.remove();
	                $toastElement = null;
	                if ($container.children().length === 0) {
	                    $container.remove();
	                }
	            }
	            //#endregion
	
	        })();
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(__webpack_require__(12)));

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	if (typeof module === "object" && typeof module.exports === "object") module.exports = Lexer;
	
	Lexer.defunct = function (char) {
	    throw new Error("Unexpected character at index " + (this.index - 1) + ": " + char);
	};
	
	function Lexer(defunct) {
	    if (typeof defunct !== "function") defunct = Lexer.defunct;
	
	    var tokens = [];
	    var rules = [];
	    var remove = 0;
	    this.state = 0;
	    this.index = 0;
	    this.input = "";
	
	    this.addRule = function (pattern, action, start) {
	        var global = pattern.global;
	
	        if (!global) {
	            var flags = "g";
	            if (pattern.multiline) flags += "m";
	            if (pattern.ignoreCase) flags += "i";
	            pattern = new RegExp(pattern.source, flags);
	        }
	
	        if (Object.prototype.toString.call(start) !== "[object Array]") start = [0];
	
	        rules.push({
	            pattern: pattern,
	            global: global,
	            action: action,
	            start: start
	        });
	
	        return this;
	    };
	
	    this.setInput = function (input) {
	        remove = 0;
	        this.state = 0;
	        this.index = 0;
	        this.input = input;
	        return this;
	    };
	
	    this.lex = function () {
	        if (tokens.length) return tokens.shift();
	
	        this.reject = true;
	
	        while (this.index <= this.input.length) {
	            var matches = scan.call(this).splice(remove);
	            var index = this.index;
	
	            while (matches.length) {
	                if (this.reject) {
	                    var match = matches.shift();
	                    var result = match.result;
	                    var length = match.length;
	                    this.index += length;
	                    this.reject = false;
	                    remove++;
	
	                    var token = match.action.apply(this, result);
	                    if (this.reject) this.index = result.index;
	                    else if (typeof token !== "undefined") {
	                        switch (Object.prototype.toString.call(token)) {
	                        case "[object Array]":
	                            tokens = token.slice(1);
	                            token = token[0];
	                        default:
	                            if (length) remove = 0;
	                            return token;
	                        }
	                    }
	                } else break;
	            }
	
	            var input = this.input;
	
	            if (index < input.length) {
	                if (this.reject) {
	                    remove = 0;
	                    var token = defunct.call(this, input.charAt(this.index++));
	                    if (typeof token !== "undefined") {
	                        if (Object.prototype.toString.call(token) === "[object Array]") {
	                            tokens = token.slice(1);
	                            return token[0];
	                        } else return token;
	                    }
	                } else {
	                    if (this.index !== index) remove = 0;
	                    this.reject = true;
	                }
	            } else if (matches.length)
	                this.reject = true;
	            else break;
	        }
	    };
	
	    function scan() {
	        var matches = [];
	        var index = 0;
	
	        var state = this.state;
	        var lastIndex = this.index;
	        var input = this.input;
	
	        for (var i = 0, length = rules.length; i < length; i++) {
	            var rule = rules[i];
	            var start = rule.start;
	            var states = start.length;
	
	            if ((!states || start.indexOf(state) >= 0) ||
	                (state % 2 && states === 1 && !start[0])) {
	                var pattern = rule.pattern;
	                pattern.lastIndex = lastIndex;
	                var result = pattern.exec(input);
	
	                if (result && result.index === lastIndex) {
	                    var j = matches.push({
	                        result: result,
	                        action: rule.action,
	                        length: result[0].length
	                    });
	
	                    if (rule.global) index = j;
	
	                    while (--j > index) {
	                        var k = j - 1;
	
	                        if (matches[j].length > matches[k].length) {
	                            var temple = matches[j];
	                            matches[j] = matches[k];
	                            matches[k] = temple;
	                        }
	                    }
	                }
	            }
	        }
	
	        return matches;
	    }
	}


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
		ractive.js v0.6.1
		2014-10-25 - commit 3a576eb3 
	
		http://ractivejs.org
		http://twitter.com/RactiveJS
	
		Released under the MIT License.
	*/
	
	( function( global ) {
	
		'use strict';
	
		var noConflict = global.Ractive;
	
		/* config/defaults/options.js */
		var options = function() {
	
			var defaultOptions = {
				// render placement:
				el: void 0,
				append: false,
				// template:
				template: {
					v: 1,
					t: []
				},
				yield: null,
				// parse:
				preserveWhitespace: false,
				sanitize: false,
				stripComments: true,
				// data & binding:
				data: {},
				computed: {},
				magic: false,
				modifyArrays: true,
				adapt: [],
				isolated: false,
				twoway: true,
				lazy: false,
				// transitions:
				noIntro: false,
				transitionsEnabled: true,
				complete: void 0,
				// css:
				noCssTransform: false,
				// debug:
				debug: false
			};
			return defaultOptions;
		}();
	
		/* config/defaults/easing.js */
		var easing = {
			linear: function( pos ) {
				return pos;
			},
			easeIn: function( pos ) {
				return Math.pow( pos, 3 );
			},
			easeOut: function( pos ) {
				return Math.pow( pos - 1, 3 ) + 1;
			},
			easeInOut: function( pos ) {
				if ( ( pos /= 0.5 ) < 1 ) {
					return 0.5 * Math.pow( pos, 3 );
				}
				return 0.5 * ( Math.pow( pos - 2, 3 ) + 2 );
			}
		};
	
		/* circular.js */
		var circular = [];
	
		/* utils/hasOwnProperty.js */
		var hasOwn = Object.prototype.hasOwnProperty;
	
		/* utils/isArray.js */
		var isArray = function() {
	
			var toString = Object.prototype.toString;
			// thanks, http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/
			return function( thing ) {
				return toString.call( thing ) === '[object Array]';
			};
		}();
	
		/* utils/isObject.js */
		var isObject = function() {
	
			var toString = Object.prototype.toString;
			return function( thing ) {
				return thing && toString.call( thing ) === '[object Object]';
			};
		}();
	
		/* utils/isNumeric.js */
		var isNumeric = function( thing ) {
			return !isNaN( parseFloat( thing ) ) && isFinite( thing );
		};
	
		/* config/defaults/interpolators.js */
		var interpolators = function( circular, hasOwnProperty, isArray, isObject, isNumeric ) {
	
			var interpolators, interpolate, cssLengthPattern;
			circular.push( function() {
				interpolate = circular.interpolate;
			} );
			cssLengthPattern = /^([+-]?[0-9]+\.?(?:[0-9]+)?)(px|em|ex|%|in|cm|mm|pt|pc)$/;
			interpolators = {
				number: function( from, to ) {
					var delta;
					if ( !isNumeric( from ) || !isNumeric( to ) ) {
						return null;
					}
					from = +from;
					to = +to;
					delta = to - from;
					if ( !delta ) {
						return function() {
							return from;
						};
					}
					return function( t ) {
						return from + t * delta;
					};
				},
				array: function( from, to ) {
					var intermediate, interpolators, len, i;
					if ( !isArray( from ) || !isArray( to ) ) {
						return null;
					}
					intermediate = [];
					interpolators = [];
					i = len = Math.min( from.length, to.length );
					while ( i-- ) {
						interpolators[ i ] = interpolate( from[ i ], to[ i ] );
					}
					// surplus values - don't interpolate, but don't exclude them either
					for ( i = len; i < from.length; i += 1 ) {
						intermediate[ i ] = from[ i ];
					}
					for ( i = len; i < to.length; i += 1 ) {
						intermediate[ i ] = to[ i ];
					}
					return function( t ) {
						var i = len;
						while ( i-- ) {
							intermediate[ i ] = interpolators[ i ]( t );
						}
						return intermediate;
					};
				},
				object: function( from, to ) {
					var properties, len, interpolators, intermediate, prop;
					if ( !isObject( from ) || !isObject( to ) ) {
						return null;
					}
					properties = [];
					intermediate = {};
					interpolators = {};
					for ( prop in from ) {
						if ( hasOwnProperty.call( from, prop ) ) {
							if ( hasOwnProperty.call( to, prop ) ) {
								properties.push( prop );
								interpolators[ prop ] = interpolate( from[ prop ], to[ prop ] );
							} else {
								intermediate[ prop ] = from[ prop ];
							}
						}
					}
					for ( prop in to ) {
						if ( hasOwnProperty.call( to, prop ) && !hasOwnProperty.call( from, prop ) ) {
							intermediate[ prop ] = to[ prop ];
						}
					}
					len = properties.length;
					return function( t ) {
						var i = len,
							prop;
						while ( i-- ) {
							prop = properties[ i ];
							intermediate[ prop ] = interpolators[ prop ]( t );
						}
						return intermediate;
					};
				}
			};
			return interpolators;
		}( circular, hasOwn, isArray, isObject, isNumeric );
	
		/* config/svg.js */
		var svg = function() {
	
			var svg;
			if ( typeof document === 'undefined' ) {
				svg = false;
			} else {
				svg = document && document.implementation.hasFeature( 'http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1' );
			}
			return svg;
		}();
	
		/* utils/warn.js */
		var warn = function() {
	
			/* global console */
			var warn, warned = {};
			if ( typeof console !== 'undefined' && typeof console.warn === 'function' && typeof console.warn.apply === 'function' ) {
				warn = function( message, allowDuplicates ) {
					if ( !allowDuplicates ) {
						if ( warned[ message ] ) {
							return;
						}
						warned[ message ] = true;
					}
					console.warn( '%cRactive.js: %c' + message, 'color: rgb(114, 157, 52);', 'color: rgb(85, 85, 85);' );
				};
			} else {
				warn = function() {};
			}
			return warn;
		}();
	
		/* config/errors.js */
		var errors = {
			missingParser: 'Missing Ractive.parse - cannot parse template. Either preparse or use the version that includes the parser',
			mergeComparisonFail: 'Merge operation: comparison failed. Falling back to identity checking',
			noComponentEventArguments: 'Components currently only support simple events - you cannot include arguments. Sorry!',
			noTemplateForPartial: 'Could not find template for partial "{name}"',
			noNestedPartials: 'Partials ({{>{name}}}) cannot contain nested inline partials',
			evaluationError: 'Error evaluating "{uniqueString}": {err}',
			badArguments: 'Bad arguments "{arguments}". I\'m not allowed to argue unless you\'ve paid.',
			failedComputation: 'Failed to compute "{key}": {err}',
			missingPlugin: 'Missing "{name}" {plugin} plugin. You may need to download a {plugin} via http://docs.ractivejs.org/latest/plugins#{plugin}s',
			badRadioInputBinding: 'A radio input can have two-way binding on its name attribute, or its checked attribute - not both',
			noRegistryFunctionReturn: 'A function was specified for "{name}" {registry}, but no {registry} was returned',
			defaultElSpecified: 'The <{name}/> component has a default `el` property; it has been disregarded',
			noElementProxyEventWildcards: 'Only component proxy-events may contain "*" wildcards, <{element} on-{event}/> is not valid.',
			methodDeprecated: 'The method "{deprecated}" has been deprecated in favor of "{replacement}" and will likely be removed in a future release. See http://docs.ractivejs.org/latest/migrating for more information.'
		};
	
		/* utils/log.js */
		var log = function( consolewarn, errors ) {
	
			var log = {
				warn: function( options, passthru ) {
					if ( !options.debug && !passthru ) {
						return;
					}
					this.warnAlways( options );
				},
				warnAlways: function( options ) {
					this.logger( getMessage( options ), options.allowDuplicates );
				},
				error: function( options ) {
					this.errorOnly( options );
					if ( !options.debug ) {
						this.warn( options, true );
					}
				},
				errorOnly: function( options ) {
					if ( options.debug ) {
						this.critical( options );
					}
				},
				critical: function( options ) {
					var err = options.err || new Error( getMessage( options ) );
					this.thrower( err );
				},
				logger: consolewarn,
				thrower: function( err ) {
					throw err;
				}
			};
	
			function getMessage( options ) {
				var message = errors[ options.message ] || options.message || '';
				return interpolate( message, options.args );
			}
			// simple interpolation. probably quicker (and better) out there,
			// but log is not in golden path of execution, only exceptions
			function interpolate( message, args ) {
				return message.replace( /{([^{}]*)}/g, function( a, b ) {
					return args[ b ];
				} );
			}
			return log;
		}( warn, errors );
	
		/* Ractive/prototype/shared/hooks/Hook.js */
		var Ractive$shared_hooks_Hook = function( log ) {
	
			var deprecations = {
				construct: {
					deprecated: 'beforeInit',
					replacement: 'onconstruct'
				},
				render: {
					deprecated: 'init',
					message: 'The "init" method has been deprecated ' + 'and will likely be removed in a future release. ' + 'You can either use the "oninit" method which will fire ' + 'only once prior to, and regardless of, any eventual ractive ' + 'instance being rendered, or if you need to access the ' + 'rendered DOM, use "onrender" instead. ' + 'See http://docs.ractivejs.org/latest/migrating for more information.'
				},
				complete: {
					deprecated: 'complete',
					replacement: 'oncomplete'
				}
			};
	
			function Hook( event ) {
				this.event = event;
				this.method = 'on' + event;
				this.deprecate = deprecations[ event ];
			}
			Hook.prototype.fire = function( ractive, arg ) {
				function call( method ) {
					if ( ractive[ method ] ) {
						arg ? ractive[ method ]( arg ) : ractive[ method ]();
						return true;
					}
				}
				call( this.method );
				if ( !ractive[ this.method ] && this.deprecate && call( this.deprecate.deprecated ) ) {
					log.warnAlways( {
						debug: ractive.debug,
						message: this.deprecate.message || 'methodDeprecated',
						args: this.deprecate
					} );
				}
				arg ? ractive.fire( this.event, arg ) : ractive.fire( this.event );
			};
			return Hook;
		}( log );
	
		/* utils/removeFromArray.js */
		var removeFromArray = function( array, member ) {
			var index = array.indexOf( member );
			if ( index !== -1 ) {
				array.splice( index, 1 );
			}
		};
	
		/* utils/Promise.js */
		var Promise = function() {
	
			var __export;
			var _Promise, PENDING = {},
				FULFILLED = {},
				REJECTED = {};
			if ( typeof Promise === 'function' ) {
				// use native Promise
				_Promise = Promise;
			} else {
				_Promise = function( callback ) {
					var fulfilledHandlers = [],
						rejectedHandlers = [],
						state = PENDING,
						result, dispatchHandlers, makeResolver, fulfil, reject, promise;
					makeResolver = function( newState ) {
						return function( value ) {
							if ( state !== PENDING ) {
								return;
							}
							result = value;
							state = newState;
							dispatchHandlers = makeDispatcher( state === FULFILLED ? fulfilledHandlers : rejectedHandlers, result );
							// dispatch onFulfilled and onRejected handlers asynchronously
							wait( dispatchHandlers );
						};
					};
					fulfil = makeResolver( FULFILLED );
					reject = makeResolver( REJECTED );
					try {
						callback( fulfil, reject );
					} catch ( err ) {
						reject( err );
					}
					promise = {
						// `then()` returns a Promise - 2.2.7
						then: function( onFulfilled, onRejected ) {
							var promise2 = new _Promise( function( fulfil, reject ) {
								var processResolutionHandler = function( handler, handlers, forward ) {
									// 2.2.1.1
									if ( typeof handler === 'function' ) {
										handlers.push( function( p1result ) {
											var x;
											try {
												x = handler( p1result );
												resolve( promise2, x, fulfil, reject );
											} catch ( err ) {
												reject( err );
											}
										} );
									} else {
										// Forward the result of promise1 to promise2, if resolution handlers
										// are not given
										handlers.push( forward );
									}
								};
								// 2.2
								processResolutionHandler( onFulfilled, fulfilledHandlers, fulfil );
								processResolutionHandler( onRejected, rejectedHandlers, reject );
								if ( state !== PENDING ) {
									// If the promise has resolved already, dispatch the appropriate handlers asynchronously
									wait( dispatchHandlers );
								}
							} );
							return promise2;
						}
					};
					promise[ 'catch' ] = function( onRejected ) {
						return this.then( null, onRejected );
					};
					return promise;
				};
				_Promise.all = function( promises ) {
					return new _Promise( function( fulfil, reject ) {
						var result = [],
							pending, i, processPromise;
						if ( !promises.length ) {
							fulfil( result );
							return;
						}
						processPromise = function( i ) {
							promises[ i ].then( function( value ) {
								result[ i ] = value;
								if ( !--pending ) {
									fulfil( result );
								}
							}, reject );
						};
						pending = i = promises.length;
						while ( i-- ) {
							processPromise( i );
						}
					} );
				};
				_Promise.resolve = function( value ) {
					return new _Promise( function( fulfil ) {
						fulfil( value );
					} );
				};
				_Promise.reject = function( reason ) {
					return new _Promise( function( fulfil, reject ) {
						reject( reason );
					} );
				};
			}
			__export = _Promise;
			// TODO use MutationObservers or something to simulate setImmediate
			function wait( callback ) {
				setTimeout( callback, 0 );
			}
	
			function makeDispatcher( handlers, result ) {
				return function() {
					var handler;
					while ( handler = handlers.shift() ) {
						handler( result );
					}
				};
			}
	
			function resolve( promise, x, fulfil, reject ) {
				// Promise Resolution Procedure
				var then;
				// 2.3.1
				if ( x === promise ) {
					throw new TypeError( 'A promise\'s fulfillment handler cannot return the same promise' );
				}
				// 2.3.2
				if ( x instanceof _Promise ) {
					x.then( fulfil, reject );
				} else if ( x && ( typeof x === 'object' || typeof x === 'function' ) ) {
					try {
						then = x.then;
					} catch ( e ) {
						reject( e );
						// 2.3.3.2
						return;
					}
					// 2.3.3.3
					if ( typeof then === 'function' ) {
						var called, resolvePromise, rejectPromise;
						resolvePromise = function( y ) {
							if ( called ) {
								return;
							}
							called = true;
							resolve( promise, y, fulfil, reject );
						};
						rejectPromise = function( r ) {
							if ( called ) {
								return;
							}
							called = true;
							reject( r );
						};
						try {
							then.call( x, resolvePromise, rejectPromise );
						} catch ( e ) {
							if ( !called ) {
								// 2.3.3.3.4.1
								reject( e );
								// 2.3.3.3.4.2
								called = true;
								return;
							}
						}
					} else {
						fulfil( x );
					}
				} else {
					fulfil( x );
				}
			}
			return __export;
		}();
	
		/* utils/normaliseRef.js */
		var normaliseRef = function() {
	
			var regex = /\[\s*(\*|[0-9]|[1-9][0-9]+)\s*\]/g;
			return function normaliseRef( ref ) {
				return ( ref || '' ).replace( regex, '.$1' );
			};
		}();
	
		/* shared/getInnerContext.js */
		var getInnerContext = function( fragment ) {
			do {
				if ( fragment.context !== undefined ) {
					return fragment.context;
				}
			} while ( fragment = fragment.parent );
			return '';
		};
	
		/* utils/isEqual.js */
		var isEqual = function( a, b ) {
			if ( a === null && b === null ) {
				return true;
			}
			if ( typeof a === 'object' || typeof b === 'object' ) {
				return false;
			}
			return a === b;
		};
	
		/* shared/createComponentBinding.js */
		var createComponentBinding = function( circular, isEqual ) {
	
			var runloop;
			circular.push( function() {
				return runloop = circular.runloop;
			} );
			var Binding = function( ractive, keypath, otherInstance, otherKeypath ) {
				var this$0 = this;
				this.root = ractive;
				this.keypath = keypath;
				this.otherInstance = otherInstance;
				this.otherKeypath = otherKeypath;
				this.lock = function() {
					return this$0.updating = true;
				};
				this.unlock = function() {
					return this$0.updating = false;
				};
				this.bind();
				this.value = this.root.viewmodel.get( this.keypath );
			};
			Binding.prototype = {
				isLocked: function() {
					return this.updating || this.counterpart && this.counterpart.updating;
				},
				shuffle: function( newIndices, value ) {
					this.propagateChange( value, newIndices );
				},
				setValue: function( value ) {
					this.propagateChange( value );
				},
				propagateChange: function( value, newIndices ) {
					var other;
					// Only *you* can prevent infinite loops
					if ( this.isLocked() ) {
						this.value = value;
						return;
					}
					if ( !isEqual( value, this.value ) ) {
						this.lock();
						// TODO maybe the case that `value === this.value` - should that result
						// in an update rather than a set?
						// if the other viewmodel is already locked up, need to do a deferred update
						if ( !runloop.addViewmodel( other = this.otherInstance.viewmodel ) && this.counterpart.value !== value ) {
							runloop.scheduleTask( function() {
								return runloop.addViewmodel( other );
							} );
						}
						if ( newIndices ) {
							other.smartUpdate( this.otherKeypath, value, newIndices );
						} else {
							if ( isSettable( other, this.otherKeypath ) ) {
								other.set( this.otherKeypath, value );
							}
						}
						this.value = value;
						// TODO will the counterpart update after this line, during
						// the runloop end cycle? may be a problem...
						runloop.scheduleTask( this.unlock );
					}
				},
				refineValue: function( keypaths ) {
					var this$0 = this;
					var other;
					if ( this.isLocked() ) {
						return;
					}
					this.lock();
					runloop.addViewmodel( other = this.otherInstance.viewmodel );
					keypaths.map( function( keypath ) {
						return this$0.otherKeypath + keypath.substr( this$0.keypath.length );
					} ).forEach( function( keypath ) {
						return other.mark( keypath );
					} );
					runloop.scheduleTask( this.unlock );
				},
				bind: function() {
					this.root.viewmodel.register( this.keypath, this );
				},
				rebind: function( newKeypath ) {
					this.unbind();
					this.keypath = newKeypath;
					this.counterpart.otherKeypath = newKeypath;
					this.bind();
				},
				unbind: function() {
					this.root.viewmodel.unregister( this.keypath, this );
				}
			};
	
			function isSettable( viewmodel, keypath ) {
				var computed = viewmodel.computations[ keypath ];
				return !computed || computed.setter;
			}
			return function createComponentBinding( component, parentInstance, parentKeypath, childKeypath ) {
				var hash, childInstance, bindings, parentToChildBinding, childToParentBinding;
				hash = parentKeypath + '=' + childKeypath;
				bindings = component.bindings;
				if ( bindings[ hash ] ) {
					// TODO does this ever happen?
					return;
				}
				childInstance = component.instance;
				parentToChildBinding = new Binding( parentInstance, parentKeypath, childInstance, childKeypath );
				bindings.push( parentToChildBinding );
				if ( childInstance.twoway ) {
					childToParentBinding = new Binding( childInstance, childKeypath, parentInstance, parentKeypath );
					bindings.push( childToParentBinding );
					parentToChildBinding.counterpart = childToParentBinding;
					childToParentBinding.counterpart = parentToChildBinding;
				}
				bindings[ hash ] = parentToChildBinding;
			};
		}( circular, isEqual );
	
		/* shared/resolveRef.js */
		var resolveRef = function( normaliseRef, getInnerContext, createComponentBinding ) {
	
			var __export;
			var ancestorErrorMessage, getOptions;
			ancestorErrorMessage = 'Could not resolve reference - too many "../" prefixes';
			getOptions = {
				evaluateWrapped: true
			};
			__export = function resolveRef( ractive, ref, fragment, isParentLookup ) {
				var context, key, index, keypath, parentValue, hasContextChain, parentKeys, childKeys, parentKeypath, childKeypath;
				ref = normaliseRef( ref );
				// If a reference begins '~/', it's a top-level reference
				if ( ref.substr( 0, 2 ) === '~/' ) {
					return ref.substring( 2 );
				}
				// If a reference begins with '.', it's either a restricted reference or
				// an ancestor reference...
				if ( ref.charAt( 0 ) === '.' ) {
					return resolveAncestorReference( getInnerContext( fragment ), ref );
				}
				// ...otherwise we need to find the keypath
				key = ref.split( '.' )[ 0 ];
				// get() in viewmodel creation means no fragment (yet)
				fragment = fragment || {};
				do {
					context = fragment.context;
					if ( !context ) {
						continue;
					}
					hasContextChain = true;
					parentValue = ractive.viewmodel.get( context, getOptions );
					if ( parentValue && ( typeof parentValue === 'object' || typeof parentValue === 'function' ) && key in parentValue ) {
						return context + '.' + ref;
					}
				} while ( fragment = fragment.parent );
				// Root/computed property?
				if ( key in ractive.data || key in ractive.viewmodel.computations ) {
					return ref;
				}
				// If this is an inline component, and it's not isolated, we
				// can try going up the scope chain
				if ( ractive._parent && !ractive.isolated ) {
					hasContextChain = true;
					fragment = ractive.component.parentFragment;
					// Special case - index refs
					if ( fragment.indexRefs && ( index = fragment.indexRefs[ ref ] ) !== undefined ) {
						// Create an index ref binding, so that it can be rebound letter if necessary.
						// It doesn't have an alias since it's an implicit binding, hence `...[ ref ] = ref`
						ractive.component.indexRefBindings[ ref ] = ref;
						ractive.viewmodel.set( ref, index, true );
						return;
					}
					keypath = resolveRef( ractive._parent, ref, fragment, true );
					if ( keypath ) {
						// We need to create an inter-component binding
						// If parent keypath is 'one.foo' and child is 'two.foo', we bind
						// 'one' to 'two' as it's more efficient and avoids edge cases
						parentKeys = keypath.split( '.' );
						childKeys = ref.split( '.' );
						while ( parentKeys.length > 1 && childKeys.length > 1 && parentKeys[ parentKeys.length - 1 ] === childKeys[ childKeys.length - 1 ] ) {
							parentKeys.pop();
							childKeys.pop();
						}
						parentKeypath = parentKeys.join( '.' );
						childKeypath = childKeys.join( '.' );
						ractive.viewmodel.set( childKeypath, ractive._parent.viewmodel.get( parentKeypath ), true );
						createComponentBinding( ractive.component, ractive._parent, parentKeypath, childKeypath );
						return ref;
					}
				}
				// If there's no context chain, and the instance is either a) isolated or
				// b) an orphan, then we know that the keypath is identical to the reference
				if ( !isParentLookup && !hasContextChain ) {
					// the data object needs to have a property by this name,
					// to prevent future failed lookups
					ractive.viewmodel.set( ref, undefined );
					return ref;
				}
				if ( ractive.viewmodel.get( ref ) !== undefined ) {
					return ref;
				}
			};
	
			function resolveAncestorReference( baseContext, ref ) {
				var contextKeys;
				// {{.}} means 'current context'
				if ( ref === '.' )
					return baseContext;
				contextKeys = baseContext ? baseContext.split( '.' ) : [];
				// ancestor references (starting "../") go up the tree
				if ( ref.substr( 0, 3 ) === '../' ) {
					while ( ref.substr( 0, 3 ) === '../' ) {
						if ( !contextKeys.length ) {
							throw new Error( ancestorErrorMessage );
						}
						contextKeys.pop();
						ref = ref.substring( 3 );
					}
					contextKeys.push( ref );
					return contextKeys.join( '.' );
				}
				// not an ancestor reference - must be a restricted reference (prepended with "." or "./")
				if ( !baseContext ) {
					return ref.replace( /^\.\/?/, '' );
				}
				return baseContext + ref.replace( /^\.\//, '.' );
			}
			return __export;
		}( normaliseRef, getInnerContext, createComponentBinding );
	
		/* global/TransitionManager.js */
		var TransitionManager = function( removeFromArray ) {
	
			var TransitionManager = function( callback, parent ) {
				this.callback = callback;
				this.parent = parent;
				this.intros = [];
				this.outros = [];
				this.children = [];
				this.totalChildren = this.outroChildren = 0;
				this.detachQueue = [];
				this.outrosComplete = false;
				if ( parent ) {
					parent.addChild( this );
				}
			};
			TransitionManager.prototype = {
				addChild: function( child ) {
					this.children.push( child );
					this.totalChildren += 1;
					this.outroChildren += 1;
				},
				decrementOutros: function() {
					this.outroChildren -= 1;
					check( this );
				},
				decrementTotal: function() {
					this.totalChildren -= 1;
					check( this );
				},
				add: function( transition ) {
					var list = transition.isIntro ? this.intros : this.outros;
					list.push( transition );
				},
				remove: function( transition ) {
					var list = transition.isIntro ? this.intros : this.outros;
					removeFromArray( list, transition );
					check( this );
				},
				init: function() {
					this.ready = true;
					check( this );
				},
				detachNodes: function() {
					this.detachQueue.forEach( detach );
					this.children.forEach( detachNodes );
				}
			};
	
			function detach( element ) {
				element.detach();
			}
	
			function detachNodes( tm ) {
				tm.detachNodes();
			}
	
			function check( tm ) {
				if ( !tm.ready || tm.outros.length || tm.outroChildren )
					return;
				// If all outros are complete, and we haven't already done this,
				// we notify the parent if there is one, otherwise
				// start detaching nodes
				if ( !tm.outrosComplete ) {
					if ( tm.parent ) {
						tm.parent.decrementOutros( tm );
					} else {
						tm.detachNodes();
					}
					tm.outrosComplete = true;
				}
				// Once everything is done, we can notify parent transition
				// manager and call the callback
				if ( !tm.intros.length && !tm.totalChildren ) {
					if ( typeof tm.callback === 'function' ) {
						tm.callback();
					}
					if ( tm.parent ) {
						tm.parent.decrementTotal();
					}
				}
			}
			return TransitionManager;
		}( removeFromArray );
	
		/* global/runloop.js */
		var runloop = function( circular, Hook, removeFromArray, Promise, resolveRef, TransitionManager ) {
	
			var __export;
			var batch, runloop, unresolved = [],
				changeHook = new Hook( 'change' );
			runloop = {
				start: function( instance, returnPromise ) {
					var promise, fulfilPromise;
					if ( returnPromise ) {
						promise = new Promise( function( f ) {
							return fulfilPromise = f;
						} );
					}
					batch = {
						previousBatch: batch,
						transitionManager: new TransitionManager( fulfilPromise, batch && batch.transitionManager ),
						views: [],
						tasks: [],
						viewmodels: [],
						instance: instance
					};
					if ( instance ) {
						batch.viewmodels.push( instance.viewmodel );
					}
					return promise;
				},
				end: function() {
					flushChanges();
					batch.transitionManager.init();
					if ( !batch.previousBatch && !!batch.instance )
						batch.instance.viewmodel.changes = [];
					batch = batch.previousBatch;
				},
				addViewmodel: function( viewmodel ) {
					if ( batch ) {
						if ( batch.viewmodels.indexOf( viewmodel ) === -1 ) {
							batch.viewmodels.push( viewmodel );
							return true;
						} else {
							return false;
						}
					} else {
						viewmodel.applyChanges();
						return false;
					}
				},
				registerTransition: function( transition ) {
					transition._manager = batch.transitionManager;
					batch.transitionManager.add( transition );
				},
				addView: function( view ) {
					batch.views.push( view );
				},
				addUnresolved: function( thing ) {
					unresolved.push( thing );
				},
				removeUnresolved: function( thing ) {
					removeFromArray( unresolved, thing );
				},
				// synchronise node detachments with transition ends
				detachWhenReady: function( thing ) {
					batch.transitionManager.detachQueue.push( thing );
				},
				scheduleTask: function( task, postRender ) {
					var _batch;
					if ( !batch ) {
						task();
					} else {
						_batch = batch;
						while ( postRender && _batch.previousBatch ) {
							// this can't happen until the DOM has been fully updated
							// otherwise in some situations (with components inside elements)
							// transitions and decorators will initialise prematurely
							_batch = _batch.previousBatch;
						}
						_batch.tasks.push( task );
					}
				}
			};
			circular.runloop = runloop;
			__export = runloop;
	
			function flushChanges() {
				var i, thing, changeHash;
				for ( i = 0; i < batch.viewmodels.length; i += 1 ) {
					thing = batch.viewmodels[ i ];
					changeHash = thing.applyChanges();
					if ( changeHash ) {
						changeHook.fire( thing.ractive, changeHash );
					}
				}
				batch.viewmodels.length = 0;
				attemptKeypathResolution();
				// Now that changes have been fully propagated, we can update the DOM
				// and complete other tasks
				for ( i = 0; i < batch.views.length; i += 1 ) {
					batch.views[ i ].update();
				}
				batch.views.length = 0;
				for ( i = 0; i < batch.tasks.length; i += 1 ) {
					batch.tasks[ i ]();
				}
				batch.tasks.length = 0;
				// If updating the view caused some model blowback - e.g. a triple
				// containing <option> elements caused the binding on the <select>
				// to update - then we start over
				if ( batch.viewmodels.length )
					return flushChanges();
			}
	
			function attemptKeypathResolution() {
				var i, item, keypath, resolved;
				i = unresolved.length;
				// see if we can resolve any unresolved references
				while ( i-- ) {
					item = unresolved[ i ];
					if ( item.keypath ) {
						// it resolved some other way. TODO how? two-way binding? Seems
						// weird that we'd still end up here
						unresolved.splice( i, 1 );
					}
					if ( keypath = resolveRef( item.root, item.ref, item.parentFragment ) ) {
						( resolved || ( resolved = [] ) ).push( {
							item: item,
							keypath: keypath
						} );
						unresolved.splice( i, 1 );
					}
				}
				if ( resolved ) {
					resolved.forEach( resolve );
				}
			}
	
			function resolve( resolved ) {
				resolved.item.resolve( resolved.keypath );
			}
			return __export;
		}( circular, Ractive$shared_hooks_Hook, removeFromArray, Promise, resolveRef, TransitionManager );
	
		/* utils/createBranch.js */
		var createBranch = function() {
	
			var numeric = /^\s*[0-9]+\s*$/;
			return function( key ) {
				return numeric.test( key ) ? [] : {};
			};
		}();
	
		/* viewmodel/prototype/get/magicAdaptor.js */
		var viewmodel$get_magicAdaptor = function( runloop, createBranch, isArray ) {
	
			var __export;
			var magicAdaptor, MagicWrapper;
			try {
				Object.defineProperty( {}, 'test', {
					value: 0
				} );
				magicAdaptor = {
					filter: function( object, keypath, ractive ) {
						var keys, key, parentKeypath, parentWrapper, parentValue;
						if ( !keypath ) {
							return false;
						}
						keys = keypath.split( '.' );
						key = keys.pop();
						parentKeypath = keys.join( '.' );
						// If the parent value is a wrapper, other than a magic wrapper,
						// we shouldn't wrap this property
						if ( ( parentWrapper = ractive.viewmodel.wrapped[ parentKeypath ] ) && !parentWrapper.magic ) {
							return false;
						}
						parentValue = ractive.get( parentKeypath );
						// if parentValue is an array that doesn't include this member,
						// we should return false otherwise lengths will get messed up
						if ( isArray( parentValue ) && /^[0-9]+$/.test( key ) ) {
							return false;
						}
						return parentValue && ( typeof parentValue === 'object' || typeof parentValue === 'function' );
					},
					wrap: function( ractive, property, keypath ) {
						return new MagicWrapper( ractive, property, keypath );
					}
				};
				MagicWrapper = function( ractive, value, keypath ) {
					var keys, objKeypath, template, siblings;
					this.magic = true;
					this.ractive = ractive;
					this.keypath = keypath;
					this.value = value;
					keys = keypath.split( '.' );
					this.prop = keys.pop();
					objKeypath = keys.join( '.' );
					this.obj = objKeypath ? ractive.get( objKeypath ) : ractive.data;
					template = this.originalDescriptor = Object.getOwnPropertyDescriptor( this.obj, this.prop );
					// Has this property already been wrapped?
					if ( template && template.set && ( siblings = template.set._ractiveWrappers ) ) {
						// Yes. Register this wrapper to this property, if it hasn't been already
						if ( siblings.indexOf( this ) === -1 ) {
							siblings.push( this );
						}
						return;
					}
					// No, it hasn't been wrapped
					createAccessors( this, value, template );
				};
				MagicWrapper.prototype = {
					get: function() {
						return this.value;
					},
					reset: function( value ) {
						if ( this.updating ) {
							return;
						}
						this.updating = true;
						this.obj[ this.prop ] = value;
						// trigger set() accessor
						runloop.addViewmodel( this.ractive.viewmodel );
						this.ractive.viewmodel.mark( this.keypath );
						this.updating = false;
					},
					set: function( key, value ) {
						if ( this.updating ) {
							return;
						}
						if ( !this.obj[ this.prop ] ) {
							this.updating = true;
							this.obj[ this.prop ] = createBranch( key );
							this.updating = false;
						}
						this.obj[ this.prop ][ key ] = value;
					},
					teardown: function() {
						var template, set, value, wrappers, index;
						// If this method was called because the cache was being cleared as a
						// result of a set()/update() call made by this wrapper, we return false
						// so that it doesn't get torn down
						if ( this.updating ) {
							return false;
						}
						template = Object.getOwnPropertyDescriptor( this.obj, this.prop );
						set = template && template.set;
						if ( !set ) {
							// most likely, this was an array member that was spliced out
							return;
						}
						wrappers = set._ractiveWrappers;
						index = wrappers.indexOf( this );
						if ( index !== -1 ) {
							wrappers.splice( index, 1 );
						}
						// Last one out, turn off the lights
						if ( !wrappers.length ) {
							value = this.obj[ this.prop ];
							Object.defineProperty( this.obj, this.prop, this.originalDescriptor || {
								writable: true,
								enumerable: true,
								configurable: true
							} );
							this.obj[ this.prop ] = value;
						}
					}
				};
			} catch ( err ) {
				magicAdaptor = false;
			}
			__export = magicAdaptor;
	
			function createAccessors( originalWrapper, value, template ) {
				var object, property, oldGet, oldSet, get, set;
				object = originalWrapper.obj;
				property = originalWrapper.prop;
				// Is this template configurable?
				if ( template && !template.configurable ) {
					// Special case - array length
					if ( property === 'length' ) {
						return;
					}
					throw new Error( 'Cannot use magic mode with property "' + property + '" - object is not configurable' );
				}
				// Time to wrap this property
				if ( template ) {
					oldGet = template.get;
					oldSet = template.set;
				}
				get = oldGet || function() {
					return value;
				};
				set = function( v ) {
					if ( oldSet ) {
						oldSet( v );
					}
					value = oldGet ? oldGet() : v;
					set._ractiveWrappers.forEach( updateWrapper );
				};
	
				function updateWrapper( wrapper ) {
					var keypath, ractive;
					wrapper.value = value;
					if ( wrapper.updating ) {
						return;
					}
					ractive = wrapper.ractive;
					keypath = wrapper.keypath;
					wrapper.updating = true;
					runloop.start( ractive );
					ractive.viewmodel.mark( keypath );
					runloop.end();
					wrapper.updating = false;
				}
				// Create an array of wrappers, in case other keypaths/ractives depend on this property.
				// Handily, we can store them as a property of the set function. Yay JavaScript.
				set._ractiveWrappers = [ originalWrapper ];
				Object.defineProperty( object, property, {
					get: get,
					set: set,
					enumerable: true,
					configurable: true
				} );
			}
			return __export;
		}( runloop, createBranch, isArray );
	
		/* config/magic.js */
		var magic = function( magicAdaptor ) {
	
			return !!magicAdaptor;
		}( viewmodel$get_magicAdaptor );
	
		/* config/namespaces.js */
		var namespaces = {
			html: 'http://www.w3.org/1999/xhtml',
			mathml: 'http://www.w3.org/1998/Math/MathML',
			svg: 'http://www.w3.org/2000/svg',
			xlink: 'http://www.w3.org/1999/xlink',
			xml: 'http://www.w3.org/XML/1998/namespace',
			xmlns: 'http://www.w3.org/2000/xmlns/'
		};
	
		/* utils/createElement.js */
		var createElement = function( svg, namespaces ) {
	
			var createElement;
			// Test for SVG support
			if ( !svg ) {
				createElement = function( type, ns ) {
					if ( ns && ns !== namespaces.html ) {
						throw 'This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you\'re trying to render SVG in an older browser. See http://docs.ractivejs.org/latest/svg-and-older-browsers for more information';
					}
					return document.createElement( type );
				};
			} else {
				createElement = function( type, ns ) {
					if ( !ns || ns === namespaces.html ) {
						return document.createElement( type );
					}
					return document.createElementNS( ns, type );
				};
			}
			return createElement;
		}( svg, namespaces );
	
		/* config/isClient.js */
		var isClient = function() {
	
			var isClient = typeof document === 'object';
			return isClient;
		}();
	
		/* utils/defineProperty.js */
		var defineProperty = function( isClient ) {
	
			var defineProperty;
			try {
				Object.defineProperty( {}, 'test', {
					value: 0
				} );
				if ( isClient ) {
					Object.defineProperty( document.createElement( 'div' ), 'test', {
						value: 0
					} );
				}
				defineProperty = Object.defineProperty;
			} catch ( err ) {
				// Object.defineProperty doesn't exist, or we're in IE8 where you can
				// only use it with DOM objects (what the fuck were you smoking, MSFT?)
				defineProperty = function( obj, prop, desc ) {
					obj[ prop ] = desc.value;
				};
			}
			return defineProperty;
		}( isClient );
	
		/* utils/defineProperties.js */
		var defineProperties = function( createElement, defineProperty, isClient ) {
	
			var defineProperties;
			try {
				try {
					Object.defineProperties( {}, {
						test: {
							value: 0
						}
					} );
				} catch ( err ) {
					// TODO how do we account for this? noMagic = true;
					throw err;
				}
				if ( isClient ) {
					Object.defineProperties( createElement( 'div' ), {
						test: {
							value: 0
						}
					} );
				}
				defineProperties = Object.defineProperties;
			} catch ( err ) {
				defineProperties = function( obj, props ) {
					var prop;
					for ( prop in props ) {
						if ( props.hasOwnProperty( prop ) ) {
							defineProperty( obj, prop, props[ prop ] );
						}
					}
				};
			}
			return defineProperties;
		}( createElement, defineProperty, isClient );
	
		/* Ractive/prototype/shared/add.js */
		var Ractive$shared_add = function( isNumeric ) {
	
			return function add( root, keypath, d ) {
				var value;
				if ( typeof keypath !== 'string' || !isNumeric( d ) ) {
					throw new Error( 'Bad arguments' );
				}
				value = +root.get( keypath ) || 0;
				if ( !isNumeric( value ) ) {
					throw new Error( 'Cannot add to a non-numeric value' );
				}
				return root.set( keypath, value + d );
			};
		}( isNumeric );
	
		/* Ractive/prototype/add.js */
		var Ractive$add = function( add ) {
	
			return function Ractive$add( keypath, d ) {
				return add( this, keypath, d === undefined ? 1 : +d );
			};
		}( Ractive$shared_add );
	
		/* utils/normaliseKeypath.js */
		var normaliseKeypath = function( normaliseRef ) {
	
			var leadingDot = /^\.+/;
			return function normaliseKeypath( keypath ) {
				return normaliseRef( keypath ).replace( leadingDot, '' );
			};
		}( normaliseRef );
	
		/* config/vendors.js */
		var vendors = [
			'o',
			'ms',
			'moz',
			'webkit'
		];
	
		/* utils/requestAnimationFrame.js */
		var requestAnimationFrame = function( vendors ) {
	
			var requestAnimationFrame;
			// If window doesn't exist, we don't need requestAnimationFrame
			if ( typeof window === 'undefined' ) {
				requestAnimationFrame = null;
			} else {
				// https://gist.github.com/paulirish/1579671
				( function( vendors, lastTime, window ) {
					var x, setTimeout;
					if ( window.requestAnimationFrame ) {
						return;
					}
					for ( x = 0; x < vendors.length && !window.requestAnimationFrame; ++x ) {
						window.requestAnimationFrame = window[ vendors[ x ] + 'RequestAnimationFrame' ];
					}
					if ( !window.requestAnimationFrame ) {
						setTimeout = window.setTimeout;
						window.requestAnimationFrame = function( callback ) {
							var currTime, timeToCall, id;
							currTime = Date.now();
							timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );
							id = setTimeout( function() {
								callback( currTime + timeToCall );
							}, timeToCall );
							lastTime = currTime + timeToCall;
							return id;
						};
					}
				}( vendors, 0, window ) );
				requestAnimationFrame = window.requestAnimationFrame;
			}
			return requestAnimationFrame;
		}( vendors );
	
		/* utils/getTime.js */
		var getTime = function() {
	
			var getTime;
			if ( typeof window !== 'undefined' && window.performance && typeof window.performance.now === 'function' ) {
				getTime = function() {
					return window.performance.now();
				};
			} else {
				getTime = function() {
					return Date.now();
				};
			}
			return getTime;
		}();
	
		/* shared/animations.js */
		var animations = function( rAF, getTime, runloop ) {
	
			var queue = [];
			var animations = {
				tick: function() {
					var i, animation, now;
					now = getTime();
					runloop.start();
					for ( i = 0; i < queue.length; i += 1 ) {
						animation = queue[ i ];
						if ( !animation.tick( now ) ) {
							// animation is complete, remove it from the stack, and decrement i so we don't miss one
							queue.splice( i--, 1 );
						}
					}
					runloop.end();
					if ( queue.length ) {
						rAF( animations.tick );
					} else {
						animations.running = false;
					}
				},
				add: function( animation ) {
					queue.push( animation );
					if ( !animations.running ) {
						animations.running = true;
						rAF( animations.tick );
					}
				},
				// TODO optimise this
				abort: function( keypath, root ) {
					var i = queue.length,
						animation;
					while ( i-- ) {
						animation = queue[ i ];
						if ( animation.root === root && animation.keypath === keypath ) {
							animation.stop();
						}
					}
				}
			};
			return animations;
		}( requestAnimationFrame, getTime, runloop );
	
		/* config/options/css/transform.js */
		var transform = function() {
	
			var __export;
			var selectorsPattern = /(?:^|\})?\s*([^\{\}]+)\s*\{/g,
				commentsPattern = /\/\*.*?\*\//g,
				selectorUnitPattern = /((?:(?:\[[^\]+]\])|(?:[^\s\+\>\~:]))+)((?::[^\s\+\>\~]+)?\s*[\s\+\>\~]?)\s*/g,
				mediaQueryPattern = /^@media/,
				dataRvcGuidPattern = /\[data-rvcguid="[a-z0-9-]+"]/g;
			__export = function transformCss( css, guid ) {
				var transformed, addGuid;
				addGuid = function( selector ) {
					var selectorUnits, match, unit, dataAttr, base, prepended, appended, i, transformed = [];
					selectorUnits = [];
					while ( match = selectorUnitPattern.exec( selector ) ) {
						selectorUnits.push( {
							str: match[ 0 ],
							base: match[ 1 ],
							modifiers: match[ 2 ]
						} );
					}
					// For each simple selector within the selector, we need to create a version
					// that a) combines with the guid, and b) is inside the guid
					dataAttr = '[data-rvcguid="' + guid + '"]';
					base = selectorUnits.map( extractString );
					i = selectorUnits.length;
					while ( i-- ) {
						appended = base.slice();
						// Pseudo-selectors should go after the attribute selector
						unit = selectorUnits[ i ];
						appended[ i ] = unit.base + dataAttr + unit.modifiers || '';
						prepended = base.slice();
						prepended[ i ] = dataAttr + ' ' + prepended[ i ];
						transformed.push( appended.join( ' ' ), prepended.join( ' ' ) );
					}
					return transformed.join( ', ' );
				};
				if ( dataRvcGuidPattern.test( css ) ) {
					transformed = css.replace( dataRvcGuidPattern, '[data-rvcguid="' + guid + '"]' );
				} else {
					transformed = css.replace( commentsPattern, '' ).replace( selectorsPattern, function( match, $1 ) {
						var selectors, transformed;
						// don't transform media queries!
						if ( mediaQueryPattern.test( $1 ) )
							return match;
						selectors = $1.split( ',' ).map( trim );
						transformed = selectors.map( addGuid ).join( ', ' ) + ' ';
						return match.replace( $1, transformed );
					} );
				}
				return transformed;
			};
	
			function trim( str ) {
				if ( str.trim ) {
					return str.trim();
				}
				return str.replace( /^\s+/, '' ).replace( /\s+$/, '' );
			}
	
			function extractString( unit ) {
				return unit.str;
			}
			return __export;
		}();
	
		/* config/options/css/css.js */
		var css = function( transformCss ) {
	
			var cssConfig = {
				name: 'css',
				extend: extend,
				init: function() {}
			};
	
			function extend( Parent, proto, options ) {
				var guid = proto.constructor._guid,
					css;
				if ( css = getCss( options.css, options, guid ) || getCss( Parent.css, Parent, guid ) ) {
					proto.constructor.css = css;
				}
			}
	
			function getCss( css, target, guid ) {
				if ( !css ) {
					return;
				}
				return target.noCssTransform ? css : transformCss( css, guid );
			}
			return cssConfig;
		}( transform );
	
		/* utils/wrapMethod.js */
		var wrapMethod = function() {
	
			var __export;
			__export = function( method, superMethod, force ) {
				if ( force || needsSuper( method, superMethod ) ) {
					return function() {
						var hasSuper = '_super' in this,
							_super = this._super,
							result;
						this._super = superMethod;
						result = method.apply( this, arguments );
						if ( hasSuper ) {
							this._super = _super;
						}
						return result;
					};
				} else {
					return method;
				}
			};
	
			function needsSuper( method, superMethod ) {
				return typeof superMethod === 'function' && /_super/.test( method );
			}
			return __export;
		}();
	
		/* config/options/data.js */
		var data = function( wrap ) {
	
			var __export;
			var dataConfig = {
				name: 'data',
				extend: extend,
				init: init,
				reset: reset
			};
			__export = dataConfig;
	
			function combine( Parent, target, options ) {
				var value = options.data || {},
					parentValue = getAddedKeys( Parent.prototype.data );
				if ( typeof value !== 'object' && typeof value !== 'function' ) {
					throw new TypeError( 'data option must be an object or a function, "' + value + '" is not valid' );
				}
				return dispatch( parentValue, value );
			}
	
			function extend( Parent, proto, options ) {
				proto.data = combine( Parent, proto, options );
			}
	
			function init( Parent, ractive, options ) {
				var value = options.data,
					result = combine( Parent, ractive, options );
				if ( typeof result === 'function' ) {
					result = result.call( ractive, value ) || value;
				}
				return ractive.data = result || {};
			}
	
			function reset( ractive ) {
				var result = this.init( ractive.constructor, ractive, ractive );
				if ( result ) {
					ractive.data = result;
					return true;
				}
			}
	
			function getAddedKeys( parent ) {
				// only for functions that had keys added
				if ( typeof parent !== 'function' || !Object.keys( parent ).length ) {
					return parent;
				}
				// copy the added keys to temp 'object', otherwise
				// parent would be interpreted as 'function' by dispatch
				var temp = {};
				copy( parent, temp );
				// roll in added keys
				return dispatch( parent, temp );
			}
	
			function dispatch( parent, child ) {
				if ( typeof child === 'function' ) {
					return extendFn( child, parent );
				} else if ( typeof parent === 'function' ) {
					return fromFn( child, parent );
				} else {
					return fromProperties( child, parent );
				}
			}
	
			function copy( from, to, fillOnly ) {
				for ( var key in from ) {
					if ( fillOnly && key in to ) {
						continue;
					}
					to[ key ] = from[ key ];
				}
			}
	
			function fromProperties( child, parent ) {
				child = child || {};
				if ( !parent ) {
					return child;
				}
				copy( parent, child, true );
				return child;
			}
	
			function fromFn( child, parentFn ) {
				return function( data ) {
					var keys;
					if ( child ) {
						// Track the keys that our on the child,
						// but not on the data. We'll need to apply these
						// after the parent function returns.
						keys = [];
						for ( var key in child ) {
							if ( !data || !( key in data ) ) {
								keys.push( key );
							}
						}
					}
					// call the parent fn, use data if no return value
					data = parentFn.call( this, data ) || data;
					// Copy child keys back onto data. The child keys
					// should take precedence over whatever the
					// parent did with the data.
					if ( keys && keys.length ) {
						data = data || {};
						keys.forEach( function( key ) {
							data[ key ] = child[ key ];
						} );
					}
					return data;
				};
			}
	
			function extendFn( childFn, parent ) {
				var parentFn;
				if ( typeof parent !== 'function' ) {
					// copy props to data
					parentFn = function( data ) {
						fromProperties( data, parent );
					};
				} else {
					parentFn = function( data ) {
						// give parent function it's own this._super context,
						// otherwise this._super is from child and
						// causes infinite loop
						parent = wrap( parent, function() {}, true );
						return parent.call( this, data ) || data;
					};
				}
				return wrap( childFn, parentFn );
			}
			return __export;
		}( wrapMethod );
	
		/* config/types.js */
		var types = {
			TEXT: 1,
			INTERPOLATOR: 2,
			TRIPLE: 3,
			SECTION: 4,
			INVERTED: 5,
			CLOSING: 6,
			ELEMENT: 7,
			PARTIAL: 8,
			COMMENT: 9,
			DELIMCHANGE: 10,
			MUSTACHE: 11,
			TAG: 12,
			ATTRIBUTE: 13,
			CLOSING_TAG: 14,
			COMPONENT: 15,
			NUMBER_LITERAL: 20,
			STRING_LITERAL: 21,
			ARRAY_LITERAL: 22,
			OBJECT_LITERAL: 23,
			BOOLEAN_LITERAL: 24,
			GLOBAL: 26,
			KEY_VALUE_PAIR: 27,
			REFERENCE: 30,
			REFINEMENT: 31,
			MEMBER: 32,
			PREFIX_OPERATOR: 33,
			BRACKETED: 34,
			CONDITIONAL: 35,
			INFIX_OPERATOR: 36,
			INVOCATION: 40,
			SECTION_IF: 50,
			SECTION_UNLESS: 51,
			SECTION_EACH: 52,
			SECTION_WITH: 53,
			SECTION_IF_WITH: 54
		};
	
		/* utils/create.js */
		var create = function() {
	
			var create;
			try {
				Object.create( null );
				create = Object.create;
			} catch ( err ) {
				// sigh
				create = function() {
					var F = function() {};
					return function( proto, props ) {
						var obj;
						if ( proto === null ) {
							return {};
						}
						F.prototype = proto;
						obj = new F();
						if ( props ) {
							Object.defineProperties( obj, props );
						}
						return obj;
					};
				}();
			}
			return create;
		}();
	
		/* parse/Parser/expressions/shared/errors.js */
		var parse_Parser_expressions_shared_errors = {
			expectedExpression: 'Expected a JavaScript expression',
			expectedParen: 'Expected closing paren'
		};
	
		/* parse/Parser/expressions/primary/literal/numberLiteral.js */
		var numberLiteral = function( types ) {
	
			var numberPattern = /^(?:[+-]?)(?:(?:(?:0|[1-9]\d*)?\.\d+)|(?:(?:0|[1-9]\d*)\.)|(?:0|[1-9]\d*))(?:[eE][+-]?\d+)?/;
			return function( parser ) {
				var result;
				if ( result = parser.matchPattern( numberPattern ) ) {
					return {
						t: types.NUMBER_LITERAL,
						v: result
					};
				}
				return null;
			};
		}( types );
	
		/* parse/Parser/expressions/primary/literal/booleanLiteral.js */
		var booleanLiteral = function( types ) {
	
			return function( parser ) {
				var remaining = parser.remaining();
				if ( remaining.substr( 0, 4 ) === 'true' ) {
					parser.pos += 4;
					return {
						t: types.BOOLEAN_LITERAL,
						v: 'true'
					};
				}
				if ( remaining.substr( 0, 5 ) === 'false' ) {
					parser.pos += 5;
					return {
						t: types.BOOLEAN_LITERAL,
						v: 'false'
					};
				}
				return null;
			};
		}( types );
	
		/* parse/Parser/expressions/primary/literal/stringLiteral/makeQuotedStringMatcher.js */
		var makeQuotedStringMatcher = function() {
	
			var stringMiddlePattern, escapeSequencePattern, lineContinuationPattern;
			// Match one or more characters until: ", ', \, or EOL/EOF.
			// EOL/EOF is written as (?!.) (meaning there's no non-newline char next).
			stringMiddlePattern = /^(?=.)[^"'\\]+?(?:(?!.)|(?=["'\\]))/;
			// Match one escape sequence, including the backslash.
			escapeSequencePattern = /^\\(?:['"\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;
			// Match one ES5 line continuation (backslash + line terminator).
			lineContinuationPattern = /^\\(?:\r\n|[\u000A\u000D\u2028\u2029])/;
			// Helper for defining getDoubleQuotedString and getSingleQuotedString.
			return function( okQuote ) {
				return function( parser ) {
					var start, literal, done, next;
					start = parser.pos;
					literal = '"';
					done = false;
					while ( !done ) {
						next = parser.matchPattern( stringMiddlePattern ) || parser.matchPattern( escapeSequencePattern ) || parser.matchString( okQuote );
						if ( next ) {
							if ( next === '"' ) {
								literal += '\\"';
							} else if ( next === '\\\'' ) {
								literal += '\'';
							} else {
								literal += next;
							}
						} else {
							next = parser.matchPattern( lineContinuationPattern );
							if ( next ) {
								// convert \(newline-like) into a \u escape, which is allowed in JSON
								literal += '\\u' + ( '000' + next.charCodeAt( 1 ).toString( 16 ) ).slice( -4 );
							} else {
								done = true;
							}
						}
					}
					literal += '"';
					// use JSON.parse to interpret escapes
					return JSON.parse( literal );
				};
			};
		}();
	
		/* parse/Parser/expressions/primary/literal/stringLiteral/singleQuotedString.js */
		var singleQuotedString = function( makeQuotedStringMatcher ) {
	
			return makeQuotedStringMatcher( '"' );
		}( makeQuotedStringMatcher );
	
		/* parse/Parser/expressions/primary/literal/stringLiteral/doubleQuotedString.js */
		var doubleQuotedString = function( makeQuotedStringMatcher ) {
	
			return makeQuotedStringMatcher( '\'' );
		}( makeQuotedStringMatcher );
	
		/* parse/Parser/expressions/primary/literal/stringLiteral/_stringLiteral.js */
		var stringLiteral = function( types, getSingleQuotedString, getDoubleQuotedString ) {
	
			return function( parser ) {
				var start, string;
				start = parser.pos;
				if ( parser.matchString( '"' ) ) {
					string = getDoubleQuotedString( parser );
					if ( !parser.matchString( '"' ) ) {
						parser.pos = start;
						return null;
					}
					return {
						t: types.STRING_LITERAL,
						v: string
					};
				}
				if ( parser.matchString( '\'' ) ) {
					string = getSingleQuotedString( parser );
					if ( !parser.matchString( '\'' ) ) {
						parser.pos = start;
						return null;
					}
					return {
						t: types.STRING_LITERAL,
						v: string
					};
				}
				return null;
			};
		}( types, singleQuotedString, doubleQuotedString );
	
		/* parse/Parser/expressions/shared/patterns.js */
		var patterns = {
			name: /^[a-zA-Z_$][a-zA-Z_$0-9]*/
		};
	
		/* parse/Parser/expressions/shared/key.js */
		var key = function( getStringLiteral, getNumberLiteral, patterns ) {
	
			var identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
			// http://mathiasbynens.be/notes/javascript-properties
			// can be any name, string literal, or number literal
			return function( parser ) {
				var token;
				if ( token = getStringLiteral( parser ) ) {
					return identifier.test( token.v ) ? token.v : '"' + token.v.replace( /"/g, '\\"' ) + '"';
				}
				if ( token = getNumberLiteral( parser ) ) {
					return token.v;
				}
				if ( token = parser.matchPattern( patterns.name ) ) {
					return token;
				}
			};
		}( stringLiteral, numberLiteral, patterns );
	
		/* parse/Parser/expressions/primary/literal/objectLiteral/keyValuePair.js */
		var keyValuePair = function( types, getKey ) {
	
			return function( parser ) {
				var start, key, value;
				start = parser.pos;
				// allow whitespace between '{' and key
				parser.allowWhitespace();
				key = getKey( parser );
				if ( key === null ) {
					parser.pos = start;
					return null;
				}
				// allow whitespace between key and ':'
				parser.allowWhitespace();
				// next character must be ':'
				if ( !parser.matchString( ':' ) ) {
					parser.pos = start;
					return null;
				}
				// allow whitespace between ':' and value
				parser.allowWhitespace();
				// next expression must be a, well... expression
				value = parser.readExpression();
				if ( value === null ) {
					parser.pos = start;
					return null;
				}
				return {
					t: types.KEY_VALUE_PAIR,
					k: key,
					v: value
				};
			};
		}( types, key );
	
		/* parse/Parser/expressions/primary/literal/objectLiteral/keyValuePairs.js */
		var keyValuePairs = function( getKeyValuePair ) {
	
			return function getKeyValuePairs( parser ) {
				var start, pairs, pair, keyValuePairs;
				start = parser.pos;
				pair = getKeyValuePair( parser );
				if ( pair === null ) {
					return null;
				}
				pairs = [ pair ];
				if ( parser.matchString( ',' ) ) {
					keyValuePairs = getKeyValuePairs( parser );
					if ( !keyValuePairs ) {
						parser.pos = start;
						return null;
					}
					return pairs.concat( keyValuePairs );
				}
				return pairs;
			};
		}( keyValuePair );
	
		/* parse/Parser/expressions/primary/literal/objectLiteral/_objectLiteral.js */
		var objectLiteral = function( types, getKeyValuePairs ) {
	
			return function( parser ) {
				var start, keyValuePairs;
				start = parser.pos;
				// allow whitespace
				parser.allowWhitespace();
				if ( !parser.matchString( '{' ) ) {
					parser.pos = start;
					return null;
				}
				keyValuePairs = getKeyValuePairs( parser );
				// allow whitespace between final value and '}'
				parser.allowWhitespace();
				if ( !parser.matchString( '}' ) ) {
					parser.pos = start;
					return null;
				}
				return {
					t: types.OBJECT_LITERAL,
					m: keyValuePairs
				};
			};
		}( types, keyValuePairs );
	
		/* parse/Parser/expressions/shared/expressionList.js */
		var expressionList = function( errors ) {
	
			return function getExpressionList( parser ) {
				var start, expressions, expr, next;
				start = parser.pos;
				parser.allowWhitespace();
				expr = parser.readExpression();
				if ( expr === null ) {
					return null;
				}
				expressions = [ expr ];
				// allow whitespace between expression and ','
				parser.allowWhitespace();
				if ( parser.matchString( ',' ) ) {
					next = getExpressionList( parser );
					if ( next === null ) {
						parser.error( errors.expectedExpression );
					}
					next.forEach( append );
				}
	
				function append( expression ) {
					expressions.push( expression );
				}
				return expressions;
			};
		}( parse_Parser_expressions_shared_errors );
	
		/* parse/Parser/expressions/primary/literal/arrayLiteral.js */
		var arrayLiteral = function( types, getExpressionList ) {
	
			return function( parser ) {
				var start, expressionList;
				start = parser.pos;
				// allow whitespace before '['
				parser.allowWhitespace();
				if ( !parser.matchString( '[' ) ) {
					parser.pos = start;
					return null;
				}
				expressionList = getExpressionList( parser );
				if ( !parser.matchString( ']' ) ) {
					parser.pos = start;
					return null;
				}
				return {
					t: types.ARRAY_LITERAL,
					m: expressionList
				};
			};
		}( types, expressionList );
	
		/* parse/Parser/expressions/primary/literal/_literal.js */
		var literal = function( getNumberLiteral, getBooleanLiteral, getStringLiteral, getObjectLiteral, getArrayLiteral ) {
	
			return function( parser ) {
				var literal = getNumberLiteral( parser ) || getBooleanLiteral( parser ) || getStringLiteral( parser ) || getObjectLiteral( parser ) || getArrayLiteral( parser );
				return literal;
			};
		}( numberLiteral, booleanLiteral, stringLiteral, objectLiteral, arrayLiteral );
	
		/* parse/Parser/expressions/primary/reference.js */
		var reference = function( types, patterns ) {
	
			var dotRefinementPattern, arrayMemberPattern, getArrayRefinement, globals, keywords;
			dotRefinementPattern = /^\.[a-zA-Z_$0-9]+/;
			getArrayRefinement = function( parser ) {
				var num = parser.matchPattern( arrayMemberPattern );
				if ( num ) {
					return '.' + num;
				}
				return null;
			};
			arrayMemberPattern = /^\[(0|[1-9][0-9]*)\]/;
			// if a reference is a browser global, we don't deference it later, so it needs special treatment
			globals = /^(?:Array|console|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null)$/;
			// keywords are not valid references, with the exception of `this`
			keywords = /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/;
			return function( parser ) {
				var startPos, ancestor, name, dot, combo, refinement, lastDotIndex;
				startPos = parser.pos;
				// we might have a root-level reference
				if ( parser.matchString( '~/' ) ) {
					ancestor = '~/';
				} else {
					// we might have ancestor refs...
					ancestor = '';
					while ( parser.matchString( '../' ) ) {
						ancestor += '../';
					}
				}
				if ( !ancestor ) {
					// we might have an implicit iterator or a restricted reference
					dot = parser.matchString( './' ) || parser.matchString( '.' ) || '';
				}
				name = parser.matchPattern( /^@(?:keypath|index|key)/ ) || parser.matchPattern( patterns.name ) || '';
				// bug out if it's a keyword
				if ( keywords.test( name ) ) {
					parser.pos = startPos;
					return null;
				}
				// if this is a browser global, stop here
				if ( !ancestor && !dot && globals.test( name ) ) {
					return {
						t: types.GLOBAL,
						v: name
					};
				}
				combo = ( ancestor || dot ) + name;
				if ( !combo ) {
					return null;
				}
				while ( refinement = parser.matchPattern( dotRefinementPattern ) || getArrayRefinement( parser ) ) {
					combo += refinement;
				}
				if ( parser.matchString( '(' ) ) {
					// if this is a method invocation (as opposed to a function) we need
					// to strip the method name from the reference combo, else the context
					// will be wrong
					lastDotIndex = combo.lastIndexOf( '.' );
					if ( lastDotIndex !== -1 ) {
						combo = combo.substr( 0, lastDotIndex );
						parser.pos = startPos + combo.length;
					} else {
						parser.pos -= 1;
					}
				}
				return {
					t: types.REFERENCE,
					n: combo.replace( /^this\./, './' ).replace( /^this$/, '.' )
				};
			};
		}( types, patterns );
	
		/* parse/Parser/expressions/primary/bracketedExpression.js */
		var bracketedExpression = function( types, errors ) {
	
			return function( parser ) {
				var start, expr;
				start = parser.pos;
				if ( !parser.matchString( '(' ) ) {
					return null;
				}
				parser.allowWhitespace();
				expr = parser.readExpression();
				if ( !expr ) {
					parser.error( errors.expectedExpression );
				}
				parser.allowWhitespace();
				if ( !parser.matchString( ')' ) ) {
					parser.error( errors.expectedParen );
				}
				return {
					t: types.BRACKETED,
					x: expr
				};
			};
		}( types, parse_Parser_expressions_shared_errors );
	
		/* parse/Parser/expressions/primary/_primary.js */
		var primary = function( getLiteral, getReference, getBracketedExpression ) {
	
			return function( parser ) {
				return getLiteral( parser ) || getReference( parser ) || getBracketedExpression( parser );
			};
		}( literal, reference, bracketedExpression );
	
		/* parse/Parser/expressions/shared/refinement.js */
		var refinement = function( types, errors, patterns ) {
	
			return function getRefinement( parser ) {
				var start, name, expr;
				start = parser.pos;
				parser.allowWhitespace();
				// "." name
				if ( parser.matchString( '.' ) ) {
					parser.allowWhitespace();
					if ( name = parser.matchPattern( patterns.name ) ) {
						return {
							t: types.REFINEMENT,
							n: name
						};
					}
					parser.error( 'Expected a property name' );
				}
				// "[" expression "]"
				if ( parser.matchString( '[' ) ) {
					parser.allowWhitespace();
					expr = parser.readExpression();
					if ( !expr ) {
						parser.error( errors.expectedExpression );
					}
					parser.allowWhitespace();
					if ( !parser.matchString( ']' ) ) {
						parser.error( 'Expected \']\'' );
					}
					return {
						t: types.REFINEMENT,
						x: expr
					};
				}
				return null;
			};
		}( types, parse_Parser_expressions_shared_errors, patterns );
	
		/* parse/Parser/expressions/memberOrInvocation.js */
		var memberOrInvocation = function( types, getPrimary, getExpressionList, getRefinement, errors ) {
	
			return function( parser ) {
				var current, expression, refinement, expressionList;
				expression = getPrimary( parser );
				if ( !expression ) {
					return null;
				}
				while ( expression ) {
					current = parser.pos;
					if ( refinement = getRefinement( parser ) ) {
						expression = {
							t: types.MEMBER,
							x: expression,
							r: refinement
						};
					} else if ( parser.matchString( '(' ) ) {
						parser.allowWhitespace();
						expressionList = getExpressionList( parser );
						parser.allowWhitespace();
						if ( !parser.matchString( ')' ) ) {
							parser.error( errors.expectedParen );
						}
						expression = {
							t: types.INVOCATION,
							x: expression
						};
						if ( expressionList ) {
							expression.o = expressionList;
						}
					} else {
						break;
					}
				}
				return expression;
			};
		}( types, primary, expressionList, refinement, parse_Parser_expressions_shared_errors );
	
		/* parse/Parser/expressions/typeof.js */
		var _typeof = function( types, errors, getMemberOrInvocation ) {
	
			var getTypeof, makePrefixSequenceMatcher;
			makePrefixSequenceMatcher = function( symbol, fallthrough ) {
				return function( parser ) {
					var expression;
					if ( expression = fallthrough( parser ) ) {
						return expression;
					}
					if ( !parser.matchString( symbol ) ) {
						return null;
					}
					parser.allowWhitespace();
					expression = parser.readExpression();
					if ( !expression ) {
						parser.error( errors.expectedExpression );
					}
					return {
						s: symbol,
						o: expression,
						t: types.PREFIX_OPERATOR
					};
				};
			};
			// create all prefix sequence matchers, return getTypeof
			( function() {
				var i, len, matcher, prefixOperators, fallthrough;
				prefixOperators = '! ~ + - typeof'.split( ' ' );
				fallthrough = getMemberOrInvocation;
				for ( i = 0, len = prefixOperators.length; i < len; i += 1 ) {
					matcher = makePrefixSequenceMatcher( prefixOperators[ i ], fallthrough );
					fallthrough = matcher;
				}
				// typeof operator is higher precedence than multiplication, so provides the
				// fallthrough for the multiplication sequence matcher we're about to create
				// (we're skipping void and delete)
				getTypeof = fallthrough;
			}() );
			return getTypeof;
		}( types, parse_Parser_expressions_shared_errors, memberOrInvocation );
	
		/* parse/Parser/expressions/logicalOr.js */
		var logicalOr = function( types, getTypeof ) {
	
			var getLogicalOr, makeInfixSequenceMatcher;
			makeInfixSequenceMatcher = function( symbol, fallthrough ) {
				return function( parser ) {
					var start, left, right;
					left = fallthrough( parser );
					if ( !left ) {
						return null;
					}
					// Loop to handle left-recursion in a case like `a * b * c` and produce
					// left association, i.e. `(a * b) * c`.  The matcher can't call itself
					// to parse `left` because that would be infinite regress.
					while ( true ) {
						start = parser.pos;
						parser.allowWhitespace();
						if ( !parser.matchString( symbol ) ) {
							parser.pos = start;
							return left;
						}
						// special case - in operator must not be followed by [a-zA-Z_$0-9]
						if ( symbol === 'in' && /[a-zA-Z_$0-9]/.test( parser.remaining().charAt( 0 ) ) ) {
							parser.pos = start;
							return left;
						}
						parser.allowWhitespace();
						// right operand must also consist of only higher-precedence operators
						right = fallthrough( parser );
						if ( !right ) {
							parser.pos = start;
							return left;
						}
						left = {
							t: types.INFIX_OPERATOR,
							s: symbol,
							o: [
								left,
								right
							]
						};
					}
				};
			};
			// create all infix sequence matchers, and return getLogicalOr
			( function() {
				var i, len, matcher, infixOperators, fallthrough;
				// All the infix operators on order of precedence (source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence)
				// Each sequence matcher will initially fall through to its higher precedence
				// neighbour, and only attempt to match if one of the higher precedence operators
				// (or, ultimately, a literal, reference, or bracketed expression) already matched
				infixOperators = '* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||'.split( ' ' );
				// A typeof operator is higher precedence than multiplication
				fallthrough = getTypeof;
				for ( i = 0, len = infixOperators.length; i < len; i += 1 ) {
					matcher = makeInfixSequenceMatcher( infixOperators[ i ], fallthrough );
					fallthrough = matcher;
				}
				// Logical OR is the fallthrough for the conditional matcher
				getLogicalOr = fallthrough;
			}() );
			return getLogicalOr;
		}( types, _typeof );
	
		/* parse/Parser/expressions/conditional.js */
		var conditional = function( types, getLogicalOr, errors ) {
	
			return function( parser ) {
				var start, expression, ifTrue, ifFalse;
				expression = getLogicalOr( parser );
				if ( !expression ) {
					return null;
				}
				start = parser.pos;
				parser.allowWhitespace();
				if ( !parser.matchString( '?' ) ) {
					parser.pos = start;
					return expression;
				}
				parser.allowWhitespace();
				ifTrue = parser.readExpression();
				if ( !ifTrue ) {
					parser.error( errors.expectedExpression );
				}
				parser.allowWhitespace();
				if ( !parser.matchString( ':' ) ) {
					parser.error( 'Expected ":"' );
				}
				parser.allowWhitespace();
				ifFalse = parser.readExpression();
				if ( !ifFalse ) {
					parser.error( errors.expectedExpression );
				}
				return {
					t: types.CONDITIONAL,
					o: [
						expression,
						ifTrue,
						ifFalse
					]
				};
			};
		}( types, logicalOr, parse_Parser_expressions_shared_errors );
	
		/* parse/Parser/utils/flattenExpression.js */
		var flattenExpression = function( types, isObject ) {
	
			var __export;
			__export = function( expression ) {
				var refs = [],
					flattened;
				extractRefs( expression, refs );
				flattened = {
					r: refs,
					s: stringify( this, expression, refs )
				};
				return flattened;
			};
	
			function quoteStringLiteral( str ) {
				return JSON.stringify( String( str ) );
			}
			// TODO maybe refactor this?
			function extractRefs( node, refs ) {
				var i, list;
				if ( node.t === types.REFERENCE ) {
					if ( refs.indexOf( node.n ) === -1 ) {
						refs.unshift( node.n );
					}
				}
				list = node.o || node.m;
				if ( list ) {
					if ( isObject( list ) ) {
						extractRefs( list, refs );
					} else {
						i = list.length;
						while ( i-- ) {
							extractRefs( list[ i ], refs );
						}
					}
				}
				if ( node.x ) {
					extractRefs( node.x, refs );
				}
				if ( node.r ) {
					extractRefs( node.r, refs );
				}
				if ( node.v ) {
					extractRefs( node.v, refs );
				}
			}
	
			function stringify( parser, node, refs ) {
				var stringifyAll = function( item ) {
					return stringify( parser, item, refs );
				};
				switch ( node.t ) {
					case types.BOOLEAN_LITERAL:
					case types.GLOBAL:
					case types.NUMBER_LITERAL:
						return node.v;
					case types.STRING_LITERAL:
						return quoteStringLiteral( node.v );
					case types.ARRAY_LITERAL:
						return '[' + ( node.m ? node.m.map( stringifyAll ).join( ',' ) : '' ) + ']';
					case types.OBJECT_LITERAL:
						return '{' + ( node.m ? node.m.map( stringifyAll ).join( ',' ) : '' ) + '}';
					case types.KEY_VALUE_PAIR:
						return node.k + ':' + stringify( parser, node.v, refs );
					case types.PREFIX_OPERATOR:
						return ( node.s === 'typeof' ? 'typeof ' : node.s ) + stringify( parser, node.o, refs );
					case types.INFIX_OPERATOR:
						return stringify( parser, node.o[ 0 ], refs ) + ( node.s.substr( 0, 2 ) === 'in' ? ' ' + node.s + ' ' : node.s ) + stringify( parser, node.o[ 1 ], refs );
					case types.INVOCATION:
						return stringify( parser, node.x, refs ) + '(' + ( node.o ? node.o.map( stringifyAll ).join( ',' ) : '' ) + ')';
					case types.BRACKETED:
						return '(' + stringify( parser, node.x, refs ) + ')';
					case types.MEMBER:
						return stringify( parser, node.x, refs ) + stringify( parser, node.r, refs );
					case types.REFINEMENT:
						return node.n ? '.' + node.n : '[' + stringify( parser, node.x, refs ) + ']';
					case types.CONDITIONAL:
						return stringify( parser, node.o[ 0 ], refs ) + '?' + stringify( parser, node.o[ 1 ], refs ) + ':' + stringify( parser, node.o[ 2 ], refs );
					case types.REFERENCE:
						return '_' + refs.indexOf( node.n );
					default:
						parser.error( 'Expected legal JavaScript' );
				}
			}
			return __export;
		}( types, isObject );
	
		/* parse/Parser/_Parser.js */
		var Parser = function( circular, create, hasOwnProperty, getConditional, flattenExpression ) {
	
			var Parser, ParseError, leadingWhitespace = /^\s+/;
			ParseError = function( message ) {
				this.name = 'ParseError';
				this.message = message;
				try {
					throw new Error( message );
				} catch ( e ) {
					this.stack = e.stack;
				}
			};
			ParseError.prototype = Error.prototype;
			Parser = function( str, options ) {
				var items, item, lineStart = 0;
				this.str = str;
				this.options = options || {};
				this.pos = 0;
				this.lines = this.str.split( '\n' );
				this.lineEnds = this.lines.map( function( line ) {
					var lineEnd = lineStart + line.length + 1;
					// +1 for the newline
					lineStart = lineEnd;
					return lineEnd;
				}, 0 );
				// Custom init logic
				if ( this.init )
					this.init( str, options );
				items = [];
				while ( this.pos < this.str.length && ( item = this.read() ) ) {
					items.push( item );
				}
				this.leftover = this.remaining();
				this.result = this.postProcess ? this.postProcess( items, options ) : items;
			};
			Parser.prototype = {
				read: function( converters ) {
					var pos, i, len, item;
					if ( !converters )
						converters = this.converters;
					pos = this.pos;
					len = converters.length;
					for ( i = 0; i < len; i += 1 ) {
						this.pos = pos;
						// reset for each attempt
						if ( item = converters[ i ]( this ) ) {
							return item;
						}
					}
					return null;
				},
				readExpression: function() {
					// The conditional operator is the lowest precedence operator (except yield,
					// assignment operators, and commas, none of which are supported), so we
					// start there. If it doesn't match, it 'falls through' to progressively
					// higher precedence operators, until it eventually matches (or fails to
					// match) a 'primary' - a literal or a reference. This way, the abstract syntax
					// tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.
					return getConditional( this );
				},
				flattenExpression: flattenExpression,
				getLinePos: function( char ) {
					var lineNum = 0,
						lineStart = 0,
						columnNum;
					while ( char >= this.lineEnds[ lineNum ] ) {
						lineStart = this.lineEnds[ lineNum ];
						lineNum += 1;
					}
					columnNum = char - lineStart;
					return [
						lineNum + 1,
						columnNum + 1,
						char
					];
				},
				error: function( message ) {
					var pos, lineNum, columnNum, line, annotation, error;
					pos = this.getLinePos( this.pos );
					lineNum = pos[ 0 ];
					columnNum = pos[ 1 ];
					line = this.lines[ pos[ 0 ] - 1 ];
					annotation = line + '\n' + new Array( pos[ 1 ] ).join( ' ' ) + '^----';
					error = new ParseError( message + ' at line ' + lineNum + ' character ' + columnNum + ':\n' + annotation );
					error.line = pos[ 0 ];
					error.character = pos[ 1 ];
					error.shortMessage = message;
					throw error;
				},
				matchString: function( string ) {
					if ( this.str.substr( this.pos, string.length ) === string ) {
						this.pos += string.length;
						return string;
					}
				},
				matchPattern: function( pattern ) {
					var match;
					if ( match = pattern.exec( this.remaining() ) ) {
						this.pos += match[ 0 ].length;
						return match[ 1 ] || match[ 0 ];
					}
				},
				allowWhitespace: function() {
					this.matchPattern( leadingWhitespace );
				},
				remaining: function() {
					return this.str.substring( this.pos );
				},
				nextChar: function() {
					return this.str.charAt( this.pos );
				}
			};
			Parser.extend = function( proto ) {
				var Parent = this,
					Child, key;
				Child = function( str, options ) {
					Parser.call( this, str, options );
				};
				Child.prototype = create( Parent.prototype );
				for ( key in proto ) {
					if ( hasOwnProperty.call( proto, key ) ) {
						Child.prototype[ key ] = proto[ key ];
					}
				}
				Child.extend = Parser.extend;
				return Child;
			};
			circular.Parser = Parser;
			return Parser;
		}( circular, create, hasOwn, conditional, flattenExpression );
	
		/* parse/converters/mustache/delimiterChange.js */
		var delimiterChange = function() {
	
			var delimiterChangePattern = /^[^\s=]+/,
				whitespacePattern = /^\s+/;
			return function( parser ) {
				var start, opening, closing;
				if ( !parser.matchString( '=' ) ) {
					return null;
				}
				start = parser.pos;
				// allow whitespace before new opening delimiter
				parser.allowWhitespace();
				opening = parser.matchPattern( delimiterChangePattern );
				if ( !opening ) {
					parser.pos = start;
					return null;
				}
				// allow whitespace (in fact, it's necessary...)
				if ( !parser.matchPattern( whitespacePattern ) ) {
					return null;
				}
				closing = parser.matchPattern( delimiterChangePattern );
				if ( !closing ) {
					parser.pos = start;
					return null;
				}
				// allow whitespace before closing '='
				parser.allowWhitespace();
				if ( !parser.matchString( '=' ) ) {
					parser.pos = start;
					return null;
				}
				return [
					opening,
					closing
				];
			};
		}();
	
		/* parse/converters/mustache/delimiterTypes.js */
		var delimiterTypes = [ {
			delimiters: 'delimiters',
			isTriple: false,
			isStatic: false
		}, {
			delimiters: 'tripleDelimiters',
			isTriple: true,
			isStatic: false
		}, {
			delimiters: 'staticDelimiters',
			isTriple: false,
			isStatic: true
		}, {
			delimiters: 'staticTripleDelimiters',
			isTriple: true,
			isStatic: true
		} ];
	
		/* parse/converters/mustache/type.js */
		var type = function( types ) {
	
			var mustacheTypes = {
				'#': types.SECTION,
				'^': types.INVERTED,
				'/': types.CLOSING,
				'>': types.PARTIAL,
				'!': types.COMMENT,
				'&': types.TRIPLE
			};
			return function( parser ) {
				var type = mustacheTypes[ parser.str.charAt( parser.pos ) ];
				if ( !type ) {
					return null;
				}
				parser.pos += 1;
				return type;
			};
		}( types );
	
		/* parse/converters/mustache/handlebarsBlockCodes.js */
		var handlebarsBlockCodes = function( types ) {
	
			return {
				'each': types.SECTION_EACH,
				'if': types.SECTION_IF,
				'if-with': types.SECTION_IF_WITH,
				'with': types.SECTION_WITH,
				'unless': types.SECTION_UNLESS
			};
		}( types );
	
		/* empty/legacy.js */
		var legacy = null;
	
		/* parse/converters/mustache/content.js */
		var content = function( types, mustacheType, handlebarsBlockCodes ) {
	
			var __export;
			var indexRefPattern = /^\s*:\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,
				arrayMemberPattern = /^[0-9][1-9]*$/,
				handlebarsBlockPattern = new RegExp( '^(' + Object.keys( handlebarsBlockCodes ).join( '|' ) + ')\\b' ),
				legalReference;
			legalReference = /^[a-zA-Z$_0-9]+(?:(\.[a-zA-Z$_0-9]+)|(\[[a-zA-Z$_0-9]+\]))*$/;
			__export = function( parser, delimiterType ) {
				var start, pos, mustache, type, block, expression, i, remaining, index, delimiters;
				start = parser.pos;
				mustache = {};
				delimiters = parser[ delimiterType.delimiters ];
				if ( delimiterType.isStatic ) {
					mustache.s = true;
				}
				// Determine mustache type
				if ( delimiterType.isTriple ) {
					mustache.t = types.TRIPLE;
				} else {
					// We need to test for expressions before we test for mustache type, because
					// an expression that begins '!' looks a lot like a comment
					if ( parser.remaining()[ 0 ] === '!' ) {
						try {
							expression = parser.readExpression();
							// Was it actually an expression, or a comment block in disguise?
							parser.allowWhitespace();
							if ( parser.remaining().indexOf( delimiters[ 1 ] ) ) {
								expression = null;
							} else {
								mustache.t = types.INTERPOLATOR;
							}
						} catch ( err ) {}
						if ( !expression ) {
							index = parser.remaining().indexOf( delimiters[ 1 ] );
							if ( ~index ) {
								parser.pos += index;
							} else {
								parser.error( 'Expected closing delimiter (\'' + delimiters[ 1 ] + '\')' );
							}
							return {
								t: types.COMMENT
							};
						}
					}
					if ( !expression ) {
						type = mustacheType( parser );
						mustache.t = type || types.INTERPOLATOR;
						// default
						// See if there's an explicit section type e.g. {{#with}}...{{/with}}
						if ( type === types.SECTION ) {
							if ( block = parser.matchPattern( handlebarsBlockPattern ) ) {
								mustache.n = block;
							}
							parser.allowWhitespace();
						} else if ( type === types.COMMENT || type === types.CLOSING ) {
							remaining = parser.remaining();
							index = remaining.indexOf( delimiters[ 1 ] );
							if ( index !== -1 ) {
								mustache.r = remaining.substr( 0, index ).split( ' ' )[ 0 ];
								parser.pos += index;
								return mustache;
							}
						}
					}
				}
				if ( !expression ) {
					// allow whitespace
					parser.allowWhitespace();
					// get expression
					expression = parser.readExpression();
					// If this is a partial, it may have a context (e.g. `{{>item foo}}`). These
					// cases involve a bit of a hack - we want to turn it into the equivalent of
					// `{{#with foo}}{{>item}}{{/with}}`, but to get there we temporarily append
					// a 'contextPartialExpression' to the mustache, and process the context instead of
					// the reference
					var temp;
					if ( mustache.t === types.PARTIAL && expression && ( temp = parser.readExpression() ) ) {
						mustache = {
							contextPartialExpression: expression
						};
						expression = temp;
					}
					// With certain valid references that aren't valid expressions,
					// e.g. {{1.foo}}, we have a problem: it looks like we've got an
					// expression, but the expression didn't consume the entire
					// reference. So we need to check that the mustache delimiters
					// appear next, unless there's an index reference (i.e. a colon)
					remaining = parser.remaining();
					if ( remaining.substr( 0, delimiters[ 1 ].length ) !== delimiters[ 1 ] && remaining.charAt( 0 ) !== ':' ) {
						pos = parser.pos;
						parser.pos = start;
						remaining = parser.remaining();
						index = remaining.indexOf( delimiters[ 1 ] );
						if ( index !== -1 ) {
							mustache.r = remaining.substr( 0, index ).trim();
							// Check it's a legal reference
							if ( !legalReference.test( mustache.r ) ) {
								parser.error( 'Expected a legal Mustache reference' );
							}
							parser.pos += index;
							return mustache;
						}
						parser.pos = pos;
					}
				}
				refineExpression( parser, expression, mustache );
				// if there was context, process the expression now and save it for later
				if ( mustache.contextPartialExpression ) {
					mustache.contextPartialExpression = [ refineExpression( parser, mustache.contextPartialExpression, {
						t: types.PARTIAL
					} ) ];
				}
				// optional index reference
				if ( i = parser.matchPattern( indexRefPattern ) ) {
					mustache.i = i;
				}
				return mustache;
			};
	
			function refineExpression( parser, expression, mustache ) {
				var referenceExpression;
				if ( expression ) {
					while ( expression.t === types.BRACKETED && expression.x ) {
						expression = expression.x;
					}
					// special case - integers should be treated as array members references,
					// rather than as expressions in their own right
					if ( expression.t === types.REFERENCE ) {
						mustache.r = expression.n;
					} else {
						if ( expression.t === types.NUMBER_LITERAL && arrayMemberPattern.test( expression.v ) ) {
							mustache.r = expression.v;
						} else if ( referenceExpression = getReferenceExpression( parser, expression ) ) {
							mustache.rx = referenceExpression;
						} else {
							mustache.x = parser.flattenExpression( expression );
						}
					}
					return mustache;
				}
			}
			// TODO refactor this! it's bewildering
			function getReferenceExpression( parser, expression ) {
				var members = [],
					refinement;
				while ( expression.t === types.MEMBER && expression.r.t === types.REFINEMENT ) {
					refinement = expression.r;
					if ( refinement.x ) {
						if ( refinement.x.t === types.REFERENCE ) {
							members.unshift( refinement.x );
						} else {
							members.unshift( parser.flattenExpression( refinement.x ) );
						}
					} else {
						members.unshift( refinement.n );
					}
					expression = expression.x;
				}
				if ( expression.t !== types.REFERENCE ) {
					return null;
				}
				return {
					r: expression.n,
					m: members
				};
			}
			return __export;
		}( types, type, handlebarsBlockCodes, legacy );
	
		/* parse/converters/mustache.js */
		var mustache = function( types, delimiterChange, delimiterTypes, mustacheContent, handlebarsBlockCodes ) {
	
			var __export;
			var delimiterChangeToken = {
				t: types.DELIMCHANGE,
				exclude: true
			};
			__export = getMustache;
	
			function getMustache( parser ) {
				var types;
				// If we're inside a <script> or <style> tag, and we're not
				// interpolating, bug out
				if ( parser.interpolate[ parser.inside ] === false ) {
					return null;
				}
				types = delimiterTypes.slice().sort( function compare( a, b ) {
					// Sort in order of descending opening delimiter length (longer first),
					// to protect against opening delimiters being substrings of each other
					return parser[ b.delimiters ][ 0 ].length - parser[ a.delimiters ][ 0 ].length;
				} );
				return function r( type ) {
					if ( !type ) {
						return null;
					} else {
						return getMustacheOfType( parser, type ) || r( types.shift() );
					}
				}( types.shift() );
			}
	
			function getMustacheOfType( parser, delimiterType ) {
				var start, mustache, delimiters, children, expectedClose, elseChildren, currentChildren, child;
				start = parser.pos;
				delimiters = parser[ delimiterType.delimiters ];
				if ( !parser.matchString( delimiters[ 0 ] ) ) {
					return null;
				}
				// delimiter change?
				if ( mustache = delimiterChange( parser ) ) {
					// find closing delimiter or abort...
					if ( !parser.matchString( delimiters[ 1 ] ) ) {
						return null;
					}
					// ...then make the switch
					parser[ delimiterType.delimiters ] = mustache;
					return delimiterChangeToken;
				}
				parser.allowWhitespace();
				mustache = mustacheContent( parser, delimiterType );
				if ( mustache === null ) {
					parser.pos = start;
					return null;
				}
				// allow whitespace before closing delimiter
				parser.allowWhitespace();
				if ( !parser.matchString( delimiters[ 1 ] ) ) {
					parser.error( 'Expected closing delimiter \'' + delimiters[ 1 ] + '\' after reference' );
				}
				if ( mustache.t === types.COMMENT ) {
					mustache.exclude = true;
				}
				if ( mustache.t === types.CLOSING ) {
					parser.sectionDepth -= 1;
					if ( parser.sectionDepth < 0 ) {
						parser.pos = start;
						parser.error( 'Attempted to close a section that wasn\'t open' );
					}
				}
				// partials with context
				if ( mustache.contextPartialExpression ) {
					mustache.f = mustache.contextPartialExpression;
					mustache.t = types.SECTION;
					mustache.n = 'with';
					delete mustache.contextPartialExpression;
				} else if ( isSection( mustache ) ) {
					parser.sectionDepth += 1;
					children = [];
					currentChildren = children;
					expectedClose = mustache.n;
					while ( child = parser.read() ) {
						if ( child.t === types.CLOSING ) {
							if ( expectedClose && child.r !== expectedClose ) {
								parser.error( 'Expected {{/' + expectedClose + '}}' );
							}
							break;
						}
						// {{else}} tags require special treatment
						if ( child.t === types.INTERPOLATOR && child.r === 'else' ) {
							// no {{else}} allowed in {{#unless}}
							if ( mustache.n === 'unless' ) {
								parser.error( '{{else}} not allowed in {{#unless}}' );
							} else {
								currentChildren = elseChildren = [];
								continue;
							}
						}
						currentChildren.push( child );
					}
					if ( children.length ) {
						mustache.f = children;
					}
					if ( elseChildren && elseChildren.length ) {
						mustache.l = elseChildren;
						if ( mustache.n === 'with' ) {
							mustache.n = 'if-with';
						}
					}
				}
				if ( parser.includeLinePositions ) {
					mustache.p = parser.getLinePos( start );
				}
				// Replace block name with code
				if ( mustache.n ) {
					mustache.n = handlebarsBlockCodes[ mustache.n ];
				} else if ( mustache.t === types.INVERTED ) {
					mustache.t = types.SECTION;
					mustache.n = types.SECTION_UNLESS;
				}
				return mustache;
			}
	
			function isSection( mustache ) {
				return mustache.t === types.SECTION || mustache.t === types.INVERTED;
			}
			return __export;
		}( types, delimiterChange, delimiterTypes, content, handlebarsBlockCodes );
	
		/* parse/converters/comment.js */
		var comment = function( types ) {
	
			var OPEN_COMMENT = '<!--',
				CLOSE_COMMENT = '-->';
			return function( parser ) {
				var start, content, remaining, endIndex, comment;
				start = parser.pos;
				if ( !parser.matchString( OPEN_COMMENT ) ) {
					return null;
				}
				remaining = parser.remaining();
				endIndex = remaining.indexOf( CLOSE_COMMENT );
				if ( endIndex === -1 ) {
					parser.error( 'Illegal HTML - expected closing comment sequence (\'-->\')' );
				}
				content = remaining.substr( 0, endIndex );
				parser.pos += endIndex + 3;
				comment = {
					t: types.COMMENT,
					c: content
				};
				if ( parser.includeLinePositions ) {
					comment.p = parser.getLinePos( start );
				}
				return comment;
			};
		}( types );
	
		/* config/voidElementNames.js */
		var voidElementNames = function() {
	
			var voidElementNames = /^(?:area|base|br|col|command|doctype|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;
			return voidElementNames;
		}();
	
		/* parse/converters/utils/getLowestIndex.js */
		var getLowestIndex = function( haystack, needles ) {
			var i, index, lowest;
			i = needles.length;
			while ( i-- ) {
				index = haystack.indexOf( needles[ i ] );
				// short circuit
				if ( !index ) {
					return 0;
				}
				if ( index === -1 ) {
					continue;
				}
				if ( !lowest || index < lowest ) {
					lowest = index;
				}
			}
			return lowest || -1;
		};
	
		/* shared/decodeCharacterReferences.js */
		var decodeCharacterReferences = function() {
	
			var __export;
			var htmlEntities, controlCharacters, entityPattern;
			htmlEntities = {
				quot: 34,
				amp: 38,
				apos: 39,
				lt: 60,
				gt: 62,
				nbsp: 160,
				iexcl: 161,
				cent: 162,
				pound: 163,
				curren: 164,
				yen: 165,
				brvbar: 166,
				sect: 167,
				uml: 168,
				copy: 169,
				ordf: 170,
				laquo: 171,
				not: 172,
				shy: 173,
				reg: 174,
				macr: 175,
				deg: 176,
				plusmn: 177,
				sup2: 178,
				sup3: 179,
				acute: 180,
				micro: 181,
				para: 182,
				middot: 183,
				cedil: 184,
				sup1: 185,
				ordm: 186,
				raquo: 187,
				frac14: 188,
				frac12: 189,
				frac34: 190,
				iquest: 191,
				Agrave: 192,
				Aacute: 193,
				Acirc: 194,
				Atilde: 195,
				Auml: 196,
				Aring: 197,
				AElig: 198,
				Ccedil: 199,
				Egrave: 200,
				Eacute: 201,
				Ecirc: 202,
				Euml: 203,
				Igrave: 204,
				Iacute: 205,
				Icirc: 206,
				Iuml: 207,
				ETH: 208,
				Ntilde: 209,
				Ograve: 210,
				Oacute: 211,
				Ocirc: 212,
				Otilde: 213,
				Ouml: 214,
				times: 215,
				Oslash: 216,
				Ugrave: 217,
				Uacute: 218,
				Ucirc: 219,
				Uuml: 220,
				Yacute: 221,
				THORN: 222,
				szlig: 223,
				agrave: 224,
				aacute: 225,
				acirc: 226,
				atilde: 227,
				auml: 228,
				aring: 229,
				aelig: 230,
				ccedil: 231,
				egrave: 232,
				eacute: 233,
				ecirc: 234,
				euml: 235,
				igrave: 236,
				iacute: 237,
				icirc: 238,
				iuml: 239,
				eth: 240,
				ntilde: 241,
				ograve: 242,
				oacute: 243,
				ocirc: 244,
				otilde: 245,
				ouml: 246,
				divide: 247,
				oslash: 248,
				ugrave: 249,
				uacute: 250,
				ucirc: 251,
				uuml: 252,
				yacute: 253,
				thorn: 254,
				yuml: 255,
				OElig: 338,
				oelig: 339,
				Scaron: 352,
				scaron: 353,
				Yuml: 376,
				fnof: 402,
				circ: 710,
				tilde: 732,
				Alpha: 913,
				Beta: 914,
				Gamma: 915,
				Delta: 916,
				Epsilon: 917,
				Zeta: 918,
				Eta: 919,
				Theta: 920,
				Iota: 921,
				Kappa: 922,
				Lambda: 923,
				Mu: 924,
				Nu: 925,
				Xi: 926,
				Omicron: 927,
				Pi: 928,
				Rho: 929,
				Sigma: 931,
				Tau: 932,
				Upsilon: 933,
				Phi: 934,
				Chi: 935,
				Psi: 936,
				Omega: 937,
				alpha: 945,
				beta: 946,
				gamma: 947,
				delta: 948,
				epsilon: 949,
				zeta: 950,
				eta: 951,
				theta: 952,
				iota: 953,
				kappa: 954,
				lambda: 955,
				mu: 956,
				nu: 957,
				xi: 958,
				omicron: 959,
				pi: 960,
				rho: 961,
				sigmaf: 962,
				sigma: 963,
				tau: 964,
				upsilon: 965,
				phi: 966,
				chi: 967,
				psi: 968,
				omega: 969,
				thetasym: 977,
				upsih: 978,
				piv: 982,
				ensp: 8194,
				emsp: 8195,
				thinsp: 8201,
				zwnj: 8204,
				zwj: 8205,
				lrm: 8206,
				rlm: 8207,
				ndash: 8211,
				mdash: 8212,
				lsquo: 8216,
				rsquo: 8217,
				sbquo: 8218,
				ldquo: 8220,
				rdquo: 8221,
				bdquo: 8222,
				dagger: 8224,
				Dagger: 8225,
				bull: 8226,
				hellip: 8230,
				permil: 8240,
				prime: 8242,
				Prime: 8243,
				lsaquo: 8249,
				rsaquo: 8250,
				oline: 8254,
				frasl: 8260,
				euro: 8364,
				image: 8465,
				weierp: 8472,
				real: 8476,
				trade: 8482,
				alefsym: 8501,
				larr: 8592,
				uarr: 8593,
				rarr: 8594,
				darr: 8595,
				harr: 8596,
				crarr: 8629,
				lArr: 8656,
				uArr: 8657,
				rArr: 8658,
				dArr: 8659,
				hArr: 8660,
				forall: 8704,
				part: 8706,
				exist: 8707,
				empty: 8709,
				nabla: 8711,
				isin: 8712,
				notin: 8713,
				ni: 8715,
				prod: 8719,
				sum: 8721,
				minus: 8722,
				lowast: 8727,
				radic: 8730,
				prop: 8733,
				infin: 8734,
				ang: 8736,
				and: 8743,
				or: 8744,
				cap: 8745,
				cup: 8746,
				'int': 8747,
				there4: 8756,
				sim: 8764,
				cong: 8773,
				asymp: 8776,
				ne: 8800,
				equiv: 8801,
				le: 8804,
				ge: 8805,
				sub: 8834,
				sup: 8835,
				nsub: 8836,
				sube: 8838,
				supe: 8839,
				oplus: 8853,
				otimes: 8855,
				perp: 8869,
				sdot: 8901,
				lceil: 8968,
				rceil: 8969,
				lfloor: 8970,
				rfloor: 8971,
				lang: 9001,
				rang: 9002,
				loz: 9674,
				spades: 9824,
				clubs: 9827,
				hearts: 9829,
				diams: 9830
			};
			controlCharacters = [
				8364,
				129,
				8218,
				402,
				8222,
				8230,
				8224,
				8225,
				710,
				8240,
				352,
				8249,
				338,
				141,
				381,
				143,
				144,
				8216,
				8217,
				8220,
				8221,
				8226,
				8211,
				8212,
				732,
				8482,
				353,
				8250,
				339,
				157,
				382,
				376
			];
			entityPattern = new RegExp( '&(#?(?:x[\\w\\d]+|\\d+|' + Object.keys( htmlEntities ).join( '|' ) + '));?', 'g' );
			__export = function decodeCharacterReferences( html ) {
				return html.replace( entityPattern, function( match, entity ) {
					var code;
					// Handle named entities
					if ( entity[ 0 ] !== '#' ) {
						code = htmlEntities[ entity ];
					} else if ( entity[ 1 ] === 'x' ) {
						code = parseInt( entity.substring( 2 ), 16 );
					} else {
						code = parseInt( entity.substring( 1 ), 10 );
					}
					if ( !code ) {
						return match;
					}
					return String.fromCharCode( validateCode( code ) );
				} );
			};
			// some code points are verboten. If we were inserting HTML, the browser would replace the illegal
			// code points with alternatives in some cases - since we're bypassing that mechanism, we need
			// to replace them ourselves
			//
			// Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters
			function validateCode( code ) {
				if ( !code ) {
					return 65533;
				}
				// line feed becomes generic whitespace
				if ( code === 10 ) {
					return 32;
				}
				// ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)
				if ( code < 128 ) {
					return code;
				}
				// code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need
				// to correct the mistake or we'll end up with missing  signs and so on
				if ( code <= 159 ) {
					return controlCharacters[ code - 128 ];
				}
				// basic multilingual plane
				if ( code < 55296 ) {
					return code;
				}
				// UTF-16 surrogate halves
				if ( code <= 57343 ) {
					return 65533;
				}
				// rest of the basic multilingual plane
				if ( code <= 65535 ) {
					return code;
				}
				return 65533;
			}
			return __export;
		}( legacy );
	
		/* parse/converters/text.js */
		var text = function( getLowestIndex, decodeCharacterReferences ) {
	
			return function( parser ) {
				var index, remaining, disallowed, barrier;
				remaining = parser.remaining();
				barrier = parser.inside ? '</' + parser.inside : '<';
				if ( parser.inside && !parser.interpolate[ parser.inside ] ) {
					index = remaining.indexOf( barrier );
				} else {
					disallowed = [
						parser.delimiters[ 0 ],
						parser.tripleDelimiters[ 0 ],
						parser.staticDelimiters[ 0 ],
						parser.staticTripleDelimiters[ 0 ]
					];
					// http://developers.whatwg.org/syntax.html#syntax-attributes
					if ( parser.inAttribute === true ) {
						// we're inside an unquoted attribute value
						disallowed.push( '"', '\'', '=', '<', '>', '`' );
					} else if ( parser.inAttribute ) {
						// quoted attribute value
						disallowed.push( parser.inAttribute );
					} else {
						disallowed.push( barrier );
					}
					index = getLowestIndex( remaining, disallowed );
				}
				if ( !index ) {
					return null;
				}
				if ( index === -1 ) {
					index = remaining.length;
				}
				parser.pos += index;
				return parser.inside ? remaining.substr( 0, index ) : decodeCharacterReferences( remaining.substr( 0, index ) );
			};
		}( getLowestIndex, decodeCharacterReferences );
	
		/* parse/converters/element/closingTag.js */
		var closingTag = function( types ) {
	
			var closingTagPattern = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\-]*)\s*\>/;
			return function( parser ) {
				var tag;
				// are we looking at a closing tag?
				if ( !parser.matchString( '</' ) ) {
					return null;
				}
				if ( tag = parser.matchPattern( closingTagPattern ) ) {
					return {
						t: types.CLOSING_TAG,
						e: tag
					};
				}
				// We have an illegal closing tag, report it
				parser.pos -= 2;
				parser.error( 'Illegal closing tag' );
			};
		}( types );
	
		/* parse/converters/element/attribute.js */
		var attribute = function( getLowestIndex, getMustache, decodeCharacterReferences ) {
	
			var __export;
			var attributeNamePattern = /^[^\s"'>\/=]+/,
				unquotedAttributeValueTextPattern = /^[^\s"'=<>`]+/;
			__export = getAttribute;
	
			function getAttribute( parser ) {
				var attr, name, value;
				parser.allowWhitespace();
				name = parser.matchPattern( attributeNamePattern );
				if ( !name ) {
					return null;
				}
				attr = {
					name: name
				};
				value = getAttributeValue( parser );
				if ( value ) {
					attr.value = value;
				}
				return attr;
			}
	
			function getAttributeValue( parser ) {
				var start, valueStart, startDepth, value;
				start = parser.pos;
				parser.allowWhitespace();
				if ( !parser.matchString( '=' ) ) {
					parser.pos = start;
					return null;
				}
				parser.allowWhitespace();
				valueStart = parser.pos;
				startDepth = parser.sectionDepth;
				value = getQuotedAttributeValue( parser, '\'' ) || getQuotedAttributeValue( parser, '"' ) || getUnquotedAttributeValue( parser );
				if ( parser.sectionDepth !== startDepth ) {
					parser.pos = valueStart;
					parser.error( 'An attribute value must contain as many opening section tags as closing section tags' );
				}
				if ( value === null ) {
					parser.pos = start;
					return null;
				}
				if ( !value.length ) {
					return null;
				}
				if ( value.length === 1 && typeof value[ 0 ] === 'string' ) {
					return decodeCharacterReferences( value[ 0 ] );
				}
				return value;
			}
	
			function getUnquotedAttributeValueToken( parser ) {
				var start, text, haystack, needles, index;
				start = parser.pos;
				text = parser.matchPattern( unquotedAttributeValueTextPattern );
				if ( !text ) {
					return null;
				}
				haystack = text;
				needles = [
					parser.delimiters[ 0 ],
					parser.tripleDelimiters[ 0 ],
					parser.staticDelimiters[ 0 ],
					parser.staticTripleDelimiters[ 0 ]
				];
				if ( ( index = getLowestIndex( haystack, needles ) ) !== -1 ) {
					text = text.substr( 0, index );
					parser.pos = start + text.length;
				}
				return text;
			}
	
			function getUnquotedAttributeValue( parser ) {
				var tokens, token;
				parser.inAttribute = true;
				tokens = [];
				token = getMustache( parser ) || getUnquotedAttributeValueToken( parser );
				while ( token !== null ) {
					tokens.push( token );
					token = getMustache( parser ) || getUnquotedAttributeValueToken( parser );
				}
				if ( !tokens.length ) {
					return null;
				}
				parser.inAttribute = false;
				return tokens;
			}
	
			function getQuotedAttributeValue( parser, quoteMark ) {
				var start, tokens, token;
				start = parser.pos;
				if ( !parser.matchString( quoteMark ) ) {
					return null;
				}
				parser.inAttribute = quoteMark;
				tokens = [];
				token = getMustache( parser ) || getQuotedStringToken( parser, quoteMark );
				while ( token !== null ) {
					tokens.push( token );
					token = getMustache( parser ) || getQuotedStringToken( parser, quoteMark );
				}
				if ( !parser.matchString( quoteMark ) ) {
					parser.pos = start;
					return null;
				}
				parser.inAttribute = false;
				return tokens;
			}
	
			function getQuotedStringToken( parser, quoteMark ) {
				var start, index, haystack, needles;
				start = parser.pos;
				haystack = parser.remaining();
				needles = [
					quoteMark,
					parser.delimiters[ 0 ],
					parser.tripleDelimiters[ 0 ],
					parser.staticDelimiters[ 0 ],
					parser.staticTripleDelimiters[ 0 ]
				];
				index = getLowestIndex( haystack, needles );
				if ( index === -1 ) {
					parser.error( 'Quoted attribute value must have a closing quote' );
				}
				if ( !index ) {
					return null;
				}
				parser.pos += index;
				return haystack.substr( 0, index );
			}
			return __export;
		}( getLowestIndex, mustache, decodeCharacterReferences );
	
		/* utils/parseJSON.js */
		var parseJSON = function( Parser, getStringLiteral, getKey ) {
	
			var JsonParser, specials, specialsPattern, numberPattern, placeholderPattern, placeholderAtStartPattern, onlyWhitespace;
			specials = {
				'true': true,
				'false': false,
				'undefined': undefined,
				'null': null
			};
			specialsPattern = new RegExp( '^(?:' + Object.keys( specials ).join( '|' ) + ')' );
			numberPattern = /^(?:[+-]?)(?:(?:(?:0|[1-9]\d*)?\.\d+)|(?:(?:0|[1-9]\d*)\.)|(?:0|[1-9]\d*))(?:[eE][+-]?\d+)?/;
			placeholderPattern = /\$\{([^\}]+)\}/g;
			placeholderAtStartPattern = /^\$\{([^\}]+)\}/;
			onlyWhitespace = /^\s*$/;
			JsonParser = Parser.extend( {
				init: function( str, options ) {
					this.values = options.values;
					this.allowWhitespace();
				},
				postProcess: function( result ) {
					if ( result.length !== 1 || !onlyWhitespace.test( this.leftover ) ) {
						return null;
					}
					return {
						value: result[ 0 ].v
					};
				},
				converters: [
	
					function getPlaceholder( parser ) {
						var placeholder;
						if ( !parser.values ) {
							return null;
						}
						placeholder = parser.matchPattern( placeholderAtStartPattern );
						if ( placeholder && parser.values.hasOwnProperty( placeholder ) ) {
							return {
								v: parser.values[ placeholder ]
							};
						}
					},
					function getSpecial( parser ) {
						var special;
						if ( special = parser.matchPattern( specialsPattern ) ) {
							return {
								v: specials[ special ]
							};
						}
					},
					function getNumber( parser ) {
						var number;
						if ( number = parser.matchPattern( numberPattern ) ) {
							return {
								v: +number
							};
						}
					},
					function getString( parser ) {
						var stringLiteral = getStringLiteral( parser ),
							values;
						if ( stringLiteral && ( values = parser.values ) ) {
							return {
								v: stringLiteral.v.replace( placeholderPattern, function( match, $1 ) {
									return $1 in values ? values[ $1 ] : $1;
								} )
							};
						}
						return stringLiteral;
					},
					function getObject( parser ) {
						var result, pair;
						if ( !parser.matchString( '{' ) ) {
							return null;
						}
						result = {};
						parser.allowWhitespace();
						if ( parser.matchString( '}' ) ) {
							return {
								v: result
							};
						}
						while ( pair = getKeyValuePair( parser ) ) {
							result[ pair.key ] = pair.value;
							parser.allowWhitespace();
							if ( parser.matchString( '}' ) ) {
								return {
									v: result
								};
							}
							if ( !parser.matchString( ',' ) ) {
								return null;
							}
						}
						return null;
					},
					function getArray( parser ) {
						var result, valueToken;
						if ( !parser.matchString( '[' ) ) {
							return null;
						}
						result = [];
						parser.allowWhitespace();
						if ( parser.matchString( ']' ) ) {
							return {
								v: result
							};
						}
						while ( valueToken = parser.read() ) {
							result.push( valueToken.v );
							parser.allowWhitespace();
							if ( parser.matchString( ']' ) ) {
								return {
									v: result
								};
							}
							if ( !parser.matchString( ',' ) ) {
								return null;
							}
							parser.allowWhitespace();
						}
						return null;
					}
				]
			} );
	
			function getKeyValuePair( parser ) {
				var key, valueToken, pair;
				parser.allowWhitespace();
				key = getKey( parser );
				if ( !key ) {
					return null;
				}
				pair = {
					key: key
				};
				parser.allowWhitespace();
				if ( !parser.matchString( ':' ) ) {
					return null;
				}
				parser.allowWhitespace();
				valueToken = parser.read();
				if ( !valueToken ) {
					return null;
				}
				pair.value = valueToken.v;
				return pair;
			}
			return function( str, values ) {
				var parser = new JsonParser( str, {
					values: values
				} );
				return parser.result;
			};
		}( Parser, stringLiteral, key );
	
		/* parse/converters/element/processDirective.js */
		var processDirective = function( Parser, conditional, flattenExpression, parseJSON ) {
	
			var methodCallPattern = /^([a-zA-Z_$][a-zA-Z_$0-9]*)\(/,
				ExpressionParser;
			ExpressionParser = Parser.extend( {
				converters: [ conditional ]
			} );
			// TODO clean this up, it's shocking
			return function( tokens ) {
				var result, match, parser, args, token, colonIndex, directiveName, directiveArgs, parsed;
				if ( typeof tokens === 'string' ) {
					if ( match = methodCallPattern.exec( tokens ) ) {
						result = {
							m: match[ 1 ]
						};
						args = '[' + tokens.slice( result.m.length + 1, -1 ) + ']';
						parser = new ExpressionParser( args );
						result.a = flattenExpression( parser.result[ 0 ] );
						return result;
					}
					if ( tokens.indexOf( ':' ) === -1 ) {
						return tokens.trim();
					}
					tokens = [ tokens ];
				}
				result = {};
				directiveName = [];
				directiveArgs = [];
				if ( tokens ) {
					while ( tokens.length ) {
						token = tokens.shift();
						if ( typeof token === 'string' ) {
							colonIndex = token.indexOf( ':' );
							if ( colonIndex === -1 ) {
								directiveName.push( token );
							} else {
								// is the colon the first character?
								if ( colonIndex ) {
									// no
									directiveName.push( token.substr( 0, colonIndex ) );
								}
								// if there is anything after the colon in this token, treat
								// it as the first token of the directiveArgs fragment
								if ( token.length > colonIndex + 1 ) {
									directiveArgs[ 0 ] = token.substring( colonIndex + 1 );
								}
								break;
							}
						} else {
							directiveName.push( token );
						}
					}
					directiveArgs = directiveArgs.concat( tokens );
				}
				if ( !directiveName.length ) {
					result = '';
				} else if ( directiveArgs.length || typeof directiveName !== 'string' ) {
					result = {
						// TODO is this really necessary? just use the array
						n: directiveName.length === 1 && typeof directiveName[ 0 ] === 'string' ? directiveName[ 0 ] : directiveName
					};
					if ( directiveArgs.length === 1 && typeof directiveArgs[ 0 ] === 'string' ) {
						parsed = parseJSON( '[' + directiveArgs[ 0 ] + ']' );
						result.a = parsed ? parsed.value : directiveArgs[ 0 ].trim();
					} else {
						result.d = directiveArgs;
					}
				} else {
					result = directiveName;
				}
				return result;
			};
		}( Parser, conditional, flattenExpression, parseJSON );
	
		/* parse/converters/element.js */
		var element = function( types, voidElementNames, getMustache, getComment, getText, getClosingTag, getAttribute, processDirective ) {
	
			var __export;
			var tagNamePattern = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\-]*/,
				validTagNameFollower = /^[\s\n\/>]/,
				onPattern = /^on/,
				proxyEventPattern = /^on-([a-zA-Z\\*\\.$_][a-zA-Z\\*\\.$_0-9\-]+)$/,
				reservedEventNames = /^(?:change|reset|teardown|update|construct|config|init|render|unrender|detach|insert)$/,
				directives = {
					'intro-outro': 't0',
					intro: 't1',
					outro: 't2',
					decorator: 'o'
				},
				exclude = {
					exclude: true
				},
				converters, disallowedContents;
			// Different set of converters, because this time we're looking for closing tags
			converters = [
				getMustache,
				getComment,
				getElement,
				getText,
				getClosingTag
			];
			// based on http://developers.whatwg.org/syntax.html#syntax-tag-omission
			disallowedContents = {
				li: [ 'li' ],
				dt: [
					'dt',
					'dd'
				],
				dd: [
					'dt',
					'dd'
				],
				p: 'address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul'.split( ' ' ),
				rt: [
					'rt',
					'rp'
				],
				rp: [
					'rt',
					'rp'
				],
				optgroup: [ 'optgroup' ],
				option: [
					'option',
					'optgroup'
				],
				thead: [
					'tbody',
					'tfoot'
				],
				tbody: [
					'tbody',
					'tfoot'
				],
				tfoot: [ 'tbody' ],
				tr: [
					'tr',
					'tbody'
				],
				td: [
					'td',
					'th',
					'tr'
				],
				th: [
					'td',
					'th',
					'tr'
				]
			};
			__export = getElement;
	
			function getElement( parser ) {
				var start, element, lowerCaseName, directiveName, match, addProxyEvent, attribute, directive, selfClosing, children, child;
				start = parser.pos;
				if ( parser.inside || parser.inAttribute ) {
					return null;
				}
				if ( !parser.matchString( '<' ) ) {
					return null;
				}
				// if this is a closing tag, abort straight away
				if ( parser.nextChar() === '/' ) {
					return null;
				}
				element = {
					t: types.ELEMENT
				};
				if ( parser.includeLinePositions ) {
					element.p = parser.getLinePos( start );
				}
				if ( parser.matchString( '!' ) ) {
					element.y = 1;
				}
				// element name
				element.e = parser.matchPattern( tagNamePattern );
				if ( !element.e ) {
					return null;
				}
				// next character must be whitespace, closing solidus or '>'
				if ( !validTagNameFollower.test( parser.nextChar() ) ) {
					parser.error( 'Illegal tag name' );
				}
				addProxyEvent = function( name, directive ) {
					var directiveName = directive.n || directive;
					if ( reservedEventNames.test( directiveName ) ) {
						parser.pos -= directiveName.length;
						parser.error( 'Cannot use reserved event names (change, reset, teardown, update, construct, config, init, render, unrender, detach, insert)' );
					}
					element.v[ name ] = directive;
				};
				parser.allowWhitespace();
				// directives and attributes
				while ( attribute = getMustache( parser ) || getAttribute( parser ) ) {
					// regular attributes
					if ( attribute.name ) {
						// intro, outro, decorator
						if ( directiveName = directives[ attribute.name ] ) {
							element[ directiveName ] = processDirective( attribute.value );
						} else if ( match = proxyEventPattern.exec( attribute.name ) ) {
							if ( !element.v )
								element.v = {};
							directive = processDirective( attribute.value );
							addProxyEvent( match[ 1 ], directive );
						} else {
							if ( !parser.sanitizeEventAttributes || !onPattern.test( attribute.name ) ) {
								if ( !element.a )
									element.a = {};
								element.a[ attribute.name ] = attribute.value || 0;
							}
						}
					} else {
						if ( !element.m )
							element.m = [];
						element.m.push( attribute );
					}
					parser.allowWhitespace();
				}
				// allow whitespace before closing solidus
				parser.allowWhitespace();
				// self-closing solidus?
				if ( parser.matchString( '/' ) ) {
					selfClosing = true;
				}
				// closing angle bracket
				if ( !parser.matchString( '>' ) ) {
					return null;
				}
				lowerCaseName = element.e.toLowerCase();
				if ( !selfClosing && !voidElementNames.test( element.e ) ) {
					// Special case - if we open a script element, further tags should
					// be ignored unless they're a closing script element
					if ( lowerCaseName === 'script' || lowerCaseName === 'style' ) {
						parser.inside = lowerCaseName;
					}
					children = [];
					while ( canContain( lowerCaseName, parser.remaining() ) && ( child = parser.read( converters ) ) ) {
						// Special case - closing section tag
						if ( child.t === types.CLOSING ) {
							break;
						}
						if ( child.t === types.CLOSING_TAG ) {
							break;
						}
						children.push( child );
					}
					if ( children.length ) {
						element.f = children;
					}
				}
				parser.inside = null;
				if ( parser.sanitizeElements && parser.sanitizeElements.indexOf( lowerCaseName ) !== -1 ) {
					return exclude;
				}
				return element;
			}
	
			function canContain( name, remaining ) {
				var match, disallowed;
				match = /^<([a-zA-Z][a-zA-Z0-9]*)/.exec( remaining );
				disallowed = disallowedContents[ name ];
				if ( !match || !disallowed ) {
					return true;
				}
				return !~disallowed.indexOf( match[ 1 ].toLowerCase() );
			}
			return __export;
		}( types, voidElementNames, mustache, comment, text, closingTag, attribute, processDirective );
	
		/* parse/utils/trimWhitespace.js */
		var trimWhitespace = function() {
	
			var leadingWhitespace = /^[ \t\f\r\n]+/,
				trailingWhitespace = /[ \t\f\r\n]+$/;
			return function( items, leading, trailing ) {
				var item;
				if ( leading ) {
					item = items[ 0 ];
					if ( typeof item === 'string' ) {
						item = item.replace( leadingWhitespace, '' );
						if ( !item ) {
							items.shift();
						} else {
							items[ 0 ] = item;
						}
					}
				}
				if ( trailing ) {
					item = items[ items.length - 1 ];
					if ( typeof item === 'string' ) {
						item = item.replace( trailingWhitespace, '' );
						if ( !item ) {
							items.pop();
						} else {
							items[ items.length - 1 ] = item;
						}
					}
				}
			};
		}();
	
		/* parse/utils/stripStandalones.js */
		var stripStandalones = function( types ) {
	
			var __export;
			var leadingLinebreak = /^\s*\r?\n/,
				trailingLinebreak = /\r?\n\s*$/;
			__export = function( items ) {
				var i, current, backOne, backTwo, lastSectionItem;
				for ( i = 1; i < items.length; i += 1 ) {
					current = items[ i ];
					backOne = items[ i - 1 ];
					backTwo = items[ i - 2 ];
					// if we're at the end of a [text][comment][text] sequence...
					if ( isString( current ) && isComment( backOne ) && isString( backTwo ) ) {
						// ... and the comment is a standalone (i.e. line breaks either side)...
						if ( trailingLinebreak.test( backTwo ) && leadingLinebreak.test( current ) ) {
							// ... then we want to remove the whitespace after the first line break
							items[ i - 2 ] = backTwo.replace( trailingLinebreak, '\n' );
							// and the leading line break of the second text token
							items[ i ] = current.replace( leadingLinebreak, '' );
						}
					}
					// if the current item is a section, and it is preceded by a linebreak, and
					// its first item is a linebreak...
					if ( isSection( current ) && isString( backOne ) ) {
						if ( trailingLinebreak.test( backOne ) && isString( current.f[ 0 ] ) && leadingLinebreak.test( current.f[ 0 ] ) ) {
							items[ i - 1 ] = backOne.replace( trailingLinebreak, '\n' );
							current.f[ 0 ] = current.f[ 0 ].replace( leadingLinebreak, '' );
						}
					}
					// if the last item was a section, and it is followed by a linebreak, and
					// its last item is a linebreak...
					if ( isString( current ) && isSection( backOne ) ) {
						lastSectionItem = backOne.f[ backOne.f.length - 1 ];
						if ( isString( lastSectionItem ) && trailingLinebreak.test( lastSectionItem ) && leadingLinebreak.test( current ) ) {
							backOne.f[ backOne.f.length - 1 ] = lastSectionItem.replace( trailingLinebreak, '\n' );
							items[ i ] = current.replace( leadingLinebreak, '' );
						}
					}
				}
				return items;
			};
	
			function isString( item ) {
				return typeof item === 'string';
			}
	
			function isComment( item ) {
				return item.t === types.COMMENT || item.t === types.DELIMCHANGE;
			}
	
			function isSection( item ) {
				return ( item.t === types.SECTION || item.t === types.INVERTED ) && item.f;
			}
			return __export;
		}( types );
	
		/* utils/escapeRegExp.js */
		var escapeRegExp = function() {
	
			var pattern = /[-/\\^$*+?.()|[\]{}]/g;
			return function escapeRegExp( str ) {
				return str.replace( pattern, '\\$&' );
			};
		}();
	
		/* parse/_parse.js */
		var parse = function( types, Parser, mustache, comment, element, text, trimWhitespace, stripStandalones, escapeRegExp ) {
	
			var __export;
			var StandardParser, parse, contiguousWhitespace = /[ \t\f\r\n]+/g,
				preserveWhitespaceElements = /^(?:pre|script|style|textarea)$/i,
				leadingWhitespace = /^\s+/,
				trailingWhitespace = /\s+$/;
			StandardParser = Parser.extend( {
				init: function( str, options ) {
					// config
					setDelimiters( options, this );
					this.sectionDepth = 0;
					this.interpolate = {
						script: !options.interpolate || options.interpolate.script !== false,
						style: !options.interpolate || options.interpolate.style !== false
					};
					if ( options.sanitize === true ) {
						options.sanitize = {
							// blacklist from https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json
							elements: 'applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title'.split( ' ' ),
							eventAttributes: true
						};
					}
					this.sanitizeElements = options.sanitize && options.sanitize.elements;
					this.sanitizeEventAttributes = options.sanitize && options.sanitize.eventAttributes;
					this.includeLinePositions = options.includeLinePositions;
				},
				postProcess: function( items, options ) {
					if ( this.sectionDepth > 0 ) {
						this.error( 'A section was left open' );
					}
					cleanup( items, options.stripComments !== false, options.preserveWhitespace, !options.preserveWhitespace, !options.preserveWhitespace, options.rewriteElse !== false );
					return items;
				},
				converters: [
					mustache,
					comment,
					element,
					text
				]
			} );
			parse = function( template ) {
				var options = arguments[ 1 ];
				if ( options === void 0 )
					options = {};
				var result, remaining, partials, name, startMatch, endMatch, inlinePartialStart, inlinePartialEnd;
				setDelimiters( options );
				inlinePartialStart = new RegExp( '<!--\\s*' + escapeRegExp( options.delimiters[ 0 ] ) + '\\s*>\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*' + escapeRegExp( options.delimiters[ 1 ] ) + '\\s*-->' );
				inlinePartialEnd = new RegExp( '<!--\\s*' + escapeRegExp( options.delimiters[ 0 ] ) + '\\s*\\/\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*' + escapeRegExp( options.delimiters[ 1 ] ) + '\\s*-->' );
				result = {
					v: 1
				};
				if ( inlinePartialStart.test( template ) ) {
					remaining = template;
					template = '';
					while ( startMatch = inlinePartialStart.exec( remaining ) ) {
						name = startMatch[ 1 ];
						template += remaining.substr( 0, startMatch.index );
						remaining = remaining.substring( startMatch.index + startMatch[ 0 ].length );
						endMatch = inlinePartialEnd.exec( remaining );
						if ( !endMatch || endMatch[ 1 ] !== name ) {
							throw new Error( 'Inline partials must have a closing delimiter, and cannot be nested. Expected closing for "' + name + '", but ' + ( endMatch ? 'instead found "' + endMatch[ 1 ] + '"' : ' no closing found' ) );
						}
						( partials || ( partials = {} ) )[ name ] = new StandardParser( remaining.substr( 0, endMatch.index ), options ).result;
						remaining = remaining.substring( endMatch.index + endMatch[ 0 ].length );
					}
					template += remaining;
					result.p = partials;
				}
				result.t = new StandardParser( template, options ).result;
				return result;
			};
			__export = parse;
	
			function cleanup( items, stripComments, preserveWhitespace, removeLeadingWhitespace, removeTrailingWhitespace, rewriteElse ) {
				var i, item, previousItem, nextItem, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, unlessBlock, key;
				// First pass - remove standalones and comments etc
				stripStandalones( items );
				i = items.length;
				while ( i-- ) {
					item = items[ i ];
					// Remove delimiter changes, unsafe elements etc
					if ( item.exclude ) {
						items.splice( i, 1 );
					} else if ( stripComments && item.t === types.COMMENT ) {
						items.splice( i, 1 );
					}
				}
				// If necessary, remove leading and trailing whitespace
				trimWhitespace( items, removeLeadingWhitespace, removeTrailingWhitespace );
				i = items.length;
				while ( i-- ) {
					item = items[ i ];
					// Recurse
					if ( item.f ) {
						preserveWhitespaceInsideFragment = preserveWhitespace || item.t === types.ELEMENT && preserveWhitespaceElements.test( item.e );
						if ( !preserveWhitespaceInsideFragment ) {
							previousItem = items[ i - 1 ];
							nextItem = items[ i + 1 ];
							// if the previous item was a text item with trailing whitespace,
							// remove leading whitespace inside the fragment
							if ( !previousItem || typeof previousItem === 'string' && trailingWhitespace.test( previousItem ) ) {
								removeLeadingWhitespaceInsideFragment = true;
							}
							// and vice versa
							if ( !nextItem || typeof nextItem === 'string' && leadingWhitespace.test( nextItem ) ) {
								removeTrailingWhitespaceInsideFragment = true;
							}
						}
						cleanup( item.f, stripComments, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, rewriteElse );
					}
					// Split if-else blocks into two (an if, and an unless)
					if ( item.l ) {
						cleanup( item.l, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, rewriteElse );
						if ( rewriteElse ) {
							unlessBlock = {
								t: 4,
								n: types.SECTION_UNLESS,
								f: item.l
							};
							// copy the conditional based on its type
							if ( item.r ) {
								unlessBlock.r = item.r;
							}
							if ( item.x ) {
								unlessBlock.x = item.x;
							}
							if ( item.rx ) {
								unlessBlock.rx = item.rx;
							}
							items.splice( i + 1, 0, unlessBlock );
							delete item.l;
						}
					}
					// Clean up element attributes
					if ( item.a ) {
						for ( key in item.a ) {
							if ( item.a.hasOwnProperty( key ) && typeof item.a[ key ] !== 'string' ) {
								cleanup( item.a[ key ], stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, rewriteElse );
							}
						}
					}
				}
				// final pass - fuse text nodes together
				i = items.length;
				while ( i-- ) {
					if ( typeof items[ i ] === 'string' ) {
						if ( typeof items[ i + 1 ] === 'string' ) {
							items[ i ] = items[ i ] + items[ i + 1 ];
							items.splice( i + 1, 1 );
						}
						if ( !preserveWhitespace ) {
							items[ i ] = items[ i ].replace( contiguousWhitespace, ' ' );
						}
						if ( items[ i ] === '' ) {
							items.splice( i, 1 );
						}
					}
				}
			}
	
			function setDelimiters( source ) {
				var target = arguments[ 1 ];
				if ( target === void 0 )
					target = source;
				target.delimiters = source.delimiters || [
					'{{',
					'}}'
				];
				target.tripleDelimiters = source.tripleDelimiters || [
					'{{{',
					'}}}'
				];
				target.staticDelimiters = source.staticDelimiters || [
					'[[',
					']]'
				];
				target.staticTripleDelimiters = source.staticTripleDelimiters || [
					'[[[',
					']]]'
				];
			}
			return __export;
		}( types, Parser, mustache, comment, element, text, trimWhitespace, stripStandalones, escapeRegExp );
	
		/* config/options/groups/optionGroup.js */
		var optionGroup = function() {
	
			return function createOptionGroup( keys, config ) {
				var group = keys.map( config );
				keys.forEach( function( key, i ) {
					group[ key ] = group[ i ];
				} );
				return group;
			};
		}( legacy );
	
		/* config/options/groups/parseOptions.js */
		var parseOptions = function( optionGroup ) {
	
			var keys, parseOptions;
			keys = [
				'preserveWhitespace',
				'sanitize',
				'stripComments',
				'delimiters',
				'tripleDelimiters',
				'interpolate'
			];
			parseOptions = optionGroup( keys, function( key ) {
				return key;
			} );
			return parseOptions;
		}( optionGroup );
	
		/* config/options/template/parser.js */
		var parser = function( errors, isClient, parse, create, parseOptions ) {
	
			var parser = {
				parse: doParse,
				fromId: fromId,
				isHashedId: isHashedId,
				isParsed: isParsed,
				getParseOptions: getParseOptions,
				createHelper: createHelper
			};
	
			function createHelper( parseOptions ) {
				var helper = create( parser );
				helper.parse = function( template, options ) {
					return doParse( template, options || parseOptions );
				};
				return helper;
			}
	
			function doParse( template, parseOptions ) {
				if ( !parse ) {
					throw new Error( errors.missingParser );
				}
				return parse( template, parseOptions || this.options );
			}
	
			function fromId( id, options ) {
				var template;
				if ( !isClient ) {
					if ( options && options.noThrow ) {
						return;
					}
					throw new Error( 'Cannot retrieve template #' + id + ' as Ractive is not running in a browser.' );
				}
				if ( isHashedId( id ) ) {
					id = id.substring( 1 );
				}
				if ( !( template = document.getElementById( id ) ) ) {
					if ( options && options.noThrow ) {
						return;
					}
					throw new Error( 'Could not find template element with id #' + id );
				}
				if ( template.tagName.toUpperCase() !== 'SCRIPT' ) {
					if ( options && options.noThrow ) {
						return;
					}
					throw new Error( 'Template element with id #' + id + ', must be a <script> element' );
				}
				return template.innerHTML;
			}
	
			function isHashedId( id ) {
				return id && id.charAt( 0 ) === '#';
			}
	
			function isParsed( template ) {
				return !( typeof template === 'string' );
			}
	
			function getParseOptions( ractive ) {
				// Could be Ractive or a Component
				if ( ractive.defaults ) {
					ractive = ractive.defaults;
				}
				return parseOptions.reduce( function( val, key ) {
					val[ key ] = ractive[ key ];
					return val;
				}, {} );
			}
			return parser;
		}( errors, isClient, parse, create, parseOptions );
	
		/* config/options/template/template.js */
		var template = function( parser, parse ) {
	
			var templateConfig = {
				name: 'template',
				extend: function extend( Parent, proto, options ) {
					var template;
					// only assign if exists
					if ( 'template' in options ) {
						template = options.template;
						if ( typeof template === 'function' ) {
							proto.template = template;
						} else {
							proto.template = parseIfString( template, proto );
						}
					}
				},
				init: function init( Parent, ractive, options ) {
					var template, fn;
					// TODO because of prototypal inheritance, we might just be able to use
					// ractive.template, and not bother passing through the Parent object.
					// At present that breaks the test mocks' expectations
					template = 'template' in options ? options.template : Parent.prototype.template;
					if ( typeof template === 'function' ) {
						fn = template;
						template = getDynamicTemplate( ractive, fn );
						ractive._config.template = {
							fn: fn,
							result: template
						};
					}
					template = parseIfString( template, ractive );
					// TODO the naming of this is confusing - ractive.template refers to [...],
					// but Component.prototype.template refers to {v:1,t:[],p:[]}...
					// it's unnecessary, because the developer never needs to access
					// ractive.template
					ractive.template = template.t;
					if ( template.p ) {
						extendPartials( ractive.partials, template.p );
					}
				},
				reset: function( ractive ) {
					var result = resetValue( ractive ),
						parsed;
					if ( result ) {
						parsed = parseIfString( result, ractive );
						ractive.template = parsed.t;
						extendPartials( ractive.partials, parsed.p, true );
						return true;
					}
				}
			};
	
			function resetValue( ractive ) {
				var initial = ractive._config.template,
					result;
				// If this isn't a dynamic template, there's nothing to do
				if ( !initial || !initial.fn ) {
					return;
				}
				result = getDynamicTemplate( ractive, initial.fn );
				// TODO deep equality check to prevent unnecessary re-rendering
				// in the case of already-parsed templates
				if ( result !== initial.result ) {
					initial.result = result;
					result = parseIfString( result, ractive );
					return result;
				}
			}
	
			function getDynamicTemplate( ractive, fn ) {
				var helper = parser.createHelper( parser.getParseOptions( ractive ) );
				return fn.call( ractive, ractive.data, helper );
			}
	
			function parseIfString( template, ractive ) {
				if ( typeof template === 'string' ) {
					// ID of an element containing the template?
					if ( template[ 0 ] === '#' ) {
						template = parser.fromId( template );
					}
					template = parse( template, parser.getParseOptions( ractive ) );
				} else if ( template.v !== 1 ) {
					throw new Error( 'Mismatched template version! Please ensure you are using the latest version of Ractive.js in your build process as well as in your app' );
				}
				return template;
			}
	
			function extendPartials( existingPartials, newPartials, overwrite ) {
				if ( !newPartials )
					return;
				// TODO there's an ambiguity here - we need to overwrite in the `reset()`
				// case, but not initially...
				for ( var key in newPartials ) {
					if ( overwrite || !existingPartials.hasOwnProperty( key ) ) {
						existingPartials[ key ] = newPartials[ key ];
					}
				}
			}
			return templateConfig;
		}( parser, parse );
	
		/* config/options/Registry.js */
		var Registry = function( create ) {
	
			function Registry( name, useDefaults ) {
				this.name = name;
				this.useDefaults = useDefaults;
			}
			Registry.prototype = {
				constructor: Registry,
				extend: function( Parent, proto, options ) {
					this.configure( this.useDefaults ? Parent.defaults : Parent, this.useDefaults ? proto : proto.constructor, options );
				},
				init: function( Parent, ractive, options ) {
					this.configure( this.useDefaults ? Parent.defaults : Parent, ractive, options );
				},
				configure: function( Parent, target, options ) {
					var name = this.name,
						option = options[ name ],
						registry;
					registry = create( Parent[ name ] );
					for ( var key in option ) {
						registry[ key ] = option[ key ];
					}
					target[ name ] = registry;
				},
				reset: function( ractive ) {
					var registry = ractive[ this.name ];
					var changed = false;
					Object.keys( registry ).forEach( function( key ) {
						var item = registry[ key ];
						if ( item._fn ) {
							if ( item._fn.isOwner ) {
								registry[ key ] = item._fn;
							} else {
								delete registry[ key ];
							}
							changed = true;
						}
					} );
					return changed;
				},
				findOwner: function( ractive, key ) {
					return ractive[ this.name ].hasOwnProperty( key ) ? ractive : this.findConstructor( ractive.constructor, key );
				},
				findConstructor: function( constructor, key ) {
					if ( !constructor ) {
						return;
					}
					return constructor[ this.name ].hasOwnProperty( key ) ? constructor : this.findConstructor( constructor._parent, key );
				},
				find: function( ractive, key ) {
					var this$0 = this;
					return recurseFind( ractive, function( r ) {
						return r[ this$0.name ][ key ];
					} );
				},
				findInstance: function( ractive, key ) {
					var this$0 = this;
					return recurseFind( ractive, function( r ) {
						return r[ this$0.name ][ key ] ? r : void 0;
					} );
				}
			};
	
			function recurseFind( ractive, fn ) {
				var find, parent;
				if ( find = fn( ractive ) ) {
					return find;
				}
				if ( !ractive.isolated && ( parent = ractive._parent ) ) {
					return recurseFind( parent, fn );
				}
			}
			return Registry;
		}( create, legacy );
	
		/* config/options/groups/registries.js */
		var registries = function( optionGroup, Registry ) {
	
			var keys = [
					'adaptors',
					'components',
					'computed',
					'decorators',
					'easing',
					'events',
					'interpolators',
					'partials',
					'transitions'
				],
				registries = optionGroup( keys, function( key ) {
					return new Registry( key, key === 'computed' );
				} );
			return registries;
		}( optionGroup, Registry );
	
		/* utils/noop.js */
		var noop = function() {};
	
		/* utils/wrapPrototypeMethod.js */
		var wrapPrototypeMethod = function( noop ) {
	
			var __export;
			__export = function wrap( parent, name, method ) {
				if ( !/_super/.test( method ) ) {
					return method;
				}
				var wrapper = function wrapSuper() {
					var superMethod = getSuperMethod( wrapper._parent, name ),
						hasSuper = '_super' in this,
						oldSuper = this._super,
						result;
					this._super = superMethod;
					result = method.apply( this, arguments );
					if ( hasSuper ) {
						this._super = oldSuper;
					} else {
						delete this._super;
					}
					return result;
				};
				wrapper._parent = parent;
				wrapper._method = method;
				return wrapper;
			};
	
			function getSuperMethod( parent, name ) {
				var method;
				if ( name in parent ) {
					var value = parent[ name ];
					if ( typeof value === 'function' ) {
						method = value;
					} else {
						method = function returnValue() {
							return value;
						};
					}
				} else {
					method = noop;
				}
				return method;
			}
			return __export;
		}( noop );
	
		/* config/deprecate.js */
		var deprecate = function( warn, isArray ) {
	
			function deprecate( options, deprecated, correct ) {
				if ( deprecated in options ) {
					if ( !( correct in options ) ) {
						warn( getMessage( deprecated, correct ) );
						options[ correct ] = options[ deprecated ];
					} else {
						throw new Error( getMessage( deprecated, correct, true ) );
					}
				}
			}
	
			function getMessage( deprecated, correct, isError ) {
				return 'options.' + deprecated + ' has been deprecated in favour of options.' + correct + '.' + ( isError ? ' You cannot specify both options, please use options.' + correct + '.' : '' );
			}
	
			function deprecateEventDefinitions( options ) {
				deprecate( options, 'eventDefinitions', 'events' );
			}
	
			function deprecateAdaptors( options ) {
				// Using extend with Component instead of options,
				// like Human.extend( Spider ) means adaptors as a registry
				// gets copied to options. So we have to check if actually an array
				if ( isArray( options.adaptors ) ) {
					deprecate( options, 'adaptors', 'adapt' );
				}
			}
			return function deprecateOptions( options ) {
				deprecate( options, 'beforeInit', 'onconstruct' );
				deprecate( options, 'init', 'onrender' );
				deprecate( options, 'complete', 'oncomplete' );
				deprecateEventDefinitions( options );
				deprecateAdaptors( options );
			};
		}( warn, isArray );
	
		/* config/config.js */
		var config = function( css, data, defaults, template, parseOptions, registries, wrapPrototype, deprecate ) {
	
			var custom, options, config, blacklisted;
			// would be nice to not have these here,
			// they get added during initialise, so for now we have
			// to make sure not to try and extend them.
			// Possibly, we could re-order and not add till later
			// in process.
			blacklisted = {
				'_parent': true,
				'_component': true
			};
			custom = {
				data: data,
				template: template,
				css: css
			};
			options = Object.keys( defaults ).filter( function( key ) {
				return !registries[ key ] && !custom[ key ] && !parseOptions[ key ];
			} );
			// this defines the order:
			config = [].concat( custom.data, parseOptions, options, registries, custom.template, custom.css );
			for ( var key in custom ) {
				config[ key ] = custom[ key ];
			}
			// for iteration
			config.keys = Object.keys( defaults ).concat( registries.map( function( r ) {
				return r.name;
			} ) ).concat( [ 'css' ] );
			// add these to blacklisted key's that we don't double extend
			config.keys.forEach( function( key ) {
				return blacklisted[ key ] = true;
			} );
			config.parseOptions = parseOptions;
			config.registries = registries;
	
			function customConfig( method, key, Parent, instance, options ) {
				custom[ key ][ method ]( Parent, instance, options );
			}
			config.extend = function( Parent, proto, options ) {
				configure( 'extend', Parent, proto, options );
			};
			config.init = function( Parent, ractive, options ) {
				configure( 'init', Parent, ractive, options );
			};
	
			function isStandardDefaultKey( key ) {
				return key in defaults && !( key in config.parseOptions ) && !( key in custom );
			}
	
			function configure( method, Parent, instance, options ) {
				deprecate( options );
				customConfig( method, 'data', Parent, instance, options );
				config.parseOptions.forEach( function( key ) {
					if ( key in options ) {
						instance[ key ] = options[ key ];
					}
				} );
				for ( var key in options ) {
					if ( isStandardDefaultKey( key ) ) {
						var value = options[ key ];
						instance[ key ] = typeof value === 'function' ? wrapPrototype( Parent.prototype, key, value ) : value;
					}
				}
				config.registries.forEach( function( registry ) {
					registry[ method ]( Parent, instance, options );
				} );
				customConfig( method, 'template', Parent, instance, options );
				customConfig( method, 'css', Parent, instance, options );
				extendOtherMethods( Parent.prototype, instance, options );
			}
	
			function extendOtherMethods( parent, instance, options ) {
				for ( var key in options ) {
					if ( !( key in blacklisted ) && options.hasOwnProperty( key ) ) {
						var member = options[ key ];
						// if this is a method that overwrites a method, wrap it:
						if ( typeof member === 'function' ) {
							member = wrapPrototype( parent, key, member );
						}
						instance[ key ] = member;
					}
				}
			}
			config.reset = function( ractive ) {
				return config.filter( function( c ) {
					return c.reset && c.reset( ractive );
				} ).map( function( c ) {
					return c.name;
				} );
			};
			config.getConstructTarget = function( ractive, options ) {
				if ( options.onconstruct ) {
					// pretend this object literal is the ractive instance
					return {
						onconstruct: wrapPrototype( ractive, 'onconstruct', options.onconstruct ).bind( ractive ),
						fire: ractive.fire.bind( ractive )
					};
				} else {
					return ractive;
				}
			};
			return config;
		}( css, data, options, template, parseOptions, registries, wrapPrototypeMethod, deprecate );
	
		/* shared/interpolate.js */
		var interpolate = function( circular, warn, interpolators, config ) {
	
			var __export;
			var interpolate = function( from, to, ractive, type ) {
				if ( from === to ) {
					return snap( to );
				}
				if ( type ) {
					var interpol = config.registries.interpolators.find( ractive, type );
					if ( interpol ) {
						return interpol( from, to ) || snap( to );
					}
					warn( 'Missing "' + type + '" interpolator. You may need to download a plugin from [TODO]' );
				}
				return interpolators.number( from, to ) || interpolators.array( from, to ) || interpolators.object( from, to ) || snap( to );
			};
			circular.interpolate = interpolate;
			__export = interpolate;
	
			function snap( to ) {
				return function() {
					return to;
				};
			}
			return __export;
		}( circular, warn, interpolators, config );
	
		/* Ractive/prototype/animate/Animation.js */
		var Ractive$animate_Animation = function( warn, runloop, interpolate ) {
	
			var Animation = function( options ) {
				var key;
				this.startTime = Date.now();
				// from and to
				for ( key in options ) {
					if ( options.hasOwnProperty( key ) ) {
						this[ key ] = options[ key ];
					}
				}
				this.interpolator = interpolate( this.from, this.to, this.root, this.interpolator );
				this.running = true;
				this.tick();
			};
			Animation.prototype = {
				tick: function() {
					var elapsed, t, value, timeNow, index, keypath;
					keypath = this.keypath;
					if ( this.running ) {
						timeNow = Date.now();
						elapsed = timeNow - this.startTime;
						if ( elapsed >= this.duration ) {
							if ( keypath !== null ) {
								runloop.start( this.root );
								this.root.viewmodel.set( keypath, this.to );
								runloop.end();
							}
							if ( this.step ) {
								this.step( 1, this.to );
							}
							this.complete( this.to );
							index = this.root._animations.indexOf( this );
							// TODO investigate why this happens
							if ( index === -1 ) {
								warn( 'Animation was not found' );
							}
							this.root._animations.splice( index, 1 );
							this.running = false;
							return false;
						}
						t = this.easing ? this.easing( elapsed / this.duration ) : elapsed / this.duration;
						if ( keypath !== null ) {
							value = this.interpolator( t );
							runloop.start( this.root );
							this.root.viewmodel.set( keypath, value );
							runloop.end();
						}
						if ( this.step ) {
							this.step( t, value );
						}
						return true;
					}
					return false;
				},
				stop: function() {
					var index;
					this.running = false;
					index = this.root._animations.indexOf( this );
					// TODO investigate why this happens
					if ( index === -1 ) {
						warn( 'Animation was not found' );
					}
					this.root._animations.splice( index, 1 );
				}
			};
			return Animation;
		}( warn, runloop, interpolate );
	
		/* Ractive/prototype/animate.js */
		var Ractive$animate = function( isEqual, Promise, normaliseKeypath, animations, Animation ) {
	
			var __export;
			var noop = function() {},
				noAnimation = {
					stop: noop
				};
			__export = function Ractive$animate( keypath, to, options ) {
				var promise, fulfilPromise, k, animation, animations, easing, duration, step, complete, makeValueCollector, currentValues, collectValue, dummy, dummyOptions;
				promise = new Promise( function( fulfil ) {
					fulfilPromise = fulfil;
				} );
				// animate multiple keypaths
				if ( typeof keypath === 'object' ) {
					options = to || {};
					easing = options.easing;
					duration = options.duration;
					animations = [];
					// we don't want to pass the `step` and `complete` handlers, as they will
					// run for each animation! So instead we'll store the handlers and create
					// our own...
					step = options.step;
					complete = options.complete;
					if ( step || complete ) {
						currentValues = {};
						options.step = null;
						options.complete = null;
						makeValueCollector = function( keypath ) {
							return function( t, value ) {
								currentValues[ keypath ] = value;
							};
						};
					}
					for ( k in keypath ) {
						if ( keypath.hasOwnProperty( k ) ) {
							if ( step || complete ) {
								collectValue = makeValueCollector( k );
								options = {
									easing: easing,
									duration: duration
								};
								if ( step ) {
									options.step = collectValue;
								}
							}
							options.complete = complete ? collectValue : noop;
							animations.push( animate( this, k, keypath[ k ], options ) );
						}
					}
					// Create a dummy animation, to facilitate step/complete
					// callbacks, and Promise fulfilment
					dummyOptions = {
						easing: easing,
						duration: duration
					};
					if ( step ) {
						dummyOptions.step = function( t ) {
							step( t, currentValues );
						};
					}
					if ( complete ) {
						promise.then( function( t ) {
							complete( t, currentValues );
						} );
					}
					dummyOptions.complete = fulfilPromise;
					dummy = animate( this, null, null, dummyOptions );
					animations.push( dummy );
					promise.stop = function() {
						var animation;
						while ( animation = animations.pop() ) {
							animation.stop();
						}
						if ( dummy ) {
							dummy.stop();
						}
					};
					return promise;
				}
				// animate a single keypath
				options = options || {};
				if ( options.complete ) {
					promise.then( options.complete );
				}
				options.complete = fulfilPromise;
				animation = animate( this, keypath, to, options );
				promise.stop = function() {
					animation.stop();
				};
				return promise;
			};
	
			function animate( root, keypath, to, options ) {
				var easing, duration, animation, from;
				if ( keypath ) {
					keypath = normaliseKeypath( keypath );
				}
				if ( keypath !== null ) {
					from = root.viewmodel.get( keypath );
				}
				// cancel any existing animation
				// TODO what about upstream/downstream keypaths?
				animations.abort( keypath, root );
				// don't bother animating values that stay the same
				if ( isEqual( from, to ) ) {
					if ( options.complete ) {
						options.complete( options.to );
					}
					return noAnimation;
				}
				// easing function
				if ( options.easing ) {
					if ( typeof options.easing === 'function' ) {
						easing = options.easing;
					} else {
						easing = root.easing[ options.easing ];
					}
					if ( typeof easing !== 'function' ) {
						easing = null;
					}
				}
				// duration
				duration = options.duration === undefined ? 400 : options.duration;
				// TODO store keys, use an internal set method
				animation = new Animation( {
					keypath: keypath,
					from: from,
					to: to,
					root: root,
					duration: duration,
					easing: easing,
					interpolator: options.interpolator,
					// TODO wrap callbacks if necessary, to use instance as context
					step: options.step,
					complete: options.complete
				} );
				animations.add( animation );
				root._animations.push( animation );
				return animation;
			}
			return __export;
		}( isEqual, Promise, normaliseKeypath, animations, Ractive$animate_Animation );
	
		/* Ractive/prototype/detach.js */
		var Ractive$detach = function( Hook, removeFromArray ) {
	
			var detachHook = new Hook( 'detach' );
			return function Ractive$detach() {
				if ( this.detached ) {
					return this.detached;
				}
				if ( this.el ) {
					removeFromArray( this.el.__ractive_instances__, this );
				}
				this.detached = this.fragment.detach();
				detachHook.fire( this );
				return this.detached;
			};
		}( Ractive$shared_hooks_Hook, removeFromArray );
	
		/* Ractive/prototype/find.js */
		var Ractive$find = function Ractive$find( selector ) {
			if ( !this.el ) {
				return null;
			}
			return this.fragment.find( selector );
		};
	
		/* utils/matches.js */
		var matches = function( isClient, vendors, createElement ) {
	
			var matches, div, methodNames, unprefixed, prefixed, i, j, makeFunction;
			if ( !isClient ) {
				matches = null;
			} else {
				div = createElement( 'div' );
				methodNames = [
					'matches',
					'matchesSelector'
				];
				makeFunction = function( methodName ) {
					return function( node, selector ) {
						return node[ methodName ]( selector );
					};
				};
				i = methodNames.length;
				while ( i-- && !matches ) {
					unprefixed = methodNames[ i ];
					if ( div[ unprefixed ] ) {
						matches = makeFunction( unprefixed );
					} else {
						j = vendors.length;
						while ( j-- ) {
							prefixed = vendors[ i ] + unprefixed.substr( 0, 1 ).toUpperCase() + unprefixed.substring( 1 );
							if ( div[ prefixed ] ) {
								matches = makeFunction( prefixed );
								break;
							}
						}
					}
				}
				// IE8...
				if ( !matches ) {
					matches = function( node, selector ) {
						var nodes, parentNode, i;
						parentNode = node.parentNode;
						if ( !parentNode ) {
							// empty dummy <div>
							div.innerHTML = '';
							parentNode = div;
							node = node.cloneNode();
							div.appendChild( node );
						}
						nodes = parentNode.querySelectorAll( selector );
						i = nodes.length;
						while ( i-- ) {
							if ( nodes[ i ] === node ) {
								return true;
							}
						}
						return false;
					};
				}
			}
			return matches;
		}( isClient, vendors, createElement );
	
		/* Ractive/prototype/shared/makeQuery/test.js */
		var Ractive$shared_makeQuery_test = function( matches ) {
	
			return function( item, noDirty ) {
				var itemMatches = this._isComponentQuery ? !this.selector || item.name === this.selector : matches( item.node, this.selector );
				if ( itemMatches ) {
					this.push( item.node || item.instance );
					if ( !noDirty ) {
						this._makeDirty();
					}
					return true;
				}
			};
		}( matches );
	
		/* Ractive/prototype/shared/makeQuery/cancel.js */
		var Ractive$shared_makeQuery_cancel = function() {
			var liveQueries, selector, index;
			liveQueries = this._root[ this._isComponentQuery ? 'liveComponentQueries' : 'liveQueries' ];
			selector = this.selector;
			index = liveQueries.indexOf( selector );
			if ( index !== -1 ) {
				liveQueries.splice( index, 1 );
				liveQueries[ selector ] = null;
			}
		};
	
		/* Ractive/prototype/shared/makeQuery/sortByItemPosition.js */
		var Ractive$shared_makeQuery_sortByItemPosition = function() {
	
			var __export;
			__export = function( a, b ) {
				var ancestryA, ancestryB, oldestA, oldestB, mutualAncestor, indexA, indexB, fragments, fragmentA, fragmentB;
				ancestryA = getAncestry( a.component || a._ractive.proxy );
				ancestryB = getAncestry( b.component || b._ractive.proxy );
				oldestA = ancestryA[ ancestryA.length - 1 ];
				oldestB = ancestryB[ ancestryB.length - 1 ];
				// remove items from the end of both ancestries as long as they are identical
				// - the final one removed is the closest mutual ancestor
				while ( oldestA && oldestA === oldestB ) {
					ancestryA.pop();
					ancestryB.pop();
					mutualAncestor = oldestA;
					oldestA = ancestryA[ ancestryA.length - 1 ];
					oldestB = ancestryB[ ancestryB.length - 1 ];
				}
				// now that we have the mutual ancestor, we can find which is earliest
				oldestA = oldestA.component || oldestA;
				oldestB = oldestB.component || oldestB;
				fragmentA = oldestA.parentFragment;
				fragmentB = oldestB.parentFragment;
				// if both items share a parent fragment, our job is easy
				if ( fragmentA === fragmentB ) {
					indexA = fragmentA.items.indexOf( oldestA );
					indexB = fragmentB.items.indexOf( oldestB );
					// if it's the same index, it means one contains the other,
					// so we see which has the longest ancestry
					return indexA - indexB || ancestryA.length - ancestryB.length;
				}
				// if mutual ancestor is a section, we first test to see which section
				// fragment comes first
				if ( fragments = mutualAncestor.fragments ) {
					indexA = fragments.indexOf( fragmentA );
					indexB = fragments.indexOf( fragmentB );
					return indexA - indexB || ancestryA.length - ancestryB.length;
				}
				throw new Error( 'An unexpected condition was met while comparing the position of two components. Please file an issue at https://github.com/RactiveJS/Ractive/issues - thanks!' );
			};
	
			function getParent( item ) {
				var parentFragment;
				if ( parentFragment = item.parentFragment ) {
					return parentFragment.owner;
				}
				if ( item.component && ( parentFragment = item.component.parentFragment ) ) {
					return parentFragment.owner;
				}
			}
	
			function getAncestry( item ) {
				var ancestry, ancestor;
				ancestry = [ item ];
				ancestor = getParent( item );
				while ( ancestor ) {
					ancestry.push( ancestor );
					ancestor = getParent( ancestor );
				}
				return ancestry;
			}
			return __export;
		}();
	
		/* Ractive/prototype/shared/makeQuery/sortByDocumentPosition.js */
		var Ractive$shared_makeQuery_sortByDocumentPosition = function( sortByItemPosition ) {
	
			return function( node, otherNode ) {
				var bitmask;
				if ( node.compareDocumentPosition ) {
					bitmask = node.compareDocumentPosition( otherNode );
					return bitmask & 2 ? 1 : -1;
				}
				// In old IE, we can piggy back on the mechanism for
				// comparing component positions
				return sortByItemPosition( node, otherNode );
			};
		}( Ractive$shared_makeQuery_sortByItemPosition );
	
		/* Ractive/prototype/shared/makeQuery/sort.js */
		var Ractive$shared_makeQuery_sort = function( sortByDocumentPosition, sortByItemPosition ) {
	
			return function() {
				this.sort( this._isComponentQuery ? sortByItemPosition : sortByDocumentPosition );
				this._dirty = false;
			};
		}( Ractive$shared_makeQuery_sortByDocumentPosition, Ractive$shared_makeQuery_sortByItemPosition );
	
		/* Ractive/prototype/shared/makeQuery/dirty.js */
		var Ractive$shared_makeQuery_dirty = function( runloop ) {
	
			return function() {
				var this$0 = this;
				if ( !this._dirty ) {
					this._dirty = true;
					// Once the DOM has been updated, ensure the query
					// is correctly ordered
					runloop.scheduleTask( function() {
						this$0._sort();
					} );
				}
			};
		}( runloop );
	
		/* Ractive/prototype/shared/makeQuery/remove.js */
		var Ractive$shared_makeQuery_remove = function( nodeOrComponent ) {
			var index = this.indexOf( this._isComponentQuery ? nodeOrComponent.instance : nodeOrComponent );
			if ( index !== -1 ) {
				this.splice( index, 1 );
			}
		};
	
		/* Ractive/prototype/shared/makeQuery/_makeQuery.js */
		var Ractive$shared_makeQuery__makeQuery = function( defineProperties, test, cancel, sort, dirty, remove ) {
	
			return function makeQuery( ractive, selector, live, isComponentQuery ) {
				var query = [];
				defineProperties( query, {
					selector: {
						value: selector
					},
					live: {
						value: live
					},
					_isComponentQuery: {
						value: isComponentQuery
					},
					_test: {
						value: test
					}
				} );
				if ( !live ) {
					return query;
				}
				defineProperties( query, {
					cancel: {
						value: cancel
					},
					_root: {
						value: ractive
					},
					_sort: {
						value: sort
					},
					_makeDirty: {
						value: dirty
					},
					_remove: {
						value: remove
					},
					_dirty: {
						value: false,
						writable: true
					}
				} );
				return query;
			};
		}( defineProperties, Ractive$shared_makeQuery_test, Ractive$shared_makeQuery_cancel, Ractive$shared_makeQuery_sort, Ractive$shared_makeQuery_dirty, Ractive$shared_makeQuery_remove );
	
		/* Ractive/prototype/findAll.js */
		var Ractive$findAll = function( makeQuery ) {
	
			return function Ractive$findAll( selector, options ) {
				var liveQueries, query;
				if ( !this.el ) {
					return [];
				}
				options = options || {};
				liveQueries = this._liveQueries;
				// Shortcut: if we're maintaining a live query with this
				// selector, we don't need to traverse the parallel DOM
				if ( query = liveQueries[ selector ] ) {
					// Either return the exact same query, or (if not live) a snapshot
					return options && options.live ? query : query.slice();
				}
				query = makeQuery( this, selector, !!options.live, false );
				// Add this to the list of live queries Ractive needs to maintain,
				// if applicable
				if ( query.live ) {
					liveQueries.push( selector );
					liveQueries[ '_' + selector ] = query;
				}
				this.fragment.findAll( selector, query );
				return query;
			};
		}( Ractive$shared_makeQuery__makeQuery );
	
		/* Ractive/prototype/findAllComponents.js */
		var Ractive$findAllComponents = function( makeQuery ) {
	
			return function Ractive$findAllComponents( selector, options ) {
				var liveQueries, query;
				options = options || {};
				liveQueries = this._liveComponentQueries;
				// Shortcut: if we're maintaining a live query with this
				// selector, we don't need to traverse the parallel DOM
				if ( query = liveQueries[ selector ] ) {
					// Either return the exact same query, or (if not live) a snapshot
					return options && options.live ? query : query.slice();
				}
				query = makeQuery( this, selector, !!options.live, true );
				// Add this to the list of live queries Ractive needs to maintain,
				// if applicable
				if ( query.live ) {
					liveQueries.push( selector );
					liveQueries[ '_' + selector ] = query;
				}
				this.fragment.findAllComponents( selector, query );
				return query;
			};
		}( Ractive$shared_makeQuery__makeQuery );
	
		/* Ractive/prototype/findComponent.js */
		var Ractive$findComponent = function Ractive$findComponent( selector ) {
			return this.fragment.findComponent( selector );
		};
	
		/* utils/getPotentialWildcardMatches.js */
		var getPotentialWildcardMatches = function() {
	
			var __export;
			var starMaps = {};
			// This function takes a keypath such as 'foo.bar.baz', and returns
			// all the variants of that keypath that include a wildcard in place
			// of a key, such as 'foo.bar.*', 'foo.*.baz', 'foo.*.*' and so on.
			// These are then checked against the dependants map (ractive.viewmodel.depsMap)
			// to see if any pattern observers are downstream of one or more of
			// these wildcard keypaths (e.g. 'foo.bar.*.status')
			__export = function getPotentialWildcardMatches( keypath ) {
				var keys, starMap, mapper, i, result, wildcardKeypath;
				keys = keypath.split( '.' );
				if ( !( starMap = starMaps[ keys.length ] ) ) {
					starMap = getStarMap( keys.length );
				}
				result = [];
				mapper = function( star, i ) {
					return star ? '*' : keys[ i ];
				};
				i = starMap.length;
				while ( i-- ) {
					wildcardKeypath = starMap[ i ].map( mapper ).join( '.' );
					if ( !result.hasOwnProperty( wildcardKeypath ) ) {
						result.push( wildcardKeypath );
						result[ wildcardKeypath ] = true;
					}
				}
				return result;
			};
			// This function returns all the possible true/false combinations for
			// a given number - e.g. for two, the possible combinations are
			// [ true, true ], [ true, false ], [ false, true ], [ false, false ].
			// It does so by getting all the binary values between 0 and e.g. 11
			function getStarMap( num ) {
				var ones = '',
					max, binary, starMap, mapper, i;
				if ( !starMaps[ num ] ) {
					starMap = [];
					while ( ones.length < num ) {
						ones += 1;
					}
					max = parseInt( ones, 2 );
					mapper = function( digit ) {
						return digit === '1';
					};
					for ( i = 0; i <= max; i += 1 ) {
						binary = i.toString( 2 );
						while ( binary.length < num ) {
							binary = '0' + binary;
						}
						starMap[ i ] = Array.prototype.map.call( binary, mapper );
					}
					starMaps[ num ] = starMap;
				}
				return starMaps[ num ];
			}
			return __export;
		}();
	
		/* Ractive/prototype/shared/fireEvent.js */
		var Ractive$shared_fireEvent = function( getPotentialWildcardMatches ) {
	
			var __export;
			__export = function fireEvent( ractive, eventName ) {
				var options = arguments[ 2 ];
				if ( options === void 0 )
					options = {};
				if ( !eventName ) {
					return;
				}
				if ( !options.event ) {
					options.event = {
						name: eventName,
						context: ractive.data,
						keypath: '',
						// until event not included as argument default
						_noArg: true
					};
				} else {
					options.event.name = eventName;
				}
				var eventNames = getPotentialWildcardMatches( eventName );
				fireEventAs( ractive, eventNames, options.event, options.args, true );
			};
	
			function fireEventAs( ractive, eventNames, event, args ) {
				var initialFire = arguments[ 4 ];
				if ( initialFire === void 0 )
					initialFire = false;
				var subscribers, i, bubble = true;
				if ( event ) {
					ractive.event = event;
				}
				for ( i = eventNames.length; i >= 0; i-- ) {
					subscribers = ractive._subs[ eventNames[ i ] ];
					if ( subscribers ) {
						bubble = notifySubscribers( ractive, subscribers, event, args ) && bubble;
					}
				}
				if ( event ) {
					delete ractive.event;
				}
				if ( ractive._parent && bubble ) {
					if ( initialFire && ractive.component ) {
						var fullName = ractive.component.name + '.' + eventNames[ eventNames.length - 1 ];
						eventNames = getPotentialWildcardMatches( fullName );
						if ( event ) {
							event.component = ractive;
						}
					}
					fireEventAs( ractive._parent, eventNames, event, args );
				}
			}
	
			function notifySubscribers( ractive, subscribers, event, args ) {
				var originalEvent = null,
					stopEvent = false;
				if ( event && !event._noArg ) {
					args = [ event ].concat( args );
				}
				for ( var i = 0, len = subscribers.length; i < len; i += 1 ) {
					if ( subscribers[ i ].apply( ractive, args ) === false ) {
						stopEvent = true;
					}
				}
				if ( event && !event._noArg && stopEvent && ( originalEvent = event.original ) ) {
					originalEvent.preventDefault && originalEvent.preventDefault();
					originalEvent.stopPropagation && originalEvent.stopPropagation();
				}
				return !stopEvent;
			}
			return __export;
		}( getPotentialWildcardMatches );
	
		/* Ractive/prototype/fire.js */
		var Ractive$fire = function( fireEvent ) {
	
			return function Ractive$fire( eventName ) {
				var options = {
					args: Array.prototype.slice.call( arguments, 1 )
				};
				fireEvent( this, eventName, options );
			};
		}( Ractive$shared_fireEvent );
	
		/* Ractive/prototype/get.js */
		var Ractive$get = function( normaliseKeypath, resolveRef ) {
	
			var options = {
				capture: true
			};
			// top-level calls should be intercepted
			return function Ractive$get( keypath ) {
				var value;
				keypath = normaliseKeypath( keypath );
				value = this.viewmodel.get( keypath, options );
				// Create inter-component binding, if necessary
				if ( value === undefined && this._parent && !this.isolated ) {
					if ( resolveRef( this, keypath, this.fragment ) ) {
						// creates binding as side-effect, if appropriate
						value = this.viewmodel.get( keypath );
					}
				}
				return value;
			};
		}( normaliseKeypath, resolveRef );
	
		/* utils/getElement.js */
		var getElement = function getElement( input ) {
			var output;
			if ( !input || typeof input === 'boolean' ) {
				return;
			}
			if ( typeof window === 'undefined' || !document || !input ) {
				return null;
			}
			// We already have a DOM node - no work to do. (Duck typing alert!)
			if ( input.nodeType ) {
				return input;
			}
			// Get node from string
			if ( typeof input === 'string' ) {
				// try ID first
				output = document.getElementById( input );
				// then as selector, if possible
				if ( !output && document.querySelector ) {
					output = document.querySelector( input );
				}
				// did it work?
				if ( output && output.nodeType ) {
					return output;
				}
			}
			// If we've been given a collection (jQuery, Zepto etc), extract the first item
			if ( input[ 0 ] && input[ 0 ].nodeType ) {
				return input[ 0 ];
			}
			return null;
		};
	
		/* Ractive/prototype/insert.js */
		var Ractive$insert = function( Hook, getElement ) {
	
			var __export;
			var insertHook = new Hook( 'insert' );
			__export = function Ractive$insert( target, anchor ) {
				if ( !this.fragment.rendered ) {
					// TODO create, and link to, documentation explaining this
					throw new Error( 'The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.' );
				}
				target = getElement( target );
				anchor = getElement( anchor ) || null;
				if ( !target ) {
					throw new Error( 'You must specify a valid target to insert into' );
				}
				target.insertBefore( this.detach(), anchor );
				this.el = target;
				( target.__ractive_instances__ || ( target.__ractive_instances__ = [] ) ).push( this );
				this.detached = null;
				fireInsertHook( this );
			};
	
			function fireInsertHook( ractive ) {
				insertHook.fire( ractive );
				ractive.findAllComponents( '*' ).forEach( function( child ) {
					fireInsertHook( child.instance );
				} );
			}
			return __export;
		}( Ractive$shared_hooks_Hook, getElement );
	
		/* Ractive/prototype/merge.js */
		var Ractive$merge = function( runloop, isArray, normaliseKeypath ) {
	
			return function Ractive$merge( keypath, array, options ) {
				var currentArray, promise;
				keypath = normaliseKeypath( keypath );
				currentArray = this.viewmodel.get( keypath );
				// If either the existing value or the new value isn't an
				// array, just do a regular set
				if ( !isArray( currentArray ) || !isArray( array ) ) {
					return this.set( keypath, array, options && options.complete );
				}
				// Manage transitions
				promise = runloop.start( this, true );
				this.viewmodel.merge( keypath, currentArray, array, options );
				runloop.end();
				// attach callback as fulfilment handler, if specified
				if ( options && options.complete ) {
					promise.then( options.complete );
				}
				return promise;
			};
		}( runloop, isArray, normaliseKeypath );
	
		/* Ractive/prototype/observe/Observer.js */
		var Ractive$observe_Observer = function( runloop, isEqual ) {
	
			var Observer = function( ractive, keypath, callback, options ) {
				this.root = ractive;
				this.keypath = keypath;
				this.callback = callback;
				this.defer = options.defer;
				// default to root as context, but allow it to be overridden
				this.context = options && options.context ? options.context : ractive;
			};
			Observer.prototype = {
				init: function( immediate ) {
					this.value = this.root.get( this.keypath );
					if ( immediate !== false ) {
						this.update();
					} else {
						this.oldValue = this.value;
					}
				},
				setValue: function( value ) {
					var this$0 = this;
					if ( !isEqual( value, this.value ) ) {
						this.value = value;
						if ( this.defer && this.ready ) {
							runloop.scheduleTask( function() {
								return this$0.update();
							} );
						} else {
							this.update();
						}
					}
				},
				update: function() {
					// Prevent infinite loops
					if ( this.updating ) {
						return;
					}
					this.updating = true;
					this.callback.call( this.context, this.value, this.oldValue, this.keypath );
					this.oldValue = this.value;
					this.updating = false;
				}
			};
			return Observer;
		}( runloop, isEqual );
	
		/* shared/getMatchingKeypaths.js */
		var getMatchingKeypaths = function( isArray ) {
	
			return function getMatchingKeypaths( ractive, pattern ) {
				var keys, key, matchingKeypaths;
				keys = pattern.split( '.' );
				matchingKeypaths = [ '' ];
				while ( key = keys.shift() ) {
					if ( key === '*' ) {
						// expand to find all valid child keypaths
						matchingKeypaths = matchingKeypaths.reduce( expand, [] );
					} else {
						if ( matchingKeypaths[ 0 ] === '' ) {
							// first key
							matchingKeypaths[ 0 ] = key;
						} else {
							matchingKeypaths = matchingKeypaths.map( concatenate( key ) );
						}
					}
				}
				return matchingKeypaths;
	
				function expand( matchingKeypaths, keypath ) {
					var value, key, childKeypath;
					value = ractive.viewmodel.wrapped[ keypath ] ? ractive.viewmodel.wrapped[ keypath ].get() : ractive.get( keypath );
					for ( key in value ) {
						if ( value.hasOwnProperty( key ) && ( key !== '_ractive' || !isArray( value ) ) ) {
							// for benefit of IE8
							childKeypath = keypath ? keypath + '.' + key : key;
							matchingKeypaths.push( childKeypath );
						}
					}
					return matchingKeypaths;
				}
	
				function concatenate( key ) {
					return function( keypath ) {
						return keypath ? keypath + '.' + key : key;
					};
				}
			};
		}( isArray );
	
		/* Ractive/prototype/observe/getPattern.js */
		var Ractive$observe_getPattern = function( getMatchingKeypaths ) {
	
			return function getPattern( ractive, pattern ) {
				var matchingKeypaths, values;
				matchingKeypaths = getMatchingKeypaths( ractive, pattern );
				values = {};
				matchingKeypaths.forEach( function( keypath ) {
					values[ keypath ] = ractive.get( keypath );
				} );
				return values;
			};
		}( getMatchingKeypaths );
	
		/* Ractive/prototype/observe/PatternObserver.js */
		var Ractive$observe_PatternObserver = function( runloop, isEqual, getPattern ) {
	
			var PatternObserver, wildcard = /\*/,
				slice = Array.prototype.slice;
			PatternObserver = function( ractive, keypath, callback, options ) {
				this.root = ractive;
				this.callback = callback;
				this.defer = options.defer;
				this.keypath = keypath;
				this.regex = new RegExp( '^' + keypath.replace( /\./g, '\\.' ).replace( /\*/g, '([^\\.]+)' ) + '$' );
				this.values = {};
				if ( this.defer ) {
					this.proxies = [];
				}
				// default to root as context, but allow it to be overridden
				this.context = options && options.context ? options.context : ractive;
			};
			PatternObserver.prototype = {
				init: function( immediate ) {
					var values, keypath;
					values = getPattern( this.root, this.keypath );
					if ( immediate !== false ) {
						for ( keypath in values ) {
							if ( values.hasOwnProperty( keypath ) ) {
								this.update( keypath );
							}
						}
					} else {
						this.values = values;
					}
				},
				update: function( keypath ) {
					var this$0 = this;
					var values;
					if ( wildcard.test( keypath ) ) {
						values = getPattern( this.root, keypath );
						for ( keypath in values ) {
							if ( values.hasOwnProperty( keypath ) ) {
								this.update( keypath );
							}
						}
						return;
					}
					// special case - array mutation should not trigger `array.*`
					// pattern observer with `array.length`
					if ( this.root.viewmodel.implicitChanges[ keypath ] ) {
						return;
					}
					if ( this.defer && this.ready ) {
						runloop.scheduleTask( function() {
							return this$0.getProxy( keypath ).update();
						} );
						return;
					}
					this.reallyUpdate( keypath );
				},
				reallyUpdate: function( keypath ) {
					var value, keys, args;
					value = this.root.viewmodel.get( keypath );
					// Prevent infinite loops
					if ( this.updating ) {
						this.values[ keypath ] = value;
						return;
					}
					this.updating = true;
					if ( !isEqual( value, this.values[ keypath ] ) || !this.ready ) {
						keys = slice.call( this.regex.exec( keypath ), 1 );
						args = [
							value,
							this.values[ keypath ],
							keypath
						].concat( keys );
						this.callback.apply( this.context, args );
						this.values[ keypath ] = value;
					}
					this.updating = false;
				},
				getProxy: function( keypath ) {
					var self = this;
					if ( !this.proxies[ keypath ] ) {
						this.proxies[ keypath ] = {
							update: function() {
								self.reallyUpdate( keypath );
							}
						};
					}
					return this.proxies[ keypath ];
				}
			};
			return PatternObserver;
		}( runloop, isEqual, Ractive$observe_getPattern );
	
		/* Ractive/prototype/observe/getObserverFacade.js */
		var Ractive$observe_getObserverFacade = function( normaliseKeypath, Observer, PatternObserver ) {
	
			var wildcard = /\*/,
				emptyObject = {};
			return function getObserverFacade( ractive, keypath, callback, options ) {
				var observer, isPatternObserver, cancelled;
				keypath = normaliseKeypath( keypath );
				options = options || emptyObject;
				// pattern observers are treated differently
				if ( wildcard.test( keypath ) ) {
					observer = new PatternObserver( ractive, keypath, callback, options );
					ractive.viewmodel.patternObservers.push( observer );
					isPatternObserver = true;
				} else {
					observer = new Observer( ractive, keypath, callback, options );
				}
				ractive.viewmodel.register( keypath, observer, isPatternObserver ? 'patternObservers' : 'observers' );
				observer.init( options.init );
				// This flag allows observers to initialise even with undefined values
				observer.ready = true;
				return {
					cancel: function() {
						var index;
						if ( cancelled ) {
							return;
						}
						if ( isPatternObserver ) {
							index = ractive.viewmodel.patternObservers.indexOf( observer );
							ractive.viewmodel.patternObservers.splice( index, 1 );
							ractive.viewmodel.unregister( keypath, observer, 'patternObservers' );
						} else {
							ractive.viewmodel.unregister( keypath, observer, 'observers' );
						}
						cancelled = true;
					}
				};
			};
		}( normaliseKeypath, Ractive$observe_Observer, Ractive$observe_PatternObserver );
	
		/* Ractive/prototype/observe.js */
		var Ractive$observe = function( isObject, getObserverFacade ) {
	
			return function Ractive$observe( keypath, callback, options ) {
				var observers, map, keypaths, i;
				// Allow a map of keypaths to handlers
				if ( isObject( keypath ) ) {
					options = callback;
					map = keypath;
					observers = [];
					for ( keypath in map ) {
						if ( map.hasOwnProperty( keypath ) ) {
							callback = map[ keypath ];
							observers.push( this.observe( keypath, callback, options ) );
						}
					}
					return {
						cancel: function() {
							while ( observers.length ) {
								observers.pop().cancel();
							}
						}
					};
				}
				// Allow `ractive.observe( callback )` - i.e. observe entire model
				if ( typeof keypath === 'function' ) {
					options = callback;
					callback = keypath;
					keypath = '';
					return getObserverFacade( this, keypath, callback, options );
				}
				keypaths = keypath.split( ' ' );
				// Single keypath
				if ( keypaths.length === 1 ) {
					return getObserverFacade( this, keypath, callback, options );
				}
				// Multiple space-separated keypaths
				observers = [];
				i = keypaths.length;
				while ( i-- ) {
					keypath = keypaths[ i ];
					if ( keypath ) {
						observers.push( getObserverFacade( this, keypath, callback, options ) );
					}
				}
				return {
					cancel: function() {
						while ( observers.length ) {
							observers.pop().cancel();
						}
					}
				};
			};
		}( isObject, Ractive$observe_getObserverFacade );
	
		/* Ractive/prototype/shared/trim.js */
		var Ractive$shared_trim = function( str ) {
			return str.trim();
		};
	
		/* Ractive/prototype/shared/notEmptyString.js */
		var Ractive$shared_notEmptyString = function( str ) {
			return str !== '';
		};
	
		/* Ractive/prototype/off.js */
		var Ractive$off = function( trim, notEmptyString ) {
	
			return function Ractive$off( eventName, callback ) {
				var this$0 = this;
				var eventNames;
				// if no arguments specified, remove all callbacks
				if ( !eventName ) {
					// TODO use this code instead, once the following issue has been resolved
					// in PhantomJS (tests are unpassable otherwise!)
					// https://github.com/ariya/phantomjs/issues/11856
					// defineProperty( this, '_subs', { value: create( null ), configurable: true });
					for ( eventName in this._subs ) {
						delete this._subs[ eventName ];
					}
				} else {
					// Handle multiple space-separated event names
					eventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );
					eventNames.forEach( function( eventName ) {
						var subscribers, index;
						// If we have subscribers for this event...
						if ( subscribers = this$0._subs[ eventName ] ) {
							// ...if a callback was specified, only remove that
							if ( callback ) {
								index = subscribers.indexOf( callback );
								if ( index !== -1 ) {
									subscribers.splice( index, 1 );
								}
							} else {
								this$0._subs[ eventName ] = [];
							}
						}
					} );
				}
				return this;
			};
		}( Ractive$shared_trim, Ractive$shared_notEmptyString );
	
		/* Ractive/prototype/on.js */
		var Ractive$on = function( trim, notEmptyString ) {
	
			return function Ractive$on( eventName, callback ) {
				var this$0 = this;
				var self = this,
					listeners, n, eventNames;
				// allow mutliple listeners to be bound in one go
				if ( typeof eventName === 'object' ) {
					listeners = [];
					for ( n in eventName ) {
						if ( eventName.hasOwnProperty( n ) ) {
							listeners.push( this.on( n, eventName[ n ] ) );
						}
					}
					return {
						cancel: function() {
							var listener;
							while ( listener = listeners.pop() ) {
								listener.cancel();
							}
						}
					};
				}
				// Handle multiple space-separated event names
				eventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );
				eventNames.forEach( function( eventName ) {
					( this$0._subs[ eventName ] || ( this$0._subs[ eventName ] = [] ) ).push( callback );
				} );
				return {
					cancel: function() {
						self.off( eventName, callback );
					}
				};
			};
		}( Ractive$shared_trim, Ractive$shared_notEmptyString );
	
		/* shared/getNewIndices.js */
		var getNewIndices = function() {
	
			var __export;
			// This function takes an array, the name of a mutator method, and the
			// arguments to call that mutator method with, and returns an array that
			// maps the old indices to their new indices.
			// So if you had something like this...
			//
			//     array = [ 'a', 'b', 'c', 'd' ];
			//     array.push( 'e' );
			//
			// ...you'd get `[ 0, 1, 2, 3 ]` - in other words, none of the old indices
			// have changed. If you then did this...
			//
			//     array.unshift( 'z' );
			//
			// ...the indices would be `[ 1, 2, 3, 4, 5 ]` - every item has been moved
			// one higher to make room for the 'z'. If you removed an item, the new index
			// would be -1...
			//
			//     array.splice( 2, 2 );
			//
			// ...this would result in [ 0, 1, -1, -1, 2, 3 ].
			//
			// This information is used to enable fast, non-destructive shuffling of list
			// sections when you do e.g. `ractive.splice( 'items', 2, 2 );
			__export = function getNewIndices( array, methodName, args ) {
				var spliceArguments, len, newIndices = [],
					removeStart, removeEnd, balance, i;
				spliceArguments = getSpliceEquivalent( array, methodName, args );
				if ( !spliceArguments ) {
					return null;
				}
				len = array.length;
				balance = spliceArguments.length - 2 - spliceArguments[ 1 ];
				removeStart = Math.min( len, spliceArguments[ 0 ] );
				removeEnd = removeStart + spliceArguments[ 1 ];
				for ( i = 0; i < removeStart; i += 1 ) {
					newIndices.push( i );
				}
				for ( ; i < removeEnd; i += 1 ) {
					newIndices.push( -1 );
				}
				for ( ; i < len; i += 1 ) {
					newIndices.push( i + balance );
				}
				return newIndices;
			};
			// The pop, push, shift an unshift methods can all be represented
			// as an equivalent splice
			function getSpliceEquivalent( array, methodName, args ) {
				switch ( methodName ) {
					case 'splice':
						if ( args[ 0 ] !== undefined && args[ 0 ] < 0 ) {
							args[ 0 ] = array.length + Math.max( args[ 0 ], -array.length );
						}
						while ( args.length < 2 ) {
							args.push( 0 );
						}
						// ensure we only remove elements that exist
						args[ 1 ] = Math.min( args[ 1 ], array.length - args[ 0 ] );
						return args;
					case 'sort':
					case 'reverse':
						return null;
					case 'pop':
						if ( array.length ) {
							return [
								array.length - 1,
								1
							];
						}
						return null;
					case 'push':
						return [
							array.length,
							0
						].concat( args );
					case 'shift':
						return [
							0,
							1
						];
					case 'unshift':
						return [
							0,
							0
						].concat( args );
				}
			}
			return __export;
		}();
	
		/* Ractive/prototype/shared/makeArrayMethod.js */
		var Ractive$shared_makeArrayMethod = function( isArray, runloop, getNewIndices ) {
	
			var arrayProto = Array.prototype;
			return function( methodName ) {
				return function( keypath ) {
					var SLICE$0 = Array.prototype.slice;
					var args = SLICE$0.call( arguments, 1 );
					var array, newIndices = [],
						len, promise, result;
					array = this.get( keypath );
					len = array.length;
					if ( !isArray( array ) ) {
						throw new Error( 'Called ractive.' + methodName + '(\'' + keypath + '\'), but \'' + keypath + '\' does not refer to an array' );
					}
					newIndices = getNewIndices( array, methodName, args );
					result = arrayProto[ methodName ].apply( array, args );
					promise = runloop.start( this, true ).then( function() {
						return result;
					} );
					if ( !!newIndices ) {
						this.viewmodel.smartUpdate( keypath, array, newIndices );
					} else {
						this.viewmodel.mark( keypath );
					}
					runloop.end();
					return promise;
				};
			};
		}( isArray, runloop, getNewIndices );
	
		/* Ractive/prototype/pop.js */
		var Ractive$pop = function( makeArrayMethod ) {
	
			return makeArrayMethod( 'pop' );
		}( Ractive$shared_makeArrayMethod );
	
		/* Ractive/prototype/push.js */
		var Ractive$push = function( makeArrayMethod ) {
	
			return makeArrayMethod( 'push' );
		}( Ractive$shared_makeArrayMethod );
	
		/* global/css.js */
		var global_css = function( circular, isClient, removeFromArray ) {
	
			var css, update, runloop, styleElement, head, styleSheet, inDom, prefix = '/* Ractive.js component styles */\n',
				componentsInPage = {},
				styles = [];
			if ( !isClient ) {
				css = null;
			} else {
				circular.push( function() {
					runloop = circular.runloop;
				} );
				styleElement = document.createElement( 'style' );
				styleElement.type = 'text/css';
				head = document.getElementsByTagName( 'head' )[ 0 ];
				inDom = false;
				// Internet Exploder won't let you use styleSheet.innerHTML - we have to
				// use styleSheet.cssText instead
				styleSheet = styleElement.styleSheet;
				update = function() {
					var css;
					if ( styles.length ) {
						css = prefix + styles.join( ' ' );
						if ( styleSheet ) {
							styleSheet.cssText = css;
						} else {
							styleElement.innerHTML = css;
						}
						if ( !inDom ) {
							head.appendChild( styleElement );
							inDom = true;
						}
					} else if ( inDom ) {
						head.removeChild( styleElement );
						inDom = false;
					}
				};
				css = {
					add: function( Component ) {
						if ( !Component.css ) {
							return;
						}
						if ( !componentsInPage[ Component._guid ] ) {
							// we create this counter so that we can in/decrement it as
							// instances are added and removed. When all components are
							// removed, the style is too
							componentsInPage[ Component._guid ] = 0;
							styles.push( Component.css );
							update();
						}
						componentsInPage[ Component._guid ] += 1;
					},
					remove: function( Component ) {
						if ( !Component.css ) {
							return;
						}
						componentsInPage[ Component._guid ] -= 1;
						if ( !componentsInPage[ Component._guid ] ) {
							removeFromArray( styles, Component.css );
							runloop.scheduleTask( update );
						}
					}
				};
			}
			return css;
		}( circular, isClient, removeFromArray );
	
		/* Ractive/prototype/render.js */
		var Ractive$render = function( css, Hook, getElement, runloop ) {
	
			var renderHook = new Hook( 'render' ),
				completeHook = new Hook( 'complete' );
			return function Ractive$render( target, anchor ) {
				var this$0 = this;
				var promise, instances, transitionsEnabled;
				// if `noIntro` is `true`, temporarily disable transitions
				transitionsEnabled = this.transitionsEnabled;
				if ( this.noIntro ) {
					this.transitionsEnabled = false;
				}
				promise = runloop.start( this, true );
				runloop.scheduleTask( function() {
					return renderHook.fire( this$0 );
				}, true );
				if ( this.fragment.rendered ) {
					throw new Error( 'You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first' );
				}
				target = getElement( target ) || this.el;
				anchor = getElement( anchor ) || this.anchor;
				this.el = target;
				this.anchor = anchor;
				// Add CSS, if applicable
				if ( this.constructor.css ) {
					css.add( this.constructor );
				}
				if ( target ) {
					if ( !( instances = target.__ractive_instances__ ) ) {
						target.__ractive_instances__ = [ this ];
					} else {
						instances.push( this );
					}
					if ( anchor ) {
						target.insertBefore( this.fragment.render(), anchor );
					} else {
						target.appendChild( this.fragment.render() );
					}
				}
				runloop.end();
				this.transitionsEnabled = transitionsEnabled;
				// It is now more problematic to know if the complete hook
				// would fire. Method checking is straight-forward, but would
				// also require preflighting event subscriptions. Which seems
				// like more work then just letting the promise happen.
				// But perhaps I'm wrong about that...
				promise.then( function() {
					return completeHook.fire( this$0 );
				} );
				return promise;
			};
		}( global_css, Ractive$shared_hooks_Hook, getElement, runloop );
	
		/* virtualdom/Fragment/prototype/bubble.js */
		var virtualdom_Fragment$bubble = function Fragment$bubble() {
			this.dirtyValue = this.dirtyArgs = true;
			if ( this.bound && typeof this.owner.bubble === 'function' ) {
				this.owner.bubble();
			}
		};
	
		/* virtualdom/Fragment/prototype/detach.js */
		var virtualdom_Fragment$detach = function Fragment$detach() {
			var docFrag;
			if ( this.items.length === 1 ) {
				return this.items[ 0 ].detach();
			}
			docFrag = document.createDocumentFragment();
			this.items.forEach( function( item ) {
				var node = item.detach();
				// TODO The if {...} wasn't previously required - it is now, because we're
				// forcibly detaching everything to reorder sections after an update. That's
				// a non-ideal brute force approach, implemented to get all the tests to pass
				// - as soon as it's replaced with something more elegant, this should
				// revert to `docFrag.appendChild( item.detach() )`
				if ( node ) {
					docFrag.appendChild( node );
				}
			} );
			return docFrag;
		};
	
		/* virtualdom/Fragment/prototype/find.js */
		var virtualdom_Fragment$find = function Fragment$find( selector ) {
			var i, len, item, queryResult;
			if ( this.items ) {
				len = this.items.length;
				for ( i = 0; i < len; i += 1 ) {
					item = this.items[ i ];
					if ( item.find && ( queryResult = item.find( selector ) ) ) {
						return queryResult;
					}
				}
				return null;
			}
		};
	
		/* virtualdom/Fragment/prototype/findAll.js */
		var virtualdom_Fragment$findAll = function Fragment$findAll( selector, query ) {
			var i, len, item;
			if ( this.items ) {
				len = this.items.length;
				for ( i = 0; i < len; i += 1 ) {
					item = this.items[ i ];
					if ( item.findAll ) {
						item.findAll( selector, query );
					}
				}
			}
			return query;
		};
	
		/* virtualdom/Fragment/prototype/findAllComponents.js */
		var virtualdom_Fragment$findAllComponents = function Fragment$findAllComponents( selector, query ) {
			var i, len, item;
			if ( this.items ) {
				len = this.items.length;
				for ( i = 0; i < len; i += 1 ) {
					item = this.items[ i ];
					if ( item.findAllComponents ) {
						item.findAllComponents( selector, query );
					}
				}
			}
			return query;
		};
	
		/* virtualdom/Fragment/prototype/findComponent.js */
		var virtualdom_Fragment$findComponent = function Fragment$findComponent( selector ) {
			var len, i, item, queryResult;
			if ( this.items ) {
				len = this.items.length;
				for ( i = 0; i < len; i += 1 ) {
					item = this.items[ i ];
					if ( item.findComponent && ( queryResult = item.findComponent( selector ) ) ) {
						return queryResult;
					}
				}
				return null;
			}
		};
	
		/* virtualdom/Fragment/prototype/findNextNode.js */
		var virtualdom_Fragment$findNextNode = function Fragment$findNextNode( item ) {
			var index = item.index,
				node;
			if ( this.items[ index + 1 ] ) {
				node = this.items[ index + 1 ].firstNode();
			} else if ( this.owner === this.root ) {
				if ( !this.owner.component ) {
					// TODO but something else could have been appended to
					// this.root.el, no?
					node = null;
				} else {
					node = this.owner.component.findNextNode();
				}
			} else {
				node = this.owner.findNextNode( this );
			}
			return node;
		};
	
		/* virtualdom/Fragment/prototype/firstNode.js */
		var virtualdom_Fragment$firstNode = function Fragment$firstNode() {
			if ( this.items && this.items[ 0 ] ) {
				return this.items[ 0 ].firstNode();
			}
			return null;
		};
	
		/* virtualdom/Fragment/prototype/getNode.js */
		var virtualdom_Fragment$getNode = function Fragment$getNode() {
			var fragment = this;
			do {
				if ( fragment.pElement ) {
					return fragment.pElement.node;
				}
			} while ( fragment = fragment.parent );
			return this.root.detached || this.root.el;
		};
	
		/* virtualdom/Fragment/prototype/getValue.js */
		var virtualdom_Fragment$getValue = function( parseJSON ) {
	
			var __export;
			var empty = {};
			__export = function Fragment$getValue() {
				var options = arguments[ 0 ];
				if ( options === void 0 )
					options = empty;
				var asArgs, values, source, parsed, cachedResult, dirtyFlag, result;
				asArgs = options.args;
				cachedResult = asArgs ? 'argsList' : 'value';
				dirtyFlag = asArgs ? 'dirtyArgs' : 'dirtyValue';
				if ( this[ dirtyFlag ] ) {
					source = processItems( this.items, values = {}, this.root._guid );
					parsed = parseJSON( asArgs ? '[' + source + ']' : source, values );
					if ( !parsed ) {
						result = asArgs ? [ this.toString() ] : this.toString();
					} else {
						result = parsed.value;
					}
					this[ cachedResult ] = result;
					this[ dirtyFlag ] = false;
				}
				return this[ cachedResult ];
			};
	
			function processItems( items, values, guid, counter ) {
				counter = counter || 0;
				return items.map( function( item ) {
					var placeholderId, wrapped, value;
					if ( item.text ) {
						return item.text;
					}
					if ( item.fragments ) {
						return item.fragments.map( function( fragment ) {
							return processItems( fragment.items, values, guid, counter );
						} ).join( '' );
					}
					placeholderId = guid + '-' + counter++;
					if ( wrapped = item.root.viewmodel.wrapped[ item.keypath ] ) {
						value = wrapped.value;
					} else {
						value = item.getValue();
					}
					values[ placeholderId ] = value;
					return '${' + placeholderId + '}';
				} ).join( '' );
			}
			return __export;
		}( parseJSON );
	
		/* utils/escapeHtml.js */
		var escapeHtml = function() {
	
			var lessThan = /</g;
			var greaterThan = />/g;
			var amp = /&/g;
			return function escapeHtml( str ) {
				return str.replace( amp, '&amp;' ).replace( lessThan, '&lt;' ).replace( greaterThan, '&gt;' );
			};
		}();
	
		/* utils/detachNode.js */
		var detachNode = function detachNode( node ) {
			if ( node && node.parentNode ) {
				node.parentNode.removeChild( node );
			}
			return node;
		};
	
		/* virtualdom/items/shared/detach.js */
		var detach = function( detachNode ) {
	
			return function() {
				return detachNode( this.node );
			};
		}( detachNode );
	
		/* virtualdom/items/Text.js */
		var Text = function( types, escapeHtml, detach ) {
	
			var Text = function( options ) {
				this.type = types.TEXT;
				this.text = options.template;
			};
			Text.prototype = {
				detach: detach,
				firstNode: function() {
					return this.node;
				},
				render: function() {
					if ( !this.node ) {
						this.node = document.createTextNode( this.text );
					}
					return this.node;
				},
				toString: function( escape ) {
					return escape ? escapeHtml( this.text ) : this.text;
				},
				unrender: function( shouldDestroy ) {
					if ( shouldDestroy ) {
						return this.detach();
					}
				}
			};
			return Text;
		}( types, escapeHtml, detach );
	
		/* virtualdom/items/shared/unbind.js */
		var unbind = function unbind() {
			if ( this.registered ) {
				// this was registered as a dependant
				this.root.viewmodel.unregister( this.keypath, this );
			}
			if ( this.resolver ) {
				this.resolver.unbind();
			}
		};
	
		/* virtualdom/items/shared/Mustache/getValue.js */
		var getValue = function Mustache$getValue() {
			return this.value;
		};
	
		/* virtualdom/items/shared/utils/startsWithKeypath.js */
		var startsWithKeypath = function startsWithKeypath( target, keypath ) {
			return target && keypath && target.substr( 0, keypath.length + 1 ) === keypath + '.';
		};
	
		/* virtualdom/items/shared/utils/getNewKeypath.js */
		var getNewKeypath = function( startsWithKeypath ) {
	
			return function getNewKeypath( targetKeypath, oldKeypath, newKeypath ) {
				// exact match
				if ( targetKeypath === oldKeypath ) {
					return newKeypath !== undefined ? newKeypath : null;
				}
				// partial match based on leading keypath segments
				if ( startsWithKeypath( targetKeypath, oldKeypath ) ) {
					return newKeypath === null ? newKeypath : targetKeypath.replace( oldKeypath + '.', newKeypath + '.' );
				}
			};
		}( startsWithKeypath );
	
		/* virtualdom/items/shared/Resolvers/ReferenceResolver.js */
		var ReferenceResolver = function( runloop, resolveRef, getNewKeypath ) {
	
			var ReferenceResolver = function( owner, ref, callback ) {
				var keypath;
				this.ref = ref;
				this.resolved = false;
				this.root = owner.root;
				this.parentFragment = owner.parentFragment;
				this.callback = callback;
				keypath = resolveRef( owner.root, ref, owner.parentFragment );
				if ( keypath !== undefined ) {
					this.resolve( keypath );
				} else {
					runloop.addUnresolved( this );
				}
			};
			ReferenceResolver.prototype = {
				resolve: function( keypath ) {
					this.resolved = true;
					this.keypath = keypath;
					this.callback( keypath );
				},
				forceResolution: function() {
					this.resolve( this.ref );
				},
				rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
					var keypath;
					if ( this.keypath !== undefined ) {
						keypath = getNewKeypath( this.keypath, oldKeypath, newKeypath );
						// was a new keypath created?
						if ( keypath !== undefined ) {
							// resolve it
							this.resolve( keypath );
						}
					}
				},
				unbind: function() {
					if ( !this.resolved ) {
						runloop.removeUnresolved( this );
					}
				}
			};
			return ReferenceResolver;
		}( runloop, resolveRef, getNewKeypath );
	
		/* virtualdom/items/shared/Resolvers/SpecialResolver.js */
		var SpecialResolver = function() {
	
			var SpecialResolver = function( owner, ref, callback ) {
				this.parentFragment = owner.parentFragment;
				this.ref = ref;
				this.callback = callback;
				this.rebind();
			};
			SpecialResolver.prototype = {
				rebind: function() {
					var ref = this.ref,
						fragment = this.parentFragment;
					if ( ref === '@keypath' ) {
						while ( fragment ) {
							if ( !!fragment.context ) {
								return this.callback( '@' + fragment.context );
							}
							fragment = fragment.parent;
						}
					}
					if ( ref === '@index' || ref === '@key' ) {
						while ( fragment ) {
							if ( fragment.index !== undefined ) {
								return this.callback( '@' + fragment.index );
							}
							fragment = fragment.parent;
						}
					}
					throw new Error( 'Unknown special reference "' + ref + '" - valid references are @index, @key and @keypath' );
				},
				unbind: function() {}
			};
			return SpecialResolver;
		}();
	
		/* virtualdom/items/shared/Resolvers/IndexResolver.js */
		var IndexResolver = function() {
	
			var IndexResolver = function( owner, ref, callback ) {
				this.parentFragment = owner.parentFragment;
				this.ref = ref;
				this.callback = callback;
				this.rebind();
			};
			IndexResolver.prototype = {
				rebind: function() {
					var ref = this.ref,
						indexRefs = this.parentFragment.indexRefs,
						index = indexRefs[ ref ];
					if ( index !== undefined ) {
						this.callback( '@' + index );
					}
				},
				unbind: function() {}
			};
			return IndexResolver;
		}();
	
		/* virtualdom/items/shared/Resolvers/createReferenceResolver.js */
		var createReferenceResolver = function( ReferenceResolver, SpecialResolver, IndexResolver ) {
	
			return function createReferenceResolver( owner, ref, callback ) {
				var indexRefs, index;
				if ( ref.charAt( 0 ) === '@' ) {
					return new SpecialResolver( owner, ref, callback );
				}
				indexRefs = owner.parentFragment.indexRefs;
				if ( indexRefs && ( index = indexRefs[ ref ] ) !== undefined ) {
					return new IndexResolver( owner, ref, callback );
				}
				return new ReferenceResolver( owner, ref, callback );
			};
		}( ReferenceResolver, SpecialResolver, IndexResolver );
	
		/* shared/getFunctionFromString.js */
		var getFunctionFromString = function() {
	
			var cache = {};
			return function getFunctionFromString( str, i ) {
				var fn, args;
				if ( cache[ str ] ) {
					return cache[ str ];
				}
				args = [];
				while ( i-- ) {
					args[ i ] = '_' + i;
				}
				fn = new Function( args.join( ',' ), 'return(' + str + ')' );
				cache[ str ] = fn;
				return fn;
			};
		}();
	
		/* virtualdom/items/shared/Resolvers/ExpressionResolver.js */
		var ExpressionResolver = function( defineProperty, isNumeric, createReferenceResolver, getFunctionFromString ) {
	
			var __export;
			var ExpressionResolver, bind = Function.prototype.bind;
			ExpressionResolver = function( owner, parentFragment, expression, callback ) {
				var resolver = this,
					ractive, indexRefs;
				ractive = owner.root;
				resolver.root = ractive;
				resolver.parentFragment = parentFragment;
				resolver.callback = callback;
				resolver.owner = owner;
				resolver.str = expression.s;
				resolver.keypaths = [];
				indexRefs = parentFragment.indexRefs;
				// Create resolvers for each reference
				resolver.pending = expression.r.length;
				resolver.refResolvers = expression.r.map( function( ref, i ) {
					return createReferenceResolver( resolver, ref, function( keypath ) {
						resolver.resolve( i, keypath );
					} );
				} );
				resolver.ready = true;
				resolver.bubble();
			};
			ExpressionResolver.prototype = {
				bubble: function() {
					if ( !this.ready ) {
						return;
					}
					this.uniqueString = getUniqueString( this.str, this.keypaths );
					this.keypath = getKeypath( this.uniqueString );
					this.createEvaluator();
					this.callback( this.keypath );
				},
				unbind: function() {
					var resolver;
					while ( resolver = this.refResolvers.pop() ) {
						resolver.unbind();
					}
				},
				resolve: function( index, keypath ) {
					this.keypaths[ index ] = keypath;
					this.bubble();
				},
				createEvaluator: function() {
					var this$0 = this;
					var self = this,
						computation, valueGetters, signature, keypath, fn;
					computation = this.root.viewmodel.computations[ this.keypath ];
					// only if it doesn't exist yet!
					if ( !computation ) {
						fn = getFunctionFromString( this.str, this.refResolvers.length );
						valueGetters = this.keypaths.map( function( keypath ) {
							var value;
							if ( keypath === 'undefined' ) {
								return function() {
									return undefined;
								};
							}
							// 'special' keypaths encode a value
							if ( keypath[ 0 ] === '@' ) {
								value = keypath.slice( 1 );
								return isNumeric( value ) ? function() {
									return +value;
								} : function() {
									return value;
								};
							}
							return function() {
								var value = this$0.root.viewmodel.get( keypath );
								if ( typeof value === 'function' ) {
									value = wrapFunction( value, self.root );
								}
								return value;
							};
						} );
						signature = {
							deps: this.keypaths.filter( isValidDependency ),
							get: function() {
								var args = valueGetters.map( call );
								return fn.apply( null, args );
							}
						};
						computation = this.root.viewmodel.compute( this.keypath, signature );
					} else {
						this.root.viewmodel.mark( this.keypath );
					}
				},
				rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
					// TODO only bubble once, no matter how many references are affected by the rebind
					this.refResolvers.forEach( function( r ) {
						return r.rebind( indexRef, newIndex, oldKeypath, newKeypath );
					} );
				}
			};
			__export = ExpressionResolver;
	
			function call( value ) {
				return value.call();
			}
	
			function getUniqueString( str, keypaths ) {
				// get string that is unique to this expression
				return str.replace( /_([0-9]+)/g, function( match, $1 ) {
					var keypath, value;
					keypath = keypaths[ $1 ];
					if ( keypath === undefined ) {
						return 'undefined';
					}
					if ( keypath[ 0 ] === '@' ) {
						value = keypath.slice( 1 );
						return isNumeric( value ) ? value : '"' + value + '"';
					}
					return keypath;
				} );
			}
	
			function getKeypath( uniqueString ) {
				// Sanitize by removing any periods or square brackets. Otherwise
				// we can't split the keypath into keys!
				return '${' + uniqueString.replace( /[\.\[\]]/g, '-' ) + '}';
			}
	
			function isValidDependency( keypath ) {
				return keypath !== undefined && keypath[ 0 ] !== '@';
			}
	
			function wrapFunction( fn, ractive ) {
				var wrapped, prop, key;
				if ( fn._noWrap ) {
					return fn;
				}
				prop = '__ractive_' + ractive._guid;
				wrapped = fn[ prop ];
				if ( wrapped ) {
					return wrapped;
				} else if ( /this/.test( fn.toString() ) ) {
					defineProperty( fn, prop, {
						value: bind.call( fn, ractive )
					} );
					// Add properties/methods to wrapped function
					for ( key in fn ) {
						if ( fn.hasOwnProperty( key ) ) {
							fn[ prop ][ key ] = fn[ key ];
						}
					}
					return fn[ prop ];
				}
				defineProperty( fn, '__ractive_nowrap', {
					value: fn
				} );
				return fn.__ractive_nowrap;
			}
			return __export;
		}( defineProperty, isNumeric, createReferenceResolver, getFunctionFromString, legacy );
	
		/* virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/MemberResolver.js */
		var MemberResolver = function( types, createReferenceResolver, ExpressionResolver ) {
	
			var MemberResolver = function( template, resolver, parentFragment ) {
				var member = this,
					keypath;
				member.resolver = resolver;
				member.root = resolver.root;
				member.parentFragment = parentFragment;
				member.viewmodel = resolver.root.viewmodel;
				if ( typeof template === 'string' ) {
					member.value = template;
				} else if ( template.t === types.REFERENCE ) {
					member.refResolver = createReferenceResolver( this, template.n, function( keypath ) {
						member.resolve( keypath );
					} );
				} else {
					new ExpressionResolver( resolver, parentFragment, template, function( keypath ) {
						member.resolve( keypath );
					} );
				}
			};
			MemberResolver.prototype = {
				resolve: function( keypath ) {
					if ( this.keypath ) {
						this.viewmodel.unregister( this.keypath, this );
					}
					this.keypath = keypath;
					this.value = this.viewmodel.get( keypath );
					this.bind();
					this.resolver.bubble();
				},
				bind: function() {
					this.viewmodel.register( this.keypath, this );
				},
				rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
					if ( this.refResolver ) {
						this.refResolver.rebind( indexRef, newIndex, oldKeypath, newKeypath );
					}
				},
				setValue: function( value ) {
					this.value = value;
					this.resolver.bubble();
				},
				unbind: function() {
					if ( this.keypath ) {
						this.viewmodel.unregister( this.keypath, this );
					}
					if ( this.unresolved ) {
						this.unresolved.unbind();
					}
				},
				forceResolution: function() {
					if ( this.refResolver ) {
						this.refResolver.forceResolution();
					}
				}
			};
			return MemberResolver;
		}( types, createReferenceResolver, ExpressionResolver );
	
		/* virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/ReferenceExpressionResolver.js */
		var ReferenceExpressionResolver = function( resolveRef, ReferenceResolver, MemberResolver ) {
	
			var ReferenceExpressionResolver = function( mustache, template, callback ) {
				var this$0 = this;
				var resolver = this,
					ractive, ref, keypath, parentFragment;
				resolver.parentFragment = parentFragment = mustache.parentFragment;
				resolver.root = ractive = mustache.root;
				resolver.mustache = mustache;
				resolver.ref = ref = template.r;
				resolver.callback = callback;
				resolver.unresolved = [];
				// Find base keypath
				if ( keypath = resolveRef( ractive, ref, parentFragment ) ) {
					resolver.base = keypath;
				} else {
					resolver.baseResolver = new ReferenceResolver( this, ref, function( keypath ) {
						resolver.base = keypath;
						resolver.baseResolver = null;
						resolver.bubble();
					} );
				}
				// Find values for members, or mark them as unresolved
				resolver.members = template.m.map( function( template ) {
					return new MemberResolver( template, this$0, parentFragment );
				} );
				resolver.ready = true;
				resolver.bubble();
			};
			ReferenceExpressionResolver.prototype = {
				getKeypath: function() {
					var values = this.members.map( getValue );
					if ( !values.every( isDefined ) || this.baseResolver ) {
						return null;
					}
					return this.base + '.' + values.join( '.' );
				},
				bubble: function() {
					if ( !this.ready || this.baseResolver ) {
						return;
					}
					this.callback( this.getKeypath() );
				},
				unbind: function() {
					this.members.forEach( unbind );
				},
				rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
					var changed;
					this.members.forEach( function( members ) {
						if ( members.rebind( indexRef, newIndex, oldKeypath, newKeypath ) ) {
							changed = true;
						}
					} );
					if ( changed ) {
						this.bubble();
					}
				},
				forceResolution: function() {
					if ( this.baseResolver ) {
						this.base = this.ref;
						this.baseResolver.unbind();
						this.baseResolver = null;
					}
					this.members.forEach( function( m ) {
						return m.forceResolution();
					} );
					this.bubble();
				}
			};
	
			function getValue( member ) {
				return member.value;
			}
	
			function isDefined( value ) {
				return value != undefined;
			}
	
			function unbind( member ) {
				member.unbind();
			}
			return ReferenceExpressionResolver;
		}( resolveRef, ReferenceResolver, MemberResolver );
	
		/* virtualdom/items/shared/Mustache/initialise.js */
		var initialise = function( types, createReferenceResolver, ReferenceExpressionResolver, ExpressionResolver ) {
	
			return function Mustache$init( mustache, options ) {
				var ref, parentFragment, template;
				parentFragment = options.parentFragment;
				template = options.template;
				mustache.root = parentFragment.root;
				mustache.parentFragment = parentFragment;
				mustache.pElement = parentFragment.pElement;
				mustache.template = options.template;
				mustache.index = options.index || 0;
				mustache.isStatic = options.template.s;
				mustache.type = options.template.t;
				mustache.registered = false;
				// if this is a simple mustache, with a reference, we just need to resolve
				// the reference to a keypath
				if ( ref = template.r ) {
					mustache.resolver = new createReferenceResolver( mustache, ref, resolve );
				}
				// if it's an expression, we have a bit more work to do
				if ( options.template.x ) {
					mustache.resolver = new ExpressionResolver( mustache, parentFragment, options.template.x, resolveAndRebindChildren );
				}
				if ( options.template.rx ) {
					mustache.resolver = new ReferenceExpressionResolver( mustache, options.template.rx, resolveAndRebindChildren );
				}
				// Special case - inverted sections
				if ( mustache.template.n === types.SECTION_UNLESS && !mustache.hasOwnProperty( 'value' ) ) {
					mustache.setValue( undefined );
				}
	
				function resolve( keypath ) {
					mustache.resolve( keypath );
				}
	
				function resolveAndRebindChildren( newKeypath ) {
					var oldKeypath = mustache.keypath;
					if ( newKeypath !== oldKeypath ) {
						mustache.resolve( newKeypath );
						if ( oldKeypath !== undefined ) {
							mustache.fragments && mustache.fragments.forEach( function( f ) {
								f.rebind( null, null, oldKeypath, newKeypath );
							} );
						}
					}
				}
			};
		}( types, createReferenceResolver, ReferenceExpressionResolver, ExpressionResolver );
	
		/* virtualdom/items/shared/Mustache/resolve.js */
		var resolve = function( isNumeric ) {
	
			return function Mustache$resolve( keypath ) {
				var wasResolved, value, twowayBinding;
				// 'Special' keypaths, e.g. @foo or @7, encode a value
				if ( keypath && keypath[ 0 ] === '@' ) {
					value = keypath.slice( 1 );
					if ( isNumeric( value ) ) {
						value = +value;
					}
					this.keypath = keypath;
					this.setValue( value );
					return;
				}
				// If we resolved previously, we need to unregister
				if ( this.registered ) {
					// undefined or null
					this.root.viewmodel.unregister( this.keypath, this );
					this.registered = false;
					wasResolved = true;
				}
				this.keypath = keypath;
				// If the new keypath exists, we need to register
				// with the viewmodel
				if ( keypath != undefined ) {
					// undefined or null
					value = this.root.viewmodel.get( keypath );
					this.root.viewmodel.register( keypath, this );
					this.registered = true;
				}
				// Either way we need to queue up a render (`value`
				// will be `undefined` if there's no keypath)
				this.setValue( value );
				// Two-way bindings need to point to their new target keypath
				if ( wasResolved && ( twowayBinding = this.twowayBinding ) ) {
					twowayBinding.rebound();
				}
			};
		}( isNumeric );
	
		/* virtualdom/items/shared/Mustache/rebind.js */
		var rebind = function Mustache$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
			// Children first
			if ( this.fragments ) {
				this.fragments.forEach( function( f ) {
					return f.rebind( indexRef, newIndex, oldKeypath, newKeypath );
				} );
			}
			// Expression mustache?
			if ( this.resolver ) {
				this.resolver.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			}
		};
	
		/* virtualdom/items/shared/Mustache/_Mustache.js */
		var Mustache = function( getValue, init, resolve, rebind ) {
	
			return {
				getValue: getValue,
				init: init,
				resolve: resolve,
				rebind: rebind
			};
		}( getValue, initialise, resolve, rebind );
	
		/* virtualdom/items/Interpolator.js */
		var Interpolator = function( types, runloop, escapeHtml, detachNode, isEqual, unbind, Mustache, detach ) {
	
			var Interpolator = function( options ) {
				this.type = types.INTERPOLATOR;
				Mustache.init( this, options );
			};
			Interpolator.prototype = {
				update: function() {
					this.node.data = this.value == undefined ? '' : this.value;
				},
				resolve: Mustache.resolve,
				rebind: Mustache.rebind,
				detach: detach,
				unbind: unbind,
				render: function() {
					if ( !this.node ) {
						this.node = document.createTextNode( this.value != undefined ? this.value : '' );
					}
					return this.node;
				},
				unrender: function( shouldDestroy ) {
					if ( shouldDestroy ) {
						detachNode( this.node );
					}
				},
				getValue: Mustache.getValue,
				// TEMP
				setValue: function( value ) {
					var wrapper;
					// TODO is there a better way to approach this?
					if ( wrapper = this.root.viewmodel.wrapped[ this.keypath ] ) {
						value = wrapper.get();
					}
					if ( !isEqual( value, this.value ) ) {
						this.value = value;
						this.parentFragment.bubble();
						if ( this.node ) {
							runloop.addView( this );
						}
					}
				},
				firstNode: function() {
					return this.node;
				},
				toString: function( escape ) {
					var string = this.value != undefined ? '' + this.value : '';
					return escape ? escapeHtml( string ) : string;
				}
			};
			return Interpolator;
		}( types, runloop, escapeHtml, detachNode, isEqual, unbind, Mustache, detach );
	
		/* virtualdom/items/Section/prototype/bubble.js */
		var virtualdom_items_Section$bubble = function Section$bubble() {
			this.parentFragment.bubble();
		};
	
		/* virtualdom/items/Section/prototype/detach.js */
		var virtualdom_items_Section$detach = function Section$detach() {
			var docFrag;
			if ( this.fragments.length === 1 ) {
				return this.fragments[ 0 ].detach();
			}
			docFrag = document.createDocumentFragment();
			this.fragments.forEach( function( item ) {
				docFrag.appendChild( item.detach() );
			} );
			return docFrag;
		};
	
		/* virtualdom/items/Section/prototype/find.js */
		var virtualdom_items_Section$find = function Section$find( selector ) {
			var i, len, queryResult;
			len = this.fragments.length;
			for ( i = 0; i < len; i += 1 ) {
				if ( queryResult = this.fragments[ i ].find( selector ) ) {
					return queryResult;
				}
			}
			return null;
		};
	
		/* virtualdom/items/Section/prototype/findAll.js */
		var virtualdom_items_Section$findAll = function Section$findAll( selector, query ) {
			var i, len;
			len = this.fragments.length;
			for ( i = 0; i < len; i += 1 ) {
				this.fragments[ i ].findAll( selector, query );
			}
		};
	
		/* virtualdom/items/Section/prototype/findAllComponents.js */
		var virtualdom_items_Section$findAllComponents = function Section$findAllComponents( selector, query ) {
			var i, len;
			len = this.fragments.length;
			for ( i = 0; i < len; i += 1 ) {
				this.fragments[ i ].findAllComponents( selector, query );
			}
		};
	
		/* virtualdom/items/Section/prototype/findComponent.js */
		var virtualdom_items_Section$findComponent = function Section$findComponent( selector ) {
			var i, len, queryResult;
			len = this.fragments.length;
			for ( i = 0; i < len; i += 1 ) {
				if ( queryResult = this.fragments[ i ].findComponent( selector ) ) {
					return queryResult;
				}
			}
			return null;
		};
	
		/* virtualdom/items/Section/prototype/findNextNode.js */
		var virtualdom_items_Section$findNextNode = function Section$findNextNode( fragment ) {
			if ( this.fragments[ fragment.index + 1 ] ) {
				return this.fragments[ fragment.index + 1 ].firstNode();
			}
			return this.parentFragment.findNextNode( this );
		};
	
		/* virtualdom/items/Section/prototype/firstNode.js */
		var virtualdom_items_Section$firstNode = function Section$firstNode() {
			var len, i, node;
			if ( len = this.fragments.length ) {
				for ( i = 0; i < len; i += 1 ) {
					if ( node = this.fragments[ i ].firstNode() ) {
						return node;
					}
				}
			}
			return this.parentFragment.findNextNode( this );
		};
	
		/* virtualdom/items/Section/prototype/shuffle.js */
		var virtualdom_items_Section$shuffle = function( types, runloop, circular ) {
	
			var Fragment;
			circular.push( function() {
				Fragment = circular.Fragment;
			} );
			return function Section$shuffle( newIndices ) {
				var this$0 = this;
				var section = this,
					parentFragment, firstChange, i, newLength, reboundFragments, fragmentOptions, fragment;
				// short circuit any double-updates, and ensure that this isn't applied to
				// non-list sections
				if ( this.shuffling || this.unbound || this.subtype && this.subtype !== types.SECTION_EACH ) {
					return;
				}
				this.shuffling = true;
				runloop.scheduleTask( function() {
					return this$0.shuffling = false;
				} );
				parentFragment = this.parentFragment;
				reboundFragments = [];
				// first, rebind existing fragments
				newIndices.forEach( function rebindIfNecessary( newIndex, oldIndex ) {
					var fragment, by, oldKeypath, newKeypath;
					if ( newIndex === oldIndex ) {
						reboundFragments[ newIndex ] = section.fragments[ oldIndex ];
						return;
					}
					fragment = section.fragments[ oldIndex ];
					if ( firstChange === undefined ) {
						firstChange = oldIndex;
					}
					// does this fragment need to be torn down?
					if ( newIndex === -1 ) {
						section.fragmentsToUnrender.push( fragment );
						fragment.unbind();
						return;
					}
					// Otherwise, it needs to be rebound to a new index
					by = newIndex - oldIndex;
					oldKeypath = section.keypath + '.' + oldIndex;
					newKeypath = section.keypath + '.' + newIndex;
					fragment.rebind( section.template.i, newIndex, oldKeypath, newKeypath );
					fragment.index = newIndex;
					reboundFragments[ newIndex ] = fragment;
				} );
				newLength = this.root.get( this.keypath ).length;
				// If nothing changed with the existing fragments, then we start adding
				// new fragments at the end...
				if ( firstChange === undefined ) {
					// ...unless there are no new fragments to add
					if ( this.length === newLength ) {
						return;
					}
					firstChange = this.length;
				}
				this.length = this.fragments.length = newLength;
				if ( this.rendered ) {
					runloop.addView( this );
				}
				// Prepare new fragment options
				fragmentOptions = {
					template: this.template.f,
					root: this.root,
					owner: this
				};
				if ( this.template.i ) {
					fragmentOptions.indexRef = this.template.i;
				}
				// Add as many new fragments as we need to, or add back existing
				// (detached) fragments
				for ( i = firstChange; i < newLength; i += 1 ) {
					fragment = reboundFragments[ i ];
					if ( !fragment ) {
						this.fragmentsToCreate.push( i );
					}
					this.fragments[ i ] = fragment;
				}
			};
		}( types, runloop, circular );
	
		/* virtualdom/items/Section/prototype/render.js */
		var virtualdom_items_Section$render = function Section$render() {
			var docFrag;
			docFrag = this.docFrag = document.createDocumentFragment();
			this.update();
			this.rendered = true;
			return docFrag;
		};
	
		/* utils/isArrayLike.js */
		var isArrayLike = function() {
	
			var pattern = /^\[object (?:Array|FileList)\]$/,
				toString = Object.prototype.toString;
			return function isArrayLike( obj ) {
				return pattern.test( toString.call( obj ) );
			};
		}();
	
		/* virtualdom/items/Section/prototype/setValue.js */
		var virtualdom_items_Section$setValue = function( types, isArrayLike, isObject, runloop, circular ) {
	
			var __export;
			var Fragment;
			circular.push( function() {
				Fragment = circular.Fragment;
			} );
			__export = function Section$setValue( value ) {
				var this$0 = this;
				var wrapper, fragmentOptions;
				if ( this.updating ) {
					// If a child of this section causes a re-evaluation - for example, an
					// expression refers to a function that mutates the array that this
					// section depends on - we'll end up with a double rendering bug (see
					// https://github.com/ractivejs/ractive/issues/748). This prevents it.
					return;
				}
				this.updating = true;
				// with sections, we need to get the fake value if we have a wrapped object
				if ( wrapper = this.root.viewmodel.wrapped[ this.keypath ] ) {
					value = wrapper.get();
				}
				// If any fragments are awaiting creation after a splice,
				// this is the place to do it
				if ( this.fragmentsToCreate.length ) {
					fragmentOptions = {
						template: this.template.f,
						root: this.root,
						pElement: this.pElement,
						owner: this,
						indexRef: this.template.i
					};
					this.fragmentsToCreate.forEach( function( index ) {
						var fragment;
						fragmentOptions.context = this$0.keypath + '.' + index;
						fragmentOptions.index = index;
						fragment = new Fragment( fragmentOptions );
						this$0.fragmentsToRender.push( this$0.fragments[ index ] = fragment );
					} );
					this.fragmentsToCreate.length = 0;
				} else if ( reevaluateSection( this, value ) ) {
					this.bubble();
					if ( this.rendered ) {
						runloop.addView( this );
					}
				}
				this.value = value;
				this.updating = false;
			};
	
			function reevaluateSection( section, value ) {
				var fragmentOptions = {
					template: section.template.f,
					root: section.root,
					pElement: section.parentFragment.pElement,
					owner: section
				};
				// If we already know the section type, great
				// TODO can this be optimised? i.e. pick an reevaluateSection function during init
				// and avoid doing this each time?
				if ( section.subtype ) {
					switch ( section.subtype ) {
						case types.SECTION_IF:
							return reevaluateConditionalSection( section, value, false, fragmentOptions );
						case types.SECTION_UNLESS:
							return reevaluateConditionalSection( section, value, true, fragmentOptions );
						case types.SECTION_WITH:
							return reevaluateContextSection( section, fragmentOptions );
						case types.SECTION_IF_WITH:
							return reevaluateConditionalContextSection( section, value, fragmentOptions );
						case types.SECTION_EACH:
							if ( isObject( value ) ) {
								return reevaluateListObjectSection( section, value, fragmentOptions );
							}
					}
				}
				// Otherwise we need to work out what sort of section we're dealing with
				section.ordered = !!isArrayLike( value );
				// Ordered list section
				if ( section.ordered ) {
					return reevaluateListSection( section, value, fragmentOptions );
				}
				// Unordered list, or context
				if ( isObject( value ) || typeof value === 'function' ) {
					// Index reference indicates section should be treated as a list
					if ( section.template.i ) {
						return reevaluateListObjectSection( section, value, fragmentOptions );
					}
					// Otherwise, object provides context for contents
					return reevaluateContextSection( section, fragmentOptions );
				}
				// Conditional section
				return reevaluateConditionalSection( section, value, false, fragmentOptions );
			}
	
			function reevaluateListSection( section, value, fragmentOptions ) {
				var i, length, fragment;
				length = value.length;
				if ( length === section.length ) {
					// Nothing to do
					return false;
				}
				// if the array is shorter than it was previously, remove items
				if ( length < section.length ) {
					section.fragmentsToUnrender = section.fragments.splice( length, section.length - length );
					section.fragmentsToUnrender.forEach( unbind );
				} else {
					if ( length > section.length ) {
						// add any new ones
						for ( i = section.length; i < length; i += 1 ) {
							// append list item to context stack
							fragmentOptions.context = section.keypath + '.' + i;
							fragmentOptions.index = i;
							if ( section.template.i ) {
								fragmentOptions.indexRef = section.template.i;
							}
							fragment = new Fragment( fragmentOptions );
							section.fragmentsToRender.push( section.fragments[ i ] = fragment );
						}
					}
				}
				section.length = length;
				return true;
			}
	
			function reevaluateListObjectSection( section, value, fragmentOptions ) {
				var id, i, hasKey, fragment, changed;
				hasKey = section.hasKey || ( section.hasKey = {} );
				// remove any fragments that should no longer exist
				i = section.fragments.length;
				while ( i-- ) {
					fragment = section.fragments[ i ];
					if ( !( fragment.index in value ) ) {
						changed = true;
						fragment.unbind();
						section.fragmentsToUnrender.push( fragment );
						section.fragments.splice( i, 1 );
						hasKey[ fragment.index ] = false;
					}
				}
				// add any that haven't been created yet
				for ( id in value ) {
					if ( !hasKey[ id ] ) {
						changed = true;
						fragmentOptions.context = section.keypath + '.' + id;
						fragmentOptions.index = id;
						if ( section.template.i ) {
							fragmentOptions.indexRef = section.template.i;
						}
						fragment = new Fragment( fragmentOptions );
						section.fragmentsToRender.push( fragment );
						section.fragments.push( fragment );
						hasKey[ id ] = true;
					}
				}
				section.length = section.fragments.length;
				return changed;
			}
	
			function reevaluateConditionalContextSection( section, value, fragmentOptions ) {
				if ( value ) {
					return reevaluateContextSection( section, fragmentOptions );
				} else {
					return removeSectionFragments( section );
				}
			}
	
			function reevaluateContextSection( section, fragmentOptions ) {
				var fragment;
				// ...then if it isn't rendered, render it, adding section.keypath to the context stack
				// (if it is already rendered, then any children dependent on the context stack
				// will update themselves without any prompting)
				if ( !section.length ) {
					// append this section to the context stack
					fragmentOptions.context = section.keypath;
					fragmentOptions.index = 0;
					fragment = new Fragment( fragmentOptions );
					section.fragmentsToRender.push( section.fragments[ 0 ] = fragment );
					section.length = 1;
					return true;
				}
			}
	
			function reevaluateConditionalSection( section, value, inverted, fragmentOptions ) {
				var doRender, emptyArray, emptyObject, fragment, name;
				emptyArray = isArrayLike( value ) && value.length === 0;
				emptyObject = false;
				if ( !isArrayLike( value ) && isObject( value ) ) {
					emptyObject = true;
					for ( name in value ) {
						emptyObject = false;
						break;
					}
				}
				if ( inverted ) {
					doRender = emptyArray || emptyObject || !value;
				} else {
					doRender = value && !emptyArray && !emptyObject;
				}
				if ( doRender ) {
					if ( !section.length ) {
						// no change to context stack
						fragmentOptions.index = 0;
						fragment = new Fragment( fragmentOptions );
						section.fragmentsToRender.push( section.fragments[ 0 ] = fragment );
						section.length = 1;
						return true;
					}
					if ( section.length > 1 ) {
						section.fragmentsToUnrender = section.fragments.splice( 1 );
						section.fragmentsToUnrender.forEach( unbind );
						return true;
					}
				} else {
					return removeSectionFragments( section );
				}
			}
	
			function removeSectionFragments( section ) {
				if ( section.length ) {
					section.fragmentsToUnrender = section.fragments.splice( 0, section.fragments.length ).filter( isRendered );
					section.fragmentsToUnrender.forEach( unbind );
					section.length = section.fragmentsToRender.length = 0;
					return true;
				}
			}
	
			function unbind( fragment ) {
				fragment.unbind();
			}
	
			function isRendered( fragment ) {
				return fragment.rendered;
			}
			return __export;
		}( types, isArrayLike, isObject, runloop, circular );
	
		/* virtualdom/items/Section/prototype/toString.js */
		var virtualdom_items_Section$toString = function Section$toString( escape ) {
			var str, i, len;
			str = '';
			i = 0;
			len = this.length;
			for ( i = 0; i < len; i += 1 ) {
				str += this.fragments[ i ].toString( escape );
			}
			return str;
		};
	
		/* virtualdom/items/Section/prototype/unbind.js */
		var virtualdom_items_Section$unbind = function( unbind ) {
	
			var __export;
			__export = function Section$unbind() {
				this.fragments.forEach( unbindFragment );
				unbind.call( this );
				this.length = 0;
				this.unbound = true;
			};
	
			function unbindFragment( fragment ) {
				fragment.unbind();
			}
			return __export;
		}( unbind );
	
		/* virtualdom/items/Section/prototype/unrender.js */
		var virtualdom_items_Section$unrender = function() {
	
			var __export;
			__export = function Section$unrender( shouldDestroy ) {
				this.fragments.forEach( shouldDestroy ? unrenderAndDestroy : unrender );
			};
	
			function unrenderAndDestroy( fragment ) {
				fragment.unrender( true );
			}
	
			function unrender( fragment ) {
				fragment.unrender( false );
			}
			return __export;
		}();
	
		/* virtualdom/items/Section/prototype/update.js */
		var virtualdom_items_Section$update = function Section$update() {
			var fragment, renderIndex, renderedFragments, anchor, target, i, len;
			// `this.renderedFragments` is in the order of the previous render.
			// If fragments have shuffled about, this allows us to quickly
			// reinsert them in the correct place
			renderedFragments = this.renderedFragments;
			// Remove fragments that have been marked for destruction
			while ( fragment = this.fragmentsToUnrender.pop() ) {
				fragment.unrender( true );
				renderedFragments.splice( renderedFragments.indexOf( fragment ), 1 );
			}
			// Render new fragments (but don't insert them yet)
			while ( fragment = this.fragmentsToRender.shift() ) {
				fragment.render();
			}
			if ( this.rendered ) {
				target = this.parentFragment.getNode();
			}
			len = this.fragments.length;
			for ( i = 0; i < len; i += 1 ) {
				fragment = this.fragments[ i ];
				renderIndex = renderedFragments.indexOf( fragment, i );
				// search from current index - it's guaranteed to be the same or higher
				if ( renderIndex === i ) {
					// already in the right place. insert accumulated nodes (if any) and carry on
					if ( this.docFrag.childNodes.length ) {
						anchor = fragment.firstNode();
						target.insertBefore( this.docFrag, anchor );
					}
					continue;
				}
				this.docFrag.appendChild( fragment.detach() );
				// update renderedFragments
				if ( renderIndex !== -1 ) {
					renderedFragments.splice( renderIndex, 1 );
				}
				renderedFragments.splice( i, 0, fragment );
			}
			if ( this.rendered && this.docFrag.childNodes.length ) {
				anchor = this.parentFragment.findNextNode( this );
				target.insertBefore( this.docFrag, anchor );
			}
			// Save the rendering order for next time
			this.renderedFragments = this.fragments.slice();
		};
	
		/* virtualdom/items/Section/_Section.js */
		var Section = function( types, Mustache, bubble, detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, shuffle, render, setValue, toString, unbind, unrender, update ) {
	
			var Section = function( options ) {
				this.type = types.SECTION;
				this.subtype = options.template.n;
				this.inverted = this.subtype === types.SECTION_UNLESS;
				this.pElement = options.pElement;
				this.fragments = [];
				this.fragmentsToCreate = [];
				this.fragmentsToRender = [];
				this.fragmentsToUnrender = [];
				this.renderedFragments = [];
				this.length = 0;
				// number of times this section is rendered
				Mustache.init( this, options );
			};
			Section.prototype = {
				bubble: bubble,
				detach: detach,
				find: find,
				findAll: findAll,
				findAllComponents: findAllComponents,
				findComponent: findComponent,
				findNextNode: findNextNode,
				firstNode: firstNode,
				getValue: Mustache.getValue,
				shuffle: shuffle,
				rebind: Mustache.rebind,
				render: render,
				resolve: Mustache.resolve,
				setValue: setValue,
				toString: toString,
				unbind: unbind,
				unrender: unrender,
				update: update
			};
			return Section;
		}( types, Mustache, virtualdom_items_Section$bubble, virtualdom_items_Section$detach, virtualdom_items_Section$find, virtualdom_items_Section$findAll, virtualdom_items_Section$findAllComponents, virtualdom_items_Section$findComponent, virtualdom_items_Section$findNextNode, virtualdom_items_Section$firstNode, virtualdom_items_Section$shuffle, virtualdom_items_Section$render, virtualdom_items_Section$setValue, virtualdom_items_Section$toString, virtualdom_items_Section$unbind, virtualdom_items_Section$unrender, virtualdom_items_Section$update );
	
		/* virtualdom/items/Triple/prototype/detach.js */
		var virtualdom_items_Triple$detach = function Triple$detach() {
			var len, i;
			if ( this.docFrag ) {
				len = this.nodes.length;
				for ( i = 0; i < len; i += 1 ) {
					this.docFrag.appendChild( this.nodes[ i ] );
				}
				return this.docFrag;
			}
		};
	
		/* virtualdom/items/Triple/prototype/find.js */
		var virtualdom_items_Triple$find = function( matches ) {
	
			return function Triple$find( selector ) {
				var i, len, node, queryResult;
				len = this.nodes.length;
				for ( i = 0; i < len; i += 1 ) {
					node = this.nodes[ i ];
					if ( node.nodeType !== 1 ) {
						continue;
					}
					if ( matches( node, selector ) ) {
						return node;
					}
					if ( queryResult = node.querySelector( selector ) ) {
						return queryResult;
					}
				}
				return null;
			};
		}( matches );
	
		/* virtualdom/items/Triple/prototype/findAll.js */
		var virtualdom_items_Triple$findAll = function( matches ) {
	
			return function Triple$findAll( selector, queryResult ) {
				var i, len, node, queryAllResult, numNodes, j;
				len = this.nodes.length;
				for ( i = 0; i < len; i += 1 ) {
					node = this.nodes[ i ];
					if ( node.nodeType !== 1 ) {
						continue;
					}
					if ( matches( node, selector ) ) {
						queryResult.push( node );
					}
					if ( queryAllResult = node.querySelectorAll( selector ) ) {
						numNodes = queryAllResult.length;
						for ( j = 0; j < numNodes; j += 1 ) {
							queryResult.push( queryAllResult[ j ] );
						}
					}
				}
			};
		}( matches );
	
		/* virtualdom/items/Triple/prototype/firstNode.js */
		var virtualdom_items_Triple$firstNode = function Triple$firstNode() {
			if ( this.rendered && this.nodes[ 0 ] ) {
				return this.nodes[ 0 ];
			}
			return this.parentFragment.findNextNode( this );
		};
	
		/* virtualdom/items/Triple/helpers/insertHtml.js */
		var insertHtml = function( namespaces, createElement ) {
	
			var __export;
			var elementCache = {},
				ieBug, ieBlacklist;
			try {
				createElement( 'table' ).innerHTML = 'foo';
			} catch ( err ) {
				ieBug = true;
				ieBlacklist = {
					TABLE: [
						'<table class="x">',
						'</table>'
					],
					THEAD: [
						'<table><thead class="x">',
						'</thead></table>'
					],
					TBODY: [
						'<table><tbody class="x">',
						'</tbody></table>'
					],
					TR: [
						'<table><tr class="x">',
						'</tr></table>'
					],
					SELECT: [
						'<select class="x">',
						'</select>'
					]
				};
			}
			__export = function( html, node, docFrag ) {
				var container, nodes = [],
					wrapper, selectedOption, child, i;
				// render 0 and false
				if ( html != null && html !== '' ) {
					if ( ieBug && ( wrapper = ieBlacklist[ node.tagName ] ) ) {
						container = element( 'DIV' );
						container.innerHTML = wrapper[ 0 ] + html + wrapper[ 1 ];
						container = container.querySelector( '.x' );
						if ( container.tagName === 'SELECT' ) {
							selectedOption = container.options[ container.selectedIndex ];
						}
					} else if ( node.namespaceURI === namespaces.svg ) {
						container = element( 'DIV' );
						container.innerHTML = '<svg class="x">' + html + '</svg>';
						container = container.querySelector( '.x' );
					} else {
						container = element( node.tagName );
						container.innerHTML = html;
						if ( container.tagName === 'SELECT' ) {
							selectedOption = container.options[ container.selectedIndex ];
						}
					}
					while ( child = container.firstChild ) {
						nodes.push( child );
						docFrag.appendChild( child );
					}
					// This is really annoying. Extracting <option> nodes from the
					// temporary container <select> causes the remaining ones to
					// become selected. So now we have to deselect them. IE8, you
					// amaze me. You really do
					// ...and now Chrome too
					if ( node.tagName === 'SELECT' ) {
						i = nodes.length;
						while ( i-- ) {
							if ( nodes[ i ] !== selectedOption ) {
								nodes[ i ].selected = false;
							}
						}
					}
				}
				return nodes;
			};
	
			function element( tagName ) {
				return elementCache[ tagName ] || ( elementCache[ tagName ] = createElement( tagName ) );
			}
			return __export;
		}( namespaces, createElement );
	
		/* utils/toArray.js */
		var toArray = function toArray( arrayLike ) {
			var array = [],
				i = arrayLike.length;
			while ( i-- ) {
				array[ i ] = arrayLike[ i ];
			}
			return array;
		};
	
		/* virtualdom/items/Triple/helpers/updateSelect.js */
		var updateSelect = function( toArray ) {
	
			var __export;
			__export = function updateSelect( parentElement ) {
				var selectedOptions, option, value;
				if ( !parentElement || parentElement.name !== 'select' || !parentElement.binding ) {
					return;
				}
				selectedOptions = toArray( parentElement.node.options ).filter( isSelected );
				// If one of them had a `selected` attribute, we need to sync
				// the model to the view
				if ( parentElement.getAttribute( 'multiple' ) ) {
					value = selectedOptions.map( function( o ) {
						return o.value;
					} );
				} else if ( option = selectedOptions[ 0 ] ) {
					value = option.value;
				}
				if ( value !== undefined ) {
					parentElement.binding.setValue( value );
				}
				parentElement.bubble();
			};
	
			function isSelected( option ) {
				return option.selected;
			}
			return __export;
		}( toArray );
	
		/* virtualdom/items/Triple/prototype/render.js */
		var virtualdom_items_Triple$render = function( insertHtml, updateSelect ) {
	
			return function Triple$render() {
				if ( this.rendered ) {
					throw new Error( 'Attempted to render an item that was already rendered' );
				}
				this.docFrag = document.createDocumentFragment();
				this.nodes = insertHtml( this.value, this.parentFragment.getNode(), this.docFrag );
				// Special case - we're inserting the contents of a <select>
				updateSelect( this.pElement );
				this.rendered = true;
				return this.docFrag;
			};
		}( insertHtml, updateSelect );
	
		/* virtualdom/items/Triple/prototype/setValue.js */
		var virtualdom_items_Triple$setValue = function( runloop ) {
	
			return function Triple$setValue( value ) {
				var wrapper;
				// TODO is there a better way to approach this?
				if ( wrapper = this.root.viewmodel.wrapped[ this.keypath ] ) {
					value = wrapper.get();
				}
				if ( value !== this.value ) {
					this.value = value;
					this.parentFragment.bubble();
					if ( this.rendered ) {
						runloop.addView( this );
					}
				}
			};
		}( runloop );
	
		/* virtualdom/items/Triple/prototype/toString.js */
		var virtualdom_items_Triple$toString = function( decodeCharacterReferences ) {
	
			return function Triple$toString() {
				return this.value != undefined ? decodeCharacterReferences( '' + this.value ) : '';
			};
		}( decodeCharacterReferences );
	
		/* virtualdom/items/Triple/prototype/unrender.js */
		var virtualdom_items_Triple$unrender = function( detachNode ) {
	
			return function Triple$unrender( shouldDestroy ) {
				if ( this.rendered && shouldDestroy ) {
					this.nodes.forEach( detachNode );
					this.rendered = false;
				}
			};
		}( detachNode );
	
		/* virtualdom/items/Triple/prototype/update.js */
		var virtualdom_items_Triple$update = function( insertHtml, updateSelect ) {
	
			return function Triple$update() {
				var node, parentNode;
				if ( !this.rendered ) {
					return;
				}
				// Remove existing nodes
				while ( this.nodes && this.nodes.length ) {
					node = this.nodes.pop();
					node.parentNode.removeChild( node );
				}
				// Insert new nodes
				parentNode = this.parentFragment.getNode();
				this.nodes = insertHtml( this.value, parentNode, this.docFrag );
				parentNode.insertBefore( this.docFrag, this.parentFragment.findNextNode( this ) );
				// Special case - we're inserting the contents of a <select>
				updateSelect( this.pElement );
			};
		}( insertHtml, updateSelect );
	
		/* virtualdom/items/Triple/_Triple.js */
		var Triple = function( types, Mustache, detach, find, findAll, firstNode, render, setValue, toString, unrender, update, unbind ) {
	
			var Triple = function( options ) {
				this.type = types.TRIPLE;
				Mustache.init( this, options );
			};
			Triple.prototype = {
				detach: detach,
				find: find,
				findAll: findAll,
				firstNode: firstNode,
				getValue: Mustache.getValue,
				rebind: Mustache.rebind,
				render: render,
				resolve: Mustache.resolve,
				setValue: setValue,
				toString: toString,
				unbind: unbind,
				unrender: unrender,
				update: update
			};
			return Triple;
		}( types, Mustache, virtualdom_items_Triple$detach, virtualdom_items_Triple$find, virtualdom_items_Triple$findAll, virtualdom_items_Triple$firstNode, virtualdom_items_Triple$render, virtualdom_items_Triple$setValue, virtualdom_items_Triple$toString, virtualdom_items_Triple$unrender, virtualdom_items_Triple$update, unbind );
	
		/* virtualdom/items/Element/prototype/bubble.js */
		var virtualdom_items_Element$bubble = function() {
			this.parentFragment.bubble();
		};
	
		/* virtualdom/items/Element/prototype/detach.js */
		var virtualdom_items_Element$detach = function Element$detach() {
			var node = this.node,
				parentNode;
			if ( node ) {
				// need to check for parent node - DOM may have been altered
				// by something other than Ractive! e.g. jQuery UI...
				if ( parentNode = node.parentNode ) {
					parentNode.removeChild( node );
				}
				return node;
			}
		};
	
		/* virtualdom/items/Element/prototype/find.js */
		var virtualdom_items_Element$find = function( matches ) {
	
			return function( selector ) {
				if ( matches( this.node, selector ) ) {
					return this.node;
				}
				if ( this.fragment && this.fragment.find ) {
					return this.fragment.find( selector );
				}
			};
		}( matches );
	
		/* virtualdom/items/Element/prototype/findAll.js */
		var virtualdom_items_Element$findAll = function( selector, query ) {
			// Add this node to the query, if applicable, and register the
			// query on this element
			if ( query._test( this, true ) && query.live ) {
				( this.liveQueries || ( this.liveQueries = [] ) ).push( query );
			}
			if ( this.fragment ) {
				this.fragment.findAll( selector, query );
			}
		};
	
		/* virtualdom/items/Element/prototype/findAllComponents.js */
		var virtualdom_items_Element$findAllComponents = function( selector, query ) {
			if ( this.fragment ) {
				this.fragment.findAllComponents( selector, query );
			}
		};
	
		/* virtualdom/items/Element/prototype/findComponent.js */
		var virtualdom_items_Element$findComponent = function( selector ) {
			if ( this.fragment ) {
				return this.fragment.findComponent( selector );
			}
		};
	
		/* virtualdom/items/Element/prototype/findNextNode.js */
		var virtualdom_items_Element$findNextNode = function Element$findNextNode() {
			return null;
		};
	
		/* virtualdom/items/Element/prototype/firstNode.js */
		var virtualdom_items_Element$firstNode = function Element$firstNode() {
			return this.node;
		};
	
		/* virtualdom/items/Element/prototype/getAttribute.js */
		var virtualdom_items_Element$getAttribute = function Element$getAttribute( name ) {
			if ( !this.attributes || !this.attributes[ name ] ) {
				return;
			}
			return this.attributes[ name ].value;
		};
	
		/* virtualdom/items/Element/shared/enforceCase.js */
		var enforceCase = function() {
	
			var svgCamelCaseElements, svgCamelCaseAttributes, createMap, map;
			svgCamelCaseElements = 'altGlyph altGlyphDef altGlyphItem animateColor animateMotion animateTransform clipPath feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur feImage feMerge feMergeNode feMorphology feOffset fePointLight feSpecularLighting feSpotLight feTile feTurbulence foreignObject glyphRef linearGradient radialGradient textPath vkern'.split( ' ' );
			svgCamelCaseAttributes = 'attributeName attributeType baseFrequency baseProfile calcMode clipPathUnits contentScriptType contentStyleType diffuseConstant edgeMode externalResourcesRequired filterRes filterUnits glyphRef gradientTransform gradientUnits kernelMatrix kernelUnitLength keyPoints keySplines keyTimes lengthAdjust limitingConeAngle markerHeight markerUnits markerWidth maskContentUnits maskUnits numOctaves pathLength patternContentUnits patternTransform patternUnits pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits refX refY repeatCount repeatDur requiredExtensions requiredFeatures specularConstant specularExponent spreadMethod startOffset stdDeviation stitchTiles surfaceScale systemLanguage tableValues targetX targetY textLength viewBox viewTarget xChannelSelector yChannelSelector zoomAndPan'.split( ' ' );
			createMap = function( items ) {
				var map = {},
					i = items.length;
				while ( i-- ) {
					map[ items[ i ].toLowerCase() ] = items[ i ];
				}
				return map;
			};
			map = createMap( svgCamelCaseElements.concat( svgCamelCaseAttributes ) );
			return function( elementName ) {
				var lowerCaseElementName = elementName.toLowerCase();
				return map[ lowerCaseElementName ] || lowerCaseElementName;
			};
		}();
	
		/* virtualdom/items/Element/Attribute/prototype/bubble.js */
		var virtualdom_items_Element_Attribute$bubble = function( runloop, isEqual ) {
	
			return function Attribute$bubble() {
				var value = this.fragment.getValue();
				// TODO this can register the attribute multiple times (see render test
				// 'Attribute with nested mustaches')
				if ( !isEqual( value, this.value ) ) {
					// Need to clear old id from ractive.nodes
					if ( this.name === 'id' && this.value ) {
						delete this.root.nodes[ this.value ];
					}
					this.value = value;
					if ( this.name === 'value' && this.node ) {
						// We need to store the value on the DOM like this so we
						// can retrieve it later without it being coerced to a string
						this.node._ractive.value = value;
					}
					if ( this.rendered ) {
						runloop.addView( this );
					}
				}
			};
		}( runloop, isEqual );
	
		/* config/booleanAttributes.js */
		var booleanAttributes = function() {
	
			// https://github.com/kangax/html-minifier/issues/63#issuecomment-37763316
			var booleanAttributes = /^(allowFullscreen|async|autofocus|autoplay|checked|compact|controls|declare|default|defaultChecked|defaultMuted|defaultSelected|defer|disabled|draggable|enabled|formNoValidate|hidden|indeterminate|inert|isMap|itemScope|loop|multiple|muted|noHref|noResize|noShade|noValidate|noWrap|open|pauseOnExit|readOnly|required|reversed|scoped|seamless|selected|sortable|translate|trueSpeed|typeMustMatch|visible)$/i;
			return booleanAttributes;
		}();
	
		/* virtualdom/items/Element/Attribute/helpers/determineNameAndNamespace.js */
		var determineNameAndNamespace = function( namespaces, enforceCase ) {
	
			return function( attribute, name ) {
				var colonIndex, namespacePrefix;
				// are we dealing with a namespaced attribute, e.g. xlink:href?
				colonIndex = name.indexOf( ':' );
				if ( colonIndex !== -1 ) {
					// looks like we are, yes...
					namespacePrefix = name.substr( 0, colonIndex );
					// ...unless it's a namespace *declaration*, which we ignore (on the assumption
					// that only valid namespaces will be used)
					if ( namespacePrefix !== 'xmlns' ) {
						name = name.substring( colonIndex + 1 );
						attribute.name = enforceCase( name );
						attribute.namespace = namespaces[ namespacePrefix.toLowerCase() ];
						attribute.namespacePrefix = namespacePrefix;
						if ( !attribute.namespace ) {
							throw 'Unknown namespace ("' + namespacePrefix + '")';
						}
						return;
					}
				}
				// SVG attribute names are case sensitive
				attribute.name = attribute.element.namespace !== namespaces.html ? enforceCase( name ) : name;
			};
		}( namespaces, enforceCase );
	
		/* virtualdom/items/Element/Attribute/helpers/getInterpolator.js */
		var getInterpolator = function( types ) {
	
			return function getInterpolator( attribute ) {
				var items = attribute.fragment.items;
				if ( items.length !== 1 ) {
					return;
				}
				if ( items[ 0 ].type === types.INTERPOLATOR ) {
					return items[ 0 ];
				}
			};
		}( types );
	
		/* virtualdom/items/Element/Attribute/helpers/determinePropertyName.js */
		var determinePropertyName = function( namespaces, booleanAttributes ) {
	
			var propertyNames = {
				'accept-charset': 'acceptCharset',
				accesskey: 'accessKey',
				bgcolor: 'bgColor',
				'class': 'className',
				codebase: 'codeBase',
				colspan: 'colSpan',
				contenteditable: 'contentEditable',
				datetime: 'dateTime',
				dirname: 'dirName',
				'for': 'htmlFor',
				'http-equiv': 'httpEquiv',
				ismap: 'isMap',
				maxlength: 'maxLength',
				novalidate: 'noValidate',
				pubdate: 'pubDate',
				readonly: 'readOnly',
				rowspan: 'rowSpan',
				tabindex: 'tabIndex',
				usemap: 'useMap'
			};
			return function( attribute, options ) {
				var propertyName;
				if ( attribute.pNode && !attribute.namespace && ( !options.pNode.namespaceURI || options.pNode.namespaceURI === namespaces.html ) ) {
					propertyName = propertyNames[ attribute.name ] || attribute.name;
					if ( options.pNode[ propertyName ] !== undefined ) {
						attribute.propertyName = propertyName;
					}
					// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.
					// node.selected = true rather than node.setAttribute( 'selected', '' )
					if ( booleanAttributes.test( propertyName ) || propertyName === 'value' ) {
						attribute.useProperty = true;
					}
				}
			};
		}( namespaces, booleanAttributes );
	
		/* virtualdom/items/Element/Attribute/prototype/init.js */
		var virtualdom_items_Element_Attribute$init = function( types, booleanAttributes, determineNameAndNamespace, getInterpolator, determinePropertyName, circular ) {
	
			var Fragment;
			circular.push( function() {
				Fragment = circular.Fragment;
			} );
			return function Attribute$init( options ) {
				this.type = types.ATTRIBUTE;
				this.element = options.element;
				this.root = options.root;
				determineNameAndNamespace( this, options.name );
				// if it's an empty attribute, or just a straight key-value pair, with no
				// mustache shenanigans, set the attribute accordingly and go home
				if ( !options.value || typeof options.value === 'string' ) {
					this.value = booleanAttributes.test( this.name ) ? true : options.value || '';
					return;
				}
				// otherwise we need to do some work
				// share parentFragment with parent element
				this.parentFragment = this.element.parentFragment;
				this.fragment = new Fragment( {
					template: options.value,
					root: this.root,
					owner: this
				} );
				this.value = this.fragment.getValue();
				// Store a reference to this attribute's interpolator, if its fragment
				// takes the form `{{foo}}`. This is necessary for two-way binding and
				// for correctly rendering HTML later
				this.interpolator = getInterpolator( this );
				this.isBindable = !!this.interpolator && !this.interpolator.isStatic;
				// can we establish this attribute's property name equivalent?
				determinePropertyName( this, options );
				// mark as ready
				this.ready = true;
			};
		}( types, booleanAttributes, determineNameAndNamespace, getInterpolator, determinePropertyName, circular );
	
		/* virtualdom/items/Element/Attribute/prototype/rebind.js */
		var virtualdom_items_Element_Attribute$rebind = function Attribute$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
			if ( this.fragment ) {
				this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			}
		};
	
		/* virtualdom/items/Element/Attribute/prototype/render.js */
		var virtualdom_items_Element_Attribute$render = function( namespaces, booleanAttributes ) {
	
			var propertyNames = {
				'accept-charset': 'acceptCharset',
				'accesskey': 'accessKey',
				'bgcolor': 'bgColor',
				'class': 'className',
				'codebase': 'codeBase',
				'colspan': 'colSpan',
				'contenteditable': 'contentEditable',
				'datetime': 'dateTime',
				'dirname': 'dirName',
				'for': 'htmlFor',
				'http-equiv': 'httpEquiv',
				'ismap': 'isMap',
				'maxlength': 'maxLength',
				'novalidate': 'noValidate',
				'pubdate': 'pubDate',
				'readonly': 'readOnly',
				'rowspan': 'rowSpan',
				'tabindex': 'tabIndex',
				'usemap': 'useMap'
			};
			return function Attribute$render( node ) {
				var propertyName;
				this.node = node;
				// should we use direct property access, or setAttribute?
				if ( !node.namespaceURI || node.namespaceURI === namespaces.html ) {
					propertyName = propertyNames[ this.name ] || this.name;
					if ( node[ propertyName ] !== undefined ) {
						this.propertyName = propertyName;
					}
					// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.
					// node.selected = true rather than node.setAttribute( 'selected', '' )
					if ( booleanAttributes.test( propertyName ) || propertyName === 'value' ) {
						this.useProperty = true;
					}
					if ( propertyName === 'value' ) {
						this.useProperty = true;
						node._ractive.value = this.value;
					}
				}
				this.rendered = true;
				this.update();
			};
		}( namespaces, booleanAttributes );
	
		/* virtualdom/items/Element/Attribute/prototype/toString.js */
		var virtualdom_items_Element_Attribute$toString = function( booleanAttributes ) {
	
			var __export;
			__export = function Attribute$toString() {
				var name = ( fragment = this ).name,
					namespacePrefix = fragment.namespacePrefix,
					value = fragment.value,
					interpolator = fragment.interpolator,
					fragment = fragment.fragment;
				// Special case - select and textarea values (should not be stringified)
				if ( name === 'value' && ( this.element.name === 'select' || this.element.name === 'textarea' ) ) {
					return;
				}
				// Special case - content editable
				if ( name === 'value' && this.element.getAttribute( 'contenteditable' ) !== undefined ) {
					return;
				}
				// Special case - radio names
				if ( name === 'name' && this.element.name === 'input' && interpolator ) {
					return 'name={{' + ( interpolator.keypath || interpolator.ref ) + '}}';
				}
				// Boolean attributes
				if ( booleanAttributes.test( name ) ) {
					return value ? name : '';
				}
				if ( fragment ) {
					value = fragment.toString();
				}
				if ( namespacePrefix ) {
					name = namespacePrefix + ':' + name;
				}
				return value ? name + '="' + escape( value ) + '"' : name;
			};
	
			function escape( value ) {
				return value.replace( /&/g, '&amp;' ).replace( /"/g, '&quot;' ).replace( /'/g, '&#39;' );
			}
			return __export;
		}( booleanAttributes );
	
		/* virtualdom/items/Element/Attribute/prototype/unbind.js */
		var virtualdom_items_Element_Attribute$unbind = function Attribute$unbind() {
			// ignore non-dynamic attributes
			if ( this.fragment ) {
				this.fragment.unbind();
			}
			if ( this.name === 'id' ) {
				delete this.root.nodes[ this.value ];
			}
		};
	
		/* virtualdom/items/Element/Attribute/prototype/update/updateSelectValue.js */
		var virtualdom_items_Element_Attribute$update_updateSelectValue = function Attribute$updateSelect() {
			var value = this.value,
				options, option, optionValue, i;
			if ( !this.locked ) {
				this.node._ractive.value = value;
				options = this.node.options;
				i = options.length;
				while ( i-- ) {
					option = options[ i ];
					optionValue = option._ractive ? option._ractive.value : option.value;
					// options inserted via a triple don't have _ractive
					if ( optionValue == value ) {
						// double equals as we may be comparing numbers with strings
						option.selected = true;
						break;
					}
				}
			}
		};
	
		/* utils/arrayContains.js */
		var arrayContains = function arrayContains( array, value ) {
			for ( var i = 0, c = array.length; i < c; i++ ) {
				if ( array[ i ] == value ) {
					return true;
				}
			}
			return false;
		};
	
		/* virtualdom/items/Element/Attribute/prototype/update/updateMultipleSelectValue.js */
		var virtualdom_items_Element_Attribute$update_updateMultipleSelectValue = function( arrayContains, isArray ) {
	
			return function Attribute$updateMultipleSelect() {
				var value = this.value,
					options, i, option, optionValue;
				if ( !isArray( value ) ) {
					value = [ value ];
				}
				options = this.node.options;
				i = options.length;
				while ( i-- ) {
					option = options[ i ];
					optionValue = option._ractive ? option._ractive.value : option.value;
					// options inserted via a triple don't have _ractive
					option.selected = arrayContains( value, optionValue );
				}
			};
		}( arrayContains, isArray );
	
		/* virtualdom/items/Element/Attribute/prototype/update/updateRadioName.js */
		var virtualdom_items_Element_Attribute$update_updateRadioName = function Attribute$updateRadioName() {
			var node = ( value = this ).node,
				value = value.value;
			node.checked = value == node._ractive.value;
		};
	
		/* virtualdom/items/Element/Attribute/prototype/update/updateRadioValue.js */
		var virtualdom_items_Element_Attribute$update_updateRadioValue = function( runloop ) {
	
			return function Attribute$updateRadioValue() {
				var wasChecked, node = this.node,
					binding, bindings, i;
				wasChecked = node.checked;
				node.value = this.element.getAttribute( 'value' );
				node.checked = this.element.getAttribute( 'value' ) === this.element.getAttribute( 'name' );
				// This is a special case - if the input was checked, and the value
				// changed so that it's no longer checked, the twoway binding is
				// most likely out of date. To fix it we have to jump through some
				// hoops... this is a little kludgy but it works
				if ( wasChecked && !node.checked && this.element.binding ) {
					bindings = this.element.binding.siblings;
					if ( i = bindings.length ) {
						while ( i-- ) {
							binding = bindings[ i ];
							if ( !binding.element.node ) {
								// this is the initial render, siblings are still rendering!
								// we'll come back later...
								return;
							}
							if ( binding.element.node.checked ) {
								runloop.addViewmodel( binding.root.viewmodel );
								return binding.handleChange();
							}
						}
						runloop.addViewmodel( binding.root.viewmodel );
						this.root.viewmodel.set( binding.keypath, undefined );
					}
				}
			};
		}( runloop );
	
		/* virtualdom/items/Element/Attribute/prototype/update/updateCheckboxName.js */
		var virtualdom_items_Element_Attribute$update_updateCheckboxName = function( isArray ) {
	
			return function Attribute$updateCheckboxName() {
				var element = ( value = this ).element,
					node = value.node,
					value = value.value,
					valueAttribute, i;
				valueAttribute = element.getAttribute( 'value' );
				if ( !isArray( value ) ) {
					node.checked = value == valueAttribute;
				} else {
					i = value.length;
					while ( i-- ) {
						if ( valueAttribute == value[ i ] ) {
							node.checked = true;
							return;
						}
					}
					node.checked = false;
				}
			};
		}( isArray );
	
		/* virtualdom/items/Element/Attribute/prototype/update/updateClassName.js */
		var virtualdom_items_Element_Attribute$update_updateClassName = function Attribute$updateClassName() {
			var node, value;
			node = this.node;
			value = this.value;
			if ( value === undefined ) {
				value = '';
			}
			node.className = value;
		};
	
		/* virtualdom/items/Element/Attribute/prototype/update/updateIdAttribute.js */
		var virtualdom_items_Element_Attribute$update_updateIdAttribute = function Attribute$updateIdAttribute() {
			var node = ( value = this ).node,
				value = value.value;
			this.root.nodes[ value ] = node;
			node.id = value;
		};
	
		/* virtualdom/items/Element/Attribute/prototype/update/updateIEStyleAttribute.js */
		var virtualdom_items_Element_Attribute$update_updateIEStyleAttribute = function Attribute$updateIEStyleAttribute() {
			var node, value;
			node = this.node;
			value = this.value;
			if ( value === undefined ) {
				value = '';
			}
			node.style.setAttribute( 'cssText', value );
		};
	
		/* virtualdom/items/Element/Attribute/prototype/update/updateContentEditableValue.js */
		var virtualdom_items_Element_Attribute$update_updateContentEditableValue = function Attribute$updateContentEditableValue() {
			var value = this.value;
			if ( value === undefined ) {
				value = '';
			}
			if ( !this.locked ) {
				this.node.innerHTML = value;
			}
		};
	
		/* virtualdom/items/Element/Attribute/prototype/update/updateValue.js */
		var virtualdom_items_Element_Attribute$update_updateValue = function Attribute$updateValue() {
			var node = ( value = this ).node,
				value = value.value;
			// store actual value, so it doesn't get coerced to a string
			node._ractive.value = value;
			// with two-way binding, only update if the change wasn't initiated by the user
			// otherwise the cursor will often be sent to the wrong place
			if ( !this.locked ) {
				node.value = value == undefined ? '' : value;
			}
		};
	
		/* virtualdom/items/Element/Attribute/prototype/update/updateBoolean.js */
		var virtualdom_items_Element_Attribute$update_updateBoolean = function Attribute$updateBooleanAttribute() {
			// with two-way binding, only update if the change wasn't initiated by the user
			// otherwise the cursor will often be sent to the wrong place
			if ( !this.locked ) {
				this.node[ this.propertyName ] = this.value;
			}
		};
	
		/* virtualdom/items/Element/Attribute/prototype/update/updateEverythingElse.js */
		var virtualdom_items_Element_Attribute$update_updateEverythingElse = function( booleanAttributes ) {
	
			return function Attribute$updateEverythingElse() {
				var node = ( fragment = this ).node,
					namespace = fragment.namespace,
					name = fragment.name,
					value = fragment.value,
					fragment = fragment.fragment;
				if ( namespace ) {
					node.setAttributeNS( namespace, name, ( fragment || value ).toString() );
				} else if ( !booleanAttributes.test( name ) ) {
					node.setAttribute( name, ( fragment || value ).toString() );
				} else {
					if ( value ) {
						node.setAttribute( name, '' );
					} else {
						node.removeAttribute( name );
					}
				}
			};
		}( booleanAttributes );
	
		/* virtualdom/items/Element/Attribute/prototype/update.js */
		var virtualdom_items_Element_Attribute$update = function( namespaces, noop, updateSelectValue, updateMultipleSelectValue, updateRadioName, updateRadioValue, updateCheckboxName, updateClassName, updateIdAttribute, updateIEStyleAttribute, updateContentEditableValue, updateValue, updateBoolean, updateEverythingElse ) {
	
			return function Attribute$update() {
				var name = ( node = this ).name,
					element = node.element,
					node = node.node,
					type, updateMethod;
				if ( name === 'id' ) {
					updateMethod = updateIdAttribute;
				} else if ( name === 'value' ) {
					// special case - selects
					if ( element.name === 'select' && name === 'value' ) {
						updateMethod = element.getAttribute( 'multiple' ) ? updateMultipleSelectValue : updateSelectValue;
					} else if ( element.name === 'textarea' ) {
						updateMethod = updateValue;
					} else if ( element.getAttribute( 'contenteditable' ) != null ) {
						updateMethod = updateContentEditableValue;
					} else if ( element.name === 'input' ) {
						type = element.getAttribute( 'type' );
						// type='file' value='{{fileList}}'>
						if ( type === 'file' ) {
							updateMethod = noop;
						} else if ( type === 'radio' && element.binding && element.binding.name === 'name' ) {
							updateMethod = updateRadioValue;
						} else {
							updateMethod = updateValue;
						}
					}
				} else if ( this.twoway && name === 'name' ) {
					if ( node.type === 'radio' ) {
						updateMethod = updateRadioName;
					} else if ( node.type === 'checkbox' ) {
						updateMethod = updateCheckboxName;
					}
				} else if ( name === 'style' && node.style.setAttribute ) {
					updateMethod = updateIEStyleAttribute;
				} else if ( name === 'class' && ( !node.namespaceURI || node.namespaceURI === namespaces.html ) ) {
					updateMethod = updateClassName;
				} else if ( this.useProperty ) {
					updateMethod = updateBoolean;
				}
				if ( !updateMethod ) {
					updateMethod = updateEverythingElse;
				}
				this.update = updateMethod;
				this.update();
			};
		}( namespaces, noop, virtualdom_items_Element_Attribute$update_updateSelectValue, virtualdom_items_Element_Attribute$update_updateMultipleSelectValue, virtualdom_items_Element_Attribute$update_updateRadioName, virtualdom_items_Element_Attribute$update_updateRadioValue, virtualdom_items_Element_Attribute$update_updateCheckboxName, virtualdom_items_Element_Attribute$update_updateClassName, virtualdom_items_Element_Attribute$update_updateIdAttribute, virtualdom_items_Element_Attribute$update_updateIEStyleAttribute, virtualdom_items_Element_Attribute$update_updateContentEditableValue, virtualdom_items_Element_Attribute$update_updateValue, virtualdom_items_Element_Attribute$update_updateBoolean, virtualdom_items_Element_Attribute$update_updateEverythingElse );
	
		/* virtualdom/items/Element/Attribute/_Attribute.js */
		var Attribute = function( bubble, init, rebind, render, toString, unbind, update ) {
	
			var Attribute = function( options ) {
				this.init( options );
			};
			Attribute.prototype = {
				bubble: bubble,
				init: init,
				rebind: rebind,
				render: render,
				toString: toString,
				unbind: unbind,
				update: update
			};
			return Attribute;
		}( virtualdom_items_Element_Attribute$bubble, virtualdom_items_Element_Attribute$init, virtualdom_items_Element_Attribute$rebind, virtualdom_items_Element_Attribute$render, virtualdom_items_Element_Attribute$toString, virtualdom_items_Element_Attribute$unbind, virtualdom_items_Element_Attribute$update );
	
		/* virtualdom/items/Element/prototype/init/createAttributes.js */
		var virtualdom_items_Element$init_createAttributes = function( Attribute ) {
	
			return function( element, attributes ) {
				var name, attribute, result = [];
				for ( name in attributes ) {
					if ( attributes.hasOwnProperty( name ) ) {
						attribute = new Attribute( {
							element: element,
							name: name,
							value: attributes[ name ],
							root: element.root
						} );
						result.push( result[ name ] = attribute );
					}
				}
				return result;
			};
		}( Attribute );
	
		/* virtualdom/items/Element/ConditionalAttribute/_ConditionalAttribute.js */
		var ConditionalAttribute = function( circular, namespaces, createElement, toArray ) {
	
			var __export;
			var Fragment, div;
			if ( typeof document !== 'undefined' ) {
				div = createElement( 'div' );
			}
			circular.push( function() {
				Fragment = circular.Fragment;
			} );
			var ConditionalAttribute = function( element, template ) {
				this.element = element;
				this.root = element.root;
				this.parentFragment = element.parentFragment;
				this.attributes = [];
				this.fragment = new Fragment( {
					root: element.root,
					owner: this,
					template: [ template ]
				} );
			};
			ConditionalAttribute.prototype = {
				bubble: function() {
					if ( this.node ) {
						this.update();
					}
					this.element.bubble();
				},
				rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
					this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
				},
				render: function( node ) {
					this.node = node;
					this.isSvg = node.namespaceURI === namespaces.svg;
					this.update();
				},
				unbind: function() {
					this.fragment.unbind();
				},
				update: function() {
					var this$0 = this;
					var str, attrs;
					str = this.fragment.toString();
					attrs = parseAttributes( str, this.isSvg );
					// any attributes that previously existed but no longer do
					// must be removed
					this.attributes.filter( function( a ) {
						return notIn( attrs, a );
					} ).forEach( function( a ) {
						this$0.node.removeAttribute( a.name );
					} );
					attrs.forEach( function( a ) {
						this$0.node.setAttribute( a.name, a.value );
					} );
					this.attributes = attrs;
				},
				toString: function() {
					return this.fragment.toString();
				}
			};
			__export = ConditionalAttribute;
	
			function parseAttributes( str, isSvg ) {
				var tag = isSvg ? 'svg' : 'div';
				div.innerHTML = '<' + tag + ' ' + str + '></' + tag + '>';
				return toArray( div.childNodes[ 0 ].attributes );
			}
	
			function notIn( haystack, needle ) {
				var i = haystack.length;
				while ( i-- ) {
					if ( haystack[ i ].name === needle.name ) {
						return false;
					}
				}
				return true;
			}
			return __export;
		}( circular, namespaces, createElement, toArray );
	
		/* virtualdom/items/Element/prototype/init/createConditionalAttributes.js */
		var virtualdom_items_Element$init_createConditionalAttributes = function( ConditionalAttribute ) {
	
			return function( element, attributes ) {
				if ( !attributes ) {
					return [];
				}
				return attributes.map( function( a ) {
					return new ConditionalAttribute( element, a );
				} );
			};
		}( ConditionalAttribute );
	
		/* utils/extend.js */
		var extend = function( target ) {
			var SLICE$0 = Array.prototype.slice;
			var sources = SLICE$0.call( arguments, 1 );
			var prop, source;
			while ( source = sources.shift() ) {
				for ( prop in source ) {
					if ( source.hasOwnProperty( prop ) ) {
						target[ prop ] = source[ prop ];
					}
				}
			}
			return target;
		};
	
		/* virtualdom/items/Element/Binding/Binding.js */
		var Binding = function( runloop, warn, create, extend, removeFromArray ) {
	
			var Binding = function( element ) {
				var interpolator, keypath, value;
				this.element = element;
				this.root = element.root;
				this.attribute = element.attributes[ this.name || 'value' ];
				interpolator = this.attribute.interpolator;
				interpolator.twowayBinding = this;
				if ( interpolator.keypath && interpolator.keypath.substr( 0, 2 ) === '${' ) {
					warn( 'Two-way binding does not work with expressions (`' + interpolator.keypath.slice( 2, -1 ) + '`)' );
					return false;
				}
				// A mustache may be *ambiguous*. Let's say we were given
				// `value="{{bar}}"`. If the context was `foo`, and `foo.bar`
				// *wasn't* `undefined`, the keypath would be `foo.bar`.
				// Then, any user input would result in `foo.bar` being updated.
				//
				// If, however, `foo.bar` *was* undefined, and so was `bar`, we would be
				// left with an unresolved partial keypath - so we are forced to make an
				// assumption. That assumption is that the input in question should
				// be forced to resolve to `bar`, and any user input would affect `bar`
				// and not `foo.bar`.
				//
				// Did that make any sense? No? Oh. Sorry. Well the moral of the story is
				// be explicit when using two-way data-binding about what keypath you're
				// updating. Using it in lists is probably a recipe for confusion...
				if ( !interpolator.keypath ) {
					interpolator.resolver.forceResolution();
				}
				this.keypath = keypath = interpolator.keypath;
				// initialise value, if it's undefined
				if ( this.root.viewmodel.get( keypath ) === undefined && this.getInitialValue ) {
					value = this.getInitialValue();
					if ( value !== undefined ) {
						this.root.viewmodel.set( keypath, value );
					}
				}
			};
			Binding.prototype = {
				handleChange: function() {
					var this$0 = this;
					runloop.start( this.root );
					this.attribute.locked = true;
					this.root.viewmodel.set( this.keypath, this.getValue() );
					runloop.scheduleTask( function() {
						return this$0.attribute.locked = false;
					} );
					runloop.end();
				},
				rebound: function() {
					var bindings, oldKeypath, newKeypath;
					oldKeypath = this.keypath;
					newKeypath = this.attribute.interpolator.keypath;
					// The attribute this binding is linked to has already done the work
					if ( oldKeypath === newKeypath ) {
						return;
					}
					removeFromArray( this.root._twowayBindings[ oldKeypath ], this );
					this.keypath = newKeypath;
					bindings = this.root._twowayBindings[ newKeypath ] || ( this.root._twowayBindings[ newKeypath ] = [] );
					bindings.push( this );
				},
				unbind: function() {}
			};
			Binding.extend = function( properties ) {
				var Parent = this,
					SpecialisedBinding;
				SpecialisedBinding = function( element ) {
					Binding.call( this, element );
					if ( this.init ) {
						this.init();
					}
				};
				SpecialisedBinding.prototype = create( Parent.prototype );
				extend( SpecialisedBinding.prototype, properties );
				SpecialisedBinding.extend = Binding.extend;
				return SpecialisedBinding;
			};
			return Binding;
		}( runloop, warn, create, extend, removeFromArray );
	
		/* virtualdom/items/Element/Binding/shared/handleDomEvent.js */
		var handleDomEvent = function handleChange() {
			this._ractive.binding.handleChange();
		};
	
		/* virtualdom/items/Element/Binding/ContentEditableBinding.js */
		var ContentEditableBinding = function( Binding, handleDomEvent ) {
	
			var ContentEditableBinding = Binding.extend( {
				getInitialValue: function() {
					return this.element.fragment ? this.element.fragment.toString() : '';
				},
				render: function() {
					var node = this.element.node;
					node.addEventListener( 'change', handleDomEvent, false );
					if ( !this.root.lazy ) {
						node.addEventListener( 'input', handleDomEvent, false );
						if ( node.attachEvent ) {
							node.addEventListener( 'keyup', handleDomEvent, false );
						}
					}
				},
				unrender: function() {
					var node = this.element.node;
					node.removeEventListener( 'change', handleDomEvent, false );
					node.removeEventListener( 'input', handleDomEvent, false );
					node.removeEventListener( 'keyup', handleDomEvent, false );
				},
				getValue: function() {
					return this.element.node.innerHTML;
				}
			} );
			return ContentEditableBinding;
		}( Binding, handleDomEvent );
	
		/* virtualdom/items/Element/Binding/shared/getSiblings.js */
		var getSiblings = function() {
	
			var sets = {};
			return function getSiblings( id, group, keypath ) {
				var hash = id + group + keypath;
				return sets[ hash ] || ( sets[ hash ] = [] );
			};
		}();
	
		/* virtualdom/items/Element/Binding/RadioBinding.js */
		var RadioBinding = function( runloop, removeFromArray, Binding, getSiblings, handleDomEvent ) {
	
			var RadioBinding = Binding.extend( {
				name: 'checked',
				init: function() {
					this.siblings = getSiblings( this.root._guid, 'radio', this.element.getAttribute( 'name' ) );
					this.siblings.push( this );
				},
				render: function() {
					var node = this.element.node;
					node.addEventListener( 'change', handleDomEvent, false );
					if ( node.attachEvent ) {
						node.addEventListener( 'click', handleDomEvent, false );
					}
				},
				unrender: function() {
					var node = this.element.node;
					node.removeEventListener( 'change', handleDomEvent, false );
					node.removeEventListener( 'click', handleDomEvent, false );
				},
				handleChange: function() {
					runloop.start( this.root );
					this.siblings.forEach( function( binding ) {
						binding.root.viewmodel.set( binding.keypath, binding.getValue() );
					} );
					runloop.end();
				},
				getValue: function() {
					return this.element.node.checked;
				},
				unbind: function() {
					removeFromArray( this.siblings, this );
				}
			} );
			return RadioBinding;
		}( runloop, removeFromArray, Binding, getSiblings, handleDomEvent );
	
		/* virtualdom/items/Element/Binding/RadioNameBinding.js */
		var RadioNameBinding = function( removeFromArray, Binding, handleDomEvent, getSiblings ) {
	
			var RadioNameBinding = Binding.extend( {
				name: 'name',
				init: function() {
					this.siblings = getSiblings( this.root._guid, 'radioname', this.keypath );
					this.siblings.push( this );
					this.radioName = true;
					// so that ractive.updateModel() knows what to do with this
					this.attribute.twoway = true;
				},
				getInitialValue: function() {
					if ( this.element.getAttribute( 'checked' ) ) {
						return this.element.getAttribute( 'value' );
					}
				},
				render: function() {
					var node = this.element.node;
					node.name = '{{' + this.keypath + '}}';
					node.checked = this.root.viewmodel.get( this.keypath ) == this.element.getAttribute( 'value' );
					node.addEventListener( 'change', handleDomEvent, false );
					if ( node.attachEvent ) {
						node.addEventListener( 'click', handleDomEvent, false );
					}
				},
				unrender: function() {
					var node = this.element.node;
					node.removeEventListener( 'change', handleDomEvent, false );
					node.removeEventListener( 'click', handleDomEvent, false );
				},
				getValue: function() {
					var node = this.element.node;
					return node._ractive ? node._ractive.value : node.value;
				},
				handleChange: function() {
					// If this <input> is the one that's checked, then the value of its
					// `name` keypath gets set to its value
					if ( this.element.node.checked ) {
						Binding.prototype.handleChange.call( this );
					}
				},
				rebound: function( indexRef, newIndex, oldKeypath, newKeypath ) {
					var node;
					Binding.prototype.rebound.call( this, indexRef, newIndex, oldKeypath, newKeypath );
					if ( node = this.element.node ) {
						node.name = '{{' + this.keypath + '}}';
					}
				},
				unbind: function() {
					removeFromArray( this.siblings, this );
				}
			} );
			return RadioNameBinding;
		}( removeFromArray, Binding, handleDomEvent, getSiblings );
	
		/* virtualdom/items/Element/Binding/CheckboxNameBinding.js */
		var CheckboxNameBinding = function( isArray, arrayContains, removeFromArray, Binding, getSiblings, handleDomEvent ) {
	
			var CheckboxNameBinding = Binding.extend( {
				name: 'name',
				getInitialValue: function() {
					// This only gets called once per group (of inputs that
					// share a name), because it only gets called if there
					// isn't an initial value. By the same token, we can make
					// a note of that fact that there was no initial value,
					// and populate it using any `checked` attributes that
					// exist (which users should avoid, but which we should
					// support anyway to avoid breaking expectations)
					this.noInitialValue = true;
					return [];
				},
				init: function() {
					var existingValue, bindingValue;
					this.checkboxName = true;
					// so that ractive.updateModel() knows what to do with this
					this.attribute.twoway = true;
					// we set this property so that the attribute gets the correct update method
					// Each input has a reference to an array containing it and its
					// siblings, as two-way binding depends on being able to ascertain
					// the status of all inputs within the group
					this.siblings = getSiblings( this.root._guid, 'checkboxes', this.keypath );
					this.siblings.push( this );
					if ( this.noInitialValue ) {
						this.siblings.noInitialValue = true;
					}
					// If no initial value was set, and this input is checked, we
					// update the model
					if ( this.siblings.noInitialValue && this.element.getAttribute( 'checked' ) ) {
						existingValue = this.root.viewmodel.get( this.keypath );
						bindingValue = this.element.getAttribute( 'value' );
						existingValue.push( bindingValue );
					}
				},
				unbind: function() {
					removeFromArray( this.siblings, this );
				},
				render: function() {
					var node = this.element.node,
						existingValue, bindingValue;
					existingValue = this.root.viewmodel.get( this.keypath );
					bindingValue = this.element.getAttribute( 'value' );
					if ( isArray( existingValue ) ) {
						this.isChecked = arrayContains( existingValue, bindingValue );
					} else {
						this.isChecked = existingValue == bindingValue;
					}
					node.name = '{{' + this.keypath + '}}';
					node.checked = this.isChecked;
					node.addEventListener( 'change', handleDomEvent, false );
					// in case of IE emergency, bind to click event as well
					if ( node.attachEvent ) {
						node.addEventListener( 'click', handleDomEvent, false );
					}
				},
				unrender: function() {
					var node = this.element.node;
					node.removeEventListener( 'change', handleDomEvent, false );
					node.removeEventListener( 'click', handleDomEvent, false );
				},
				changed: function() {
					var wasChecked = !!this.isChecked;
					this.isChecked = this.element.node.checked;
					return this.isChecked === wasChecked;
				},
				handleChange: function() {
					this.isChecked = this.element.node.checked;
					Binding.prototype.handleChange.call( this );
				},
				getValue: function() {
					return this.siblings.filter( isChecked ).map( getValue );
				}
			} );
	
			function isChecked( binding ) {
				return binding.isChecked;
			}
	
			function getValue( binding ) {
				return binding.element.getAttribute( 'value' );
			}
			return CheckboxNameBinding;
		}( isArray, arrayContains, removeFromArray, Binding, getSiblings, handleDomEvent );
	
		/* virtualdom/items/Element/Binding/CheckboxBinding.js */
		var CheckboxBinding = function( Binding, handleDomEvent ) {
	
			var CheckboxBinding = Binding.extend( {
				name: 'checked',
				render: function() {
					var node = this.element.node;
					node.addEventListener( 'change', handleDomEvent, false );
					if ( node.attachEvent ) {
						node.addEventListener( 'click', handleDomEvent, false );
					}
				},
				unrender: function() {
					var node = this.element.node;
					node.removeEventListener( 'change', handleDomEvent, false );
					node.removeEventListener( 'click', handleDomEvent, false );
				},
				getValue: function() {
					return this.element.node.checked;
				}
			} );
			return CheckboxBinding;
		}( Binding, handleDomEvent );
	
		/* virtualdom/items/Element/Binding/SelectBinding.js */
		var SelectBinding = function( runloop, Binding, handleDomEvent ) {
	
			var SelectBinding = Binding.extend( {
				getInitialValue: function() {
					var options = this.element.options,
						len, i, value, optionWasSelected;
					if ( this.element.getAttribute( 'value' ) !== undefined ) {
						return;
					}
					i = len = options.length;
					if ( !len ) {
						return;
					}
					// take the final selected option...
					while ( i-- ) {
						if ( options[ i ].getAttribute( 'selected' ) ) {
							value = options[ i ].getAttribute( 'value' );
							optionWasSelected = true;
							break;
						}
					}
					// or the first non-disabled option, if none are selected
					if ( !optionWasSelected ) {
						while ( ++i < len ) {
							if ( !options[ i ].getAttribute( 'disabled' ) ) {
								value = options[ i ].getAttribute( 'value' );
								break;
							}
						}
					}
					// This is an optimisation (aka hack) that allows us to forgo some
					// other more expensive work
					if ( value !== undefined ) {
						this.element.attributes.value.value = value;
					}
					return value;
				},
				render: function() {
					this.element.node.addEventListener( 'change', handleDomEvent, false );
				},
				unrender: function() {
					this.element.node.removeEventListener( 'change', handleDomEvent, false );
				},
				// TODO this method is an anomaly... is it necessary?
				setValue: function( value ) {
					runloop.addViewmodel( this.root.viewmodel );
					this.root.viewmodel.set( this.keypath, value );
				},
				getValue: function() {
					var options, i, len, option, optionValue;
					options = this.element.node.options;
					len = options.length;
					for ( i = 0; i < len; i += 1 ) {
						option = options[ i ];
						if ( options[ i ].selected ) {
							optionValue = option._ractive ? option._ractive.value : option.value;
							return optionValue;
						}
					}
				},
				forceUpdate: function() {
					var this$0 = this;
					var value = this.getValue();
					if ( value !== undefined ) {
						this.attribute.locked = true;
						runloop.addViewmodel( this.root.viewmodel );
						runloop.scheduleTask( function() {
							return this$0.attribute.locked = false;
						} );
						this.root.viewmodel.set( this.keypath, value );
					}
				}
			} );
			return SelectBinding;
		}( runloop, Binding, handleDomEvent );
	
		/* utils/arrayContentsMatch.js */
		var arrayContentsMatch = function( isArray ) {
	
			return function( a, b ) {
				var i;
				if ( !isArray( a ) || !isArray( b ) ) {
					return false;
				}
				if ( a.length !== b.length ) {
					return false;
				}
				i = a.length;
				while ( i-- ) {
					if ( a[ i ] !== b[ i ] ) {
						return false;
					}
				}
				return true;
			};
		}( isArray );
	
		/* virtualdom/items/Element/Binding/MultipleSelectBinding.js */
		var MultipleSelectBinding = function( runloop, arrayContentsMatch, SelectBinding, handleDomEvent ) {
	
			var MultipleSelectBinding = SelectBinding.extend( {
				getInitialValue: function() {
					return this.element.options.filter( function( option ) {
						return option.getAttribute( 'selected' );
					} ).map( function( option ) {
						return option.getAttribute( 'value' );
					} );
				},
				render: function() {
					var valueFromModel;
					this.element.node.addEventListener( 'change', handleDomEvent, false );
					valueFromModel = this.root.viewmodel.get( this.keypath );
					if ( valueFromModel === undefined ) {
						// get value from DOM, if possible
						this.handleChange();
					}
				},
				unrender: function() {
					this.element.node.removeEventListener( 'change', handleDomEvent, false );
				},
				setValue: function() {
					throw new Error( 'TODO not implemented yet' );
				},
				getValue: function() {
					var selectedValues, options, i, len, option, optionValue;
					selectedValues = [];
					options = this.element.node.options;
					len = options.length;
					for ( i = 0; i < len; i += 1 ) {
						option = options[ i ];
						if ( option.selected ) {
							optionValue = option._ractive ? option._ractive.value : option.value;
							selectedValues.push( optionValue );
						}
					}
					return selectedValues;
				},
				handleChange: function() {
					var attribute, previousValue, value;
					attribute = this.attribute;
					previousValue = attribute.value;
					value = this.getValue();
					if ( previousValue === undefined || !arrayContentsMatch( value, previousValue ) ) {
						SelectBinding.prototype.handleChange.call( this );
					}
					return this;
				},
				forceUpdate: function() {
					var this$0 = this;
					var value = this.getValue();
					if ( value !== undefined ) {
						this.attribute.locked = true;
						runloop.addViewmodel( this.root.viewmodel );
						runloop.scheduleTask( function() {
							return this$0.attribute.locked = false;
						} );
						this.root.viewmodel.set( this.keypath, value );
					}
				},
				updateModel: function() {
					if ( this.attribute.value === undefined || !this.attribute.value.length ) {
						this.root.viewmodel.set( this.keypath, this.initialValue );
					}
				}
			} );
			return MultipleSelectBinding;
		}( runloop, arrayContentsMatch, SelectBinding, handleDomEvent );
	
		/* virtualdom/items/Element/Binding/FileListBinding.js */
		var FileListBinding = function( Binding, handleDomEvent ) {
	
			var FileListBinding = Binding.extend( {
				render: function() {
					this.element.node.addEventListener( 'change', handleDomEvent, false );
				},
				unrender: function() {
					this.element.node.removeEventListener( 'change', handleDomEvent, false );
				},
				getValue: function() {
					return this.element.node.files;
				}
			} );
			return FileListBinding;
		}( Binding, handleDomEvent );
	
		/* virtualdom/items/Element/Binding/GenericBinding.js */
		var GenericBinding = function( Binding, handleDomEvent ) {
	
			var __export;
			var GenericBinding, getOptions;
			getOptions = {
				evaluateWrapped: true
			};
			GenericBinding = Binding.extend( {
				getInitialValue: function() {
					return '';
				},
				getValue: function() {
					return this.element.node.value;
				},
				render: function() {
					var node = this.element.node;
					node.addEventListener( 'change', handleDomEvent, false );
					if ( !this.root.lazy ) {
						node.addEventListener( 'input', handleDomEvent, false );
						if ( node.attachEvent ) {
							node.addEventListener( 'keyup', handleDomEvent, false );
						}
					}
					node.addEventListener( 'blur', handleBlur, false );
				},
				unrender: function() {
					var node = this.element.node;
					node.removeEventListener( 'change', handleDomEvent, false );
					node.removeEventListener( 'input', handleDomEvent, false );
					node.removeEventListener( 'keyup', handleDomEvent, false );
					node.removeEventListener( 'blur', handleBlur, false );
				}
			} );
			__export = GenericBinding;
	
			function handleBlur() {
				var value;
				handleDomEvent.call( this );
				value = this._ractive.root.viewmodel.get( this._ractive.binding.keypath, getOptions );
				this.value = value == undefined ? '' : value;
			}
			return __export;
		}( Binding, handleDomEvent );
	
		/* virtualdom/items/Element/Binding/NumericBinding.js */
		var NumericBinding = function( GenericBinding ) {
	
			return GenericBinding.extend( {
				getInitialValue: function() {
					return undefined;
				},
				getValue: function() {
					var value = parseFloat( this.element.node.value );
					return isNaN( value ) ? undefined : value;
				}
			} );
		}( GenericBinding );
	
		/* virtualdom/items/Element/prototype/init/createTwowayBinding.js */
		var virtualdom_items_Element$init_createTwowayBinding = function( log, ContentEditableBinding, RadioBinding, RadioNameBinding, CheckboxNameBinding, CheckboxBinding, SelectBinding, MultipleSelectBinding, FileListBinding, NumericBinding, GenericBinding ) {
	
			var __export;
			__export = function createTwowayBinding( element ) {
				var attributes = element.attributes,
					type, Binding, bindName, bindChecked;
				// if this is a late binding, and there's already one, it
				// needs to be torn down
				if ( element.binding ) {
					element.binding.teardown();
					element.binding = null;
				}
				// contenteditable
				if ( // if the contenteditable attribute is true or is bindable and may thus become true
					( element.getAttribute( 'contenteditable' ) || !!attributes.contenteditable && isBindable( attributes.contenteditable ) ) && isBindable( attributes.value ) ) {
					Binding = ContentEditableBinding;
				} else if ( element.name === 'input' ) {
					type = element.getAttribute( 'type' );
					if ( type === 'radio' || type === 'checkbox' ) {
						bindName = isBindable( attributes.name );
						bindChecked = isBindable( attributes.checked );
						// we can either bind the name attribute, or the checked attribute - not both
						if ( bindName && bindChecked ) {
							log.error( {
								message: 'badRadioInputBinding'
							} );
						}
						if ( bindName ) {
							Binding = type === 'radio' ? RadioNameBinding : CheckboxNameBinding;
						} else if ( bindChecked ) {
							Binding = type === 'radio' ? RadioBinding : CheckboxBinding;
						}
					} else if ( type === 'file' && isBindable( attributes.value ) ) {
						Binding = FileListBinding;
					} else if ( isBindable( attributes.value ) ) {
						Binding = type === 'number' || type === 'range' ? NumericBinding : GenericBinding;
					}
				} else if ( element.name === 'select' && isBindable( attributes.value ) ) {
					Binding = element.getAttribute( 'multiple' ) ? MultipleSelectBinding : SelectBinding;
				} else if ( element.name === 'textarea' && isBindable( attributes.value ) ) {
					Binding = GenericBinding;
				}
				if ( Binding ) {
					return new Binding( element );
				}
			};
	
			function isBindable( attribute ) {
				return attribute && attribute.isBindable;
			}
			return __export;
		}( log, ContentEditableBinding, RadioBinding, RadioNameBinding, CheckboxNameBinding, CheckboxBinding, SelectBinding, MultipleSelectBinding, FileListBinding, NumericBinding, GenericBinding );
	
		/* virtualdom/items/Element/EventHandler/prototype/bubble.js */
		var virtualdom_items_Element_EventHandler$bubble = function EventHandler$bubble() {
			var hasAction = this.getAction();
			if ( hasAction && !this.hasListener ) {
				this.listen();
			} else if ( !hasAction && this.hasListener ) {
				this.unrender();
			}
		};
	
		/* virtualdom/items/Element/EventHandler/prototype/fire.js */
		var virtualdom_items_Element_EventHandler$fire = function( fireEvent ) {
	
			return function EventHandler$fire( event ) {
				fireEvent( this.root, this.getAction(), {
					event: event
				} );
			};
		}( Ractive$shared_fireEvent );
	
		/* virtualdom/items/Element/EventHandler/prototype/getAction.js */
		var virtualdom_items_Element_EventHandler$getAction = function EventHandler$getAction() {
			return this.action.toString().trim();
		};
	
		/* virtualdom/items/Element/EventHandler/prototype/init.js */
		var virtualdom_items_Element_EventHandler$init = function( getFunctionFromString, createReferenceResolver, circular, fireEvent, log ) {
	
			var __export;
			var Fragment, getValueOptions = {
					args: true
				},
				eventPattern = /^event(?:\.(.+))?/;
			circular.push( function() {
				Fragment = circular.Fragment;
			} );
			__export = function EventHandler$init( element, name, template ) {
				var handler = this,
					action, refs, ractive;
				handler.element = element;
				handler.root = element.root;
				handler.name = name;
				if ( name.indexOf( '*' ) !== -1 ) {
					log.error( {
						debug: this.root.debug,
						message: 'noElementProxyEventWildcards',
						args: {
							element: element.tagName,
							event: name
						}
					} );
					this.invalid = true;
				}
				if ( template.m ) {
					refs = template.a.r;
					// This is a method call
					handler.method = template.m;
					handler.keypaths = [];
					handler.fn = getFunctionFromString( template.a.s, refs.length );
					handler.parentFragment = element.parentFragment;
					ractive = handler.root;
					// Create resolvers for each reference
					handler.refResolvers = refs.map( function( ref, i ) {
						var match;
						// special case - the `event` object
						if ( match = eventPattern.exec( ref ) ) {
							handler.keypaths[ i ] = {
								eventObject: true,
								refinements: match[ 1 ] ? match[ 1 ].split( '.' ) : []
							};
							return null;
						}
						return createReferenceResolver( handler, ref, function( keypath ) {
							handler.resolve( i, keypath );
						} );
					} );
					this.fire = fireMethodCall;
				} else {
					// Get action ('foo' in 'on-click='foo')
					action = template.n || template;
					if ( typeof action !== 'string' ) {
						action = new Fragment( {
							template: action,
							root: this.root,
							owner: this
						} );
					}
					this.action = action;
					// Get parameters
					if ( template.d ) {
						this.dynamicParams = new Fragment( {
							template: template.d,
							root: this.root,
							owner: this.element
						} );
						this.fire = fireEventWithDynamicParams;
					} else if ( template.a ) {
						this.params = template.a;
						this.fire = fireEventWithParams;
					}
				}
			};
	
			function fireMethodCall( event ) {
				var ractive, values, args;
				ractive = this.root;
				if ( typeof ractive[ this.method ] !== 'function' ) {
					throw new Error( 'Attempted to call a non-existent method ("' + this.method + '")' );
				}
				values = this.keypaths.map( function( keypath ) {
					var value, len, i;
					if ( keypath === undefined ) {
						// not yet resolved
						return undefined;
					}
					// TODO the refinements stuff would be better handled at parse time
					if ( keypath.eventObject ) {
						value = event;
						if ( len = keypath.refinements.length ) {
							for ( i = 0; i < len; i += 1 ) {
								value = value[ keypath.refinements[ i ] ];
							}
						}
					} else {
						value = ractive.viewmodel.get( keypath );
					}
					return value;
				} );
				ractive.event = event;
				args = this.fn.apply( null, values );
				ractive[ this.method ].apply( ractive, args );
				delete ractive.event;
			}
	
			function fireEventWithParams( event ) {
				fireEvent( this.root, this.getAction(), {
					event: event,
					args: this.params
				} );
			}
	
			function fireEventWithDynamicParams( event ) {
				var args = this.dynamicParams.getValue( getValueOptions );
				// need to strip [] from ends if a string!
				if ( typeof args === 'string' ) {
					args = args.substr( 1, args.length - 2 );
				}
				fireEvent( this.root, this.getAction(), {
					event: event,
					args: args
				} );
			}
			return __export;
		}( getFunctionFromString, createReferenceResolver, circular, Ractive$shared_fireEvent, log );
	
		/* virtualdom/items/Element/EventHandler/shared/genericHandler.js */
		var genericHandler = function genericHandler( event ) {
			var storage, handler;
			storage = this._ractive;
			handler = storage.events[ event.type ];
			handler.fire( {
				node: this,
				original: event,
				index: storage.index,
				keypath: storage.keypath,
				context: storage.root.get( storage.keypath )
			} );
		};
	
		/* virtualdom/items/Element/EventHandler/prototype/listen.js */
		var virtualdom_items_Element_EventHandler$listen = function( config, genericHandler, log ) {
	
			var __export;
			var customHandlers = {},
				touchEvents = {
					touchstart: true,
					touchmove: true,
					touchend: true,
					touchcancel: true,
					//not w3c, but supported in some browsers
					touchleave: true
				};
			__export = function EventHandler$listen() {
				var definition, name = this.name;
				if ( this.invalid ) {
					return;
				}
				if ( definition = config.registries.events.find( this.root, name ) ) {
					this.custom = definition( this.node, getCustomHandler( name ) );
				} else {
					// Looks like we're dealing with a standard DOM event... but let's check
					if ( !( 'on' + name in this.node ) && !( window && 'on' + name in window ) ) {
						// okay to use touch events if this browser doesn't support them
						if ( !touchEvents[ name ] ) {
							log.error( {
								debug: this.root.debug,
								message: 'missingPlugin',
								args: {
									plugin: 'event',
									name: name
								}
							} );
						}
						return;
					}
					this.node.addEventListener( name, genericHandler, false );
				}
				this.hasListener = true;
			};
	
			function getCustomHandler( name ) {
				if ( !customHandlers[ name ] ) {
					customHandlers[ name ] = function( event ) {
						var storage = event.node._ractive;
						event.index = storage.index;
						event.keypath = storage.keypath;
						event.context = storage.root.get( storage.keypath );
						storage.events[ name ].fire( event );
					};
				}
				return customHandlers[ name ];
			}
			return __export;
		}( config, genericHandler, log );
	
		/* virtualdom/items/Element/EventHandler/prototype/rebind.js */
		var virtualdom_items_Element_EventHandler$rebind = function EventHandler$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
			var fragment;
			if ( this.method ) {
				fragment = this.element.parentFragment;
				this.refResolvers.forEach( rebind );
				return;
			}
			if ( typeof this.action !== 'string' ) {
				rebind( this.action );
			}
			if ( this.dynamicParams ) {
				rebind( this.dynamicParams );
			}
	
			function rebind( thing ) {
				thing && thing.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			}
		};
	
		/* virtualdom/items/Element/EventHandler/prototype/render.js */
		var virtualdom_items_Element_EventHandler$render = function EventHandler$render() {
			this.node = this.element.node;
			// store this on the node itself, so it can be retrieved by a
			// universal handler
			this.node._ractive.events[ this.name ] = this;
			if ( this.method || this.getAction() ) {
				this.listen();
			}
		};
	
		/* virtualdom/items/Element/EventHandler/prototype/resolve.js */
		var virtualdom_items_Element_EventHandler$resolve = function EventHandler$resolve( index, keypath ) {
			this.keypaths[ index ] = keypath;
		};
	
		/* virtualdom/items/Element/EventHandler/prototype/unbind.js */
		var virtualdom_items_Element_EventHandler$unbind = function() {
	
			var __export;
			__export = function EventHandler$unbind() {
				if ( this.method ) {
					this.refResolvers.forEach( unbind );
					return;
				}
				// Tear down dynamic name
				if ( typeof this.action !== 'string' ) {
					this.action.unbind();
				}
				// Tear down dynamic parameters
				if ( this.dynamicParams ) {
					this.dynamicParams.unbind();
				}
			};
	
			function unbind( x ) {
				x.unbind();
			}
			return __export;
		}();
	
		/* virtualdom/items/Element/EventHandler/prototype/unrender.js */
		var virtualdom_items_Element_EventHandler$unrender = function( genericHandler ) {
	
			return function EventHandler$unrender() {
				if ( this.custom ) {
					this.custom.teardown();
				} else {
					this.node.removeEventListener( this.name, genericHandler, false );
				}
				this.hasListener = false;
			};
		}( genericHandler );
	
		/* virtualdom/items/Element/EventHandler/_EventHandler.js */
		var EventHandler = function( bubble, fire, getAction, init, listen, rebind, render, resolve, unbind, unrender ) {
	
			var EventHandler = function( element, name, template ) {
				this.init( element, name, template );
			};
			EventHandler.prototype = {
				bubble: bubble,
				fire: fire,
				getAction: getAction,
				init: init,
				listen: listen,
				rebind: rebind,
				render: render,
				resolve: resolve,
				unbind: unbind,
				unrender: unrender
			};
			return EventHandler;
		}( virtualdom_items_Element_EventHandler$bubble, virtualdom_items_Element_EventHandler$fire, virtualdom_items_Element_EventHandler$getAction, virtualdom_items_Element_EventHandler$init, virtualdom_items_Element_EventHandler$listen, virtualdom_items_Element_EventHandler$rebind, virtualdom_items_Element_EventHandler$render, virtualdom_items_Element_EventHandler$resolve, virtualdom_items_Element_EventHandler$unbind, virtualdom_items_Element_EventHandler$unrender );
	
		/* virtualdom/items/Element/prototype/init/createEventHandlers.js */
		var virtualdom_items_Element$init_createEventHandlers = function( EventHandler ) {
	
			return function( element, template ) {
				var i, name, names, handler, result = [];
				for ( name in template ) {
					if ( template.hasOwnProperty( name ) ) {
						names = name.split( '-' );
						i = names.length;
						while ( i-- ) {
							handler = new EventHandler( element, names[ i ], template[ name ] );
							result.push( handler );
						}
					}
				}
				return result;
			};
		}( EventHandler );
	
		/* virtualdom/items/Element/Decorator/_Decorator.js */
		var Decorator = function( log, circular, config ) {
	
			var Fragment, getValueOptions, Decorator;
			circular.push( function() {
				Fragment = circular.Fragment;
			} );
			getValueOptions = {
				args: true
			};
			Decorator = function( element, template ) {
				var decorator = this,
					ractive, name, fragment;
				decorator.element = element;
				decorator.root = ractive = element.root;
				name = template.n || template;
				if ( typeof name !== 'string' ) {
					fragment = new Fragment( {
						template: name,
						root: ractive,
						owner: element
					} );
					name = fragment.toString();
					fragment.unbind();
				}
				if ( template.a ) {
					decorator.params = template.a;
				} else if ( template.d ) {
					decorator.fragment = new Fragment( {
						template: template.d,
						root: ractive,
						owner: element
					} );
					decorator.params = decorator.fragment.getValue( getValueOptions );
					decorator.fragment.bubble = function() {
						this.dirtyArgs = this.dirtyValue = true;
						decorator.params = this.getValue( getValueOptions );
						if ( decorator.ready ) {
							decorator.update();
						}
					};
				}
				decorator.fn = config.registries.decorators.find( ractive, name );
				if ( !decorator.fn ) {
					log.error( {
						debug: ractive.debug,
						message: 'missingPlugin',
						args: {
							plugin: 'decorator',
							name: name
						}
					} );
				}
			};
			Decorator.prototype = {
				init: function() {
					var decorator = this,
						node, result, args;
					node = decorator.element.node;
					if ( decorator.params ) {
						args = [ node ].concat( decorator.params );
						result = decorator.fn.apply( decorator.root, args );
					} else {
						result = decorator.fn.call( decorator.root, node );
					}
					if ( !result || !result.teardown ) {
						throw new Error( 'Decorator definition must return an object with a teardown method' );
					}
					// TODO does this make sense?
					decorator.actual = result;
					decorator.ready = true;
				},
				update: function() {
					if ( this.actual.update ) {
						this.actual.update.apply( this.root, this.params );
					} else {
						this.actual.teardown( true );
						this.init();
					}
				},
				rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
					if ( this.fragment ) {
						this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
					}
				},
				teardown: function( updating ) {
					this.actual.teardown();
					if ( !updating && this.fragment ) {
						this.fragment.unbind();
					}
				}
			};
			return Decorator;
		}( log, circular, config );
	
		/* virtualdom/items/Element/special/select/sync.js */
		var sync = function( toArray ) {
	
			var __export;
			__export = function syncSelect( selectElement ) {
				var selectNode, selectValue, isMultiple, options, optionWasSelected;
				selectNode = selectElement.node;
				if ( !selectNode ) {
					return;
				}
				options = toArray( selectNode.options );
				selectValue = selectElement.getAttribute( 'value' );
				isMultiple = selectElement.getAttribute( 'multiple' );
				// If the <select> has a specified value, that should override
				// these options
				if ( selectValue !== undefined ) {
					options.forEach( function( o ) {
						var optionValue, shouldSelect;
						optionValue = o._ractive ? o._ractive.value : o.value;
						shouldSelect = isMultiple ? valueContains( selectValue, optionValue ) : selectValue == optionValue;
						if ( shouldSelect ) {
							optionWasSelected = true;
						}
						o.selected = shouldSelect;
					} );
					if ( !optionWasSelected ) {
						if ( options[ 0 ] ) {
							options[ 0 ].selected = true;
						}
						if ( selectElement.binding ) {
							selectElement.binding.forceUpdate();
						}
					}
				} else if ( selectElement.binding ) {
					selectElement.binding.forceUpdate();
				}
			};
	
			function valueContains( selectValue, optionValue ) {
				var i = selectValue.length;
				while ( i-- ) {
					if ( selectValue[ i ] == optionValue ) {
						return true;
					}
				}
			}
			return __export;
		}( toArray );
	
		/* virtualdom/items/Element/special/select/bubble.js */
		var bubble = function( runloop, syncSelect ) {
	
			return function bubbleSelect() {
				var this$0 = this;
				if ( !this.dirty ) {
					this.dirty = true;
					runloop.scheduleTask( function() {
						syncSelect( this$0 );
						this$0.dirty = false;
					} );
				}
				this.parentFragment.bubble();
			};
		}( runloop, sync );
	
		/* virtualdom/items/Element/special/option/findParentSelect.js */
		var findParentSelect = function findParentSelect( element ) {
			do {
				if ( element.name === 'select' ) {
					return element;
				}
			} while ( element = element.parent );
		};
	
		/* virtualdom/items/Element/special/option/init.js */
		var init = function( findParentSelect ) {
	
			return function initOption( option, template ) {
				option.select = findParentSelect( option.parent );
				// we might be inside a <datalist> element
				if ( !option.select ) {
					return;
				}
				option.select.options.push( option );
				// If the value attribute is missing, use the element's content
				if ( !template.a ) {
					template.a = {};
				}
				// ...as long as it isn't disabled
				if ( template.a.value === undefined && !template.a.hasOwnProperty( 'disabled' ) ) {
					template.a.value = template.f;
				}
				// If there is a `selected` attribute, but the <select>
				// already has a value, delete it
				if ( 'selected' in template.a && option.select.getAttribute( 'value' ) !== undefined ) {
					delete template.a.selected;
				}
			};
		}( findParentSelect );
	
		/* virtualdom/items/Element/prototype/init.js */
		var virtualdom_items_Element$init = function( types, enforceCase, createAttributes, createConditionalAttributes, createTwowayBinding, createEventHandlers, Decorator, bubbleSelect, initOption, circular ) {
	
			var Fragment;
			circular.push( function() {
				Fragment = circular.Fragment;
			} );
			return function Element$init( options ) {
				var parentFragment, template, ractive, binding, bindings;
				this.type = types.ELEMENT;
				// stuff we'll need later
				parentFragment = this.parentFragment = options.parentFragment;
				template = this.template = options.template;
				this.parent = options.pElement || parentFragment.pElement;
				this.root = ractive = parentFragment.root;
				this.index = options.index;
				this.name = enforceCase( template.e );
				// Special case - <option> elements
				if ( this.name === 'option' ) {
					initOption( this, template );
				}
				// Special case - <select> elements
				if ( this.name === 'select' ) {
					this.options = [];
					this.bubble = bubbleSelect;
				}
				// create attributes
				this.attributes = createAttributes( this, template.a );
				this.conditionalAttributes = createConditionalAttributes( this, template.m );
				// append children, if there are any
				if ( template.f ) {
					this.fragment = new Fragment( {
						template: template.f,
						root: ractive,
						owner: this,
						pElement: this
					} );
				}
				// create twoway binding
				if ( ractive.twoway && ( binding = createTwowayBinding( this, template.a ) ) ) {
					this.binding = binding;
					// register this with the root, so that we can do ractive.updateModel()
					bindings = this.root._twowayBindings[ binding.keypath ] || ( this.root._twowayBindings[ binding.keypath ] = [] );
					bindings.push( binding );
				}
				// create event proxies
				if ( template.v ) {
					this.eventHandlers = createEventHandlers( this, template.v );
				}
				// create decorator
				if ( template.o ) {
					this.decorator = new Decorator( this, template.o );
				}
				// create transitions
				this.intro = template.t0 || template.t1;
				this.outro = template.t0 || template.t2;
			};
		}( types, enforceCase, virtualdom_items_Element$init_createAttributes, virtualdom_items_Element$init_createConditionalAttributes, virtualdom_items_Element$init_createTwowayBinding, virtualdom_items_Element$init_createEventHandlers, Decorator, bubble, init, circular );
	
		/* virtualdom/items/shared/utils/startsWith.js */
		var startsWith = function( startsWithKeypath ) {
	
			return function startsWith( target, keypath ) {
				return target === keypath || startsWithKeypath( target, keypath );
			};
		}( startsWithKeypath );
	
		/* virtualdom/items/shared/utils/assignNewKeypath.js */
		var assignNewKeypath = function( startsWith, getNewKeypath ) {
	
			return function assignNewKeypath( target, property, oldKeypath, newKeypath ) {
				var existingKeypath = target[ property ];
				if ( !existingKeypath || startsWith( existingKeypath, newKeypath ) || !startsWith( existingKeypath, oldKeypath ) ) {
					return;
				}
				target[ property ] = getNewKeypath( existingKeypath, oldKeypath, newKeypath );
			};
		}( startsWith, getNewKeypath );
	
		/* virtualdom/items/Element/prototype/rebind.js */
		var virtualdom_items_Element$rebind = function( assignNewKeypath ) {
	
			return function Element$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
				var i, storage, liveQueries, ractive;
				if ( this.attributes ) {
					this.attributes.forEach( rebind );
				}
				if ( this.conditionalAttributes ) {
					this.conditionalAttributes.forEach( rebind );
				}
				if ( this.eventHandlers ) {
					this.eventHandlers.forEach( rebind );
				}
				if ( this.decorator ) {
					rebind( this.decorator );
				}
				// rebind children
				if ( this.fragment ) {
					rebind( this.fragment );
				}
				// Update live queries, if necessary
				if ( liveQueries = this.liveQueries ) {
					ractive = this.root;
					i = liveQueries.length;
					while ( i-- ) {
						liveQueries[ i ]._makeDirty();
					}
				}
				if ( this.node && ( storage = this.node._ractive ) ) {
					// adjust keypath if needed
					assignNewKeypath( storage, 'keypath', oldKeypath, newKeypath );
					if ( indexRef != undefined ) {
						storage.index[ indexRef ] = newIndex;
					}
				}
	
				function rebind( thing ) {
					thing.rebind( indexRef, newIndex, oldKeypath, newKeypath );
				}
			};
		}( assignNewKeypath );
	
		/* virtualdom/items/Element/special/img/render.js */
		var render = function renderImage( img ) {
			var loadHandler;
			// if this is an <img>, and we're in a crap browser, we may need to prevent it
			// from overriding width and height when it loads the src
			if ( img.attributes.width || img.attributes.height ) {
				img.node.addEventListener( 'load', loadHandler = function() {
					var width = img.getAttribute( 'width' ),
						height = img.getAttribute( 'height' );
					if ( width !== undefined ) {
						img.node.setAttribute( 'width', width );
					}
					if ( height !== undefined ) {
						img.node.setAttribute( 'height', height );
					}
					img.node.removeEventListener( 'load', loadHandler, false );
				}, false );
			}
		};
	
		/* virtualdom/items/Element/Transition/prototype/init.js */
		var virtualdom_items_Element_Transition$init = function( log, config, circular ) {
	
			var Fragment, getValueOptions = {};
			// TODO what are the options?
			circular.push( function() {
				Fragment = circular.Fragment;
			} );
			return function Transition$init( element, template, isIntro ) {
				var t = this,
					ractive, name, fragment;
				t.element = element;
				t.root = ractive = element.root;
				t.isIntro = isIntro;
				name = template.n || template;
				if ( typeof name !== 'string' ) {
					fragment = new Fragment( {
						template: name,
						root: ractive,
						owner: element
					} );
					name = fragment.toString();
					fragment.unbind();
				}
				t.name = name;
				if ( template.a ) {
					t.params = template.a;
				} else if ( template.d ) {
					// TODO is there a way to interpret dynamic arguments without all the
					// 'dependency thrashing'?
					fragment = new Fragment( {
						template: template.d,
						root: ractive,
						owner: element
					} );
					t.params = fragment.getValue( getValueOptions );
					fragment.unbind();
				}
				t._fn = config.registries.transitions.find( ractive, name );
				if ( !t._fn ) {
					log.error( {
						debug: ractive.debug,
						message: 'missingPlugin',
						args: {
							plugin: 'transition',
							name: name
						}
					} );
					return;
				}
			};
		}( log, config, circular );
	
		/* utils/camelCase.js */
		var camelCase = function( hyphenatedStr ) {
			return hyphenatedStr.replace( /-([a-zA-Z])/g, function( match, $1 ) {
				return $1.toUpperCase();
			} );
		};
	
		/* virtualdom/items/Element/Transition/helpers/prefix.js */
		var prefix = function( isClient, vendors, createElement, camelCase ) {
	
			var prefix, prefixCache, testStyle;
			if ( !isClient ) {
				prefix = null;
			} else {
				prefixCache = {};
				testStyle = createElement( 'div' ).style;
				prefix = function( prop ) {
					var i, vendor, capped;
					prop = camelCase( prop );
					if ( !prefixCache[ prop ] ) {
						if ( testStyle[ prop ] !== undefined ) {
							prefixCache[ prop ] = prop;
						} else {
							// test vendors...
							capped = prop.charAt( 0 ).toUpperCase() + prop.substring( 1 );
							i = vendors.length;
							while ( i-- ) {
								vendor = vendors[ i ];
								if ( testStyle[ vendor + capped ] !== undefined ) {
									prefixCache[ prop ] = vendor + capped;
									break;
								}
							}
						}
					}
					return prefixCache[ prop ];
				};
			}
			return prefix;
		}( isClient, vendors, createElement, camelCase );
	
		/* virtualdom/items/Element/Transition/prototype/getStyle.js */
		var virtualdom_items_Element_Transition$getStyle = function( legacy, isClient, isArray, prefix ) {
	
			var getStyle, getComputedStyle;
			if ( !isClient ) {
				getStyle = null;
			} else {
				getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;
				getStyle = function( props ) {
					var computedStyle, styles, i, prop, value;
					computedStyle = getComputedStyle( this.node );
					if ( typeof props === 'string' ) {
						value = computedStyle[ prefix( props ) ];
						if ( value === '0px' ) {
							value = 0;
						}
						return value;
					}
					if ( !isArray( props ) ) {
						throw new Error( 'Transition$getStyle must be passed a string, or an array of strings representing CSS properties' );
					}
					styles = {};
					i = props.length;
					while ( i-- ) {
						prop = props[ i ];
						value = computedStyle[ prefix( prop ) ];
						if ( value === '0px' ) {
							value = 0;
						}
						styles[ prop ] = value;
					}
					return styles;
				};
			}
			return getStyle;
		}( legacy, isClient, isArray, prefix );
	
		/* virtualdom/items/Element/Transition/prototype/setStyle.js */
		var virtualdom_items_Element_Transition$setStyle = function( prefix ) {
	
			return function( style, value ) {
				var prop;
				if ( typeof style === 'string' ) {
					this.node.style[ prefix( style ) ] = value;
				} else {
					for ( prop in style ) {
						if ( style.hasOwnProperty( prop ) ) {
							this.node.style[ prefix( prop ) ] = style[ prop ];
						}
					}
				}
				return this;
			};
		}( prefix );
	
		/* shared/Ticker.js */
		var Ticker = function( warn, getTime, animations ) {
	
			var __export;
			var Ticker = function( options ) {
				var easing;
				this.duration = options.duration;
				this.step = options.step;
				this.complete = options.complete;
				// easing
				if ( typeof options.easing === 'string' ) {
					easing = options.root.easing[ options.easing ];
					if ( !easing ) {
						warn( 'Missing easing function ("' + options.easing + '"). You may need to download a plugin from [TODO]' );
						easing = linear;
					}
				} else if ( typeof options.easing === 'function' ) {
					easing = options.easing;
				} else {
					easing = linear;
				}
				this.easing = easing;
				this.start = getTime();
				this.end = this.start + this.duration;
				this.running = true;
				animations.add( this );
			};
			Ticker.prototype = {
				tick: function( now ) {
					var elapsed, eased;
					if ( !this.running ) {
						return false;
					}
					if ( now > this.end ) {
						if ( this.step ) {
							this.step( 1 );
						}
						if ( this.complete ) {
							this.complete( 1 );
						}
						return false;
					}
					elapsed = now - this.start;
					eased = this.easing( elapsed / this.duration );
					if ( this.step ) {
						this.step( eased );
					}
					return true;
				},
				stop: function() {
					if ( this.abort ) {
						this.abort();
					}
					this.running = false;
				}
			};
			__export = Ticker;
	
			function linear( t ) {
				return t;
			}
			return __export;
		}( warn, getTime, animations );
	
		/* virtualdom/items/Element/Transition/helpers/unprefix.js */
		var unprefix = function( vendors ) {
	
			var unprefixPattern = new RegExp( '^-(?:' + vendors.join( '|' ) + ')-' );
			return function( prop ) {
				return prop.replace( unprefixPattern, '' );
			};
		}( vendors );
	
		/* virtualdom/items/Element/Transition/helpers/hyphenate.js */
		var hyphenate = function( vendors ) {
	
			var vendorPattern = new RegExp( '^(?:' + vendors.join( '|' ) + ')([A-Z])' );
			return function( str ) {
				var hyphenated;
				if ( !str ) {
					return '';
				}
				if ( vendorPattern.test( str ) ) {
					str = '-' + str;
				}
				hyphenated = str.replace( /[A-Z]/g, function( match ) {
					return '-' + match.toLowerCase();
				} );
				return hyphenated;
			};
		}( vendors );
	
		/* virtualdom/items/Element/Transition/prototype/animateStyle/createTransitions.js */
		var virtualdom_items_Element_Transition$animateStyle_createTransitions = function( isClient, warn, createElement, camelCase, interpolate, Ticker, prefix, unprefix, hyphenate ) {
	
			var createTransitions, testStyle, TRANSITION, TRANSITIONEND, CSS_TRANSITIONS_ENABLED, TRANSITION_DURATION, TRANSITION_PROPERTY, TRANSITION_TIMING_FUNCTION, canUseCssTransitions = {},
				cannotUseCssTransitions = {};
			if ( !isClient ) {
				createTransitions = null;
			} else {
				testStyle = createElement( 'div' ).style;
				// determine some facts about our environment
				( function() {
					if ( testStyle.transition !== undefined ) {
						TRANSITION = 'transition';
						TRANSITIONEND = 'transitionend';
						CSS_TRANSITIONS_ENABLED = true;
					} else if ( testStyle.webkitTransition !== undefined ) {
						TRANSITION = 'webkitTransition';
						TRANSITIONEND = 'webkitTransitionEnd';
						CSS_TRANSITIONS_ENABLED = true;
					} else {
						CSS_TRANSITIONS_ENABLED = false;
					}
				}() );
				if ( TRANSITION ) {
					TRANSITION_DURATION = TRANSITION + 'Duration';
					TRANSITION_PROPERTY = TRANSITION + 'Property';
					TRANSITION_TIMING_FUNCTION = TRANSITION + 'TimingFunction';
				}
				createTransitions = function( t, to, options, changedProperties, resolve ) {
					// Wait a beat (otherwise the target styles will be applied immediately)
					// TODO use a fastdom-style mechanism?
					setTimeout( function() {
						var hashPrefix, jsTransitionsComplete, cssTransitionsComplete, checkComplete, transitionEndHandler;
						checkComplete = function() {
							if ( jsTransitionsComplete && cssTransitionsComplete ) {
								// will changes to events and fire have an unexpected consequence here?
								t.root.fire( t.name + ':end', t.node, t.isIntro );
								resolve();
							}
						};
						// this is used to keep track of which elements can use CSS to animate
						// which properties
						hashPrefix = ( t.node.namespaceURI || '' ) + t.node.tagName;
						t.node.style[ TRANSITION_PROPERTY ] = changedProperties.map( prefix ).map( hyphenate ).join( ',' );
						t.node.style[ TRANSITION_TIMING_FUNCTION ] = hyphenate( options.easing || 'linear' );
						t.node.style[ TRANSITION_DURATION ] = options.duration / 1000 + 's';
						transitionEndHandler = function( event ) {
							var index;
							index = changedProperties.indexOf( camelCase( unprefix( event.propertyName ) ) );
							if ( index !== -1 ) {
								changedProperties.splice( index, 1 );
							}
							if ( changedProperties.length ) {
								// still transitioning...
								return;
							}
							t.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );
							cssTransitionsComplete = true;
							checkComplete();
						};
						t.node.addEventListener( TRANSITIONEND, transitionEndHandler, false );
						setTimeout( function() {
							var i = changedProperties.length,
								hash, originalValue, index, propertiesToTransitionInJs = [],
								prop, suffix;
							while ( i-- ) {
								prop = changedProperties[ i ];
								hash = hashPrefix + prop;
								if ( CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[ hash ] ) {
									t.node.style[ prefix( prop ) ] = to[ prop ];
									// If we're not sure if CSS transitions are supported for
									// this tag/property combo, find out now
									if ( !canUseCssTransitions[ hash ] ) {
										originalValue = t.getStyle( prop );
										// if this property is transitionable in this browser,
										// the current style will be different from the target style
										canUseCssTransitions[ hash ] = t.getStyle( prop ) != to[ prop ];
										cannotUseCssTransitions[ hash ] = !canUseCssTransitions[ hash ];
										// Reset, if we're going to use timers after all
										if ( cannotUseCssTransitions[ hash ] ) {
											t.node.style[ prefix( prop ) ] = originalValue;
										}
									}
								}
								if ( !CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[ hash ] ) {
									// we need to fall back to timer-based stuff
									if ( originalValue === undefined ) {
										originalValue = t.getStyle( prop );
									}
									// need to remove this from changedProperties, otherwise transitionEndHandler
									// will get confused
									index = changedProperties.indexOf( prop );
									if ( index === -1 ) {
										warn( 'Something very strange happened with transitions. If you see this message, please let @RactiveJS know. Thanks!' );
									} else {
										changedProperties.splice( index, 1 );
									}
									// TODO Determine whether this property is animatable at all
									suffix = /[^\d]*$/.exec( to[ prop ] )[ 0 ];
									// ...then kick off a timer-based transition
									propertiesToTransitionInJs.push( {
										name: prefix( prop ),
										interpolator: interpolate( parseFloat( originalValue ), parseFloat( to[ prop ] ) ),
										suffix: suffix
									} );
								}
							}
							// javascript transitions
							if ( propertiesToTransitionInJs.length ) {
								new Ticker( {
									root: t.root,
									duration: options.duration,
									easing: camelCase( options.easing || '' ),
									step: function( pos ) {
										var prop, i;
										i = propertiesToTransitionInJs.length;
										while ( i-- ) {
											prop = propertiesToTransitionInJs[ i ];
											t.node.style[ prop.name ] = prop.interpolator( pos ) + prop.suffix;
										}
									},
									complete: function() {
										jsTransitionsComplete = true;
										checkComplete();
									}
								} );
							} else {
								jsTransitionsComplete = true;
							}
							if ( !changedProperties.length ) {
								// We need to cancel the transitionEndHandler, and deal with
								// the fact that it will never fire
								t.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );
								cssTransitionsComplete = true;
								checkComplete();
							}
						}, 0 );
					}, options.delay || 0 );
				};
			}
			return createTransitions;
		}( isClient, warn, createElement, camelCase, interpolate, Ticker, prefix, unprefix, hyphenate );
	
		/* virtualdom/items/Element/Transition/prototype/animateStyle/visibility.js */
		var virtualdom_items_Element_Transition$animateStyle_visibility = function( vendors ) {
	
			var hidden, vendor, prefix, i, visibility;
			if ( typeof document !== 'undefined' ) {
				hidden = 'hidden';
				visibility = {};
				if ( hidden in document ) {
					prefix = '';
				} else {
					i = vendors.length;
					while ( i-- ) {
						vendor = vendors[ i ];
						hidden = vendor + 'Hidden';
						if ( hidden in document ) {
							prefix = vendor;
						}
					}
				}
				if ( prefix !== undefined ) {
					document.addEventListener( prefix + 'visibilitychange', onChange );
					// initialise
					onChange();
				} else {
					// gah, we're in an old browser
					if ( 'onfocusout' in document ) {
						document.addEventListener( 'focusout', onHide );
						document.addEventListener( 'focusin', onShow );
					} else {
						window.addEventListener( 'pagehide', onHide );
						window.addEventListener( 'blur', onHide );
						window.addEventListener( 'pageshow', onShow );
						window.addEventListener( 'focus', onShow );
					}
					visibility.hidden = false;
				}
			}
	
			function onChange() {
				visibility.hidden = document[ hidden ];
			}
	
			function onHide() {
				visibility.hidden = true;
			}
	
			function onShow() {
				visibility.hidden = false;
			}
			return visibility;
		}( vendors );
	
		/* virtualdom/items/Element/Transition/prototype/animateStyle/_animateStyle.js */
		var virtualdom_items_Element_Transition$animateStyle__animateStyle = function( legacy, isClient, warn, Promise, prefix, createTransitions, visibility ) {
	
			var animateStyle, getComputedStyle, resolved;
			if ( !isClient ) {
				animateStyle = null;
			} else {
				getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;
				animateStyle = function( style, value, options, complete ) {
					var t = this,
						to;
					// Special case - page isn't visible. Don't animate anything, because
					// that way you'll never get CSS transitionend events
					if ( visibility.hidden ) {
						this.setStyle( style, value );
						return resolved || ( resolved = Promise.resolve() );
					}
					if ( typeof style === 'string' ) {
						to = {};
						to[ style ] = value;
					} else {
						to = style;
						// shuffle arguments
						complete = options;
						options = value;
					}
					// As of 0.3.9, transition authors should supply an `option` object with
					// `duration` and `easing` properties (and optional `delay`), plus a
					// callback function that gets called after the animation completes
					// TODO remove this check in a future version
					if ( !options ) {
						warn( 'The "' + t.name + '" transition does not supply an options object to `t.animateStyle()`. This will break in a future version of Ractive. For more info see https://github.com/RactiveJS/Ractive/issues/340' );
						options = t;
						complete = t.complete;
					}
					var promise = new Promise( function( resolve ) {
						var propertyNames, changedProperties, computedStyle, current, from, i, prop;
						// Edge case - if duration is zero, set style synchronously and complete
						if ( !options.duration ) {
							t.setStyle( to );
							resolve();
							return;
						}
						// Get a list of the properties we're animating
						propertyNames = Object.keys( to );
						changedProperties = [];
						// Store the current styles
						computedStyle = getComputedStyle( t.node );
						from = {};
						i = propertyNames.length;
						while ( i-- ) {
							prop = propertyNames[ i ];
							current = computedStyle[ prefix( prop ) ];
							if ( current === '0px' ) {
								current = 0;
							}
							// we need to know if we're actually changing anything
							if ( current != to[ prop ] ) {
								// use != instead of !==, so we can compare strings with numbers
								changedProperties.push( prop );
								// make the computed style explicit, so we can animate where
								// e.g. height='auto'
								t.node.style[ prefix( prop ) ] = current;
							}
						}
						// If we're not actually changing anything, the transitionend event
						// will never fire! So we complete early
						if ( !changedProperties.length ) {
							resolve();
							return;
						}
						createTransitions( t, to, options, changedProperties, resolve );
					} );
					// If a callback was supplied, do the honours
					// TODO remove this check in future
					if ( complete ) {
						warn( 't.animateStyle returns a Promise as of 0.4.0. Transition authors should do t.animateStyle(...).then(callback)' );
						promise.then( complete );
					}
					return promise;
				};
			}
			return animateStyle;
		}( legacy, isClient, warn, Promise, prefix, virtualdom_items_Element_Transition$animateStyle_createTransitions, virtualdom_items_Element_Transition$animateStyle_visibility );
	
		/* utils/fillGaps.js */
		var fillGaps = function( target ) {
			var SLICE$0 = Array.prototype.slice;
			var sources = SLICE$0.call( arguments, 1 );
			sources.forEach( function( s ) {
				for ( var key in s ) {
					if ( s.hasOwnProperty( key ) && !( key in target ) ) {
						target[ key ] = s[ key ];
					}
				}
			} );
			return target;
		};
	
		/* virtualdom/items/Element/Transition/prototype/processParams.js */
		var virtualdom_items_Element_Transition$processParams = function( fillGaps ) {
	
			return function( params, defaults ) {
				if ( typeof params === 'number' ) {
					params = {
						duration: params
					};
				} else if ( typeof params === 'string' ) {
					if ( params === 'slow' ) {
						params = {
							duration: 600
						};
					} else if ( params === 'fast' ) {
						params = {
							duration: 200
						};
					} else {
						params = {
							duration: 400
						};
					}
				} else if ( !params ) {
					params = {};
				}
				return fillGaps( {}, params, defaults );
			};
		}( fillGaps );
	
		/* virtualdom/items/Element/Transition/prototype/start.js */
		var virtualdom_items_Element_Transition$start = function() {
	
			var __export;
			__export = function Transition$start() {
				var t = this,
					node, originalStyle, completed;
				node = t.node = t.element.node;
				originalStyle = node.getAttribute( 'style' );
				// create t.complete() - we don't want this on the prototype,
				// because we don't want `this` silliness when passing it as
				// an argument
				t.complete = function( noReset ) {
					if ( completed ) {
						return;
					}
					if ( !noReset && t.isIntro ) {
						resetStyle( node, originalStyle );
					}
					node._ractive.transition = null;
					t._manager.remove( t );
					completed = true;
				};
				// If the transition function doesn't exist, abort
				if ( !t._fn ) {
					t.complete();
					return;
				}
				t._fn.apply( t.root, [ t ].concat( t.params ) );
			};
	
			function resetStyle( node, style ) {
				if ( style ) {
					node.setAttribute( 'style', style );
				} else {
					// Next line is necessary, to remove empty style attribute!
					// See http://stackoverflow.com/a/7167553
					node.getAttribute( 'style' );
					node.removeAttribute( 'style' );
				}
			}
			return __export;
		}();
	
		/* virtualdom/items/Element/Transition/_Transition.js */
		var Transition = function( init, getStyle, setStyle, animateStyle, processParams, start, circular ) {
	
			var Fragment, Transition;
			circular.push( function() {
				Fragment = circular.Fragment;
			} );
			Transition = function( owner, template, isIntro ) {
				this.init( owner, template, isIntro );
			};
			Transition.prototype = {
				init: init,
				start: start,
				getStyle: getStyle,
				setStyle: setStyle,
				animateStyle: animateStyle,
				processParams: processParams
			};
			return Transition;
		}( virtualdom_items_Element_Transition$init, virtualdom_items_Element_Transition$getStyle, virtualdom_items_Element_Transition$setStyle, virtualdom_items_Element_Transition$animateStyle__animateStyle, virtualdom_items_Element_Transition$processParams, virtualdom_items_Element_Transition$start, circular );
	
		/* virtualdom/items/Element/prototype/render.js */
		var virtualdom_items_Element$render = function( namespaces, isArray, warn, create, createElement, defineProperty, noop, runloop, getInnerContext, renderImage, Transition ) {
	
			var __export;
			var updateCss, updateScript;
			updateCss = function() {
				var node = this.node,
					content = this.fragment.toString( false );
				// IE8 has no styleSheet unless there's a type text/css
				if ( window && window.appearsToBeIELessEqual8 ) {
					node.type = 'text/css';
				}
				if ( node.styleSheet ) {
					node.styleSheet.cssText = content;
				} else {
					while ( node.hasChildNodes() ) {
						node.removeChild( node.firstChild );
					}
					node.appendChild( document.createTextNode( content ) );
				}
			};
			updateScript = function() {
				if ( !this.node.type || this.node.type === 'text/javascript' ) {
					warn( 'Script tag was updated. This does not cause the code to be re-evaluated!' );
				}
				this.node.text = this.fragment.toString( false );
			};
			__export = function Element$render() {
				var this$0 = this;
				var root = this.root,
					namespace, node;
				namespace = getNamespace( this );
				node = this.node = createElement( this.name, namespace );
				// Is this a top-level node of a component? If so, we may need to add
				// a data-rvcguid attribute, for CSS encapsulation
				// NOTE: css no longer copied to instance, so we check constructor.css -
				// we can enhance to handle instance, but this is more "correct" with current
				// functionality
				if ( root.constructor.css && this.parentFragment.getNode() === root.el ) {
					this.node.setAttribute( 'data-rvcguid', root.constructor._guid );
				}
				// Add _ractive property to the node - we use this object to store stuff
				// related to proxy events, two-way bindings etc
				defineProperty( this.node, '_ractive', {
					value: {
						proxy: this,
						keypath: getInnerContext( this.parentFragment ),
						index: this.parentFragment.indexRefs,
						events: create( null ),
						root: root
					}
				} );
				// Render attributes
				this.attributes.forEach( function( a ) {
					return a.render( node );
				} );
				this.conditionalAttributes.forEach( function( a ) {
					return a.render( node );
				} );
				// Render children
				if ( this.fragment ) {
					// Special case - <script> element
					if ( this.name === 'script' ) {
						this.bubble = updateScript;
						this.node.text = this.fragment.toString( false );
						// bypass warning initially
						this.fragment.unrender = noop;
					} else if ( this.name === 'style' ) {
						this.bubble = updateCss;
						this.bubble();
						this.fragment.unrender = noop;
					} else if ( this.binding && this.getAttribute( 'contenteditable' ) ) {
						this.fragment.unrender = noop;
					} else {
						this.node.appendChild( this.fragment.render() );
					}
				}
				// Add proxy event handlers
				if ( this.eventHandlers ) {
					this.eventHandlers.forEach( function( h ) {
						return h.render();
					} );
				}
				// deal with two-way bindings
				if ( this.binding ) {
					this.binding.render();
					this.node._ractive.binding = this.binding;
				}
				// Special case: if this is an <img>, and we're in a crap browser, we may
				// need to prevent it from overriding width and height when it loads the src
				if ( this.name === 'img' ) {
					renderImage( this );
				}
				// apply decorator(s)
				if ( this.decorator && this.decorator.fn ) {
					runloop.scheduleTask( function() {
						return this$0.decorator.init();
					}, true );
				}
				// trigger intro transition
				if ( root.transitionsEnabled && this.intro ) {
					var transition = new Transition( this, this.intro, true );
					runloop.registerTransition( transition );
					runloop.scheduleTask( function() {
						return transition.start();
					}, true );
					this.transition = transition;
				}
				if ( this.name === 'option' ) {
					processOption( this );
				}
				if ( this.node.autofocus ) {
					// Special case. Some browsers (*cough* Firefix *cough*) have a problem
					// with dynamically-generated elements having autofocus, and they won't
					// allow you to programmatically focus the element until it's in the DOM
					runloop.scheduleTask( function() {
						return this$0.node.focus();
					}, true );
				}
				updateLiveQueries( this );
				return this.node;
			};
	
			function getNamespace( element ) {
				var namespace, xmlns, parent;
				// Use specified namespace...
				if ( xmlns = element.getAttribute( 'xmlns' ) ) {
					namespace = xmlns;
				} else if ( element.name === 'svg' ) {
					namespace = namespaces.svg;
				} else if ( parent = element.parent ) {
					// ...or HTML, if the parent is a <foreignObject>
					if ( parent.name === 'foreignObject' ) {
						namespace = namespaces.html;
					} else {
						namespace = parent.node.namespaceURI;
					}
				} else {
					namespace = element.root.el.namespaceURI;
				}
				return namespace;
			}
	
			function processOption( option ) {
				var optionValue, selectValue, i;
				if ( !option.select ) {
					return;
				}
				selectValue = option.select.getAttribute( 'value' );
				if ( selectValue === undefined ) {
					return;
				}
				optionValue = option.getAttribute( 'value' );
				if ( option.select.node.multiple && isArray( selectValue ) ) {
					i = selectValue.length;
					while ( i-- ) {
						if ( optionValue == selectValue[ i ] ) {
							option.node.selected = true;
							break;
						}
					}
				} else {
					option.node.selected = optionValue == selectValue;
				}
			}
	
			function updateLiveQueries( element ) {
				var instance, liveQueries, i, selector, query;
				// Does this need to be added to any live queries?
				instance = element.root;
				do {
					liveQueries = instance._liveQueries;
					i = liveQueries.length;
					while ( i-- ) {
						selector = liveQueries[ i ];
						query = liveQueries[ '_' + selector ];
						if ( query._test( element ) ) {
							// keep register of applicable selectors, for when we teardown
							( element.liveQueries || ( element.liveQueries = [] ) ).push( query );
						}
					}
				} while ( instance = instance._parent );
			}
			return __export;
		}( namespaces, isArray, warn, create, createElement, defineProperty, noop, runloop, getInnerContext, render, Transition );
	
		/* virtualdom/items/Element/prototype/toString.js */
		var virtualdom_items_Element$toString = function( voidElementNames, isArray, escapeHtml ) {
	
			var __export;
			__export = function() {
				var str, escape;
				str = '<' + ( this.template.y ? '!DOCTYPE' : this.template.e );
				str += this.attributes.map( stringifyAttribute ).join( '' ) + this.conditionalAttributes.map( stringifyAttribute ).join( '' );
				// Special case - selected options
				if ( this.name === 'option' && optionIsSelected( this ) ) {
					str += ' selected';
				}
				// Special case - two-way radio name bindings
				if ( this.name === 'input' && inputIsCheckedRadio( this ) ) {
					str += ' checked';
				}
				str += '>';
				// Special case - textarea
				if ( this.name === 'textarea' && this.getAttribute( 'value' ) !== undefined ) {
					str += escapeHtml( this.getAttribute( 'value' ) );
				} else if ( this.getAttribute( 'contenteditable' ) !== undefined ) {
					str += this.getAttribute( 'value' );
				}
				if ( this.fragment ) {
					escape = this.name !== 'script' && this.name !== 'style';
					str += this.fragment.toString( escape );
				}
				// add a closing tag if this isn't a void element
				if ( !voidElementNames.test( this.template.e ) ) {
					str += '</' + this.template.e + '>';
				}
				return str;
			};
	
			function optionIsSelected( element ) {
				var optionValue, selectValue, i;
				optionValue = element.getAttribute( 'value' );
				if ( optionValue === undefined || !element.select ) {
					return false;
				}
				selectValue = element.select.getAttribute( 'value' );
				if ( selectValue == optionValue ) {
					return true;
				}
				if ( element.select.getAttribute( 'multiple' ) && isArray( selectValue ) ) {
					i = selectValue.length;
					while ( i-- ) {
						if ( selectValue[ i ] == optionValue ) {
							return true;
						}
					}
				}
			}
	
			function inputIsCheckedRadio( element ) {
				var attributes, typeAttribute, valueAttribute, nameAttribute;
				attributes = element.attributes;
				typeAttribute = attributes.type;
				valueAttribute = attributes.value;
				nameAttribute = attributes.name;
				if ( !typeAttribute || typeAttribute.value !== 'radio' || !valueAttribute || !nameAttribute.interpolator ) {
					return;
				}
				if ( valueAttribute.value === nameAttribute.interpolator.value ) {
					return true;
				}
			}
	
			function stringifyAttribute( attribute ) {
				var str = attribute.toString();
				return str ? ' ' + str : '';
			}
			return __export;
		}( voidElementNames, isArray, escapeHtml );
	
		/* virtualdom/items/Element/special/option/unbind.js */
		var virtualdom_items_Element_special_option_unbind = function( removeFromArray ) {
	
			return function unbindOption( option ) {
				if ( option.select ) {
					removeFromArray( option.select.options, option );
				}
			};
		}( removeFromArray );
	
		/* virtualdom/items/Element/prototype/unbind.js */
		var virtualdom_items_Element$unbind = function( unbindOption ) {
	
			var __export;
			__export = function Element$unbind() {
				if ( this.fragment ) {
					this.fragment.unbind();
				}
				if ( this.binding ) {
					this.binding.unbind();
				}
				if ( this.eventHandlers ) {
					this.eventHandlers.forEach( unbind );
				}
				// Special case - <option>
				if ( this.name === 'option' ) {
					unbindOption( this );
				}
				this.attributes.forEach( unbind );
				this.conditionalAttributes.forEach( unbind );
			};
	
			function unbind( x ) {
				x.unbind();
			}
			return __export;
		}( virtualdom_items_Element_special_option_unbind );
	
		/* virtualdom/items/Element/prototype/unrender.js */
		var virtualdom_items_Element$unrender = function( runloop, Transition ) {
	
			var __export;
			__export = function Element$unrender( shouldDestroy ) {
				var binding, bindings;
				if ( this.transition ) {
					this.transition.complete();
				}
				// Detach as soon as we can
				if ( this.name === 'option' ) {
					// <option> elements detach immediately, so that
					// their parent <select> element syncs correctly, and
					// since option elements can't have transitions anyway
					this.detach();
				} else if ( shouldDestroy ) {
					runloop.detachWhenReady( this );
				}
				// Children first. that way, any transitions on child elements will be
				// handled by the current transitionManager
				if ( this.fragment ) {
					this.fragment.unrender( false );
				}
				if ( binding = this.binding ) {
					this.binding.unrender();
					this.node._ractive.binding = null;
					bindings = this.root._twowayBindings[ binding.keypath ];
					bindings.splice( bindings.indexOf( binding ), 1 );
				}
				// Remove event handlers
				if ( this.eventHandlers ) {
					this.eventHandlers.forEach( function( h ) {
						return h.unrender();
					} );
				}
				if ( this.decorator ) {
					this.decorator.teardown();
				}
				// trigger outro transition if necessary
				if ( this.root.transitionsEnabled && this.outro ) {
					var transition = new Transition( this, this.outro, false );
					runloop.registerTransition( transition );
					runloop.scheduleTask( function() {
						return transition.start();
					} );
				}
				// Remove this node from any live queries
				if ( this.liveQueries ) {
					removeFromLiveQueries( this );
				}
			};
	
			function removeFromLiveQueries( element ) {
				var query, selector, i;
				i = element.liveQueries.length;
				while ( i-- ) {
					query = element.liveQueries[ i ];
					selector = query.selector;
					query._remove( element.node );
				}
			}
			return __export;
		}( runloop, Transition );
	
		/* virtualdom/items/Element/_Element.js */
		var Element = function( bubble, detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, getAttribute, init, rebind, render, toString, unbind, unrender ) {
	
			var Element = function( options ) {
				this.init( options );
			};
			Element.prototype = {
				bubble: bubble,
				detach: detach,
				find: find,
				findAll: findAll,
				findAllComponents: findAllComponents,
				findComponent: findComponent,
				findNextNode: findNextNode,
				firstNode: firstNode,
				getAttribute: getAttribute,
				init: init,
				rebind: rebind,
				render: render,
				toString: toString,
				unbind: unbind,
				unrender: unrender
			};
			return Element;
		}( virtualdom_items_Element$bubble, virtualdom_items_Element$detach, virtualdom_items_Element$find, virtualdom_items_Element$findAll, virtualdom_items_Element$findAllComponents, virtualdom_items_Element$findComponent, virtualdom_items_Element$findNextNode, virtualdom_items_Element$firstNode, virtualdom_items_Element$getAttribute, virtualdom_items_Element$init, virtualdom_items_Element$rebind, virtualdom_items_Element$render, virtualdom_items_Element$toString, virtualdom_items_Element$unbind, virtualdom_items_Element$unrender );
	
		/* virtualdom/items/Partial/deIndent.js */
		var deIndent = function() {
	
			var __export;
			var empty = /^\s*$/,
				leadingWhitespace = /^\s*/;
			__export = function( str ) {
				var lines, firstLine, lastLine, minIndent;
				lines = str.split( '\n' );
				// remove first and last line, if they only contain whitespace
				firstLine = lines[ 0 ];
				if ( firstLine !== undefined && empty.test( firstLine ) ) {
					lines.shift();
				}
				lastLine = lines[ lines.length - 1 ];
				if ( lastLine !== undefined && empty.test( lastLine ) ) {
					lines.pop();
				}
				minIndent = lines.reduce( reducer, null );
				if ( minIndent ) {
					str = lines.map( function( line ) {
						return line.replace( minIndent, '' );
					} ).join( '\n' );
				}
				return str;
			};
	
			function reducer( previous, line ) {
				var lineIndent = leadingWhitespace.exec( line )[ 0 ];
				if ( previous === null || lineIndent.length < previous.length ) {
					return lineIndent;
				}
				return previous;
			}
			return __export;
		}();
	
		/* virtualdom/items/Partial/getPartialTemplate.js */
		var getPartialTemplate = function( log, config, parser, deIndent ) {
	
			var __export;
			__export = function getPartialTemplate( ractive, name ) {
				var partial;
				// If the partial in instance or view heirarchy instances, great
				if ( partial = getPartialFromRegistry( ractive, name ) ) {
					return partial;
				}
				// Does it exist on the page as a script tag?
				partial = parser.fromId( name, {
					noThrow: true
				} );
				if ( partial ) {
					// is this necessary?
					partial = deIndent( partial );
					// parse and register to this ractive instance
					var parsed = parser.parse( partial, parser.getParseOptions( ractive ) );
					// register (and return main partial if there are others in the template)
					return ractive.partials[ name ] = parsed.t;
				}
			};
	
			function getPartialFromRegistry( ractive, name ) {
				var partials = config.registries.partials;
				// find first instance in the ractive or view hierarchy that has this partial
				var instance = partials.findInstance( ractive, name );
				if ( !instance ) {
					return;
				}
				var partial = instance.partials[ name ],
					fn;
				// partial is a function?
				if ( typeof partial === 'function' ) {
					fn = partial.bind( instance );
					fn.isOwner = instance.partials.hasOwnProperty( name );
					partial = fn( instance.data, parser );
				}
				if ( !partial ) {
					log.warn( {
						debug: ractive.debug,
						message: 'noRegistryFunctionReturn',
						args: {
							registry: 'partial',
							name: name
						}
					} );
					return;
				}
				// If this was added manually to the registry,
				// but hasn't been parsed, parse it now
				if ( !parser.isParsed( partial ) ) {
					// use the parseOptions of the ractive instance on which it was found
					var parsed = parser.parse( partial, parser.getParseOptions( instance ) );
					// Partials cannot contain nested partials!
					// TODO add a test for this
					if ( parsed.p ) {
						log.warn( {
							debug: ractive.debug,
							message: 'noNestedPartials',
							args: {
								rname: name
							}
						} );
					}
					// if fn, use instance to store result, otherwise needs to go
					// in the correct point in prototype chain on instance or constructor
					var target = fn ? instance : partials.findOwner( instance, name );
					// may be a template with partials, which need to be registered and main template extracted
					target.partials[ name ] = partial = parsed.t;
				}
				// store for reset
				if ( fn ) {
					partial._fn = fn;
				}
				return partial.v ? partial.t : partial;
			}
			return __export;
		}( log, config, parser, deIndent );
	
		/* virtualdom/items/Partial/applyIndent.js */
		var applyIndent = function( string, indent ) {
			var indented;
			if ( !indent ) {
				return string;
			}
			indented = string.split( '\n' ).map( function( line, notFirstLine ) {
				return notFirstLine ? indent + line : line;
			} ).join( '\n' );
			return indented;
		};
	
		/* virtualdom/items/Partial/_Partial.js */
		var Partial = function( log, types, getPartialTemplate, applyIndent, circular, runloop, Mustache, rebind, unbind ) {
	
			var Partial, Fragment;
			circular.push( function() {
				Fragment = circular.Fragment;
			} );
			Partial = function( options ) {
				var parentFragment, template;
				parentFragment = this.parentFragment = options.parentFragment;
				this.root = parentFragment.root;
				this.type = types.PARTIAL;
				this.index = options.index;
				this.name = options.template.r;
				this.fragment = this.fragmentToRender = this.fragmentToUnrender = null;
				Mustache.init( this, options );
				// If this didn't resolve, it most likely means we have a named partial
				// (i.e. `{{>foo}}` means 'use the foo partial', not 'use the partial
				// whose name is the value of `foo`')
				if ( !this.keypath && ( template = getPartialTemplate( this.root, this.name ) ) ) {
					unbind.call( this );
					// prevent any further changes
					this.isNamed = true;
					this.setTemplate( template );
				}
			};
			Partial.prototype = {
				bubble: function() {
					this.parentFragment.bubble();
				},
				detach: function() {
					return this.fragment.detach();
				},
				find: function( selector ) {
					return this.fragment.find( selector );
				},
				findAll: function( selector, query ) {
					return this.fragment.findAll( selector, query );
				},
				findComponent: function( selector ) {
					return this.fragment.findComponent( selector );
				},
				findAllComponents: function( selector, query ) {
					return this.fragment.findAllComponents( selector, query );
				},
				firstNode: function() {
					return this.fragment.firstNode();
				},
				findNextNode: function() {
					return this.parentFragment.findNextNode( this );
				},
				getValue: function() {
					return this.fragment.getValue();
				},
				rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
					rebind.call( this, indexRef, newIndex, oldKeypath, newKeypath );
					this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
				},
				render: function() {
					this.docFrag = document.createDocumentFragment();
					this.update();
					this.rendered = true;
					return this.docFrag;
				},
				resolve: Mustache.resolve,
				setValue: function( value ) {
					var template;
					if ( value !== undefined && value === this.value ) {
						// nothing has changed, so no work to be done
						return;
					}
					template = getPartialTemplate( this.root, '' + value );
					// we may be here if we have a partial like `{{>foo}}` and `foo` is the
					// name of both a data property (whose value ISN'T the name of a partial)
					// and a partial. In those cases, this becomes a named partial
					if ( !template && this.name && ( template = getPartialTemplate( this.root, this.name ) ) ) {
						unbind.call( this );
						this.isNamed = true;
					}
					if ( !template ) {
						log.error( {
							debug: this.root.debug,
							message: 'noTemplateForPartial',
							args: {
								name: this.name
							}
						} );
					}
					this.setTemplate( template || [] );
					this.value = value;
					this.bubble();
					if ( this.rendered ) {
						runloop.addView( this );
					}
				},
				setTemplate: function( template ) {
					if ( this.fragment ) {
						this.fragment.unbind();
						this.fragmentToUnrender = this.fragment;
					}
					this.fragment = new Fragment( {
						template: template,
						root: this.root,
						owner: this,
						pElement: this.parentFragment.pElement
					} );
					this.fragmentToRender = this.fragment;
				},
				toString: function( toString ) {
					var string, previousItem, lastLine, match;
					string = this.fragment.toString( toString );
					previousItem = this.parentFragment.items[ this.index - 1 ];
					if ( !previousItem || previousItem.type !== types.TEXT ) {
						return string;
					}
					lastLine = previousItem.text.split( '\n' ).pop();
					if ( match = /^\s+$/.exec( lastLine ) ) {
						return applyIndent( string, match[ 0 ] );
					}
					return string;
				},
				unbind: function() {
					if ( !this.isNamed ) {
						// dynamic partial - need to unbind self
						unbind.call( this );
					}
					if ( this.fragment ) {
						this.fragment.unbind();
					}
				},
				unrender: function( shouldDestroy ) {
					if ( this.rendered ) {
						if ( this.fragment ) {
							this.fragment.unrender( shouldDestroy );
						}
						this.rendered = false;
					}
				},
				update: function() {
					var target, anchor;
					if ( this.fragmentToUnrender ) {
						this.fragmentToUnrender.unrender( true );
						this.fragmentToUnrender = null;
					}
					if ( this.fragmentToRender ) {
						this.docFrag.appendChild( this.fragmentToRender.render() );
						this.fragmentToRender = null;
					}
					if ( this.rendered ) {
						target = this.parentFragment.getNode();
						anchor = this.parentFragment.findNextNode( this );
						target.insertBefore( this.docFrag, anchor );
					}
				}
			};
			return Partial;
		}( log, types, getPartialTemplate, applyIndent, circular, runloop, Mustache, rebind, unbind );
	
		/* virtualdom/items/Component/getComponent.js */
		var getComponent = function( config, log, circular ) {
	
			var Ractive;
			circular.push( function() {
				Ractive = circular.Ractive;
			} );
			// finds the component constructor in the registry or view hierarchy registries
			return function getComponent( ractive, name ) {
				var component, instance = config.registries.components.findInstance( ractive, name );
				if ( instance ) {
					component = instance.components[ name ];
					// best test we have for not Ractive.extend
					if ( !component._parent ) {
						// function option, execute and store for reset
						var fn = component.bind( instance );
						fn.isOwner = instance.components.hasOwnProperty( name );
						component = fn( instance.data );
						if ( !component ) {
							log.warn( {
								debug: ractive.debug,
								message: 'noRegistryFunctionReturn',
								args: {
									registry: 'component',
									name: name
								}
							} );
							return;
						}
						if ( typeof component === 'string' ) {
							//allow string lookup
							component = getComponent( ractive, component );
						}
						component._fn = fn;
						instance.components[ name ] = component;
					}
				}
				return component;
			};
		}( config, log, circular );
	
		/* virtualdom/items/Component/prototype/detach.js */
		var virtualdom_items_Component$detach = function( Hook ) {
	
			var detachHook = new Hook( 'detach' );
			return function Component$detach() {
				var detached = this.instance.fragment.detach();
				detachHook.fire( this.instance );
				return detached;
			};
		}( Ractive$shared_hooks_Hook );
	
		/* virtualdom/items/Component/prototype/find.js */
		var virtualdom_items_Component$find = function Component$find( selector ) {
			return this.instance.fragment.find( selector );
		};
	
		/* virtualdom/items/Component/prototype/findAll.js */
		var virtualdom_items_Component$findAll = function Component$findAll( selector, query ) {
			return this.instance.fragment.findAll( selector, query );
		};
	
		/* virtualdom/items/Component/prototype/findAllComponents.js */
		var virtualdom_items_Component$findAllComponents = function Component$findAllComponents( selector, query ) {
			query._test( this, true );
			if ( this.instance.fragment ) {
				this.instance.fragment.findAllComponents( selector, query );
			}
		};
	
		/* virtualdom/items/Component/prototype/findComponent.js */
		var virtualdom_items_Component$findComponent = function Component$findComponent( selector ) {
			if ( !selector || selector === this.name ) {
				return this.instance;
			}
			if ( this.instance.fragment ) {
				return this.instance.fragment.findComponent( selector );
			}
			return null;
		};
	
		/* virtualdom/items/Component/prototype/findNextNode.js */
		var virtualdom_items_Component$findNextNode = function Component$findNextNode() {
			return this.parentFragment.findNextNode( this );
		};
	
		/* virtualdom/items/Component/prototype/firstNode.js */
		var virtualdom_items_Component$firstNode = function Component$firstNode() {
			if ( this.rendered ) {
				return this.instance.fragment.firstNode();
			}
			return null;
		};
	
		/* virtualdom/items/Component/initialise/createModel/ComponentParameter.js */
		var ComponentParameter = function( runloop, circular ) {
	
			var Fragment, ComponentParameter;
			circular.push( function() {
				Fragment = circular.Fragment;
			} );
			ComponentParameter = function( component, key, value ) {
				this.parentFragment = component.parentFragment;
				this.component = component;
				this.key = key;
				this.fragment = new Fragment( {
					template: value,
					root: component.root,
					owner: this
				} );
				this.value = this.fragment.getValue();
			};
			ComponentParameter.prototype = {
				bubble: function() {
					if ( !this.dirty ) {
						this.dirty = true;
						runloop.addView( this );
					}
				},
				update: function() {
					var value = this.fragment.getValue();
					this.component.instance.viewmodel.set( this.key, value );
					runloop.addViewmodel( this.component.instance.viewmodel );
					this.value = value;
					this.dirty = false;
				},
				rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
					this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
				},
				unbind: function() {
					this.fragment.unbind();
				}
			};
			return ComponentParameter;
		}( runloop, circular );
	
		/* virtualdom/items/Component/initialise/createModel/ReferenceExpressionParameter.js */
		var ReferenceExpressionParameter = function( ReferenceExpressionResolver, createComponentBinding ) {
	
			var ReferenceExpressionParameter = function( component, childKeypath, template, toBind ) {
				var this$0 = this;
				this.root = component.root;
				this.parentFragment = component.parentFragment;
				this.ready = false;
				this.hash = null;
				this.resolver = new ReferenceExpressionResolver( this, template, function( keypath ) {
					// Are we updating an existing binding?
					if ( this$0.binding || ( this$0.binding = component.bindings[ this$0.hash ] ) ) {
						component.bindings[ this$0.hash ] = null;
						this$0.binding.rebind( keypath );
						this$0.hash = keypath + '=' + childKeypath;
						component.bindings[ this$0.hash ];
					} else {
						if ( !this$0.ready ) {
							// The child instance isn't created yet, we need to create the binding later
							toBind.push( {
								childKeypath: childKeypath,
								parentKeypath: keypath
							} );
						} else {
							createComponentBinding( component, component.root, keypath, childKeypath );
						}
					}
					this$0.value = component.root.viewmodel.get( keypath );
				} );
			};
			ReferenceExpressionParameter.prototype = {
				rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
					this.resolver.rebind( indexRef, newIndex, oldKeypath, newKeypath );
				},
				unbind: function() {
					this.resolver.unbind();
				}
			};
			return ReferenceExpressionParameter;
		}( ReferenceExpressionResolver, createComponentBinding );
	
		/* virtualdom/items/Component/initialise/createModel/_createModel.js */
		var createModel = function( types, parseJSON, resolveRef, ComponentParameter, ReferenceExpressionParameter ) {
	
			var __export;
			__export = function( component, defaultData, attributes, toBind ) {
				var data = {},
					key, value;
				// some parameters, e.g. foo="The value is {{bar}}", are 'complex' - in
				// other words, we need to construct a string fragment to watch
				// when they change. We store these so they can be torn down later
				component.complexParameters = [];
				for ( key in attributes ) {
					if ( attributes.hasOwnProperty( key ) ) {
						value = getValue( component, key, attributes[ key ], toBind );
						if ( value !== undefined || defaultData[ key ] === undefined ) {
							data[ key ] = value;
						}
					}
				}
				return data;
			};
	
			function getValue( component, key, template, toBind ) {
				var parameter, parsed, parentInstance, parentFragment, keypath, indexRef;
				parentInstance = component.root;
				parentFragment = component.parentFragment;
				// If this is a static value, great
				if ( typeof template === 'string' ) {
					parsed = parseJSON( template );
					if ( !parsed ) {
						return template;
					}
					return parsed.value;
				}
				// If null, we treat it as a boolean attribute (i.e. true)
				if ( template === null ) {
					return true;
				}
				// Single interpolator?
				if ( template.length === 1 && template[ 0 ].t === types.INTERPOLATOR ) {
					// If it's a regular interpolator, we bind to it
					if ( template[ 0 ].r ) {
						// Is it an index reference?
						if ( parentFragment.indexRefs && parentFragment.indexRefs[ indexRef = template[ 0 ].r ] !== undefined ) {
							component.indexRefBindings[ indexRef ] = key;
							return parentFragment.indexRefs[ indexRef ];
						}
						// TODO what about references that resolve late? Should these be considered?
						keypath = resolveRef( parentInstance, template[ 0 ].r, parentFragment ) || template[ 0 ].r;
						// We need to set up bindings between parent and child, but
						// we can't do it yet because the child instance doesn't exist
						// yet - so we make a note instead
						toBind.push( {
							childKeypath: key,
							parentKeypath: keypath
						} );
						return parentInstance.viewmodel.get( keypath );
					}
					// If it's a reference expression (e.g. `{{foo[bar]}}`), we need
					// to watch the keypath and create/destroy bindings
					if ( template[ 0 ].rx ) {
						parameter = new ReferenceExpressionParameter( component, key, template[ 0 ].rx, toBind );
						component.complexParameters.push( parameter );
						parameter.ready = true;
						return parameter.value;
					}
				}
				// We have a 'complex parameter' - we need to create a full-blown string
				// fragment in order to evaluate and observe its value
				parameter = new ComponentParameter( component, key, template );
				component.complexParameters.push( parameter );
				return parameter.value;
			}
			return __export;
		}( types, parseJSON, resolveRef, ComponentParameter, ReferenceExpressionParameter );
	
		/* virtualdom/items/Component/initialise/createInstance.js */
		var createInstance = function( log ) {
	
			return function( component, Component, data, contentDescriptor ) {
				var instance, parentFragment, partials, ractive;
				parentFragment = component.parentFragment;
				ractive = component.root;
				// Make contents available as a {{>content}} partial
				partials = {
					content: contentDescriptor || []
				};
				if ( Component.defaults.el ) {
					log.warn( {
						debug: ractive.debug,
						message: 'defaultElSpecified',
						args: {
							name: component.name
						}
					} );
				}
				instance = new Component( {
					el: null,
					append: true,
					data: data,
					partials: partials,
					magic: ractive.magic || Component.defaults.magic,
					modifyArrays: ractive.modifyArrays,
					_parent: ractive,
					_component: component,
					// need to inherit runtime parent adaptors
					adapt: ractive.adapt,
					yield: {
						template: contentDescriptor,
						instance: ractive
					}
				} );
				return instance;
			};
		}( log );
	
		/* virtualdom/items/Component/initialise/createBindings.js */
		var createBindings = function( createComponentBinding ) {
	
			return function createInitialComponentBindings( component, toBind ) {
				toBind.forEach( function createInitialComponentBinding( pair ) {
					var childValue, parentValue;
					createComponentBinding( component, component.root, pair.parentKeypath, pair.childKeypath );
					childValue = component.instance.viewmodel.get( pair.childKeypath );
					parentValue = component.root.viewmodel.get( pair.parentKeypath );
					if ( childValue !== undefined && parentValue === undefined ) {
						component.root.viewmodel.set( pair.parentKeypath, childValue );
					}
				} );
			};
		}( createComponentBinding );
	
		/* virtualdom/items/Component/initialise/propagateEvents.js */
		var propagateEvents = function( circular, fireEvent, log ) {
	
			var __export;
			var Fragment;
			circular.push( function() {
				Fragment = circular.Fragment;
			} );
			__export = function propagateEvents( component, eventsDescriptor ) {
				var eventName;
				for ( eventName in eventsDescriptor ) {
					if ( eventsDescriptor.hasOwnProperty( eventName ) ) {
						propagateEvent( component.instance, component.root, eventName, eventsDescriptor[ eventName ] );
					}
				}
			};
	
			function propagateEvent( childInstance, parentInstance, eventName, proxyEventName ) {
				if ( typeof proxyEventName !== 'string' ) {
					log.error( {
						debug: parentInstance.debug,
						message: 'noComponentEventArguments'
					} );
				}
				childInstance.on( eventName, function() {
					var event, args;
					// semi-weak test, but what else? tag the event obj ._isEvent ?
					if ( arguments.length && arguments[ 0 ] && arguments[ 0 ].node ) {
						event = Array.prototype.shift.call( arguments );
					}
					args = Array.prototype.slice.call( arguments );
					fireEvent( parentInstance, proxyEventName, {
						event: event,
						args: args
					} );
					// cancel bubbling
					return false;
				} );
			}
			return __export;
		}( circular, Ractive$shared_fireEvent, log );
	
		/* virtualdom/items/Component/initialise/updateLiveQueries.js */
		var updateLiveQueries = function( component ) {
			var ancestor, query;
			// If there's a live query for this component type, add it
			ancestor = component.root;
			while ( ancestor ) {
				if ( query = ancestor._liveComponentQueries[ '_' + component.name ] ) {
					query.push( component.instance );
				}
				ancestor = ancestor._parent;
			}
		};
	
		/* virtualdom/items/Component/prototype/init.js */
		var virtualdom_items_Component$init = function( types, warn, createModel, createInstance, createBindings, propagateEvents, updateLiveQueries ) {
	
			return function Component$init( options, Component ) {
				var parentFragment, root, data, toBind;
				parentFragment = this.parentFragment = options.parentFragment;
				root = parentFragment.root;
				this.root = root;
				this.type = types.COMPONENT;
				this.name = options.template.e;
				this.index = options.index;
				this.indexRefBindings = {};
				this.bindings = [];
				// even though only one yielder is allowed, we need to have an array of them
				// as it's possible to cause a yielder to be created before the last one
				// was destroyed in the same turn of the runloop
				this.yielders = [];
				if ( !Component ) {
					throw new Error( 'Component "' + this.name + '" not found' );
				}
				// First, we need to create a model for the component - e.g. if we
				// encounter <widget foo='bar'/> then we need to create a widget
				// with `data: { foo: 'bar' }`.
				//
				// This may involve setting up some bindings, but we can't do it
				// yet so we take some notes instead
				toBind = [];
				data = createModel( this, Component.defaults.data || {}, options.template.a, toBind );
				createInstance( this, Component, data, options.template.f );
				createBindings( this, toBind );
				propagateEvents( this, options.template.v );
				// intro, outro and decorator directives have no effect
				if ( options.template.t1 || options.template.t2 || options.template.o ) {
					warn( 'The "intro", "outro" and "decorator" directives have no effect on components' );
				}
				updateLiveQueries( this );
			};
		}( types, warn, createModel, createInstance, createBindings, propagateEvents, updateLiveQueries );
	
		/* virtualdom/items/Component/prototype/rebind.js */
		var virtualdom_items_Component$rebind = function( runloop, getNewKeypath ) {
	
			return function Component$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
				var childInstance = this.instance,
					parentInstance = childInstance._parent,
					indexRefAlias, query;
				this.bindings.forEach( function( binding ) {
					var updated;
					if ( binding.root !== parentInstance ) {
						return;
					}
					if ( updated = getNewKeypath( binding.keypath, oldKeypath, newKeypath ) ) {
						binding.rebind( updated );
					}
				} );
				this.complexParameters.forEach( rebind );
				if ( this.yielders[ 0 ] ) {
					rebind( this.yielders[ 0 ] );
				}
				if ( indexRefAlias = this.indexRefBindings[ indexRef ] ) {
					runloop.addViewmodel( childInstance.viewmodel );
					childInstance.viewmodel.set( indexRefAlias, newIndex );
				}
				if ( query = this.root._liveComponentQueries[ '_' + this.name ] ) {
					query._makeDirty();
				}
	
				function rebind( x ) {
					x.rebind( indexRef, newIndex, oldKeypath, newKeypath );
				}
			};
		}( runloop, getNewKeypath );
	
		/* virtualdom/items/Component/prototype/render.js */
		var virtualdom_items_Component$render = function Component$render() {
			var instance = this.instance;
			instance.render( this.parentFragment.getNode() );
			this.rendered = true;
			return instance.fragment.detach();
		};
	
		/* virtualdom/items/Component/prototype/toString.js */
		var virtualdom_items_Component$toString = function Component$toString() {
			return this.instance.fragment.toString();
		};
	
		/* virtualdom/items/Component/prototype/unbind.js */
		var virtualdom_items_Component$unbind = function( Hook, removeFromArray ) {
	
			var __export;
			var teardownHook = new Hook( 'teardown' );
			__export = function Component$unbind() {
				var instance = this.instance;
				this.complexParameters.forEach( unbind );
				this.bindings.forEach( unbind );
				removeFromLiveComponentQueries( this );
				// teardown the instance
				instance.fragment.unbind();
				instance.viewmodel.teardown();
				if ( instance.fragment.rendered && instance.el.__ractive_instances__ ) {
					removeFromArray( instance.el.__ractive_instances__, instance );
				}
				teardownHook.fire( instance );
			};
	
			function unbind( thing ) {
				thing.unbind();
			}
	
			function removeFromLiveComponentQueries( component ) {
				var instance, query;
				instance = component.root;
				do {
					if ( query = instance._liveComponentQueries[ '_' + component.name ] ) {
						query._remove( component );
					}
				} while ( instance = instance._parent );
			}
			return __export;
		}( Ractive$shared_hooks_Hook, removeFromArray );
	
		/* virtualdom/items/Component/prototype/unrender.js */
		var virtualdom_items_Component$unrender = function Component$unrender( shouldDestroy ) {
			this.shouldDestroy = shouldDestroy;
			this.instance.unrender();
		};
	
		/* virtualdom/items/Component/_Component.js */
		var Component = function( detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, init, rebind, render, toString, unbind, unrender ) {
	
			var Component = function( options, Constructor ) {
				this.init( options, Constructor );
			};
			Component.prototype = {
				detach: detach,
				find: find,
				findAll: findAll,
				findAllComponents: findAllComponents,
				findComponent: findComponent,
				findNextNode: findNextNode,
				firstNode: firstNode,
				init: init,
				rebind: rebind,
				render: render,
				toString: toString,
				unbind: unbind,
				unrender: unrender
			};
			return Component;
		}( virtualdom_items_Component$detach, virtualdom_items_Component$find, virtualdom_items_Component$findAll, virtualdom_items_Component$findAllComponents, virtualdom_items_Component$findComponent, virtualdom_items_Component$findNextNode, virtualdom_items_Component$firstNode, virtualdom_items_Component$init, virtualdom_items_Component$rebind, virtualdom_items_Component$render, virtualdom_items_Component$toString, virtualdom_items_Component$unbind, virtualdom_items_Component$unrender );
	
		/* virtualdom/items/Comment.js */
		var Comment = function( types, detach ) {
	
			var Comment = function( options ) {
				this.type = types.COMMENT;
				this.value = options.template.c;
			};
			Comment.prototype = {
				detach: detach,
				firstNode: function() {
					return this.node;
				},
				render: function() {
					if ( !this.node ) {
						this.node = document.createComment( this.value );
					}
					return this.node;
				},
				toString: function() {
					return '<!--' + this.value + '-->';
				},
				unrender: function( shouldDestroy ) {
					if ( shouldDestroy ) {
						this.node.parentNode.removeChild( this.node );
					}
				}
			};
			return Comment;
		}( types, detach );
	
		/* virtualdom/items/Yielder.js */
		var Yielder = function( runloop, removeFromArray, circular ) {
	
			var Fragment;
			circular.push( function() {
				Fragment = circular.Fragment;
			} );
			var Yielder = function( options ) {
				var componentInstance, component;
				componentInstance = options.parentFragment.root;
				this.component = component = componentInstance.component;
				this.surrogateParent = options.parentFragment;
				this.parentFragment = component.parentFragment;
				this.fragment = new Fragment( {
					owner: this,
					root: componentInstance.yield.instance,
					template: componentInstance.yield.template,
					pElement: this.surrogateParent.pElement
				} );
				component.yielders.push( this );
				runloop.scheduleTask( function() {
					if ( component.yielders.length > 1 ) {
						throw new Error( 'A component template can only have one {{yield}} declaration at a time' );
					}
				} );
			};
			Yielder.prototype = {
				detach: function() {
					return this.fragment.detach();
				},
				find: function( selector ) {
					return this.fragment.find( selector );
				},
				findAll: function( selector, query ) {
					return this.fragment.findAll( selector, query );
				},
				findComponent: function( selector ) {
					return this.fragment.findComponent( selector );
				},
				findAllComponents: function( selector, query ) {
					return this.fragment.findAllComponents( selector, query );
				},
				findNextNode: function() {
					return this.surrogateParent.findNextNode( this );
				},
				firstNode: function() {
					return this.fragment.firstNode();
				},
				getValue: function( options ) {
					return this.fragment.getValue( options );
				},
				render: function() {
					return this.fragment.render();
				},
				unbind: function() {
					this.fragment.unbind();
				},
				unrender: function( shouldDestroy ) {
					this.fragment.unrender( shouldDestroy );
					removeFromArray( this.component.yielders, this );
				},
				rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
					this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
				},
				toString: function() {
					return this.fragment.toString();
				}
			};
			return Yielder;
		}( runloop, removeFromArray, circular );
	
		/* virtualdom/Fragment/prototype/init/createItem.js */
		var virtualdom_Fragment$init_createItem = function( types, Text, Interpolator, Section, Triple, Element, Partial, getComponent, Component, Comment, Yielder ) {
	
			return function createItem( options ) {
				if ( typeof options.template === 'string' ) {
					return new Text( options );
				}
				switch ( options.template.t ) {
					case types.INTERPOLATOR:
						if ( options.template.r === 'yield' ) {
							return new Yielder( options );
						}
						return new Interpolator( options );
					case types.SECTION:
						return new Section( options );
					case types.TRIPLE:
						return new Triple( options );
					case types.ELEMENT:
						var constructor;
						if ( constructor = getComponent( options.parentFragment.root, options.template.e ) ) {
							return new Component( options, constructor );
						}
						return new Element( options );
					case types.PARTIAL:
						return new Partial( options );
					case types.COMMENT:
						return new Comment( options );
					default:
						throw new Error( 'Something very strange happened. Please file an issue at https://github.com/ractivejs/ractive/issues. Thanks!' );
				}
			};
		}( types, Text, Interpolator, Section, Triple, Element, Partial, getComponent, Component, Comment, Yielder );
	
		/* virtualdom/Fragment/prototype/init.js */
		var virtualdom_Fragment$init = function( types, create, createItem ) {
	
			return function Fragment$init( options ) {
				var this$0 = this;
				var parentFragment, parentRefs, ref;
				// The item that owns this fragment - an element, section, partial, or attribute
				this.owner = options.owner;
				parentFragment = this.parent = this.owner.parentFragment;
				// inherited properties
				this.root = options.root;
				this.pElement = options.pElement;
				this.context = options.context;
				// If parent item is a section, this may not be the only fragment
				// that belongs to it - we need to make a note of the index
				if ( this.owner.type === types.SECTION ) {
					this.index = options.index;
				}
				// index references (the 'i' in {{#section:i}}...{{/section}}) need to cascade
				// down the tree
				if ( parentFragment ) {
					parentRefs = parentFragment.indexRefs;
					if ( parentRefs ) {
						this.indexRefs = create( null );
						// avoids need for hasOwnProperty
						for ( ref in parentRefs ) {
							this.indexRefs[ ref ] = parentRefs[ ref ];
						}
					}
				}
				if ( options.indexRef ) {
					if ( !this.indexRefs ) {
						this.indexRefs = {};
					}
					this.indexRefs[ options.indexRef ] = options.index;
				}
				// Time to create this fragment's child items
				// TEMP should this be happening?
				if ( typeof options.template === 'string' ) {
					options.template = [ options.template ];
				} else if ( !options.template ) {
					options.template = [];
				}
				this.items = options.template.map( function( template, i ) {
					return createItem( {
						parentFragment: this$0,
						pElement: options.pElement,
						template: template,
						index: i
					} );
				} );
				this.value = this.argsList = null;
				this.dirtyArgs = this.dirtyValue = true;
				this.bound = true;
			};
		}( types, create, virtualdom_Fragment$init_createItem );
	
		/* virtualdom/Fragment/prototype/rebind.js */
		var virtualdom_Fragment$rebind = function( assignNewKeypath ) {
	
			return function Fragment$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
				this.index = newIndex;
				// assign new context keypath if needed
				assignNewKeypath( this, 'context', oldKeypath, newKeypath );
				if ( this.indexRefs && this.indexRefs[ indexRef ] !== undefined ) {
					this.indexRefs[ indexRef ] = newIndex;
				}
				this.items.forEach( function( item ) {
					if ( item.rebind ) {
						item.rebind( indexRef, newIndex, oldKeypath, newKeypath );
					}
				} );
			};
		}( assignNewKeypath );
	
		/* virtualdom/Fragment/prototype/render.js */
		var virtualdom_Fragment$render = function Fragment$render() {
			var result;
			if ( this.items.length === 1 ) {
				result = this.items[ 0 ].render();
			} else {
				result = document.createDocumentFragment();
				this.items.forEach( function( item ) {
					result.appendChild( item.render() );
				} );
			}
			this.rendered = true;
			return result;
		};
	
		/* virtualdom/Fragment/prototype/toString.js */
		var virtualdom_Fragment$toString = function Fragment$toString( escape ) {
			if ( !this.items ) {
				return '';
			}
			return this.items.map( function( item ) {
				return item.toString( escape );
			} ).join( '' );
		};
	
		/* virtualdom/Fragment/prototype/unbind.js */
		var virtualdom_Fragment$unbind = function() {
	
			var __export;
			__export = function Fragment$unbind() {
				if ( !this.bound ) {
					return;
				}
				this.items.forEach( unbindItem );
				this.bound = false;
			};
	
			function unbindItem( item ) {
				if ( item.unbind ) {
					item.unbind();
				}
			}
			return __export;
		}();
	
		/* virtualdom/Fragment/prototype/unrender.js */
		var virtualdom_Fragment$unrender = function Fragment$unrender( shouldDestroy ) {
			if ( !this.rendered ) {
				throw new Error( 'Attempted to unrender a fragment that was not rendered' );
			}
			this.items.forEach( function( i ) {
				return i.unrender( shouldDestroy );
			} );
			this.rendered = false;
		};
	
		/* virtualdom/Fragment.js */
		var Fragment = function( bubble, detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, getNode, getValue, init, rebind, render, toString, unbind, unrender, circular ) {
	
			var Fragment = function( options ) {
				this.init( options );
			};
			Fragment.prototype = {
				bubble: bubble,
				detach: detach,
				find: find,
				findAll: findAll,
				findAllComponents: findAllComponents,
				findComponent: findComponent,
				findNextNode: findNextNode,
				firstNode: firstNode,
				getNode: getNode,
				getValue: getValue,
				init: init,
				rebind: rebind,
				render: render,
				toString: toString,
				unbind: unbind,
				unrender: unrender
			};
			circular.Fragment = Fragment;
			return Fragment;
		}( virtualdom_Fragment$bubble, virtualdom_Fragment$detach, virtualdom_Fragment$find, virtualdom_Fragment$findAll, virtualdom_Fragment$findAllComponents, virtualdom_Fragment$findComponent, virtualdom_Fragment$findNextNode, virtualdom_Fragment$firstNode, virtualdom_Fragment$getNode, virtualdom_Fragment$getValue, virtualdom_Fragment$init, virtualdom_Fragment$rebind, virtualdom_Fragment$render, virtualdom_Fragment$toString, virtualdom_Fragment$unbind, virtualdom_Fragment$unrender, circular );
	
		/* Ractive/prototype/reset.js */
		var Ractive$reset = function( Hook, runloop, Fragment, config ) {
	
			var shouldRerender = [
					'template',
					'partials',
					'components',
					'decorators',
					'events'
				],
				resetHook = new Hook( 'reset' );
			return function Ractive$reset( data, callback ) {
				var promise, wrapper, changes, i, rerender;
				if ( typeof data === 'function' && !callback ) {
					callback = data;
					data = {};
				} else {
					data = data || {};
				}
				if ( typeof data !== 'object' ) {
					throw new Error( 'The reset method takes either no arguments, or an object containing new data' );
				}
				// If the root object is wrapped, try and use the wrapper's reset value
				if ( ( wrapper = this.viewmodel.wrapped[ '' ] ) && wrapper.reset ) {
					if ( wrapper.reset( data ) === false ) {
						// reset was rejected, we need to replace the object
						this.data = data;
					}
				} else {
					this.data = data;
				}
				// reset config items and track if need to rerender
				changes = config.reset( this );
				i = changes.length;
				while ( i-- ) {
					if ( shouldRerender.indexOf( changes[ i ] ) > -1 ) {
						rerender = true;
						break;
					}
				}
				if ( rerender ) {
					var component;
					this.viewmodel.mark( '' );
					// Is this is a component, we need to set the `shouldDestroy`
					// flag, otherwise it will assume by default that a parent node
					// will be detached, and therefore it doesn't need to bother
					// detaching its own nodes
					if ( component = this.component ) {
						component.shouldDestroy = true;
					}
					this.unrender();
					if ( component ) {
						component.shouldDestroy = false;
					}
					// If the template changed, we need to destroy the parallel DOM
					// TODO if we're here, presumably it did?
					if ( this.fragment.template !== this.template ) {
						this.fragment.unbind();
						this.fragment = new Fragment( {
							template: this.template,
							root: this,
							owner: this
						} );
					}
					promise = this.render( this.el, this.anchor );
				} else {
					promise = runloop.start( this, true );
					this.viewmodel.mark( '' );
					runloop.end();
				}
				resetHook.fire( this, data );
				if ( callback ) {
					promise.then( callback );
				}
				return promise;
			};
		}( Ractive$shared_hooks_Hook, runloop, Fragment, config );
	
		/* Ractive/prototype/resetTemplate.js */
		var Ractive$resetTemplate = function( config, Fragment ) {
	
			return function Ractive$resetTemplate( template ) {
				var transitionsEnabled, component;
				config.template.init( null, this, {
					template: template
				} );
				transitionsEnabled = this.transitionsEnabled;
				this.transitionsEnabled = false;
				// Is this is a component, we need to set the `shouldDestroy`
				// flag, otherwise it will assume by default that a parent node
				// will be detached, and therefore it doesn't need to bother
				// detaching its own nodes
				if ( component = this.component ) {
					component.shouldDestroy = true;
				}
				this.unrender();
				if ( component ) {
					component.shouldDestroy = false;
				}
				// remove existing fragment and create new one
				this.fragment.unbind();
				this.fragment = new Fragment( {
					template: this.template,
					root: this,
					owner: this
				} );
				this.render( this.el, this.anchor );
				this.transitionsEnabled = transitionsEnabled;
			};
		}( config, Fragment );
	
		/* Ractive/prototype/reverse.js */
		var Ractive$reverse = function( makeArrayMethod ) {
	
			return makeArrayMethod( 'reverse' );
		}( Ractive$shared_makeArrayMethod );
	
		/* Ractive/prototype/set.js */
		var Ractive$set = function( runloop, isObject, normaliseKeypath, getMatchingKeypaths ) {
	
			var wildcard = /\*/;
			return function Ractive$set( keypath, value, callback ) {
				var this$0 = this;
				var map, promise;
				promise = runloop.start( this, true );
				// Set multiple keypaths in one go
				if ( isObject( keypath ) ) {
					map = keypath;
					callback = value;
					for ( keypath in map ) {
						if ( map.hasOwnProperty( keypath ) ) {
							value = map[ keypath ];
							keypath = normaliseKeypath( keypath );
							this.viewmodel.set( keypath, value );
						}
					}
				} else {
					keypath = normaliseKeypath( keypath );
					if ( wildcard.test( keypath ) ) {
						getMatchingKeypaths( this, keypath ).forEach( function( keypath ) {
							this$0.viewmodel.set( keypath, value );
						} );
					} else {
						this.viewmodel.set( keypath, value );
					}
				}
				runloop.end();
				if ( callback ) {
					promise.then( callback.bind( this ) );
				}
				return promise;
			};
		}( runloop, isObject, normaliseKeypath, getMatchingKeypaths );
	
		/* Ractive/prototype/shift.js */
		var Ractive$shift = function( makeArrayMethod ) {
	
			return makeArrayMethod( 'shift' );
		}( Ractive$shared_makeArrayMethod );
	
		/* Ractive/prototype/sort.js */
		var Ractive$sort = function( makeArrayMethod ) {
	
			return makeArrayMethod( 'sort' );
		}( Ractive$shared_makeArrayMethod );
	
		/* Ractive/prototype/splice.js */
		var Ractive$splice = function( makeArrayMethod ) {
	
			return makeArrayMethod( 'splice' );
		}( Ractive$shared_makeArrayMethod );
	
		/* Ractive/prototype/subtract.js */
		var Ractive$subtract = function( add ) {
	
			return function Ractive$subtract( keypath, d ) {
				return add( this, keypath, d === undefined ? -1 : -d );
			};
		}( Ractive$shared_add );
	
		/* Ractive/prototype/teardown.js */
		var Ractive$teardown = function( Hook, Promise, removeFromArray ) {
	
			var teardownHook = new Hook( 'teardown' );
			// Teardown. This goes through the root fragment and all its children, removing observers
			// and generally cleaning up after itself
			return function Ractive$teardown( callback ) {
				var promise;
				this.fragment.unbind();
				this.viewmodel.teardown();
				if ( this.fragment.rendered && this.el.__ractive_instances__ ) {
					removeFromArray( this.el.__ractive_instances__, this );
				}
				this.shouldDestroy = true;
				promise = this.fragment.rendered ? this.unrender() : Promise.resolve();
				teardownHook.fire( this );
				if ( callback ) {
					// TODO deprecate this?
					promise.then( callback.bind( this ) );
				}
				return promise;
			};
		}( Ractive$shared_hooks_Hook, Promise, removeFromArray );
	
		/* Ractive/prototype/toggle.js */
		var Ractive$toggle = function( log ) {
	
			return function Ractive$toggle( keypath, callback ) {
				var value;
				if ( typeof keypath !== 'string' ) {
					log.errorOnly( {
						debug: this.debug,
						messsage: 'badArguments',
						arg: {
							arguments: keypath
						}
					} );
				}
				value = this.get( keypath );
				return this.set( keypath, !value, callback );
			};
		}( log );
	
		/* Ractive/prototype/toHTML.js */
		var Ractive$toHTML = function Ractive$toHTML() {
			return this.fragment.toString( true );
		};
	
		/* Ractive/prototype/unrender.js */
		var Ractive$unrender = function( css, Hook, log, Promise, removeFromArray, runloop ) {
	
			var unrenderHook = new Hook( 'unrender' );
			return function Ractive$unrender() {
				var this$0 = this;
				var promise, shouldDestroy;
				if ( !this.fragment.rendered ) {
					log.warn( {
						debug: this.debug,
						message: 'ractive.unrender() was called on a Ractive instance that was not rendered'
					} );
					return Promise.resolve();
				}
				promise = runloop.start( this, true );
				// If this is a component, and the component isn't marked for destruction,
				// don't detach nodes from the DOM unnecessarily
				shouldDestroy = !this.component || this.component.shouldDestroy || this.shouldDestroy;
				if ( this.constructor.css ) {
					promise.then( function() {
						css.remove( this$0.constructor );
					} );
				}
				// Cancel any animations in progress
				while ( this._animations[ 0 ] ) {
					this._animations[ 0 ].stop();
				}
				this.fragment.unrender( shouldDestroy );
				removeFromArray( this.el.__ractive_instances__, this );
				unrenderHook.fire( this );
				runloop.end();
				return promise;
			};
		}( global_css, Ractive$shared_hooks_Hook, log, Promise, removeFromArray, runloop );
	
		/* Ractive/prototype/unshift.js */
		var Ractive$unshift = function( makeArrayMethod ) {
	
			return makeArrayMethod( 'unshift' );
		}( Ractive$shared_makeArrayMethod );
	
		/* Ractive/prototype/update.js */
		var Ractive$update = function( Hook, runloop ) {
	
			var updateHook = new Hook( 'update' );
			return function Ractive$update( keypath, callback ) {
				var promise;
				if ( typeof keypath === 'function' ) {
					callback = keypath;
					keypath = '';
				} else {
					keypath = keypath || '';
				}
				promise = runloop.start( this, true );
				this.viewmodel.mark( keypath );
				runloop.end();
				updateHook.fire( this, keypath );
				if ( callback ) {
					promise.then( callback.bind( this ) );
				}
				return promise;
			};
		}( Ractive$shared_hooks_Hook, runloop );
	
		/* Ractive/prototype/updateModel.js */
		var Ractive$updateModel = function( arrayContentsMatch, isEqual ) {
	
			var __export;
			__export = function Ractive$updateModel( keypath, cascade ) {
				var values;
				if ( typeof keypath !== 'string' ) {
					keypath = '';
					cascade = true;
				}
				consolidateChangedValues( this, keypath, values = {}, cascade );
				return this.set( values );
			};
	
			function consolidateChangedValues( ractive, keypath, values, cascade ) {
				var bindings, childDeps, i, binding, oldValue, newValue, checkboxGroups = [];
				bindings = ractive._twowayBindings[ keypath ];
				if ( bindings && ( i = bindings.length ) ) {
					while ( i-- ) {
						binding = bindings[ i ];
						// special case - radio name bindings
						if ( binding.radioName && !binding.element.node.checked ) {
							continue;
						}
						// special case - checkbox name bindings come in groups, so
						// we want to get the value once at most
						if ( binding.checkboxName ) {
							if ( !checkboxGroups[ binding.keypath ] && !binding.changed() ) {
								checkboxGroups.push( binding.keypath );
								checkboxGroups[ binding.keypath ] = binding;
							}
							continue;
						}
						oldValue = binding.attribute.value;
						newValue = binding.getValue();
						if ( arrayContentsMatch( oldValue, newValue ) ) {
							continue;
						}
						if ( !isEqual( oldValue, newValue ) ) {
							values[ keypath ] = newValue;
						}
					}
				}
				// Handle groups of `<input type='checkbox' name='{{foo}}' ...>`
				if ( checkboxGroups.length ) {
					checkboxGroups.forEach( function( keypath ) {
						var binding, oldValue, newValue;
						binding = checkboxGroups[ keypath ];
						// one to represent the entire group
						oldValue = binding.attribute.value;
						newValue = binding.getValue();
						if ( !arrayContentsMatch( oldValue, newValue ) ) {
							values[ keypath ] = newValue;
						}
					} );
				}
				if ( !cascade ) {
					return;
				}
				// cascade
				childDeps = ractive.viewmodel.depsMap[ 'default' ][ keypath ];
				if ( childDeps ) {
					i = childDeps.length;
					while ( i-- ) {
						consolidateChangedValues( ractive, childDeps[ i ], values, cascade );
					}
				}
			}
			return __export;
		}( arrayContentsMatch, isEqual );
	
		/* Ractive/prototype.js */
		var prototype = function( add, animate, detach, find, findAll, findAllComponents, findComponent, fire, get, insert, merge, observe, off, on, pop, push, render, reset, resetTemplate, reverse, set, shift, sort, splice, subtract, teardown, toggle, toHTML, unrender, unshift, update, updateModel ) {
	
			return {
				add: add,
				animate: animate,
				detach: detach,
				find: find,
				findAll: findAll,
				findAllComponents: findAllComponents,
				findComponent: findComponent,
				fire: fire,
				get: get,
				insert: insert,
				merge: merge,
				observe: observe,
				off: off,
				on: on,
				pop: pop,
				push: push,
				render: render,
				reset: reset,
				resetTemplate: resetTemplate,
				reverse: reverse,
				set: set,
				shift: shift,
				sort: sort,
				splice: splice,
				subtract: subtract,
				teardown: teardown,
				toggle: toggle,
				toHTML: toHTML,
				unrender: unrender,
				unshift: unshift,
				update: update,
				updateModel: updateModel
			};
		}( Ractive$add, Ractive$animate, Ractive$detach, Ractive$find, Ractive$findAll, Ractive$findAllComponents, Ractive$findComponent, Ractive$fire, Ractive$get, Ractive$insert, Ractive$merge, Ractive$observe, Ractive$off, Ractive$on, Ractive$pop, Ractive$push, Ractive$render, Ractive$reset, Ractive$resetTemplate, Ractive$reverse, Ractive$set, Ractive$shift, Ractive$sort, Ractive$splice, Ractive$subtract, Ractive$teardown, Ractive$toggle, Ractive$toHTML, Ractive$unrender, Ractive$unshift, Ractive$update, Ractive$updateModel );
	
		/* utils/getGuid.js */
		var getGuid = function() {
			return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace( /[xy]/g, function( c ) {
				var r, v;
				r = Math.random() * 16 | 0;
				v = c == 'x' ? r : r & 3 | 8;
				return v.toString( 16 );
			} );
		};
	
		/* utils/getNextNumber.js */
		var getNextNumber = function() {
	
			var i = 0;
			return function() {
				return 'r-' + i++;
			};
		}();
	
		/* Ractive/prototype/shared/hooks/HookQueue.js */
		var Ractive$shared_hooks_HookQueue = function( Hook ) {
	
			function HookQueue( event ) {
				this.hook = new Hook( event );
				this.inProcess = {};
				this.queue = {};
			}
			HookQueue.prototype = {
				constructor: HookQueue,
				begin: function( ractive ) {
					this.inProcess[ ractive._guid ] = true;
				},
				end: function( ractive ) {
					var parent = ractive._parent;
					// If this is *isn't* a child of a component that's in process,
					// it should call methods or fire at this point
					if ( !parent || !this.inProcess[ parent._guid ] ) {
						fire( this, ractive );
					} else {
						getChildQueue( this.queue, parent ).push( ractive );
					}
					delete this.inProcess[ ractive._guid ];
				}
			};
	
			function getChildQueue( queue, ractive ) {
				return queue[ ractive._guid ] || ( queue[ ractive._guid ] = [] );
			}
	
			function fire( hookQueue, ractive ) {
				var childQueue = getChildQueue( hookQueue.queue, ractive );
				hookQueue.hook.fire( ractive );
				// queue is "live" because components can end up being
				// added while hooks fire on parents that modify data values.
				while ( childQueue.length ) {
					fire( hookQueue, childQueue.shift() );
				}
				delete hookQueue.queue[ ractive._guid ];
			}
			return HookQueue;
		}( Ractive$shared_hooks_Hook );
	
		/* viewmodel/prototype/get/arrayAdaptor/processWrapper.js */
		var viewmodel$get_arrayAdaptor_processWrapper = function( wrapper, array, methodName, newIndices ) {
			var root = wrapper.root,
				keypath = wrapper.keypath;
			// If this is a sort or reverse, we just do root.set()...
			// TODO use merge logic?
			if ( methodName === 'sort' || methodName === 'reverse' ) {
				root.viewmodel.set( keypath, array );
				return;
			}
			root.viewmodel.smartUpdate( keypath, array, newIndices );
		};
	
		/* viewmodel/prototype/get/arrayAdaptor/patch.js */
		var viewmodel$get_arrayAdaptor_patch = function( runloop, defineProperty, getNewIndices, processWrapper ) {
	
			var patchedArrayProto = [],
				mutatorMethods = [
					'pop',
					'push',
					'reverse',
					'shift',
					'sort',
					'splice',
					'unshift'
				],
				testObj, patchArrayMethods, unpatchArrayMethods;
			mutatorMethods.forEach( function( methodName ) {
				var method = function() {
					var SLICE$0 = Array.prototype.slice;
					var args = SLICE$0.call( arguments, 0 );
					var newIndices, result, wrapper, i;
					newIndices = getNewIndices( this, methodName, args );
					// apply the underlying method
					result = Array.prototype[ methodName ].apply( this, arguments );
					// trigger changes
					runloop.start();
					this._ractive.setting = true;
					i = this._ractive.wrappers.length;
					while ( i-- ) {
						wrapper = this._ractive.wrappers[ i ];
						runloop.addViewmodel( wrapper.root.viewmodel );
						processWrapper( wrapper, this, methodName, newIndices );
					}
					runloop.end();
					this._ractive.setting = false;
					return result;
				};
				defineProperty( patchedArrayProto, methodName, {
					value: method
				} );
			} );
			// can we use prototype chain injection?
			// http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/#wrappers_prototype_chain_injection
			testObj = {};
			if ( testObj.__proto__ ) {
				// yes, we can
				patchArrayMethods = function( array ) {
					array.__proto__ = patchedArrayProto;
				};
				unpatchArrayMethods = function( array ) {
					array.__proto__ = Array.prototype;
				};
			} else {
				// no, we can't
				patchArrayMethods = function( array ) {
					var i, methodName;
					i = mutatorMethods.length;
					while ( i-- ) {
						methodName = mutatorMethods[ i ];
						defineProperty( array, methodName, {
							value: patchedArrayProto[ methodName ],
							configurable: true
						} );
					}
				};
				unpatchArrayMethods = function( array ) {
					var i;
					i = mutatorMethods.length;
					while ( i-- ) {
						delete array[ mutatorMethods[ i ] ];
					}
				};
			}
			patchArrayMethods.unpatch = unpatchArrayMethods;
			return patchArrayMethods;
		}( runloop, defineProperty, getNewIndices, viewmodel$get_arrayAdaptor_processWrapper );
	
		/* viewmodel/prototype/get/arrayAdaptor.js */
		var viewmodel$get_arrayAdaptor = function( defineProperty, isArray, patch ) {
	
			var arrayAdaptor,
				// helpers
				ArrayWrapper, errorMessage;
			arrayAdaptor = {
				filter: function( object ) {
					// wrap the array if a) b) it's an array, and b) either it hasn't been wrapped already,
					// or the array didn't trigger the get() itself
					return isArray( object ) && ( !object._ractive || !object._ractive.setting );
				},
				wrap: function( ractive, array, keypath ) {
					return new ArrayWrapper( ractive, array, keypath );
				}
			};
			ArrayWrapper = function( ractive, array, keypath ) {
				this.root = ractive;
				this.value = array;
				this.keypath = keypath;
				// if this array hasn't already been ractified, ractify it
				if ( !array._ractive ) {
					// define a non-enumerable _ractive property to store the wrappers
					defineProperty( array, '_ractive', {
						value: {
							wrappers: [],
							instances: [],
							setting: false
						},
						configurable: true
					} );
					patch( array );
				}
				// store the ractive instance, so we can handle transitions later
				if ( !array._ractive.instances[ ractive._guid ] ) {
					array._ractive.instances[ ractive._guid ] = 0;
					array._ractive.instances.push( ractive );
				}
				array._ractive.instances[ ractive._guid ] += 1;
				array._ractive.wrappers.push( this );
			};
			ArrayWrapper.prototype = {
				get: function() {
					return this.value;
				},
				teardown: function() {
					var array, storage, wrappers, instances, index;
					array = this.value;
					storage = array._ractive;
					wrappers = storage.wrappers;
					instances = storage.instances;
					// if teardown() was invoked because we're clearing the cache as a result of
					// a change that the array itself triggered, we can save ourselves the teardown
					// and immediate setup
					if ( storage.setting ) {
						return false;
					}
					index = wrappers.indexOf( this );
					if ( index === -1 ) {
						throw new Error( errorMessage );
					}
					wrappers.splice( index, 1 );
					// if nothing else depends on this array, we can revert it to its
					// natural state
					if ( !wrappers.length ) {
						delete array._ractive;
						patch.unpatch( this.value );
					} else {
						// remove ractive instance if possible
						instances[ this.root._guid ] -= 1;
						if ( !instances[ this.root._guid ] ) {
							index = instances.indexOf( this.root );
							if ( index === -1 ) {
								throw new Error( errorMessage );
							}
							instances.splice( index, 1 );
						}
					}
				}
			};
			errorMessage = 'Something went wrong in a rather interesting way';
			return arrayAdaptor;
		}( defineProperty, isArray, viewmodel$get_arrayAdaptor_patch );
	
		/* viewmodel/prototype/get/magicArrayAdaptor.js */
		var viewmodel$get_magicArrayAdaptor = function( magicAdaptor, arrayAdaptor ) {
	
			var magicArrayAdaptor, MagicArrayWrapper;
			if ( magicAdaptor ) {
				magicArrayAdaptor = {
					filter: function( object, keypath, ractive ) {
						return magicAdaptor.filter( object, keypath, ractive ) && arrayAdaptor.filter( object );
					},
					wrap: function( ractive, array, keypath ) {
						return new MagicArrayWrapper( ractive, array, keypath );
					}
				};
				MagicArrayWrapper = function( ractive, array, keypath ) {
					this.value = array;
					this.magic = true;
					this.magicWrapper = magicAdaptor.wrap( ractive, array, keypath );
					this.arrayWrapper = arrayAdaptor.wrap( ractive, array, keypath );
				};
				MagicArrayWrapper.prototype = {
					get: function() {
						return this.value;
					},
					teardown: function() {
						this.arrayWrapper.teardown();
						this.magicWrapper.teardown();
					},
					reset: function( value ) {
						return this.magicWrapper.reset( value );
					}
				};
			}
			return magicArrayAdaptor;
		}( viewmodel$get_magicAdaptor, viewmodel$get_arrayAdaptor );
	
		/* viewmodel/prototype/adapt.js */
		var viewmodel$adapt = function( config, arrayAdaptor, log, magicAdaptor, magicArrayAdaptor ) {
	
			var __export;
			var prefixers = {};
			__export = function Viewmodel$adapt( keypath, value ) {
				var ractive = this.ractive,
					len, i, adaptor, wrapped;
				// Do we have an adaptor for this value?
				len = ractive.adapt.length;
				for ( i = 0; i < len; i += 1 ) {
					adaptor = ractive.adapt[ i ];
					// Adaptors can be specified as e.g. [ 'Backbone.Model', 'Backbone.Collection' ] -
					// we need to get the actual adaptor if that's the case
					if ( typeof adaptor === 'string' ) {
						var found = config.registries.adaptors.find( ractive, adaptor );
						if ( !found ) {
							// will throw. "return" for safety, if we downgrade :)
							return log.critical( {
								debug: ractive.debug,
								message: 'missingPlugin',
								args: {
									plugin: 'adaptor',
									name: adaptor
								}
							} );
						}
						adaptor = ractive.adapt[ i ] = found;
					}
					if ( adaptor.filter( value, keypath, ractive ) ) {
						wrapped = this.wrapped[ keypath ] = adaptor.wrap( ractive, value, keypath, getPrefixer( keypath ) );
						wrapped.value = value;
						return value;
					}
				}
				if ( ractive.magic ) {
					if ( magicArrayAdaptor.filter( value, keypath, ractive ) ) {
						this.wrapped[ keypath ] = magicArrayAdaptor.wrap( ractive, value, keypath );
					} else if ( magicAdaptor.filter( value, keypath, ractive ) ) {
						this.wrapped[ keypath ] = magicAdaptor.wrap( ractive, value, keypath );
					}
				} else if ( ractive.modifyArrays && arrayAdaptor.filter( value, keypath, ractive ) ) {
					this.wrapped[ keypath ] = arrayAdaptor.wrap( ractive, value, keypath );
				}
				return value;
			};
	
			function prefixKeypath( obj, prefix ) {
				var prefixed = {},
					key;
				if ( !prefix ) {
					return obj;
				}
				prefix += '.';
				for ( key in obj ) {
					if ( obj.hasOwnProperty( key ) ) {
						prefixed[ prefix + key ] = obj[ key ];
					}
				}
				return prefixed;
			}
	
			function getPrefixer( rootKeypath ) {
				var rootDot;
				if ( !prefixers[ rootKeypath ] ) {
					rootDot = rootKeypath ? rootKeypath + '.' : '';
					prefixers[ rootKeypath ] = function( relativeKeypath, value ) {
						var obj;
						if ( typeof relativeKeypath === 'string' ) {
							obj = {};
							obj[ rootDot + relativeKeypath ] = value;
							return obj;
						}
						if ( typeof relativeKeypath === 'object' ) {
							// 'relativeKeypath' is in fact a hash, not a keypath
							return rootDot ? prefixKeypath( relativeKeypath, rootKeypath ) : relativeKeypath;
						}
					};
				}
				return prefixers[ rootKeypath ];
			}
			return __export;
		}( config, viewmodel$get_arrayAdaptor, log, viewmodel$get_magicAdaptor, viewmodel$get_magicArrayAdaptor );
	
		/* viewmodel/helpers/getUpstreamChanges.js */
		var getUpstreamChanges = function getUpstreamChanges( changes ) {
			var upstreamChanges = [ '' ],
				i, keypath, keys, upstreamKeypath;
			i = changes.length;
			while ( i-- ) {
				keypath = changes[ i ];
				keys = keypath.split( '.' );
				while ( keys.length > 1 ) {
					keys.pop();
					upstreamKeypath = keys.join( '.' );
					if ( upstreamChanges.indexOf( upstreamKeypath ) === -1 ) {
						upstreamChanges.push( upstreamKeypath );
					}
				}
			}
			return upstreamChanges;
		};
	
		/* viewmodel/prototype/applyChanges/getPotentialWildcardMatches.js */
		var viewmodel$applyChanges_getPotentialWildcardMatches = function() {
	
			var __export;
			var starMaps = {};
			// This function takes a keypath such as 'foo.bar.baz', and returns
			// all the variants of that keypath that include a wildcard in place
			// of a key, such as 'foo.bar.*', 'foo.*.baz', 'foo.*.*' and so on.
			// These are then checked against the dependants map (ractive.viewmodel.depsMap)
			// to see if any pattern observers are downstream of one or more of
			// these wildcard keypaths (e.g. 'foo.bar.*.status')
			__export = function getPotentialWildcardMatches( keypath ) {
				var keys, starMap, mapper, result;
				keys = keypath.split( '.' );
				starMap = getStarMap( keys.length );
				mapper = function( star, i ) {
					return star ? '*' : keys[ i ];
				};
				result = starMap.map( function( mask ) {
					return mask.map( mapper ).join( '.' );
				} );
				return result;
			};
			// This function returns all the possible true/false combinations for
			// a given number - e.g. for two, the possible combinations are
			// [ true, true ], [ true, false ], [ false, true ], [ false, false ].
			// It does so by getting all the binary values between 0 and e.g. 11
			function getStarMap( length ) {
				var ones = '',
					max, binary, starMap, mapper, i;
				if ( !starMaps[ length ] ) {
					starMap = [];
					while ( ones.length < length ) {
						ones += 1;
					}
					max = parseInt( ones, 2 );
					mapper = function( digit ) {
						return digit === '1';
					};
					for ( i = 0; i <= max; i += 1 ) {
						binary = i.toString( 2 );
						while ( binary.length < length ) {
							binary = '0' + binary;
						}
						starMap[ i ] = Array.prototype.map.call( binary, mapper );
					}
					starMaps[ length ] = starMap;
				}
				return starMaps[ length ];
			}
			return __export;
		}();
	
		/* viewmodel/prototype/applyChanges/notifyPatternObservers.js */
		var viewmodel$applyChanges_notifyPatternObservers = function( getPotentialWildcardMatches ) {
	
			var __export;
			var lastKey = /[^\.]+$/;
			__export = notifyPatternObservers;
	
			function notifyPatternObservers( viewmodel, keypath, onlyDirect ) {
				var potentialWildcardMatches;
				updateMatchingPatternObservers( viewmodel, keypath );
				if ( onlyDirect ) {
					return;
				}
				potentialWildcardMatches = getPotentialWildcardMatches( keypath );
				potentialWildcardMatches.forEach( function( upstreamPattern ) {
					cascade( viewmodel, upstreamPattern, keypath );
				} );
			}
	
			function cascade( viewmodel, upstreamPattern, keypath ) {
				var group, map, actualChildKeypath;
				group = viewmodel.depsMap.patternObservers;
				map = group[ upstreamPattern ];
				if ( map ) {
					map.forEach( function( childKeypath ) {
						var key = lastKey.exec( childKeypath )[ 0 ];
						// 'baz'
						actualChildKeypath = keypath ? keypath + '.' + key : key;
						// 'foo.bar.baz'
						updateMatchingPatternObservers( viewmodel, actualChildKeypath );
						cascade( viewmodel, childKeypath, actualChildKeypath );
					} );
				}
			}
	
			function updateMatchingPatternObservers( viewmodel, keypath ) {
				viewmodel.patternObservers.forEach( function( observer ) {
					if ( observer.regex.test( keypath ) ) {
						observer.update( keypath );
					}
				} );
			}
			return __export;
		}( viewmodel$applyChanges_getPotentialWildcardMatches );
	
		/* viewmodel/prototype/applyChanges.js */
		var viewmodel$applyChanges = function( getUpstreamChanges, notifyPatternObservers ) {
	
			var __export;
			__export = function Viewmodel$applyChanges() {
				var this$0 = this;
				var self = this,
					changes, upstreamChanges, hash = {};
				changes = this.changes;
				if ( !changes.length ) {
					// TODO we end up here on initial render. Perhaps we shouldn't?
					return;
				}
	
				function cascade( keypath ) {
					var map, dependants, keys;
					if ( self.noCascade.hasOwnProperty( keypath ) ) {
						return;
					}
					if ( dependants = self.deps.computed[ keypath ] ) {
						dependants.forEach( invalidate );
						keys = dependants.map( getKey );
						keys.forEach( mark );
						keys.forEach( cascade );
					}
					if ( map = self.depsMap.computed[ keypath ] ) {
						map.forEach( cascade );
					}
				}
	
				function mark( keypath ) {
					self.mark( keypath );
				}
				changes.forEach( cascade );
				upstreamChanges = getUpstreamChanges( changes );
				upstreamChanges.forEach( function( keypath ) {
					var dependants, keys;
					if ( dependants = self.deps.computed[ keypath ] ) {
						dependants.forEach( invalidate );
						keys = dependants.map( getKey );
						keys.forEach( mark );
						keys.forEach( cascade );
					}
				} );
				this.changes = [];
				// Pattern observers are a weird special case
				if ( this.patternObservers.length ) {
					upstreamChanges.forEach( function( keypath ) {
						return notifyPatternObservers( this$0, keypath, true );
					} );
					changes.forEach( function( keypath ) {
						return notifyPatternObservers( this$0, keypath );
					} );
				}
				if ( this.deps.observers ) {
					upstreamChanges.forEach( function( keypath ) {
						return notifyUpstreamDependants( this$0, null, keypath, 'observers' );
					} );
					notifyAllDependants( this, changes, 'observers' );
				}
				if ( this.deps[ 'default' ] ) {
					var bindings = [];
					upstreamChanges.forEach( function( keypath ) {
						return notifyUpstreamDependants( this$0, bindings, keypath, 'default' );
					} );
					if ( bindings.length ) {
						notifyBindings( this, bindings, changes );
					}
					notifyAllDependants( this, changes, 'default' );
				}
				// Return a hash of keypaths to updated values
				changes.forEach( function( keypath ) {
					hash[ keypath ] = this$0.get( keypath );
				} );
				this.implicitChanges = {};
				this.noCascade = {};
				return hash;
			};
	
			function invalidate( computation ) {
				computation.invalidate();
			}
	
			function getKey( computation ) {
				return computation.key;
			}
	
			function notifyUpstreamDependants( viewmodel, bindings, keypath, groupName ) {
				var dependants, value;
				if ( dependants = findDependants( viewmodel, keypath, groupName ) ) {
					value = viewmodel.get( keypath );
					dependants.forEach( function( d ) {
						// don't "set" the parent value, refine it
						// i.e. not data = value, but data[foo] = fooValue
						if ( bindings && d.refineValue ) {
							bindings.push( d );
						} else {
							d.setValue( value );
						}
					} );
				}
			}
	
			function notifyBindings( viewmodel, bindings, changes ) {
				bindings.forEach( function( binding ) {
					var useSet = false,
						i = 0,
						length = changes.length,
						refinements = [];
					while ( i < length ) {
						var keypath = changes[ i ];
						if ( keypath === binding.keypath ) {
							useSet = true;
							break;
						}
						if ( keypath.slice( 0, binding.keypath.length ) === binding.keypath ) {
							refinements.push( keypath );
						}
						i++;
					}
					if ( useSet ) {
						binding.setValue( viewmodel.get( binding.keypath ) );
					}
					if ( refinements.length ) {
						binding.refineValue( refinements );
					}
				} );
			}
	
			function notifyAllDependants( viewmodel, keypaths, groupName ) {
				var queue = [];
				addKeypaths( keypaths );
				queue.forEach( dispatch );
	
				function addKeypaths( keypaths ) {
					keypaths.forEach( addKeypath );
					keypaths.forEach( cascade );
				}
	
				function addKeypath( keypath ) {
					var deps = findDependants( viewmodel, keypath, groupName );
					if ( deps ) {
						queue.push( {
							keypath: keypath,
							deps: deps
						} );
					}
				}
	
				function cascade( keypath ) {
					var childDeps;
					if ( childDeps = viewmodel.depsMap[ groupName ][ keypath ] ) {
						addKeypaths( childDeps );
					}
				}
	
				function dispatch( set ) {
					var value = viewmodel.get( set.keypath );
					set.deps.forEach( function( d ) {
						return d.setValue( value );
					} );
				}
			}
	
			function findDependants( viewmodel, keypath, groupName ) {
				var group = viewmodel.deps[ groupName ];
				return group ? group[ keypath ] : null;
			}
			return __export;
		}( getUpstreamChanges, viewmodel$applyChanges_notifyPatternObservers );
	
		/* viewmodel/prototype/capture.js */
		var viewmodel$capture = function Viewmodel$capture() {
			this.captureGroups.push( [] );
		};
	
		/* viewmodel/prototype/clearCache.js */
		var viewmodel$clearCache = function Viewmodel$clearCache( keypath, dontTeardownWrapper ) {
			var cacheMap, wrapper;
			if ( !dontTeardownWrapper ) {
				// Is there a wrapped property at this keypath?
				if ( wrapper = this.wrapped[ keypath ] ) {
					// Did we unwrap it?
					if ( wrapper.teardown() !== false ) {
						// Is this right?
						// What's the meaning of returning false from teardown?
						// Could there be a GC ramification if this is a "real" ractive.teardown()?
						this.wrapped[ keypath ] = null;
					}
				}
			}
			this.cache[ keypath ] = undefined;
			if ( cacheMap = this.cacheMap[ keypath ] ) {
				while ( cacheMap.length ) {
					this.clearCache( cacheMap.pop() );
				}
			}
		};
	
		/* viewmodel/Computation/getComputationSignature.js */
		var getComputationSignature = function() {
	
			var __export;
			var pattern = /\$\{([^\}]+)\}/g;
			__export = function( signature ) {
				if ( typeof signature === 'function' ) {
					return {
						get: signature
					};
				}
				if ( typeof signature === 'string' ) {
					return {
						get: createFunctionFromString( signature )
					};
				}
				if ( typeof signature === 'object' && typeof signature.get === 'string' ) {
					signature = {
						get: createFunctionFromString( signature.get ),
						set: signature.set
					};
				}
				return signature;
			};
	
			function createFunctionFromString( signature ) {
				var functionBody = 'var __ractive=this;return(' + signature.replace( pattern, function( match, keypath ) {
					return '__ractive.get("' + keypath + '")';
				} ) + ')';
				return new Function( functionBody );
			}
			return __export;
		}();
	
		/* viewmodel/Computation/Computation.js */
		var Computation = function( log, isEqual ) {
	
			var Computation = function( ractive, key, signature ) {
				var this$0 = this;
				this.ractive = ractive;
				this.viewmodel = ractive.viewmodel;
				this.key = key;
				this.getter = signature.get;
				this.setter = signature.set;
				this.hardDeps = signature.deps || [];
				this.softDeps = [];
				this.depValues = {};
				if ( this.hardDeps ) {
					this.hardDeps.forEach( function( d ) {
						return ractive.viewmodel.register( d, this$0, 'computed' );
					} );
				}
				this._dirty = this._firstRun = true;
			};
			Computation.prototype = {
				constructor: Computation,
				init: function() {
					var initial;
					this.bypass = true;
					initial = this.ractive.viewmodel.get( this.key );
					this.ractive.viewmodel.clearCache( this.key );
					this.bypass = false;
					if ( this.setter && initial !== undefined ) {
						this.set( initial );
					}
				},
				invalidate: function() {
					this._dirty = true;
				},
				get: function() {
					var this$0 = this;
					var ractive, newDeps, dependenciesChanged, dependencyValuesChanged = false;
					if ( this.getting ) {
						// prevent double-computation (e.g. caused by array mutation inside computation)
						return;
					}
					this.getting = true;
					if ( this._dirty ) {
						ractive = this.ractive;
						// determine whether the inputs have changed, in case this depends on
						// other computed values
						if ( this._firstRun || !this.hardDeps.length && !this.softDeps.length ) {
							dependencyValuesChanged = true;
						} else {
							[
								this.hardDeps,
								this.softDeps
							].forEach( function( deps ) {
								var keypath, value, i;
								if ( dependencyValuesChanged ) {
									return;
								}
								i = deps.length;
								while ( i-- ) {
									keypath = deps[ i ];
									value = ractive.viewmodel.get( keypath );
									if ( !isEqual( value, this$0.depValues[ keypath ] ) ) {
										this$0.depValues[ keypath ] = value;
										dependencyValuesChanged = true;
										return;
									}
								}
							} );
						}
						if ( dependencyValuesChanged ) {
							ractive.viewmodel.capture();
							try {
								this.value = this.getter.call( ractive );
							} catch ( err ) {
								log.warn( {
									debug: ractive.debug,
									message: 'failedComputation',
									args: {
										key: this.key,
										err: err.message || err
									}
								} );
								this.value = void 0;
							}
							newDeps = ractive.viewmodel.release();
							dependenciesChanged = this.updateDependencies( newDeps );
							if ( dependenciesChanged ) {
								[
									this.hardDeps,
									this.softDeps
								].forEach( function( deps ) {
									deps.forEach( function( keypath ) {
										this$0.depValues[ keypath ] = ractive.viewmodel.get( keypath );
									} );
								} );
							}
						}
						this._dirty = false;
					}
					this.getting = this._firstRun = false;
					return this.value;
				},
				set: function( value ) {
					if ( this.setting ) {
						this.value = value;
						return;
					}
					if ( !this.setter ) {
						throw new Error( 'Computed properties without setters are read-only. (This may change in a future version of Ractive!)' );
					}
					this.setter.call( this.ractive, value );
				},
				updateDependencies: function( newDeps ) {
					var i, oldDeps, keypath, dependenciesChanged;
					oldDeps = this.softDeps;
					// remove dependencies that are no longer used
					i = oldDeps.length;
					while ( i-- ) {
						keypath = oldDeps[ i ];
						if ( newDeps.indexOf( keypath ) === -1 ) {
							dependenciesChanged = true;
							this.viewmodel.unregister( keypath, this, 'computed' );
						}
					}
					// create references for any new dependencies
					i = newDeps.length;
					while ( i-- ) {
						keypath = newDeps[ i ];
						if ( oldDeps.indexOf( keypath ) === -1 && ( !this.hardDeps || this.hardDeps.indexOf( keypath ) === -1 ) ) {
							dependenciesChanged = true;
							this.viewmodel.register( keypath, this, 'computed' );
						}
					}
					if ( dependenciesChanged ) {
						this.softDeps = newDeps.slice();
					}
					return dependenciesChanged;
				}
			};
			return Computation;
		}( log, isEqual );
	
		/* viewmodel/prototype/compute.js */
		var viewmodel$compute = function( getComputationSignature, Computation ) {
	
			return function Viewmodel$compute( key, signature ) {
				signature = getComputationSignature( signature );
				return this.computations[ key ] = new Computation( this.ractive, key, signature );
			};
		}( getComputationSignature, Computation );
	
		/* viewmodel/prototype/get/FAILED_LOOKUP.js */
		var viewmodel$get_FAILED_LOOKUP = {
			FAILED_LOOKUP: true
		};
	
		/* viewmodel/prototype/get/UnresolvedImplicitDependency.js */
		var viewmodel$get_UnresolvedImplicitDependency = function( removeFromArray, runloop ) {
	
			var empty = {};
			var UnresolvedImplicitDependency = function( viewmodel, keypath ) {
				this.viewmodel = viewmodel;
				this.root = viewmodel.ractive;
				// TODO eliminate this
				this.ref = keypath;
				this.parentFragment = empty;
				viewmodel.unresolvedImplicitDependencies[ keypath ] = true;
				viewmodel.unresolvedImplicitDependencies.push( this );
				runloop.addUnresolved( this );
			};
			UnresolvedImplicitDependency.prototype = {
				resolve: function() {
					this.viewmodel.mark( this.ref );
					this.viewmodel.unresolvedImplicitDependencies[ this.ref ] = false;
					removeFromArray( this.viewmodel.unresolvedImplicitDependencies, this );
				},
				teardown: function() {
					runloop.removeUnresolved( this );
				}
			};
			return UnresolvedImplicitDependency;
		}( removeFromArray, runloop );
	
		/* viewmodel/prototype/get.js */
		var viewmodel$get = function( isNumeric, FAILED_LOOKUP, UnresolvedImplicitDependency ) {
	
			var __export;
			var empty = {};
			__export = function Viewmodel$get( keypath ) {
				var options = arguments[ 1 ];
				if ( options === void 0 )
					options = empty;
				var ractive = this.ractive,
					cache = this.cache,
					value, computation, wrapped, captureGroup;
				if ( keypath[ 0 ] === '@' ) {
					value = keypath.slice( 1 );
					return isNumeric( value ) ? +value : value;
				}
				if ( cache[ keypath ] === undefined ) {
					// Is this a computed property?
					if ( ( computation = this.computations[ keypath ] ) && !computation.bypass ) {
						value = computation.get();
						this.adapt( keypath, value );
					} else if ( wrapped = this.wrapped[ keypath ] ) {
						value = wrapped.value;
					} else if ( !keypath ) {
						this.adapt( '', ractive.data );
						value = ractive.data;
					} else {
						value = retrieve( this, keypath );
					}
					cache[ keypath ] = value;
				} else {
					value = cache[ keypath ];
				}
				if ( options.evaluateWrapped && ( wrapped = this.wrapped[ keypath ] ) ) {
					value = wrapped.get();
				}
				// capture the keypath, if we're inside a computation
				if ( options.capture && ( captureGroup = this.captureGroups[ this.captureGroups.length - 1 ] ) ) {
					if ( !~captureGroup.indexOf( keypath ) ) {
						captureGroup.push( keypath );
						// if we couldn't resolve the keypath, we need to make it as a failed
						// lookup, so that the computation updates correctly once we CAN
						// resolve the keypath
						if ( value === FAILED_LOOKUP && this.unresolvedImplicitDependencies[ keypath ] !== true ) {
							new UnresolvedImplicitDependency( this, keypath );
						}
					}
				}
				return value === FAILED_LOOKUP ? void 0 : value;
			};
	
			function retrieve( viewmodel, keypath ) {
				var keys, key, parentKeypath, parentValue, cacheMap, value, wrapped;
				keys = keypath.split( '.' );
				key = keys.pop();
				parentKeypath = keys.join( '.' );
				parentValue = viewmodel.get( parentKeypath );
				if ( wrapped = viewmodel.wrapped[ parentKeypath ] ) {
					parentValue = wrapped.get();
				}
				if ( parentValue === null || parentValue === undefined ) {
					return;
				}
				// update cache map
				if ( !( cacheMap = viewmodel.cacheMap[ parentKeypath ] ) ) {
					viewmodel.cacheMap[ parentKeypath ] = [ keypath ];
				} else {
					if ( cacheMap.indexOf( keypath ) === -1 ) {
						cacheMap.push( keypath );
					}
				}
				// If this property doesn't exist, we return a sentinel value
				// so that we know to query parent scope (if such there be)
				if ( typeof parentValue === 'object' && !( key in parentValue ) ) {
					return viewmodel.cache[ keypath ] = FAILED_LOOKUP;
				}
				value = parentValue[ key ];
				// Do we have an adaptor for this value?
				viewmodel.adapt( keypath, value, false );
				// Update cache
				viewmodel.cache[ keypath ] = value;
				return value;
			}
			return __export;
		}( isNumeric, viewmodel$get_FAILED_LOOKUP, viewmodel$get_UnresolvedImplicitDependency );
	
		/* viewmodel/prototype/init.js */
		var viewmodel$init = function() {
	
			var __export;
			__export = function Viewmodel$init() {
				var key, computation, computations = [];
				for ( key in this.ractive.computed ) {
					computation = this.compute( key, this.ractive.computed[ key ] );
					computations.push( computation );
				}
				computations.forEach( init );
			};
	
			function init( computation ) {
				computation.init();
			}
			return __export;
		}();
	
		/* viewmodel/prototype/mark.js */
		var viewmodel$mark = function Viewmodel$mark( keypath, options ) {
			var computation;
			// implicit changes (i.e. `foo.length` on `ractive.push('foo',42)`)
			// should not be picked up by pattern observers
			if ( options ) {
				if ( options.implicit ) {
					this.implicitChanges[ keypath ] = true;
				}
				if ( options.noCascade ) {
					this.noCascade[ keypath ] = true;
				}
			}
			if ( computation = this.computations[ keypath ] ) {
				computation.invalidate();
			}
			if ( this.changes.indexOf( keypath ) === -1 ) {
				this.changes.push( keypath );
			}
			this.clearCache( keypath );
		};
	
		/* viewmodel/prototype/merge/mapOldToNewIndex.js */
		var viewmodel$merge_mapOldToNewIndex = function( oldArray, newArray ) {
			var usedIndices, firstUnusedIndex, newIndices, changed;
			usedIndices = {};
			firstUnusedIndex = 0;
			newIndices = oldArray.map( function( item, i ) {
				var index, start, len;
				start = firstUnusedIndex;
				len = newArray.length;
				do {
					index = newArray.indexOf( item, start );
					if ( index === -1 ) {
						changed = true;
						return -1;
					}
					start = index + 1;
				} while ( usedIndices[ index ] && start < len );
				// keep track of the first unused index, so we don't search
				// the whole of newArray for each item in oldArray unnecessarily
				if ( index === firstUnusedIndex ) {
					firstUnusedIndex += 1;
				}
				if ( index !== i ) {
					changed = true;
				}
				usedIndices[ index ] = true;
				return index;
			} );
			return newIndices;
		};
	
		/* viewmodel/prototype/merge.js */
		var viewmodel$merge = function( warn, mapOldToNewIndex ) {
	
			var __export;
			var comparators = {};
			__export = function Viewmodel$merge( keypath, currentArray, array, options ) {
				var oldArray, newArray, comparator, newIndices;
				this.mark( keypath );
				if ( options && options.compare ) {
					comparator = getComparatorFunction( options.compare );
					try {
						oldArray = currentArray.map( comparator );
						newArray = array.map( comparator );
					} catch ( err ) {
						// fallback to an identity check - worst case scenario we have
						// to do more DOM manipulation than we thought...
						// ...unless we're in debug mode of course
						if ( this.debug ) {
							throw err;
						} else {
							warn( 'Merge operation: comparison failed. Falling back to identity checking' );
						}
						oldArray = currentArray;
						newArray = array;
					}
				} else {
					oldArray = currentArray;
					newArray = array;
				}
				// find new indices for members of oldArray
				newIndices = mapOldToNewIndex( oldArray, newArray );
				this.smartUpdate( keypath, array, newIndices, currentArray.length !== array.length );
			};
	
			function stringify( item ) {
				return JSON.stringify( item );
			}
	
			function getComparatorFunction( comparator ) {
				// If `compare` is `true`, we use JSON.stringify to compare
				// objects that are the same shape, but non-identical - i.e.
				// { foo: 'bar' } !== { foo: 'bar' }
				if ( comparator === true ) {
					return stringify;
				}
				if ( typeof comparator === 'string' ) {
					if ( !comparators[ comparator ] ) {
						comparators[ comparator ] = function( item ) {
							return item[ comparator ];
						};
					}
					return comparators[ comparator ];
				}
				if ( typeof comparator === 'function' ) {
					return comparator;
				}
				throw new Error( 'The `compare` option must be a function, or a string representing an identifying field (or `true` to use JSON.stringify)' );
			}
			return __export;
		}( warn, viewmodel$merge_mapOldToNewIndex );
	
		/* viewmodel/prototype/register.js */
		var viewmodel$register = function() {
	
			var __export;
			__export = function Viewmodel$register( keypath, dependant ) {
				var group = arguments[ 2 ];
				if ( group === void 0 )
					group = 'default';
				var depsByKeypath, deps;
				if ( dependant.isStatic ) {
					return;
				}
				depsByKeypath = this.deps[ group ] || ( this.deps[ group ] = {} );
				deps = depsByKeypath[ keypath ] || ( depsByKeypath[ keypath ] = [] );
				deps.push( dependant );
				if ( !keypath ) {
					return;
				}
				updateDependantsMap( this, keypath, group );
			};
	
			function updateDependantsMap( viewmodel, keypath, group ) {
				var keys, parentKeypath, map, parent;
				// update dependants map
				keys = keypath.split( '.' );
				while ( keys.length ) {
					keys.pop();
					parentKeypath = keys.join( '.' );
					map = viewmodel.depsMap[ group ] || ( viewmodel.depsMap[ group ] = {} );
					parent = map[ parentKeypath ] || ( map[ parentKeypath ] = [] );
					if ( parent[ keypath ] === undefined ) {
						parent[ keypath ] = 0;
						parent.push( keypath );
					}
					parent[ keypath ] += 1;
					keypath = parentKeypath;
				}
			}
			return __export;
		}();
	
		/* viewmodel/prototype/release.js */
		var viewmodel$release = function Viewmodel$release() {
			return this.captureGroups.pop();
		};
	
		/* viewmodel/prototype/set.js */
		var viewmodel$set = function( isEqual, createBranch ) {
	
			var __export;
			__export = function Viewmodel$set( keypath, value, silent ) {
				var computation, wrapper, dontTeardownWrapper;
				computation = this.computations[ keypath ];
				if ( computation ) {
					if ( computation.setting ) {
						// let the other computation set() handle things...
						return;
					}
					computation.set( value );
					value = computation.get();
				}
				if ( isEqual( this.cache[ keypath ], value ) ) {
					return;
				}
				wrapper = this.wrapped[ keypath ];
				// If we have a wrapper with a `reset()` method, we try and use it. If the
				// `reset()` method returns false, the wrapper should be torn down, and
				// (most likely) a new one should be created later
				if ( wrapper && wrapper.reset ) {
					dontTeardownWrapper = wrapper.reset( value ) !== false;
					if ( dontTeardownWrapper ) {
						value = wrapper.get();
					}
				}
				if ( !computation && !dontTeardownWrapper ) {
					resolveSet( this, keypath, value );
				}
				if ( !silent ) {
					this.mark( keypath );
				} else {
					// We're setting a parent of the original target keypath (i.e.
					// creating a fresh branch) - we need to clear the cache, but
					// not mark it as a change
					this.clearCache( keypath );
				}
			};
	
			function resolveSet( viewmodel, keypath, value ) {
				var keys, lastKey, parentKeypath, wrapper, parentValue, wrapperSet, valueSet;
				wrapperSet = function() {
					if ( wrapper.set ) {
						wrapper.set( lastKey, value );
					} else {
						parentValue = wrapper.get();
						valueSet();
					}
				};
				valueSet = function() {
					if ( !parentValue ) {
						parentValue = createBranch( lastKey );
						viewmodel.set( parentKeypath, parentValue, true );
					}
					parentValue[ lastKey ] = value;
				};
				keys = keypath.split( '.' );
				lastKey = keys.pop();
				parentKeypath = keys.join( '.' );
				wrapper = viewmodel.wrapped[ parentKeypath ];
				if ( wrapper ) {
					wrapperSet();
				} else {
					parentValue = viewmodel.get( parentKeypath );
					// may have been wrapped via the above .get()
					// call on viewmodel if this is first access via .set()!
					if ( wrapper = viewmodel.wrapped[ parentKeypath ] ) {
						wrapperSet();
					} else {
						valueSet();
					}
				}
			}
			return __export;
		}( isEqual, createBranch );
	
		/* viewmodel/prototype/smartUpdate.js */
		var viewmodel$smartUpdate = function() {
	
			var __export;
			var implicitOption = {
					implicit: true
				},
				noCascadeOption = {
					noCascade: true
				};
			__export = function Viewmodel$smartUpdate( keypath, array, newIndices ) {
				var this$0 = this;
				var dependants, oldLength;
				oldLength = newIndices.length;
				// Indices that are being removed should be marked as dirty
				newIndices.forEach( function( newIndex, oldIndex ) {
					if ( newIndex === -1 ) {
						this$0.mark( keypath + '.' + oldIndex, noCascadeOption );
					}
				} );
				// Update the model
				// TODO allow existing array to be updated in place, rather than replaced?
				this.set( keypath, array, true );
				if ( dependants = this.deps[ 'default' ][ keypath ] ) {
					dependants.filter( canShuffle ).forEach( function( d ) {
						return d.shuffle( newIndices, array );
					} );
				}
				if ( oldLength !== array.length ) {
					this.mark( keypath + '.length', implicitOption );
					for ( var i = oldLength; i < array.length; i += 1 ) {
						this.mark( keypath + '.' + i );
					}
					// don't allow removed indexes beyond end of new array to trigger recomputations
					for ( var i$0 = array.length; i$0 < oldLength; i$0 += 1 ) {
						this.mark( keypath + '.' + i$0, noCascadeOption );
					}
				}
			};
	
			function canShuffle( dependant ) {
				return typeof dependant.shuffle === 'function';
			}
			return __export;
		}();
	
		/* viewmodel/prototype/teardown.js */
		var viewmodel$teardown = function Viewmodel$teardown() {
			var this$0 = this;
			var unresolvedImplicitDependency;
			// Clear entire cache - this has the desired side-effect
			// of unwrapping adapted values (e.g. arrays)
			Object.keys( this.cache ).forEach( function( keypath ) {
				return this$0.clearCache( keypath );
			} );
			// Teardown any failed lookups - we don't need them to resolve any more
			while ( unresolvedImplicitDependency = this.unresolvedImplicitDependencies.pop() ) {
				unresolvedImplicitDependency.teardown();
			}
		};
	
		/* viewmodel/prototype/unregister.js */
		var viewmodel$unregister = function() {
	
			var __export;
			__export = function Viewmodel$unregister( keypath, dependant ) {
				var group = arguments[ 2 ];
				if ( group === void 0 )
					group = 'default';
				var deps, index;
				if ( dependant.isStatic ) {
					return;
				}
				deps = this.deps[ group ][ keypath ];
				index = deps.indexOf( dependant );
				if ( index === -1 ) {
					throw new Error( 'Attempted to remove a dependant that was no longer registered! This should not happen. If you are seeing this bug in development please raise an issue at https://github.com/RactiveJS/Ractive/issues - thanks' );
				}
				deps.splice( index, 1 );
				if ( !keypath ) {
					return;
				}
				updateDependantsMap( this, keypath, group );
			};
	
			function updateDependantsMap( viewmodel, keypath, group ) {
				var keys, parentKeypath, map, parent;
				// update dependants map
				keys = keypath.split( '.' );
				while ( keys.length ) {
					keys.pop();
					parentKeypath = keys.join( '.' );
					map = viewmodel.depsMap[ group ];
					parent = map[ parentKeypath ];
					parent[ keypath ] -= 1;
					if ( !parent[ keypath ] ) {
						// remove from parent deps map
						parent.splice( parent.indexOf( keypath ), 1 );
						parent[ keypath ] = undefined;
					}
					keypath = parentKeypath;
				}
			}
			return __export;
		}();
	
		/* viewmodel/adaptConfig.js */
		var adaptConfig = function() {
	
			// should this be combined with prototype/adapt.js?
			var configure = {
				lookup: function( target, adaptors ) {
					var i, adapt = target.adapt;
					if ( !adapt || !adapt.length ) {
						return adapt;
					}
					if ( adaptors && Object.keys( adaptors ).length && ( i = adapt.length ) ) {
						while ( i-- ) {
							var adaptor = adapt[ i ];
							if ( typeof adaptor === 'string' ) {
								adapt[ i ] = adaptors[ adaptor ] || adaptor;
							}
						}
					}
					return adapt;
				},
				combine: function( parent, adapt ) {
					// normalize 'Foo' to [ 'Foo' ]
					parent = arrayIfString( parent );
					adapt = arrayIfString( adapt );
					// no parent? return adapt
					if ( !parent || !parent.length ) {
						return adapt;
					}
					// no adapt? return 'copy' of parent
					if ( !adapt || !adapt.length ) {
						return parent.slice();
					}
					// add parent adaptors to options
					parent.forEach( function( a ) {
						// don't put in duplicates
						if ( adapt.indexOf( a ) === -1 ) {
							adapt.push( a );
						}
					} );
					return adapt;
				}
			};
	
			function arrayIfString( adapt ) {
				if ( typeof adapt === 'string' ) {
					adapt = [ adapt ];
				}
				return adapt;
			}
			return configure;
		}();
	
		/* viewmodel/Viewmodel.js */
		var Viewmodel = function( create, adapt, applyChanges, capture, clearCache, compute, get, init, mark, merge, register, release, set, smartUpdate, teardown, unregister, adaptConfig ) {
	
			var noMagic;
			try {
				Object.defineProperty( {}, 'test', {
					value: 0
				} );
			} catch ( err ) {
				noMagic = true;
			}
			var Viewmodel = function( ractive ) {
				this.ractive = ractive;
				// TODO eventually, we shouldn't need this reference
				Viewmodel.extend( ractive.constructor, ractive );
				this.cache = {};
				// we need to be able to use hasOwnProperty, so can't inherit from null
				this.cacheMap = create( null );
				this.deps = {
					computed: {},
					'default': {}
				};
				this.depsMap = {
					computed: {},
					'default': {}
				};
				this.patternObservers = [];
				this.wrapped = create( null );
				this.computations = create( null );
				this.captureGroups = [];
				this.unresolvedImplicitDependencies = [];
				this.changes = [];
				this.implicitChanges = {};
				this.noCascade = {};
			};
			Viewmodel.extend = function( Parent, instance ) {
				if ( instance.magic && noMagic ) {
					throw new Error( 'Getters and setters (magic mode) are not supported in this browser' );
				}
				instance.adapt = adaptConfig.combine( Parent.prototype.adapt, instance.adapt ) || [];
				instance.adapt = adaptConfig.lookup( instance, instance.adaptors );
			};
			Viewmodel.prototype = {
				adapt: adapt,
				applyChanges: applyChanges,
				capture: capture,
				clearCache: clearCache,
				compute: compute,
				get: get,
				init: init,
				mark: mark,
				merge: merge,
				register: register,
				release: release,
				set: set,
				smartUpdate: smartUpdate,
				teardown: teardown,
				unregister: unregister
			};
			return Viewmodel;
		}( create, viewmodel$adapt, viewmodel$applyChanges, viewmodel$capture, viewmodel$clearCache, viewmodel$compute, viewmodel$get, viewmodel$init, viewmodel$mark, viewmodel$merge, viewmodel$register, viewmodel$release, viewmodel$set, viewmodel$smartUpdate, viewmodel$teardown, viewmodel$unregister, adaptConfig );
	
		/* Ractive/initialise.js */
		var Ractive_initialise = function( config, create, Fragment, getElement, getNextNumber, Hook, HookQueue, Viewmodel ) {
	
			var __export;
			var constructHook = new Hook( 'construct' ),
				configHook = new Hook( 'config' ),
				initHook = new HookQueue( 'init' );
			__export = function initialiseRactiveInstance( ractive ) {
				var options = arguments[ 1 ];
				if ( options === void 0 )
					options = {};
				var el;
				initialiseProperties( ractive, options );
				// make this option do what would be expected if someone
				// did include it on a new Ractive() or new Component() call.
				// Silly to do so (put a hook on the very options being used),
				// but handle it correctly, consistent with the intent.
				constructHook.fire( config.getConstructTarget( ractive, options ), options );
				// init config from Parent and options
				config.init( ractive.constructor, ractive, options );
				configHook.fire( ractive );
				// Teardown any existing instances *before* trying to set up the new one -
				// avoids certain weird bugs
				if ( el = getElement( ractive.el ) ) {
					if ( !ractive.append ) {
						if ( el.__ractive_instances__ ) {
							try {
								el.__ractive_instances__.splice( 0, el.__ractive_instances__.length ).forEach( function( r ) {
									return r.teardown();
								} );
							} catch ( err ) {}
						}
						el.innerHTML = '';
					}
				}
				initHook.begin( ractive );
				// TEMPORARY. This is so we can implement Viewmodel gradually
				ractive.viewmodel = new Viewmodel( ractive );
				// hacky circular problem until we get this sorted out
				// if viewmodel immediately processes computed properties,
				// they may call ractive.get, which calls ractive.viewmodel,
				// which hasn't been set till line above finishes.
				ractive.viewmodel.init();
				// Render our *root fragment*
				if ( ractive.template ) {
					ractive.fragment = new Fragment( {
						template: ractive.template,
						root: ractive,
						owner: ractive
					} );
				}
				initHook.end( ractive );
				// render automatically ( if `el` is specified )
				if ( el ) {
					ractive.render( el, ractive.append );
				}
			};
	
			function initialiseProperties( ractive, options ) {
				// Generate a unique identifier, for places where you'd use a weak map if it
				// existed
				ractive._guid = getNextNumber();
				// events
				ractive._subs = create( null );
				// storage for item configuration from instantiation to reset,
				// like dynamic functions or original values
				ractive._config = {};
				// two-way bindings
				ractive._twowayBindings = create( null );
				// animations (so we can stop any in progress at teardown)
				ractive._animations = [];
				// nodes registry
				ractive.nodes = {};
				// live queries
				ractive._liveQueries = [];
				ractive._liveComponentQueries = [];
				// If this is a component, store a reference to the parent
				if ( options._parent && options._component ) {
					ractive._parent = options._parent;
					ractive.component = options._component;
					// And store a reference to the instance on the component
					options._component.instance = ractive;
				}
			}
			return __export;
		}( config, create, Fragment, getElement, getNextNumber, Ractive$shared_hooks_Hook, Ractive$shared_hooks_HookQueue, Viewmodel );
	
		/* extend/unwrapExtended.js */
		var unwrapExtended = function( wrap, config, circular ) {
	
			var __export;
			var Ractive;
			circular.push( function() {
				Ractive = circular.Ractive;
			} );
			__export = function unwrapExtended( Child ) {
				if ( !( Child.prototype instanceof Ractive ) ) {
					return Child;
				}
				var options = {};
				while ( Child ) {
					config.registries.forEach( function( r ) {
						addRegistry( r.useDefaults ? Child.prototype : Child, options, r.name );
					} );
					Object.keys( Child.prototype ).forEach( function( key ) {
						if ( key === 'computed' ) {
							return;
						}
						var value = Child.prototype[ key ];
						if ( !( key in options ) ) {
							options[ key ] = value._method ? value._method : value;
						} else if ( typeof options[ key ] === 'function' && typeof value === 'function' && options[ key ]._method ) {
							var result, needsSuper = value._method;
							if ( needsSuper ) {
								value = value._method;
							}
							// rewrap bound directly to parent fn
							result = wrap( options[ key ]._method, value );
							if ( needsSuper ) {
								result._method = result;
							}
							options[ key ] = result;
						}
					} );
					if ( Child._parent !== Ractive ) {
						Child = Child._parent;
					} else {
						Child = false;
					}
				}
				return options;
			};
	
			function addRegistry( target, options, name ) {
				var registry, keys = Object.keys( target[ name ] );
				if ( !keys.length ) {
					return;
				}
				if ( !( registry = options[ name ] ) ) {
					registry = options[ name ] = {};
				}
				keys.filter( function( key ) {
					return !( key in registry );
				} ).forEach( function( key ) {
					return registry[ key ] = target[ name ][ key ];
				} );
			}
			return __export;
		}( wrapMethod, config, circular );
	
		/* extend/_extend.js */
		var Ractive_extend = function( create, defineProperties, getGuid, config, initialise, Viewmodel, unwrap ) {
	
			return function extend() {
				var options = arguments[ 0 ];
				if ( options === void 0 )
					options = {};
				var Parent = this,
					Child, proto, staticProperties;
				// if we're extending with another Ractive instance, inherit its
				// prototype methods and default options as well
				options = unwrap( options );
				// create Child constructor
				Child = function( options ) {
					initialise( this, options );
				};
				proto = create( Parent.prototype );
				proto.constructor = Child;
				staticProperties = {
					// each component needs a guid, for managing CSS etc
					_guid: {
						value: getGuid()
					},
					// alias prototype as defaults
					defaults: {
						value: proto
					},
					// extendable
					extend: {
						value: extend,
						writable: true,
						configurable: true
					},
					// Parent - for IE8, can't use Object.getPrototypeOf
					_parent: {
						value: Parent
					}
				};
				defineProperties( Child, staticProperties );
				// extend configuration
				config.extend( Parent, proto, options );
				Viewmodel.extend( Parent, proto );
				Child.prototype = proto;
				return Child;
			};
		}( create, defineProperties, getGuid, config, Ractive_initialise, Viewmodel, unwrapExtended );
	
		/* Ractive.js */
		var Ractive = function( defaults, easing, interpolators, svg, magic, defineProperties, proto, Promise, extendObj, extend, parse, initialise, circular ) {
	
			var Ractive, properties;
			// Main Ractive required object
			Ractive = function( options ) {
				initialise( this, options );
			};
			// Ractive properties
			properties = {
				// static methods:
				extend: {
					value: extend
				},
				parse: {
					value: parse
				},
				// Namespaced constructors
				Promise: {
					value: Promise
				},
				// support
				svg: {
					value: svg
				},
				magic: {
					value: magic
				},
				// version
				VERSION: {
					value: '0.6.1'
				},
				// Plugins
				adaptors: {
					writable: true,
					value: {}
				},
				components: {
					writable: true,
					value: {}
				},
				decorators: {
					writable: true,
					value: {}
				},
				easing: {
					writable: true,
					value: easing
				},
				events: {
					writable: true,
					value: {}
				},
				interpolators: {
					writable: true,
					value: interpolators
				},
				partials: {
					writable: true,
					value: {}
				},
				transitions: {
					writable: true,
					value: {}
				}
			};
			// Ractive properties
			defineProperties( Ractive, properties );
			Ractive.prototype = extendObj( proto, defaults );
			Ractive.prototype.constructor = Ractive;
			// alias prototype as defaults
			Ractive.defaults = Ractive.prototype;
			// Certain modules have circular dependencies. If we were bundling a
			// module loader, e.g. almond.js, this wouldn't be a problem, but we're
			// not - we're using amdclean as part of the build process. Because of
			// this, we need to wait until all modules have loaded before those
			// circular dependencies can be required.
			circular.Ractive = Ractive;
			while ( circular.length ) {
				circular.pop()();
			}
			// Ractive.js makes liberal use of things like Array.prototype.indexOf. In
			// older browsers, these are made available via a shim - here, we do a quick
			// pre-flight check to make sure that either a) we're not in a shit browser,
			// or b) we're using a Ractive-legacy.js build
			var FUNCTION = 'function';
			if ( typeof Date.now !== FUNCTION || typeof String.prototype.trim !== FUNCTION || typeof Object.keys !== FUNCTION || typeof Array.prototype.indexOf !== FUNCTION || typeof Array.prototype.forEach !== FUNCTION || typeof Array.prototype.map !== FUNCTION || typeof Array.prototype.filter !== FUNCTION || typeof window !== 'undefined' && typeof window.addEventListener !== FUNCTION ) {
				throw new Error( 'It looks like you\'re attempting to use Ractive.js in an older browser. You\'ll need to use one of the \'legacy builds\' in order to continue - see http://docs.ractivejs.org/latest/legacy-builds for more information.' );
			}
			return Ractive;
		}( options, easing, interpolators, svg, magic, defineProperties, prototype, Promise, extend, Ractive_extend, parse, Ractive_initialise, circular );
	
	
		// export as Common JS module...
		if ( typeof module !== "undefined" && module.exports ) {
			module.exports = Ractive;
		}
	
		// ... or as AMD module
		else if ( true ) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return Ractive;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}
	
		// ... or as browser global
		global.Ractive = Ractive;
	
		Ractive.noConflict = function() {
			global.Ractive = noConflict;
			return Ractive;
		};
	
	}( typeof window !== 'undefined' ? window : this ) );


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_RESULT__;/* svg.js 1.0.1 - svg selector inventor polyfill regex default color array pointarray patharray number viewbox bbox rbox element parent container fx relative event defs group arrange mask clip gradient pattern doc shape symbol use rect ellipse line poly path image text textpath nested hyperlink marker sugar set data memory loader helpers - svgjs.com/license */
	;(function(root, factory) {
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports === 'object') {
	    module.exports = factory();
	  } else {
	    root.SVG = factory();
	  }
	}(this, function() {
	
	  var SVG = this.SVG = function(element) {
	    if (SVG.supported) {
	      element = new SVG.Doc(element)
	  
	      if (!SVG.parser)
	        SVG.prepare(element)
	  
	      return element
	    }
	  }
	  
	  // Default namespaces
	  SVG.ns    = 'http://www.w3.org/2000/svg'
	  SVG.xmlns = 'http://www.w3.org/2000/xmlns/'
	  SVG.xlink = 'http://www.w3.org/1999/xlink'
	  
	  // Element id sequence
	  SVG.did  = 1000
	  
	  // Get next named element id
	  SVG.eid = function(name) {
	    return 'Svgjs' + name.charAt(0).toUpperCase() + name.slice(1) + (SVG.did++)
	  }
	  
	  // Method for element creation
	  SVG.create = function(name) {
	    /* create element */
	    var element = document.createElementNS(this.ns, name)
	    
	    /* apply unique id */
	    element.setAttribute('id', this.eid(name))
	    
	    return element
	  }
	  
	  // Method for extending objects
	  SVG.extend = function() {
	    var modules, methods, key, i
	    
	    /* get list of modules */
	    modules = [].slice.call(arguments)
	    
	    /* get object with extensions */
	    methods = modules.pop()
	    
	    for (i = modules.length - 1; i >= 0; i--)
	      if (modules[i])
	        for (key in methods)
	          modules[i].prototype[key] = methods[key]
	  
	    /* make sure SVG.Set inherits any newly added methods */
	    if (SVG.Set && SVG.Set.inherit)
	      SVG.Set.inherit()
	  }
	  
	  // Initialize parsing element
	  SVG.prepare = function(element) {
	    /* select document body and create invisible svg element */
	    var body = document.getElementsByTagName('body')[0]
	      , draw = (body ? new SVG.Doc(body) : element.nested()).size(2, 0)
	      , path = SVG.create('path')
	  
	    /* insert parsers */
	    draw.node.appendChild(path)
	  
	    /* create parser object */
	    SVG.parser = {
	      body: body || element.parent
	    , draw: draw.style('opacity:0;position:fixed;left:100%;top:100%;overflow:hidden')
	    , poly: draw.polyline().node
	    , path: path
	    }
	  }
	  
	  // svg support test
	  SVG.supported = (function() {
	    return !! document.createElementNS &&
	           !! document.createElementNS(SVG.ns,'svg').createSVGRect
	  })()
	  
	  if (!SVG.supported) return false
	
	
	  SVG.get = function(id) {
	    var node = document.getElementById(idFromReference(id) || id)
	    if (node) return node.instance
	  }
	
	  SVG.invent = function(config) {
	  	/* create element initializer */
	  	var initializer = typeof config.create == 'function' ?
	  		config.create :
	  		function() {
	  			this.constructor.call(this, SVG.create(config.create))
	  		}
	  
	  	/* inherit prototype */
	  	if (config.inherit)
	  		initializer.prototype = new config.inherit
	  
	  	/* extend with methods */
	  	if (config.extend)
	  		SVG.extend(initializer, config.extend)
	  
	  	/* attach construct method to parent */
	  	if (config.construct)
	  		SVG.extend(config.parent || SVG.Container, config.construct)
	  
	  	return initializer
	  }
	
	  if (typeof CustomEvent !== 'function') {
	    // Code from: https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent
	    function CustomEvent (event, options) {
	      options = options || { bubbles: false, cancelable: false, detail: undefined }
	      var e = document.createEvent('CustomEvent')
	      e.initCustomEvent(event, options.bubbles, options.cancelable, options.detail)
	      return e
	    }
	  
	    CustomEvent.prototype = window.Event.prototype
	  
	    window.CustomEvent = CustomEvent
	  }
	
	  SVG.regex = {
	    /* parse unit value */
	    unit:         /^(-?[\d\.]+)([a-z%]{0,2})$/
	    
	    /* parse hex value */
	  , hex:          /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i
	    
	    /* parse rgb value */
	  , rgb:          /rgb\((\d+),(\d+),(\d+)\)/
	    
	    /* parse reference id */
	  , reference:    /#([a-z0-9\-_]+)/i
	  
	    /* test hex value */
	  , isHex:        /^#[a-f0-9]{3,6}$/i
	    
	    /* test rgb value */
	  , isRgb:        /^rgb\(/
	    
	    /* test css declaration */
	  , isCss:        /[^:]+:[^;]+;?/
	    
	    /* test for blank string */
	  , isBlank:      /^(\s+)?$/
	    
	    /* test for numeric string */
	  , isNumber:     /^-?[\d\.]+$/
	  
	    /* test for percent value */
	  , isPercent:    /^-?[\d\.]+%$/
	  
	    /* test for image url */
	  , isImage:      /\.(jpg|jpeg|png|gif)(\?[^=]+.*)?/i
	    
	    /* test for namespaced event */
	  , isEvent:      /^[\w]+:[\w]+$/
	  
	  }
	
	  SVG.defaults = {
	    // Default matrix
	    matrix:       '1 0 0 1 0 0'
	    
	    // Default attribute values
	  , attrs: {
	      /* fill and stroke */
	      'fill-opacity':     1
	    , 'stroke-opacity':   1
	    , 'stroke-width':     0
	    , 'stroke-linejoin':  'miter'
	    , 'stroke-linecap':   'butt'
	    , fill:               '#000000'
	    , stroke:             '#000000'
	    , opacity:            1
	      /* position */
	    , x:                  0
	    , y:                  0
	    , cx:                 0
	    , cy:                 0
	      /* size */  
	    , width:              0
	    , height:             0
	      /* radius */  
	    , r:                  0
	    , rx:                 0
	    , ry:                 0
	      /* gradient */  
	    , offset:             0
	    , 'stop-opacity':     1
	    , 'stop-color':       '#000000'
	      /* text */
	    , 'font-size':        16
	    , 'font-family':      'Helvetica, Arial, sans-serif'
	    , 'text-anchor':      'start'
	    }
	    
	    // Default transformation values
	  , trans: function() {
	      return {
	        /* translate */
	        x:        0
	      , y:        0
	        /* scale */
	      , scaleX:   1
	      , scaleY:   1
	        /* rotate */
	      , rotation: 0
	        /* skew */
	      , skewX:    0
	      , skewY:    0
	        /* matrix */
	      , matrix:   this.matrix
	      , a:        1
	      , b:        0
	      , c:        0
	      , d:        1
	      , e:        0
	      , f:        0
	      }
	    }
	    
	  }
	
	  SVG.Color = function(color) {
	    var match
	    
	    /* initialize defaults */
	    this.r = 0
	    this.g = 0
	    this.b = 0
	    
	    /* parse color */
	    if (typeof color === 'string') {
	      if (SVG.regex.isRgb.test(color)) {
	        /* get rgb values */
	        match = SVG.regex.rgb.exec(color.replace(/\s/g,''))
	        
	        /* parse numeric values */
	        this.r = parseInt(match[1])
	        this.g = parseInt(match[2])
	        this.b = parseInt(match[3])
	        
	      } else if (SVG.regex.isHex.test(color)) {
	        /* get hex values */
	        match = SVG.regex.hex.exec(fullHex(color))
	  
	        /* parse numeric values */
	        this.r = parseInt(match[1], 16)
	        this.g = parseInt(match[2], 16)
	        this.b = parseInt(match[3], 16)
	  
	      }
	      
	    } else if (typeof color === 'object') {
	      this.r = color.r
	      this.g = color.g
	      this.b = color.b
	      
	    }
	      
	  }
	  
	  SVG.extend(SVG.Color, {
	    // Default to hex conversion
	    toString: function() {
	      return this.toHex()
	    }
	    // Build hex value
	  , toHex: function() {
	      return '#'
	        + compToHex(this.r)
	        + compToHex(this.g)
	        + compToHex(this.b)
	    }
	    // Build rgb value
	  , toRgb: function() {
	      return 'rgb(' + [this.r, this.g, this.b].join() + ')'
	    }
	    // Calculate true brightness
	  , brightness: function() {
	      return (this.r / 255 * 0.30)
	           + (this.g / 255 * 0.59)
	           + (this.b / 255 * 0.11)
	    }
	    // Make color morphable
	  , morph: function(color) {
	      this.destination = new SVG.Color(color)
	  
	      return this
	    }
	    // Get morphed color at given position
	  , at: function(pos) {
	      /* make sure a destination is defined */
	      if (!this.destination) return this
	  
	      /* normalise pos */
	      pos = pos < 0 ? 0 : pos > 1 ? 1 : pos
	  
	      /* generate morphed color */
	      return new SVG.Color({
	        r: ~~(this.r + (this.destination.r - this.r) * pos)
	      , g: ~~(this.g + (this.destination.g - this.g) * pos)
	      , b: ~~(this.b + (this.destination.b - this.b) * pos)
	      })
	    }
	    
	  })
	  
	  // Testers
	  
	  // Test if given value is a color string
	  SVG.Color.test = function(color) {
	    color += ''
	    return SVG.regex.isHex.test(color)
	        || SVG.regex.isRgb.test(color)
	  }
	  
	  // Test if given value is a rgb object
	  SVG.Color.isRgb = function(color) {
	    return color && typeof color.r == 'number'
	                 && typeof color.g == 'number'
	                 && typeof color.b == 'number'
	  }
	  
	  // Test if given value is a color
	  SVG.Color.isColor = function(color) {
	    return SVG.Color.isRgb(color) || SVG.Color.test(color)
	  }
	
	  SVG.Array = function(array, fallback) {
	    array = (array || []).valueOf()
	  
	    /* if array is empty and fallback is provided, use fallback */
	    if (array.length == 0 && fallback)
	      array = fallback.valueOf()
	  
	    /* parse array */
	    this.value = this.parse(array)
	  }
	  
	  SVG.extend(SVG.Array, {
	    // Make array morphable
	    morph: function(array) {
	      this.destination = this.parse(array)
	  
	      /* normalize length of arrays */
	      if (this.value.length != this.destination.length) {
	        var lastValue       = this.value[this.value.length - 1]
	          , lastDestination = this.destination[this.destination.length - 1]
	  
	        while(this.value.length > this.destination.length)
	          this.destination.push(lastDestination)
	        while(this.value.length < this.destination.length)
	          this.value.push(lastValue)
	      }
	  
	      return this
	    }
	    // Clean up any duplicate points
	  , settle: function() {
	      /* find all unique values */
	      for (var i = 0, il = this.value.length, seen = []; i < il; i++)
	        if (seen.indexOf(this.value[i]) == -1)
	          seen.push(this.value[i])
	  
	      /* set new value */
	      return this.value = seen
	    }
	    // Get morphed array at given position
	  , at: function(pos) {
	      /* make sure a destination is defined */
	      if (!this.destination) return this
	  
	      /* generate morphed array */
	      for (var i = 0, il = this.value.length, array = []; i < il; i++)
	        array.push(this.value[i] + (this.destination[i] - this.value[i]) * pos)
	  
	      return new SVG.Array(array)
	    }
	    // Convert array to string
	  , toString: function() {
	      return this.value.join(' ')
	    }
	    // Real value
	  , valueOf: function() {
	      return this.value
	    }
	    // Parse whitespace separated string
	  , parse: function(array) {
	      array = array.valueOf()
	  
	      /* if already is an array, no need to parse it */
	      if (Array.isArray(array)) return array
	  
	      return this.split(array)
	    }
	    // Strip unnecessary whitespace
	  , split: function(string) {
	      return string.replace(/\s+/g, ' ').replace(/^\s+|\s+$/g,'').split(' ') 
	    }
	    // Reverse array
	  , reverse: function() {
	      this.value.reverse()
	  
	      return this
	    }
	  
	  })
	  
	
	
	  SVG.PointArray = function() {
	    this.constructor.apply(this, arguments)
	  }
	  
	  // Inherit from SVG.Array
	  SVG.PointArray.prototype = new SVG.Array
	  
	  SVG.extend(SVG.PointArray, {
	    // Convert array to string
	    toString: function() {
	      /* convert to a poly point string */
	      for (var i = 0, il = this.value.length, array = []; i < il; i++)
	        array.push(this.value[i].join(','))
	  
	      return array.join(' ')
	    }
	    // Get morphed array at given position
	  , at: function(pos) {
	      /* make sure a destination is defined */
	      if (!this.destination) return this
	  
	      /* generate morphed point string */
	      for (var i = 0, il = this.value.length, array = []; i < il; i++)
	        array.push([
	          this.value[i][0] + (this.destination[i][0] - this.value[i][0]) * pos
	        , this.value[i][1] + (this.destination[i][1] - this.value[i][1]) * pos
	        ])
	  
	      return new SVG.PointArray(array)
	    }
	    // Parse point string
	  , parse: function(array) {
	      array = array.valueOf()
	  
	      /* if already is an array, no need to parse it */
	      if (Array.isArray(array)) return array
	  
	      /* split points */
	      array = this.split(array)
	  
	      /* parse points */
	      for (var i = 0, il = array.length, p, points = []; i < il; i++) {
	        p = array[i].split(',')
	        points.push([parseFloat(p[0]), parseFloat(p[1])])
	      }
	  
	      return points
	    }
	    // Move point string
	  , move: function(x, y) {
	      var box = this.bbox()
	  
	      /* get relative offset */
	      x -= box.x
	      y -= box.y
	  
	      /* move every point */
	      if (!isNaN(x) && !isNaN(y))
	        for (var i = this.value.length - 1; i >= 0; i--)
	          this.value[i] = [this.value[i][0] + x, this.value[i][1] + y]
	  
	      return this
	    }
	    // Resize poly string
	  , size: function(width, height) {
	      var i, box = this.bbox()
	  
	      /* recalculate position of all points according to new size */
	      for (i = this.value.length - 1; i >= 0; i--) {
	        this.value[i][0] = ((this.value[i][0] - box.x) * width)  / box.width  + box.x
	        this.value[i][1] = ((this.value[i][1] - box.y) * height) / box.height + box.y
	      }
	  
	      return this
	    }
	    // Get bounding box of points
	  , bbox: function() {
	      SVG.parser.poly.setAttribute('points', this.toString())
	  
	      return SVG.parser.poly.getBBox()
	    }
	  
	  })
	
	  SVG.PathArray = function(array, fallback) {
	    this.constructor.call(this, array, fallback)
	  }
	  
	  // Inherit from SVG.Array
	  SVG.PathArray.prototype = new SVG.Array
	  
	  SVG.extend(SVG.PathArray, {
	    // Convert array to string
	    toString: function() {
	      return arrayToString(this.value)
	    }
	    // Move path string
	  , move: function(x, y) {
	  		/* get bounding box of current situation */
	  		var box = this.bbox()
	  		
	      /* get relative offset */
	      x -= box.x
	      y -= box.y
	  
	      if (!isNaN(x) && !isNaN(y)) {
	        /* move every point */
	        for (var l, i = this.value.length - 1; i >= 0; i--) {
	          l = this.value[i][0]
	  
	          if (l == 'M' || l == 'L' || l == 'T')  {
	            this.value[i][1] += x
	            this.value[i][2] += y
	  
	          } else if (l == 'H')  {
	            this.value[i][1] += x
	  
	          } else if (l == 'V')  {
	            this.value[i][1] += y
	  
	          } else if (l == 'C' || l == 'S' || l == 'Q')  {
	            this.value[i][1] += x
	            this.value[i][2] += y
	            this.value[i][3] += x
	            this.value[i][4] += y
	  
	            if (l == 'C')  {
	              this.value[i][5] += x
	              this.value[i][6] += y
	            }
	  
	          } else if (l == 'A')  {
	            this.value[i][6] += x
	            this.value[i][7] += y
	          }
	  
	        }
	      }
	  
	      return this
	    }
	    // Resize path string
	  , size: function(width, height) {
	  		/* get bounding box of current situation */
	  		var i, l, box = this.bbox()
	  
	      /* recalculate position of all points according to new size */
	      for (i = this.value.length - 1; i >= 0; i--) {
	        l = this.value[i][0]
	  
	        if (l == 'M' || l == 'L' || l == 'T')  {
	          this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x
	          this.value[i][2] = ((this.value[i][2] - box.y) * height) / box.height + box.y
	  
	        } else if (l == 'H')  {
	          this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x
	  
	        } else if (l == 'V')  {
	          this.value[i][1] = ((this.value[i][1] - box.y) * height) / box.height + box.y
	  
	        } else if (l == 'C' || l == 'S' || l == 'Q')  {
	          this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x
	          this.value[i][2] = ((this.value[i][2] - box.y) * height) / box.height + box.y
	          this.value[i][3] = ((this.value[i][3] - box.x) * width)  / box.width  + box.x
	          this.value[i][4] = ((this.value[i][4] - box.y) * height) / box.height + box.y
	  
	          if (l == 'C')  {
	            this.value[i][5] = ((this.value[i][5] - box.x) * width)  / box.width  + box.x
	            this.value[i][6] = ((this.value[i][6] - box.y) * height) / box.height + box.y
	          }
	  
	        } else if (l == 'A')  {
	          /* resize radii */
	          this.value[i][1] = (this.value[i][1] * width)  / box.width
	          this.value[i][2] = (this.value[i][2] * height) / box.height
	  
	          /* move position values */
	          this.value[i][6] = ((this.value[i][6] - box.x) * width)  / box.width  + box.x
	          this.value[i][7] = ((this.value[i][7] - box.y) * height) / box.height + box.y
	        }
	  
	      }
	  
	      return this
	    }
	    // Absolutize and parse path to array
	  , parse: function(array) {
	      /* if it's already is a patharray, no need to parse it */
	      if (array instanceof SVG.PathArray) return array.valueOf()
	  
	      /* prepare for parsing */
	      var i, il, x0, y0, x1, y1, x2, y2, s, seg, segs
	        , x = 0
	        , y = 0
	      
	      /* populate working path */
	      SVG.parser.path.setAttribute('d', typeof array === 'string' ? array : arrayToString(array))
	      
	      /* get segments */
	      segs = SVG.parser.path.pathSegList
	  
	      for (i = 0, il = segs.numberOfItems; i < il; ++i) {
	        seg = segs.getItem(i)
	        s = seg.pathSegTypeAsLetter
	  
	        /* yes, this IS quite verbose but also about 30 times faster than .test() with a precompiled regex */
	        if (s == 'M' || s == 'L' || s == 'H' || s == 'V' || s == 'C' || s == 'S' || s == 'Q' || s == 'T' || s == 'A') {
	          if ('x' in seg) x = seg.x
	          if ('y' in seg) y = seg.y
	  
	        } else {
	          if ('x1' in seg) x1 = x + seg.x1
	          if ('x2' in seg) x2 = x + seg.x2
	          if ('y1' in seg) y1 = y + seg.y1
	          if ('y2' in seg) y2 = y + seg.y2
	          if ('x'  in seg) x += seg.x
	          if ('y'  in seg) y += seg.y
	  
	          if (s == 'm')
	            segs.replaceItem(SVG.parser.path.createSVGPathSegMovetoAbs(x, y), i)
	          else if (s == 'l')
	            segs.replaceItem(SVG.parser.path.createSVGPathSegLinetoAbs(x, y), i)
	          else if (s == 'h')
	            segs.replaceItem(SVG.parser.path.createSVGPathSegLinetoHorizontalAbs(x), i)
	          else if (s == 'v')
	            segs.replaceItem(SVG.parser.path.createSVGPathSegLinetoVerticalAbs(y), i)
	          else if (s == 'c')
	            segs.replaceItem(SVG.parser.path.createSVGPathSegCurvetoCubicAbs(x, y, x1, y1, x2, y2), i)
	          else if (s == 's')
	            segs.replaceItem(SVG.parser.path.createSVGPathSegCurvetoCubicSmoothAbs(x, y, x2, y2), i)
	          else if (s == 'q')
	            segs.replaceItem(SVG.parser.path.createSVGPathSegCurvetoQuadraticAbs(x, y, x1, y1), i)
	          else if (s == 't')
	            segs.replaceItem(SVG.parser.path.createSVGPathSegCurvetoQuadraticSmoothAbs(x, y), i)
	          else if (s == 'a')
	            segs.replaceItem(SVG.parser.path.createSVGPathSegArcAbs(x, y, seg.r1, seg.r2, seg.angle, seg.largeArcFlag, seg.sweepFlag), i)
	          else if (s == 'z' || s == 'Z') {
	            x = x0
	            y = y0
	          }
	        }
	  
	        /* record the start of a subpath */
	        if (s == 'M' || s == 'm') {
	          x0 = x
	          y0 = y
	        }
	      }
	  
	      /* build internal representation */
	      array = []
	      segs  = SVG.parser.path.pathSegList
	      
	      for (i = 0, il = segs.numberOfItems; i < il; ++i) {
	        seg = segs.getItem(i)
	        s = seg.pathSegTypeAsLetter
	        x = [s]
	  
	        if (s == 'M' || s == 'L' || s == 'T')
	          x.push(seg.x, seg.y)
	        else if (s == 'H')
	          x.push(seg.x)
	        else if (s == 'V')
	          x.push(seg.y)
	        else if (s == 'C')
	          x.push(seg.x1, seg.y1, seg.x2, seg.y2, seg.x, seg.y)
	        else if (s == 'S')
	          x.push(seg.x2, seg.y2, seg.x, seg.y)
	        else if (s == 'Q')
	          x.push(seg.x1, seg.y1, seg.x, seg.y)
	        else if (s == 'A')
	          x.push(seg.r1, seg.r2, seg.angle, seg.largeArcFlag|0, seg.sweepFlag|0, seg.x, seg.y)
	  
	        /* store segment */
	        array.push(x)
	      }
	      
	      return array
	    }
	    // Get bounding box of path
	  , bbox: function() {
	      SVG.parser.path.setAttribute('d', this.toString())
	  
	      return SVG.parser.path.getBBox()
	    }
	  
	  })
	
	  SVG.Number = function(value) {
	  
	    /* initialize defaults */
	    this.value = 0
	    this.unit = ''
	  
	    /* parse value */
	    if (typeof value === 'number') {
	      /* ensure a valid numeric value */
	      this.value = isNaN(value) ? 0 : !isFinite(value) ? (value < 0 ? -3.4e+38 : +3.4e+38) : value
	  
	    } else if (typeof value === 'string') {
	      var match = value.match(SVG.regex.unit)
	  
	      if (match) {
	        /* make value numeric */
	        this.value = parseFloat(match[1])
	      
	        /* normalize percent value */
	        if (match[2] == '%')
	          this.value /= 100
	        else if (match[2] == 's')
	          this.value *= 1000
	      
	        /* store unit */
	        this.unit = match[2]
	      }
	  
	    } else {
	      if (value instanceof SVG.Number) {
	        this.value = value.value
	        this.unit  = value.unit
	      }
	    }
	  
	  }
	  
	  SVG.extend(SVG.Number, {
	    // Stringalize
	    toString: function() {
	      return (
	        this.unit == '%' ?
	          ~~(this.value * 1e8) / 1e6:
	        this.unit == 's' ?
	          this.value / 1e3 :
	          this.value
	      ) + this.unit
	    }
	  , // Convert to primitive
	    valueOf: function() {
	      return this.value
	    }
	    // Add number
	  , plus: function(number) {
	      this.value = this + new SVG.Number(number)
	  
	      return this
	    }
	    // Subtract number
	  , minus: function(number) {
	      return this.plus(-new SVG.Number(number))
	    }
	    // Multiply number
	  , times: function(number) {
	      this.value = this * new SVG.Number(number)
	  
	      return this
	    }
	    // Divide number
	  , divide: function(number) {
	      this.value = this / new SVG.Number(number)
	  
	      return this
	    }
	    // Convert to different unit
	  , to: function(unit) {
	      if (typeof unit === 'string')
	        this.unit = unit
	  
	      return this
	    }
	    // Make number morphable
	  , morph: function(number) {
	      this.destination = new SVG.Number(number)
	  
	      return this
	    }
	    // Get morphed number at given position
	  , at: function(pos) {
	      /* make sure a destination is defined */
	      if (!this.destination) return this
	  
	      /* generate new morphed number */
	      return new SVG.Number(this.destination)
	          .minus(this)
	          .times(pos)
	          .plus(this)
	    }
	  
	  })
	
	  SVG.ViewBox = function(element) {
	    var x, y, width, height
	      , wm   = 1 /* width multiplier */
	      , hm   = 1 /* height multiplier */
	      , box  = element.bbox()
	      , view = (element.attr('viewBox') || '').match(/-?[\d\.]+/g)
	      , we   = element
	      , he   = element
	  
	    /* get dimensions of current node */
	    width  = new SVG.Number(element.width())
	    height = new SVG.Number(element.height())
	  
	    /* find nearest non-percentual dimensions */
	    while (width.unit == '%') {
	      wm *= width.value
	      width = new SVG.Number(we instanceof SVG.Doc ? we.parent.offsetWidth : we.parent.width())
	      we = we.parent
	    }
	    while (height.unit == '%') {
	      hm *= height.value
	      height = new SVG.Number(he instanceof SVG.Doc ? he.parent.offsetHeight : he.parent.height())
	      he = he.parent
	    }
	    
	    /* ensure defaults */
	    this.x      = box.x
	    this.y      = box.y
	    this.width  = width  * wm
	    this.height = height * hm
	    this.zoom   = 1
	    
	    if (view) {
	      /* get width and height from viewbox */
	      x      = parseFloat(view[0])
	      y      = parseFloat(view[1])
	      width  = parseFloat(view[2])
	      height = parseFloat(view[3])
	      
	      /* calculate zoom accoring to viewbox */
	      this.zoom = ((this.width / this.height) > (width / height)) ?
	        this.height / height :
	        this.width  / width
	  
	      /* calculate real pixel dimensions on parent SVG.Doc element */
	      this.x      = x
	      this.y      = y
	      this.width  = width
	      this.height = height
	      
	    }
	    
	  }
	  
	  //
	  SVG.extend(SVG.ViewBox, {
	    // Parse viewbox to string
	    toString: function() {
	      return this.x + ' ' + this.y + ' ' + this.width + ' ' + this.height
	    }
	    
	  })
	
	  SVG.BBox = function(element) {
	    var box
	  
	    /* initialize zero box */
	    this.x      = 0
	    this.y      = 0
	    this.width  = 0
	    this.height = 0
	    
	    /* get values if element is given */
	    if (element) {
	      try {
	        /* actual, native bounding box */
	        box = element.node.getBBox()
	      } catch(e) {
	        /* fallback for some browsers */
	        box = {
	          x:      element.node.clientLeft
	        , y:      element.node.clientTop
	        , width:  element.node.clientWidth
	        , height: element.node.clientHeight
	        }
	      }
	      
	      /* include translations on x an y */
	      this.x = box.x + element.trans.x
	      this.y = box.y + element.trans.y
	      
	      /* plain width and height */
	      this.width  = box.width  * element.trans.scaleX
	      this.height = box.height * element.trans.scaleY
	    }
	  
	    /* add center, right and bottom */
	    boxProperties(this)
	    
	  }
	  
	  //
	  SVG.extend(SVG.BBox, {
	    // merge bounding box with another, return a new instance
	    merge: function(box) {
	      var b = new SVG.BBox()
	  
	      /* merge box */
	      b.x      = Math.min(this.x, box.x)
	      b.y      = Math.min(this.y, box.y)
	      b.width  = Math.max(this.x + this.width,  box.x + box.width)  - b.x
	      b.height = Math.max(this.y + this.height, box.y + box.height) - b.y
	  
	      /* add center, right and bottom */
	      boxProperties(b)
	  
	      return b
	    }
	  
	  })
	
	  SVG.RBox = function(element) {
	    var e, zoom
	      , box = {}
	  
	    /* initialize zero box */
	    this.x      = 0
	    this.y      = 0
	    this.width  = 0
	    this.height = 0
	    
	    if (element) {
	      e = element.doc().parent
	      zoom = element.doc().viewbox().zoom
	      
	      /* actual, native bounding box */
	      box = element.node.getBoundingClientRect()
	      
	      /* get screen offset */
	      this.x = box.left
	      this.y = box.top
	      
	      /* subtract parent offset */
	      this.x -= e.offsetLeft
	      this.y -= e.offsetTop
	      
	      while (e = e.offsetParent) {
	        this.x -= e.offsetLeft
	        this.y -= e.offsetTop
	      }
	      
	      /* calculate cumulative zoom from svg documents */
	      e = element
	      while (e = e.parent) {
	        if (e.type == 'svg' && e.viewbox) {
	          zoom *= e.viewbox().zoom
	          this.x -= e.x() || 0
	          this.y -= e.y() || 0
	        }
	      }
	    }
	    
	    /* recalculate viewbox distortion */
	    this.x /= zoom
	    this.y /= zoom
	    this.width  = box.width  /= zoom
	    this.height = box.height /= zoom
	    
	    /* offset by window scroll position, because getBoundingClientRect changes when window is scrolled */
	    this.x += typeof window.scrollX === 'number' ? window.scrollX : window.pageXOffset
	    this.y += typeof window.scrollY === 'number' ? window.scrollY : window.pageYOffset
	  
	    /* add center, right and bottom */
	    boxProperties(this)
	    
	  }
	  
	  //
	  SVG.extend(SVG.RBox, {
	    // merge rect box with another, return a new instance
	    merge: function(box) {
	      var b = new SVG.RBox()
	  
	      /* merge box */
	      b.x      = Math.min(this.x, box.x)
	      b.y      = Math.min(this.y, box.y)
	      b.width  = Math.max(this.x + this.width,  box.x + box.width)  - b.x
	      b.height = Math.max(this.y + this.height, box.y + box.height) - b.y
	  
	      /* add center, right and bottom */
	      boxProperties(b)
	  
	      return b
	    }
	  
	  })
	
	
	  SVG.Element = SVG.invent({
	    // Initialize node
	    create: function(node) {
	      /* make stroke value accessible dynamically */
	      this._stroke = SVG.defaults.attrs.stroke
	  
	      /* initialize transformation store with defaults */
	      this.trans = SVG.defaults.trans()
	      
	      /* create circular reference */
	      if (this.node = node) {
	        this.type = node.nodeName
	        this.node.instance = this
	      }
	    }
	  
	    // Add class methods
	  , extend: {
	      // Move over x-axis
	      x: function(x) {
	        if (x != null) {
	          x = new SVG.Number(x)
	          x.value /= this.trans.scaleX
	        }
	        return this.attr('x', x)
	      }
	      // Move over y-axis
	    , y: function(y) {
	        if (y != null) {
	          y = new SVG.Number(y)
	          y.value /= this.trans.scaleY
	        }
	        return this.attr('y', y)
	      }
	      // Move by center over x-axis
	    , cx: function(x) {
	        return x == null ? this.x() + this.width() / 2 : this.x(x - this.width() / 2)
	      }
	      // Move by center over y-axis
	    , cy: function(y) {
	        return y == null ? this.y() + this.height() / 2 : this.y(y - this.height() / 2)
	      }
	      // Move element to given x and y values
	    , move: function(x, y) {
	        return this.x(x).y(y)
	      }
	      // Move element by its center
	    , center: function(x, y) {
	        return this.cx(x).cy(y)
	      }
	      // Set width of element
	    , width: function(width) {
	        return this.attr('width', width)
	      }
	      // Set height of element
	    , height: function(height) {
	        return this.attr('height', height)
	      }
	      // Set element size to given width and height
	    , size: function(width, height) {
	        var p = proportionalSize(this.bbox(), width, height)
	  
	        return this
	          .width(new SVG.Number(p.width))
	          .height(new SVG.Number(p.height))
	      }
	      // Clone element
	    , clone: function() {
	        var clone , attr
	          , type = this.type
	        
	        /* invoke shape method with shape-specific arguments */
	        clone = type == 'rect' || type == 'ellipse' ?
	          this.parent[type](0,0) :
	        type == 'line' ?
	          this.parent[type](0,0,0,0) :
	        type == 'image' ?
	          this.parent[type](this.src) :
	        type == 'text' ?
	          this.parent[type](this.content) :
	        type == 'path' ?
	          this.parent[type](this.attr('d')) :
	        type == 'polyline' || type == 'polygon' ?
	          this.parent[type](this.attr('points')) :
	        type == 'g' ?
	          this.parent.group() :
	          this.parent[type]()
	        
	        /* apply attributes attributes */
	        attr = this.attr()
	        delete attr.id
	        clone.attr(attr)
	        
	        /* copy transformations */
	        clone.trans = this.trans
	        
	        /* apply attributes and translations */
	        return clone.transform({})
	      }
	      // Remove element
	    , remove: function() {
	        if (this.parent)
	          this.parent.removeElement(this)
	        
	        return this
	      }
	      // Replace element
	    , replace: function(element) {
	        this.after(element).remove()
	  
	        return element
	      }
	      // Add element to given container and return self
	    , addTo: function(parent) {
	        return parent.put(this)
	      }
	      // Add element to given container and return container
	    , putIn: function(parent) {
	        return parent.add(this)
	      }
	      // Get parent document
	    , doc: function(type) {
	        return this._parent(type || SVG.Doc)
	      }
	      // Set svg element attribute
	    , attr: function(a, v, n) {
	        if (a == null) {
	          /* get an object of attributes */
	          a = {}
	          v = this.node.attributes
	          for (n = v.length - 1; n >= 0; n--)
	            a[v[n].nodeName] = SVG.regex.isNumber.test(v[n].nodeValue) ? parseFloat(v[n].nodeValue) : v[n].nodeValue
	          
	          return a
	          
	        } else if (typeof a == 'object') {
	          /* apply every attribute individually if an object is passed */
	          for (v in a) this.attr(v, a[v])
	          
	        } else if (v === null) {
	            /* remove value */
	            this.node.removeAttribute(a)
	          
	        } else if (v == null) {
	          /* act as a getter if the first and only argument is not an object */
	          v = this.node.attributes[a]
	          return v == null ? 
	            SVG.defaults.attrs[a] :
	          SVG.regex.isNumber.test(v.nodeValue) ?
	            parseFloat(v.nodeValue) : v.nodeValue
	        
	        } else if (a == 'style') {
	          /* redirect to the style method */
	          return this.style(v)
	        
	        } else {
	          /* BUG FIX: some browsers will render a stroke if a color is given even though stroke width is 0 */
	          if (a == 'stroke-width')
	            this.attr('stroke', parseFloat(v) > 0 ? this._stroke : null)
	          else if (a == 'stroke')
	            this._stroke = v
	  
	          /* convert image fill and stroke to patterns */
	          if (a == 'fill' || a == 'stroke') {
	            if (SVG.regex.isImage.test(v))
	              v = this.doc().defs().image(v, 0, 0)
	  
	            if (v instanceof SVG.Image)
	              v = this.doc().defs().pattern(0, 0, function() {
	                this.add(v)
	              })
	          }
	          
	          /* ensure correct numeric values (also accepts NaN and Infinity) */
	          if (typeof v === 'number')
	            v = new SVG.Number(v)
	  
	          /* ensure full hex color */
	          else if (SVG.Color.isColor(v))
	            v = new SVG.Color(v)
	          
	          /* parse array values */
	          else if (Array.isArray(v))
	            v = new SVG.Array(v)
	  
	          /* if the passed attribute is leading... */
	          if (a == 'leading') {
	            /* ... call the leading method instead */
	            if (this.leading)
	              this.leading(v)
	          } else {
	            /* set given attribute on node */
	            typeof n === 'string' ?
	              this.node.setAttributeNS(n, a, v.toString()) :
	              this.node.setAttribute(a, v.toString())
	          }
	          
	          /* rebuild if required */
	          if (this.rebuild && (a == 'font-size' || a == 'x'))
	            this.rebuild(a, v)
	        }
	        
	        return this
	      }
	      // Manage transformations
	    , transform: function(o, v) {
	        
	        if (arguments.length == 0) {
	          /* act as a getter if no argument is given */
	          return this.trans
	          
	        } else if (typeof o === 'string') {
	          /* act as a getter if only one string argument is given */
	          if (arguments.length < 2)
	            return this.trans[o]
	          
	          /* apply transformations as object if key value arguments are given*/
	          var transform = {}
	          transform[o] = v
	          
	          return this.transform(transform)
	        }
	        
	        /* ... otherwise continue as a setter */
	        var transform = []
	        
	        /* parse matrix */
	        o = parseMatrix(o)
	        
	        /* merge values */
	        for (v in o)
	          if (o[v] != null)
	            this.trans[v] = o[v]
	        
	        /* compile matrix */
	        this.trans.matrix = this.trans.a
	                    + ' ' + this.trans.b
	                    + ' ' + this.trans.c
	                    + ' ' + this.trans.d
	                    + ' ' + this.trans.e
	                    + ' ' + this.trans.f
	        
	        /* alias current transformations */
	        o = this.trans
	        
	        /* add matrix */
	        if (o.matrix != SVG.defaults.matrix)
	          transform.push('matrix(' + o.matrix + ')')
	        
	        /* add rotation */
	        if (o.rotation != 0)
	          transform.push('rotate(' + o.rotation + ' ' + (o.cx == null ? this.bbox().cx : o.cx) + ' ' + (o.cy == null ? this.bbox().cy : o.cy) + ')')
	        
	        /* add scale */
	        if (o.scaleX != 1 || o.scaleY != 1)
	          transform.push('scale(' + o.scaleX + ' ' + o.scaleY + ')')
	        
	        /* add skew on x axis */
	        if (o.skewX != 0)
	          transform.push('skewX(' + o.skewX + ')')
	        
	        /* add skew on y axis */
	        if (o.skewY != 0)
	          transform.push('skewY(' + o.skewY + ')')
	        
	        /* add translation */
	        if (o.x != 0 || o.y != 0)
	          transform.push('translate(' + new SVG.Number(o.x / o.scaleX) + ' ' + new SVG.Number(o.y / o.scaleY) + ')')
	        
	        /* update transformations, even if there are none */
	        if (transform.length == 0)
	          this.node.removeAttribute('transform')
	        else
	          this.node.setAttribute('transform', transform.join(' '))
	        
	        return this
	      }
	      // Dynamic style generator
	    , style: function(s, v) {
	        if (arguments.length == 0) {
	          /* get full style */
	          return this.node.style.cssText || ''
	        
	        } else if (arguments.length < 2) {
	          /* apply every style individually if an object is passed */
	          if (typeof s == 'object') {
	            for (v in s) this.style(v, s[v])
	          
	          } else if (SVG.regex.isCss.test(s)) {
	            /* parse css string */
	            s = s.split(';')
	  
	            /* apply every definition individually */
	            for (var i = 0; i < s.length; i++) {
	              v = s[i].split(':')
	              this.style(v[0].replace(/\s+/g, ''), v[1])
	            }
	          } else {
	            /* act as a getter if the first and only argument is not an object */
	            return this.node.style[camelCase(s)]
	          }
	        
	        } else {
	          this.node.style[camelCase(s)] = v === null || SVG.regex.isBlank.test(v) ? '' : v
	        }
	        
	        return this
	      }
	      // Get / set id
	    , id: function(id) {
	        return this.attr('id', id)
	      }
	      // Get bounding box
	    , bbox: function() {
	        return new SVG.BBox(this)
	      }
	      // Get rect box
	    , rbox: function() {
	        return new SVG.RBox(this)
	      }
	      // Checks whether the given point inside the bounding box of the element
	    , inside: function(x, y) {
	        var box = this.bbox()
	        
	        return x > box.x
	            && y > box.y
	            && x < box.x + box.width
	            && y < box.y + box.height
	      }
	      // Show element
	    , show: function() {
	        return this.style('display', '')
	      }
	      // Hide element
	    , hide: function() {
	        return this.style('display', 'none')
	      }
	      // Is element visible?
	    , visible: function() {
	        return this.style('display') != 'none'
	      }
	      // Return id on string conversion
	    , toString: function() {
	        return this.attr('id')
	      }
	      // Return array of classes on the node
	    , classes: function() {
	        var classAttr = this.node.getAttribute('class')
	        if (classAttr === null) {
	          return []
	        } else {
	          return classAttr.trim().split(/\s+/)
	        }
	      }
	      // Return true if class exists on the node, false otherwise
	    , hasClass: function(className) {
	        return this.classes().indexOf(className) != -1
	      }
	      // Add class to the node
	    , addClass: function(className) {
	        var classArray
	        if (!(this.hasClass(className))) {
	          classArray = this.classes()
	          classArray.push(className)
	          this.node.setAttribute('class', classArray.join(' '))
	        }
	        return this
	      }
	      // Remove class from the node
	    , removeClass: function(className) {
	        var classArray
	        if (this.hasClass(className)) {
	          classArray = this.classes().filter(function(c) {
	            return c != className
	          })
	          this.node.setAttribute('class', classArray.join(' '))
	        }
	        return this
	      }
	      // Toggle the presence of a class on the node
	    , toggleClass: function(className) {
	        if (this.hasClass(className)) {
	          this.removeClass(className)
	        } else {
	          this.addClass(className)
	        }
	        return this
	      }
	      // Get referenced element form attribute value
	    , reference: function(attr) {
	        return SVG.get(this.attr()[attr])
	      }
	      // Private: find svg parent by instance
	    , _parent: function(parent) {
	        var element = this
	        
	        while (element != null && !(element instanceof parent))
	          element = element.parent
	  
	        return element
	      }
	    }
	  })
	
	
	  SVG.Parent = SVG.invent({
	    // Initialize node
	    create: function(element) {
	      this.constructor.call(this, element)
	    }
	  
	    // Inherit from
	  , inherit: SVG.Element
	  
	    // Add class methods
	  , extend: {
	      // Returns all child elements
	      children: function() {
	        return this._children || (this._children = [])
	      }
	      // Add given element at a position
	    , add: function(element, i) {
	        if (!this.has(element)) {
	          /* define insertion index if none given */
	          i = i == null ? this.children().length : i
	          
	          /* remove references from previous parent */
	          if (element.parent)
	            element.parent.children().splice(element.parent.index(element), 1)
	          
	          /* add element references */
	          this.children().splice(i, 0, element)
	          this.node.insertBefore(element.node, this.node.childNodes[i] || null)
	          element.parent = this
	        }
	  
	        /* reposition defs */
	        if (this._defs) {
	          this.node.removeChild(this._defs.node)
	          this.node.appendChild(this._defs.node)
	        }
	        
	        return this
	      }
	      // Basically does the same as `add()` but returns the added element instead
	    , put: function(element, i) {
	        this.add(element, i)
	        return element
	      }
	      // Checks if the given element is a child
	    , has: function(element) {
	        return this.index(element) >= 0
	      }
	      // Gets index of given element
	    , index: function(element) {
	        return this.children().indexOf(element)
	      }
	      // Get a element at the given index
	    , get: function(i) {
	        return this.children()[i]
	      }
	      // Get first child, skipping the defs node
	    , first: function() {
	        return this.children()[0]
	      }
	      // Get the last child
	    , last: function() {
	        return this.children()[this.children().length - 1]
	      }
	      // Iterates over all children and invokes a given block
	    , each: function(block, deep) {
	        var i, il
	          , children = this.children()
	        
	        for (i = 0, il = children.length; i < il; i++) {
	          if (children[i] instanceof SVG.Element)
	            block.apply(children[i], [i, children])
	  
	          if (deep && (children[i] instanceof SVG.Container))
	            children[i].each(block, deep)
	        }
	      
	        return this
	      }
	      // Remove a child element at a position
	    , removeElement: function(element) {
	        this.children().splice(this.index(element), 1)
	        this.node.removeChild(element.node)
	        element.parent = null
	        
	        return this
	      }
	      // Remove all elements in this container
	    , clear: function() {
	        /* remove children */
	        for (var i = this.children().length - 1; i >= 0; i--)
	          this.removeElement(this.children()[i])
	  
	        /* remove defs node */
	        if (this._defs)
	          this._defs.clear()
	  
	        return this
	      }
	     , // Get defs
	      defs: function() {
	        return this.doc().defs()
	      }
	    }
	    
	  })
	
	
	  SVG.Container = SVG.invent({
	    // Initialize node
	    create: function(element) {
	      this.constructor.call(this, element)
	    }
	  
	    // Inherit from
	  , inherit: SVG.Parent
	  
	    // Add class methods
	  , extend: {
	      // Get the viewBox and calculate the zoom value
	      viewbox: function(v) {
	        if (arguments.length == 0)
	          /* act as a getter if there are no arguments */
	          return new SVG.ViewBox(this)
	        
	        /* otherwise act as a setter */
	        v = arguments.length == 1 ?
	          [v.x, v.y, v.width, v.height] :
	          [].slice.call(arguments)
	        
	        return this.attr('viewBox', v)
	      }
	    }
	    
	  })
	
	  SVG.FX = SVG.invent({
	    // Initialize FX object
	    create: function(element) {
	      /* store target element */
	      this.target = element
	    }
	  
	    // Add class methods
	  , extend: {
	      // Add animation parameters and start animation
	      animate: function(d, ease, delay) {
	        var akeys, tkeys, skeys, key
	          , element = this.target
	          , fx = this
	        
	        /* dissect object if one is passed */
	        if (typeof d == 'object') {
	          delay = d.delay
	          ease = d.ease
	          d = d.duration
	        }
	  
	        /* ensure default duration and easing */
	        d = d == '=' ? d : d == null ? 1000 : new SVG.Number(d).valueOf()
	        ease = ease || '<>'
	  
	        /* process values */
	        fx.to = function(pos) {
	          var i
	  
	          /* normalise pos */
	          pos = pos < 0 ? 0 : pos > 1 ? 1 : pos
	  
	          /* collect attribute keys */
	          if (akeys == null) {
	            akeys = []
	            for (key in fx.attrs)
	              akeys.push(key)
	  
	            /* make sure morphable elements are scaled, translated and morphed all together */
	            if (element.morphArray && (fx._plot || akeys.indexOf('points') > -1)) {
	              /* get destination */
	              var box
	                , p = new element.morphArray(fx._plot || fx.attrs.points || element.array)
	  
	              /* add size */
	              if (fx._size) p.size(fx._size.width.to, fx._size.height.to)
	  
	              /* add movement */
	              box = p.bbox()
	              if (fx._x) p.move(fx._x.to, box.y)
	              else if (fx._cx) p.move(fx._cx.to - box.width / 2, box.y)
	  
	              box = p.bbox()
	              if (fx._y) p.move(box.x, fx._y.to)
	              else if (fx._cy) p.move(box.x, fx._cy.to - box.height / 2)
	  
	              /* delete element oriented changes */
	              delete fx._x
	              delete fx._y
	              delete fx._cx
	              delete fx._cy
	              delete fx._size
	  
	              fx._plot = element.array.morph(p)
	            }
	          }
	  
	          /* collect transformation keys */
	          if (tkeys == null) {
	            tkeys = []
	            for (key in fx.trans)
	              tkeys.push(key)
	          }
	  
	          /* collect style keys */
	          if (skeys == null) {
	            skeys = []
	            for (key in fx.styles)
	              skeys.push(key)
	          }
	  
	          /* apply easing */
	          pos = ease == '<>' ?
	            (-Math.cos(pos * Math.PI) / 2) + 0.5 :
	          ease == '>' ?
	            Math.sin(pos * Math.PI / 2) :
	          ease == '<' ?
	            -Math.cos(pos * Math.PI / 2) + 1 :
	          ease == '-' ?
	            pos :
	          typeof ease == 'function' ?
	            ease(pos) :
	            pos
	          
	          /* run plot function */
	          if (fx._plot) {
	            element.plot(fx._plot.at(pos))
	  
	          } else {
	            /* run all x-position properties */
	            if (fx._x)
	              element.x(fx._x.at(pos))
	            else if (fx._cx)
	              element.cx(fx._cx.at(pos))
	  
	            /* run all y-position properties */
	            if (fx._y)
	              element.y(fx._y.at(pos))
	            else if (fx._cy)
	              element.cy(fx._cy.at(pos))
	  
	            /* run all size properties */
	            if (fx._size)
	              element.size(fx._size.width.at(pos), fx._size.height.at(pos))
	          }
	  
	          /* run all viewbox properties */
	          if (fx._viewbox)
	            element.viewbox(
	              fx._viewbox.x.at(pos)
	            , fx._viewbox.y.at(pos)
	            , fx._viewbox.width.at(pos)
	            , fx._viewbox.height.at(pos)
	            )
	  
	          /* run leading property */
	          if (fx._leading)
	            element.leading(fx._leading.at(pos))
	  
	          /* animate attributes */
	          for (i = akeys.length - 1; i >= 0; i--)
	            element.attr(akeys[i], at(fx.attrs[akeys[i]], pos))
	  
	          /* animate transformations */
	          for (i = tkeys.length - 1; i >= 0; i--)
	            element.transform(tkeys[i], at(fx.trans[tkeys[i]], pos))
	  
	          /* animate styles */
	          for (i = skeys.length - 1; i >= 0; i--)
	            element.style(skeys[i], at(fx.styles[skeys[i]], pos))
	  
	          /* callback for each keyframe */
	          if (fx._during)
	            fx._during.call(element, pos, function(from, to) {
	              return at({ from: from, to: to }, pos)
	            })
	        }
	        
	        if (typeof d === 'number') {
	          /* delay animation */
	          this.timeout = setTimeout(function() {
	            var start = new Date().getTime()
	  
	            /* initialize situation object */
	            fx.situation = {
	              interval: 1000 / 60
	            , start:    start
	            , play:     true
	            , finish:   start + d
	            , duration: d
	            }
	  
	            /* render function */
	            fx.render = function() {
	              
	              if (fx.situation.play === true) {
	                // This code was borrowed from the emile.js micro framework by Thomas Fuchs, aka MadRobby.
	                var time = new Date().getTime()
	                  , pos = time > fx.situation.finish ? 1 : (time - fx.situation.start) / d
	                
	                /* process values */
	                fx.to(pos)
	                
	                /* finish off animation */
	                if (time > fx.situation.finish) {
	                  if (fx._plot)
	                    element.plot(new SVG.PointArray(fx._plot.destination).settle())
	  
	                  if (fx._loop === true || (typeof fx._loop == 'number' && fx._loop > 1)) {
	                    if (typeof fx._loop == 'number')
	                      --fx._loop
	                    fx.animate(d, ease, delay)
	                  } else {
	                    fx._after ? fx._after.apply(element, [fx]) : fx.stop()
	                  }
	  
	                } else {
	                  requestAnimFrame(fx.render)
	                }
	              } else {
	                requestAnimFrame(fx.render)
	              }
	              
	            }
	  
	            /* start animation */
	            fx.render()
	            
	          }, new SVG.Number(delay).valueOf())
	        }
	        
	        return this
	      }
	      // Get bounding box of target element
	    , bbox: function() {
	        return this.target.bbox()
	      }
	      // Add animatable attributes
	    , attr: function(a, v) {
	        if (typeof a == 'object') {
	          for (var key in a)
	            this.attr(key, a[key])
	        
	        } else {
	          var from = this.target.attr(a)
	  
	          this.attrs[a] = SVG.Color.isColor(from) ?
	            new SVG.Color(from).morph(v) :
	          SVG.regex.unit.test(from) ?
	            new SVG.Number(from).morph(v) :
	            { from: from, to: v }
	        }
	        
	        return this
	      }
	      // Add animatable transformations
	    , transform: function(o, v) {
	        if (arguments.length == 1) {
	          /* parse matrix string */
	          o = parseMatrix(o)
	          
	          /* dlete matrixstring from object */
	          delete o.matrix
	          
	          /* store matrix values */
	          for (v in o)
	            this.trans[v] = { from: this.target.trans[v], to: o[v] }
	          
	        } else {
	          /* apply transformations as object if key value arguments are given*/
	          var transform = {}
	          transform[o] = v
	          
	          this.transform(transform)
	        }
	        
	        return this
	      }
	      // Add animatable styles
	    , style: function(s, v) {
	        if (typeof s == 'object')
	          for (var key in s)
	            this.style(key, s[key])
	        
	        else
	          this.styles[s] = { from: this.target.style(s), to: v }
	        
	        return this
	      }
	      // Animatable x-axis
	    , x: function(x) {
	        this._x = new SVG.Number(this.target.x()).morph(x)
	        
	        return this
	      }
	      // Animatable y-axis
	    , y: function(y) {
	        this._y = new SVG.Number(this.target.y()).morph(y)
	        
	        return this
	      }
	      // Animatable center x-axis
	    , cx: function(x) {
	        this._cx = new SVG.Number(this.target.cx()).morph(x)
	        
	        return this
	      }
	      // Animatable center y-axis
	    , cy: function(y) {
	        this._cy = new SVG.Number(this.target.cy()).morph(y)
	        
	        return this
	      }
	      // Add animatable move
	    , move: function(x, y) {
	        return this.x(x).y(y)
	      }
	      // Add animatable center
	    , center: function(x, y) {
	        return this.cx(x).cy(y)
	      }
	      // Add animatable size
	    , size: function(width, height) {
	        if (this.target instanceof SVG.Text) {
	          /* animate font size for Text elements */
	          this.attr('font-size', width)
	          
	        } else {
	          /* animate bbox based size for all other elements */
	          var box = this.target.bbox()
	  
	          this._size = {
	            width:  new SVG.Number(box.width).morph(width)
	          , height: new SVG.Number(box.height).morph(height)
	          }
	        }
	        
	        return this
	      }
	      // Add animatable plot
	    , plot: function(p) {
	        this._plot = p
	  
	        return this
	      }
	      // Add leading method
	    , leading: function(value) {
	        if (this.target._leading)
	          this._leading = new SVG.Number(this.target._leading).morph(value)
	  
	        return this
	      }
	      // Add animatable viewbox
	    , viewbox: function(x, y, width, height) {
	        if (this.target instanceof SVG.Container) {
	          var box = this.target.viewbox()
	          
	          this._viewbox = {
	            x:      new SVG.Number(box.x).morph(x)
	          , y:      new SVG.Number(box.y).morph(y)
	          , width:  new SVG.Number(box.width).morph(width)
	          , height: new SVG.Number(box.height).morph(height)
	          }
	        }
	        
	        return this
	      }
	      // Add animateable gradient update
	    , update: function(o) {
	        if (this.target instanceof SVG.Stop) {
	          if (o.opacity != null) this.attr('stop-opacity', o.opacity)
	          if (o.color   != null) this.attr('stop-color', o.color)
	          if (o.offset  != null) this.attr('offset', new SVG.Number(o.offset))
	        }
	  
	        return this
	      }
	      // Add callback for each keyframe
	    , during: function(during) {
	        this._during = during
	        
	        return this
	      }
	      // Callback after animation
	    , after: function(after) {
	        this._after = after
	        
	        return this
	      }
	      // Make loopable
	    , loop: function(times) {
	        this._loop = times || true
	  
	        return this
	      }
	      // Stop running animation
	    , stop: function(fulfill) {
	        /* fulfill animation */
	        if (fulfill === true) {
	  
	          this.animate(0)
	  
	          if (this._after)
	            this._after.apply(this.target, [this])
	  
	        } else {
	          /* stop current animation */
	          clearTimeout(this.timeout)
	  
	          /* reset storage for properties that need animation */
	          this.attrs     = {}
	          this.trans     = {}
	          this.styles    = {}
	          this.situation = {}
	  
	          /* delete destinations */
	          delete this._x
	          delete this._y
	          delete this._cx
	          delete this._cy
	          delete this._size
	          delete this._plot
	          delete this._loop
	          delete this._after
	          delete this._during
	          delete this._leading
	          delete this._viewbox
	        }
	        
	        return this
	      }
	      // Pause running animation
	    , pause: function() {
	        if (this.situation.play === true) {
	          this.situation.play  = false
	          this.situation.pause = new Date().getTime()
	        }
	  
	        return this
	      }
	      // Play running animation
	    , play: function() {
	        if (this.situation.play === false) {
	          var pause = new Date().getTime() - this.situation.pause
	          
	          this.situation.finish += pause
	          this.situation.start  += pause
	          this.situation.play    = true
	        }
	  
	        return this
	      }
	      
	    }
	  
	    // Define parent class
	  , parent: SVG.Element
	  
	    // Add method to parent elements
	  , construct: {
	      // Get fx module or create a new one, then animate with given duration and ease
	      animate: function(d, ease, delay) {
	        return (this.fx || (this.fx = new SVG.FX(this))).stop().animate(d, ease, delay)
	      }
	      // Stop current animation; this is an alias to the fx instance
	    , stop: function(fulfill) {
	        if (this.fx)
	          this.fx.stop(fulfill)
	        
	        return this
	      }
	      // Pause current animation
	    , pause: function() {
	        if (this.fx)
	          this.fx.pause()
	  
	        return this
	      }
	      // Play paused current animation
	    , play: function() {
	        if (this.fx)
	          this.fx.play()
	  
	        return this
	      }
	      
	    }
	  })
	
	
	  SVG.extend(SVG.Element, SVG.FX, {
	    // Relative move over x axis
	    dx: function(x) {
	      return this.x((this.target || this).x() + x)
	    }
	    // Relative move over y axis
	  , dy: function(y) {
	      return this.y((this.target || this).y() + y)
	    }
	    // Relative move over x and y axes
	  , dmove: function(x, y) {
	      return this.dx(x).dy(y)
	    }
	  
	  })
	
	  ;[  'click'
	    , 'dblclick'
	    , 'mousedown'
	    , 'mouseup'
	    , 'mouseover'
	    , 'mouseout'
	    , 'mousemove'
	    // , 'mouseenter' -> not supported by IE
	    // , 'mouseleave' -> not supported by IE
	    , 'touchstart'
	    , 'touchmove'
	    , 'touchleave'
	    , 'touchend'
	    , 'touchcancel' ].forEach(function(event) {
	    
	    /* add event to SVG.Element */
	    SVG.Element.prototype[event] = function(f) {
	      var self = this
	      
	      /* bind event to element rather than element node */
	      this.node['on' + event] = typeof f == 'function' ?
	        function() { return f.apply(self, arguments) } : null
	      
	      return this
	    }
	    
	  })
	  
	  // Initialize events and listeners stack
	  SVG.events = {}
	  SVG.listeners = {}
	  
	  // Event constructor
	  SVG.registerEvent = function(event) {
	    if (!SVG.events[event])
	      SVG.events[event] = new CustomEvent(event)
	  }
	  
	  // Add event binder in the SVG namespace
	  SVG.on = function(node, event, listener) {
	    // create listener
	    var l = listener.bind(node.instance || node)
	  
	    // ensure reference objects
	    SVG.listeners[node]        = SVG.listeners[node]        || {}
	    SVG.listeners[node][event] = SVG.listeners[node][event] || {}
	  
	    // reference listener
	    SVG.listeners[node][event][listener] = l
	  
	    // add listener
	    node.addEventListener(event, l, false)
	  }
	  
	  // Add event unbinder in the SVG namespace
	  SVG.off = function(node, event, listener) {
	    if (listener) {
	      // remove listener reference
	      if (SVG.listeners[node] && SVG.listeners[node][event]) {
	        // remove listener
	        node.removeEventListener(event, SVG.listeners[node][event][listener], false)
	  
	        delete SVG.listeners[node][event][listener]
	      }
	  
	    } else if (event) {
	      // remove all listeners for the event
	      if (SVG.listeners[node][event]) {
	        for (listener in SVG.listeners[node][event])
	          SVG.off(node, event, listener)
	  
	        delete SVG.listeners[node][event]
	      }
	  
	    } else {
	      // remove all listeners on a given node
	      if (SVG.listeners[node]) {
	        for (event in SVG.listeners[node])
	          SVG.off(node, event)
	  
	        delete SVG.listeners[node]
	      }
	    }
	  }
	  
	  //
	  SVG.extend(SVG.Element, {
	    // Bind given event to listener
	    on: function(event, listener) {
	      SVG.on(this.node, event, listener)
	      
	      return this
	    }
	    // Unbind event from listener
	  , off: function(event, listener) {
	      SVG.off(this.node, event, listener)
	      
	      return this
	    }
	    // Fire given event
	  , fire: function(event, data) {
	      // Add detail data to event
	      SVG.events[event].detail = data
	      
	      // Dispatch event
	      this.node.dispatchEvent(SVG.events[event])
	  
	      // Remove detail
	      delete SVG.events[event].detail
	  
	      return this
	    }
	  })
	
	  SVG.Defs = SVG.invent({
	    // Initialize node
	    create: 'defs'
	  
	    // Inherit from
	  , inherit: SVG.Container
	    
	  })
	
	  SVG.G = SVG.invent({
	    // Initialize node
	    create: 'g'
	  
	    // Inherit from
	  , inherit: SVG.Container
	    
	    // Add class methods
	  , extend: {
	      // Move over x-axis
	      x: function(x) {
	        return x == null ? this.trans.x : this.transform('x', x)
	      }
	      // Move over y-axis
	    , y: function(y) {
	        return y == null ? this.trans.y : this.transform('y', y)
	      }
	      // Move by center over x-axis
	    , cx: function(x) {
	        return x == null ? this.bbox().cx : this.x(x - this.bbox().width / 2)
	      }
	      // Move by center over y-axis
	    , cy: function(y) {
	        return y == null ? this.bbox().cy : this.y(y - this.bbox().height / 2)
	      }
	    }
	    
	    // Add parent method
	  , construct: {
	      // Create a group element
	      group: function() {
	        return this.put(new SVG.G)
	      }
	    }
	  })
	
	  SVG.extend(SVG.Element, {
	    // Get all siblings, including myself
	    siblings: function() {
	      return this.parent.children()
	    }
	    // Get the curent position siblings
	  , position: function() {
	      return this.parent.index(this)
	    }
	    // Get the next element (will return null if there is none)
	  , next: function() {
	      return this.siblings()[this.position() + 1]
	    }
	    // Get the next element (will return null if there is none)
	  , previous: function() {
	      return this.siblings()[this.position() - 1]
	    }
	    // Send given element one step forward
	  , forward: function() {
	      var i = this.position()
	      return this.parent.removeElement(this).put(this, i + 1)
	    }
	    // Send given element one step backward
	  , backward: function() {
	      var i = this.position()
	      
	      if (i > 0)
	        this.parent.removeElement(this).add(this, i - 1)
	  
	      return this
	    }
	    // Send given element all the way to the front
	  , front: function() {
	      return this.parent.removeElement(this).put(this)
	    }
	    // Send given element all the way to the back
	  , back: function() {
	      if (this.position() > 0)
	        this.parent.removeElement(this).add(this, 0)
	      
	      return this
	    }
	    // Inserts a given element before the targeted element
	  , before: function(element) {
	      element.remove()
	  
	      var i = this.position()
	      
	      this.parent.add(element, i)
	  
	      return this
	    }
	    // Insters a given element after the targeted element
	  , after: function(element) {
	      element.remove()
	      
	      var i = this.position()
	      
	      this.parent.add(element, i + 1)
	  
	      return this
	    }
	  
	  })
	
	  SVG.Mask = SVG.invent({
	    // Initialize node
	    create: function() {
	      this.constructor.call(this, SVG.create('mask'))
	  
	      /* keep references to masked elements */
	      this.targets = []
	    }
	  
	    // Inherit from
	  , inherit: SVG.Container
	  
	    // Add class methods
	  , extend: {
	      // Unmask all masked elements and remove itself
	      remove: function() {
	        /* unmask all targets */
	        for (var i = this.targets.length - 1; i >= 0; i--)
	          if (this.targets[i])
	            this.targets[i].unmask()
	        delete this.targets
	  
	        /* remove mask from parent */
	        this.parent.removeElement(this)
	        
	        return this
	      }
	    }
	    
	    // Add parent method
	  , construct: {
	      // Create masking element
	      mask: function() {
	        return this.defs().put(new SVG.Mask)
	      }
	    }
	  })
	  
	  
	  SVG.extend(SVG.Element, {
	    // Distribute mask to svg element
	    maskWith: function(element) {
	      /* use given mask or create a new one */
	      this.masker = element instanceof SVG.Mask ? element : this.parent.mask().add(element)
	  
	      /* store reverence on self in mask */
	      this.masker.targets.push(this)
	      
	      /* apply mask */
	      return this.attr('mask', 'url("#' + this.masker.attr('id') + '")')
	    }
	    // Unmask element
	  , unmask: function() {
	      delete this.masker
	      return this.attr('mask', null)
	    }
	    
	  })
	
	
	  SVG.Clip = SVG.invent({
	    // Initialize node
	    create: function() {
	      this.constructor.call(this, SVG.create('clipPath'))
	  
	      /* keep references to clipped elements */
	      this.targets = []
	    }
	  
	    // Inherit from
	  , inherit: SVG.Container
	  
	    // Add class methods
	  , extend: {
	      // Unclip all clipped elements and remove itself
	      remove: function() {
	        /* unclip all targets */
	        for (var i = this.targets.length - 1; i >= 0; i--)
	          if (this.targets[i])
	            this.targets[i].unclip()
	        delete this.targets
	  
	        /* remove clipPath from parent */
	        this.parent.removeElement(this)
	        
	        return this
	      }
	    }
	    
	    // Add parent method
	  , construct: {
	      // Create clipping element
	      clip: function() {
	        return this.defs().put(new SVG.Clip)
	      }
	    }
	  })
	  
	  //
	  SVG.extend(SVG.Element, {
	    // Distribute clipPath to svg element
	    clipWith: function(element) {
	      /* use given clip or create a new one */
	      this.clipper = element instanceof SVG.Clip ? element : this.parent.clip().add(element)
	  
	      /* store reverence on self in mask */
	      this.clipper.targets.push(this)
	      
	      /* apply mask */
	      return this.attr('clip-path', 'url("#' + this.clipper.attr('id') + '")')
	    }
	    // Unclip element
	  , unclip: function() {
	      delete this.clipper
	      return this.attr('clip-path', null)
	    }
	    
	  })
	
	  SVG.Gradient = SVG.invent({
	    // Initialize node
	    create: function(type) {
	      this.constructor.call(this, SVG.create(type + 'Gradient'))
	      
	      /* store type */
	      this.type = type
	    }
	  
	    // Inherit from
	  , inherit: SVG.Container
	  
	    // Add class methods
	  , extend: {
	      // From position
	      from: function(x, y) {
	        return this.type == 'radial' ?
	          this.attr({ fx: new SVG.Number(x), fy: new SVG.Number(y) }) :
	          this.attr({ x1: new SVG.Number(x), y1: new SVG.Number(y) })
	      }
	      // To position
	    , to: function(x, y) {
	        return this.type == 'radial' ?
	          this.attr({ cx: new SVG.Number(x), cy: new SVG.Number(y) }) :
	          this.attr({ x2: new SVG.Number(x), y2: new SVG.Number(y) })
	      }
	      // Radius for radial gradient
	    , radius: function(r) {
	        return this.type == 'radial' ?
	          this.attr({ r: new SVG.Number(r) }) :
	          this
	      }
	      // Add a color stop
	    , at: function(offset, color, opacity) {
	        return this.put(new SVG.Stop).update(offset, color, opacity)
	      }
	      // Update gradient
	    , update: function(block) {
	        /* remove all stops */
	        this.clear()
	        
	        /* invoke passed block */
	        if (typeof block == 'function')
	          block.call(this, this)
	        
	        return this
	      }
	      // Return the fill id
	    , fill: function() {
	        return 'url(#' + this.id() + ')'
	      }
	      // Alias string convertion to fill
	    , toString: function() {
	        return this.fill()
	      }
	    }
	    
	    // Add parent method
	  , construct: {
	      // Create gradient element in defs
	      gradient: function(type, block) {
	        return this.defs().gradient(type, block)
	      }
	    }
	  })
	  
	  SVG.extend(SVG.Defs, {
	    // define gradient
	    gradient: function(type, block) {
	      return this.put(new SVG.Gradient(type)).update(block)
	    }
	    
	  })
	  
	  SVG.Stop = SVG.invent({
	    // Initialize node
	    create: 'stop'
	  
	    // Inherit from
	  , inherit: SVG.Element
	  
	    // Add class methods
	  , extend: {
	      // add color stops
	      update: function(o) {
	        if (typeof o == 'number' || o instanceof SVG.Number) {
	          o = {
	            offset:  arguments[0]
	          , color:   arguments[1]
	          , opacity: arguments[2]
	          }
	        }
	  
	        /* set attributes */
	        if (o.opacity != null) this.attr('stop-opacity', o.opacity)
	        if (o.color   != null) this.attr('stop-color', o.color)
	        if (o.offset  != null) this.attr('offset', new SVG.Number(o.offset))
	  
	        return this
	      }
	    }
	  
	  })
	
	
	  SVG.Pattern = SVG.invent({
	    // Initialize node
	    create: 'pattern'
	  
	    // Inherit from
	  , inherit: SVG.Container
	  
	    // Add class methods
	  , extend: {
	      // Return the fill id
	  	  fill: function() {
	  	    return 'url(#' + this.id() + ')'
	  	  }
	  	  // Update pattern by rebuilding
	  	, update: function(block) {
	  			/* remove content */
	        this.clear()
	        
	        /* invoke passed block */
	        if (typeof block == 'function')
	        	block.call(this, this)
	        
	        return this
	  		}
	  	  // Alias string convertion to fill
	  	, toString: function() {
	  	    return this.fill()
	  	  }
	    }
	    
	    // Add parent method
	  , construct: {
	      // Create pattern element in defs
	  	  pattern: function(width, height, block) {
	  	    return this.defs().pattern(width, height, block)
	  	  }
	    }
	  })
	  
	  SVG.extend(SVG.Defs, {
	    // Define gradient
	    pattern: function(width, height, block) {
	      return this.put(new SVG.Pattern).update(block).attr({
	        x:            0
	      , y:            0
	      , width:        width
	      , height:       height
	      , patternUnits: 'userSpaceOnUse'
	      })
	    }
	  
	  })
	
	  SVG.Doc = SVG.invent({
	    // Initialize node
	    create: function(element) {
	      /* ensure the presence of a html element */
	      this.parent = typeof element == 'string' ?
	        document.getElementById(element) :
	        element
	      
	      /* If the target is an svg element, use that element as the main wrapper.
	         This allows svg.js to work with svg documents as well. */
	      this.constructor
	        .call(this, this.parent.nodeName == 'svg' ? this.parent : SVG.create('svg'))
	      
	      /* set svg element attributes */
	      this
	        .attr({ xmlns: SVG.ns, version: '1.1', width: '100%', height: '100%' })
	        .attr('xmlns:xlink', SVG.xlink, SVG.xmlns)
	      
	      /* create the <defs> node */
	      this._defs = new SVG.Defs
	      this._defs.parent = this
	      this.node.appendChild(this._defs.node)
	  
	      /* turn off sub pixel offset by default */
	      this.doSpof = false
	      
	      /* ensure correct rendering */
	      if (this.parent != this.node)
	        this.stage()
	    }
	  
	    // Inherit from
	  , inherit: SVG.Container
	  
	    // Add class methods
	  , extend: {
	      /* enable drawing */
	      stage: function() {
	        var element = this
	  
	        /* insert element */
	        this.parent.appendChild(this.node)
	  
	        /* fix sub-pixel offset */
	        element.spof()
	        
	        /* make sure sub-pixel offset is fixed every time the window is resized */
	        SVG.on(window, 'resize', function() {
	          element.spof()
	        })
	  
	        return this
	      }
	  
	      // Creates and returns defs element
	    , defs: function() {
	        return this._defs
	      }
	  
	      // Fix for possible sub-pixel offset. See:
	      // https://bugzilla.mozilla.org/show_bug.cgi?id=608812
	    , spof: function() {
	        if (this.doSpof) {
	          var pos = this.node.getScreenCTM()
	          
	          if (pos)
	            this
	              .style('left', (-pos.e % 1) + 'px')
	              .style('top',  (-pos.f % 1) + 'px')
	        }
	        
	        return this
	      }
	  
	      // Enable sub-pixel offset
	    , fixSubPixelOffset: function() {
	        this.doSpof = true
	  
	        return this
	      }
	    }
	    
	  })
	
	
	  SVG.Shape = SVG.invent({
	    // Initialize node
	    create: function(element) {
	  	  this.constructor.call(this, element)
	  	}
	  
	    // Inherit from
	  , inherit: SVG.Element
	  
	  })
	
	  SVG.Symbol = SVG.invent({
	    // Initialize node
	    create: 'symbol'
	  
	    // Inherit from
	  , inherit: SVG.Container
	  
	    // Add parent method
	  , construct: {
	      // Create a new symbol
	      symbol: function() {
	        return this.defs().put(new SVG.Symbol)
	      }
	    }
	    
	  })
	
	  SVG.Use = SVG.invent({
	    // Initialize node
	    create: 'use'
	  
	    // Inherit from
	  , inherit: SVG.Shape
	  
	    // Add class methods
	  , extend: {
	      // Use element as a reference
	      element: function(element) {
	        /* store target element */
	        this.target = element
	  
	        /* set lined element */
	        return this.attr('href', '#' + element, SVG.xlink)
	      }
	    }
	    
	    // Add parent method
	  , construct: {
	      // Create a use element
	      use: function(element) {
	        return this.put(new SVG.Use).element(element)
	      }
	    }
	  })
	
	  SVG.Rect = SVG.invent({
	  	// Initialize node
	    create: 'rect'
	  
	  	// Inherit from
	  , inherit: SVG.Shape
	  	
	  	// Add parent method
	  , construct: {
	    	// Create a rect element
	    	rect: function(width, height) {
	    	  return this.put(new SVG.Rect().size(width, height))
	    	}
	    	
	  	}
	  	
	  })
	
	  SVG.Ellipse = SVG.invent({
	    // Initialize node
	    create: 'ellipse'
	  
	    // Inherit from
	  , inherit: SVG.Shape
	  
	    // Add class methods
	  , extend: {
	      // Move over x-axis
	      x: function(x) {
	        return x == null ? this.cx() - this.attr('rx') : this.cx(x + this.attr('rx'))
	      }
	      // Move over y-axis
	    , y: function(y) {
	        return y == null ? this.cy() - this.attr('ry') : this.cy(y + this.attr('ry'))
	      }
	      // Move by center over x-axis
	    , cx: function(x) {
	        return x == null ? this.attr('cx') : this.attr('cx', new SVG.Number(x).divide(this.trans.scaleX))
	      }
	      // Move by center over y-axis
	    , cy: function(y) {
	        return y == null ? this.attr('cy') : this.attr('cy', new SVG.Number(y).divide(this.trans.scaleY))
	      }
	      // Set width of element
	    , width: function(width) {
	        return width == null ? this.attr('rx') * 2 : this.attr('rx', new SVG.Number(width).divide(2))
	      }
	      // Set height of element
	    , height: function(height) {
	        return height == null ? this.attr('ry') * 2 : this.attr('ry', new SVG.Number(height).divide(2))
	      }
	      // Custom size function
	    , size: function(width, height) {
	        var p = proportionalSize(this.bbox(), width, height)
	  
	        return this.attr({
	          rx: new SVG.Number(p.width).divide(2)
	        , ry: new SVG.Number(p.height).divide(2)
	        })
	      }
	      
	    }
	  
	    // Add parent method
	  , construct: {
	      // Create circle element, based on ellipse
	      circle: function(size) {
	        return this.ellipse(size, size)
	      }
	      // Create an ellipse
	    , ellipse: function(width, height) {
	        return this.put(new SVG.Ellipse).size(width, height).move(0, 0)
	      }
	      
	    }
	  
	  })
	
	  SVG.Line = SVG.invent({
	    // Initialize node
	    create: 'line'
	  
	    // Inherit from
	  , inherit: SVG.Shape
	  
	    // Add class methods
	  , extend: {
	      // Move over x-axis
	      x: function(x) {
	        var b = this.bbox()
	        
	        return x == null ? b.x : this.attr({
	          x1: this.attr('x1') - b.x + x
	        , x2: this.attr('x2') - b.x + x
	        })
	      }
	      // Move over y-axis
	    , y: function(y) {
	        var b = this.bbox()
	        
	        return y == null ? b.y : this.attr({
	          y1: this.attr('y1') - b.y + y
	        , y2: this.attr('y2') - b.y + y
	        })
	      }
	      // Move by center over x-axis
	    , cx: function(x) {
	        var half = this.bbox().width / 2
	        return x == null ? this.x() + half : this.x(x - half)
	      }
	      // Move by center over y-axis
	    , cy: function(y) {
	        var half = this.bbox().height / 2
	        return y == null ? this.y() + half : this.y(y - half)
	      }
	      // Set width of element
	    , width: function(width) {
	        var b = this.bbox()
	  
	        return width == null ? b.width : this.attr(this.attr('x1') < this.attr('x2') ? 'x2' : 'x1', b.x + width)
	      }
	      // Set height of element
	    , height: function(height) {
	        var b = this.bbox()
	  
	        return height == null ? b.height : this.attr(this.attr('y1') < this.attr('y2') ? 'y2' : 'y1', b.y + height)
	      }
	      // Set line size by width and height
	    , size: function(width, height) {
	        var p = proportionalSize(this.bbox(), width, height)
	  
	        return this.width(p.width).height(p.height)
	      }
	      // Set path data
	    , plot: function(x1, y1, x2, y2) {
	        return this.attr({
	          x1: x1
	        , y1: y1
	        , x2: x2
	        , y2: y2
	        })
	      }
	    }
	    
	    // Add parent method
	  , construct: {
	      // Create a line element
	      line: function(x1, y1, x2, y2) {
	        return this.put(new SVG.Line().plot(x1, y1, x2, y2))
	      }
	    }
	  })
	
	
	  SVG.Polyline = SVG.invent({
	    // Initialize node
	    create: 'polyline'
	  
	    // Inherit from
	  , inherit: SVG.Shape
	    
	    // Add parent method
	  , construct: {
	      // Create a wrapped polyline element
	      polyline: function(p) {
	        return this.put(new SVG.Polyline).plot(p)
	      }
	    }
	  })
	  
	  SVG.Polygon = SVG.invent({
	    // Initialize node
	    create: 'polygon'
	  
	    // Inherit from
	  , inherit: SVG.Shape
	    
	    // Add parent method
	  , construct: {
	      // Create a wrapped polygon element
	      polygon: function(p) {
	        return this.put(new SVG.Polygon).plot(p)
	      }
	    }
	  })
	  
	  // Add polygon-specific functions
	  SVG.extend(SVG.Polyline, SVG.Polygon, {
	    // Define morphable array
	    morphArray:  SVG.PointArray
	    // Plot new path
	  , plot: function(p) {
	      return this.attr('points', (this.array = new SVG.PointArray(p, [[0,0]])))
	    }
	    // Move by left top corner
	  , move: function(x, y) {
	      return this.attr('points', this.array.move(x, y))
	    }
	    // Move by left top corner over x-axis
	  , x: function(x) {
	      return x == null ? this.bbox().x : this.move(x, this.bbox().y)
	    }
	    // Move by left top corner over y-axis
	  , y: function(y) {
	      return y == null ? this.bbox().y : this.move(this.bbox().x, y)
	    }
	    // Set width of element
	  , width: function(width) {
	      var b = this.bbox()
	  
	      return width == null ? b.width : this.size(width, b.height)
	    }
	    // Set height of element
	  , height: function(height) {
	      var b = this.bbox()
	  
	      return height == null ? b.height : this.size(b.width, height) 
	    }
	    // Set element size to given width and height
	  , size: function(width, height) {
	      var p = proportionalSize(this.bbox(), width, height)
	  
	      return this.attr('points', this.array.size(p.width, p.height))
	    }
	  
	  })
	
	  SVG.Path = SVG.invent({
	    // Initialize node
	    create: 'path'
	  
	    // Inherit from
	  , inherit: SVG.Shape
	  
	    // Add class methods
	  , extend: {
	      // Plot new poly points
	      plot: function(p) {
	        return this.attr('d', (this.array = new SVG.PathArray(p, [['M', 0, 0]])))
	      }
	      // Move by left top corner
	    , move: function(x, y) {
	        return this.attr('d', this.array.move(x, y))
	      }
	      // Move by left top corner over x-axis
	    , x: function(x) {
	        return x == null ? this.bbox().x : this.move(x, this.bbox().y)
	      }
	      // Move by left top corner over y-axis
	    , y: function(y) {
	        return y == null ? this.bbox().y : this.move(this.bbox().x, y)
	      }
	      // Set element size to given width and height
	    , size: function(width, height) {
	        var p = proportionalSize(this.bbox(), width, height)
	        
	        return this.attr('d', this.array.size(p.width, p.height))
	      }
	      // Set width of element
	    , width: function(width) {
	        return width == null ? this.bbox().width : this.size(width, this.bbox().height)
	      }
	      // Set height of element
	    , height: function(height) {
	        return height == null ? this.bbox().height : this.size(this.bbox().width, height)
	      }
	      
	    }
	    
	    // Add parent method
	  , construct: {
	      // Create a wrapped path element
	      path: function(d) {
	        return this.put(new SVG.Path).plot(d)
	      }
	    }
	  })
	
	  SVG.Image = SVG.invent({
	    // Initialize node
	    create: 'image'
	  
	    // Inherit from
	  , inherit: SVG.Shape
	  
	    // Add class methods
	  , extend: {
	      // (re)load image
	      load: function(url) {
	        if (!url) return this
	  
	        var self = this
	          , img  = document.createElement('img')
	        
	        /* preload image */
	        img.onload = function() {
	          var p = self.doc(SVG.Pattern)
	  
	          /* ensure image size */
	          if (self.width() == 0 && self.height() == 0)
	            self.size(img.width, img.height)
	  
	          /* ensure pattern size if not set */
	          if (p && p.width() == 0 && p.height() == 0)
	            p.size(self.width(), self.height())
	          
	          /* callback */
	          if (typeof self._loaded === 'function')
	            self._loaded.call(self, {
	              width:  img.width
	            , height: img.height
	            , ratio:  img.width / img.height
	            , url:    url
	            })
	        }
	  
	        return this.attr('href', (img.src = this.src = url), SVG.xlink)
	      }
	      // Add loade callback
	    , loaded: function(loaded) {
	        this._loaded = loaded
	        return this
	      }
	    }
	    
	    // Add parent method
	  , construct: {
	      // Create image element, load image and set its size
	      image: function(source, width, height) {
	        return this.put(new SVG.Image).load(source).size(width || 0, height || width || 0)
	      }
	    }
	  
	  })
	
	  SVG.Text = SVG.invent({
	    // Initialize node
	    create: function() {
	      this.constructor.call(this, SVG.create('text'))
	      
	      this._leading = new SVG.Number(1.3)    /* store leading value for rebuilding */
	      this._rebuild = true                   /* enable automatic updating of dy values */
	      this._build   = false                  /* disable build mode for adding multiple lines */
	  
	      /* set default font */
	      this.attr('font-family', SVG.defaults.attrs['font-family'])
	    }
	  
	    // Inherit from
	  , inherit: SVG.Shape
	  
	    // Add class methods
	  , extend: {
	      // Move over x-axis
	      x: function(x) {
	        /* act as getter */
	        if (x == null)
	          return this.attr('x')
	        
	        /* move lines as well if no textPath is present */
	        if (!this.textPath)
	          this.lines.each(function() { if (this.newLined) this.x(x) })
	  
	        return this.attr('x', x)
	      }
	      // Move over y-axis
	    , y: function(y) {
	        var oy = this.attr('y')
	          , o  = typeof oy === 'number' ? oy - this.bbox().y : 0
	  
	        /* act as getter */
	        if (y == null)
	          return typeof oy === 'number' ? oy - o : oy
	  
	        return this.attr('y', typeof y === 'number' ? y + o : y)
	      }
	      // Move center over x-axis
	    , cx: function(x) {
	        return x == null ? this.bbox().cx : this.x(x - this.bbox().width / 2)
	      }
	      // Move center over y-axis
	    , cy: function(y) {
	        return y == null ? this.bbox().cy : this.y(y - this.bbox().height / 2)
	      }
	      // Set the text content
	    , text: function(text) {
	        /* act as getter */
	        if (typeof text === 'undefined') return this.content
	        
	        /* remove existing content */
	        this.clear().build(true)
	        
	        if (typeof text === 'function') {
	          /* call block */
	          text.call(this, this)
	  
	        } else {
	          /* store text and make sure text is not blank */
	          text = (this.content = text).split('\n')
	          
	          /* build new lines */
	          for (var i = 0, il = text.length; i < il; i++)
	            this.tspan(text[i]).newLine()
	        }
	        
	        /* disable build mode and rebuild lines */
	        return this.build(false).rebuild()
	      }
	      // Set font size
	    , size: function(size) {
	        return this.attr('font-size', size).rebuild()
	      }
	      // Set / get leading
	    , leading: function(value) {
	        /* act as getter */
	        if (value == null)
	          return this._leading
	        
	        /* act as setter */
	        this._leading = new SVG.Number(value)
	        
	        return this.rebuild()
	      }
	      // Rebuild appearance type
	    , rebuild: function(rebuild) {
	        /* store new rebuild flag if given */
	        if (typeof rebuild == 'boolean')
	          this._rebuild = rebuild
	  
	        /* define position of all lines */
	        if (this._rebuild) {
	          var self = this
	          
	          this.lines.each(function() {
	            if (this.newLined) {
	              if (!this.textPath)
	                this.attr('x', self.attr('x'))
	              this.attr('dy', self._leading * new SVG.Number(self.attr('font-size'))) 
	            }
	          })
	  
	          this.fire('rebuild')
	        }
	  
	        return this
	      }
	      // Enable / disable build mode
	    , build: function(build) {
	        this._build = !!build
	        return this
	      }
	    }
	    
	    // Add parent method
	  , construct: {
	      // Create text element
	      text: function(text) {
	        return this.put(new SVG.Text).text(text)
	      }
	      // Create plain text element
	    , plain: function(text) {
	        return this.put(new SVG.Text).plain(text)
	      }
	    }
	  
	  })
	  
	  SVG.TSpan = SVG.invent({
	    // Initialize node
	    create: 'tspan'
	  
	    // Inherit from
	  , inherit: SVG.Shape
	  
	    // Add class methods
	  , extend: {
	      // Set text content
	      text: function(text) {
	        typeof text === 'function' ? text.call(this, this) : this.plain(text)
	  
	        return this
	      }
	      // Shortcut dx
	    , dx: function(dx) {
	        return this.attr('dx', dx)
	      }
	      // Shortcut dy
	    , dy: function(dy) {
	        return this.attr('dy', dy)
	      }
	      // Create new line
	    , newLine: function() {
	        /* fetch text parent */
	        var t = this.doc(SVG.Text)
	  
	        /* mark new line */
	        this.newLined = true
	  
	        /* apply new hyn */
	        return this.dy(t._leading * t.attr('font-size')).attr('x', t.x())
	      }
	    }
	    
	  })
	  
	  SVG.extend(SVG.Text, SVG.TSpan, {
	    // Create plain text node
	    plain: function(text) {
	      /* clear if build mode is disabled */
	      if (this._build === false)
	        this.clear()
	  
	      /* create text node */
	      this.node.appendChild(document.createTextNode((this.content = text)))
	      
	      return this
	    }
	    // Create a tspan
	  , tspan: function(text) {
	      var node  = (this.textPath || this).node
	        , tspan = new SVG.TSpan
	  
	      /* clear if build mode is disabled */
	      if (this._build === false)
	        this.clear()
	      
	      /* add new tspan and reference */
	      node.appendChild(tspan.node)
	      tspan.parent = this
	  
	      /* only first level tspans are considered to be "lines" */
	      if (this instanceof SVG.Text)
	        this.lines.add(tspan)
	  
	      return tspan.text(text)
	    }
	    // Clear all lines
	  , clear: function() {
	      var node = (this.textPath || this).node
	  
	      /* remove existing child nodes */
	      while (node.hasChildNodes())
	        node.removeChild(node.lastChild)
	      
	      /* reset content references  */
	      if (this instanceof SVG.Text) {
	        delete this.lines
	        this.lines = new SVG.Set
	        this.content = ''
	      }
	      
	      return this
	    }
	    // Get length of text element
	  , length: function() {
	      return this.node.getComputedTextLength()
	    }
	  })
	  
	  // Register rebuild event
	  SVG.registerEvent('rebuild')
	
	
	  SVG.TextPath = SVG.invent({
	    // Initialize node
	    create: 'textPath'
	  
	    // Inherit from
	  , inherit: SVG.Element
	  
	    // Define parent class
	  , parent: SVG.Text
	  
	    // Add parent method
	  , construct: {
	      // Create path for text to run on
	      path: function(d) {
	        /* create textPath element */
	        this.textPath = new SVG.TextPath
	  
	        /* move lines to textpath */
	        while(this.node.hasChildNodes())
	          this.textPath.node.appendChild(this.node.firstChild)
	  
	        /* add textPath element as child node */
	        this.node.appendChild(this.textPath.node)
	  
	        /* create path in defs */
	        this.track = this.doc().defs().path(d)
	  
	        /* create circular reference */
	        this.textPath.parent = this
	  
	        /* link textPath to path and add content */
	        this.textPath.attr('href', '#' + this.track, SVG.xlink)
	  
	        return this
	      }
	      // Plot path if any
	    , plot: function(d) {
	        if (this.track) this.track.plot(d)
	        return this
	      }
	    }
	  })
	
	  SVG.Nested = SVG.invent({
	    // Initialize node
	    create: function() {
	      this.constructor.call(this, SVG.create('svg'))
	      
	      this.style('overflow', 'visible')
	    }
	  
	    // Inherit from
	  , inherit: SVG.Container
	    
	    // Add parent method
	  , construct: {
	      // Create nested svg document
	      nested: function() {
	        return this.put(new SVG.Nested)
	      }
	    }
	  })
	
	  SVG.A = SVG.invent({
	    // Initialize node
	    create: 'a'
	  
	    // Inherit from
	  , inherit: SVG.Container
	  
	    // Add class methods
	  , extend: {
	      // Link url
	      to: function(url) {
	        return this.attr('href', url, SVG.xlink)
	      }
	      // Link show attribute
	    , show: function(target) {
	        return this.attr('show', target, SVG.xlink)
	      }
	      // Link target attribute
	    , target: function(target) {
	        return this.attr('target', target)
	      }
	    }
	    
	    // Add parent method
	  , construct: {
	      // Create a hyperlink element
	      link: function(url) {
	        return this.put(new SVG.A).to(url)
	      }
	    }
	  })
	  
	  SVG.extend(SVG.Element, {
	    // Create a hyperlink element
	    linkTo: function(url) {
	      var link = new SVG.A
	  
	      if (typeof url == 'function')
	        url.call(link, link)
	      else
	        link.to(url)
	  
	      return this.parent.put(link).put(this)
	    }
	    
	  })
	
	  SVG.Marker = SVG.invent({
	    // Initialize node
	    create: 'marker'
	  
	    // Inherit from
	  , inherit: SVG.Container
	  
	    // Add class methods
	  , extend: {
	      // Set width of element
	      width: function(width) {
	        return this.attr('markerWidth', width)
	      }
	      // Set height of element
	    , height: function(height) {
	        return this.attr('markerHeight', height)
	      }
	      // Set marker refX and refY
	    , ref: function(x, y) {
	        return this.attr('refX', x).attr('refY', y)
	      }
	      // Update marker
	    , update: function(block) {
	        /* remove all content */
	        this.clear()
	        
	        /* invoke passed block */
	        if (typeof block == 'function')
	          block.call(this, this)
	        
	        return this
	      }
	      // Return the fill id
	    , toString: function() {
	        return 'url(#' + this.id() + ')'
	      }
	    }
	  
	    // Add parent method
	  , construct: {
	      marker: function(width, height, block) {
	        // Create marker element in defs
	        return this.defs().marker(width, height, block)
	      }
	    }
	  
	  })
	  
	  SVG.extend(SVG.Defs, {
	    // Create marker
	    marker: function(width, height, block) {
	      // Set default viewbox to match the width and height, set ref to cx and cy and set orient to auto
	      return this.put(new SVG.Marker)
	        .size(width, height)
	        .ref(width / 2, height / 2)
	        .viewbox(0, 0, width, height)
	        .attr('orient', 'auto')
	        .update(block)
	    }
	    
	  })
	  
	  SVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, SVG.Path, {
	    // Create and attach markers
	    marker: function(marker, width, height, block) {
	      var attr = ['marker']
	  
	      // Build attribute name
	      if (marker != 'all') attr.push(marker)
	      attr = attr.join('-')
	  
	      // Set marker attribute
	      marker = arguments[1] instanceof SVG.Marker ?
	        arguments[1] :
	        this.doc().marker(width, height, block)
	      
	      return this.attr(attr, marker)
	    }
	    
	  })
	
	  var sugar = {
	    stroke: ['color', 'width', 'opacity', 'linecap', 'linejoin', 'miterlimit', 'dasharray', 'dashoffset']
	  , fill:   ['color', 'opacity', 'rule']
	  , prefix: function(t, a) {
	      return a == 'color' ? t : t + '-' + a
	    }
	  }
	  
	  /* Add sugar for fill and stroke */
	  ;['fill', 'stroke'].forEach(function(m) {
	    var i, extension = {}
	    
	    extension[m] = function(o) {
	      if (typeof o == 'string' || SVG.Color.isRgb(o) || (o && typeof o.fill === 'function'))
	        this.attr(m, o)
	  
	      else
	        /* set all attributes from sugar.fill and sugar.stroke list */
	        for (i = sugar[m].length - 1; i >= 0; i--)
	          if (o[sugar[m][i]] != null)
	            this.attr(sugar.prefix(m, sugar[m][i]), o[sugar[m][i]])
	      
	      return this
	    }
	    
	    SVG.extend(SVG.Element, SVG.FX, extension)
	    
	  })
	  
	  SVG.extend(SVG.Element, SVG.FX, {
	    // Rotation
	    rotate: function(deg, x, y) {
	      return this.transform({
	        rotation: deg || 0
	      , cx: x
	      , cy: y
	      })
	    }
	    // Skew
	  , skew: function(x, y) {
	      return this.transform({
	        skewX: x || 0
	      , skewY: y || 0
	      })
	    }
	    // Scale
	  , scale: function(x, y) {
	      return this.transform({
	        scaleX: x
	      , scaleY: y == null ? x : y
	      })
	    }
	    // Translate
	  , translate: function(x, y) {
	      return this.transform({
	        x: x
	      , y: y
	      })
	    }
	    // Matrix
	  , matrix: function(m) {
	      return this.transform({ matrix: m })
	    }
	    // Opacity
	  , opacity: function(value) {
	      return this.attr('opacity', value)
	    }
	  
	  })
	  
	  SVG.extend(SVG.Rect, SVG.Ellipse, SVG.FX, {
	    // Add x and y radius
	    radius: function(x, y) {
	      return this.attr({ rx: x, ry: y || x })
	    }
	  
	  })
	  
	  SVG.extend(SVG.Path, {
	    // Get path length
	    length: function() {
	      return this.node.getTotalLength()
	    }
	    // Get point at length
	  , pointAt: function(length) {
	      return this.node.getPointAtLength(length)
	    }
	  
	  })
	  
	  SVG.extend(SVG.Parent, SVG.Text, SVG.FX, {
	    // Set font 
	    font: function(o) {
	      for (var k in o)
	        k == 'leading' ?
	          this.leading(o[k]) :
	        k == 'anchor' ?
	          this.attr('text-anchor', o[k]) :
	        k == 'size' || k == 'family' || k == 'weight' || k == 'stretch' || k == 'variant' || k == 'style' ?
	          this.attr('font-'+ k, o[k]) :
	          this.attr(k, o[k])
	      
	      return this
	    }
	    
	  })
	  
	
	
	  SVG.Set = SVG.invent({
	    // Initialize
	    create: function() {
	      /* set initial state */
	      this.clear()
	    }
	  
	    // Add class methods
	  , extend: {
	      // Add element to set
	      add: function() {
	        var i, il, elements = [].slice.call(arguments)
	  
	        for (i = 0, il = elements.length; i < il; i++)
	          this.members.push(elements[i])
	        
	        return this
	      }
	      // Remove element from set
	    , remove: function(element) {
	        var i = this.index(element)
	        
	        /* remove given child */
	        if (i > -1)
	          this.members.splice(i, 1)
	  
	        return this
	      }
	      // Iterate over all members
	    , each: function(block) {
	        for (var i = 0, il = this.members.length; i < il; i++)
	          block.apply(this.members[i], [i, this.members])
	  
	        return this
	      }
	      // Restore to defaults
	    , clear: function() {
	        /* initialize store */
	        this.members = []
	  
	        return this
	      }
	      // Checks if a given element is present in set
	    , has: function(element) {
	        return this.index(element) >= 0
	      }
	      // retuns index of given element in set
	    , index: function(element) {
	        return this.members.indexOf(element)
	      }
	      // Get member at given index
	    , get: function(i) {
	        return this.members[i]
	      }
	      // Get first member
	    , first: function() {
	        return this.get(0)
	      }
	      // Get last member
	    , last: function() {
	        return this.get(this.members.length - 1)
	      }
	      // Default value
	    , valueOf: function() {
	        return this.members
	      }
	      // Get the bounding box of all members included or empty box if set has no items
	    , bbox: function(){
	        var box = new SVG.BBox()
	  
	        /* return an empty box of there are no members */
	        if (this.members.length == 0)
	          return box
	  
	        /* get the first rbox and update the target bbox */
	        var rbox = this.members[0].rbox()
	        box.x      = rbox.x
	        box.y      = rbox.y
	        box.width  = rbox.width
	        box.height = rbox.height
	  
	        this.each(function() {
	          /* user rbox for correct position and visual representation */
	          box = box.merge(this.rbox())
	        })
	  
	        return box
	      }
	    }
	    
	    // Add parent method
	  , construct: {
	      // Create a new set
	      set: function() {
	        return new SVG.Set
	      }
	    }
	  })
	  
	  SVG.SetFX = SVG.invent({
	    // Initialize node
	    create: function(set) {
	      /* store reference to set */
	      this.set = set
	    }
	  
	  })
	  
	  // Alias methods
	  SVG.Set.inherit = function() {
	    var m
	      , methods = []
	    
	    /* gather shape methods */
	    for(var m in SVG.Shape.prototype)
	      if (typeof SVG.Shape.prototype[m] == 'function' && typeof SVG.Set.prototype[m] != 'function')
	        methods.push(m)
	  
	    /* apply shape aliasses */
	    methods.forEach(function(method) {
	      SVG.Set.prototype[method] = function() {
	        for (var i = 0, il = this.members.length; i < il; i++)
	          if (this.members[i] && typeof this.members[i][method] == 'function')
	            this.members[i][method].apply(this.members[i], arguments)
	  
	        return method == 'animate' ? (this.fx || (this.fx = new SVG.SetFX(this))) : this
	      }
	    })
	  
	    /* clear methods for the next round */
	    methods = []
	  
	    /* gather fx methods */
	    for(var m in SVG.FX.prototype)
	      if (typeof SVG.FX.prototype[m] == 'function' && typeof SVG.SetFX.prototype[m] != 'function')
	        methods.push(m)
	  
	    /* apply fx aliasses */
	    methods.forEach(function(method) {
	      SVG.SetFX.prototype[method] = function() {
	        for (var i = 0, il = this.set.members.length; i < il; i++)
	          this.set.members[i].fx[method].apply(this.set.members[i].fx, arguments)
	  
	        return this
	      }
	    })
	  }
	  
	  
	
	
	  SVG.extend(SVG.Element, {
	  	// Store data values on svg nodes
	    data: function(a, v, r) {
	    	if (typeof a == 'object') {
	    		for (v in a)
	    			this.data(v, a[v])
	  
	      } else if (arguments.length < 2) {
	        try {
	          return JSON.parse(this.attr('data-' + a))
	        } catch(e) {
	          return this.attr('data-' + a)
	        }
	        
	      } else {
	        this.attr(
	          'data-' + a
	        , v === null ?
	            null :
	          r === true || typeof v === 'string' || typeof v === 'number' ?
	            v :
	            JSON.stringify(v)
	        )
	      }
	      
	      return this
	    }
	  })
	
	  SVG.extend(SVG.Element, {
	    // Remember arbitrary data
	    remember: function(k, v) {
	      /* remember every item in an object individually */
	      if (typeof arguments[0] == 'object')
	        for (var v in k)
	          this.remember(v, k[v])
	  
	      /* retrieve memory */
	      else if (arguments.length == 1)
	        return this.memory()[k]
	  
	      /* store memory */
	      else
	        this.memory()[k] = v
	  
	      return this
	    }
	  
	    // Erase a given memory
	  , forget: function() {
	      if (arguments.length == 0)
	        this._memory = {}
	      else
	        for (var i = arguments.length - 1; i >= 0; i--)
	          delete this.memory()[arguments[i]]
	  
	      return this
	    }
	  
	    // Initialize or return local memory object
	  , memory: function() {
	      return this._memory || (this._memory = {})
	    }
	  
	  })
	
	  if (true)
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return SVG }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
	  else if (typeof exports !== 'undefined')
	    exports.SVG = SVG
	
	  function camelCase(s) { 
	    return s.toLowerCase().replace(/-(.)/g, function(m, g) {
	      return g.toUpperCase()
	    })
	  }
	  
	  // Ensure to six-based hex 
	  function fullHex(hex) {
	    return hex.length == 4 ?
	      [ '#',
	        hex.substring(1, 2), hex.substring(1, 2)
	      , hex.substring(2, 3), hex.substring(2, 3)
	      , hex.substring(3, 4), hex.substring(3, 4)
	      ].join('') : hex
	  }
	  
	  // Component to hex value
	  function compToHex(comp) {
	    var hex = comp.toString(16)
	    return hex.length == 1 ? '0' + hex : hex
	  }
	  
	  // Calculate proportional width and height values when necessary
	  function proportionalSize(box, width, height) {
	    if (width == null || height == null) {
	      if (height == null)
	        height = box.height / box.width * width
	      else if (width == null)
	        width = box.width / box.height * height
	    }
	    
	    return {
	      width:  width
	    , height: height
	    }
	  }
	  
	  // Calculate position according to from and to
	  function at(o, pos) {
	    /* number recalculation (don't bother converting to SVG.Number for performance reasons) */
	    return typeof o.from == 'number' ?
	      o.from + (o.to - o.from) * pos :
	    
	    /* instance recalculation */
	    o instanceof SVG.Color || o instanceof SVG.Number ? o.at(pos) :
	    
	    /* for all other values wait until pos has reached 1 to return the final value */
	    pos < 1 ? o.from : o.to
	  }
	  
	  // PathArray Helpers
	  function arrayToString(a) {
	    for (var i = 0, il = a.length, s = ''; i < il; i++) {
	      s += a[i][0]
	  
	      if (a[i][1] != null) {
	        s += a[i][1]
	  
	        if (a[i][2] != null) {
	          s += ' '
	          s += a[i][2]
	  
	          if (a[i][3] != null) {
	            s += ' '
	            s += a[i][3]
	            s += ' '
	            s += a[i][4]
	  
	            if (a[i][5] != null) {
	              s += ' '
	              s += a[i][5]
	              s += ' '
	              s += a[i][6]
	  
	              if (a[i][7] != null) {
	                s += ' '
	                s += a[i][7]
	              }
	            }
	          }
	        }
	      }
	    }
	    
	    return s + ' '
	  }
	  
	  // Add more bounding box properties
	  function boxProperties(b) {
	    b.x2 = b.x + b.width
	    b.y2 = b.y + b.height
	    b.cx = b.x + b.width / 2
	    b.cy = b.y + b.height / 2
	  }
	  
	  // Parse a matrix string
	  function parseMatrix(o) {
	    if (o.matrix) {
	      /* split matrix string */
	      var m = o.matrix.replace(/\s/g, '').split(',')
	      
	      /* pasrse values */
	      if (m.length == 6) {
	        o.a = parseFloat(m[0])
	        o.b = parseFloat(m[1])
	        o.c = parseFloat(m[2])
	        o.d = parseFloat(m[3])
	        o.e = parseFloat(m[4])
	        o.f = parseFloat(m[5])
	      }
	    }
	    
	    return o
	  }
	  
	  // Get id from reference string
	  function idFromReference(url) {
	    var m = url.toString().match(SVG.regex.reference)
	  
	    if (m) return m[1]
	  }
	  
	  // Shim layer with setTimeout fallback by Paul Irish
	  window.requestAnimFrame = (function(){
	    return  window.requestAnimationFrame       ||
	            window.webkitRequestAnimationFrame ||
	            window.mozRequestAnimationFrame    ||
	            window.msRequestAnimationFrame     ||
	            function (c) { window.setTimeout(c, 1000 / 60) }
	  })()
	
	  return SVG
	}));


/***/ },
/* 8 */,
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global, process) {// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.
	
	;(function (undefined) {
	
	  var objectTypes = {
	    'boolean': false,
	    'function': true,
	    'object': true,
	    'number': false,
	    'string': false,
	    'undefined': false
	  };
	
	  var root = (objectTypes[typeof window] && window) || this,
	    freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
	    freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
	    moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
	    freeGlobal = objectTypes[typeof global] && global;
	
	  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
	    root = freeGlobal;
	  }
	
	  var Rx = {
	      internals: {},
	      config: {
	        Promise: root.Promise // Detect if promise exists
	      },
	      helpers: { }
	  };
	
	  // Defaults
	  var noop = Rx.helpers.noop = function () { },
	    notDefined = Rx.helpers.notDefined = function (x) { return typeof x === 'undefined'; },
	    isScheduler = Rx.helpers.isScheduler = function (x) { return x instanceof Rx.Scheduler; },
	    identity = Rx.helpers.identity = function (x) { return x; },
	    pluck = Rx.helpers.pluck = function (property) { return function (x) { return x[property]; }; },
	    just = Rx.helpers.just = function (value) { return function () { return value; }; },
	    defaultNow = Rx.helpers.defaultNow = Date.now,
	    defaultComparer = Rx.helpers.defaultComparer = function (x, y) { return isEqual(x, y); },
	    defaultSubComparer = Rx.helpers.defaultSubComparer = function (x, y) { return x > y ? 1 : (x < y ? -1 : 0); },
	    defaultKeySerializer = Rx.helpers.defaultKeySerializer = function (x) { return x.toString(); },
	    defaultError = Rx.helpers.defaultError = function (err) { throw err; },
	    isPromise = Rx.helpers.isPromise = function (p) { return !!p && typeof p.then === 'function'; },
	    asArray = Rx.helpers.asArray = function () { return Array.prototype.slice.call(arguments); },
	    not = Rx.helpers.not = function (a) { return !a; },
	    isFunction = Rx.helpers.isFunction = (function () {
	
	      var isFn = function (value) {
	        return typeof value == 'function' || false;
	      }
	
	      // fallback for older versions of Chrome and Safari
	      if (isFn(/x/)) {
	        isFn = function(value) {
	          return typeof value == 'function' && toString.call(value) == '[object Function]';
	        };
	      }
	
	      return isFn;
	    }());
	
	  // Errors
	  var sequenceContainsNoElements = 'Sequence contains no elements.';
	  var argumentOutOfRange = 'Argument out of range';
	  var objectDisposed = 'Object has been disposed';
	  function checkDisposed() { if (this.isDisposed) { throw new Error(objectDisposed); } }
	
	  // Shim in iterator support
	  var $iterator$ = (typeof Symbol === 'function' && Symbol.iterator) ||
	    '_es6shim_iterator_';
	  // Bug for mozilla version
	  if (root.Set && typeof new root.Set()['@@iterator'] === 'function') {
	    $iterator$ = '@@iterator';
	  }
	
	  var doneEnumerator = Rx.doneEnumerator = { done: true, value: undefined };
	
	  Rx.iterator = $iterator$;
	
	  /** `Object#toString` result shortcuts */
	  var argsClass = '[object Arguments]',
	    arrayClass = '[object Array]',
	    boolClass = '[object Boolean]',
	    dateClass = '[object Date]',
	    errorClass = '[object Error]',
	    funcClass = '[object Function]',
	    numberClass = '[object Number]',
	    objectClass = '[object Object]',
	    regexpClass = '[object RegExp]',
	    stringClass = '[object String]';
	
	  var toString = Object.prototype.toString,
	    hasOwnProperty = Object.prototype.hasOwnProperty,
	    supportsArgsClass = toString.call(arguments) == argsClass, // For less <IE9 && FF<4
	    suportNodeClass,
	    errorProto = Error.prototype,
	    objectProto = Object.prototype,
	    propertyIsEnumerable = objectProto.propertyIsEnumerable;
	
	  try {
	    suportNodeClass = !(toString.call(document) == objectClass && !({ 'toString': 0 } + ''));
	  } catch(e) {
	    suportNodeClass = true;
	  }
	
	  var shadowedProps = [
	    'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'
	  ];
	
	  var nonEnumProps = {};
	  nonEnumProps[arrayClass] = nonEnumProps[dateClass] = nonEnumProps[numberClass] = { 'constructor': true, 'toLocaleString': true, 'toString': true, 'valueOf': true };
	  nonEnumProps[boolClass] = nonEnumProps[stringClass] = { 'constructor': true, 'toString': true, 'valueOf': true };
	  nonEnumProps[errorClass] = nonEnumProps[funcClass] = nonEnumProps[regexpClass] = { 'constructor': true, 'toString': true };
	  nonEnumProps[objectClass] = { 'constructor': true };
	
	  var support = {};
	  (function () {
	    var ctor = function() { this.x = 1; },
	      props = [];
	
	    ctor.prototype = { 'valueOf': 1, 'y': 1 };
	    for (var key in new ctor) { props.push(key); }
	    for (key in arguments) { }
	
	    // Detect if `name` or `message` properties of `Error.prototype` are enumerable by default.
	    support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') || propertyIsEnumerable.call(errorProto, 'name');
	
	    // Detect if `prototype` properties are enumerable by default.
	    support.enumPrototypes = propertyIsEnumerable.call(ctor, 'prototype');
	
	    // Detect if `arguments` object indexes are non-enumerable
	    support.nonEnumArgs = key != 0;
	
	    // Detect if properties shadowing those on `Object.prototype` are non-enumerable.
	    support.nonEnumShadows = !/valueOf/.test(props);
	  }(1));
	
	  function isObject(value) {
	    // check if the value is the ECMAScript language type of Object
	    // http://es5.github.io/#x8
	    // and avoid a V8 bug
	    // https://code.google.com/p/v8/issues/detail?id=2291
	    var type = typeof value;
	    return value && (type == 'function' || type == 'object') || false;
	  }
	
	  function keysIn(object) {
	    var result = [];
	    if (!isObject(object)) {
	      return result;
	    }
	    if (support.nonEnumArgs && object.length && isArguments(object)) {
	      object = slice.call(object);
	    }
	    var skipProto = support.enumPrototypes && typeof object == 'function',
	        skipErrorProps = support.enumErrorProps && (object === errorProto || object instanceof Error);
	
	    for (var key in object) {
	      if (!(skipProto && key == 'prototype') &&
	          !(skipErrorProps && (key == 'message' || key == 'name'))) {
	        result.push(key);
	      }
	    }
	
	    if (support.nonEnumShadows && object !== objectProto) {
	      var ctor = object.constructor,
	          index = -1,
	          length = shadowedProps.length;
	
	      if (object === (ctor && ctor.prototype)) {
	        var className = object === stringProto ? stringClass : object === errorProto ? errorClass : toString.call(object),
	            nonEnum = nonEnumProps[className];
	      }
	      while (++index < length) {
	        key = shadowedProps[index];
	        if (!(nonEnum && nonEnum[key]) && hasOwnProperty.call(object, key)) {
	          result.push(key);
	        }
	      }
	    }
	    return result;
	  }
	
	  function internalFor(object, callback, keysFunc) {
	    var index = -1,
	      props = keysFunc(object),
	      length = props.length;
	
	    while (++index < length) {
	      var key = props[index];
	      if (callback(object[key], key, object) === false) {
	        break;
	      }
	    }
	    return object;
	  }
	
	  function internalForIn(object, callback) {
	    return internalFor(object, callback, keysIn);
	  }
	
	  function isNode(value) {
	    // IE < 9 presents DOM nodes as `Object` objects except they have `toString`
	    // methods that are `typeof` "string" and still can coerce nodes to strings
	    return typeof value.toString != 'function' && typeof (value + '') == 'string';
	  }
	
	  function isArguments(value) {
	    return (value && typeof value == 'object') ? toString.call(value) == argsClass : false;
	  }
	
	  // fallback for browsers that can't detect `arguments` objects by [[Class]]
	  if (!supportsArgsClass) {
	    isArguments = function(value) {
	      return (value && typeof value == 'object') ? hasOwnProperty.call(value, 'callee') : false;
	    };
	  }
	
	  var isEqual = Rx.internals.isEqual = function (x, y) {
	    return deepEquals(x, y, [], []);
	  };
	
	  /** @private
	   * Used for deep comparison
	   **/
	  function deepEquals(a, b, stackA, stackB) {
	    // exit early for identical values
	    if (a === b) {
	      // treat `+0` vs. `-0` as not equal
	      return a !== 0 || (1 / a == 1 / b);
	    }
	
	    var type = typeof a,
	        otherType = typeof b;
	
	    // exit early for unlike primitive values
	    if (a === a && (a == null || b == null ||
	        (type != 'function' && type != 'object' && otherType != 'function' && otherType != 'object'))) {
	      return false;
	    }
	
	    // compare [[Class]] names
	    var className = toString.call(a),
	        otherClass = toString.call(b);
	
	    if (className == argsClass) {
	      className = objectClass;
	    }
	    if (otherClass == argsClass) {
	      otherClass = objectClass;
	    }
	    if (className != otherClass) {
	      return false;
	    }
	    switch (className) {
	      case boolClass:
	      case dateClass:
	        // coerce dates and booleans to numbers, dates to milliseconds and booleans
	        // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
	        return +a == +b;
	
	      case numberClass:
	        // treat `NaN` vs. `NaN` as equal
	        return (a != +a)
	          ? b != +b
	          // but treat `-0` vs. `+0` as not equal
	          : (a == 0 ? (1 / a == 1 / b) : a == +b);
	
	      case regexpClass:
	      case stringClass:
	        // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
	        // treat string primitives and their corresponding object instances as equal
	        return a == String(b);
	    }
	    var isArr = className == arrayClass;
	    if (!isArr) {
	
	      // exit for functions and DOM nodes
	      if (className != objectClass || (!support.nodeClass && (isNode(a) || isNode(b)))) {
	        return false;
	      }
	      // in older versions of Opera, `arguments` objects have `Array` constructors
	      var ctorA = !support.argsObject && isArguments(a) ? Object : a.constructor,
	          ctorB = !support.argsObject && isArguments(b) ? Object : b.constructor;
	
	      // non `Object` object instances with different constructors are not equal
	      if (ctorA != ctorB &&
	            !(hasOwnProperty.call(a, 'constructor') && hasOwnProperty.call(b, 'constructor')) &&
	            !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
	            ('constructor' in a && 'constructor' in b)
	          ) {
	        return false;
	      }
	    }
	    // assume cyclic structures are equal
	    // the algorithm for detecting cyclic structures is adapted from ES 5.1
	    // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
	    var initedStack = !stackA;
	    stackA || (stackA = []);
	    stackB || (stackB = []);
	
	    var length = stackA.length;
	    while (length--) {
	      if (stackA[length] == a) {
	        return stackB[length] == b;
	      }
	    }
	    var size = 0;
	    var result = true;
	
	    // add `a` and `b` to the stack of traversed objects
	    stackA.push(a);
	    stackB.push(b);
	
	    // recursively compare objects and arrays (susceptible to call stack limits)
	    if (isArr) {
	      // compare lengths to determine if a deep comparison is necessary
	      length = a.length;
	      size = b.length;
	      result = size == length;
	
	      if (result) {
	        // deep compare the contents, ignoring non-numeric properties
	        while (size--) {
	          var index = length,
	              value = b[size];
	
	          if (!(result = deepEquals(a[size], value, stackA, stackB))) {
	            break;
	          }
	        }
	      }
	    }
	    else {
	      // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
	      // which, in this case, is more costly
	      internalForIn(b, function(value, key, b) {
	        if (hasOwnProperty.call(b, key)) {
	          // count the number of properties.
	          size++;
	          // deep compare each property value.
	          return (result = hasOwnProperty.call(a, key) && deepEquals(a[key], value, stackA, stackB));
	        }
	      });
	
	      if (result) {
	        // ensure both objects have the same number of properties
	        internalForIn(a, function(value, key, a) {
	          if (hasOwnProperty.call(a, key)) {
	            // `size` will be `-1` if `a` has more properties than `b`
	            return (result = --size > -1);
	          }
	        });
	      }
	    }
	    stackA.pop();
	    stackB.pop();
	
	    return result;
	  }
	
	  var slice = Array.prototype.slice;
	  function argsOrArray(args, idx) {
	    return args.length === 1 && Array.isArray(args[idx]) ?
	      args[idx] :
	      slice.call(args);
	  }
	  var hasProp = {}.hasOwnProperty;
	
	  var inherits = this.inherits = Rx.internals.inherits = function (child, parent) {
	    function __() { this.constructor = child; }
	    __.prototype = parent.prototype;
	    child.prototype = new __();
	  };
	
	  var addProperties = Rx.internals.addProperties = function (obj) {
	    var sources = slice.call(arguments, 1);
	    for (var i = 0, len = sources.length; i < len; i++) {
	      var source = sources[i];
	      for (var prop in source) {
	        obj[prop] = source[prop];
	      }
	    }
	  };
	
	  // Rx Utils
	  var addRef = Rx.internals.addRef = function (xs, r) {
	    return new AnonymousObservable(function (observer) {
	      return new CompositeDisposable(r.getDisposable(), xs.subscribe(observer));
	    });
	  };
	
	  function arrayInitialize(count, factory) {
	    var a = new Array(count);
	    for (var i = 0; i < count; i++) {
	      a[i] = factory();
	    }
	    return a;
	  }
	
	  // Collections
	  function IndexedItem(id, value) {
	    this.id = id;
	    this.value = value;
	  }
	
	  IndexedItem.prototype.compareTo = function (other) {
	    var c = this.value.compareTo(other.value);
	    c === 0 && (c = this.id - other.id);
	    return c;
	  };
	
	  // Priority Queue for Scheduling
	  var PriorityQueue = Rx.internals.PriorityQueue = function (capacity) {
	    this.items = new Array(capacity);
	    this.length = 0;
	  };
	
	  var priorityProto = PriorityQueue.prototype;
	  priorityProto.isHigherPriority = function (left, right) {
	    return this.items[left].compareTo(this.items[right]) < 0;
	  };
	
	  priorityProto.percolate = function (index) {
	    if (index >= this.length || index < 0) { return; }
	    var parent = index - 1 >> 1;
	    if (parent < 0 || parent === index) { return; }
	    if (this.isHigherPriority(index, parent)) {
	      var temp = this.items[index];
	      this.items[index] = this.items[parent];
	      this.items[parent] = temp;
	      this.percolate(parent);
	    }
	  };
	
	  priorityProto.heapify = function (index) {
	    +index || (index = 0);
	    if (index >= this.length || index < 0) { return; }
	    var left = 2 * index + 1,
	        right = 2 * index + 2,
	        first = index;
	    if (left < this.length && this.isHigherPriority(left, first)) {
	      first = left;
	    }
	    if (right < this.length && this.isHigherPriority(right, first)) {
	      first = right;
	    }
	    if (first !== index) {
	      var temp = this.items[index];
	      this.items[index] = this.items[first];
	      this.items[first] = temp;
	      this.heapify(first);
	    }
	  };
	
	  priorityProto.peek = function () { return this.items[0].value; };
	
	  priorityProto.removeAt = function (index) {
	    this.items[index] = this.items[--this.length];
	    delete this.items[this.length];
	    this.heapify();
	  };
	
	  priorityProto.dequeue = function () {
	    var result = this.peek();
	    this.removeAt(0);
	    return result;
	  };
	
	  priorityProto.enqueue = function (item) {
	    var index = this.length++;
	    this.items[index] = new IndexedItem(PriorityQueue.count++, item);
	    this.percolate(index);
	  };
	
	  priorityProto.remove = function (item) {
	    for (var i = 0; i < this.length; i++) {
	      if (this.items[i].value === item) {
	        this.removeAt(i);
	        return true;
	      }
	    }
	    return false;
	  };
	  PriorityQueue.count = 0;
	
	  /**
	   * Represents a group of disposable resources that are disposed together.
	   * @constructor
	   */
	  var CompositeDisposable = Rx.CompositeDisposable = function () {
	    this.disposables = argsOrArray(arguments, 0);
	    this.isDisposed = false;
	    this.length = this.disposables.length;
	  };
	
	  var CompositeDisposablePrototype = CompositeDisposable.prototype;
	
	  /**
	   * Adds a disposable to the CompositeDisposable or disposes the disposable if the CompositeDisposable is disposed.
	   * @param {Mixed} item Disposable to add.
	   */
	  CompositeDisposablePrototype.add = function (item) {
	    if (this.isDisposed) {
	      item.dispose();
	    } else {
	      this.disposables.push(item);
	      this.length++;
	    }
	  };
	
	  /**
	   * Removes and disposes the first occurrence of a disposable from the CompositeDisposable.
	   * @param {Mixed} item Disposable to remove.
	   * @returns {Boolean} true if found; false otherwise.
	   */
	  CompositeDisposablePrototype.remove = function (item) {
	    var shouldDispose = false;
	    if (!this.isDisposed) {
	      var idx = this.disposables.indexOf(item);
	      if (idx !== -1) {
	        shouldDispose = true;
	        this.disposables.splice(idx, 1);
	        this.length--;
	        item.dispose();
	      }
	    }
	    return shouldDispose;
	  };
	
	  /**
	   *  Disposes all disposables in the group and removes them from the group.
	   */
	  CompositeDisposablePrototype.dispose = function () {
	    if (!this.isDisposed) {
	      this.isDisposed = true;
	      var currentDisposables = this.disposables.slice(0);
	      this.disposables = [];
	      this.length = 0;
	
	      for (var i = 0, len = currentDisposables.length; i < len; i++) {
	        currentDisposables[i].dispose();
	      }
	    }
	  };
	
	  /**
	   * Converts the existing CompositeDisposable to an array of disposables
	   * @returns {Array} An array of disposable objects.
	   */
	  CompositeDisposablePrototype.toArray = function () {
	    return this.disposables.slice(0);
	  };
	
	  /**
	   * Provides a set of static methods for creating Disposables.
	   *
	   * @constructor
	   * @param {Function} dispose Action to run during the first call to dispose. The action is guaranteed to be run at most once.
	   */
	  var Disposable = Rx.Disposable = function (action) {
	    this.isDisposed = false;
	    this.action = action || noop;
	  };
	
	  /** Performs the task of cleaning up resources. */
	  Disposable.prototype.dispose = function () {
	    if (!this.isDisposed) {
	      this.action();
	      this.isDisposed = true;
	    }
	  };
	
	  /**
	   * Creates a disposable object that invokes the specified action when disposed.
	   * @param {Function} dispose Action to run during the first call to dispose. The action is guaranteed to be run at most once.
	   * @return {Disposable} The disposable object that runs the given action upon disposal.
	   */
	  var disposableCreate = Disposable.create = function (action) { return new Disposable(action); };
	
	  /**
	   * Gets the disposable that does nothing when disposed.
	   */
	  var disposableEmpty = Disposable.empty = { dispose: noop };
	
	  var SingleAssignmentDisposable = Rx.SingleAssignmentDisposable = (function () {
	    function BooleanDisposable () {
	      this.isDisposed = false;
	      this.current = null;
	    }
	
	    var booleanDisposablePrototype = BooleanDisposable.prototype;
	
	    /**
	     * Gets the underlying disposable.
	     * @return The underlying disposable.
	     */
	    booleanDisposablePrototype.getDisposable = function () {
	      return this.current;
	    };
	
	    /**
	     * Sets the underlying disposable.
	     * @param {Disposable} value The new underlying disposable.
	     */
	    booleanDisposablePrototype.setDisposable = function (value) {
	      var shouldDispose = this.isDisposed, old;
	      if (!shouldDispose) {
	        old = this.current;
	        this.current = value;
	      }
	      old && old.dispose();
	      shouldDispose && value && value.dispose();
	    };
	
	    /**
	     * Disposes the underlying disposable as well as all future replacements.
	     */
	    booleanDisposablePrototype.dispose = function () {
	      var old;
	      if (!this.isDisposed) {
	        this.isDisposed = true;
	        old = this.current;
	        this.current = null;
	      }
	      old && old.dispose();
	    };
	
	    return BooleanDisposable;
	  }());
	  var SerialDisposable = Rx.SerialDisposable = SingleAssignmentDisposable;
	
	    /**
	     * Represents a disposable resource that only disposes its underlying disposable resource when all dependent disposable objects have been disposed.
	     */
	    var RefCountDisposable = Rx.RefCountDisposable = (function () {
	
	        function InnerDisposable(disposable) {
	            this.disposable = disposable;
	            this.disposable.count++;
	            this.isInnerDisposed = false;
	        }
	
	        InnerDisposable.prototype.dispose = function () {
	            if (!this.disposable.isDisposed) {
	                if (!this.isInnerDisposed) {
	                    this.isInnerDisposed = true;
	                    this.disposable.count--;
	                    if (this.disposable.count === 0 && this.disposable.isPrimaryDisposed) {
	                        this.disposable.isDisposed = true;
	                        this.disposable.underlyingDisposable.dispose();
	                    }
	                }
	            }
	        };
	
	        /**
	         * Initializes a new instance of the RefCountDisposable with the specified disposable.
	         * @constructor
	         * @param {Disposable} disposable Underlying disposable.
	          */
	        function RefCountDisposable(disposable) {
	            this.underlyingDisposable = disposable;
	            this.isDisposed = false;
	            this.isPrimaryDisposed = false;
	            this.count = 0;
	        }
	
	        /**
	         * Disposes the underlying disposable only when all dependent disposables have been disposed
	         */
	        RefCountDisposable.prototype.dispose = function () {
	            if (!this.isDisposed) {
	                if (!this.isPrimaryDisposed) {
	                    this.isPrimaryDisposed = true;
	                    if (this.count === 0) {
	                        this.isDisposed = true;
	                        this.underlyingDisposable.dispose();
	                    }
	                }
	            }
	        };
	
	        /**
	         * Returns a dependent disposable that when disposed decreases the refcount on the underlying disposable.
	         * @returns {Disposable} A dependent disposable contributing to the reference count that manages the underlying disposable's lifetime.
	         */
	        RefCountDisposable.prototype.getDisposable = function () {
	            return this.isDisposed ? disposableEmpty : new InnerDisposable(this);
	        };
	
	        return RefCountDisposable;
	    })();
	
	    function ScheduledDisposable(scheduler, disposable) {
	        this.scheduler = scheduler;
	        this.disposable = disposable;
	        this.isDisposed = false;
	    }
	
	    ScheduledDisposable.prototype.dispose = function () {
	        var parent = this;
	        this.scheduler.schedule(function () {
	            if (!parent.isDisposed) {
	                parent.isDisposed = true;
	                parent.disposable.dispose();
	            }
	        });
	    };
	
	  var ScheduledItem = Rx.internals.ScheduledItem = function (scheduler, state, action, dueTime, comparer) {
	    this.scheduler = scheduler;
	    this.state = state;
	    this.action = action;
	    this.dueTime = dueTime;
	    this.comparer = comparer || defaultSubComparer;
	    this.disposable = new SingleAssignmentDisposable();
	  }
	
	  ScheduledItem.prototype.invoke = function () {
	    this.disposable.setDisposable(this.invokeCore());
	  };
	
	  ScheduledItem.prototype.compareTo = function (other) {
	    return this.comparer(this.dueTime, other.dueTime);
	  };
	
	  ScheduledItem.prototype.isCancelled = function () {
	    return this.disposable.isDisposed;
	  };
	
	  ScheduledItem.prototype.invokeCore = function () {
	    return this.action(this.scheduler, this.state);
	  };
	
	  /** Provides a set of static properties to access commonly used schedulers. */
	  var Scheduler = Rx.Scheduler = (function () {
	
	    function Scheduler(now, schedule, scheduleRelative, scheduleAbsolute) {
	      this.now = now;
	      this._schedule = schedule;
	      this._scheduleRelative = scheduleRelative;
	      this._scheduleAbsolute = scheduleAbsolute;
	    }
	
	    function invokeAction(scheduler, action) {
	      action();
	      return disposableEmpty;
	    }
	
	    var schedulerProto = Scheduler.prototype;
	
	    /**
	     * Schedules an action to be executed.
	     * @param {Function} action Action to execute.
	     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
	     */
	    schedulerProto.schedule = function (action) {
	      return this._schedule(action, invokeAction);
	    };
	
	    /**
	     * Schedules an action to be executed.
	     * @param state State passed to the action to be executed.
	     * @param {Function} action Action to be executed.
	     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
	     */
	    schedulerProto.scheduleWithState = function (state, action) {
	      return this._schedule(state, action);
	    };
	
	    /**
	     * Schedules an action to be executed after the specified relative due time.
	     * @param {Function} action Action to execute.
	     * @param {Number} dueTime Relative time after which to execute the action.
	     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
	     */
	    schedulerProto.scheduleWithRelative = function (dueTime, action) {
	      return this._scheduleRelative(action, dueTime, invokeAction);
	    };
	
	    /**
	     * Schedules an action to be executed after dueTime.
	     * @param state State passed to the action to be executed.
	     * @param {Function} action Action to be executed.
	     * @param {Number} dueTime Relative time after which to execute the action.
	     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
	     */
	    schedulerProto.scheduleWithRelativeAndState = function (state, dueTime, action) {
	      return this._scheduleRelative(state, dueTime, action);
	    };
	
	    /**
	     * Schedules an action to be executed at the specified absolute due time.
	     * @param {Function} action Action to execute.
	     * @param {Number} dueTime Absolute time at which to execute the action.
	     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
	      */
	    schedulerProto.scheduleWithAbsolute = function (dueTime, action) {
	      return this._scheduleAbsolute(action, dueTime, invokeAction);
	    };
	
	    /**
	     * Schedules an action to be executed at dueTime.
	     * @param {Mixed} state State passed to the action to be executed.
	     * @param {Function} action Action to be executed.
	     * @param {Number}dueTime Absolute time at which to execute the action.
	     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
	     */
	    schedulerProto.scheduleWithAbsoluteAndState = function (state, dueTime, action) {
	      return this._scheduleAbsolute(state, dueTime, action);
	    };
	
	    /** Gets the current time according to the local machine's system clock. */
	    Scheduler.now = defaultNow;
	
	    /**
	     * Normalizes the specified TimeSpan value to a positive value.
	     * @param {Number} timeSpan The time span value to normalize.
	     * @returns {Number} The specified TimeSpan value if it is zero or positive; otherwise, 0
	     */
	    Scheduler.normalize = function (timeSpan) {
	      timeSpan < 0 && (timeSpan = 0);
	      return timeSpan;
	    };
	
	    return Scheduler;
	  }());
	
	  var normalizeTime = Scheduler.normalize;
	
	  (function (schedulerProto) {
	    function invokeRecImmediate(scheduler, pair) {
	      var state = pair.first, action = pair.second, group = new CompositeDisposable(),
	      recursiveAction = function (state1) {
	        action(state1, function (state2) {
	          var isAdded = false, isDone = false,
	          d = scheduler.scheduleWithState(state2, function (scheduler1, state3) {
	            if (isAdded) {
	              group.remove(d);
	            } else {
	              isDone = true;
	            }
	            recursiveAction(state3);
	            return disposableEmpty;
	          });
	          if (!isDone) {
	            group.add(d);
	            isAdded = true;
	          }
	        });
	      };
	      recursiveAction(state);
	      return group;
	    }
	
	    function invokeRecDate(scheduler, pair, method) {
	      var state = pair.first, action = pair.second, group = new CompositeDisposable(),
	      recursiveAction = function (state1) {
	        action(state1, function (state2, dueTime1) {
	          var isAdded = false, isDone = false,
	          d = scheduler[method].call(scheduler, state2, dueTime1, function (scheduler1, state3) {
	            if (isAdded) {
	              group.remove(d);
	            } else {
	              isDone = true;
	            }
	            recursiveAction(state3);
	            return disposableEmpty;
	          });
	          if (!isDone) {
	            group.add(d);
	            isAdded = true;
	          }
	        });
	      };
	      recursiveAction(state);
	      return group;
	    }
	
	    function scheduleInnerRecursive(action, self) {
	      action(function(dt) { self(action, dt); });
	    }
	
	    /**
	     * Schedules an action to be executed recursively.
	     * @param {Function} action Action to execute recursively. The parameter passed to the action is used to trigger recursive scheduling of the action.
	     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
	     */
	    schedulerProto.scheduleRecursive = function (action) {
	      return this.scheduleRecursiveWithState(action, function (_action, self) {
	        _action(function () { self(_action); }); });
	    };
	
	    /**
	     * Schedules an action to be executed recursively.
	     * @param {Mixed} state State passed to the action to be executed.
	     * @param {Function} action Action to execute recursively. The last parameter passed to the action is used to trigger recursive scheduling of the action, passing in recursive invocation state.
	     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
	     */
	    schedulerProto.scheduleRecursiveWithState = function (state, action) {
	      return this.scheduleWithState({ first: state, second: action }, invokeRecImmediate);
	    };
	
	    /**
	     * Schedules an action to be executed recursively after a specified relative due time.
	     * @param {Function} action Action to execute recursively. The parameter passed to the action is used to trigger recursive scheduling of the action at the specified relative time.
	     * @param {Number}dueTime Relative time after which to execute the action for the first time.
	     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
	     */
	    schedulerProto.scheduleRecursiveWithRelative = function (dueTime, action) {
	      return this.scheduleRecursiveWithRelativeAndState(action, dueTime, scheduleInnerRecursive);
	    };
	
	    /**
	     * Schedules an action to be executed recursively after a specified relative due time.
	     * @param {Mixed} state State passed to the action to be executed.
	     * @param {Function} action Action to execute recursively. The last parameter passed to the action is used to trigger recursive scheduling of the action, passing in the recursive due time and invocation state.
	     * @param {Number}dueTime Relative time after which to execute the action for the first time.
	     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
	     */
	    schedulerProto.scheduleRecursiveWithRelativeAndState = function (state, dueTime, action) {
	      return this._scheduleRelative({ first: state, second: action }, dueTime, function (s, p) {
	        return invokeRecDate(s, p, 'scheduleWithRelativeAndState');
	      });
	    };
	
	    /**
	     * Schedules an action to be executed recursively at a specified absolute due time.
	     * @param {Function} action Action to execute recursively. The parameter passed to the action is used to trigger recursive scheduling of the action at the specified absolute time.
	     * @param {Number}dueTime Absolute time at which to execute the action for the first time.
	     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
	     */
	    schedulerProto.scheduleRecursiveWithAbsolute = function (dueTime, action) {
	      return this.scheduleRecursiveWithAbsoluteAndState(action, dueTime, scheduleInnerRecursive);
	    };
	
	    /**
	     * Schedules an action to be executed recursively at a specified absolute due time.
	     * @param {Mixed} state State passed to the action to be executed.
	     * @param {Function} action Action to execute recursively. The last parameter passed to the action is used to trigger recursive scheduling of the action, passing in the recursive due time and invocation state.
	     * @param {Number}dueTime Absolute time at which to execute the action for the first time.
	     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
	     */
	    schedulerProto.scheduleRecursiveWithAbsoluteAndState = function (state, dueTime, action) {
	      return this._scheduleAbsolute({ first: state, second: action }, dueTime, function (s, p) {
	        return invokeRecDate(s, p, 'scheduleWithAbsoluteAndState');
	      });
	    };
	  }(Scheduler.prototype));
	
	  (function (schedulerProto) {
	
	    /**
	     * Schedules a periodic piece of work by dynamically discovering the scheduler's capabilities. The periodic task will be scheduled using window.setInterval for the base implementation.
	     * @param {Number} period Period for running the work periodically.
	     * @param {Function} action Action to be executed.
	     * @returns {Disposable} The disposable object used to cancel the scheduled recurring action (best effort).
	     */
	    Scheduler.prototype.schedulePeriodic = function (period, action) {
	      return this.schedulePeriodicWithState(null, period, action);
	    };
	
	    /**
	     * Schedules a periodic piece of work by dynamically discovering the scheduler's capabilities. The periodic task will be scheduled using window.setInterval for the base implementation.
	     * @param {Mixed} state Initial state passed to the action upon the first iteration.
	     * @param {Number} period Period for running the work periodically.
	     * @param {Function} action Action to be executed, potentially updating the state.
	     * @returns {Disposable} The disposable object used to cancel the scheduled recurring action (best effort).
	     */
	    Scheduler.prototype.schedulePeriodicWithState = function(state, period, action) {
	      if (typeof root.setInterval === 'undefined') { throw new Error('Periodic scheduling not supported.'); }
	      var s = state;
	
	      var id = root.setInterval(function () {
	        s = action(s);
	      }, period);
	
	      return disposableCreate(function () {
	        root.clearInterval(id);
	      });
	    };
	
	  }(Scheduler.prototype));
	
	  (function (schedulerProto) {
	    /**
	     * Returns a scheduler that wraps the original scheduler, adding exception handling for scheduled actions.
	     * @param {Function} handler Handler that's run if an exception is caught. The exception will be rethrown if the handler returns false.
	     * @returns {Scheduler} Wrapper around the original scheduler, enforcing exception handling.
	     */
	    schedulerProto.catchError = schedulerProto['catch'] = function (handler) {
	      return new CatchScheduler(this, handler);
	    };
	  }(Scheduler.prototype));
	
	  var SchedulePeriodicRecursive = Rx.internals.SchedulePeriodicRecursive = (function () {
	    function tick(command, recurse) {
	      recurse(0, this._period);
	      try {
	        this._state = this._action(this._state);
	      } catch (e) {
	        this._cancel.dispose();
	        throw e;
	      }
	    }
	
	    function SchedulePeriodicRecursive(scheduler, state, period, action) {
	      this._scheduler = scheduler;
	      this._state = state;
	      this._period = period;
	      this._action = action;
	    }
	
	    SchedulePeriodicRecursive.prototype.start = function () {
	      var d = new SingleAssignmentDisposable();
	      this._cancel = d;
	      d.setDisposable(this._scheduler.scheduleRecursiveWithRelativeAndState(0, this._period, tick.bind(this)));
	
	      return d;
	    };
	
	    return SchedulePeriodicRecursive;
	  }());
	
	  /**
	   * Gets a scheduler that schedules work immediately on the current thread.
	   */
	  var immediateScheduler = Scheduler.immediate = (function () {
	
	    function scheduleNow(state, action) { return action(this, state); }
	
	    function scheduleRelative(state, dueTime, action) {
	      var dt = normalizeTime(dt);
	      while (dt - this.now() > 0) { }
	      return action(this, state);
	    }
	
	    function scheduleAbsolute(state, dueTime, action) {
	      return this.scheduleWithRelativeAndState(state, dueTime - this.now(), action);
	    }
	
	    return new Scheduler(defaultNow, scheduleNow, scheduleRelative, scheduleAbsolute);
	  }());
	
	  /**
	   * Gets a scheduler that schedules work as soon as possible on the current thread.
	   */
	  var currentThreadScheduler = Scheduler.currentThread = (function () {
	    var queue;
	
	    function runTrampoline (q) {
	      var item;
	      while (q.length > 0) {
	        item = q.dequeue();
	        if (!item.isCancelled()) {
	          // Note, do not schedule blocking work!
	          while (item.dueTime - Scheduler.now() > 0) {
	          }
	          if (!item.isCancelled()) {
	            item.invoke();
	          }
	        }
	      }
	    }
	
	    function scheduleNow(state, action) {
	      return this.scheduleWithRelativeAndState(state, 0, action);
	    }
	
	    function scheduleRelative(state, dueTime, action) {
	      var dt = this.now() + Scheduler.normalize(dueTime),
	          si = new ScheduledItem(this, state, action, dt);
	
	      if (!queue) {
	        queue = new PriorityQueue(4);
	        queue.enqueue(si);
	        try {
	          runTrampoline(queue);
	        } catch (e) {
	          throw e;
	        } finally {
	          queue = null;
	        }
	      } else {
	        queue.enqueue(si);
	      }
	      return si.disposable;
	    }
	
	    function scheduleAbsolute(state, dueTime, action) {
	      return this.scheduleWithRelativeAndState(state, dueTime - this.now(), action);
	    }
	
	    var currentScheduler = new Scheduler(defaultNow, scheduleNow, scheduleRelative, scheduleAbsolute);
	
	    currentScheduler.scheduleRequired = function () { return !queue; };
	    currentScheduler.ensureTrampoline = function (action) {
	      if (!queue) { this.schedule(action); } else { action(); }
	    };
	
	    return currentScheduler;
	  }());
	
	  var scheduleMethod, clearMethod = noop;
	  var localTimer = (function () {
	    var localSetTimeout, localClearTimeout = noop;
	    if ('WScript' in this) {
	      localSetTimeout = function (fn, time) {
	        WScript.Sleep(time);
	        fn();
	      };
	    } else if (!!root.setTimeout) {
	      localSetTimeout = root.setTimeout;
	      localClearTimeout = root.clearTimeout;
	    } else {
	      throw new Error('No concurrency detected!');
	    }
	
	    return {
	      setTimeout: localSetTimeout,
	      clearTimeout: localClearTimeout
	    };
	  }());
	  var localSetTimeout = localTimer.setTimeout,
	    localClearTimeout = localTimer.clearTimeout;
	
	  (function () {
	
	    var reNative = RegExp('^' +
	      String(toString)
	        .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
	        .replace(/toString| for [^\]]+/g, '.*?') + '$'
	    );
	
	    var setImmediate = typeof (setImmediate = freeGlobal && moduleExports && freeGlobal.setImmediate) == 'function' &&
	      !reNative.test(setImmediate) && setImmediate,
	      clearImmediate = typeof (clearImmediate = freeGlobal && moduleExports && freeGlobal.clearImmediate) == 'function' &&
	      !reNative.test(clearImmediate) && clearImmediate;
	
	    function postMessageSupported () {
	      // Ensure not in a worker
	      if (!root.postMessage || root.importScripts) { return false; }
	      var isAsync = false,
	          oldHandler = root.onmessage;
	      // Test for async
	      root.onmessage = function () { isAsync = true; };
	      root.postMessage('','*');
	      root.onmessage = oldHandler;
	
	      return isAsync;
	    }
	
	    // Use in order, nextTick, setImmediate, postMessage, MessageChannel, script readystatechanged, setTimeout
	    if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
	      scheduleMethod = process.nextTick;
	    } else if (typeof setImmediate === 'function') {
	      scheduleMethod = setImmediate;
	      clearMethod = clearImmediate;
	    } else if (postMessageSupported()) {
	      var MSG_PREFIX = 'ms.rx.schedule' + Math.random(),
	        tasks = {},
	        taskId = 0;
	
	      function onGlobalPostMessage(event) {
	        // Only if we're a match to avoid any other global events
	        if (typeof event.data === 'string' && event.data.substring(0, MSG_PREFIX.length) === MSG_PREFIX) {
	          var handleId = event.data.substring(MSG_PREFIX.length),
	            action = tasks[handleId];
	          action();
	          delete tasks[handleId];
	        }
	      }
	
	      if (root.addEventListener) {
	        root.addEventListener('message', onGlobalPostMessage, false);
	      } else {
	        root.attachEvent('onmessage', onGlobalPostMessage, false);
	      }
	
	      scheduleMethod = function (action) {
	        var currentId = taskId++;
	        tasks[currentId] = action;
	        root.postMessage(MSG_PREFIX + currentId, '*');
	      };
	    } else if (!!root.MessageChannel) {
	      var channel = new root.MessageChannel(),
	        channelTasks = {},
	        channelTaskId = 0;
	
	      channel.port1.onmessage = function (event) {
	        var id = event.data,
	          action = channelTasks[id];
	        action();
	        delete channelTasks[id];
	      };
	
	      scheduleMethod = function (action) {
	        var id = channelTaskId++;
	        channelTasks[id] = action;
	        channel.port2.postMessage(id);
	      };
	    } else if ('document' in root && 'onreadystatechange' in root.document.createElement('script')) {
	
	      scheduleMethod = function (action) {
	        var scriptElement = root.document.createElement('script');
	        scriptElement.onreadystatechange = function () {
	          action();
	          scriptElement.onreadystatechange = null;
	          scriptElement.parentNode.removeChild(scriptElement);
	          scriptElement = null;
	        };
	        root.document.documentElement.appendChild(scriptElement);
	      };
	
	    } else {
	      scheduleMethod = function (action) { return localSetTimeout(action, 0); };
	      clearMethod = localClearTimeout;
	    }
	  }());
	
	  /**
	   * Gets a scheduler that schedules work via a timed callback based upon platform.
	   */
	  var timeoutScheduler = Scheduler.timeout = (function () {
	
	    function scheduleNow(state, action) {
	      var scheduler = this,
	        disposable = new SingleAssignmentDisposable();
	      var id = scheduleMethod(function () {
	        if (!disposable.isDisposed) {
	          disposable.setDisposable(action(scheduler, state));
	        }
	      });
	      return new CompositeDisposable(disposable, disposableCreate(function () {
	        clearMethod(id);
	      }));
	    }
	
	    function scheduleRelative(state, dueTime, action) {
	      var scheduler = this,
	        dt = Scheduler.normalize(dueTime);
	      if (dt === 0) {
	        return scheduler.scheduleWithState(state, action);
	      }
	      var disposable = new SingleAssignmentDisposable();
	      var id = localSetTimeout(function () {
	        if (!disposable.isDisposed) {
	          disposable.setDisposable(action(scheduler, state));
	        }
	      }, dt);
	      return new CompositeDisposable(disposable, disposableCreate(function () {
	        localClearTimeout(id);
	      }));
	    }
	
	    function scheduleAbsolute(state, dueTime, action) {
	      return this.scheduleWithRelativeAndState(state, dueTime - this.now(), action);
	    }
	
	    return new Scheduler(defaultNow, scheduleNow, scheduleRelative, scheduleAbsolute);
	  })();
	
	  var CatchScheduler = (function (__super__) {
	
	    function scheduleNow(state, action) {
	      return this._scheduler.scheduleWithState(state, this._wrap(action));
	    }
	
	    function scheduleRelative(state, dueTime, action) {
	      return this._scheduler.scheduleWithRelativeAndState(state, dueTime, this._wrap(action));
	    }
	
	    function scheduleAbsolute(state, dueTime, action) {
	      return this._scheduler.scheduleWithAbsoluteAndState(state, dueTime, this._wrap(action));
	    }
	
	    inherits(CatchScheduler, __super__);
	
	    function CatchScheduler(scheduler, handler) {
	      this._scheduler = scheduler;
	      this._handler = handler;
	      this._recursiveOriginal = null;
	      this._recursiveWrapper = null;
	      __super__.call(this, this._scheduler.now.bind(this._scheduler), scheduleNow, scheduleRelative, scheduleAbsolute);
	    }
	
	    CatchScheduler.prototype._clone = function (scheduler) {
	        return new CatchScheduler(scheduler, this._handler);
	    };
	
	    CatchScheduler.prototype._wrap = function (action) {
	      var parent = this;
	      return function (self, state) {
	        try {
	          return action(parent._getRecursiveWrapper(self), state);
	        } catch (e) {
	          if (!parent._handler(e)) { throw e; }
	          return disposableEmpty;
	        }
	      };
	    };
	
	    CatchScheduler.prototype._getRecursiveWrapper = function (scheduler) {
	      if (this._recursiveOriginal !== scheduler) {
	        this._recursiveOriginal = scheduler;
	        var wrapper = this._clone(scheduler);
	        wrapper._recursiveOriginal = scheduler;
	        wrapper._recursiveWrapper = wrapper;
	        this._recursiveWrapper = wrapper;
	      }
	      return this._recursiveWrapper;
	    };
	
	    CatchScheduler.prototype.schedulePeriodicWithState = function (state, period, action) {
	      var self = this, failed = false, d = new SingleAssignmentDisposable();
	
	      d.setDisposable(this._scheduler.schedulePeriodicWithState(state, period, function (state1) {
	        if (failed) { return null; }
	        try {
	          return action(state1);
	        } catch (e) {
	          failed = true;
	          if (!self._handler(e)) { throw e; }
	          d.dispose();
	          return null;
	        }
	      }));
	
	      return d;
	    };
	
	    return CatchScheduler;
	  }(Scheduler));
	
	  /**
	   *  Represents a notification to an observer.
	   */
	  var Notification = Rx.Notification = (function () {
	    function Notification(kind, hasValue) {
	      this.hasValue = hasValue == null ? false : hasValue;
	      this.kind = kind;
	    }
	
	    /**
	     * Invokes the delegate corresponding to the notification or the observer's method corresponding to the notification and returns the produced result.
	     *
	     * @memberOf Notification
	     * @param {Any} observerOrOnNext Delegate to invoke for an OnNext notification or Observer to invoke the notification on..
	     * @param {Function} onError Delegate to invoke for an OnError notification.
	     * @param {Function} onCompleted Delegate to invoke for an OnCompleted notification.
	     * @returns {Any} Result produced by the observation.
	     */
	    Notification.prototype.accept = function (observerOrOnNext, onError, onCompleted) {
	      return observerOrOnNext && typeof observerOrOnNext === 'object' ?
	        this._acceptObservable(observerOrOnNext) :
	        this._accept(observerOrOnNext, onError, onCompleted);
	    };
	
	    /**
	     * Returns an observable sequence with a single notification.
	     *
	     * @memberOf Notifications
	     * @param {Scheduler} [scheduler] Scheduler to send out the notification calls on.
	     * @returns {Observable} The observable sequence that surfaces the behavior of the notification upon subscription.
	     */
	    Notification.prototype.toObservable = function (scheduler) {
	      var notification = this;
	      isScheduler(scheduler) || (scheduler = immediateScheduler);
	      return new AnonymousObservable(function (observer) {
	        return scheduler.schedule(function () {
	          notification._acceptObservable(observer);
	          notification.kind === 'N' && observer.onCompleted();
	        });
	      });
	    };
	
	    return Notification;
	  })();
	
	  /**
	   * Creates an object that represents an OnNext notification to an observer.
	   * @param {Any} value The value contained in the notification.
	   * @returns {Notification} The OnNext notification containing the value.
	   */
	  var notificationCreateOnNext = Notification.createOnNext = (function () {
	
	      function _accept (onNext) { return onNext(this.value); }
	      function _acceptObservable(observer) { return observer.onNext(this.value); }
	      function toString () { return 'OnNext(' + this.value + ')'; }
	
	      return function (value) {
	        var notification = new Notification('N', true);
	        notification.value = value;
	        notification._accept = _accept;
	        notification._acceptObservable = _acceptObservable;
	        notification.toString = toString;
	        return notification;
	      };
	  }());
	
	  /**
	   * Creates an object that represents an OnError notification to an observer.
	   * @param {Any} error The exception contained in the notification.
	   * @returns {Notification} The OnError notification containing the exception.
	   */
	  var notificationCreateOnError = Notification.createOnError = (function () {
	
	    function _accept (onNext, onError) { return onError(this.exception); }
	    function _acceptObservable(observer) { return observer.onError(this.exception); }
	    function toString () { return 'OnError(' + this.exception + ')'; }
	
	    return function (e) {
	      var notification = new Notification('E');
	      notification.exception = e;
	      notification._accept = _accept;
	      notification._acceptObservable = _acceptObservable;
	      notification.toString = toString;
	      return notification;
	    };
	  }());
	
	  /**
	   * Creates an object that represents an OnCompleted notification to an observer.
	   * @returns {Notification} The OnCompleted notification.
	   */
	  var notificationCreateOnCompleted = Notification.createOnCompleted = (function () {
	
	    function _accept (onNext, onError, onCompleted) { return onCompleted(); }
	    function _acceptObservable(observer) { return observer.onCompleted(); }
	    function toString () { return 'OnCompleted()'; }
	
	    return function () {
	      var notification = new Notification('C');
	      notification._accept = _accept;
	      notification._acceptObservable = _acceptObservable;
	      notification.toString = toString;
	      return notification;
	    };
	  }());
	
	  var Enumerator = Rx.internals.Enumerator = function (next) {
	    this._next = next;
	  };
	
	  Enumerator.prototype.next = function () {
	    return this._next();
	  };
	
	  Enumerator.prototype[$iterator$] = function () { return this; }
	
	  var Enumerable = Rx.internals.Enumerable = function (iterator) {
	    this._iterator = iterator;
	  };
	
	  Enumerable.prototype[$iterator$] = function () {
	    return this._iterator();
	  };
	
	  Enumerable.prototype.concat = function () {
	    var sources = this;
	    return new AnonymousObservable(function (observer) {
	      var e;
	      try {
	        e = sources[$iterator$]();
	      } catch(err) {
	        observer.onError();
	        return;
	      }
	
	      var isDisposed,
	        subscription = new SerialDisposable();
	      var cancelable = immediateScheduler.scheduleRecursive(function (self) {
	        var currentItem;
	        if (isDisposed) { return; }
	
	        try {
	          currentItem = e.next();
	        } catch (ex) {
	          observer.onError(ex);
	          return;
	        }
	
	        if (currentItem.done) {
	          observer.onCompleted();
	          return;
	        }
	
	        // Check if promise
	        var currentValue = currentItem.value;
	        isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));
	
	        var d = new SingleAssignmentDisposable();
	        subscription.setDisposable(d);
	        d.setDisposable(currentValue.subscribe(
	          observer.onNext.bind(observer),
	          observer.onError.bind(observer),
	          function () { self(); })
	        );
	      });
	
	      return new CompositeDisposable(subscription, cancelable, disposableCreate(function () {
	        isDisposed = true;
	      }));
	    });
	  };
	
	  Enumerable.prototype.catchException = function () {
	    var sources = this;
	    return new AnonymousObservable(function (observer) {
	      var e;
	      try {
	        e = sources[$iterator$]();
	      } catch(err) {
	        observer.onError();
	        return;
	      }
	
	      var isDisposed,
	        lastException,
	        subscription = new SerialDisposable();
	      var cancelable = immediateScheduler.scheduleRecursive(function (self) {
	        if (isDisposed) { return; }
	
	        var currentItem;
	        try {
	          currentItem = e.next();
	        } catch (ex) {
	          observer.onError(ex);
	          return;
	        }
	
	        if (currentItem.done) {
	          if (lastException) {
	            observer.onError(lastException);
	          } else {
	            observer.onCompleted();
	          }
	          return;
	        }
	
	        // Check if promise
	        var currentValue = currentItem.value;
	        isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));
	
	        var d = new SingleAssignmentDisposable();
	        subscription.setDisposable(d);
	        d.setDisposable(currentValue.subscribe(
	          observer.onNext.bind(observer),
	          function (exn) {
	            lastException = exn;
	            self();
	          },
	          observer.onCompleted.bind(observer)));
	      });
	      return new CompositeDisposable(subscription, cancelable, disposableCreate(function () {
	        isDisposed = true;
	      }));
	    });
	  };
	
	  var enumerableRepeat = Enumerable.repeat = function (value, repeatCount) {
	    if (repeatCount == null) { repeatCount = -1; }
	    return new Enumerable(function () {
	      var left = repeatCount;
	      return new Enumerator(function () {
	        if (left === 0) { return doneEnumerator; }
	        if (left > 0) { left--; }
	        return { done: false, value: value };
	      });
	    });
	  };
	
	  var enumerableOf = Enumerable.of = function (source, selector, thisArg) {
	    selector || (selector = identity);
	    return new Enumerable(function () {
	      var index = -1;
	      return new Enumerator(
	        function () {
	          return ++index < source.length ?
	            { done: false, value: selector.call(thisArg, source[index], index, source) } :
	            doneEnumerator;
	        });
	    });
	  };
	
	  /**
	   * Supports push-style iteration over an observable sequence.
	   */
	  var Observer = Rx.Observer = function () { };
	
	  /**
	   *  Creates a notification callback from an observer.
	   * @returns The action that forwards its input notification to the underlying observer.
	   */
	  Observer.prototype.toNotifier = function () {
	    var observer = this;
	    return function (n) { return n.accept(observer); };
	  };
	
	  /**
	   *  Hides the identity of an observer.
	   * @returns An observer that hides the identity of the specified observer.
	   */
	  Observer.prototype.asObserver = function () {
	    return new AnonymousObserver(this.onNext.bind(this), this.onError.bind(this), this.onCompleted.bind(this));
	  };
	
	  /**
	   *  Checks access to the observer for grammar violations. This includes checking for multiple OnError or OnCompleted calls, as well as reentrancy in any of the observer methods.
	   *  If a violation is detected, an Error is thrown from the offending observer method call.
	   * @returns An observer that checks callbacks invocations against the observer grammar and, if the checks pass, forwards those to the specified observer.
	   */
	  Observer.prototype.checked = function () { return new CheckedObserver(this); };
	
	  /**
	   *  Creates an observer from the specified OnNext, along with optional OnError, and OnCompleted actions.
	   * @param {Function} [onNext] Observer's OnNext action implementation.
	   * @param {Function} [onError] Observer's OnError action implementation.
	   * @param {Function} [onCompleted] Observer's OnCompleted action implementation.
	   * @returns {Observer} The observer object implemented using the given actions.
	   */
	  var observerCreate = Observer.create = function (onNext, onError, onCompleted) {
	    onNext || (onNext = noop);
	    onError || (onError = defaultError);
	    onCompleted || (onCompleted = noop);
	    return new AnonymousObserver(onNext, onError, onCompleted);
	  };
	
	  /**
	   *  Creates an observer from a notification callback.
	   *
	   * @static
	   * @memberOf Observer
	   * @param {Function} handler Action that handles a notification.
	   * @returns The observer object that invokes the specified handler using a notification corresponding to each message it receives.
	   */
	  Observer.fromNotifier = function (handler, thisArg) {
	    return new AnonymousObserver(function (x) {
	      return handler.call(thisArg, notificationCreateOnNext(x));
	    }, function (e) {
	      return handler.call(thisArg, notificationCreateOnError(e));
	    }, function () {
	      return handler.call(thisArg, notificationCreateOnCompleted());
	    });
	  };
	
	  /**
	   * Schedules the invocation of observer methods on the given scheduler.
	   * @param {Scheduler} scheduler Scheduler to schedule observer messages on.
	   * @returns {Observer} Observer whose messages are scheduled on the given scheduler.
	   */
	  Observer.notifyOn = function (scheduler) {
	    return new ObserveOnObserver(scheduler, this);
	  };
	
	  /**
	   * Abstract base class for implementations of the Observer class.
	   * This base class enforces the grammar of observers where OnError and OnCompleted are terminal messages.
	   */
	  var AbstractObserver = Rx.internals.AbstractObserver = (function (__super__) {
	    inherits(AbstractObserver, __super__);
	
	    /**
	     * Creates a new observer in a non-stopped state.
	     */
	    function AbstractObserver() {
	      this.isStopped = false;
	      __super__.call(this);
	    }
	
	    /**
	     * Notifies the observer of a new element in the sequence.
	     * @param {Any} value Next element in the sequence.
	     */
	    AbstractObserver.prototype.onNext = function (value) {
	      if (!this.isStopped) { this.next(value); }
	    };
	
	    /**
	     * Notifies the observer that an exception has occurred.
	     * @param {Any} error The error that has occurred.
	     */
	    AbstractObserver.prototype.onError = function (error) {
	      if (!this.isStopped) {
	        this.isStopped = true;
	        this.error(error);
	      }
	    };
	
	    /**
	     * Notifies the observer of the end of the sequence.
	     */
	    AbstractObserver.prototype.onCompleted = function () {
	      if (!this.isStopped) {
	        this.isStopped = true;
	        this.completed();
	      }
	    };
	
	    /**
	     * Disposes the observer, causing it to transition to the stopped state.
	     */
	    AbstractObserver.prototype.dispose = function () {
	      this.isStopped = true;
	    };
	
	    AbstractObserver.prototype.fail = function (e) {
	      if (!this.isStopped) {
	        this.isStopped = true;
	        this.error(e);
	        return true;
	      }
	
	      return false;
	    };
	
	    return AbstractObserver;
	  }(Observer));
	
	  /**
	   * Class to create an Observer instance from delegate-based implementations of the on* methods.
	   */
	  var AnonymousObserver = Rx.AnonymousObserver = (function (__super__) {
	    inherits(AnonymousObserver, __super__);
	
	    /**
	     * Creates an observer from the specified OnNext, OnError, and OnCompleted actions.
	     * @param {Any} onNext Observer's OnNext action implementation.
	     * @param {Any} onError Observer's OnError action implementation.
	     * @param {Any} onCompleted Observer's OnCompleted action implementation.
	     */
	    function AnonymousObserver(onNext, onError, onCompleted) {
	      __super__.call(this);
	      this._onNext = onNext;
	      this._onError = onError;
	      this._onCompleted = onCompleted;
	    }
	
	    /**
	     * Calls the onNext action.
	     * @param {Any} value Next element in the sequence.
	     */
	    AnonymousObserver.prototype.next = function (value) {
	      this._onNext(value);
	    };
	
	    /**
	     * Calls the onError action.
	     * @param {Any} error The error that has occurred.
	     */
	    AnonymousObserver.prototype.error = function (error) {
	      this._onError(error);
	    };
	
	    /**
	     *  Calls the onCompleted action.
	     */
	    AnonymousObserver.prototype.completed = function () {
	      this._onCompleted();
	    };
	
	    return AnonymousObserver;
	  }(AbstractObserver));
	
	    var CheckedObserver = (function (_super) {
	        inherits(CheckedObserver, _super);
	
	        function CheckedObserver(observer) {
	            _super.call(this);
	            this._observer = observer;
	            this._state = 0; // 0 - idle, 1 - busy, 2 - done
	        }
	
	        var CheckedObserverPrototype = CheckedObserver.prototype;
	
	        CheckedObserverPrototype.onNext = function (value) {
	            this.checkAccess();
	            try {
	                this._observer.onNext(value);
	            } catch (e) {
	                throw e;
	            } finally {
	                this._state = 0;
	            }
	        };
	
	        CheckedObserverPrototype.onError = function (err) {
	            this.checkAccess();
	            try {
	                this._observer.onError(err);
	            } catch (e) {
	                throw e;
	            } finally {
	                this._state = 2;
	            }
	        };
	
	        CheckedObserverPrototype.onCompleted = function () {
	            this.checkAccess();
	            try {
	                this._observer.onCompleted();
	            } catch (e) {
	                throw e;
	            } finally {
	                this._state = 2;
	            }
	        };
	
	        CheckedObserverPrototype.checkAccess = function () {
	            if (this._state === 1) { throw new Error('Re-entrancy detected'); }
	            if (this._state === 2) { throw new Error('Observer completed'); }
	            if (this._state === 0) { this._state = 1; }
	        };
	
	        return CheckedObserver;
	    }(Observer));
	
	  var ScheduledObserver = Rx.internals.ScheduledObserver = (function (__super__) {
	    inherits(ScheduledObserver, __super__);
	
	    function ScheduledObserver(scheduler, observer) {
	      __super__.call(this);
	      this.scheduler = scheduler;
	      this.observer = observer;
	      this.isAcquired = false;
	      this.hasFaulted = false;
	      this.queue = [];
	      this.disposable = new SerialDisposable();
	    }
	
	    ScheduledObserver.prototype.next = function (value) {
	      var self = this;
	      this.queue.push(function () {
	        self.observer.onNext(value);
	      });
	    };
	
	    ScheduledObserver.prototype.error = function (err) {
	      var self = this;
	      this.queue.push(function () {
	        self.observer.onError(err);
	      });
	    };
	
	    ScheduledObserver.prototype.completed = function () {
	      var self = this;
	      this.queue.push(function () {
	        self.observer.onCompleted();
	      });
	    };
	
	    ScheduledObserver.prototype.ensureActive = function () {
	      var isOwner = false, parent = this;
	      if (!this.hasFaulted && this.queue.length > 0) {
	        isOwner = !this.isAcquired;
	        this.isAcquired = true;
	      }
	      if (isOwner) {
	        this.disposable.setDisposable(this.scheduler.scheduleRecursive(function (self) {
	          var work;
	          if (parent.queue.length > 0) {
	            work = parent.queue.shift();
	          } else {
	            parent.isAcquired = false;
	            return;
	          }
	          try {
	            work();
	          } catch (ex) {
	            parent.queue = [];
	            parent.hasFaulted = true;
	            throw ex;
	          }
	          self();
	        }));
	      }
	    };
	
	    ScheduledObserver.prototype.dispose = function () {
	      __super__.prototype.dispose.call(this);
	      this.disposable.dispose();
	    };
	
	    return ScheduledObserver;
	  }(AbstractObserver));
	
	  var ObserveOnObserver = (function (__super__) {
	    inherits(ObserveOnObserver, __super__);
	
	    function ObserveOnObserver() {
	      __super__.apply(this, arguments);
	    }
	
	    ObserveOnObserver.prototype.next = function (value) {
	      __super__.prototype.next.call(this, value);
	      this.ensureActive();
	    };
	
	    ObserveOnObserver.prototype.error = function (e) {
	      __super__.prototype.error.call(this, e);
	      this.ensureActive();
	    };
	
	    ObserveOnObserver.prototype.completed = function () {
	      __super__.prototype.completed.call(this);
	      this.ensureActive();
	    };
	
	    return ObserveOnObserver;
	  })(ScheduledObserver);
	
	  var observableProto;
	
	  /**
	   * Represents a push-style collection.
	   */
	  var Observable = Rx.Observable = (function () {
	
	    function Observable(subscribe) {
	      this._subscribe = subscribe;
	    }
	
	    observableProto = Observable.prototype;
	
	    /**
	     *  Subscribes an observer to the observable sequence.
	     *  @param {Mixed} [observerOrOnNext] The object that is to receive notifications or an action to invoke for each element in the observable sequence.
	     *  @param {Function} [onError] Action to invoke upon exceptional termination of the observable sequence.
	     *  @param {Function} [onCompleted] Action to invoke upon graceful termination of the observable sequence.
	     *  @returns {Diposable} A disposable handling the subscriptions and unsubscriptions.
	     */
	    observableProto.subscribe = observableProto.forEach = function (observerOrOnNext, onError, onCompleted) {
	      return this._subscribe(typeof observerOrOnNext === 'object' ?
	        observerOrOnNext :
	        observerCreate(observerOrOnNext, onError, onCompleted));
	    };
	
	    /**
	     * Subscribes to the next value in the sequence with an optional "this" argument.
	     * @param {Function} onNext The function to invoke on each element in the observable sequence.
	     * @param {Any} [thisArg] Object to use as this when executing callback.
	     * @returns {Disposable} A disposable handling the subscriptions and unsubscriptions.
	     */
	    observableProto.subscribeOnNext = function (onNext, thisArg) {
	      return this._subscribe(observerCreate(arguments.length === 2 ? function(x) { onNext.call(thisArg, x); } : onNext));
	    };
	
	    /**
	     * Subscribes to an exceptional condition in the sequence with an optional "this" argument.
	     * @param {Function} onError The function to invoke upon exceptional termination of the observable sequence.
	     * @param {Any} [thisArg] Object to use as this when executing callback.
	     * @returns {Disposable} A disposable handling the subscriptions and unsubscriptions.
	     */
	    observableProto.subscribeOnError = function (onError, thisArg) {
	      return this._subscribe(observerCreate(null, arguments.length === 2 ? function(e) { onError.call(thisArg, e); } : onError));
	    };
	
	    /**
	     * Subscribes to the next value in the sequence with an optional "this" argument.
	     * @param {Function} onCompleted The function to invoke upon graceful termination of the observable sequence.
	     * @param {Any} [thisArg] Object to use as this when executing callback.
	     * @returns {Disposable} A disposable handling the subscriptions and unsubscriptions.
	     */
	    observableProto.subscribeOnCompleted = function (onCompleted, thisArg) {
	      return this._subscribe(observerCreate(null, null, arguments.length === 2 ? function() { onCompleted.call(thisArg); } : onCompleted));
	    };
	
	    return Observable;
	  })();
	
	   /**
	   *  Wraps the source sequence in order to run its observer callbacks on the specified scheduler.
	   *
	   *  This only invokes observer callbacks on a scheduler. In case the subscription and/or unsubscription actions have side-effects
	   *  that require to be run on a scheduler, use subscribeOn.
	   *
	   *  @param {Scheduler} scheduler Scheduler to notify observers on.
	   *  @returns {Observable} The source sequence whose observations happen on the specified scheduler.
	   */
	  observableProto.observeOn = function (scheduler) {
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      return source.subscribe(new ObserveOnObserver(scheduler, observer));
	    });
	  };
	
	   /**
	   *  Wraps the source sequence in order to run its subscription and unsubscription logic on the specified scheduler. This operation is not commonly used;
	   *  see the remarks section for more information on the distinction between subscribeOn and observeOn.
	
	   *  This only performs the side-effects of subscription and unsubscription on the specified scheduler. In order to invoke observer
	   *  callbacks on a scheduler, use observeOn.
	
	   *  @param {Scheduler} scheduler Scheduler to perform subscription and unsubscription actions on.
	   *  @returns {Observable} The source sequence whose subscriptions and unsubscriptions happen on the specified scheduler.
	   */
	  observableProto.subscribeOn = function (scheduler) {
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      var m = new SingleAssignmentDisposable(), d = new SerialDisposable();
	      d.setDisposable(m);
	      m.setDisposable(scheduler.schedule(function () {
	        d.setDisposable(new ScheduledDisposable(scheduler, source.subscribe(observer)));
	      }));
	      return d;
	    });
	  };
	
	  /**
	   * Converts a Promise to an Observable sequence
	   * @param {Promise} An ES6 Compliant promise.
	   * @returns {Observable} An Observable sequence which wraps the existing promise success and failure.
	   */
	  var observableFromPromise = Observable.fromPromise = function (promise) {
	    return observableDefer(function () {
	      var subject = new Rx.AsyncSubject();
	
	      promise.then(
	        function (value) {
	          if (!subject.isDisposed) {
	            subject.onNext(value);
	            subject.onCompleted();
	          }
	        },
	        subject.onError.bind(subject));
	
	      return subject;
	    });
	  };
	
	  /*
	   * Converts an existing observable sequence to an ES6 Compatible Promise
	   * @example
	   * var promise = Rx.Observable.return(42).toPromise(RSVP.Promise);
	   *
	   * // With config
	   * Rx.config.Promise = RSVP.Promise;
	   * var promise = Rx.Observable.return(42).toPromise();
	   * @param {Function} [promiseCtor] The constructor of the promise. If not provided, it looks for it in Rx.config.Promise.
	   * @returns {Promise} An ES6 compatible promise with the last value from the observable sequence.
	   */
	  observableProto.toPromise = function (promiseCtor) {
	    promiseCtor || (promiseCtor = Rx.config.Promise);
	    if (!promiseCtor) { throw new TypeError('Promise type not provided nor in Rx.config.Promise'); }
	    var source = this;
	    return new promiseCtor(function (resolve, reject) {
	      // No cancellation can be done
	      var value, hasValue = false;
	      source.subscribe(function (v) {
	        value = v;
	        hasValue = true;
	      }, reject, function () {
	        hasValue && resolve(value);
	      });
	    });
	  };
	
	  /**
	   * Creates a list from an observable sequence.
	   * @returns An observable sequence containing a single element with a list containing all the elements of the source sequence.
	   */
	  observableProto.toArray = function () {
	    var self = this;
	    return new AnonymousObservable(function(observer) {
	      var arr = [];
	      return self.subscribe(
	        arr.push.bind(arr),
	        observer.onError.bind(observer),
	        function () {
	          observer.onNext(arr);
	          observer.onCompleted();
	        });
	    });
	  };
	
	  /**
	   *  Creates an observable sequence from a specified subscribe method implementation.
	   *
	   * @example
	   *  var res = Rx.Observable.create(function (observer) { return function () { } );
	   *  var res = Rx.Observable.create(function (observer) { return Rx.Disposable.empty; } );
	   *  var res = Rx.Observable.create(function (observer) { } );
	   *
	   * @param {Function} subscribe Implementation of the resulting observable sequence's subscribe method, returning a function that will be wrapped in a Disposable.
	   * @returns {Observable} The observable sequence with the specified implementation for the Subscribe method.
	   */
	  Observable.create = Observable.createWithDisposable = function (subscribe) {
	    return new AnonymousObservable(subscribe);
	  };
	
	  /**
	   *  Returns an observable sequence that invokes the specified factory function whenever a new observer subscribes.
	   *
	   * @example
	   *  var res = Rx.Observable.defer(function () { return Rx.Observable.fromArray([1,2,3]); });
	   * @param {Function} observableFactory Observable factory function to invoke for each observer that subscribes to the resulting sequence or Promise.
	   * @returns {Observable} An observable sequence whose observers trigger an invocation of the given observable factory function.
	   */
	  var observableDefer = Observable.defer = function (observableFactory) {
	    return new AnonymousObservable(function (observer) {
	      var result;
	      try {
	        result = observableFactory();
	      } catch (e) {
	        return observableThrow(e).subscribe(observer);
	      }
	      isPromise(result) && (result = observableFromPromise(result));
	      return result.subscribe(observer);
	    });
	  };
	
	  /**
	   *  Returns an empty observable sequence, using the specified scheduler to send out the single OnCompleted message.
	   *
	   * @example
	   *  var res = Rx.Observable.empty();
	   *  var res = Rx.Observable.empty(Rx.Scheduler.timeout);
	   * @param {Scheduler} [scheduler] Scheduler to send the termination call on.
	   * @returns {Observable} An observable sequence with no elements.
	   */
	  var observableEmpty = Observable.empty = function (scheduler) {
	    isScheduler(scheduler) || (scheduler = immediateScheduler);
	    return new AnonymousObservable(function (observer) {
	      return scheduler.schedule(function () {
	        observer.onCompleted();
	      });
	    });
	  };
	
	  var maxSafeInteger = Math.pow(2, 53) - 1;
	
	  function numberIsFinite(value) {
	    return typeof value === 'number' && root.isFinite(value);
	  }
	
	  function isNan(n) {
	    return n !== n;
	  }
	
	  function isIterable(o) {
	    return o[$iterator$] !== undefined;
	  }
	
	  function sign(value) {
	    var number = +value;
	    if (number === 0) { return number; }
	    if (isNaN(number)) { return number; }
	    return number < 0 ? -1 : 1;
	  }
	
	  function toLength(o) {
	    var len = +o.length;
	    if (isNaN(len)) { return 0; }
	    if (len === 0 || !numberIsFinite(len)) { return len; }
	    len = sign(len) * Math.floor(Math.abs(len));
	    if (len <= 0) { return 0; }
	    if (len > maxSafeInteger) { return maxSafeInteger; }
	    return len;
	  }
	
	  function isCallable(f) {
	    return Object.prototype.toString.call(f) === '[object Function]' && typeof f === 'function';
	  }
	
	  /**
	   * This method creates a new Observable sequence from an array-like or iterable object.
	   * @param {Any} arrayLike An array-like or iterable object to convert to an Observable sequence.
	   * @param {Function} [mapFn] Map function to call on every element of the array.
	   * @param {Any} [thisArg] The context to use calling the mapFn if provided.
	   * @param {Scheduler} [scheduler] Optional scheduler to use for scheduling.  If not provided, defaults to Scheduler.currentThread.
	   */
	  var observableFrom = Observable.from = function (iterable, mapFn, thisArg, scheduler) {
	    if (iterable == null) {
	      throw new Error('iterable cannot be null.')
	    }
	    if (mapFn && !isCallable(mapFn)) {
	      throw new Error('mapFn when provided must be a function');
	    }
	    isScheduler(scheduler) || (scheduler = currentThreadScheduler);
	    return new AnonymousObservable(function (observer) {
	      var list = Object(iterable),
	        objIsIterable = isIterable(list),
	        len = objIsIterable ? 0 : toLength(list),
	        it = objIsIterable ? list[$iterator$]() : null,
	        i = 0;
	      return scheduler.scheduleRecursive(function (self) {
	        if (i < len || objIsIterable) {
	          var result;
	          if (objIsIterable) {
	            var next;
	            try {
	              next = it.next();
	            } catch (e) {
	              observer.onError(e);
	              return;
	            }
	            if (next.done) {
	              observer.onCompleted();
	              return;
	            }
	
	            result = next.value;
	          } else {
	            result = !!list.charAt ? list.charAt(i) : list[i];
	          }
	
	          if (mapFn && isCallable(mapFn)) {
	            try {
	              result = thisArg ? mapFn.call(thisArg, result, i) : mapFn(result, i);
	            } catch (e) {
	              observer.onError(e);
	              return;
	            }
	          }
	
	          observer.onNext(result);
	          i++;
	          self();
	        } else {
	          observer.onCompleted();
	        }
	      });
	    });
	  };
	
	  /**
	   *  Converts an array to an observable sequence, using an optional scheduler to enumerate the array.
	   *
	   * @example
	   *  var res = Rx.Observable.fromArray([1,2,3]);
	   *  var res = Rx.Observable.fromArray([1,2,3], Rx.Scheduler.timeout);
	   * @param {Scheduler} [scheduler] Scheduler to run the enumeration of the input sequence on.
	   * @returns {Observable} The observable sequence whose elements are pulled from the given enumerable sequence.
	   */
	  var observableFromArray = Observable.fromArray = function (array, scheduler) {
	    isScheduler(scheduler) || (scheduler = currentThreadScheduler);
	    return new AnonymousObservable(function (observer) {
	      var count = 0, len = array.length;
	      return scheduler.scheduleRecursive(function (self) {
	        if (count < len) {
	          observer.onNext(array[count++]);
	          self();
	        } else {
	          observer.onCompleted();
	        }
	      });
	    });
	  };
	
	  /**
	   *  Generates an observable sequence by running a state-driven loop producing the sequence's elements, using the specified scheduler to send out observer messages.
	   *
	   * @example
	   *  var res = Rx.Observable.generate(0, function (x) { return x < 10; }, function (x) { return x + 1; }, function (x) { return x; });
	   *  var res = Rx.Observable.generate(0, function (x) { return x < 10; }, function (x) { return x + 1; }, function (x) { return x; }, Rx.Scheduler.timeout);
	   * @param {Mixed} initialState Initial state.
	   * @param {Function} condition Condition to terminate generation (upon returning false).
	   * @param {Function} iterate Iteration step function.
	   * @param {Function} resultSelector Selector function for results produced in the sequence.
	   * @param {Scheduler} [scheduler] Scheduler on which to run the generator loop. If not provided, defaults to Scheduler.currentThread.
	   * @returns {Observable} The generated sequence.
	   */
	  Observable.generate = function (initialState, condition, iterate, resultSelector, scheduler) {
	    isScheduler(scheduler) || (scheduler = currentThreadScheduler);
	    return new AnonymousObservable(function (observer) {
	      var first = true, state = initialState;
	      return scheduler.scheduleRecursive(function (self) {
	        var hasResult, result;
	        try {
	          if (first) {
	            first = false;
	          } else {
	            state = iterate(state);
	          }
	          hasResult = condition(state);
	          if (hasResult) {
	            result = resultSelector(state);
	          }
	        } catch (exception) {
	          observer.onError(exception);
	          return;
	        }
	        if (hasResult) {
	          observer.onNext(result);
	          self();
	        } else {
	          observer.onCompleted();
	        }
	      });
	    });
	  };
	
	  /**
	   *  This method creates a new Observable instance with a variable number of arguments, regardless of number or type of the arguments.
	   * @example
	   *  var res = Rx.Observable.of(1,2,3);
	   * @returns {Observable} The observable sequence whose elements are pulled from the given arguments.
	   */
	  Observable.of = function () {
	    var len = arguments.length, args = new Array(len);
	    for(var i = 0; i < len; i++) { args[i] = arguments[i]; }
	    return observableFromArray(args);
	  };
	
	  /**
	   *  This method creates a new Observable instance with a variable number of arguments, regardless of number or type of the arguments.
	   * @example
	   *  var res = Rx.Observable.of(1,2,3);
	   * @param {Scheduler} scheduler A scheduler to use for scheduling the arguments.
	   * @returns {Observable} The observable sequence whose elements are pulled from the given arguments.
	   */
	  var observableOf = Observable.ofWithScheduler = function (scheduler) {
	    var len = arguments.length - 1, args = new Array(len);
	    for(var i = 0; i < len; i++) { args[i] = arguments[i + 1]; }
	    return observableFromArray(args, scheduler);
	  };
	
	  /**
	   *  Returns a non-terminating observable sequence, which can be used to denote an infinite duration (e.g. when using reactive joins).
	   * @returns {Observable} An observable sequence whose observers will never get called.
	   */
	  var observableNever = Observable.never = function () {
	    return new AnonymousObservable(function () {
	      return disposableEmpty;
	    });
	  };
	
	  /**
	   *  Generates an observable sequence of integral numbers within a specified range, using the specified scheduler to send out observer messages.
	   *
	   * @example
	   *  var res = Rx.Observable.range(0, 10);
	   *  var res = Rx.Observable.range(0, 10, Rx.Scheduler.timeout);
	   * @param {Number} start The value of the first integer in the sequence.
	   * @param {Number} count The number of sequential integers to generate.
	   * @param {Scheduler} [scheduler] Scheduler to run the generator loop on. If not specified, defaults to Scheduler.currentThread.
	   * @returns {Observable} An observable sequence that contains a range of sequential integral numbers.
	   */
	  Observable.range = function (start, count, scheduler) {
	    isScheduler(scheduler) || (scheduler = currentThreadScheduler);
	    return new AnonymousObservable(function (observer) {
	      return scheduler.scheduleRecursiveWithState(0, function (i, self) {
	        if (i < count) {
	          observer.onNext(start + i);
	          self(i + 1);
	        } else {
	          observer.onCompleted();
	        }
	      });
	    });
	  };
	
	  /**
	   *  Generates an observable sequence that repeats the given element the specified number of times, using the specified scheduler to send out observer messages.
	   *
	   * @example
	   *  var res = Rx.Observable.repeat(42);
	   *  var res = Rx.Observable.repeat(42, 4);
	   *  3 - res = Rx.Observable.repeat(42, 4, Rx.Scheduler.timeout);
	   *  4 - res = Rx.Observable.repeat(42, null, Rx.Scheduler.timeout);
	   * @param {Mixed} value Element to repeat.
	   * @param {Number} repeatCount [Optiona] Number of times to repeat the element. If not specified, repeats indefinitely.
	   * @param {Scheduler} scheduler Scheduler to run the producer loop on. If not specified, defaults to Scheduler.immediate.
	   * @returns {Observable} An observable sequence that repeats the given element the specified number of times.
	   */
	  Observable.repeat = function (value, repeatCount, scheduler) {
	    isScheduler(scheduler) || (scheduler = currentThreadScheduler);
	    return observableReturn(value, scheduler).repeat(repeatCount == null ? -1 : repeatCount);
	  };
	
	  /**
	   *  Returns an observable sequence that contains a single element, using the specified scheduler to send out observer messages.
	   *  There is an alias called 'just', and 'returnValue' for browsers <IE9.
	   *
	   * @example
	   *  var res = Rx.Observable.return(42);
	   *  var res = Rx.Observable.return(42, Rx.Scheduler.timeout);
	   * @param {Mixed} value Single element in the resulting observable sequence.
	   * @param {Scheduler} scheduler Scheduler to send the single element on. If not specified, defaults to Scheduler.immediate.
	   * @returns {Observable} An observable sequence containing the single specified element.
	   */
	  var observableReturn = Observable['return'] = Observable.returnValue = Observable.just = function (value, scheduler) {
	    isScheduler(scheduler) || (scheduler = immediateScheduler);
	    return new AnonymousObservable(function (observer) {
	      return scheduler.schedule(function () {
	        observer.onNext(value);
	        observer.onCompleted();
	      });
	    });
	  };
	
	  /**
	   *  Returns an observable sequence that terminates with an exception, using the specified scheduler to send out the single onError message.
	   *  There is an alias to this method called 'throwError' for browsers <IE9.
	   * @param {Mixed} exception An object used for the sequence's termination.
	   * @param {Scheduler} scheduler Scheduler to send the exceptional termination call on. If not specified, defaults to Scheduler.immediate.
	   * @returns {Observable} The observable sequence that terminates exceptionally with the specified exception object.
	   */
	  var observableThrow = Observable['throw'] = Observable.throwException = Observable.throwError = function (exception, scheduler) {
	    isScheduler(scheduler) || (scheduler = immediateScheduler);
	    return new AnonymousObservable(function (observer) {
	      return scheduler.schedule(function () {
	        observer.onError(exception);
	      });
	    });
	  };
	
	  /**
	   * Constructs an observable sequence that depends on a resource object, whose lifetime is tied to the resulting observable sequence's lifetime.
	   * @param {Function} resourceFactory Factory function to obtain a resource object.
	   * @param {Function} observableFactory Factory function to obtain an observable sequence that depends on the obtained resource.
	   * @returns {Observable} An observable sequence whose lifetime controls the lifetime of the dependent resource object.
	   */
	  Observable.using = function (resourceFactory, observableFactory) {
	    return new AnonymousObservable(function (observer) {
	      var disposable = disposableEmpty, resource, source;
	      try {
	        resource = resourceFactory();
	        resource && (disposable = resource);
	        source = observableFactory(resource);
	      } catch (exception) {
	        return new CompositeDisposable(observableThrow(exception).subscribe(observer), disposable);
	      }
	      return new CompositeDisposable(source.subscribe(observer), disposable);
	    });
	  };
	
	  /**
	   * Propagates the observable sequence or Promise that reacts first.
	   * @param {Observable} rightSource Second observable sequence or Promise.
	   * @returns {Observable} {Observable} An observable sequence that surfaces either of the given sequences, whichever reacted first.
	   */
	  observableProto.amb = function (rightSource) {
	    var leftSource = this;
	    return new AnonymousObservable(function (observer) {
	      var choice,
	        leftChoice = 'L', rightChoice = 'R',
	        leftSubscription = new SingleAssignmentDisposable(),
	        rightSubscription = new SingleAssignmentDisposable();
	
	      isPromise(rightSource) && (rightSource = observableFromPromise(rightSource));
	
	      function choiceL() {
	        if (!choice) {
	          choice = leftChoice;
	          rightSubscription.dispose();
	        }
	      }
	
	      function choiceR() {
	        if (!choice) {
	          choice = rightChoice;
	          leftSubscription.dispose();
	        }
	      }
	
	      leftSubscription.setDisposable(leftSource.subscribe(function (left) {
	        choiceL();
	        if (choice === leftChoice) {
	          observer.onNext(left);
	        }
	      }, function (err) {
	        choiceL();
	        if (choice === leftChoice) {
	          observer.onError(err);
	        }
	      }, function () {
	        choiceL();
	        if (choice === leftChoice) {
	          observer.onCompleted();
	        }
	      }));
	
	      rightSubscription.setDisposable(rightSource.subscribe(function (right) {
	        choiceR();
	        if (choice === rightChoice) {
	          observer.onNext(right);
	        }
	      }, function (err) {
	        choiceR();
	        if (choice === rightChoice) {
	          observer.onError(err);
	        }
	      }, function () {
	        choiceR();
	        if (choice === rightChoice) {
	          observer.onCompleted();
	        }
	      }));
	
	      return new CompositeDisposable(leftSubscription, rightSubscription);
	    });
	  };
	
	  /**
	   * Propagates the observable sequence or Promise that reacts first.
	   *
	   * @example
	   * var = Rx.Observable.amb(xs, ys, zs);
	   * @returns {Observable} An observable sequence that surfaces any of the given sequences, whichever reacted first.
	   */
	  Observable.amb = function () {
	    var acc = observableNever(),
	      items = argsOrArray(arguments, 0);
	    function func(previous, current) {
	      return previous.amb(current);
	    }
	    for (var i = 0, len = items.length; i < len; i++) {
	      acc = func(acc, items[i]);
	    }
	    return acc;
	  };
	
	  function observableCatchHandler(source, handler) {
	    return new AnonymousObservable(function (observer) {
	      var d1 = new SingleAssignmentDisposable(), subscription = new SerialDisposable();
	      subscription.setDisposable(d1);
	      d1.setDisposable(source.subscribe(observer.onNext.bind(observer), function (exception) {
	        var d, result;
	        try {
	          result = handler(exception);
	        } catch (ex) {
	          observer.onError(ex);
	          return;
	        }
	        isPromise(result) && (result = observableFromPromise(result));
	
	        d = new SingleAssignmentDisposable();
	        subscription.setDisposable(d);
	        d.setDisposable(result.subscribe(observer));
	      }, observer.onCompleted.bind(observer)));
	
	      return subscription;
	    });
	  }
	
	  /**
	   * Continues an observable sequence that is terminated by an exception with the next observable sequence.
	   * @example
	   * 1 - xs.catchException(ys)
	   * 2 - xs.catchException(function (ex) { return ys(ex); })
	   * @param {Mixed} handlerOrSecond Exception handler function that returns an observable sequence given the error that occurred in the first sequence, or a second observable sequence used to produce results when an error occurred in the first sequence.
	   * @returns {Observable} An observable sequence containing the first sequence's elements, followed by the elements of the handler sequence in case an exception occurred.
	   */
	  observableProto['catch'] = observableProto.catchError = observableProto.catchException = function (handlerOrSecond) {
	    return typeof handlerOrSecond === 'function' ?
	      observableCatchHandler(this, handlerOrSecond) :
	      observableCatch([this, handlerOrSecond]);
	  };
	
	  /**
	   * Continues an observable sequence that is terminated by an exception with the next observable sequence.
	   * @param {Array | Arguments} args Arguments or an array to use as the next sequence if an error occurs.
	   * @returns {Observable} An observable sequence containing elements from consecutive source sequences until a source sequence terminates successfully.
	   */
	  var observableCatch = Observable.catchException = Observable.catchError = Observable['catch'] = function () {
	    return enumerableOf(argsOrArray(arguments, 0)).catchException();
	  };
	
	  /**
	   * Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences or Promises produces an element.
	   * This can be in the form of an argument list of observables or an array.
	   *
	   * @example
	   * 1 - obs = observable.combineLatest(obs1, obs2, obs3, function (o1, o2, o3) { return o1 + o2 + o3; });
	   * 2 - obs = observable.combineLatest([obs1, obs2, obs3], function (o1, o2, o3) { return o1 + o2 + o3; });
	   * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result selector function.
	   */
	  observableProto.combineLatest = function () {
	    var args = slice.call(arguments);
	    if (Array.isArray(args[0])) {
	      args[0].unshift(this);
	    } else {
	      args.unshift(this);
	    }
	    return combineLatest.apply(this, args);
	  };
	
	  /**
	   * Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences or Promises produces an element.
	   *
	   * @example
	   * 1 - obs = Rx.Observable.combineLatest(obs1, obs2, obs3, function (o1, o2, o3) { return o1 + o2 + o3; });
	   * 2 - obs = Rx.Observable.combineLatest([obs1, obs2, obs3], function (o1, o2, o3) { return o1 + o2 + o3; });
	   * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result selector function.
	   */
	  var combineLatest = Observable.combineLatest = function () {
	    var args = slice.call(arguments), resultSelector = args.pop();
	
	    if (Array.isArray(args[0])) {
	      args = args[0];
	    }
	
	    return new AnonymousObservable(function (observer) {
	      var falseFactory = function () { return false; },
	        n = args.length,
	        hasValue = arrayInitialize(n, falseFactory),
	        hasValueAll = false,
	        isDone = arrayInitialize(n, falseFactory),
	        values = new Array(n);
	
	      function next(i) {
	        var res;
	        hasValue[i] = true;
	        if (hasValueAll || (hasValueAll = hasValue.every(identity))) {
	          try {
	            res = resultSelector.apply(null, values);
	          } catch (ex) {
	            observer.onError(ex);
	            return;
	          }
	          observer.onNext(res);
	        } else if (isDone.filter(function (x, j) { return j !== i; }).every(identity)) {
	          observer.onCompleted();
	        }
	      }
	
	      function done (i) {
	        isDone[i] = true;
	        if (isDone.every(identity)) {
	          observer.onCompleted();
	        }
	      }
	
	      var subscriptions = new Array(n);
	      for (var idx = 0; idx < n; idx++) {
	        (function (i) {
	          var source = args[i], sad = new SingleAssignmentDisposable();
	          isPromise(source) && (source = observableFromPromise(source));
	          sad.setDisposable(source.subscribe(function (x) {
	            values[i] = x;
	            next(i);
	          }, observer.onError.bind(observer), function () {
	            done(i);
	          }));
	          subscriptions[i] = sad;
	        }(idx));
	      }
	
	      return new CompositeDisposable(subscriptions);
	    });
	  };
	
	    /**
	     * Concatenates all the observable sequences.  This takes in either an array or variable arguments to concatenate.
	     *
	     * @example
	     * 1 - concatenated = xs.concat(ys, zs);
	     * 2 - concatenated = xs.concat([ys, zs]);
	     * @returns {Observable} An observable sequence that contains the elements of each given sequence, in sequential order.
	     */
	    observableProto.concat = function () {
	        var items = slice.call(arguments, 0);
	        items.unshift(this);
	        return observableConcat.apply(this, items);
	    };
	
	  /**
	   * Concatenates all the observable sequences.
	   * @param {Array | Arguments} args Arguments or an array to concat to the observable sequence.
	   * @returns {Observable} An observable sequence that contains the elements of each given sequence, in sequential order.
	   */
	  var observableConcat = Observable.concat = function () {
	    return enumerableOf(argsOrArray(arguments, 0)).concat();
	  };
	
	    /**
	     * Concatenates an observable sequence of observable sequences.
	     * @returns {Observable} An observable sequence that contains the elements of each observed inner sequence, in sequential order.
	     */
	    observableProto.concatObservable = observableProto.concatAll =function () {
	        return this.merge(1);
	    };
	
	  /**
	   * Merges an observable sequence of observable sequences into an observable sequence, limiting the number of concurrent subscriptions to inner sequences.
	   * Or merges two observable sequences into a single observable sequence.
	   *
	   * @example
	   * 1 - merged = sources.merge(1);
	   * 2 - merged = source.merge(otherSource);
	   * @param {Mixed} [maxConcurrentOrOther] Maximum number of inner observable sequences being subscribed to concurrently or the second observable sequence.
	   * @returns {Observable} The observable sequence that merges the elements of the inner sequences.
	   */
	  observableProto.merge = function (maxConcurrentOrOther) {
	    if (typeof maxConcurrentOrOther !== 'number') { return observableMerge(this, maxConcurrentOrOther); }
	    var sources = this;
	    return new AnonymousObservable(function (observer) {
	      var activeCount = 0, group = new CompositeDisposable(), isStopped = false, q = [];
	
	      function subscribe(xs) {
	        var subscription = new SingleAssignmentDisposable();
	        group.add(subscription);
	
	        // Check for promises support
	        isPromise(xs) && (xs = observableFromPromise(xs));
	
	        subscription.setDisposable(xs.subscribe(observer.onNext.bind(observer), observer.onError.bind(observer), function () {
	          group.remove(subscription);
	          if (q.length > 0) {
	            subscribe(q.shift());
	          } else {
	            activeCount--;
	            isStopped && activeCount === 0 && observer.onCompleted();
	          }
	        }));
	      }
	      group.add(sources.subscribe(function (innerSource) {
	        if (activeCount < maxConcurrentOrOther) {
	          activeCount++;
	          subscribe(innerSource);
	        } else {
	          q.push(innerSource);
	        }
	      }, observer.onError.bind(observer), function () {
	        isStopped = true;
	        activeCount === 0 && observer.onCompleted();
	      }));
	      return group;
	    });
	  };
	
	    /**
	     * Merges all the observable sequences into a single observable sequence.
	     * The scheduler is optional and if not specified, the immediate scheduler is used.
	     *
	     * @example
	     * 1 - merged = Rx.Observable.merge(xs, ys, zs);
	     * 2 - merged = Rx.Observable.merge([xs, ys, zs]);
	     * 3 - merged = Rx.Observable.merge(scheduler, xs, ys, zs);
	     * 4 - merged = Rx.Observable.merge(scheduler, [xs, ys, zs]);
	     * @returns {Observable} The observable sequence that merges the elements of the observable sequences.
	     */
	    var observableMerge = Observable.merge = function () {
	        var scheduler, sources;
	        if (!arguments[0]) {
	            scheduler = immediateScheduler;
	            sources = slice.call(arguments, 1);
	        } else if (arguments[0].now) {
	            scheduler = arguments[0];
	            sources = slice.call(arguments, 1);
	        } else {
	            scheduler = immediateScheduler;
	            sources = slice.call(arguments, 0);
	        }
	        if (Array.isArray(sources[0])) {
	            sources = sources[0];
	        }
	        return observableFromArray(sources, scheduler).mergeObservable();
	    };
	
	  /**
	   * Merges an observable sequence of observable sequences into an observable sequence.
	   * @returns {Observable} The observable sequence that merges the elements of the inner sequences.
	   */
	  observableProto.mergeObservable = observableProto.mergeAll = function () {
	    var sources = this;
	    return new AnonymousObservable(function (observer) {
	      var group = new CompositeDisposable(),
	        isStopped = false,
	        m = new SingleAssignmentDisposable();
	
	      group.add(m);
	      m.setDisposable(sources.subscribe(function (innerSource) {
	        var innerSubscription = new SingleAssignmentDisposable();
	        group.add(innerSubscription);
	
	        // Check for promises support
	        isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
	
	        innerSubscription.setDisposable(innerSource.subscribe(observer.onNext.bind(observer), observer.onError.bind(observer), function () {
	          group.remove(innerSubscription);
	          isStopped && group.length === 1 && observer.onCompleted();
	        }));
	      }, observer.onError.bind(observer), function () {
	        isStopped = true;
	        group.length === 1 && observer.onCompleted();
	      }));
	      return group;
	    });
	  };
	
	  /**
	   * Continues an observable sequence that is terminated normally or by an exception with the next observable sequence.
	   * @param {Observable} second Second observable sequence used to produce results after the first sequence terminates.
	   * @returns {Observable} An observable sequence that concatenates the first and second sequence, even if the first sequence terminates exceptionally.
	   */
	  observableProto.onErrorResumeNext = function (second) {
	    if (!second) { throw new Error('Second observable is required'); }
	    return onErrorResumeNext([this, second]);
	  };
	
	  /**
	   * Continues an observable sequence that is terminated normally or by an exception with the next observable sequence.
	   *
	   * @example
	   * 1 - res = Rx.Observable.onErrorResumeNext(xs, ys, zs);
	   * 1 - res = Rx.Observable.onErrorResumeNext([xs, ys, zs]);
	   * @returns {Observable} An observable sequence that concatenates the source sequences, even if a sequence terminates exceptionally.
	   */
	  var onErrorResumeNext = Observable.onErrorResumeNext = function () {
	    var sources = argsOrArray(arguments, 0);
	    return new AnonymousObservable(function (observer) {
	      var pos = 0, subscription = new SerialDisposable(),
	      cancelable = immediateScheduler.scheduleRecursive(function (self) {
	        var current, d;
	        if (pos < sources.length) {
	          current = sources[pos++];
	          isPromise(current) && (current = observableFromPromise(current));
	          d = new SingleAssignmentDisposable();
	          subscription.setDisposable(d);
	          d.setDisposable(current.subscribe(observer.onNext.bind(observer), self, self));
	        } else {
	          observer.onCompleted();
	        }
	      });
	      return new CompositeDisposable(subscription, cancelable);
	    });
	  };
	
	  /**
	   * Returns the values from the source observable sequence only after the other observable sequence produces a value.
	   * @param {Observable | Promise} other The observable sequence or Promise that triggers propagation of elements of the source sequence.
	   * @returns {Observable} An observable sequence containing the elements of the source sequence starting from the point the other sequence triggered propagation.
	   */
	  observableProto.skipUntil = function (other) {
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      var isOpen = false;
	      var disposables = new CompositeDisposable(source.subscribe(function (left) {
	        isOpen && observer.onNext(left);
	      }, observer.onError.bind(observer), function () {
	        isOpen && observer.onCompleted();
	      }));
	
	      isPromise(other) && (other = observableFromPromise(other));
	
	      var rightSubscription = new SingleAssignmentDisposable();
	      disposables.add(rightSubscription);
	      rightSubscription.setDisposable(other.subscribe(function () {
	        isOpen = true;
	        rightSubscription.dispose();
	      }, observer.onError.bind(observer), function () {
	        rightSubscription.dispose();
	      }));
	
	      return disposables;
	    });
	  };
	
	  /**
	   * Transforms an observable sequence of observable sequences into an observable sequence producing values only from the most recent observable sequence.
	   * @returns {Observable} The observable sequence that at any point in time produces the elements of the most recent inner observable sequence that has been received.
	   */
	  observableProto['switch'] = observableProto.switchLatest = function () {
	    var sources = this;
	    return new AnonymousObservable(function (observer) {
	      var hasLatest = false,
	        innerSubscription = new SerialDisposable(),
	        isStopped = false,
	        latest = 0,
	        subscription = sources.subscribe(
	          function (innerSource) {
	            var d = new SingleAssignmentDisposable(), id = ++latest;
	            hasLatest = true;
	            innerSubscription.setDisposable(d);
	
	            // Check if Promise or Observable
	            isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
	
	            d.setDisposable(innerSource.subscribe(
	              function (x) { latest === id && observer.onNext(x); },
	              function (e) { latest === id && observer.onError(e); },
	              function () {
	                if (latest === id) {
	                  hasLatest = false;
	                  isStopped && observer.onCompleted();
	                }
	              }));
	          },
	          observer.onError.bind(observer),
	          function () {
	            isStopped = true;
	            !hasLatest && observer.onCompleted();
	          });
	      return new CompositeDisposable(subscription, innerSubscription);
	    });
	  };
	
	  /**
	   * Returns the values from the source observable sequence until the other observable sequence produces a value.
	   * @param {Observable | Promise} other Observable sequence or Promise that terminates propagation of elements of the source sequence.
	   * @returns {Observable} An observable sequence containing the elements of the source sequence up to the point the other sequence interrupted further propagation.
	   */
	  observableProto.takeUntil = function (other) {
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      isPromise(other) && (other = observableFromPromise(other));
	      return new CompositeDisposable(
	        source.subscribe(observer),
	        other.subscribe(observer.onCompleted.bind(observer), observer.onError.bind(observer), noop)
	      );
	    });
	  };
	
	  function zipArray(second, resultSelector) {
	    var first = this;
	    return new AnonymousObservable(function (observer) {
	      var index = 0, len = second.length;
	      return first.subscribe(function (left) {
	        if (index < len) {
	          var right = second[index++], result;
	          try {
	            result = resultSelector(left, right);
	          } catch (e) {
	            observer.onError(e);
	            return;
	          }
	          observer.onNext(result);
	        } else {
	          observer.onCompleted();
	        }
	      }, observer.onError.bind(observer), observer.onCompleted.bind(observer));
	    });
	  }
	
	  /**
	   * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences or an array have produced an element at a corresponding index.
	   * The last element in the arguments must be a function to invoke for each series of elements at corresponding indexes in the sources.
	   *
	   * @example
	   * 1 - res = obs1.zip(obs2, fn);
	   * 1 - res = x1.zip([1,2,3], fn);
	   * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result selector function.
	   */
	  observableProto.zip = function () {
	    if (Array.isArray(arguments[0])) {
	      return zipArray.apply(this, arguments);
	    }
	    var parent = this, sources = slice.call(arguments), resultSelector = sources.pop();
	    sources.unshift(parent);
	    return new AnonymousObservable(function (observer) {
	      var n = sources.length,
	        queues = arrayInitialize(n, function () { return []; }),
	        isDone = arrayInitialize(n, function () { return false; });
	
	      function next(i) {
	        var res, queuedValues;
	        if (queues.every(function (x) { return x.length > 0; })) {
	          try {
	            queuedValues = queues.map(function (x) { return x.shift(); });
	            res = resultSelector.apply(parent, queuedValues);
	          } catch (ex) {
	            observer.onError(ex);
	            return;
	          }
	          observer.onNext(res);
	        } else if (isDone.filter(function (x, j) { return j !== i; }).every(identity)) {
	          observer.onCompleted();
	        }
	      };
	
	      function done(i) {
	        isDone[i] = true;
	        if (isDone.every(function (x) { return x; })) {
	          observer.onCompleted();
	        }
	      }
	
	      var subscriptions = new Array(n);
	      for (var idx = 0; idx < n; idx++) {
	        (function (i) {
	          var source = sources[i], sad = new SingleAssignmentDisposable();
	          isPromise(source) && (source = observableFromPromise(source));
	          sad.setDisposable(source.subscribe(function (x) {
	            queues[i].push(x);
	            next(i);
	          }, observer.onError.bind(observer), function () {
	            done(i);
	          }));
	          subscriptions[i] = sad;
	        })(idx);
	      }
	
	      return new CompositeDisposable(subscriptions);
	    });
	  };
	
	  /**
	   * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
	   * @param arguments Observable sources.
	   * @param {Function} resultSelector Function to invoke for each series of elements at corresponding indexes in the sources.
	   * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result selector function.
	   */
	  Observable.zip = function () {
	    var args = slice.call(arguments, 0), first = args.shift();
	    return first.zip.apply(first, args);
	  };
	
	  /**
	   * Merges the specified observable sequences into one observable sequence by emitting a list with the elements of the observable sequences at corresponding indexes.
	   * @param arguments Observable sources.
	   * @returns {Observable} An observable sequence containing lists of elements at corresponding indexes.
	   */
	  Observable.zipArray = function () {
	    var sources = argsOrArray(arguments, 0);
	    return new AnonymousObservable(function (observer) {
	      var n = sources.length,
	        queues = arrayInitialize(n, function () { return []; }),
	        isDone = arrayInitialize(n, function () { return false; });
	
	      function next(i) {
	        if (queues.every(function (x) { return x.length > 0; })) {
	          var res = queues.map(function (x) { return x.shift(); });
	          observer.onNext(res);
	        } else if (isDone.filter(function (x, j) { return j !== i; }).every(identity)) {
	          observer.onCompleted();
	          return;
	        }
	      };
	
	      function done(i) {
	        isDone[i] = true;
	        if (isDone.every(identity)) {
	          observer.onCompleted();
	          return;
	        }
	      }
	
	      var subscriptions = new Array(n);
	      for (var idx = 0; idx < n; idx++) {
	        (function (i) {
	          subscriptions[i] = new SingleAssignmentDisposable();
	          subscriptions[i].setDisposable(sources[i].subscribe(function (x) {
	            queues[i].push(x);
	            next(i);
	          }, observer.onError.bind(observer), function () {
	            done(i);
	          }));
	        })(idx);
	      }
	
	      var compositeDisposable = new CompositeDisposable(subscriptions);
	      compositeDisposable.add(disposableCreate(function () {
	        for (var qIdx = 0, qLen = queues.length; qIdx < qLen; qIdx++) { queues[qIdx] = []; }
	      }));
	      return compositeDisposable;
	    });
	  };
	
	  /**
	   *  Hides the identity of an observable sequence.
	   * @returns {Observable} An observable sequence that hides the identity of the source sequence.
	   */
	  observableProto.asObservable = function () {
	    return new AnonymousObservable(this.subscribe.bind(this));
	  };
	
	  /**
	   *  Projects each element of an observable sequence into zero or more buffers which are produced based on element count information.
	   *
	   * @example
	   *  var res = xs.bufferWithCount(10);
	   *  var res = xs.bufferWithCount(10, 1);
	   * @param {Number} count Length of each buffer.
	   * @param {Number} [skip] Number of elements to skip between creation of consecutive buffers. If not provided, defaults to the count.
	   * @returns {Observable} An observable sequence of buffers.
	   */
	  observableProto.bufferWithCount = function (count, skip) {
	    if (typeof skip !== 'number') {
	      skip = count;
	    }
	    return this.windowWithCount(count, skip).selectMany(function (x) {
	      return x.toArray();
	    }).where(function (x) {
	      return x.length > 0;
	    });
	  };
	
	    /**
	     * Dematerializes the explicit notification values of an observable sequence as implicit notifications.
	     * @returns {Observable} An observable sequence exhibiting the behavior corresponding to the source sequence's notification values.
	     */
	    observableProto.dematerialize = function () {
	        var source = this;
	        return new AnonymousObservable(function (observer) {
	            return source.subscribe(function (x) {
	                return x.accept(observer);
	            }, observer.onError.bind(observer), observer.onCompleted.bind(observer));
	        });
	    };
	
	    /**
	     *  Returns an observable sequence that contains only distinct contiguous elements according to the keySelector and the comparer.
	     *
	     *  var obs = observable.distinctUntilChanged();
	     *  var obs = observable.distinctUntilChanged(function (x) { return x.id; });
	     *  var obs = observable.distinctUntilChanged(function (x) { return x.id; }, function (x, y) { return x === y; });
	     *
	     * @param {Function} [keySelector] A function to compute the comparison key for each element. If not provided, it projects the value.
	     * @param {Function} [comparer] Equality comparer for computed key values. If not provided, defaults to an equality comparer function.
	     * @returns {Observable} An observable sequence only containing the distinct contiguous elements, based on a computed key value, from the source sequence.
	     */
	    observableProto.distinctUntilChanged = function (keySelector, comparer) {
	        var source = this;
	        keySelector || (keySelector = identity);
	        comparer || (comparer = defaultComparer);
	        return new AnonymousObservable(function (observer) {
	            var hasCurrentKey = false, currentKey;
	            return source.subscribe(function (value) {
	                var comparerEquals = false, key;
	                try {
	                    key = keySelector(value);
	                } catch (exception) {
	                    observer.onError(exception);
	                    return;
	                }
	                if (hasCurrentKey) {
	                    try {
	                        comparerEquals = comparer(currentKey, key);
	                    } catch (exception) {
	                        observer.onError(exception);
	                        return;
	                    }
	                }
	                if (!hasCurrentKey || !comparerEquals) {
	                    hasCurrentKey = true;
	                    currentKey = key;
	                    observer.onNext(value);
	                }
	            }, observer.onError.bind(observer), observer.onCompleted.bind(observer));
	        });
	    };
	
	  /**
	   *  Invokes an action for each element in the observable sequence and invokes an action upon graceful or exceptional termination of the observable sequence.
	   *  This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.
	   * @param {Function | Observer} observerOrOnNext Action to invoke for each element in the observable sequence or an observer.
	   * @param {Function} [onError]  Action to invoke upon exceptional termination of the observable sequence. Used if only the observerOrOnNext parameter is also a function.
	   * @param {Function} [onCompleted]  Action to invoke upon graceful termination of the observable sequence. Used if only the observerOrOnNext parameter is also a function.
	   * @returns {Observable} The source sequence with the side-effecting behavior applied.
	   */
	  observableProto['do'] = observableProto.doAction = observableProto.tap = function (observerOrOnNext, onError, onCompleted) {
	    var source = this, onNextFunc;
	    if (typeof observerOrOnNext === 'function') {
	      onNextFunc = observerOrOnNext;
	    } else {
	      onNextFunc = observerOrOnNext.onNext.bind(observerOrOnNext);
	      onError = observerOrOnNext.onError.bind(observerOrOnNext);
	      onCompleted = observerOrOnNext.onCompleted.bind(observerOrOnNext);
	    }
	    return new AnonymousObservable(function (observer) {
	      return source.subscribe(function (x) {
	        try {
	          onNextFunc(x);
	        } catch (e) {
	          observer.onError(e);
	        }
	        observer.onNext(x);
	      }, function (err) {
	        if (onError) {
	          try {
	            onError(err);
	          } catch (e) {
	            observer.onError(e);
	          }
	        }
	        observer.onError(err);
	      }, function () {
	        if (onCompleted) {
	          try {
	            onCompleted();
	          } catch (e) {
	            observer.onError(e);
	          }
	        }
	        observer.onCompleted();
	      });
	    });
	  };
	
	  /**
	   *  Invokes an action for each element in the observable sequence.
	   *  This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.
	   * @param {Function} onNext Action to invoke for each element in the observable sequence.
	   * @param {Any} [thisArg] Object to use as this when executing callback.
	   * @returns {Observable} The source sequence with the side-effecting behavior applied.
	   */
	  observableProto.doOnNext = observableProto.tapOnNext = function (onNext, thisArg) {
	    return this.tap(arguments.length === 2 ? function (x) { onNext.call(thisArg, x); } : onNext);
	  };
	
	  /**
	   *  Invokes an action upon exceptional termination of the observable sequence.
	   *  This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.
	   * @param {Function} onError Action to invoke upon exceptional termination of the observable sequence.
	   * @param {Any} [thisArg] Object to use as this when executing callback.
	   * @returns {Observable} The source sequence with the side-effecting behavior applied.
	   */
	  observableProto.doOnError = observableProto.tapOnError = function (onError, thisArg) {
	    return this.tap(noop, arguments.length === 2 ? function (e) { onError.call(thisArg, e); } : onError);
	  };
	
	  /**
	   *  Invokes an action upon graceful termination of the observable sequence.
	   *  This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.
	   * @param {Function} onCompleted Action to invoke upon graceful termination of the observable sequence.
	   * @param {Any} [thisArg] Object to use as this when executing callback.
	   * @returns {Observable} The source sequence with the side-effecting behavior applied.
	   */
	  observableProto.doOnCompleted = observableProto.tapOnCompleted = function (onCompleted, thisArg) {
	    return this.tap(noop, null, arguments.length === 2 ? function () { onCompleted.call(thisArg); } : onCompleted);
	  };
	
	  /**
	   *  Invokes a specified action after the source observable sequence terminates gracefully or exceptionally.
	   *
	   * @example
	   *  var res = observable.finallyAction(function () { console.log('sequence ended'; });
	   * @param {Function} finallyAction Action to invoke after the source observable sequence terminates.
	   * @returns {Observable} Source sequence with the action-invoking termination behavior applied.
	   */
	  observableProto['finally'] = observableProto.finallyAction = function (action) {
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      var subscription;
	      try {
	        subscription = source.subscribe(observer);
	      } catch (e) {
	        action();
	        throw e;
	      }
	      return disposableCreate(function () {
	        try {
	          subscription.dispose();
	        } catch (e) {
	          throw e;
	        } finally {
	          action();
	        }
	      });
	    });
	  };
	
	  /**
	   *  Ignores all elements in an observable sequence leaving only the termination messages.
	   * @returns {Observable} An empty observable sequence that signals termination, successful or exceptional, of the source sequence.
	   */
	  observableProto.ignoreElements = function () {
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      return source.subscribe(noop, observer.onError.bind(observer), observer.onCompleted.bind(observer));
	    });
	  };
	
	  /**
	   *  Materializes the implicit notifications of an observable sequence as explicit notification values.
	   * @returns {Observable} An observable sequence containing the materialized notification values from the source sequence.
	   */
	  observableProto.materialize = function () {
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      return source.subscribe(function (value) {
	        observer.onNext(notificationCreateOnNext(value));
	      }, function (e) {
	        observer.onNext(notificationCreateOnError(e));
	        observer.onCompleted();
	      }, function () {
	        observer.onNext(notificationCreateOnCompleted());
	        observer.onCompleted();
	      });
	    });
	  };
	
	    /**
	     *  Repeats the observable sequence a specified number of times. If the repeat count is not specified, the sequence repeats indefinitely.
	     *
	     * @example
	     *  var res = repeated = source.repeat();
	     *  var res = repeated = source.repeat(42);
	     * @param {Number} [repeatCount]  Number of times to repeat the sequence. If not provided, repeats the sequence indefinitely.
	     * @returns {Observable} The observable sequence producing the elements of the given sequence repeatedly.
	     */
	    observableProto.repeat = function (repeatCount) {
	        return enumerableRepeat(this, repeatCount).concat();
	    };
	
	  /**
	   *  Repeats the source observable sequence the specified number of times or until it successfully terminates. If the retry count is not specified, it retries indefinitely.
	   *  Note if you encounter an error and want it to retry once, then you must use .retry(2);
	   *
	   * @example
	   *  var res = retried = retry.repeat();
	   *  var res = retried = retry.repeat(2);
	   * @param {Number} [retryCount]  Number of times to retry the sequence. If not provided, retry the sequence indefinitely.
	   * @returns {Observable} An observable sequence producing the elements of the given sequence repeatedly until it terminates successfully.
	   */
	  observableProto.retry = function (retryCount) {
	    return enumerableRepeat(this, retryCount).catchException();
	  };
	
	  /**
	   *  Applies an accumulator function over an observable sequence and returns each intermediate result. The optional seed value is used as the initial accumulator value.
	   *  For aggregation behavior with no intermediate results, see Observable.aggregate.
	   * @example
	   *  var res = source.scan(function (acc, x) { return acc + x; });
	   *  var res = source.scan(0, function (acc, x) { return acc + x; });
	   * @param {Mixed} [seed] The initial accumulator value.
	   * @param {Function} accumulator An accumulator function to be invoked on each element.
	   * @returns {Observable} An observable sequence containing the accumulated values.
	   */
	  observableProto.scan = function () {
	    var hasSeed = false, seed, accumulator, source = this;
	    if (arguments.length === 2) {
	      hasSeed = true;
	      seed = arguments[0];
	      accumulator = arguments[1];
	    } else {
	      accumulator = arguments[0];
	    }
	    return new AnonymousObservable(function (observer) {
	      var hasAccumulation, accumulation, hasValue;
	      return source.subscribe (
	        function (x) {
	          !hasValue && (hasValue = true);
	          try {
	            if (hasAccumulation) {
	              accumulation = accumulator(accumulation, x);
	            } else {
	              accumulation = hasSeed ? accumulator(seed, x) : x;
	              hasAccumulation = true;
	            }
	          } catch (e) {
	            observer.onError(e);
	            return;
	          }
	
	          observer.onNext(accumulation);
	        },
	        observer.onError.bind(observer),
	        function () {
	          !hasValue && hasSeed && observer.onNext(seed);
	          observer.onCompleted();
	        }
	      );
	    });
	  };
	
	  /**
	   *  Bypasses a specified number of elements at the end of an observable sequence.
	   * @description
	   *  This operator accumulates a queue with a length enough to store the first `count` elements. As more elements are
	   *  received, elements are taken from the front of the queue and produced on the result sequence. This causes elements to be delayed.
	   * @param count Number of elements to bypass at the end of the source sequence.
	   * @returns {Observable} An observable sequence containing the source sequence elements except for the bypassed ones at the end.
	   */
	  observableProto.skipLast = function (count) {
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      var q = [];
	      return source.subscribe(function (x) {
	        q.push(x);
	        q.length > count && observer.onNext(q.shift());
	      }, observer.onError.bind(observer), observer.onCompleted.bind(observer));
	    });
	  };
	
	  /**
	   *  Prepends a sequence of values to an observable sequence with an optional scheduler and an argument list of values to prepend.
	   *  @example
	   *  var res = source.startWith(1, 2, 3);
	   *  var res = source.startWith(Rx.Scheduler.timeout, 1, 2, 3);
	   * @param {Arguments} args The specified values to prepend to the observable sequence
	   * @returns {Observable} The source sequence prepended with the specified values.
	   */
	  observableProto.startWith = function () {
	    var values, scheduler, start = 0;
	    if (!!arguments.length && isScheduler(arguments[0])) {
	      scheduler = arguments[0];
	      start = 1;
	    } else {
	      scheduler = immediateScheduler;
	    }
	    values = slice.call(arguments, start);
	    return enumerableOf([observableFromArray(values, scheduler), this]).concat();
	  };
	
	  /**
	   *  Returns a specified number of contiguous elements from the end of an observable sequence.
	   * @description
	   *  This operator accumulates a buffer with a length enough to store elements count elements. Upon completion of
	   *  the source sequence, this buffer is drained on the result sequence. This causes the elements to be delayed.
	   * @param {Number} count Number of elements to take from the end of the source sequence.
	   * @returns {Observable} An observable sequence containing the specified number of elements from the end of the source sequence.
	   */
	  observableProto.takeLast = function (count) {
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      var q = [];
	      return source.subscribe(function (x) {
	        q.push(x);
	        q.length > count && q.shift();
	      }, observer.onError.bind(observer), function () {
	        while(q.length > 0) { observer.onNext(q.shift()); }
	        observer.onCompleted();
	      });
	    });
	  };
	
	  /**
	   *  Returns an array with the specified number of contiguous elements from the end of an observable sequence.
	   *
	   * @description
	   *  This operator accumulates a buffer with a length enough to store count elements. Upon completion of the
	   *  source sequence, this buffer is produced on the result sequence.
	   * @param {Number} count Number of elements to take from the end of the source sequence.
	   * @returns {Observable} An observable sequence containing a single array with the specified number of elements from the end of the source sequence.
	   */
	  observableProto.takeLastBuffer = function (count) {
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      var q = [];
	      return source.subscribe(function (x) {
	        q.push(x);
	        q.length > count && q.shift();
	      }, observer.onError.bind(observer), function () {
	        observer.onNext(q);
	        observer.onCompleted();
	      });
	    });
	  };
	
	  /**
	   *  Projects each element of an observable sequence into zero or more windows which are produced based on element count information.
	   *
	   *  var res = xs.windowWithCount(10);
	   *  var res = xs.windowWithCount(10, 1);
	   * @param {Number} count Length of each window.
	   * @param {Number} [skip] Number of elements to skip between creation of consecutive windows. If not specified, defaults to the count.
	   * @returns {Observable} An observable sequence of windows.
	   */
	  observableProto.windowWithCount = function (count, skip) {
	    var source = this;
	    +count || (count = 0);
	    Math.abs(count) === Infinity && (count = 0);
	    if (count <= 0) { throw new Error(argumentOutOfRange); }
	    skip == null && (skip = count);
	    +skip || (skip = 0);
	    Math.abs(skip) === Infinity && (skip = 0);
	
	    if (skip <= 0) { throw new Error(argumentOutOfRange); }
	    return new AnonymousObservable(function (observer) {
	      var m = new SingleAssignmentDisposable(),
	        refCountDisposable = new RefCountDisposable(m),
	        n = 0,
	        q = [];
	
	      function createWindow () {
	        var s = new Subject();
	        q.push(s);
	        observer.onNext(addRef(s, refCountDisposable));
	      }
	
	      createWindow();
	
	      m.setDisposable(source.subscribe(
	        function (x) {
	          for (var i = 0, len = q.length; i < len; i++) { q[i].onNext(x); }
	          var c = n - count + 1;
	          c >=0 && c % skip === 0 && q.shift().onCompleted();
	          ++n % skip === 0 && createWindow();
	        }, 
	        function (e) {
	          while (q.length > 0) { q.shift().onError(e); }
	          observer.onError(e);
	        }, 
	        function () {
	          while (q.length > 0) { q.shift().onCompleted(); }
	          observer.onCompleted();
	        }
	      ));
	      return refCountDisposable;
	    });
	  };
	
	  function concatMap(source, selector, thisArg) {
	    return source.map(function (x, i) {
	      var result = selector.call(thisArg, x, i, source);
	      isPromise(result) && (result = observableFromPromise(result));
	      (Array.isArray(result) || isIterable(result)) && (result = observableFrom(result));
	      return result;
	    }).concatAll();
	  }
	
	  /**
	   *  One of the Following:
	   *  Projects each element of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.
	   *
	   * @example
	   *  var res = source.concatMap(function (x) { return Rx.Observable.range(0, x); });
	   *  Or:
	   *  Projects each element of an observable sequence to an observable sequence, invokes the result selector for the source element and each of the corresponding inner sequence's elements, and merges the results into one observable sequence.
	   *
	   *  var res = source.concatMap(function (x) { return Rx.Observable.range(0, x); }, function (x, y) { return x + y; });
	   *  Or:
	   *  Projects each element of the source observable sequence to the other observable sequence and merges the resulting observable sequences into one observable sequence.
	   *
	   *  var res = source.concatMap(Rx.Observable.fromArray([1,2,3]));
	   * @param {Function} selector A transform function to apply to each element or an observable sequence to project each element from the
	   * source sequence onto which could be either an observable or Promise.
	   * @param {Function} [resultSelector]  A transform function to apply to each element of the intermediate sequence.
	   * @returns {Observable} An observable sequence whose elements are the result of invoking the one-to-many transform function collectionSelector on each element of the input sequence and then mapping each of those sequence elements and their corresponding source element to a result element.
	   */
	  observableProto.selectConcat = observableProto.concatMap = function (selector, resultSelector, thisArg) {
	    if (typeof selector === 'function' && typeof resultSelector === 'function') {
	      return this.concatMap(function (x, i) {
	        var selectorResult = selector(x, i);
	        isPromise(selectorResult) && (selectorResult = observableFromPromise(selectorResult));
	        (Array.isArray(selectorResult) || isIterable(selectorResult)) && (selectorResult = observableFrom(selectorResult));
	
	        return selectorResult.map(function (y, i2) {
	          return resultSelector(x, y, i, i2);
	        });
	      });
	    }
	    return typeof selector === 'function' ?
	      concatMap(this, selector, thisArg) :
	      concatMap(this, function () { return selector; });
	  };
	
	  /**
	   * Projects each notification of an observable sequence to an observable sequence and concats the resulting observable sequences into one observable sequence.
	   * @param {Function} onNext A transform function to apply to each element; the second parameter of the function represents the index of the source element.
	   * @param {Function} onError A transform function to apply when an error occurs in the source sequence.
	   * @param {Function} onCompleted A transform function to apply when the end of the source sequence is reached.
	   * @param {Any} [thisArg] An optional "this" to use to invoke each transform.
	   * @returns {Observable} An observable sequence whose elements are the result of invoking the one-to-many transform function corresponding to each notification in the input sequence.
	   */
	  observableProto.concatMapObserver = observableProto.selectConcatObserver = function(onNext, onError, onCompleted, thisArg) {
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      var index = 0;
	
	      return source.subscribe(
	        function (x) {
	          var result;
	          try {
	            result = onNext.call(thisArg, x, index++);
	          } catch (e) {
	            observer.onError(e);
	            return;
	          }
	          isPromise(result) && (result = observableFromPromise(result));
	          observer.onNext(result);
	        },
	        function (err) {
	          var result;
	          try {
	            result = onError.call(thisArg, err);
	          } catch (e) {
	            observer.onError(e);
	            return;
	          }
	          isPromise(result) && (result = observableFromPromise(result));
	          observer.onNext(result);
	          observer.onCompleted();
	        },
	        function () {
	          var result;
	          try {
	            result = onCompleted.call(thisArg);
	          } catch (e) {
	            observer.onError(e);
	            return;
	          }
	          isPromise(result) && (result = observableFromPromise(result));
	          observer.onNext(result);
	          observer.onCompleted();
	        });
	    }).concatAll();
	  };
	
	    /**
	     *  Returns the elements of the specified sequence or the specified value in a singleton sequence if the sequence is empty.
	     *
	     *  var res = obs = xs.defaultIfEmpty();
	     *  2 - obs = xs.defaultIfEmpty(false);
	     *
	     * @memberOf Observable#
	     * @param defaultValue The value to return if the sequence is empty. If not provided, this defaults to null.
	     * @returns {Observable} An observable sequence that contains the specified default value if the source is empty; otherwise, the elements of the source itself.
	     */
	    observableProto.defaultIfEmpty = function (defaultValue) {
	        var source = this;
	        if (defaultValue === undefined) {
	            defaultValue = null;
	        }
	        return new AnonymousObservable(function (observer) {
	            var found = false;
	            return source.subscribe(function (x) {
	                found = true;
	                observer.onNext(x);
	            }, observer.onError.bind(observer), function () {
	                if (!found) {
	                    observer.onNext(defaultValue);
	                }
	                observer.onCompleted();
	            });
	        });
	    };
	
	  // Swap out for Array.findIndex
	  function arrayIndexOfComparer(array, item, comparer) {
	    for (var i = 0, len = array.length; i < len; i++) {
	      if (comparer(array[i], item)) { return i; }
	    }
	    return -1;
	  }
	
	  function HashSet(comparer) {
	    this.comparer = comparer;
	    this.set = [];
	  }
	  HashSet.prototype.push = function(value) {
	    var retValue = arrayIndexOfComparer(this.set, value, this.comparer) === -1;
	    retValue && this.set.push(value);
	    return retValue;
	  };
	
	  /**
	   *  Returns an observable sequence that contains only distinct elements according to the keySelector and the comparer.
	   *  Usage of this operator should be considered carefully due to the maintenance of an internal lookup structure which can grow large.
	   *
	   * @example
	   *  var res = obs = xs.distinct();
	   *  2 - obs = xs.distinct(function (x) { return x.id; });
	   *  2 - obs = xs.distinct(function (x) { return x.id; }, function (a,b) { return a === b; });
	   * @param {Function} [keySelector]  A function to compute the comparison key for each element.
	   * @param {Function} [comparer]  Used to compare items in the collection.
	   * @returns {Observable} An observable sequence only containing the distinct elements, based on a computed key value, from the source sequence.
	   */
	  observableProto.distinct = function (keySelector, comparer) {
	    var source = this;
	    comparer || (comparer = defaultComparer);
	    return new AnonymousObservable(function (observer) {
	      var hashSet = new HashSet(comparer);
	      return source.subscribe(function (x) {
	        var key = x;
	
	        if (keySelector) {
	          try {
	            key = keySelector(x);
	          } catch (e) {
	            observer.onError(e);
	            return;
	          }
	        }
	        hashSet.push(key) && observer.onNext(x);
	      },
	      observer.onError.bind(observer),
	      observer.onCompleted.bind(observer));
	    });
	  };
	
	  /**
	   *  Groups the elements of an observable sequence according to a specified key selector function and comparer and selects the resulting elements by using a specified function.
	   *
	   * @example
	   *  var res = observable.groupBy(function (x) { return x.id; });
	   *  2 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; });
	   *  3 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; }, function (x) { return x.toString(); });
	   * @param {Function} keySelector A function to extract the key for each element.
	   * @param {Function} [elementSelector]  A function to map each source element to an element in an observable group.
	   * @param {Function} [comparer] Used to determine whether the objects are equal.
	   * @returns {Observable} A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.
	   */
	  observableProto.groupBy = function (keySelector, elementSelector, comparer) {
	    return this.groupByUntil(keySelector, elementSelector, observableNever, comparer);
	  };
	
	    /**
	     *  Groups the elements of an observable sequence according to a specified key selector function.
	     *  A duration selector function is used to control the lifetime of groups. When a group expires, it receives an OnCompleted notification. When a new element with the same
	     *  key value as a reclaimed group occurs, the group will be reborn with a new lifetime request.
	     *
	     * @example
	     *  var res = observable.groupByUntil(function (x) { return x.id; }, null,  function () { return Rx.Observable.never(); });
	     *  2 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; },  function () { return Rx.Observable.never(); });
	     *  3 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; },  function () { return Rx.Observable.never(); }, function (x) { return x.toString(); });
	     * @param {Function} keySelector A function to extract the key for each element.
	     * @param {Function} durationSelector A function to signal the expiration of a group.
	     * @param {Function} [comparer] Used to compare objects. When not specified, the default comparer is used.
	     * @returns {Observable}
	     *  A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.
	     *  If a group's lifetime expires, a new group with the same key value can be created once an element with such a key value is encoutered.
	     *
	     */
	    observableProto.groupByUntil = function (keySelector, elementSelector, durationSelector, comparer) {
	      var source = this;
	      elementSelector || (elementSelector = identity);
	      comparer || (comparer = defaultComparer);
	      return new AnonymousObservable(function (observer) {
	        function handleError(e) { return function (item) { item.onError(e); }; }
	        var map = new Dictionary(0, comparer),
	          groupDisposable = new CompositeDisposable(),
	          refCountDisposable = new RefCountDisposable(groupDisposable);
	
	        groupDisposable.add(source.subscribe(function (x) {
	          var key;
	          try {
	            key = keySelector(x);
	          } catch (e) {
	            map.getValues().forEach(handleError(e));
	            observer.onError(e);
	            return;
	          }
	
	          var fireNewMapEntry = false,
	            writer = map.tryGetValue(key);
	          if (!writer) {
	            writer = new Subject();
	            map.set(key, writer);
	            fireNewMapEntry = true;
	          }
	
	          if (fireNewMapEntry) {
	            var group = new GroupedObservable(key, writer, refCountDisposable),
	              durationGroup = new GroupedObservable(key, writer);
	            try {
	              duration = durationSelector(durationGroup);
	            } catch (e) {
	              map.getValues().forEach(handleError(e));
	              observer.onError(e);
	              return;
	            }
	
	            observer.onNext(group);
	
	            var md = new SingleAssignmentDisposable();
	            groupDisposable.add(md);
	
	            var expire = function () {
	              map.remove(key) && writer.onCompleted();
	              groupDisposable.remove(md);
	            };
	
	            md.setDisposable(duration.take(1).subscribe(
	              noop,
	              function (exn) {
	                map.getValues().forEach(handleError(exn));
	                observer.onError(exn);
	              },
	              expire)
	            );
	          }
	
	          var element;
	          try {
	            element = elementSelector(x);
	          } catch (e) {
	            map.getValues().forEach(handleError(e));
	            observer.onError(e);
	            return;
	          }
	
	          writer.onNext(element);
	      }, function (ex) {
	        map.getValues().forEach(handleError(ex));
	        observer.onError(ex);
	      }, function () {
	        map.getValues().forEach(function (item) { item.onCompleted(); });
	        observer.onCompleted();
	      }));
	
	      return refCountDisposable;
	    });
	  };
	
	  /**
	   *  Projects each element of an observable sequence into a new form by incorporating the element's index.
	   * @param {Function} selector A transform function to apply to each source element; the second parameter of the function represents the index of the source element.
	   * @param {Any} [thisArg] Object to use as this when executing callback.
	   * @returns {Observable} An observable sequence whose elements are the result of invoking the transform function on each element of source.
	   */
	  observableProto.select = observableProto.map = function (selector, thisArg) {
	    var parent = this;
	    return new AnonymousObservable(function (observer) {
	      var count = 0;
	      return parent.subscribe(function (value) {
	        var result;
	        try {
	          result = selector.call(thisArg, value, count++, parent);
	        } catch (e) {
	          observer.onError(e);
	          return;
	        }
	        observer.onNext(result);
	      }, observer.onError.bind(observer), observer.onCompleted.bind(observer));
	    });
	  };
	
	  /**
	   * Retrieves the value of a specified property from all elements in the Observable sequence.
	   * @param {String} prop The property to pluck.
	   * @returns {Observable} Returns a new Observable sequence of property values.
	   */
	  observableProto.pluck = function (prop) {
	    return this.map(function (x) { return x[prop]; });
	  };
	
	  function flatMap(source, selector, thisArg) {
	    return source.map(function (x, i) {
	      var result = selector.call(thisArg, x, i, source);
	      isPromise(result) && (result = observableFromPromise(result));
	      (Array.isArray(result) || isIterable(result)) && (result = observableFrom(result));
	      return result;
	    }).mergeObservable();
	  }
	
	  /**
	   *  One of the Following:
	   *  Projects each element of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.
	   *
	   * @example
	   *  var res = source.selectMany(function (x) { return Rx.Observable.range(0, x); });
	   *  Or:
	   *  Projects each element of an observable sequence to an observable sequence, invokes the result selector for the source element and each of the corresponding inner sequence's elements, and merges the results into one observable sequence.
	   *
	   *  var res = source.selectMany(function (x) { return Rx.Observable.range(0, x); }, function (x, y) { return x + y; });
	   *  Or:
	   *  Projects each element of the source observable sequence to the other observable sequence and merges the resulting observable sequences into one observable sequence.
	   *
	   *  var res = source.selectMany(Rx.Observable.fromArray([1,2,3]));
	   * @param {Function} selector A transform function to apply to each element or an observable sequence to project each element from the source sequence onto which could be either an observable or Promise.
	   * @param {Function} [resultSelector]  A transform function to apply to each element of the intermediate sequence.
	   * @param {Any} [thisArg] Object to use as this when executing callback.
	   * @returns {Observable} An observable sequence whose elements are the result of invoking the one-to-many transform function collectionSelector on each element of the input sequence and then mapping each of those sequence elements and their corresponding source element to a result element.
	   */
	  observableProto.selectMany = observableProto.flatMap = function (selector, resultSelector, thisArg) {
	    if (typeof selector === 'function' && typeof resultSelector === 'function') {
	      return this.flatMap(function (x, i) {
	        var selectorResult = selector(x, i);
	        isPromise(selectorResult) && (selectorResult = observableFromPromise(selectorResult));
	        (Array.isArray(selectorResult) || isIterable(selectorResult)) && (selectorResult = observableFrom(selectorResult));
	
	        return selectorResult.map(function (y, i2) {
	          return resultSelector(x, y, i, i2);
	        });
	      }, thisArg);
	    }
	    return typeof selector === 'function' ?
	      flatMap(this, selector, thisArg) :
	      flatMap(this, function () { return selector; });
	  };
	
	  /**
	   * Projects each notification of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.
	   * @param {Function} onNext A transform function to apply to each element; the second parameter of the function represents the index of the source element.
	   * @param {Function} onError A transform function to apply when an error occurs in the source sequence.
	   * @param {Function} onCompleted A transform function to apply when the end of the source sequence is reached.
	   * @param {Any} [thisArg] An optional "this" to use to invoke each transform.
	   * @returns {Observable} An observable sequence whose elements are the result of invoking the one-to-many transform function corresponding to each notification in the input sequence.
	   */
	  observableProto.flatMapObserver = observableProto.selectManyObserver = function (onNext, onError, onCompleted, thisArg) {
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      var index = 0;
	
	      return source.subscribe(
	        function (x) {
	          var result;
	          try {
	            result = onNext.call(thisArg, x, index++);
	          } catch (e) {
	            observer.onError(e);
	            return;
	          }
	          isPromise(result) && (result = observableFromPromise(result));
	          observer.onNext(result);
	        },
	        function (err) {
	          var result;
	          try {
	            result = onError.call(thisArg, err);
	          } catch (e) {
	            observer.onError(e);
	            return;
	          }
	          isPromise(result) && (result = observableFromPromise(result));
	          observer.onNext(result);
	          observer.onCompleted();
	        },
	        function () {
	          var result;
	          try {
	            result = onCompleted.call(thisArg);
	          } catch (e) {
	            observer.onError(e);
	            return;
	          }
	          isPromise(result) && (result = observableFromPromise(result));
	          observer.onNext(result);
	          observer.onCompleted();
	        });
	    }).mergeAll();
	  };
	
	  /**
	   *  Projects each element of an observable sequence into a new sequence of observable sequences by incorporating the element's index and then
	   *  transforms an observable sequence of observable sequences into an observable sequence producing values only from the most recent observable sequence.
	   * @param {Function} selector A transform function to apply to each source element; the second parameter of the function represents the index of the source element.
	   * @param {Any} [thisArg] Object to use as this when executing callback.
	   * @returns {Observable} An observable sequence whose elements are the result of invoking the transform function on each element of source producing an Observable of Observable sequences
	   *  and that at any point in time produces the elements of the most recent inner observable sequence that has been received.
	   */
	  observableProto.selectSwitch = observableProto.flatMapLatest = observableProto.switchMap = function (selector, thisArg) {
	    return this.select(selector, thisArg).switchLatest();
	  };
	
	  /**
	   * Bypasses a specified number of elements in an observable sequence and then returns the remaining elements.
	   * @param {Number} count The number of elements to skip before returning the remaining elements.
	   * @returns {Observable} An observable sequence that contains the elements that occur after the specified index in the input sequence.
	   */
	  observableProto.skip = function (count) {
	      if (count < 0) { throw new Error(argumentOutOfRange); }
	      var source = this;
	      return new AnonymousObservable(function (observer) {
	        var remaining = count;
	        return source.subscribe(function (x) {
	          if (remaining <= 0) {
	            observer.onNext(x);
	          } else {
	            remaining--;
	          }
	        }, observer.onError.bind(observer), observer.onCompleted.bind(observer));
	      });
	  };
	
	  /**
	   *  Bypasses elements in an observable sequence as long as a specified condition is true and then returns the remaining elements.
	   *  The element's index is used in the logic of the predicate function.
	   *
	   *  var res = source.skipWhile(function (value) { return value < 10; });
	   *  var res = source.skipWhile(function (value, index) { return value < 10 || index < 10; });
	   * @param {Function} predicate A function to test each element for a condition; the second parameter of the function represents the index of the source element.
	   * @param {Any} [thisArg] Object to use as this when executing callback.
	   * @returns {Observable} An observable sequence that contains the elements from the input sequence starting at the first element in the linear series that does not pass the test specified by predicate.
	   */
	  observableProto.skipWhile = function (predicate, thisArg) {
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      var i = 0, running = false;
	      return source.subscribe(function (x) {
	        if (!running) {
	          try {
	            running = !predicate.call(thisArg, x, i++, source);
	          } catch (e) {
	            observer.onError(e);
	            return;
	          }
	        }
	        running && observer.onNext(x);
	      }, observer.onError.bind(observer), observer.onCompleted.bind(observer));
	    });
	  };
	
	  /**
	   *  Returns a specified number of contiguous elements from the start of an observable sequence, using the specified scheduler for the edge case of take(0).
	   *
	   *  var res = source.take(5);
	   *  var res = source.take(0, Rx.Scheduler.timeout);
	   * @param {Number} count The number of elements to return.
	   * @param {Scheduler} [scheduler] Scheduler used to produce an OnCompleted message in case <paramref name="count count</paramref> is set to 0.
	   * @returns {Observable} An observable sequence that contains the specified number of elements from the start of the input sequence.
	   */
	  observableProto.take = function (count, scheduler) {
	      if (count < 0) { throw new RangeError(argumentOutOfRange); }
	      if (count === 0) { return observableEmpty(scheduler); }
	      var observable = this;
	      return new AnonymousObservable(function (observer) {
	        var remaining = count;
	        return observable.subscribe(function (x) {
	          if (remaining-- > 0) {
	            observer.onNext(x);
	            remaining === 0 && observer.onCompleted();
	          }
	        }, observer.onError.bind(observer), observer.onCompleted.bind(observer));
	      });
	  };
	
	  /**
	   *  Returns elements from an observable sequence as long as a specified condition is true.
	   *  The element's index is used in the logic of the predicate function.
	   * @param {Function} predicate A function to test each element for a condition; the second parameter of the function represents the index of the source element.
	   * @param {Any} [thisArg] Object to use as this when executing callback.
	   * @returns {Observable} An observable sequence that contains the elements from the input sequence that occur before the element at which the test no longer passes.
	   */
	  observableProto.takeWhile = function (predicate, thisArg) {
	    var observable = this;
	    return new AnonymousObservable(function (observer) {
	      var i = 0, running = true;
	      return observable.subscribe(function (x) {
	        if (running) {
	          try {
	            running = predicate.call(thisArg, x, i++, observable);
	          } catch (e) {
	            observer.onError(e);
	            return;
	          }
	          if (running) {
	            observer.onNext(x);
	          } else {
	            observer.onCompleted();
	          }
	        }
	      }, observer.onError.bind(observer), observer.onCompleted.bind(observer));
	    });
	  };
	
	  /**
	   *  Filters the elements of an observable sequence based on a predicate by incorporating the element's index.
	   *
	   * @example
	   *  var res = source.where(function (value) { return value < 10; });
	   *  var res = source.where(function (value, index) { return value < 10 || index < 10; });
	   * @param {Function} predicate A function to test each source element for a condition; the second parameter of the function represents the index of the source element.
	   * @param {Any} [thisArg] Object to use as this when executing callback.
	   * @returns {Observable} An observable sequence that contains elements from the input sequence that satisfy the condition.
	   */
	  observableProto.where = observableProto.filter = function (predicate, thisArg) {
	      var parent = this;
	      return new AnonymousObservable(function (observer) {
	        var count = 0;
	        return parent.subscribe(function (value) {
	          var shouldRun;
	          try {
	            shouldRun = predicate.call(thisArg, value, count++, parent);
	          } catch (e) {
	            observer.onError(e);
	            return;
	          }
	          shouldRun && observer.onNext(value);
	        }, observer.onError.bind(observer), observer.onCompleted.bind(observer));
	      });
	  };
	
	  observableProto.finalValue = function () {
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      var hasValue = false, value;
	      return source.subscribe(function (x) {
	        hasValue = true;
	        value = x;
	      }, observer.onError.bind(observer), function () {
	        if (!hasValue) {
	          observer.onError(new Error(sequenceContainsNoElements));
	        } else {
	          observer.onNext(value);
	          observer.onCompleted();
	        }
	      });
	    });
	  };
	
	  function extremaBy(source, keySelector, comparer) {
	    return new AnonymousObservable(function (observer) {
	      var hasValue = false, lastKey = null, list = [];
	      return source.subscribe(function (x) {
	        var comparison, key;
	        try {
	          key = keySelector(x);
	        } catch (ex) {
	          observer.onError(ex);
	          return;
	        }
	        comparison = 0;
	        if (!hasValue) {
	          hasValue = true;
	          lastKey = key;
	        } else {
	          try {
	            comparison = comparer(key, lastKey);
	          } catch (ex1) {
	            observer.onError(ex1);
	            return;
	          }
	        }
	        if (comparison > 0) {
	          lastKey = key;
	          list = [];
	        }
	        if (comparison >= 0) { list.push(x); }
	      }, observer.onError.bind(observer), function () {
	        observer.onNext(list);
	        observer.onCompleted();
	      });
	    });
	  }
	
	    function firstOnly(x) {
	        if (x.length === 0) {
	            throw new Error(sequenceContainsNoElements);
	        }
	        return x[0];
	    }
	
	  /**
	   * Applies an accumulator function over an observable sequence, returning the result of the aggregation as a single element in the result sequence. The specified seed value is used as the initial accumulator value.
	   * For aggregation behavior with incremental intermediate results, see Observable.scan.
	   * @param {Mixed} [seed] The initial accumulator value.
	   * @param {Function} accumulator An accumulator function to be invoked on each element.
	   * @returns {Observable} An observable sequence containing a single element with the final accumulator value.
	   */
	  observableProto.aggregate = function () {
	    var seed, hasSeed, accumulator;
	    if (arguments.length === 2) {
	      seed = arguments[0];
	      hasSeed = true;
	      accumulator = arguments[1];
	    } else {
	      accumulator = arguments[0];
	    }
	    return hasSeed ? this.scan(seed, accumulator).startWith(seed).finalValue() : this.scan(accumulator).finalValue();
	  };
	
	  /**
	   * Applies an accumulator function over an observable sequence, returning the result of the aggregation as a single element in the result sequence. The specified seed value is used as the initial accumulator value.
	   * For aggregation behavior with incremental intermediate results, see Observable.scan.
	   * @param {Function} accumulator An accumulator function to be invoked on each element.
	   * @param {Any} [seed] The initial accumulator value.
	   * @returns {Observable} An observable sequence containing a single element with the final accumulator value.
	   */
	  observableProto.reduce = function (accumulator) {
	    var seed, hasSeed;
	    if (arguments.length === 2) {
	      hasSeed = true;
	      seed = arguments[1];
	    }
	    return hasSeed ? this.scan(seed, accumulator).startWith(seed).finalValue() : this.scan(accumulator).finalValue();
	  };
	
	    /**
	     * Determines whether any element of an observable sequence satisfies a condition if present, else if any items are in the sequence.
	     * @example
	     * var result = source.any();
	     * var result = source.any(function (x) { return x > 3; });
	     * @param {Function} [predicate] A function to test each element for a condition.
	     * @returns {Observable} An observable sequence containing a single element determining whether any elements in the source sequence pass the test in the specified predicate if given, else if any items are in the sequence.
	     */
	    observableProto.some = observableProto.any = function (predicate, thisArg) {
	        var source = this;
	        return predicate ?
	            source.where(predicate, thisArg).any() :
	            new AnonymousObservable(function (observer) {
	                return source.subscribe(function () {
	                    observer.onNext(true);
	                    observer.onCompleted();
	                }, observer.onError.bind(observer), function () {
	                    observer.onNext(false);
	                    observer.onCompleted();
	                });
	            });
	    };
	
	  /**
	   * Determines whether an observable sequence is empty.
	   * @returns {Observable} An observable sequence containing a single element determining whether the source sequence is empty.
	   */
	  observableProto.isEmpty = function () {
	    return this.any().map(not);
	  };
	
	    /**
	     * Determines whether all elements of an observable sequence satisfy a condition.
	     *
	     * 1 - res = source.all(function (value) { return value.length > 3; });
	     * @memberOf Observable#
	     * @param {Function} [predicate] A function to test each element for a condition.
	     * @param {Any} [thisArg] Object to use as this when executing callback.
	     * @returns {Observable} An observable sequence containing a single element determining whether all elements in the source sequence pass the test in the specified predicate.
	     */
	    observableProto.every = observableProto.all = function (predicate, thisArg) {
	        return this.where(function (v) {
	            return !predicate(v);
	        }, thisArg).any().select(function (b) {
	            return !b;
	        });
	    };
	
	  /**
	   * Determines whether an observable sequence contains a specified element with an optional equality comparer.
	   * @param searchElement The value to locate in the source sequence.
	   * @param {Number} [fromIndex] An equality comparer to compare elements.
	   * @returns {Observable} An observable sequence containing a single element determining whether the source sequence contains an element that has the specified value from the given index.
	   */
	  observableProto.contains = function (searchElement, fromIndex) {
	    var source = this;
	    function comparer(a, b) {
	      return (a === 0 && b === 0) || (a === b || (isNaN(a) && isNaN(b)));
	    }
	    return new AnonymousObservable(function (observer) {
	      var i = 0, n = +fromIndex || 0;
	      Math.abs(n) === Infinity && (n = 0);
	      if (n < 0) {
	        observer.onNext(false);
	        observer.onCompleted();
	        return disposableEmpty;
	      }
	      return source.subscribe(
	        function (x) {
	          if (i++ >= n && comparer(x, searchElement)) {
	            observer.onNext(true);
	            observer.onCompleted();
	          }
	        },
	        observer.onError.bind(observer),
	        function () {
	          observer.onNext(false);
	          observer.onCompleted();
	        });
	    });
	  };
	
	    /**
	     * Returns an observable sequence containing a value that represents how many elements in the specified observable sequence satisfy a condition if provided, else the count of items.
	     * @example
	     * res = source.count();
	     * res = source.count(function (x) { return x > 3; });
	     * @param {Function} [predicate]A function to test each element for a condition.
	     * @param {Any} [thisArg] Object to use as this when executing callback.
	     * @returns {Observable} An observable sequence containing a single element with a number that represents how many elements in the input sequence satisfy the condition in the predicate function if provided, else the count of items in the sequence.
	     */
	    observableProto.count = function (predicate, thisArg) {
	        return predicate ?
	            this.where(predicate, thisArg).count() :
	            this.aggregate(0, function (count) {
	                return count + 1;
	            });
	    };
	
	  /**
	   * Returns the first index at which a given element can be found in the observable sequence, or -1 if it is not present.
	   * @param {Any} searchElement Element to locate in the array.
	   * @param {Number} [fromIndex] The index to start the search.  If not specified, defaults to 0.
	   * @returns {Observable} And observable sequence containing the first index at which a given element can be found in the observable sequence, or -1 if it is not present.
	   */
	  observableProto.indexOf = function(searchElement, fromIndex) {
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      var i = 0, n = +fromIndex || 0;
	      Math.abs(n) === Infinity && (n = 0);
	      if (n < 0) {
	        observer.onNext(-1);
	        observer.onCompleted();
	        return disposableEmpty;
	      }
	      return source.subscribe(
	        function (x) {
	          if (i >= n && x === searchElement) {
	            observer.onNext(i);
	            observer.onCompleted();
	          }
	          i++;
	        },
	        observer.onError.bind(observer),
	        function () {
	          observer.onNext(-1);
	          observer.onCompleted();
	        });
	    });
	  };
	  /**
	   * Computes the sum of a sequence of values that are obtained by invoking an optional transform function on each element of the input sequence, else if not specified computes the sum on each item in the sequence.
	   * @example
	   * var res = source.sum();
	   * var res = source.sum(function (x) { return x.value; });
	   * @param {Function} [selector] A transform function to apply to each element.
	   * @param {Any} [thisArg] Object to use as this when executing callback.
	   * @returns {Observable} An observable sequence containing a single element with the sum of the values in the source sequence.
	   */
	  observableProto.sum = function (keySelector, thisArg) {
	    return keySelector && isFunction(keySelector) ?
	      this.map(keySelector, thisArg).sum() :
	      this.aggregate(0, function (prev, curr) {
	        return prev + curr;
	      });
	  };
	
	    /**
	     * Returns the elements in an observable sequence with the minimum key value according to the specified comparer.
	     * @example
	     * var res = source.minBy(function (x) { return x.value; });
	     * var res = source.minBy(function (x) { return x.value; }, function (x, y) { return x - y; });
	     * @param {Function} keySelector Key selector function.
	     * @param {Function} [comparer] Comparer used to compare key values.
	     * @returns {Observable} An observable sequence containing a list of zero or more elements that have a minimum key value.
	     */
	    observableProto.minBy = function (keySelector, comparer) {
	        comparer || (comparer = defaultSubComparer);
	        return extremaBy(this, keySelector, function (x, y) {
	            return comparer(x, y) * -1;
	        });
	    };
	
	    /**
	     * Returns the minimum element in an observable sequence according to the optional comparer else a default greater than less than check.
	     * @example
	     * var res = source.min();
	     * var res = source.min(function (x, y) { return x.value - y.value; });
	     * @param {Function} [comparer] Comparer used to compare elements.
	     * @returns {Observable} An observable sequence containing a single element with the minimum element in the source sequence.
	     */
	    observableProto.min = function (comparer) {
	        return this.minBy(identity, comparer).select(function (x) {
	            return firstOnly(x);
	        });
	    };
	
	    /**
	     * Returns the elements in an observable sequence with the maximum  key value according to the specified comparer.
	     * @example
	     * var res = source.maxBy(function (x) { return x.value; });
	     * var res = source.maxBy(function (x) { return x.value; }, function (x, y) { return x - y;; });
	     * @param {Function} keySelector Key selector function.
	     * @param {Function} [comparer]  Comparer used to compare key values.
	     * @returns {Observable} An observable sequence containing a list of zero or more elements that have a maximum key value.
	     */
	    observableProto.maxBy = function (keySelector, comparer) {
	        comparer || (comparer = defaultSubComparer);
	        return extremaBy(this, keySelector, comparer);
	    };
	
	    /**
	     * Returns the maximum value in an observable sequence according to the specified comparer.
	     * @example
	     * var res = source.max();
	     * var res = source.max(function (x, y) { return x.value - y.value; });
	     * @param {Function} [comparer] Comparer used to compare elements.
	     * @returns {Observable} An observable sequence containing a single element with the maximum element in the source sequence.
	     */
	    observableProto.max = function (comparer) {
	        return this.maxBy(identity, comparer).select(function (x) {
	            return firstOnly(x);
	        });
	    };
	
	  /**
	   * Computes the average of an observable sequence of values that are in the sequence or obtained by invoking a transform function on each element of the input sequence if present.
	   * @param {Function} [selector] A transform function to apply to each element.
	   * @param {Any} [thisArg] Object to use as this when executing callback.
	   * @returns {Observable} An observable sequence containing a single element with the average of the sequence of values.
	   */
	  observableProto.average = function (keySelector, thisArg) {
	    return keySelector && isFunction(keySelector) ?
	      this.select(keySelector, thisArg).average() :
	      this.scan({sum: 0, count: 0 }, function (prev, cur) {
	        return {
	          sum: prev.sum + cur,
	          count: prev.count + 1
	        };
	      }).finalValue().map(function (s) {
	        if (s.count === 0) {
	          throw new Error('The input sequence was empty');
	        }
	        return s.sum / s.count;
	      });
	  };
	
	  function sequenceEqualArray(first, second, comparer) {
	    return new AnonymousObservable(function (observer) {
	      var count = 0, len = second.length;
	      return first.subscribe(function (value) {
	        var equal = false;
	        try {
	          count < len && (equal = comparer(value, second[count++]));
	        } catch (e) {
	          observer.onError(e);
	          return;
	        }
	        if (!equal) {
	          observer.onNext(false);
	          observer.onCompleted();
	        }
	      }, observer.onError.bind(observer), function () {
	        observer.onNext(count === len);
	        observer.onCompleted();
	      });
	    });
	  }
	
	  /**
	   *  Determines whether two sequences are equal by comparing the elements pairwise using a specified equality comparer.
	   *
	   * @example
	   * var res = res = source.sequenceEqual([1,2,3]);
	   * var res = res = source.sequenceEqual([{ value: 42 }], function (x, y) { return x.value === y.value; });
	   * 3 - res = source.sequenceEqual(Rx.Observable.returnValue(42));
	   * 4 - res = source.sequenceEqual(Rx.Observable.returnValue({ value: 42 }), function (x, y) { return x.value === y.value; });
	   * @param {Observable} second Second observable sequence or array to compare.
	   * @param {Function} [comparer] Comparer used to compare elements of both sequences.
	   * @returns {Observable} An observable sequence that contains a single element which indicates whether both sequences are of equal length and their corresponding elements are equal according to the specified equality comparer.
	   */
	  observableProto.sequenceEqual = function (second, comparer) {
	    var first = this;
	    comparer || (comparer = defaultComparer);
	    if (Array.isArray(second)) {
	      return sequenceEqualArray(first, second, comparer);
	    }
	    return new AnonymousObservable(function (observer) {
	      var donel = false, doner = false, ql = [], qr = [];
	      var subscription1 = first.subscribe(function (x) {
	        var equal, v;
	        if (qr.length > 0) {
	          v = qr.shift();
	          try {
	            equal = comparer(v, x);
	          } catch (e) {
	            observer.onError(e);
	            return;
	          }
	          if (!equal) {
	            observer.onNext(false);
	            observer.onCompleted();
	          }
	        } else if (doner) {
	          observer.onNext(false);
	          observer.onCompleted();
	        } else {
	          ql.push(x);
	        }
	      }, observer.onError.bind(observer), function () {
	        donel = true;
	        if (ql.length === 0) {
	          if (qr.length > 0) {
	            observer.onNext(false);
	            observer.onCompleted();
	          } else if (doner) {
	            observer.onNext(true);
	            observer.onCompleted();
	          }
	        }
	      });
	
	      isPromise(second) && (second = observableFromPromise(second));
	      var subscription2 = second.subscribe(function (x) {
	        var equal;
	        if (ql.length > 0) {
	          var v = ql.shift();
	          try {
	            equal = comparer(v, x);
	          } catch (exception) {
	            observer.onError(exception);
	            return;
	          }
	          if (!equal) {
	            observer.onNext(false);
	            observer.onCompleted();
	          }
	        } else if (donel) {
	          observer.onNext(false);
	          observer.onCompleted();
	        } else {
	          qr.push(x);
	        }
	      }, observer.onError.bind(observer), function () {
	        doner = true;
	        if (qr.length === 0) {
	          if (ql.length > 0) {
	            observer.onNext(false);
	            observer.onCompleted();
	          } else if (donel) {
	            observer.onNext(true);
	            observer.onCompleted();
	          }
	        }
	      });
	      return new CompositeDisposable(subscription1, subscription2);
	    });
	  };
	
	    function elementAtOrDefault(source, index, hasDefault, defaultValue) {
	        if (index < 0) {
	            throw new Error(argumentOutOfRange);
	        }
	        return new AnonymousObservable(function (observer) {
	            var i = index;
	            return source.subscribe(function (x) {
	                if (i === 0) {
	                    observer.onNext(x);
	                    observer.onCompleted();
	                }
	                i--;
	            }, observer.onError.bind(observer), function () {
	                if (!hasDefault) {
	                    observer.onError(new Error(argumentOutOfRange));
	                } else {
	                    observer.onNext(defaultValue);
	                    observer.onCompleted();
	                }
	            });
	        });
	    }
	
	    /**
	     * Returns the element at a specified index in a sequence.
	     * @example
	     * var res = source.elementAt(5);
	     * @param {Number} index The zero-based index of the element to retrieve.
	     * @returns {Observable} An observable sequence that produces the element at the specified position in the source sequence.
	     */
	    observableProto.elementAt =  function (index) {
	        return elementAtOrDefault(this, index, false);
	    };
	
	    /**
	     * Returns the element at a specified index in a sequence or a default value if the index is out of range.
	     * @example
	     * var res = source.elementAtOrDefault(5);
	     * var res = source.elementAtOrDefault(5, 0);
	     * @param {Number} index The zero-based index of the element to retrieve.
	     * @param [defaultValue] The default value if the index is outside the bounds of the source sequence.
	     * @returns {Observable} An observable sequence that produces the element at the specified position in the source sequence, or a default value if the index is outside the bounds of the source sequence.
	     */
	    observableProto.elementAtOrDefault = function (index, defaultValue) {
	        return elementAtOrDefault(this, index, true, defaultValue);
	    };
	
	  function singleOrDefaultAsync(source, hasDefault, defaultValue) {
	    return new AnonymousObservable(function (observer) {
	      var value = defaultValue, seenValue = false;
	      return source.subscribe(function (x) {
	        if (seenValue) {
	          observer.onError(new Error('Sequence contains more than one element'));
	        } else {
	          value = x;
	          seenValue = true;
	        }
	      }, observer.onError.bind(observer), function () {
	        if (!seenValue && !hasDefault) {
	          observer.onError(new Error(sequenceContainsNoElements));
	        } else {
	          observer.onNext(value);
	          observer.onCompleted();
	        }
	      });
	    });
	  }
	
	  /**
	   * Returns the only element of an observable sequence that satisfies the condition in the optional predicate, and reports an exception if there is not exactly one element in the observable sequence.
	   * @example
	   * var res = res = source.single();
	   * var res = res = source.single(function (x) { return x === 42; });
	   * @param {Function} [predicate] A predicate function to evaluate for elements in the source sequence.
	   * @param {Any} [thisArg] Object to use as `this` when executing the predicate.
	   * @returns {Observable} Sequence containing the single element in the observable sequence that satisfies the condition in the predicate.
	   */
	  observableProto.single = function (predicate, thisArg) {
	    return predicate && isFunction(predicate) ?
	      this.where(predicate, thisArg).single() :
	      singleOrDefaultAsync(this, false);
	  };
	
	  /**
	   * Returns the only element of an observable sequence that matches the predicate, or a default value if no such element exists; this method reports an exception if there is more than one element in the observable sequence.
	   * @example
	   * var res = res = source.singleOrDefault();
	   * var res = res = source.singleOrDefault(function (x) { return x === 42; });
	   * res = source.singleOrDefault(function (x) { return x === 42; }, 0);
	   * res = source.singleOrDefault(null, 0);
	   * @memberOf Observable#
	   * @param {Function} predicate A predicate function to evaluate for elements in the source sequence.
	   * @param [defaultValue] The default value if the index is outside the bounds of the source sequence.
	   * @param {Any} [thisArg] Object to use as `this` when executing the predicate.
	   * @returns {Observable} Sequence containing the single element in the observable sequence that satisfies the condition in the predicate, or a default value if no such element exists.
	   */
	  observableProto.singleOrDefault = function (predicate, defaultValue, thisArg) {
	    return predicate && isFunction(predicate) ?
	      this.where(predicate, thisArg).singleOrDefault(null, defaultValue) :
	      singleOrDefaultAsync(this, true, defaultValue);
	  };
	
	    function firstOrDefaultAsync(source, hasDefault, defaultValue) {
	        return new AnonymousObservable(function (observer) {
	            return source.subscribe(function (x) {
	                observer.onNext(x);
	                observer.onCompleted();
	            }, observer.onError.bind(observer), function () {
	                if (!hasDefault) {
	                    observer.onError(new Error(sequenceContainsNoElements));
	                } else {
	                    observer.onNext(defaultValue);
	                    observer.onCompleted();
	                }
	            });
	        });
	    }
	
	    /**
	     * Returns the first element of an observable sequence that satisfies the condition in the predicate if present else the first item in the sequence.
	     * @example
	     * var res = res = source.first();
	     * var res = res = source.first(function (x) { return x > 3; });
	     * @param {Function} [predicate] A predicate function to evaluate for elements in the source sequence.
	     * @param {Any} [thisArg] Object to use as `this` when executing the predicate.
	     * @returns {Observable} Sequence containing the first element in the observable sequence that satisfies the condition in the predicate if provided, else the first item in the sequence.
	     */
	    observableProto.first = function (predicate, thisArg) {
	        return predicate ?
	            this.where(predicate, thisArg).first() :
	            firstOrDefaultAsync(this, false);
	    };
	
	    /**
	     * Returns the first element of an observable sequence that satisfies the condition in the predicate, or a default value if no such element exists.
	     * @example
	     * var res = res = source.firstOrDefault();
	     * var res = res = source.firstOrDefault(function (x) { return x > 3; });
	     * var res = source.firstOrDefault(function (x) { return x > 3; }, 0);
	     * var res = source.firstOrDefault(null, 0);
	     * @param {Function} [predicate] A predicate function to evaluate for elements in the source sequence.
	     * @param {Any} [defaultValue] The default value if no such element exists.  If not specified, defaults to null.
	     * @param {Any} [thisArg] Object to use as `this` when executing the predicate.
	     * @returns {Observable} Sequence containing the first element in the observable sequence that satisfies the condition in the predicate, or a default value if no such element exists.
	     */
	    observableProto.firstOrDefault = function (predicate, defaultValue, thisArg) {
	        return predicate ?
	            this.where(predicate).firstOrDefault(null, defaultValue) :
	            firstOrDefaultAsync(this, true, defaultValue);
	    };
	
	    function lastOrDefaultAsync(source, hasDefault, defaultValue) {
	        return new AnonymousObservable(function (observer) {
	            var value = defaultValue, seenValue = false;
	            return source.subscribe(function (x) {
	                value = x;
	                seenValue = true;
	            }, observer.onError.bind(observer), function () {
	                if (!seenValue && !hasDefault) {
	                    observer.onError(new Error(sequenceContainsNoElements));
	                } else {
	                    observer.onNext(value);
	                    observer.onCompleted();
	                }
	            });
	        });
	    }
	
	    /**
	     * Returns the last element of an observable sequence that satisfies the condition in the predicate if specified, else the last element.
	     * @example
	     * var res = source.last();
	     * var res = source.last(function (x) { return x > 3; });
	     * @param {Function} [predicate] A predicate function to evaluate for elements in the source sequence.
	     * @param {Any} [thisArg] Object to use as `this` when executing the predicate.
	     * @returns {Observable} Sequence containing the last element in the observable sequence that satisfies the condition in the predicate.
	     */
	    observableProto.last = function (predicate, thisArg) {
	        return predicate ?
	            this.where(predicate, thisArg).last() :
	            lastOrDefaultAsync(this, false);
	    };
	
	    /**
	     * Returns the last element of an observable sequence that satisfies the condition in the predicate, or a default value if no such element exists.
	     * @example
	     * var res = source.lastOrDefault();
	     * var res = source.lastOrDefault(function (x) { return x > 3; });
	     * var res = source.lastOrDefault(function (x) { return x > 3; }, 0);
	     * var res = source.lastOrDefault(null, 0);
	     * @param {Function} [predicate] A predicate function to evaluate for elements in the source sequence.
	     * @param [defaultValue] The default value if no such element exists.  If not specified, defaults to null.
	     * @param {Any} [thisArg] Object to use as `this` when executing the predicate.
	     * @returns {Observable} Sequence containing the last element in the observable sequence that satisfies the condition in the predicate, or a default value if no such element exists.
	     */
	    observableProto.lastOrDefault = function (predicate, defaultValue, thisArg) {
	        return predicate ?
	            this.where(predicate, thisArg).lastOrDefault(null, defaultValue) :
	            lastOrDefaultAsync(this, true, defaultValue);
	    };
	
	    function findValue (source, predicate, thisArg, yieldIndex) {
	        return new AnonymousObservable(function (observer) {
	            var i = 0;
	            return source.subscribe(function (x) {
	                var shouldRun;
	                try {
	                    shouldRun = predicate.call(thisArg, x, i, source);
	                } catch(e) {
	                    observer.onError(e);
	                    return;
	                }
	                if (shouldRun) {
	                    observer.onNext(yieldIndex ? i : x);
	                    observer.onCompleted();
	                } else {
	                    i++;
	                }
	            }, observer.onError.bind(observer), function () {
	                observer.onNext(yieldIndex ? -1 : undefined);
	                observer.onCompleted();
	            });
	        });
	    }
	
	    /**
	     * Searches for an element that matches the conditions defined by the specified predicate, and returns the first occurrence within the entire Observable sequence.
	     * @param {Function} predicate The predicate that defines the conditions of the element to search for.
	     * @param {Any} [thisArg] Object to use as `this` when executing the predicate.
	     * @returns {Observable} An Observable sequence with the first element that matches the conditions defined by the specified predicate, if found; otherwise, undefined.
	     */
	    observableProto.find = function (predicate, thisArg) {
	        return findValue(this, predicate, thisArg, false);
	    };
	
	    /**
	     * Searches for an element that matches the conditions defined by the specified predicate, and returns
	     * an Observable sequence with the zero-based index of the first occurrence within the entire Observable sequence.
	     * @param {Function} predicate The predicate that defines the conditions of the element to search for.
	     * @param {Any} [thisArg] Object to use as `this` when executing the predicate.
	     * @returns {Observable} An Observable sequence with the zero-based index of the first occurrence of an element that matches the conditions defined by match, if found; otherwise, 1.
	    */
	    observableProto.findIndex = function (predicate, thisArg) {
	        return findValue(this, predicate, thisArg, true);
	    };
	
	  if (!!root.Set) {
	    /**
	     * Converts the observable sequence to a Set if it exists.
	     * @returns {Observable} An observable sequence with a single value of a Set containing the values from the observable sequence.
	     */
	    observableProto.toSet = function () {
	      var source = this;
	      return new AnonymousObservable(function (observer) {
	        var s = new root.Set();
	        return source.subscribe(
	          s.add.bind(s),
	          observer.onError.bind(observer),
	          function () {
	            observer.onNext(s);
	            observer.onCompleted();
	          });
	      });
	    };
	  }
	
	  if (!!root.Map) {
	    /**
	    * Converts the observable sequence to a Map if it exists.
	    * @param {Function} keySelector A function which produces the key for the Map.
	    * @param {Function} [elementSelector] An optional function which produces the element for the Map. If not present, defaults to the value from the observable sequence.
	    * @returns {Observable} An observable sequence with a single value of a Map containing the values from the observable sequence.
	    */
	    observableProto.toMap = function (keySelector, elementSelector) {
	      var source = this;
	      return new AnonymousObservable(function (observer) {
	        var m = new root.Map();
	        return source.subscribe(
	          function (x) {
	            var key;
	            try {
	              key = keySelector(x);
	            } catch (e) {
	              observer.onError(e);
	              return;
	            }
	
	            var element = x;
	            if (elementSelector) {
	              try {
	                element = elementSelector(x);
	              } catch (e) {
	                observer.onError(e);
	                return;
	              }
	            }
	
	            m.set(key, element);
	          },
	          observer.onError.bind(observer),
	          function () {
	            observer.onNext(m);
	            observer.onCompleted();
	          });
	      });
	    };
	  }
	
	  var fnString = 'function',
	      throwString = 'throw';
	
	  function toThunk(obj, ctx) {
	    if (Array.isArray(obj)) {  return objectToThunk.call(ctx, obj); }
	    if (isGeneratorFunction(obj)) { return observableSpawn(obj.call(ctx)); }
	    if (isGenerator(obj)) {  return observableSpawn(obj); }
	    if (isObservable(obj)) { return observableToThunk(obj); }
	    if (isPromise(obj)) { return promiseToThunk(obj); }
	    if (typeof obj === fnString) { return obj; }
	    if (isObject(obj) || Array.isArray(obj)) { return objectToThunk.call(ctx, obj); }
	
	    return obj;
	  }
	
	  function objectToThunk(obj) {
	    var ctx = this;
	
	    return function (done) {
	      var keys = Object.keys(obj),
	          pending = keys.length,
	          results = new obj.constructor(),
	          finished;
	
	      if (!pending) {
	        timeoutScheduler.schedule(function () { done(null, results); });
	        return;
	      }
	
	      for (var i = 0, len = keys.length; i < len; i++) {
	        run(obj[keys[i]], keys[i]);
	      }
	
	      function run(fn, key) {
	        if (finished) { return; }
	        try {
	          fn = toThunk(fn, ctx);
	
	          if (typeof fn !== fnString) {
	            results[key] = fn;
	            return --pending || done(null, results);
	          }
	
	          fn.call(ctx, function(err, res){
	            if (finished) { return; }
	
	            if (err) {
	              finished = true;
	              return done(err);
	            }
	
	            results[key] = res;
	            --pending || done(null, results);
	          });
	        } catch (e) {
	          finished = true;
	          done(e);
	        }
	      }
	    }
	  }
	
	  function observableToThunk(observable) {
	    return function (fn) {
	      var value, hasValue = false;
	      observable.subscribe(
	        function (v) {
	          value = v;
	          hasValue = true;
	        },
	        fn,
	        function () {
	          hasValue && fn(null, value);
	        });
	    }
	  }
	
	  function promiseToThunk(promise) {
	    return function(fn){
	      promise.then(function(res) {
	        fn(null, res);
	      }, fn);
	    }
	  }
	
	  function isObservable(obj) {
	    return obj && typeof obj.subscribe === fnString;
	  }
	
	  function isGeneratorFunction(obj) {
	    return obj && obj.constructor && obj.constructor.name === 'GeneratorFunction';
	  }
	
	  function isGenerator(obj) {
	    return obj && typeof obj.next === fnString && typeof obj[throwString] === fnString;
	  }
	
	  function isObject(val) {
	    return val && val.constructor === Object;
	  }
	
	  /*
	   * Spawns a generator function which allows for Promises, Observable sequences, Arrays, Objects, Generators and functions.
	   * @param {Function} The spawning function.
	   * @returns {Function} a function which has a done continuation.
	   */
	  var observableSpawn = Rx.spawn = function (fn) {
	    var isGenFun = isGeneratorFunction(fn);
	
	    return function (done) {
	      var ctx = this,
	        gen = fn;
	
	      if (isGenFun) {
	        var args = slice.call(arguments),
	          len = args.length,
	          hasCallback = len && typeof args[len - 1] === fnString;
	
	        done = hasCallback ? args.pop() : error;
	        gen = fn.apply(this, args);
	      } else {
	        done = done || error;
	      }
	
	      next();
	
	      function exit(err, res) {
	        timeoutScheduler.schedule(done.bind(ctx, err, res));
	      }
	
	      function next(err, res) {
	        var ret;
	
	        // multiple args
	        if (arguments.length > 2) res = slice.call(arguments, 1);
	
	        if (err) {
	          try {
	            ret = gen[throwString](err);
	          } catch (e) {
	            return exit(e);
	          }
	        }
	
	        if (!err) {
	          try {
	            ret = gen.next(res);
	          } catch (e) {
	            return exit(e);
	          }
	        }
	
	        if (ret.done)  {
	          return exit(null, ret.value);
	        }
	
	        ret.value = toThunk(ret.value, ctx);
	
	        if (typeof ret.value === fnString) {
	          var called = false;
	          try {
	            ret.value.call(ctx, function(){
	              if (called) {
	                return;
	              }
	
	              called = true;
	              next.apply(ctx, arguments);
	            });
	          } catch (e) {
	            timeoutScheduler.schedule(function () {
	              if (called) {
	                return;
	              }
	
	              called = true;
	              next.call(ctx, e);
	            });
	          }
	          return;
	        }
	
	        // Not supported
	        next(new TypeError('Rx.spawn only supports a function, Promise, Observable, Object or Array.'));
	      }
	    }
	  };
	
	  /**
	   * Takes a function with a callback and turns it into a thunk.
	   * @param {Function} A function with a callback such as fs.readFile
	   * @returns {Function} A function, when executed will continue the state machine.
	   */
	  Rx.denodify = function (fn) {
	    return function (){
	      var args = slice.call(arguments),
	        results,
	        called,
	        callback;
	
	      args.push(function(){
	        results = arguments;
	
	        if (callback && !called) {
	          called = true;
	          cb.apply(this, results);
	        }
	      });
	
	      fn.apply(this, args);
	
	      return function (fn){
	        callback = fn;
	
	        if (results && !called) {
	          called = true;
	          fn.apply(this, results);
	        }
	      }
	    }
	  };
	
	  function error(err) {
	    if (!err) { return; }
	    timeoutScheduler.schedule(function(){
	      throw err;
	    });
	  }
	
	  /**
	   * Invokes the specified function asynchronously on the specified scheduler, surfacing the result through an observable sequence.
	   *
	   * @example
	   * var res = Rx.Observable.start(function () { console.log('hello'); });
	   * var res = Rx.Observable.start(function () { console.log('hello'); }, Rx.Scheduler.timeout);
	   * var res = Rx.Observable.start(function () { this.log('hello'); }, Rx.Scheduler.timeout, console);
	   *
	   * @param {Function} func Function to run asynchronously.
	   * @param {Scheduler} [scheduler]  Scheduler to run the function on. If not specified, defaults to Scheduler.timeout.
	   * @param [context]  The context for the func parameter to be executed.  If not specified, defaults to undefined.
	   * @returns {Observable} An observable sequence exposing the function's result value, or an exception.
	   *
	   * Remarks
	   * * The function is called immediately, not during the subscription of the resulting sequence.
	   * * Multiple subscriptions to the resulting sequence can observe the function's result.
	   */
	  Observable.start = function (func, context, scheduler) {
	    return observableToAsync(func, context, scheduler)();
	  };
	
	  /**
	   * Converts the function into an asynchronous function. Each invocation of the resulting asynchronous function causes an invocation of the original synchronous function on the specified scheduler.
	   *
	   * @example
	   * var res = Rx.Observable.toAsync(function (x, y) { return x + y; })(4, 3);
	   * var res = Rx.Observable.toAsync(function (x, y) { return x + y; }, Rx.Scheduler.timeout)(4, 3);
	   * var res = Rx.Observable.toAsync(function (x) { this.log(x); }, Rx.Scheduler.timeout, console)('hello');
	   *
	   * @param {Function} function Function to convert to an asynchronous function.
	   * @param {Scheduler} [scheduler] Scheduler to run the function on. If not specified, defaults to Scheduler.timeout.
	   * @param {Mixed} [context] The context for the func parameter to be executed.  If not specified, defaults to undefined.
	   * @returns {Function} Asynchronous function.
	   */
	  var observableToAsync = Observable.toAsync = function (func, context, scheduler) {
	    isScheduler(scheduler) || (scheduler = timeoutScheduler);
	    return function () {
	      var args = arguments,
	        subject = new AsyncSubject();
	
	      scheduler.schedule(function () {
	        var result;
	        try {
	          result = func.apply(context, args);
	        } catch (e) {
	          subject.onError(e);
	          return;
	        }
	        subject.onNext(result);
	        subject.onCompleted();
	      });
	      return subject.asObservable();
	    };
	  };
	
	  /**
	   * Converts a callback function to an observable sequence.
	   *
	   * @param {Function} function Function with a callback as the last parameter to convert to an Observable sequence.
	   * @param {Mixed} [context] The context for the func parameter to be executed.  If not specified, defaults to undefined.
	   * @param {Function} [selector] A selector which takes the arguments from the callback to produce a single item to yield on next.
	   * @returns {Function} A function, when executed with the required parameters minus the callback, produces an Observable sequence with a single value of the arguments to the callback as an array.
	   */
	  Observable.fromCallback = function (func, context, selector) {
	    return function () {
	      var args = slice.call(arguments, 0);
	
	      return new AnonymousObservable(function (observer) {
	        function handler(e) {
	          var results = e;
	
	          if (selector) {
	            try {
	              results = selector(arguments);
	            } catch (err) {
	              observer.onError(err);
	              return;
	            }
	
	            observer.onNext(results);
	          } else {
	            if (results.length <= 1) {
	              observer.onNext.apply(observer, results);
	            } else {
	              observer.onNext(results);
	            }
	          }
	
	          observer.onCompleted();
	        }
	
	        args.push(handler);
	        func.apply(context, args);
	      }).publishLast().refCount();
	    };
	  };
	
	  /**
	   * Converts a Node.js callback style function to an observable sequence.  This must be in function (err, ...) format.
	   * @param {Function} func The function to call
	   * @param {Mixed} [context] The context for the func parameter to be executed.  If not specified, defaults to undefined.
	   * @param {Function} [selector] A selector which takes the arguments from the callback minus the error to produce a single item to yield on next.
	   * @returns {Function} An async function which when applied, returns an observable sequence with the callback arguments as an array.
	   */
	  Observable.fromNodeCallback = function (func, context, selector) {
	    return function () {
	      var args = slice.call(arguments, 0);
	
	      return new AnonymousObservable(function (observer) {
	        function handler(err) {
	          if (err) {
	            observer.onError(err);
	            return;
	          }
	
	          var results = slice.call(arguments, 1);
	
	          if (selector) {
	            try {
	              results = selector(results);
	            } catch (e) {
	              observer.onError(e);
	              return;
	            }
	            observer.onNext(results);
	          } else {
	            if (results.length <= 1) {
	              observer.onNext.apply(observer, results);
	            } else {
	              observer.onNext(results);
	            }
	          }
	
	          observer.onCompleted();
	        }
	
	        args.push(handler);
	        func.apply(context, args);
	      }).publishLast().refCount();
	    };
	  };
	
	  function createListener (element, name, handler) {
	    if (element.addEventListener) {
	      element.addEventListener(name, handler, false);
	      return disposableCreate(function () {
	        element.removeEventListener(name, handler, false);
	      });
	    }
	    throw new Error('No listener found');
	  }
	
	  function createEventListener (el, eventName, handler) {
	    var disposables = new CompositeDisposable();
	
	    // Asume NodeList
	    if (Object.prototype.toString.call(el) === '[object NodeList]') {
	      for (var i = 0, len = el.length; i < len; i++) {
	        disposables.add(createEventListener(el.item(i), eventName, handler));
	      }
	    } else if (el) {
	      disposables.add(createListener(el, eventName, handler));
	    }
	
	    return disposables;
	  }
	
	  /**
	   * Configuration option to determine whether to use native events only
	   */
	  Rx.config.useNativeEvents = false;
	
	  // Check for Angular/jQuery/Zepto support
	  var jq =
	   !!root.angular && !!angular.element ? angular.element :
	   (!!root.jQuery ? root.jQuery : (
	     !!root.Zepto ? root.Zepto : null));
	
	  // Check for ember
	  var ember = !!root.Ember && typeof root.Ember.addListener === 'function';
	
	  // Check for Backbone.Marionette. Note if using AMD add Marionette as a dependency of rxjs
	  // for proper loading order!
	  var marionette = !!root.Backbone && !!root.Backbone.Marionette;
	
	  /**
	   * Creates an observable sequence by adding an event listener to the matching DOMElement or each item in the NodeList.
	   *
	   * @example
	   *   var source = Rx.Observable.fromEvent(element, 'mouseup');
	   *
	   * @param {Object} element The DOMElement or NodeList to attach a listener.
	   * @param {String} eventName The event name to attach the observable sequence.
	   * @param {Function} [selector] A selector which takes the arguments from the event handler to produce a single item to yield on next.
	   * @returns {Observable} An observable sequence of events from the specified element and the specified event.
	   */
	  Observable.fromEvent = function (element, eventName, selector) {
	    // Node.js specific
	    if (element.addListener) {
	      return fromEventPattern(
	        function (h) { element.addListener(eventName, h); },
	        function (h) { element.removeListener(eventName, h); },
	        selector);
	    }
	
	    // Use only if non-native events are allowed
	    if (!Rx.config.useNativeEvents) {
	      if (marionette) {
	        return fromEventPattern(
	          function (h) { element.on(eventName, h); },
	          function (h) { element.off(eventName, h); },
	          selector);
	      }
	      if (ember) {
	        return fromEventPattern(
	          function (h) { Ember.addListener(element, eventName, h); },
	          function (h) { Ember.removeListener(element, eventName, h); },
	          selector);
	      }
	      if (jq) {
	        var $elem = jq(element);
	        return fromEventPattern(
	          function (h) { $elem.on(eventName, h); },
	          function (h) { $elem.off(eventName, h); },
	          selector);
	      }
	    }
	    return new AnonymousObservable(function (observer) {
	      return createEventListener(
	        element,
	        eventName,
	        function handler (e) {
	          var results = e;
	
	          if (selector) {
	            try {
	              results = selector(arguments);
	            } catch (err) {
	              observer.onError(err);
	              return
	            }
	          }
	
	          observer.onNext(results);
	        });
	    }).publish().refCount();
	  };
	
	  /**
	   * Creates an observable sequence from an event emitter via an addHandler/removeHandler pair.
	   * @param {Function} addHandler The function to add a handler to the emitter.
	   * @param {Function} [removeHandler] The optional function to remove a handler from an emitter.
	   * @param {Function} [selector] A selector which takes the arguments from the event handler to produce a single item to yield on next.
	   * @returns {Observable} An observable sequence which wraps an event from an event emitter
	   */
	  var fromEventPattern = Observable.fromEventPattern = function (addHandler, removeHandler, selector) {
	    return new AnonymousObservable(function (observer) {
	      function innerHandler (e) {
	        var result = e;
	        if (selector) {
	          try {
	            result = selector(arguments);
	          } catch (err) {
	            observer.onError(err);
	            return;
	          }
	        }
	        observer.onNext(result);
	      }
	
	      var returnValue = addHandler(innerHandler);
	      return disposableCreate(function () {
	        if (removeHandler) {
	          removeHandler(innerHandler, returnValue);
	        }
	      });
	    }).publish().refCount();
	  };
	
	  /**
	   * Invokes the asynchronous function, surfacing the result through an observable sequence.
	   * @param {Function} functionAsync Asynchronous function which returns a Promise to run.
	   * @returns {Observable} An observable sequence exposing the function's result value, or an exception.
	   */
	  Observable.startAsync = function (functionAsync) {
	    var promise;
	    try {
	      promise = functionAsync();
	    } catch (e) {
	      return observableThrow(e);
	    }
	    return observableFromPromise(promise);
	  }
	
	  var PausableObservable = (function (_super) {
	
	    inherits(PausableObservable, _super);
	
	    function subscribe(observer) {
	      var conn = this.source.publish(),
	        subscription = conn.subscribe(observer),
	        connection = disposableEmpty;
	
	      var pausable = this.pauser.distinctUntilChanged().subscribe(function (b) {
	        if (b) {
	          connection = conn.connect();
	        } else {
	          connection.dispose();
	          connection = disposableEmpty;
	        }
	      });
	
	      return new CompositeDisposable(subscription, connection, pausable);
	    }
	
	    function PausableObservable(source, pauser) {
	      this.source = source;
	      this.controller = new Subject();
	
	      if (pauser && pauser.subscribe) {
	        this.pauser = this.controller.merge(pauser);
	      } else {
	        this.pauser = this.controller;
	      }
	
	      _super.call(this, subscribe);
	    }
	
	    PausableObservable.prototype.pause = function () {
	      this.controller.onNext(false);
	    };
	
	    PausableObservable.prototype.resume = function () {
	      this.controller.onNext(true);
	    };
	
	    return PausableObservable;
	
	  }(Observable));
	
	  /**
	   * Pauses the underlying observable sequence based upon the observable sequence which yields true/false.
	   * @example
	   * var pauser = new Rx.Subject();
	   * var source = Rx.Observable.interval(100).pausable(pauser);
	   * @param {Observable} pauser The observable sequence used to pause the underlying sequence.
	   * @returns {Observable} The observable sequence which is paused based upon the pauser.
	   */
	  observableProto.pausable = function (pauser) {
	    return new PausableObservable(this, pauser);
	  };
	
	  function combineLatestSource(source, subject, resultSelector) {
	    return new AnonymousObservable(function (observer) {
	      var n = 2,
	        hasValue = [false, false],
	        hasValueAll = false,
	        isDone = false,
	        values = new Array(n);
	
	      function next(x, i) {
	        values[i] = x
	        var res;
	        hasValue[i] = true;
	        if (hasValueAll || (hasValueAll = hasValue.every(identity))) {
	          try {
	            res = resultSelector.apply(null, values);
	          } catch (ex) {
	            observer.onError(ex);
	            return;
	          }
	          observer.onNext(res);
	        } else if (isDone) {
	          observer.onCompleted();
	        }
	      }
	
	      return new CompositeDisposable(
	        source.subscribe(
	          function (x) {
	            next(x, 0);
	          },
	          observer.onError.bind(observer),
	          function () {
	            isDone = true;
	            observer.onCompleted();
	          }),
	        subject.subscribe(
	          function (x) {
	            next(x, 1);
	          },
	          observer.onError.bind(observer))
	        );
	    });
	  }
	
	  var PausableBufferedObservable = (function (_super) {
	
	    inherits(PausableBufferedObservable, _super);
	
	    function subscribe(observer) {
	      var q = [], previousShouldFire;
	
	      var subscription =
	        combineLatestSource(
	          this.source,
	          this.pauser.distinctUntilChanged().startWith(false),
	          function (data, shouldFire) {
	            return { data: data, shouldFire: shouldFire };
	          })
	          .subscribe(
	            function (results) {
	              if (previousShouldFire !== undefined && results.shouldFire != previousShouldFire) {
	                previousShouldFire = results.shouldFire;
	                // change in shouldFire
	                if (results.shouldFire) {
	                  while (q.length > 0) {
	                    observer.onNext(q.shift());
	                  }
	                }
	              } else {
	                previousShouldFire = results.shouldFire;
	                // new data
	                if (results.shouldFire) {
	                  observer.onNext(results.data);
	                } else {
	                  q.push(results.data);
	                }
	              }
	            },
	            function (err) {
	              // Empty buffer before sending error
	              while (q.length > 0) {
	                observer.onNext(q.shift());
	              }
	              observer.onError(err);
	            },
	            function () {
	              // Empty buffer before sending completion
	              while (q.length > 0) {
	                observer.onNext(q.shift());
	              }
	              observer.onCompleted();
	            }
	          );
	      return subscription;
	    }
	
	    function PausableBufferedObservable(source, pauser) {
	      this.source = source;
	      this.controller = new Subject();
	
	      if (pauser && pauser.subscribe) {
	        this.pauser = this.controller.merge(pauser);
	      } else {
	        this.pauser = this.controller;
	      }
	
	      _super.call(this, subscribe);
	    }
	
	    PausableBufferedObservable.prototype.pause = function () {
	      this.controller.onNext(false);
	    };
	
	    PausableBufferedObservable.prototype.resume = function () {
	      this.controller.onNext(true);
	    };
	
	    return PausableBufferedObservable;
	
	  }(Observable));
	
	  /**
	   * Pauses the underlying observable sequence based upon the observable sequence which yields true/false,
	   * and yields the values that were buffered while paused.
	   * @example
	   * var pauser = new Rx.Subject();
	   * var source = Rx.Observable.interval(100).pausableBuffered(pauser);
	   * @param {Observable} pauser The observable sequence used to pause the underlying sequence.
	   * @returns {Observable} The observable sequence which is paused based upon the pauser.
	   */
	  observableProto.pausableBuffered = function (subject) {
	    return new PausableBufferedObservable(this, subject);
	  };
	
	  /**
	   * Attaches a controller to the observable sequence with the ability to queue.
	   * @example
	   * var source = Rx.Observable.interval(100).controlled();
	   * source.request(3); // Reads 3 values
	   * @param {Observable} pauser The observable sequence used to pause the underlying sequence.
	   * @returns {Observable} The observable sequence which is paused based upon the pauser.
	   */
	  observableProto.controlled = function (enableQueue) {
	    if (enableQueue == null) {  enableQueue = true; }
	    return new ControlledObservable(this, enableQueue);
	  };
	
	  var ControlledObservable = (function (_super) {
	
	    inherits(ControlledObservable, _super);
	
	    function subscribe (observer) {
	      return this.source.subscribe(observer);
	    }
	
	    function ControlledObservable (source, enableQueue) {
	      _super.call(this, subscribe);
	      this.subject = new ControlledSubject(enableQueue);
	      this.source = source.multicast(this.subject).refCount();
	    }
	
	    ControlledObservable.prototype.request = function (numberOfItems) {
	      if (numberOfItems == null) { numberOfItems = -1; }
	      return this.subject.request(numberOfItems);
	    };
	
	    return ControlledObservable;
	
	  }(Observable));
	
	    var ControlledSubject = Rx.ControlledSubject = (function (_super) {
	
	        function subscribe (observer) {
	            return this.subject.subscribe(observer);
	        }
	
	        inherits(ControlledSubject, _super);
	
	        function ControlledSubject(enableQueue) {
	            if (enableQueue == null) {
	                enableQueue = true;
	            }
	
	            _super.call(this, subscribe);
	            this.subject = new Subject();
	            this.enableQueue = enableQueue;
	            this.queue = enableQueue ? [] : null;
	            this.requestedCount = 0;
	            this.requestedDisposable = disposableEmpty;
	            this.error = null;
	            this.hasFailed = false;
	            this.hasCompleted = false;
	            this.controlledDisposable = disposableEmpty;
	        }
	
	        addProperties(ControlledSubject.prototype, Observer, {
	            onCompleted: function () {
	                checkDisposed.call(this);
	                this.hasCompleted = true;
	
	                if (!this.enableQueue || this.queue.length === 0) {
	                    this.subject.onCompleted();
	                }
	            },
	            onError: function (error) {
	                checkDisposed.call(this);
	                this.hasFailed = true;
	                this.error = error;
	
	                if (!this.enableQueue || this.queue.length === 0) {
	                    this.subject.onError(error);
	                }
	            },
	            onNext: function (value) {
	                checkDisposed.call(this);
	                var hasRequested = false;
	
	                if (this.requestedCount === 0) {
	                    if (this.enableQueue) {
	                        this.queue.push(value);
	                    }
	                } else {
	                    if (this.requestedCount !== -1) {
	                        if (this.requestedCount-- === 0) {
	                            this.disposeCurrentRequest();
	                        }
	                    }
	                    hasRequested = true;
	                }
	
	                if (hasRequested) {
	                    this.subject.onNext(value);
	                }
	            },
	            _processRequest: function (numberOfItems) {
	                if (this.enableQueue) {
	                    //console.log('queue length', this.queue.length);
	
	                    while (this.queue.length >= numberOfItems && numberOfItems > 0) {
	                        //console.log('number of items', numberOfItems);
	                        this.subject.onNext(this.queue.shift());
	                        numberOfItems--;
	                    }
	
	                    if (this.queue.length !== 0) {
	                        return { numberOfItems: numberOfItems, returnValue: true };
	                    } else {
	                        return { numberOfItems: numberOfItems, returnValue: false };
	                    }
	                }
	
	                if (this.hasFailed) {
	                    this.subject.onError(this.error);
	                    this.controlledDisposable.dispose();
	                    this.controlledDisposable = disposableEmpty;
	                } else if (this.hasCompleted) {
	                    this.subject.onCompleted();
	                    this.controlledDisposable.dispose();
	                    this.controlledDisposable = disposableEmpty;
	                }
	
	                return { numberOfItems: numberOfItems, returnValue: false };
	            },
	            request: function (number) {
	                checkDisposed.call(this);
	                this.disposeCurrentRequest();
	                var self = this,
	                    r = this._processRequest(number);
	
	                number = r.numberOfItems;
	                if (!r.returnValue) {
	                    this.requestedCount = number;
	                    this.requestedDisposable = disposableCreate(function () {
	                        self.requestedCount = 0;
	                    });
	
	                    return this.requestedDisposable
	                } else {
	                    return disposableEmpty;
	                }
	            },
	            disposeCurrentRequest: function () {
	                this.requestedDisposable.dispose();
	                this.requestedDisposable = disposableEmpty;
	            },
	
	            dispose: function () {
	                this.isDisposed = true;
	                this.error = null;
	                this.subject.dispose();
	                this.requestedDisposable.dispose();
	            }
	        });
	
	        return ControlledSubject;
	    }(Observable));
	
	  /**
	   * Multicasts the source sequence notifications through an instantiated subject into all uses of the sequence within a selector function. Each
	   * subscription to the resulting sequence causes a separate multicast invocation, exposing the sequence resulting from the selector function's
	   * invocation. For specializations with fixed subject types, see Publish, PublishLast, and Replay.
	   *
	   * @example
	   * 1 - res = source.multicast(observable);
	   * 2 - res = source.multicast(function () { return new Subject(); }, function (x) { return x; });
	   *
	   * @param {Function|Subject} subjectOrSubjectSelector
	   * Factory function to create an intermediate subject through which the source sequence's elements will be multicast to the selector function.
	   * Or:
	   * Subject to push source elements into.
	   *
	   * @param {Function} [selector] Optional selector function which can use the multicasted source sequence subject to the policies enforced by the created subject. Specified only if <paramref name="subjectOrSubjectSelector" is a factory function.
	   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
	   */
	  observableProto.multicast = function (subjectOrSubjectSelector, selector) {
	    var source = this;
	    return typeof subjectOrSubjectSelector === 'function' ?
	      new AnonymousObservable(function (observer) {
	        var connectable = source.multicast(subjectOrSubjectSelector());
	        return new CompositeDisposable(selector(connectable).subscribe(observer), connectable.connect());
	      }) :
	      new ConnectableObservable(source, subjectOrSubjectSelector);
	  };
	
	  /**
	   * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence.
	   * This operator is a specialization of Multicast using a regular Subject.
	   *
	   * @example
	   * var resres = source.publish();
	   * var res = source.publish(function (x) { return x; });
	   *
	   * @param {Function} [selector] Selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive all notifications of the source from the time of the subscription on.
	   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
	   */
	  observableProto.publish = function (selector) {
	    return selector && isFunction(selector) ?
	      this.multicast(function () { return new Subject(); }, selector) :
	      this.multicast(new Subject());
	  };
	
	  /**
	   * Returns an observable sequence that shares a single subscription to the underlying sequence.
	   * This operator is a specialization of publish which creates a subscription when the number of observers goes from zero to one, then shares that subscription with all subsequent observers until the number of observers returns to zero, at which point the subscription is disposed.
	   *
	   * @example
	   * var res = source.share();
	   *
	   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence.
	   */
	  observableProto.share = function () {
	    return this.publish().refCount();
	  };
	
	  /**
	   * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence containing only the last notification.
	   * This operator is a specialization of Multicast using a AsyncSubject.
	   *
	   * @example
	   * var res = source.publishLast();
	   * var res = source.publishLast(function (x) { return x; });
	   *
	   * @param selector [Optional] Selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will only receive the last notification of the source.
	   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
	   */
	  observableProto.publishLast = function (selector) {
	    return selector && isFunction(selector) ?
	      this.multicast(function () { return new AsyncSubject(); }, selector) :
	      this.multicast(new AsyncSubject());
	  };
	
	  /**
	   * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence and starts with initialValue.
	   * This operator is a specialization of Multicast using a BehaviorSubject.
	   *
	   * @example
	   * var res = source.publishValue(42);
	   * var res = source.publishValue(function (x) { return x.select(function (y) { return y * y; }) }, 42);
	   *
	   * @param {Function} [selector] Optional selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive immediately receive the initial value, followed by all notifications of the source from the time of the subscription on.
	   * @param {Mixed} initialValue Initial value received by observers upon subscription.
	   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
	   */
	  observableProto.publishValue = function (initialValueOrSelector, initialValue) {
	    return arguments.length === 2 ?
	      this.multicast(function () {
	        return new BehaviorSubject(initialValue);
	      }, initialValueOrSelector) :
	      this.multicast(new BehaviorSubject(initialValueOrSelector));
	  };
	
	  /**
	   * Returns an observable sequence that shares a single subscription to the underlying sequence and starts with an initialValue.
	   * This operator is a specialization of publishValue which creates a subscription when the number of observers goes from zero to one, then shares that subscription with all subsequent observers until the number of observers returns to zero, at which point the subscription is disposed.
	   *
	   * @example
	   * var res = source.shareValue(42);
	   *
	   * @param {Mixed} initialValue Initial value received by observers upon subscription.
	   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence.
	   */
	  observableProto.shareValue = function (initialValue) {
	    return this.publishValue(initialValue).refCount();
	  };
	
	  /**
	   * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence replaying notifications subject to a maximum time length for the replay buffer.
	   * This operator is a specialization of Multicast using a ReplaySubject.
	   *
	   * @example
	   * var res = source.replay(null, 3);
	   * var res = source.replay(null, 3, 500);
	   * var res = source.replay(null, 3, 500, scheduler);
	   * var res = source.replay(function (x) { return x.take(6).repeat(); }, 3, 500, scheduler);
	   *
	   * @param selector [Optional] Selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive all the notifications of the source subject to the specified replay buffer trimming policy.
	   * @param bufferSize [Optional] Maximum element count of the replay buffer.
	   * @param window [Optional] Maximum time length of the replay buffer.
	   * @param scheduler [Optional] Scheduler where connected observers within the selector function will be invoked on.
	   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
	   */
	  observableProto.replay = function (selector, bufferSize, window, scheduler) {
	    return selector && isFunction(selector) ?
	      this.multicast(function () { return new ReplaySubject(bufferSize, window, scheduler); }, selector) :
	      this.multicast(new ReplaySubject(bufferSize, window, scheduler));
	  };
	
	  /**
	   * Returns an observable sequence that shares a single subscription to the underlying sequence replaying notifications subject to a maximum time length for the replay buffer.
	   * This operator is a specialization of replay which creates a subscription when the number of observers goes from zero to one, then shares that subscription with all subsequent observers until the number of observers returns to zero, at which point the subscription is disposed.
	   *
	   * @example
	   * var res = source.shareReplay(3);
	   * var res = source.shareReplay(3, 500);
	   * var res = source.shareReplay(3, 500, scheduler);
	   *
	
	   * @param bufferSize [Optional] Maximum element count of the replay buffer.
	   * @param window [Optional] Maximum time length of the replay buffer.
	   * @param scheduler [Optional] Scheduler where connected observers within the selector function will be invoked on.
	   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence.
	   */
	  observableProto.shareReplay = function (bufferSize, window, scheduler) {
	    return this.replay(null, bufferSize, window, scheduler).refCount();
	  };
	
	    /** @private */
	    var InnerSubscription = function (subject, observer) {
	        this.subject = subject;
	        this.observer = observer;
	    };
	
	    /**
	     * @private
	     * @memberOf InnerSubscription
	     */
	    InnerSubscription.prototype.dispose = function () {
	        if (!this.subject.isDisposed && this.observer !== null) {
	            var idx = this.subject.observers.indexOf(this.observer);
	            this.subject.observers.splice(idx, 1);
	            this.observer = null;
	        }
	    };
	
	  /**
	   *  Represents a value that changes over time.
	   *  Observers can subscribe to the subject to receive the last (or initial) value and all subsequent notifications.
	   */
	  var BehaviorSubject = Rx.BehaviorSubject = (function (__super__) {
	    function subscribe(observer) {
	      checkDisposed.call(this);
	      if (!this.isStopped) {
	        this.observers.push(observer);
	        observer.onNext(this.value);
	        return new InnerSubscription(this, observer);
	      }
	      var ex = this.exception;
	      if (ex) {
	        observer.onError(ex);
	      } else {
	        observer.onCompleted();
	      }
	      return disposableEmpty;
	    }
	
	    inherits(BehaviorSubject, __super__);
	
	    /**
	     * @constructor
	     *  Initializes a new instance of the BehaviorSubject class which creates a subject that caches its last value and starts with the specified value.
	     *  @param {Mixed} value Initial value sent to observers when no other value has been received by the subject yet.
	     */
	    function BehaviorSubject(value) {
	      __super__.call(this, subscribe);
	      this.value = value,
	      this.observers = [],
	      this.isDisposed = false,
	      this.isStopped = false,
	      this.exception = null;
	    }
	
	    addProperties(BehaviorSubject.prototype, Observer, {
	      /**
	       * Indicates whether the subject has observers subscribed to it.
	       * @returns {Boolean} Indicates whether the subject has observers subscribed to it.
	       */
	      hasObservers: function () {
	        return this.observers.length > 0;
	      },
	      /**
	       * Notifies all subscribed observers about the end of the sequence.
	       */
	      onCompleted: function () {
	        checkDisposed.call(this);
	        if (this.isStopped) { return; }
	        this.isStopped = true;
	        for (var i = 0, os = this.observers.slice(0), len = os.length; i < len; i++) {
	          os[i].onCompleted();
	        }
	
	        this.observers = [];
	      },
	      /**
	       * Notifies all subscribed observers about the exception.
	       * @param {Mixed} error The exception to send to all observers.
	       */
	      onError: function (error) {
	        checkDisposed.call(this);
	        if (this.isStopped) { return; }
	        this.isStopped = true;
	        this.exception = error;
	
	        for (var i = 0, os = this.observers.slice(0), len = os.length; i < len; i++) {
	          os[i].onError(error);
	        }
	
	        this.observers = [];
	      },
	      /**
	       * Notifies all subscribed observers about the arrival of the specified element in the sequence.
	       * @param {Mixed} value The value to send to all observers.
	       */
	      onNext: function (value) {
	        checkDisposed.call(this);
	        if (this.isStopped) { return; }
	        this.value = value;
	        for (var i = 0, os = this.observers.slice(0), len = os.length; i < len; i++) {
	          os[i].onNext(value);
	        }
	      },
	      /**
	       * Unsubscribe all observers and release resources.
	       */
	      dispose: function () {
	        this.isDisposed = true;
	        this.observers = null;
	        this.value = null;
	        this.exception = null;
	      }
	    });
	
	    return BehaviorSubject;
	  }(Observable));
	
	  /**
	   * Represents an object that is both an observable sequence as well as an observer.
	   * Each notification is broadcasted to all subscribed and future observers, subject to buffer trimming policies.
	   */
	  var ReplaySubject = Rx.ReplaySubject = (function (__super__) {
	
	    function createRemovableDisposable(subject, observer) {
	      return disposableCreate(function () {
	        observer.dispose();
	        !subject.isDisposed && subject.observers.splice(subject.observers.indexOf(observer), 1);
	      });
	    }
	
	    function subscribe(observer) {
	      var so = new ScheduledObserver(this.scheduler, observer),
	        subscription = createRemovableDisposable(this, so);
	      checkDisposed.call(this);
	      this._trim(this.scheduler.now());
	      this.observers.push(so);
	
	      var n = this.q.length;
	
	      for (var i = 0, len = this.q.length; i < len; i++) {
	        so.onNext(this.q[i].value);
	      }
	
	      if (this.hasError) {
	        n++;
	        so.onError(this.error);
	      } else if (this.isStopped) {
	        n++;
	        so.onCompleted();
	      }
	
	      so.ensureActive(n);
	      return subscription;
	    }
	
	    inherits(ReplaySubject, __super__);
	
	    /**
	     *  Initializes a new instance of the ReplaySubject class with the specified buffer size, window size and scheduler.
	     *  @param {Number} [bufferSize] Maximum element count of the replay buffer.
	     *  @param {Number} [windowSize] Maximum time length of the replay buffer.
	     *  @param {Scheduler} [scheduler] Scheduler the observers are invoked on.
	     */
	    function ReplaySubject(bufferSize, windowSize, scheduler) {
	      this.bufferSize = bufferSize == null ? Number.MAX_VALUE : bufferSize;
	      this.windowSize = windowSize == null ? Number.MAX_VALUE : windowSize;
	      this.scheduler = scheduler || currentThreadScheduler;
	      this.q = [];
	      this.observers = [];
	      this.isStopped = false;
	      this.isDisposed = false;
	      this.hasError = false;
	      this.error = null;
	      __super__.call(this, subscribe);
	    }
	
	    addProperties(ReplaySubject.prototype, Observer, {
	      /**
	       * Indicates whether the subject has observers subscribed to it.
	       * @returns {Boolean} Indicates whether the subject has observers subscribed to it.
	       */
	      hasObservers: function () {
	        return this.observers.length > 0;
	      },
	      _trim: function (now) {
	        while (this.q.length > this.bufferSize) {
	          this.q.shift();
	        }
	        while (this.q.length > 0 && (now - this.q[0].interval) > this.windowSize) {
	          this.q.shift();
	        }
	      },
	      /**
	       * Notifies all subscribed observers about the arrival of the specified element in the sequence.
	       * @param {Mixed} value The value to send to all observers.
	       */
	      onNext: function (value) {
	        checkDisposed.call(this);
	        if (this.isStopped) { return; }
	        var now = this.scheduler.now();
	        this.q.push({ interval: now, value: value });
	        this._trim(now);
	
	        var o = this.observers.slice(0);
	        for (var i = 0, len = o.length; i < len; i++) {
	          var observer = o[i];
	          observer.onNext(value);
	          observer.ensureActive();
	        }
	      },
	      /**
	       * Notifies all subscribed observers about the exception.
	       * @param {Mixed} error The exception to send to all observers.
	       */
	      onError: function (error) {
	        checkDisposed.call(this);
	        if (this.isStopped) { return; }
	        this.isStopped = true;
	        this.error = error;
	        this.hasError = true;
	        var now = this.scheduler.now();
	        this._trim(now);
	        var o = this.observers.slice(0);
	        for (var i = 0, len = o.length; i < len; i++) {
	          var observer = o[i];
	          observer.onError(error);
	          observer.ensureActive();
	        }
	        this.observers = [];
	      },
	      /**
	       * Notifies all subscribed observers about the end of the sequence.
	       */
	      onCompleted: function () {
	        checkDisposed.call(this);
	        if (this.isStopped) { return; }
	        this.isStopped = true;
	        var now = this.scheduler.now();
	        this._trim(now);
	        var o = this.observers.slice(0);
	        for (var i = 0, len = o.length; i < len; i++) {
	          var observer = o[i];
	          observer.onCompleted();
	          observer.ensureActive();
	        }
	        this.observers = [];
	      },
	      /**
	       * Unsubscribe all observers and release resources.
	       */
	      dispose: function () {
	        this.isDisposed = true;
	        this.observers = null;
	      }
	    });
	
	    return ReplaySubject;
	  }(Observable));
	
	  var ConnectableObservable = Rx.ConnectableObservable = (function (__super__) {
	    inherits(ConnectableObservable, __super__);
	
	    function ConnectableObservable(source, subject) {
	      var hasSubscription = false,
	        subscription,
	        sourceObservable = source.asObservable();
	
	      this.connect = function () {
	        if (!hasSubscription) {
	          hasSubscription = true;
	          subscription = new CompositeDisposable(sourceObservable.subscribe(subject), disposableCreate(function () {
	            hasSubscription = false;
	          }));
	        }
	        return subscription;
	      };
	
	      __super__.call(this, subject.subscribe.bind(subject));
	    }
	
	    ConnectableObservable.prototype.refCount = function () {
	      var connectableSubscription, count = 0, source = this;
	      return new AnonymousObservable(function (observer) {
	          var shouldConnect = ++count === 1,
	            subscription = source.subscribe(observer);
	          shouldConnect && (connectableSubscription = source.connect());
	          return function () {
	            subscription.dispose();
	            --count === 0 && connectableSubscription.dispose();
	          };
	      });
	    };
	
	    return ConnectableObservable;
	  }(Observable));
	
	  var Dictionary = (function () {
	
	    var primes = [1, 3, 7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381, 32749, 65521, 131071, 262139, 524287, 1048573, 2097143, 4194301, 8388593, 16777213, 33554393, 67108859, 134217689, 268435399, 536870909, 1073741789, 2147483647],
	      noSuchkey = "no such key",
	      duplicatekey = "duplicate key";
	
	    function isPrime(candidate) {
	      if (candidate & 1 === 0) { return candidate === 2; }
	      var num1 = Math.sqrt(candidate),
	        num2 = 3;
	      while (num2 <= num1) {
	        if (candidate % num2 === 0) { return false; }
	        num2 += 2;
	      }
	      return true;
	    }
	
	    function getPrime(min) {
	      var index, num, candidate;
	      for (index = 0; index < primes.length; ++index) {
	        num = primes[index];
	        if (num >= min) { return num; }
	      }
	      candidate = min | 1;
	      while (candidate < primes[primes.length - 1]) {
	        if (isPrime(candidate)) { return candidate; }
	        candidate += 2;
	      }
	      return min;
	    }
	
	    function stringHashFn(str) {
	      var hash = 757602046;
	      if (!str.length) { return hash; }
	      for (var i = 0, len = str.length; i < len; i++) {
	        var character = str.charCodeAt(i);
	        hash = ((hash<<5)-hash)+character;
	        hash = hash & hash;
	      }
	      return hash;
	    }
	
	    function numberHashFn(key) {
	      var c2 = 0x27d4eb2d;
	      key = (key ^ 61) ^ (key >>> 16);
	      key = key + (key << 3);
	      key = key ^ (key >>> 4);
	      key = key * c2;
	      key = key ^ (key >>> 15);
	      return key;
	    }
	
	    var getHashCode = (function () {
	      var uniqueIdCounter = 0;
	
	      return function (obj) {
	        if (obj == null) { throw new Error(noSuchkey); }
	
	        // Check for built-ins before tacking on our own for any object
	        if (typeof obj === 'string') { return stringHashFn(obj); }
	        if (typeof obj === 'number') { return numberHashFn(obj); }
	        if (typeof obj === 'boolean') { return obj === true ? 1 : 0; }
	        if (obj instanceof Date) { return numberHashFn(obj.valueOf()); }
	        if (obj instanceof RegExp) { return stringHashFn(obj.toString()); }
	        if (typeof obj.valueOf === 'function') {
	          // Hack check for valueOf
	          var valueOf = obj.valueOf();
	          if (typeof valueOf === 'number') { return numberHashFn(valueOf); }
	          if (typeof obj === 'string') { return stringHashFn(valueOf); }
	        }
	        if (obj.getHashCode) { return obj.getHashCode(); }
	
	        var id = 17 * uniqueIdCounter++;
	        obj.getHashCode = function () { return id; };
	        return id;
	      };
	    }());
	
	    function newEntry() {
	      return { key: null, value: null, next: 0, hashCode: 0 };
	    }
	
	    function Dictionary(capacity, comparer) {
	      if (capacity < 0) { throw new Error('out of range'); }
	      if (capacity > 0) { this._initialize(capacity); }
	
	      this.comparer = comparer || defaultComparer;
	      this.freeCount = 0;
	      this.size = 0;
	      this.freeList = -1;
	    }
	
	    var dictionaryProto = Dictionary.prototype;
	
	    dictionaryProto._initialize = function (capacity) {
	      var prime = getPrime(capacity), i;
	      this.buckets = new Array(prime);
	      this.entries = new Array(prime);
	      for (i = 0; i < prime; i++) {
	        this.buckets[i] = -1;
	        this.entries[i] = newEntry();
	      }
	      this.freeList = -1;
	    };
	
	    dictionaryProto.add = function (key, value) {
	      return this._insert(key, value, true);
	    };
	
	    dictionaryProto._insert = function (key, value, add) {
	      if (!this.buckets) { this._initialize(0); }
	      var index3,
	        num = getHashCode(key) & 2147483647,
	        index1 = num % this.buckets.length;
	      for (var index2 = this.buckets[index1]; index2 >= 0; index2 = this.entries[index2].next) {
	        if (this.entries[index2].hashCode === num && this.comparer(this.entries[index2].key, key)) {
	          if (add) { throw new Error(duplicatekey); }
	          this.entries[index2].value = value;
	          return;
	        }
	      }
	      if (this.freeCount > 0) {
	        index3 = this.freeList;
	        this.freeList = this.entries[index3].next;
	        --this.freeCount;
	      } else {
	        if (this.size === this.entries.length) {
	          this._resize();
	          index1 = num % this.buckets.length;
	        }
	        index3 = this.size;
	        ++this.size;
	      }
	      this.entries[index3].hashCode = num;
	      this.entries[index3].next = this.buckets[index1];
	      this.entries[index3].key = key;
	      this.entries[index3].value = value;
	      this.buckets[index1] = index3;
	    };
	
	    dictionaryProto._resize = function () {
	      var prime = getPrime(this.size * 2),
	        numArray = new Array(prime);
	      for (index = 0; index < numArray.length; ++index) {  numArray[index] = -1; }
	      var entryArray = new Array(prime);
	      for (index = 0; index < this.size; ++index) { entryArray[index] = this.entries[index]; }
	      for (var index = this.size; index < prime; ++index) { entryArray[index] = newEntry(); }
	      for (var index1 = 0; index1 < this.size; ++index1) {
	        var index2 = entryArray[index1].hashCode % prime;
	        entryArray[index1].next = numArray[index2];
	        numArray[index2] = index1;
	      }
	      this.buckets = numArray;
	      this.entries = entryArray;
	    };
	
	    dictionaryProto.remove = function (key) {
	      if (this.buckets) {
	        var num = getHashCode(key) & 2147483647,
	          index1 = num % this.buckets.length,
	          index2 = -1;
	        for (var index3 = this.buckets[index1]; index3 >= 0; index3 = this.entries[index3].next) {
	          if (this.entries[index3].hashCode === num && this.comparer(this.entries[index3].key, key)) {
	            if (index2 < 0) {
	              this.buckets[index1] = this.entries[index3].next;
	            } else {
	              this.entries[index2].next = this.entries[index3].next;
	            }
	            this.entries[index3].hashCode = -1;
	            this.entries[index3].next = this.freeList;
	            this.entries[index3].key = null;
	            this.entries[index3].value = null;
	            this.freeList = index3;
	            ++this.freeCount;
	            return true;
	          } else {
	            index2 = index3;
	          }
	        }
	      }
	      return false;
	    };
	
	    dictionaryProto.clear = function () {
	      var index, len;
	      if (this.size <= 0) { return; }
	      for (index = 0, len = this.buckets.length; index < len; ++index) {
	        this.buckets[index] = -1;
	      }
	      for (index = 0; index < this.size; ++index) {
	        this.entries[index] = newEntry();
	      }
	      this.freeList = -1;
	      this.size = 0;
	    };
	
	    dictionaryProto._findEntry = function (key) {
	      if (this.buckets) {
	        var num = getHashCode(key) & 2147483647;
	        for (var index = this.buckets[num % this.buckets.length]; index >= 0; index = this.entries[index].next) {
	          if (this.entries[index].hashCode === num && this.comparer(this.entries[index].key, key)) {
	            return index;
	          }
	        }
	      }
	      return -1;
	    };
	
	    dictionaryProto.count = function () {
	      return this.size - this.freeCount;
	    };
	
	    dictionaryProto.tryGetValue = function (key) {
	      var entry = this._findEntry(key);
	      return entry >= 0 ?
	        this.entries[entry].value :
	        undefined;
	    };
	
	    dictionaryProto.getValues = function () {
	      var index = 0, results = [];
	      if (this.entries) {
	        for (var index1 = 0; index1 < this.size; index1++) {
	          if (this.entries[index1].hashCode >= 0) {
	            results[index++] = this.entries[index1].value;
	          }
	        }
	      }
	      return results;
	    };
	
	    dictionaryProto.get = function (key) {
	      var entry = this._findEntry(key);
	      if (entry >= 0) { return this.entries[entry].value; }
	      throw new Error(noSuchkey);
	    };
	
	    dictionaryProto.set = function (key, value) {
	      this._insert(key, value, false);
	    };
	
	    dictionaryProto.containskey = function (key) {
	      return this._findEntry(key) >= 0;
	    };
	
	    return Dictionary;
	  }());
	
	  /**
	   *  Correlates the elements of two sequences based on overlapping durations.
	   *
	   *  @param {Observable} right The right observable sequence to join elements for.
	   *  @param {Function} leftDurationSelector A function to select the duration (expressed as an observable sequence) of each element of the left observable sequence, used to determine overlap.
	   *  @param {Function} rightDurationSelector A function to select the duration (expressed as an observable sequence) of each element of the right observable sequence, used to determine overlap.
	   *  @param {Function} resultSelector A function invoked to compute a result element for any two overlapping elements of the left and right observable sequences. The parameters passed to the function correspond with the elements from the left and right source sequences for which overlap occurs.
	   *  @returns {Observable} An observable sequence that contains result elements computed from source elements that have an overlapping duration.
	   */
	  observableProto.join = function (right, leftDurationSelector, rightDurationSelector, resultSelector) {
	    var left = this;
	    return new AnonymousObservable(function (observer) {
	      var group = new CompositeDisposable();
	      var leftDone = false, rightDone = false;
	      var leftId = 0, rightId = 0;
	      var leftMap = new Dictionary(), rightMap = new Dictionary();
	
	      group.add(left.subscribe(
	        function (value) {
	          var id = leftId++;
	          var md = new SingleAssignmentDisposable();
	
	          leftMap.add(id, value);
	          group.add(md);
	
	          var expire = function () {
	            leftMap.remove(id) && leftMap.count() === 0 && leftDone && observer.onCompleted();
	            group.remove(md);
	          };
	
	          var duration;
	          try {
	            duration = leftDurationSelector(value);
	          } catch (e) {
	            observer.onError(e);
	            return;
	          }
	
	          md.setDisposable(duration.take(1).subscribe(noop, observer.onError.bind(observer), expire));
	
	          rightMap.getValues().forEach(function (v) {
	            var result;
	            try {
	              result = resultSelector(value, v);
	            } catch (exn) {
	              observer.onError(exn);
	              return;
	            }
	
	            observer.onNext(result);
	          });
	        },
	        observer.onError.bind(observer),
	        function () {
	          leftDone = true;
	          (rightDone || leftMap.count() === 0) && observer.onCompleted();
	        })
	      );
	
	      group.add(right.subscribe(
	        function (value) {
	          var id = rightId++;
	          var md = new SingleAssignmentDisposable();
	
	          rightMap.add(id, value);
	          group.add(md);
	
	          var expire = function () {
	            rightMap.remove(id) && rightMap.count() === 0 && rightDone && observer.onCompleted();
	            group.remove(md);
	          };
	
	          var duration;
	          try {
	            duration = rightDurationSelector(value);
	          } catch (e) {
	            observer.onError(e);
	            return;
	          }
	
	          md.setDisposable(duration.take(1).subscribe(noop, observer.onError.bind(observer), expire));
	
	          leftMap.getValues().forEach(function (v) {
	            var result;
	            try {
	              result = resultSelector(v, value);
	            } catch(exn) {
	              observer.onError(exn);
	              return;
	            }
	
	            observer.onNext(result);
	          });
	        },
	        observer.onError.bind(observer),
	        function () {
	          rightDone = true;
	          (leftDone || rightMap.count() === 0) && observer.onCompleted();
	        })
	      );
	      return group;
	    });
	  };
	
	  /**
	   *  Correlates the elements of two sequences based on overlapping durations, and groups the results.
	   *
	   *  @param {Observable} right The right observable sequence to join elements for.
	   *  @param {Function} leftDurationSelector A function to select the duration (expressed as an observable sequence) of each element of the left observable sequence, used to determine overlap.
	   *  @param {Function} rightDurationSelector A function to select the duration (expressed as an observable sequence) of each element of the right observable sequence, used to determine overlap.
	   *  @param {Function} resultSelector A function invoked to compute a result element for any element of the left sequence with overlapping elements from the right observable sequence. The first parameter passed to the function is an element of the left sequence. The second parameter passed to the function is an observable sequence with elements from the right sequence that overlap with the left sequence's element.
	   *  @returns {Observable} An observable sequence that contains result elements computed from source elements that have an overlapping duration.
	   */
	  observableProto.groupJoin = function (right, leftDurationSelector, rightDurationSelector, resultSelector) {
	    var left = this;
	    return new AnonymousObservable(function (observer) {
	      var group = new CompositeDisposable();
	      var r = new RefCountDisposable(group);
	      var leftMap = new Dictionary(), rightMap = new Dictionary();
	      var leftId = 0, rightId = 0;
	
	      function handleError(e) { return function (v) { v.onError(e); }; };
	
	      group.add(left.subscribe(
	        function (value) {
	          var s = new Subject();
	          var id = leftId++;
	          leftMap.add(id, s);
	
	          var result;
	          try {
	            result = resultSelector(value, addRef(s, r));
	          } catch (e) {
	            leftMap.getValues().forEach(handleError(e));
	            observer.onError(e);
	            return;
	          }
	          observer.onNext(result);
	
	          rightMap.getValues().forEach(function (v) { s.onNext(v); });
	
	          var md = new SingleAssignmentDisposable();
	          group.add(md);
	
	          var expire = function () {
	            leftMap.remove(id) && s.onCompleted();
	            group.remove(md);
	          };
	
	          var duration;
	          try {
	            duration = leftDurationSelector(value);
	          } catch (e) {
	            leftMap.getValues().forEach(handleError(e));
	            observer.onError(e);
	            return;
	          }
	
	          md.setDisposable(duration.take(1).subscribe(
	            noop,
	            function (e) {
	              leftMap.getValues().forEach(handleError(e));
	              observer.onError(e);
	            },
	            expire)
	          );
	        },
	        function (e) {
	          leftMap.getValues().forEach(handleError(e));
	          observer.onError(e);
	        },
	        observer.onCompleted.bind(observer))
	      );
	
	      group.add(right.subscribe(
	        function (value) {
	          var id = rightId++;
	          rightMap.add(id, value);
	
	          var md = new SingleAssignmentDisposable();
	          group.add(md);
	
	          var expire = function () {
	            rightMap.remove(id);
	            group.remove(md);
	          };
	
	          var duration;
	          try {
	            duration = rightDurationSelector(value);
	          } catch (e) {
	            leftMap.getValues().forEach(handleError(e));
	            observer.onError(e);
	            return;
	          }
	          md.setDisposable(duration.take(1).subscribe(
	            noop,
	            function (e) {
	              leftMap.getValues().forEach(handleError(e));
	              observer.onError(e);
	            },
	            expire)
	          );
	
	          leftMap.getValues().forEach(function (v) { v.onNext(value); });
	        },
	        function (e) {
	          leftMap.getValues().forEach(handleError(e));
	          observer.onError(e);
	        })
	      );
	
	      return r;
	    });
	  };
	
	    /**
	     *  Projects each element of an observable sequence into zero or more buffers.
	     *
	     *  @param {Mixed} bufferOpeningsOrClosingSelector Observable sequence whose elements denote the creation of new windows, or, a function invoked to define the boundaries of the produced windows (a new window is started when the previous one is closed, resulting in non-overlapping windows).
	     *  @param {Function} [bufferClosingSelector] A function invoked to define the closing of each produced window. If a closing selector function is specified for the first parameter, this parameter is ignored.
	     *  @returns {Observable} An observable sequence of windows.
	     */
	    observableProto.buffer = function (bufferOpeningsOrClosingSelector, bufferClosingSelector) {
	        return this.window.apply(this, arguments).selectMany(function (x) { return x.toArray(); });
	    };
	
	  /**
	   *  Projects each element of an observable sequence into zero or more windows.
	   *
	   *  @param {Mixed} windowOpeningsOrClosingSelector Observable sequence whose elements denote the creation of new windows, or, a function invoked to define the boundaries of the produced windows (a new window is started when the previous one is closed, resulting in non-overlapping windows).
	   *  @param {Function} [windowClosingSelector] A function invoked to define the closing of each produced window. If a closing selector function is specified for the first parameter, this parameter is ignored.
	   *  @returns {Observable} An observable sequence of windows.
	   */
	  observableProto.window = function (windowOpeningsOrClosingSelector, windowClosingSelector) {
	    if (arguments.length === 1 && typeof arguments[0] !== 'function') {
	      return observableWindowWithBounaries.call(this, windowOpeningsOrClosingSelector);
	    }
	    return typeof windowOpeningsOrClosingSelector === 'function' ?
	      observableWindowWithClosingSelector.call(this, windowOpeningsOrClosingSelector) :
	      observableWindowWithOpenings.call(this, windowOpeningsOrClosingSelector, windowClosingSelector);
	  };
	
	  function observableWindowWithOpenings(windowOpenings, windowClosingSelector) {
	    return windowOpenings.groupJoin(this, windowClosingSelector, observableEmpty, function (_, win) {
	      return win;
	    });
	  }
	
	  function observableWindowWithBounaries(windowBoundaries) {
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      var win = new Subject(),
	        d = new CompositeDisposable(),
	        r = new RefCountDisposable(d);
	
	      observer.onNext(addRef(win, r));
	
	      d.add(source.subscribe(function (x) {
	        win.onNext(x);
	      }, function (err) {
	        win.onError(err);
	        observer.onError(err);
	      }, function () {
	        win.onCompleted();
	        observer.onCompleted();
	      }));
	
	      isPromise(windowBoundaries) && (windowBoundaries = observableFromPromise(windowBoundaries));
	
	      d.add(windowBoundaries.subscribe(function (w) {
	        win.onCompleted();
	        win = new Subject();
	        observer.onNext(addRef(win, r));
	      }, function (err) {
	        win.onError(err);
	        observer.onError(err);
	      }, function () {
	        win.onCompleted();
	        observer.onCompleted();
	      }));
	
	      return r;
	    });
	  }
	
	  function observableWindowWithClosingSelector(windowClosingSelector) {
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      var m = new SerialDisposable(),
	        d = new CompositeDisposable(m),
	        r = new RefCountDisposable(d),
	        win = new Subject();
	      observer.onNext(addRef(win, r));
	      d.add(source.subscribe(function (x) {
	          win.onNext(x);
	      }, function (err) {
	          win.onError(err);
	          observer.onError(err);
	      }, function () {
	          win.onCompleted();
	          observer.onCompleted();
	      }));
	      
	      function createWindowClose () {
	        var windowClose;
	        try {
	          windowClose = windowClosingSelector();
	        } catch (e) {
	          observer.onError(e);
	          return;
	        }
	
	        isPromise(windowClose) && (windowClose = observableFromPromise(windowClose));
	
	        var m1 = new SingleAssignmentDisposable();
	        m.setDisposable(m1);
	        m1.setDisposable(windowClose.take(1).subscribe(noop, function (err) {
	          win.onError(err);
	          observer.onError(err);
	        }, function () {
	          win.onCompleted();
	          win = new Subject();
	          observer.onNext(addRef(win, r));
	          createWindowClose();
	        }));
	      }
	
	      createWindowClose();
	      return r;
	    });
	  }
	
	  /**
	   * Returns a new observable that triggers on the second and subsequent triggerings of the input observable.
	   * The Nth triggering of the input observable passes the arguments from the N-1th and Nth triggering as a pair.
	   * The argument passed to the N-1th triggering is held in hidden internal state until the Nth triggering occurs.
	   * @returns {Observable} An observable that triggers on successive pairs of observations from the input observable as an array.
	   */
	  observableProto.pairwise = function () {
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      var previous, hasPrevious = false;
	      return source.subscribe(
	        function (x) {
	          if (hasPrevious) {
	            observer.onNext([previous, x]);
	          } else {
	            hasPrevious = true;
	          }
	          previous = x;
	        },
	        observer.onError.bind(observer),
	        observer.onCompleted.bind(observer));
	    });
	  };
	
	  /**
	   * Returns two observables which partition the observations of the source by the given function.
	   * The first will trigger observations for those values for which the predicate returns true.
	   * The second will trigger observations for those values where the predicate returns false.
	   * The predicate is executed once for each subscribed observer.
	   * Both also propagate all error observations arising from the source and each completes
	   * when the source completes.
	   * @param {Function} predicate
	   *    The function to determine which output Observable will trigger a particular observation.
	   * @returns {Array}
	   *    An array of observables. The first triggers when the predicate returns true,
	   *    and the second triggers when the predicate returns false.
	  */
	  observableProto.partition = function(predicate, thisArg) {
	    var published = this.publish().refCount();
	    return [
	      published.filter(predicate, thisArg),
	      published.filter(function (x, i, o) { return !predicate.call(thisArg, x, i, o); })
	    ];
	  };
	
	  function enumerableWhile(condition, source) {
	    return new Enumerable(function () {
	      return new Enumerator(function () {
	        return condition() ?
	          { done: false, value: source } :
	          { done: true, value: undefined };
	      });
	    });
	  }
	
	     /**
	     *  Returns an observable sequence that is the result of invoking the selector on the source sequence, without sharing subscriptions.
	     *  This operator allows for a fluent style of writing queries that use the same sequence multiple times.
	     *
	     * @param {Function} selector Selector function which can use the source sequence as many times as needed, without sharing subscriptions to the source sequence.
	     * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
	     */
	    observableProto.letBind = observableProto['let'] = function (func) {
	        return func(this);
	    };
	
	   /**
	   *  Determines whether an observable collection contains values. There is an alias for this method called 'ifThen' for browsers <IE9
	   *
	   * @example
	   *  1 - res = Rx.Observable.if(condition, obs1);
	   *  2 - res = Rx.Observable.if(condition, obs1, obs2);
	   *  3 - res = Rx.Observable.if(condition, obs1, scheduler);
	   * @param {Function} condition The condition which determines if the thenSource or elseSource will be run.
	   * @param {Observable} thenSource The observable sequence or Promise that will be run if the condition function returns true.
	   * @param {Observable} [elseSource] The observable sequence or Promise that will be run if the condition function returns false. If this is not provided, it defaults to Rx.Observabe.Empty with the specified scheduler.
	   * @returns {Observable} An observable sequence which is either the thenSource or elseSource.
	   */
	  Observable['if'] = Observable.ifThen = function (condition, thenSource, elseSourceOrScheduler) {
	    return observableDefer(function () {
	      elseSourceOrScheduler || (elseSourceOrScheduler = observableEmpty());
	
	      isPromise(thenSource) && (thenSource = observableFromPromise(thenSource));
	      isPromise(elseSourceOrScheduler) && (elseSourceOrScheduler = observableFromPromise(elseSourceOrScheduler));
	
	      // Assume a scheduler for empty only
	      typeof elseSourceOrScheduler.now === 'function' && (elseSourceOrScheduler = observableEmpty(elseSourceOrScheduler));
	      return condition() ? thenSource : elseSourceOrScheduler;
	    });
	  };
	
	   /**
	   *  Concatenates the observable sequences obtained by running the specified result selector for each element in source.
	   * There is an alias for this method called 'forIn' for browsers <IE9
	   * @param {Array} sources An array of values to turn into an observable sequence.
	   * @param {Function} resultSelector A function to apply to each item in the sources array to turn it into an observable sequence.
	   * @returns {Observable} An observable sequence from the concatenated observable sequences.
	   */
	  Observable['for'] = Observable.forIn = function (sources, resultSelector, thisArg) {
	    return enumerableOf(sources, resultSelector, thisArg).concat();
	  };
	
	   /**
	   *  Repeats source as long as condition holds emulating a while loop.
	   * There is an alias for this method called 'whileDo' for browsers <IE9
	   *
	   * @param {Function} condition The condition which determines if the source will be repeated.
	   * @param {Observable} source The observable sequence that will be run if the condition function returns true.
	   * @returns {Observable} An observable sequence which is repeated as long as the condition holds.
	   */
	  var observableWhileDo = Observable['while'] = Observable.whileDo = function (condition, source) {
	    isPromise(source) && (source = observableFromPromise(source));
	    return enumerableWhile(condition, source).concat();
	  };
	
	     /**
	     *  Repeats source as long as condition holds emulating a do while loop.
	     *
	     * @param {Function} condition The condition which determines if the source will be repeated.
	     * @param {Observable} source The observable sequence that will be run if the condition function returns true.
	     * @returns {Observable} An observable sequence which is repeated as long as the condition holds.
	     */
	    observableProto.doWhile = function (condition) {
	        return observableConcat([this, observableWhileDo(condition, this)]);
	    };
	
	   /**
	   *  Uses selector to determine which source in sources to use.
	   *  There is an alias 'switchCase' for browsers <IE9.
	   *
	   * @example
	   *  1 - res = Rx.Observable.case(selector, { '1': obs1, '2': obs2 });
	   *  1 - res = Rx.Observable.case(selector, { '1': obs1, '2': obs2 }, obs0);
	   *  1 - res = Rx.Observable.case(selector, { '1': obs1, '2': obs2 }, scheduler);
	   *
	   * @param {Function} selector The function which extracts the value for to test in a case statement.
	   * @param {Array} sources A object which has keys which correspond to the case statement labels.
	   * @param {Observable} [elseSource] The observable sequence or Promise that will be run if the sources are not matched. If this is not provided, it defaults to Rx.Observabe.empty with the specified scheduler.
	   *
	   * @returns {Observable} An observable sequence which is determined by a case statement.
	   */
	  Observable['case'] = Observable.switchCase = function (selector, sources, defaultSourceOrScheduler) {
	    return observableDefer(function () {
	      isPromise(defaultSourceOrScheduler) && (defaultSourceOrScheduler = observableFromPromise(defaultSourceOrScheduler));
	      defaultSourceOrScheduler || (defaultSourceOrScheduler = observableEmpty());
	
	      typeof defaultSourceOrScheduler.now === 'function' && (defaultSourceOrScheduler = observableEmpty(defaultSourceOrScheduler));
	
	      var result = sources[selector()];
	      isPromise(result) && (result = observableFromPromise(result));
	
	      return result || defaultSourceOrScheduler;
	    });
	  };
	
	   /**
	   *  Expands an observable sequence by recursively invoking selector.
	   *
	   * @param {Function} selector Selector function to invoke for each produced element, resulting in another sequence to which the selector will be invoked recursively again.
	   * @param {Scheduler} [scheduler] Scheduler on which to perform the expansion. If not provided, this defaults to the current thread scheduler.
	   * @returns {Observable} An observable sequence containing all the elements produced by the recursive expansion.
	   */
	  observableProto.expand = function (selector, scheduler) {
	    isScheduler(scheduler) || (scheduler = immediateScheduler);
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      var q = [],
	        m = new SerialDisposable(),
	        d = new CompositeDisposable(m),
	        activeCount = 0,
	        isAcquired = false;
	
	      var ensureActive = function () {
	        var isOwner = false;
	        if (q.length > 0) {
	            isOwner = !isAcquired;
	            isAcquired = true;
	        }
	        if (isOwner) {
	          m.setDisposable(scheduler.scheduleRecursive(function (self) {
	            var work;
	            if (q.length > 0) {
	              work = q.shift();
	            } else {
	              isAcquired = false;
	              return;
	            }
	            var m1 = new SingleAssignmentDisposable();
	            d.add(m1);
	            m1.setDisposable(work.subscribe(function (x) {
	              observer.onNext(x);
	              var result = null;
	              try {
	                result = selector(x);
	              } catch (e) {
	                observer.onError(e);
	              }
	              q.push(result);
	              activeCount++;
	              ensureActive();
	            }, observer.onError.bind(observer), function () {
	              d.remove(m1);
	              activeCount--;
	              if (activeCount === 0) {
	                observer.onCompleted();
	              }
	            }));
	            self();
	          }));
	        }
	      };
	
	      q.push(source);
	      activeCount++;
	      ensureActive();
	      return d;
	    });
	  };
	
	   /**
	   *  Runs all observable sequences in parallel and collect their last elements.
	   *
	   * @example
	   *  1 - res = Rx.Observable.forkJoin([obs1, obs2]);
	   *  1 - res = Rx.Observable.forkJoin(obs1, obs2, ...);
	   * @returns {Observable} An observable sequence with an array collecting the last elements of all the input sequences.
	   */
	  Observable.forkJoin = function () {
	    var allSources = argsOrArray(arguments, 0);
	    return new AnonymousObservable(function (subscriber) {
	      var count = allSources.length;
	      if (count === 0) {
	        subscriber.onCompleted();
	        return disposableEmpty;
	      }
	      var group = new CompositeDisposable(),
	        finished = false,
	        hasResults = new Array(count),
	        hasCompleted = new Array(count),
	        results = new Array(count);
	
	      for (var idx = 0; idx < count; idx++) {
	        (function (i) {
	          var source = allSources[i];
	          isPromise(source) && (source = observableFromPromise(source));
	          group.add(
	            source.subscribe(
	              function (value) {
	              if (!finished) {
	                hasResults[i] = true;
	                results[i] = value;
	              }
	            },
	            function (e) {
	              finished = true;
	              subscriber.onError(e);
	              group.dispose();
	            },
	            function () {
	              if (!finished) {
	                if (!hasResults[i]) {
	                    subscriber.onCompleted();
	                    return;
	                }
	                hasCompleted[i] = true;
	                for (var ix = 0; ix < count; ix++) {
	                  if (!hasCompleted[ix]) { return; }
	                }
	                finished = true;
	                subscriber.onNext(results);
	                subscriber.onCompleted();
	              }
	            }));
	        })(idx);
	      }
	
	      return group;
	    });
	  };
	
	   /**
	   *  Runs two observable sequences in parallel and combines their last elemenets.
	   *
	   * @param {Observable} second Second observable sequence.
	   * @param {Function} resultSelector Result selector function to invoke with the last elements of both sequences.
	   * @returns {Observable} An observable sequence with the result of calling the selector function with the last elements of both input sequences.
	   */
	  observableProto.forkJoin = function (second, resultSelector) {
	    var first = this;
	
	    return new AnonymousObservable(function (observer) {
	      var leftStopped = false, rightStopped = false,
	        hasLeft = false, hasRight = false,
	        lastLeft, lastRight,
	        leftSubscription = new SingleAssignmentDisposable(), rightSubscription = new SingleAssignmentDisposable();
	
	      isPromise(second) && (second = observableFromPromise(second));
	
	      leftSubscription.setDisposable(
	          first.subscribe(function (left) {
	            hasLeft = true;
	            lastLeft = left;
	          }, function (err) {
	            rightSubscription.dispose();
	            observer.onError(err);
	          }, function () {
	            leftStopped = true;
	            if (rightStopped) {
	              if (!hasLeft) {
	                  observer.onCompleted();
	              } else if (!hasRight) {
	                  observer.onCompleted();
	              } else {
	                var result;
	                try {
	                  result = resultSelector(lastLeft, lastRight);
	                } catch (e) {
	                  observer.onError(e);
	                  return;
	                }
	                observer.onNext(result);
	                observer.onCompleted();
	              }
	            }
	          })
	      );
	
	      rightSubscription.setDisposable(
	        second.subscribe(function (right) {
	          hasRight = true;
	          lastRight = right;
	        }, function (err) {
	          leftSubscription.dispose();
	          observer.onError(err);
	        }, function () {
	          rightStopped = true;
	          if (leftStopped) {
	            if (!hasLeft) {
	              observer.onCompleted();
	            } else if (!hasRight) {
	              observer.onCompleted();
	            } else {
	              var result;
	              try {
	                result = resultSelector(lastLeft, lastRight);
	              } catch (e) {
	                observer.onError(e);
	                return;
	              }
	              observer.onNext(result);
	              observer.onCompleted();
	            }
	          }
	        })
	      );
	
	      return new CompositeDisposable(leftSubscription, rightSubscription);
	    });
	  };
	
	  /**
	   * Comonadic bind operator.
	   * @param {Function} selector A transform function to apply to each element.
	   * @param {Object} scheduler Scheduler used to execute the operation. If not specified, defaults to the ImmediateScheduler.
	   * @returns {Observable} An observable sequence which results from the comonadic bind operation.
	   */
	  observableProto.manySelect = function (selector, scheduler) {
	    isScheduler(scheduler) || (scheduler = immediateScheduler);
	    var source = this;
	    return observableDefer(function () {
	      var chain;
	
	      return source
	        .map(function (x) {
	          var curr = new ChainObservable(x);
	
	          chain && chain.onNext(x);
	          chain = curr;
	
	          return curr;
	        })
	        .tap(
	          noop,
	          function (e) { chain && chain.onError(e); },
	          function () { chain && chain.onCompleted(); }
	        )
	        .observeOn(scheduler)
	        .map(selector);
	    });
	  };
	
	  var ChainObservable = (function (__super__) {
	
	    function subscribe (observer) {
	      var self = this, g = new CompositeDisposable();
	      g.add(currentThreadScheduler.schedule(function () {
	        observer.onNext(self.head);
	        g.add(self.tail.mergeObservable().subscribe(observer));
	      }));
	
	      return g;
	    }
	
	    inherits(ChainObservable, __super__);
	
	    function ChainObservable(head) {
	      __super__.call(this, subscribe);
	      this.head = head;
	      this.tail = new AsyncSubject();
	    }
	
	    addProperties(ChainObservable.prototype, Observer, {
	      onCompleted: function () {
	        this.onNext(Observable.empty());
	      },
	      onError: function (e) {
	        this.onNext(Observable.throwException(e));
	      },
	      onNext: function (v) {
	        this.tail.onNext(v);
	        this.tail.onCompleted();
	      }
	    });
	
	    return ChainObservable;
	
	  }(Observable));
	
	  /** @private */
	  var Map = root.Map || (function () {
	
	    function Map() {
	      this._keys = [];
	      this._values = [];
	    }
	
	    Map.prototype.get = function (key) {
	      var i = this._keys.indexOf(key);
	      return i !== -1 ? this._values[i] : undefined;
	    };
	
	    Map.prototype.set = function (key, value) {
	      var i = this._keys.indexOf(key);
	      i !== -1 && (this._values[i] = value);
	      this._values[this._keys.push(key) - 1] = value;
	    };
	
	    Map.prototype.forEach = function (callback, thisArg) {
	      for (var i = 0, len = this._keys.length; i < len; i++) {
	        callback.call(thisArg, this._values[i], this._keys[i]);
	      }
	    };
	
	    return Map;
	  }());
	
	  /**
	   * @constructor
	   * Represents a join pattern over observable sequences.
	   */
	  function Pattern(patterns) {
	    this.patterns = patterns;
	  }
	
	  /**
	   *  Creates a pattern that matches the current plan matches and when the specified observable sequences has an available value.
	   *  @param other Observable sequence to match in addition to the current pattern.
	   *  @return {Pattern} Pattern object that matches when all observable sequences in the pattern have an available value.
	   */
	  Pattern.prototype.and = function (other) {
	    return new Pattern(this.patterns.concat(other));
	  };
	
	  /**
	   *  Matches when all observable sequences in the pattern (specified using a chain of and operators) have an available value and projects the values.
	   *  @param {Function} selector Selector that will be invoked with available values from the source sequences, in the same order of the sequences in the pattern.
	   *  @return {Plan} Plan that produces the projected values, to be fed (with other plans) to the when operator.
	   */
	  Pattern.prototype.thenDo = function (selector) {
	    return new Plan(this, selector);
	  };
	
	  function Plan(expression, selector) {
	      this.expression = expression;
	      this.selector = selector;
	  }
	
	  Plan.prototype.activate = function (externalSubscriptions, observer, deactivate) {
	    var self = this;
	    var joinObservers = [];
	    for (var i = 0, len = this.expression.patterns.length; i < len; i++) {
	      joinObservers.push(planCreateObserver(externalSubscriptions, this.expression.patterns[i], observer.onError.bind(observer)));
	    }
	    var activePlan = new ActivePlan(joinObservers, function () {
	      var result;
	      try {
	        result = self.selector.apply(self, arguments);
	      } catch (e) {
	        observer.onError(e);
	        return;
	      }
	      observer.onNext(result);
	    }, function () {
	      for (var j = 0, jlen = joinObservers.length; j < jlen; j++) {
	        joinObservers[j].removeActivePlan(activePlan);
	      }
	      deactivate(activePlan);
	    });
	    for (i = 0, len = joinObservers.length; i < len; i++) {
	      joinObservers[i].addActivePlan(activePlan);
	    }
	    return activePlan;
	  };
	
	  function planCreateObserver(externalSubscriptions, observable, onError) {
	    var entry = externalSubscriptions.get(observable);
	    if (!entry) {
	      var observer = new JoinObserver(observable, onError);
	      externalSubscriptions.set(observable, observer);
	      return observer;
	    }
	    return entry;
	  }
	
	  function ActivePlan(joinObserverArray, onNext, onCompleted) {
	    this.joinObserverArray = joinObserverArray;
	    this.onNext = onNext;
	    this.onCompleted = onCompleted;
	    this.joinObservers = new Map();
	    for (var i = 0, len = this.joinObserverArray.length; i < len; i++) {
	      var joinObserver = this.joinObserverArray[i];
	      this.joinObservers.set(joinObserver, joinObserver);
	    }
	  }
	
	  ActivePlan.prototype.dequeue = function () {
	    this.joinObservers.forEach(function (v) { v.queue.shift(); });
	  };
	
	  ActivePlan.prototype.match = function () {
	    var i, len, hasValues = true;
	    for (i = 0, len = this.joinObserverArray.length; i < len; i++) {
	      if (this.joinObserverArray[i].queue.length === 0) {
	        hasValues = false;
	        break;
	      }
	    }
	    if (hasValues) {
	      var firstValues = [],
	          isCompleted = false;
	      for (i = 0, len = this.joinObserverArray.length; i < len; i++) {
	        firstValues.push(this.joinObserverArray[i].queue[0]);
	        this.joinObserverArray[i].queue[0].kind === 'C' && (isCompleted = true);
	      }
	      if (isCompleted) {
	        this.onCompleted();
	      } else {
	        this.dequeue();
	        var values = [];
	        for (i = 0, len = firstValues.length; i < firstValues.length; i++) {
	          values.push(firstValues[i].value);
	        }
	        this.onNext.apply(this, values);
	      }
	    }
	  };
	
	  var JoinObserver = (function (__super__) {
	
	    inherits(JoinObserver, __super__);
	
	    function JoinObserver(source, onError) {
	      __super__.call(this);
	      this.source = source;
	      this.onError = onError;
	      this.queue = [];
	      this.activePlans = [];
	      this.subscription = new SingleAssignmentDisposable();
	      this.isDisposed = false;
	    }
	
	    var JoinObserverPrototype = JoinObserver.prototype;
	
	    JoinObserverPrototype.next = function (notification) {
	      if (!this.isDisposed) {
	        if (notification.kind === 'E') {
	          this.onError(notification.exception);
	          return;
	        }
	        this.queue.push(notification);
	        var activePlans = this.activePlans.slice(0);
	        for (var i = 0, len = activePlans.length; i < len; i++) {
	          activePlans[i].match();
	        }
	      }
	    };
	
	    JoinObserverPrototype.error = noop;
	    JoinObserverPrototype.completed = noop;
	
	    JoinObserverPrototype.addActivePlan = function (activePlan) {
	      this.activePlans.push(activePlan);
	    };
	
	    JoinObserverPrototype.subscribe = function () {
	      this.subscription.setDisposable(this.source.materialize().subscribe(this));
	    };
	
	    JoinObserverPrototype.removeActivePlan = function (activePlan) {
	      this.activePlans.splice(this.activePlans.indexOf(activePlan), 1);
	      this.activePlans.length === 0 && this.dispose();
	    };
	
	    JoinObserverPrototype.dispose = function () {
	      __super__.prototype.dispose.call(this);
	      if (!this.isDisposed) {
	        this.isDisposed = true;
	        this.subscription.dispose();
	      }
	    };
	
	    return JoinObserver;
	  } (AbstractObserver));
	
	  /**
	   *  Creates a pattern that matches when both observable sequences have an available value.
	   *
	   *  @param right Observable sequence to match with the current sequence.
	   *  @return {Pattern} Pattern object that matches when both observable sequences have an available value.
	   */
	  observableProto.and = function (right) {
	    return new Pattern([this, right]);
	  };
	
	  /**
	   *  Matches when the observable sequence has an available value and projects the value.
	   *
	   *  @param selector Selector that will be invoked for values in the source sequence.
	   *  @returns {Plan} Plan that produces the projected values, to be fed (with other plans) to the when operator.
	   */
	  observableProto.thenDo = function (selector) {
	    return new Pattern([this]).thenDo(selector);
	  };
	
	  /**
	   *  Joins together the results from several patterns.
	   *
	   *  @param plans A series of plans (specified as an Array of as a series of arguments) created by use of the Then operator on patterns.
	   *  @returns {Observable} Observable sequence with the results form matching several patterns.
	   */
	  Observable.when = function () {
	    var plans = argsOrArray(arguments, 0);
	    return new AnonymousObservable(function (observer) {
	      var activePlans = [],
	          externalSubscriptions = new Map();
	      var outObserver = observerCreate(
	        observer.onNext.bind(observer),
	        function (err) {
	          externalSubscriptions.forEach(function (v) { v.onError(err); });
	          observer.onError(err);
	        },
	        observer.onCompleted.bind(observer)
	      );
	      try {
	        for (var i = 0, len = plans.length; i < len; i++) {
	          activePlans.push(plans[i].activate(externalSubscriptions, outObserver, function (activePlan) {
	            var idx = activePlans.indexOf(activePlan);
	            activePlans.splice(idx, 1);
	            activePlans.length === 0 && observer.onCompleted();
	          }));
	        }
	      } catch (e) {
	        observableThrow(e).subscribe(observer);
	      }
	      var group = new CompositeDisposable();
	      externalSubscriptions.forEach(function (joinObserver) {
	        joinObserver.subscribe();
	        group.add(joinObserver);
	      });
	
	      return group;
	    });
	  };
	
	  function observableTimerDate(dueTime, scheduler) {
	    return new AnonymousObservable(function (observer) {
	      return scheduler.scheduleWithAbsolute(dueTime, function () {
	        observer.onNext(0);
	        observer.onCompleted();
	      });
	    });
	  }
	
	  function observableTimerDateAndPeriod(dueTime, period, scheduler) {
	    return new AnonymousObservable(function (observer) {
	      var count = 0, d = dueTime, p = normalizeTime(period);
	      return scheduler.scheduleRecursiveWithAbsolute(d, function (self) {
	        if (p > 0) {
	          var now = scheduler.now();
	          d = d + p;
	          d <= now && (d = now + p);
	        }
	        observer.onNext(count++);
	        self(d);
	      });
	    });
	  }
	
	  function observableTimerTimeSpan(dueTime, scheduler) {
	    return new AnonymousObservable(function (observer) {
	      return scheduler.scheduleWithRelative(normalizeTime(dueTime), function () {
	        observer.onNext(0);
	        observer.onCompleted();
	      });
	    });
	  }
	
	  function observableTimerTimeSpanAndPeriod(dueTime, period, scheduler) {
	    return dueTime === period ?
	      new AnonymousObservable(function (observer) {
	        return scheduler.schedulePeriodicWithState(0, period, function (count) {
	          observer.onNext(count);
	          return count + 1;
	        });
	      }) :
	      observableDefer(function () {
	        return observableTimerDateAndPeriod(scheduler.now() + dueTime, period, scheduler);
	      });
	  }
	
	  /**
	   *  Returns an observable sequence that produces a value after each period.
	   *
	   * @example
	   *  1 - res = Rx.Observable.interval(1000);
	   *  2 - res = Rx.Observable.interval(1000, Rx.Scheduler.timeout);
	   *
	   * @param {Number} period Period for producing the values in the resulting sequence (specified as an integer denoting milliseconds).
	   * @param {Scheduler} [scheduler] Scheduler to run the timer on. If not specified, Rx.Scheduler.timeout is used.
	   * @returns {Observable} An observable sequence that produces a value after each period.
	   */
	  var observableinterval = Observable.interval = function (period, scheduler) {
	    return observableTimerTimeSpanAndPeriod(period, period, isScheduler(scheduler) ? scheduler : timeoutScheduler);
	  };
	
	  /**
	   *  Returns an observable sequence that produces a value after dueTime has elapsed and then after each period.
	   * @param {Number} dueTime Absolute (specified as a Date object) or relative time (specified as an integer denoting milliseconds) at which to produce the first value.
	   * @param {Mixed} [periodOrScheduler]  Period to produce subsequent values (specified as an integer denoting milliseconds), or the scheduler to run the timer on. If not specified, the resulting timer is not recurring.
	   * @param {Scheduler} [scheduler]  Scheduler to run the timer on. If not specified, the timeout scheduler is used.
	   * @returns {Observable} An observable sequence that produces a value after due time has elapsed and then each period.
	   */
	  var observableTimer = Observable.timer = function (dueTime, periodOrScheduler, scheduler) {
	    var period;
	    isScheduler(scheduler) || (scheduler = timeoutScheduler);
	    if (periodOrScheduler !== undefined && typeof periodOrScheduler === 'number') {
	      period = periodOrScheduler;
	    } else if (isScheduler(periodOrScheduler)) {
	      scheduler = periodOrScheduler;
	    }
	    if (dueTime instanceof Date && period === undefined) {
	      return observableTimerDate(dueTime.getTime(), scheduler);
	    }
	    if (dueTime instanceof Date && period !== undefined) {
	      period = periodOrScheduler;
	      return observableTimerDateAndPeriod(dueTime.getTime(), period, scheduler);
	    }
	    return period === undefined ?
	      observableTimerTimeSpan(dueTime, scheduler) :
	      observableTimerTimeSpanAndPeriod(dueTime, period, scheduler);
	  };
	
	  function observableDelayTimeSpan(source, dueTime, scheduler) {
	    return new AnonymousObservable(function (observer) {
	      var active = false,
	        cancelable = new SerialDisposable(),
	        exception = null,
	        q = [],
	        running = false,
	        subscription;
	      subscription = source.materialize().timestamp(scheduler).subscribe(function (notification) {
	        var d, shouldRun;
	        if (notification.value.kind === 'E') {
	          q = [];
	          q.push(notification);
	          exception = notification.value.exception;
	          shouldRun = !running;
	        } else {
	          q.push({ value: notification.value, timestamp: notification.timestamp + dueTime });
	          shouldRun = !active;
	          active = true;
	        }
	        if (shouldRun) {
	          if (exception !== null) {
	            observer.onError(exception);
	          } else {
	            d = new SingleAssignmentDisposable();
	            cancelable.setDisposable(d);
	            d.setDisposable(scheduler.scheduleRecursiveWithRelative(dueTime, function (self) {
	              var e, recurseDueTime, result, shouldRecurse;
	              if (exception !== null) {
	                return;
	              }
	              running = true;
	              do {
	                result = null;
	                if (q.length > 0 && q[0].timestamp - scheduler.now() <= 0) {
	                  result = q.shift().value;
	                }
	                if (result !== null) {
	                  result.accept(observer);
	                }
	              } while (result !== null);
	              shouldRecurse = false;
	              recurseDueTime = 0;
	              if (q.length > 0) {
	                shouldRecurse = true;
	                recurseDueTime = Math.max(0, q[0].timestamp - scheduler.now());
	              } else {
	                active = false;
	              }
	              e = exception;
	              running = false;
	              if (e !== null) {
	                observer.onError(e);
	              } else if (shouldRecurse) {
	                self(recurseDueTime);
	              }
	            }));
	          }
	        }
	      });
	      return new CompositeDisposable(subscription, cancelable);
	    });
	  }
	
	  function observableDelayDate(source, dueTime, scheduler) {
	    return observableDefer(function () {
	      return observableDelayTimeSpan(source, dueTime - scheduler.now(), scheduler);
	    });
	  }
	
	  /**
	   *  Time shifts the observable sequence by dueTime. The relative time intervals between the values are preserved.
	   *
	   * @example
	   *  1 - res = Rx.Observable.delay(new Date());
	   *  2 - res = Rx.Observable.delay(new Date(), Rx.Scheduler.timeout);
	   *
	   *  3 - res = Rx.Observable.delay(5000);
	   *  4 - res = Rx.Observable.delay(5000, 1000, Rx.Scheduler.timeout);
	   * @memberOf Observable#
	   * @param {Number} dueTime Absolute (specified as a Date object) or relative time (specified as an integer denoting milliseconds) by which to shift the observable sequence.
	   * @param {Scheduler} [scheduler] Scheduler to run the delay timers on. If not specified, the timeout scheduler is used.
	   * @returns {Observable} Time-shifted sequence.
	   */
	  observableProto.delay = function (dueTime, scheduler) {
	    isScheduler(scheduler) || (scheduler = timeoutScheduler);
	    return dueTime instanceof Date ?
	      observableDelayDate(this, dueTime.getTime(), scheduler) :
	      observableDelayTimeSpan(this, dueTime, scheduler);
	  };
	
	  /**
	   *  Ignores values from an observable sequence which are followed by another value before dueTime.
	   *
	   * @example
	   *  1 - res = source.throttle(5000); // 5 seconds
	   *  2 - res = source.throttle(5000, scheduler);
	   *
	   * @param {Number} dueTime Duration of the throttle period for each value (specified as an integer denoting milliseconds).
	   * @param {Scheduler} [scheduler]  Scheduler to run the throttle timers on. If not specified, the timeout scheduler is used.
	   * @returns {Observable} The throttled sequence.
	   */
	  observableProto.throttle = function (dueTime, scheduler) {
	    isScheduler(scheduler) || (scheduler = timeoutScheduler);
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      var cancelable = new SerialDisposable(), hasvalue = false, value, id = 0;
	      var subscription = source.subscribe(
	        function (x) {
	          hasvalue = true;
	          value = x;
	          id++;
	          var currentId = id,
	            d = new SingleAssignmentDisposable();
	          cancelable.setDisposable(d);
	          d.setDisposable(scheduler.scheduleWithRelative(dueTime, function () {
	            hasvalue && id === currentId && observer.onNext(value);
	            hasvalue = false;
	          }));
	        },
	        function (e) {
	          cancelable.dispose();
	          observer.onError(e);
	          hasvalue = false;
	          id++;
	        },
	        function () {
	          cancelable.dispose();
	          hasvalue && observer.onNext(value);
	          observer.onCompleted();
	          hasvalue = false;
	          id++;
	        });
	      return new CompositeDisposable(subscription, cancelable);
	    });
	  };
	
	  /**
	   *  Projects each element of an observable sequence into zero or more windows which are produced based on timing information.
	   * @param {Number} timeSpan Length of each window (specified as an integer denoting milliseconds).
	   * @param {Mixed} [timeShiftOrScheduler]  Interval between creation of consecutive windows (specified as an integer denoting milliseconds), or an optional scheduler parameter. If not specified, the time shift corresponds to the timeSpan parameter, resulting in non-overlapping adjacent windows.
	   * @param {Scheduler} [scheduler]  Scheduler to run windowing timers on. If not specified, the timeout scheduler is used.
	   * @returns {Observable} An observable sequence of windows.
	   */
	  observableProto.windowWithTime = function (timeSpan, timeShiftOrScheduler, scheduler) {
	    var source = this, timeShift;
	    timeShiftOrScheduler == null && (timeShift = timeSpan);
	    isScheduler(scheduler) || (scheduler = timeoutScheduler);
	    if (typeof timeShiftOrScheduler === 'number') {
	      timeShift = timeShiftOrScheduler;
	    } else if (isScheduler(timeShiftOrScheduler)) {
	      timeShift = timeSpan;
	      scheduler = timeShiftOrScheduler;
	    }
	    return new AnonymousObservable(function (observer) {
	      var groupDisposable,
	        nextShift = timeShift,
	        nextSpan = timeSpan,
	        q = [],
	        refCountDisposable,
	        timerD = new SerialDisposable(),
	        totalTime = 0;
	        groupDisposable = new CompositeDisposable(timerD),
	        refCountDisposable = new RefCountDisposable(groupDisposable);
	
	       function createTimer () {
	        var m = new SingleAssignmentDisposable(),
	          isSpan = false,
	          isShift = false;
	        timerD.setDisposable(m);
	        if (nextSpan === nextShift) {
	          isSpan = true;
	          isShift = true;
	        } else if (nextSpan < nextShift) {
	            isSpan = true;
	        } else {
	          isShift = true;
	        }
	        var newTotalTime = isSpan ? nextSpan : nextShift,
	          ts = newTotalTime - totalTime;
	        totalTime = newTotalTime;
	        if (isSpan) {
	          nextSpan += timeShift;
	        }
	        if (isShift) {
	          nextShift += timeShift;
	        }
	        m.setDisposable(scheduler.scheduleWithRelative(ts, function () {
	          if (isShift) {
	            var s = new Subject();
	            q.push(s);
	            observer.onNext(addRef(s, refCountDisposable));
	          }
	          isSpan && q.shift().onCompleted();
	          createTimer();
	        }));
	      };
	      q.push(new Subject());
	      observer.onNext(addRef(q[0], refCountDisposable));
	      createTimer();
	      groupDisposable.add(source.subscribe(
	        function (x) {
	          for (var i = 0, len = q.length; i < len; i++) { q[i].onNext(x); }
	        }, 
	        function (e) {
	          for (var i = 0, len = q.length; i < len; i++) { q[i].onError(e); }
	          observer.onError(e);
	        }, 
	        function () {
	          for (var i = 0, len = q.length; i < len; i++) { q[i].onCompleted(); }
	          observer.onCompleted();
	        }
	      ));
	      return refCountDisposable;
	    });
	  };
	
	  /**
	   *  Projects each element of an observable sequence into a window that is completed when either it's full or a given amount of time has elapsed.
	   * @param {Number} timeSpan Maximum time length of a window.
	   * @param {Number} count Maximum element count of a window.
	   * @param {Scheduler} [scheduler]  Scheduler to run windowing timers on. If not specified, the timeout scheduler is used.
	   * @returns {Observable} An observable sequence of windows.
	   */
	  observableProto.windowWithTimeOrCount = function (timeSpan, count, scheduler) {
	    var source = this;
	    isScheduler(scheduler) || (scheduler = timeoutScheduler);
	    return new AnonymousObservable(function (observer) {
	      var timerD = new SerialDisposable(),
	          groupDisposable = new CompositeDisposable(timerD),
	          refCountDisposable = new RefCountDisposable(groupDisposable),
	          n = 0,
	          windowId = 0,
	          s = new Subject();
	
	      function createTimer(id) {
	        var m = new SingleAssignmentDisposable();
	        timerD.setDisposable(m);
	        m.setDisposable(scheduler.scheduleWithRelative(timeSpan, function () {
	          if (id !== windowId) { return; }
	          n = 0;
	          var newId = ++windowId;
	          s.onCompleted();
	          s = new Subject();
	          observer.onNext(addRef(s, refCountDisposable));
	          createTimer(newId);
	        }));
	      }
	      
	      observer.onNext(addRef(s, refCountDisposable));
	      createTimer(0);
	
	      groupDisposable.add(source.subscribe(
	        function (x) {
	          var newId = 0, newWindow = false;
	          s.onNext(x);
	          if (++n === count) {
	            newWindow = true;
	            n = 0;
	            newId = ++windowId;
	            s.onCompleted();
	            s = new Subject();
	            observer.onNext(addRef(s, refCountDisposable));
	          }
	          newWindow && createTimer(newId);
	        }, 
	        function (e) {
	          s.onError(e);
	          observer.onError(e);
	        }, function () {
	          s.onCompleted();
	          observer.onCompleted();
	        }
	      ));
	      return refCountDisposable;
	    });
	  };
	
	    /**
	     *  Projects each element of an observable sequence into zero or more buffers which are produced based on timing information.
	     *
	     * @example
	     *  1 - res = xs.bufferWithTime(1000, scheduler); // non-overlapping segments of 1 second
	     *  2 - res = xs.bufferWithTime(1000, 500, scheduler; // segments of 1 second with time shift 0.5 seconds
	     *
	     * @param {Number} timeSpan Length of each buffer (specified as an integer denoting milliseconds).
	     * @param {Mixed} [timeShiftOrScheduler]  Interval between creation of consecutive buffers (specified as an integer denoting milliseconds), or an optional scheduler parameter. If not specified, the time shift corresponds to the timeSpan parameter, resulting in non-overlapping adjacent buffers.
	     * @param {Scheduler} [scheduler]  Scheduler to run buffer timers on. If not specified, the timeout scheduler is used.
	     * @returns {Observable} An observable sequence of buffers.
	     */
	    observableProto.bufferWithTime = function (timeSpan, timeShiftOrScheduler, scheduler) {
	        return this.windowWithTime.apply(this, arguments).selectMany(function (x) { return x.toArray(); });
	    };
	
	    /**
	     *  Projects each element of an observable sequence into a buffer that is completed when either it's full or a given amount of time has elapsed.
	     *
	     * @example
	     *  1 - res = source.bufferWithTimeOrCount(5000, 50); // 5s or 50 items in an array
	     *  2 - res = source.bufferWithTimeOrCount(5000, 50, scheduler); // 5s or 50 items in an array
	     *
	     * @param {Number} timeSpan Maximum time length of a buffer.
	     * @param {Number} count Maximum element count of a buffer.
	     * @param {Scheduler} [scheduler]  Scheduler to run bufferin timers on. If not specified, the timeout scheduler is used.
	     * @returns {Observable} An observable sequence of buffers.
	     */
	    observableProto.bufferWithTimeOrCount = function (timeSpan, count, scheduler) {
	        return this.windowWithTimeOrCount(timeSpan, count, scheduler).selectMany(function (x) {
	            return x.toArray();
	        });
	    };
	
	  /**
	   *  Records the time interval between consecutive values in an observable sequence.
	   *
	   * @example
	   *  1 - res = source.timeInterval();
	   *  2 - res = source.timeInterval(Rx.Scheduler.timeout);
	   *
	   * @param [scheduler]  Scheduler used to compute time intervals. If not specified, the timeout scheduler is used.
	   * @returns {Observable} An observable sequence with time interval information on values.
	   */
	  observableProto.timeInterval = function (scheduler) {
	    var source = this;
	    isScheduler(scheduler) || (scheduler = timeoutScheduler);
	    return observableDefer(function () {
	      var last = scheduler.now();
	      return source.map(function (x) {
	        var now = scheduler.now(), span = now - last;
	        last = now;
	        return { value: x, interval: span };
	      });
	    });
	  };
	
	  /**
	   *  Records the timestamp for each value in an observable sequence.
	   *
	   * @example
	   *  1 - res = source.timestamp(); // produces { value: x, timestamp: ts }
	   *  2 - res = source.timestamp(Rx.Scheduler.timeout);
	   *
	   * @param {Scheduler} [scheduler]  Scheduler used to compute timestamps. If not specified, the timeout scheduler is used.
	   * @returns {Observable} An observable sequence with timestamp information on values.
	   */
	  observableProto.timestamp = function (scheduler) {
	    isScheduler(scheduler) || (scheduler = timeoutScheduler);
	    return this.map(function (x) {
	      return { value: x, timestamp: scheduler.now() };
	    });
	  };
	
	  function sampleObservable(source, sampler) {
	
	    return new AnonymousObservable(function (observer) {
	      var atEnd, value, hasValue;
	
	      function sampleSubscribe() {
	        if (hasValue) {
	          hasValue = false;
	          observer.onNext(value);
	        }
	        atEnd && observer.onCompleted();
	      }
	
	      return new CompositeDisposable(
	        source.subscribe(function (newValue) {
	          hasValue = true;
	          value = newValue;
	        }, observer.onError.bind(observer), function () {
	          atEnd = true;
	        }),
	        sampler.subscribe(sampleSubscribe, observer.onError.bind(observer), sampleSubscribe)
	      );
	    });
	  }
	
	  /**
	   *  Samples the observable sequence at each interval.
	   *
	   * @example
	   *  1 - res = source.sample(sampleObservable); // Sampler tick sequence
	   *  2 - res = source.sample(5000); // 5 seconds
	   *  2 - res = source.sample(5000, Rx.Scheduler.timeout); // 5 seconds
	   *
	   * @param {Mixed} intervalOrSampler Interval at which to sample (specified as an integer denoting milliseconds) or Sampler Observable.
	   * @param {Scheduler} [scheduler]  Scheduler to run the sampling timer on. If not specified, the timeout scheduler is used.
	   * @returns {Observable} Sampled observable sequence.
	   */
	  observableProto.sample = function (intervalOrSampler, scheduler) {
	    isScheduler(scheduler) || (scheduler = timeoutScheduler);
	    return typeof intervalOrSampler === 'number' ?
	      sampleObservable(this, observableinterval(intervalOrSampler, scheduler)) :
	      sampleObservable(this, intervalOrSampler);
	  };
	
	  /**
	   *  Returns the source observable sequence or the other observable sequence if dueTime elapses.
	   * @param {Number} dueTime Absolute (specified as a Date object) or relative time (specified as an integer denoting milliseconds) when a timeout occurs.
	   * @param {Observable} [other]  Sequence to return in case of a timeout. If not specified, a timeout error throwing sequence will be used.
	   * @param {Scheduler} [scheduler]  Scheduler to run the timeout timers on. If not specified, the timeout scheduler is used.
	   * @returns {Observable} The source sequence switching to the other sequence in case of a timeout.
	   */
	  observableProto.timeout = function (dueTime, other, scheduler) {
	    (other == null || typeof other === 'string') && (other = observableThrow(new Error(other || 'Timeout')));
	    isScheduler(scheduler) || (scheduler = timeoutScheduler);
	
	    var source = this, schedulerMethod = dueTime instanceof Date ?
	      'scheduleWithAbsolute' :
	      'scheduleWithRelative';
	
	    return new AnonymousObservable(function (observer) {
	      var id = 0,
	        original = new SingleAssignmentDisposable(),
	        subscription = new SerialDisposable(),
	        switched = false,
	        timer = new SerialDisposable();
	
	      subscription.setDisposable(original);
	
	      function createTimer() {
	        var myId = id;
	        timer.setDisposable(scheduler[schedulerMethod](dueTime, function () {
	          if (id === myId) {
	            isPromise(other) && (other = observableFromPromise(other));
	            subscription.setDisposable(other.subscribe(observer));
	          }
	        }));
	      }
	
	      createTimer();
	
	      original.setDisposable(source.subscribe(function (x) {
	        if (!switched) {
	          id++;
	          observer.onNext(x);
	          createTimer();
	        }
	      }, function (e) {
	        if (!switched) {
	          id++;
	          observer.onError(e);
	        }
	      }, function () {
	        if (!switched) {
	          id++;
	          observer.onCompleted();
	        }
	      }));
	      return new CompositeDisposable(subscription, timer);
	    });
	  };
	
	  /**
	   *  Generates an observable sequence by iterating a state from an initial state until the condition fails.
	   *
	   * @example
	   *  res = source.generateWithAbsoluteTime(0,
	   *      function (x) { return return true; },
	   *      function (x) { return x + 1; },
	   *      function (x) { return x; },
	   *      function (x) { return new Date(); }
	   *  });
	   *
	   * @param {Mixed} initialState Initial state.
	   * @param {Function} condition Condition to terminate generation (upon returning false).
	   * @param {Function} iterate Iteration step function.
	   * @param {Function} resultSelector Selector function for results produced in the sequence.
	   * @param {Function} timeSelector Time selector function to control the speed of values being produced each iteration, returning Date values.
	   * @param {Scheduler} [scheduler]  Scheduler on which to run the generator loop. If not specified, the timeout scheduler is used.
	   * @returns {Observable} The generated sequence.
	   */
	  Observable.generateWithAbsoluteTime = function (initialState, condition, iterate, resultSelector, timeSelector, scheduler) {
	    isScheduler(scheduler) || (scheduler = timeoutScheduler);
	    return new AnonymousObservable(function (observer) {
	      var first = true,
	        hasResult = false,
	        result,
	        state = initialState,
	        time;
	      return scheduler.scheduleRecursiveWithAbsolute(scheduler.now(), function (self) {
	        hasResult && observer.onNext(result);
	
	        try {
	          if (first) {
	            first = false;
	          } else {
	            state = iterate(state);
	          }
	          hasResult = condition(state);
	          if (hasResult) {
	            result = resultSelector(state);
	            time = timeSelector(state);
	          }
	        } catch (e) {
	          observer.onError(e);
	          return;
	        }
	        if (hasResult) {
	          self(time);
	        } else {
	          observer.onCompleted();
	        }
	      });
	    });
	  };
	
	  /**
	   *  Generates an observable sequence by iterating a state from an initial state until the condition fails.
	   *
	   * @example
	   *  res = source.generateWithRelativeTime(0,
	   *      function (x) { return return true; },
	   *      function (x) { return x + 1; },
	   *      function (x) { return x; },
	   *      function (x) { return 500; }
	   *  );
	   *
	   * @param {Mixed} initialState Initial state.
	   * @param {Function} condition Condition to terminate generation (upon returning false).
	   * @param {Function} iterate Iteration step function.
	   * @param {Function} resultSelector Selector function for results produced in the sequence.
	   * @param {Function} timeSelector Time selector function to control the speed of values being produced each iteration, returning integer values denoting milliseconds.
	   * @param {Scheduler} [scheduler]  Scheduler on which to run the generator loop. If not specified, the timeout scheduler is used.
	   * @returns {Observable} The generated sequence.
	   */
	  Observable.generateWithRelativeTime = function (initialState, condition, iterate, resultSelector, timeSelector, scheduler) {
	    isScheduler(scheduler) || (scheduler = timeoutScheduler);
	    return new AnonymousObservable(function (observer) {
	      var first = true,
	        hasResult = false,
	        result,
	        state = initialState,
	        time;
	      return scheduler.scheduleRecursiveWithRelative(0, function (self) {
	        hasResult && observer.onNext(result);
	
	        try {
	          if (first) {
	            first = false;
	          } else {
	            state = iterate(state);
	          }
	          hasResult = condition(state);
	          if (hasResult) {
	            result = resultSelector(state);
	            time = timeSelector(state);
	          }
	        } catch (e) {
	          observer.onError(e);
	          return;
	        }
	        if (hasResult) {
	          self(time);
	        } else {
	          observer.onCompleted();
	        }
	      });
	    });
	  };
	
	  /**
	   *  Time shifts the observable sequence by delaying the subscription.
	   *
	   * @example
	   *  1 - res = source.delaySubscription(5000); // 5s
	   *  2 - res = source.delaySubscription(5000, Rx.Scheduler.timeout); // 5 seconds
	   *
	   * @param {Number} dueTime Absolute or relative time to perform the subscription at.
	   * @param {Scheduler} [scheduler]  Scheduler to run the subscription delay timer on. If not specified, the timeout scheduler is used.
	   * @returns {Observable} Time-shifted sequence.
	   */
	  observableProto.delaySubscription = function (dueTime, scheduler) {
	    return this.delayWithSelector(observableTimer(dueTime, isScheduler(scheduler) ? scheduler : timeoutScheduler), observableEmpty);
	  };
	
	    /**
	     *  Time shifts the observable sequence based on a subscription delay and a delay selector function for each element.
	     *
	     * @example
	     *  1 - res = source.delayWithSelector(function (x) { return Rx.Scheduler.timer(5000); }); // with selector only
	     *  1 - res = source.delayWithSelector(Rx.Observable.timer(2000), function (x) { return Rx.Observable.timer(x); }); // with delay and selector
	     *
	     * @param {Observable} [subscriptionDelay]  Sequence indicating the delay for the subscription to the source.
	     * @param {Function} delayDurationSelector Selector function to retrieve a sequence indicating the delay for each given element.
	     * @returns {Observable} Time-shifted sequence.
	     */
	    observableProto.delayWithSelector = function (subscriptionDelay, delayDurationSelector) {
	        var source = this, subDelay, selector;
	        if (typeof subscriptionDelay === 'function') {
	            selector = subscriptionDelay;
	        } else {
	            subDelay = subscriptionDelay;
	            selector = delayDurationSelector;
	        }
	        return new AnonymousObservable(function (observer) {
	            var delays = new CompositeDisposable(), atEnd = false, done = function () {
	                if (atEnd && delays.length === 0) {
	                    observer.onCompleted();
	                }
	            }, subscription = new SerialDisposable(), start = function () {
	                subscription.setDisposable(source.subscribe(function (x) {
	                    var delay;
	                    try {
	                        delay = selector(x);
	                    } catch (error) {
	                        observer.onError(error);
	                        return;
	                    }
	                    var d = new SingleAssignmentDisposable();
	                    delays.add(d);
	                    d.setDisposable(delay.subscribe(function () {
	                        observer.onNext(x);
	                        delays.remove(d);
	                        done();
	                    }, observer.onError.bind(observer), function () {
	                        observer.onNext(x);
	                        delays.remove(d);
	                        done();
	                    }));
	                }, observer.onError.bind(observer), function () {
	                    atEnd = true;
	                    subscription.dispose();
	                    done();
	                }));
	            };
	
	            if (!subDelay) {
	                start();
	            } else {
	                subscription.setDisposable(subDelay.subscribe(function () {
	                    start();
	                }, observer.onError.bind(observer), function () { start(); }));
	            }
	
	            return new CompositeDisposable(subscription, delays);
	        });
	    };
	
	    /**
	     *  Returns the source observable sequence, switching to the other observable sequence if a timeout is signaled.
	     * @param {Observable} [firstTimeout]  Observable sequence that represents the timeout for the first element. If not provided, this defaults to Observable.never().
	     * @param {Function} [timeoutDurationSelector] Selector to retrieve an observable sequence that represents the timeout between the current element and the next element.
	     * @param {Observable} [other]  Sequence to return in case of a timeout. If not provided, this is set to Observable.throwException().
	     * @returns {Observable} The source sequence switching to the other sequence in case of a timeout.
	     */
	    observableProto.timeoutWithSelector = function (firstTimeout, timeoutdurationSelector, other) {
	      if (arguments.length === 1) {
	          timeoutdurationSelector = firstTimeout;
	          firstTimeout = observableNever();
	      }
	      other || (other = observableThrow(new Error('Timeout')));
	      var source = this;
	      return new AnonymousObservable(function (observer) {
	        var subscription = new SerialDisposable(), timer = new SerialDisposable(), original = new SingleAssignmentDisposable();
	
	        subscription.setDisposable(original);
	
	        var id = 0, switched = false;
	
	        function setTimer(timeout) {
	          var myId = id;
	
	          function timerWins () {
	            return id === myId;
	          }
	
	          var d = new SingleAssignmentDisposable();
	          timer.setDisposable(d);
	          d.setDisposable(timeout.subscribe(function () {
	            timerWins() && subscription.setDisposable(other.subscribe(observer));
	            d.dispose();
	          }, function (e) {
	            timerWins() && observer.onError(e);
	          }, function () {
	            timerWins() && subscription.setDisposable(other.subscribe(observer));
	          }));
	        };
	
	        setTimer(firstTimeout);
	
	        function observerWins() {
	          var res = !switched;
	          if (res) { id++; }
	          return res;
	        }
	
	        original.setDisposable(source.subscribe(function (x) {
	          if (observerWins()) {
	            observer.onNext(x);
	            var timeout;
	            try {
	              timeout = timeoutdurationSelector(x);
	            } catch (e) {
	              observer.onError(e);
	              return;
	            }
	            setTimer(isPromise(timeout) ? observableFromPromise(timeout) : timeout);
	          }
	        }, function (e) {
	          observerWins() && observer.onError(e);
	        }, function () {
	          observerWins() && observer.onCompleted();
	        }));
	        return new CompositeDisposable(subscription, timer);
	      });
	    };
	
	  /**
	   *  Ignores values from an observable sequence which are followed by another value within a computed throttle duration.
	   *
	   * @example
	   *  1 - res = source.delayWithSelector(function (x) { return Rx.Scheduler.timer(x + x); });
	   *
	   * @param {Function} throttleDurationSelector Selector function to retrieve a sequence indicating the throttle duration for each given element.
	   * @returns {Observable} The throttled sequence.
	   */
	  observableProto.throttleWithSelector = function (throttleDurationSelector) {
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      var value, hasValue = false, cancelable = new SerialDisposable(), id = 0;
	      var subscription = source.subscribe(function (x) {
	        var throttle;
	        try {
	          throttle = throttleDurationSelector(x);
	        } catch (e) {
	          observer.onError(e);
	          return;
	        }
	
	        isPromise(throttle) && (throttle = observableFromPromise(throttle));
	
	        hasValue = true;
	        value = x;
	        id++;
	        var currentid = id, d = new SingleAssignmentDisposable();
	        cancelable.setDisposable(d);
	        d.setDisposable(throttle.subscribe(function () {
	          hasValue && id === currentid && observer.onNext(value);
	          hasValue = false;
	          d.dispose();
	        }, observer.onError.bind(observer), function () {
	          hasValue && id === currentid && observer.onNext(value);
	          hasValue = false;
	          d.dispose();
	        }));
	      }, function (e) {
	        cancelable.dispose();
	        observer.onError(e);
	        hasValue = false;
	        id++;
	      }, function () {
	        cancelable.dispose();
	        hasValue && observer.onNext(value);
	        observer.onCompleted();
	        hasValue = false;
	        id++;
	      });
	      return new CompositeDisposable(subscription, cancelable);
	    });
	  };
	
	  /**
	   *  Skips elements for the specified duration from the end of the observable source sequence, using the specified scheduler to run timers.
	   *
	   *  1 - res = source.skipLastWithTime(5000);
	   *  2 - res = source.skipLastWithTime(5000, scheduler);
	   *
	   * @description
	   *  This operator accumulates a queue with a length enough to store elements received during the initial duration window.
	   *  As more elements are received, elements older than the specified duration are taken from the queue and produced on the
	   *  result sequence. This causes elements to be delayed with duration.
	   * @param {Number} duration Duration for skipping elements from the end of the sequence.
	   * @param {Scheduler} [scheduler]  Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout
	   * @returns {Observable} An observable sequence with the elements skipped during the specified duration from the end of the source sequence.
	   */
	  observableProto.skipLastWithTime = function (duration, scheduler) {
	    isScheduler(scheduler) || (scheduler = timeoutScheduler);
	    var source = this;
	    return new AnonymousObservable(function (observer) {
	      var q = [];
	      return source.subscribe(function (x) {
	        var now = scheduler.now();
	        q.push({ interval: now, value: x });
	        while (q.length > 0 && now - q[0].interval >= duration) {
	          observer.onNext(q.shift().value);
	        }
	      }, observer.onError.bind(observer), function () {
	        var now = scheduler.now();
	        while (q.length > 0 && now - q[0].interval >= duration) {
	          observer.onNext(q.shift().value);
	        }
	        observer.onCompleted();
	      });
	    });
	  };
	
	  /**
	   *  Returns elements within the specified duration from the end of the observable source sequence, using the specified schedulers to run timers and to drain the collected elements.
	   * @description
	   *  This operator accumulates a queue with a length enough to store elements received during the initial duration window.
	   *  As more elements are received, elements older than the specified duration are taken from the queue and produced on the
	   *  result sequence. This causes elements to be delayed with duration.
	   * @param {Number} duration Duration for taking elements from the end of the sequence.
	   * @param {Scheduler} [scheduler]  Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.
	   * @returns {Observable} An observable sequence with the elements taken during the specified duration from the end of the source sequence.
	   */
	  observableProto.takeLastWithTime = function (duration, scheduler) {
	    var source = this;
	    isScheduler(scheduler) || (scheduler = timeoutScheduler);
	    return new AnonymousObservable(function (observer) {
	      var q = [];
	      return source.subscribe(function (x) {
	        var now = scheduler.now();
	        q.push({ interval: now, value: x });
	        while (q.length > 0 && now - q[0].interval >= duration) {
	          q.shift();
	        }
	      }, observer.onError.bind(observer), function () {
	        var now = scheduler.now();
	        while (q.length > 0) {
	          var next = q.shift();
	          if (now - next.interval <= duration) { observer.onNext(next.value); }
	        }
	        observer.onCompleted();
	      });
	    });
	  };
	
	  /**
	   *  Returns an array with the elements within the specified duration from the end of the observable source sequence, using the specified scheduler to run timers.
	   * @description
	   *  This operator accumulates a queue with a length enough to store elements received during the initial duration window.
	   *  As more elements are received, elements older than the specified duration are taken from the queue and produced on the
	   *  result sequence. This causes elements to be delayed with duration.
	   * @param {Number} duration Duration for taking elements from the end of the sequence.
	   * @param {Scheduler} scheduler Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.
	   * @returns {Observable} An observable sequence containing a single array with the elements taken during the specified duration from the end of the source sequence.
	   */
	  observableProto.takeLastBufferWithTime = function (duration, scheduler) {
	    var source = this;
	    isScheduler(scheduler) || (scheduler = timeoutScheduler);
	    return new AnonymousObservable(function (observer) {
	      var q = [];
	      return source.subscribe(function (x) {
	        var now = scheduler.now();
	        q.push({ interval: now, value: x });
	        while (q.length > 0 && now - q[0].interval >= duration) {
	          q.shift();
	        }
	      }, observer.onError.bind(observer), function () {
	        var now = scheduler.now(), res = [];
	        while (q.length > 0) {
	          var next = q.shift();
	          if (now - next.interval <= duration) { res.push(next.value); }
	        }
	        observer.onNext(res);
	        observer.onCompleted();
	      });
	    });
	  };
	
	  /**
	   *  Takes elements for the specified duration from the start of the observable source sequence, using the specified scheduler to run timers.
	   *
	   * @example
	   *  1 - res = source.takeWithTime(5000,  [optional scheduler]);
	   * @description
	   *  This operator accumulates a queue with a length enough to store elements received during the initial duration window.
	   *  As more elements are received, elements older than the specified duration are taken from the queue and produced on the
	   *  result sequence. This causes elements to be delayed with duration.
	   * @param {Number} duration Duration for taking elements from the start of the sequence.
	   * @param {Scheduler} scheduler Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.
	   * @returns {Observable} An observable sequence with the elements taken during the specified duration from the start of the source sequence.
	   */
	  observableProto.takeWithTime = function (duration, scheduler) {
	    var source = this;
	    isScheduler(scheduler) || (scheduler = timeoutScheduler);
	    return new AnonymousObservable(function (observer) {
	      return new CompositeDisposable(scheduler.scheduleWithRelative(duration, observer.onCompleted.bind(observer)), source.subscribe(observer));
	    });
	  };
	
	  /**
	   *  Skips elements for the specified duration from the start of the observable source sequence, using the specified scheduler to run timers.
	   *
	   * @example
	   *  1 - res = source.skipWithTime(5000, [optional scheduler]);
	   *
	   * @description
	   *  Specifying a zero value for duration doesn't guarantee no elements will be dropped from the start of the source sequence.
	   *  This is a side-effect of the asynchrony introduced by the scheduler, where the action that causes callbacks from the source sequence to be forwarded
	   *  may not execute immediately, despite the zero due time.
	   *
	   *  Errors produced by the source sequence are always forwarded to the result sequence, even if the error occurs before the duration.
	   * @param {Number} duration Duration for skipping elements from the start of the sequence.
	   * @param {Scheduler} scheduler Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.
	   * @returns {Observable} An observable sequence with the elements skipped during the specified duration from the start of the source sequence.
	   */
	  observableProto.skipWithTime = function (duration, scheduler) {
	    var source = this;
	    isScheduler(scheduler) || (scheduler = timeoutScheduler);
	    return new AnonymousObservable(function (observer) {
	      var open = false;
	      return new CompositeDisposable(
	        scheduler.scheduleWithRelative(duration, function () { open = true; }),
	        source.subscribe(function (x) { open && observer.onNext(x); }, observer.onError.bind(observer), observer.onCompleted.bind(observer)));
	    });
	  };
	
	  /**
	   *  Skips elements from the observable source sequence until the specified start time, using the specified scheduler to run timers.
	   *  Errors produced by the source sequence are always forwarded to the result sequence, even if the error occurs before the start time.
	   *
	   * @examples
	   *  1 - res = source.skipUntilWithTime(new Date(), [scheduler]);
	   *  2 - res = source.skipUntilWithTime(5000, [scheduler]);
	   * @param {Date|Number} startTime Time to start taking elements from the source sequence. If this value is less than or equal to Date(), no elements will be skipped.
	   * @param {Scheduler} [scheduler] Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.
	   * @returns {Observable} An observable sequence with the elements skipped until the specified start time.
	   */
	  observableProto.skipUntilWithTime = function (startTime, scheduler) {
	    isScheduler(scheduler) || (scheduler = timeoutScheduler);
	    var source = this, schedulerMethod = startTime instanceof Date ?
	      'scheduleWithAbsolute' :
	      'scheduleWithRelative';
	    return new AnonymousObservable(function (observer) {
	      var open = false;
	
	      return new CompositeDisposable(
	        scheduler[schedulerMethod](startTime, function () { open = true; }),
	        source.subscribe(
	          function (x) { open && observer.onNext(x); },
	          observer.onError.bind(observer),
	          observer.onCompleted.bind(observer)));
	    });
	  };
	
	  /**
	   *  Takes elements for the specified duration until the specified end time, using the specified scheduler to run timers.
	   * @param {Number | Date} endTime Time to stop taking elements from the source sequence. If this value is less than or equal to new Date(), the result stream will complete immediately.
	   * @param {Scheduler} [scheduler] Scheduler to run the timer on.
	   * @returns {Observable} An observable sequence with the elements taken until the specified end time.
	   */
	  observableProto.takeUntilWithTime = function (endTime, scheduler) {
	    isScheduler(scheduler) || (scheduler = timeoutScheduler);
	    var source = this, schedulerMethod = endTime instanceof Date ?
	      'scheduleWithAbsolute' :
	      'scheduleWithRelative';
	    return new AnonymousObservable(function (observer) {
	      return new CompositeDisposable(
	        scheduler[schedulerMethod](endTime, observer.onCompleted.bind(observer)),
	        source.subscribe(observer));
	    });
	  };
	
	  /**
	   * Executes a transducer to transform the observable sequence 
	   * @param {Transducer} transducer A transducer to execute
	   * @returns {Observable} An Observable sequence containing the results from the transducer.
	   */
	  observableProto.transduce = function(transducer) {
	    var source = this;
	
	    function transformForObserver(observer) {
	      return {
	        init: function() {
	          return observer;
	        },
	        step: function(obs, input) {
	          return obs.onNext(input);
	        },
	        result: function(obs) {
	          return obs.onCompleted();
	        }
	      };
	    }
	
	    return new AnonymousObservable(function(observer) {
	      var xform = transducer(transformForObserver(observer));
	      return source.subscribe(
	        function(v) { 
	          try {
	            xform.step(observer, v);
	          } catch (e) {
	            observer.onError(e);
	          }
	        }, 
	        observer.onError.bind(observer), 
	        function() { xform.result(observer); }
	      );
	    });
	  };
	
	  /*
	   * Performs a exclusive waiting for the first to finish before subscribing to another observable.
	   * Observables that come in between subscriptions will be dropped on the floor.
	   * @returns {Observable} A exclusive observable with only the results that happen when subscribed.
	   */
	  observableProto.exclusive = function () {
	    var sources = this;
	    return new AnonymousObservable(function (observer) {
	      var hasCurrent = false,
	        isStopped = false,
	        m = new SingleAssignmentDisposable(),
	        g = new CompositeDisposable();
	
	      g.add(m);
	
	      m.setDisposable(sources.subscribe(
	        function (innerSource) {
	          if (!hasCurrent) {
	            hasCurrent = true;
	
	            isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
	
	            var innerSubscription = new SingleAssignmentDisposable();
	            g.add(innerSubscription);
	
	            innerSubscription.setDisposable(innerSource.subscribe(
	              observer.onNext.bind(observer),
	              observer.onError.bind(observer),
	              function () {
	                g.remove(innerSubscription);
	                hasCurrent = false;
	                if (isStopped && g.length === 1) {
	                  observer.onCompleted();
	                }
	            }));
	          }
	        },
	        observer.onError.bind(observer),
	        function () {
	          isStopped = true;
	          if (!hasCurrent && g.length === 1) {
	            observer.onCompleted();
	          }
	        }));
	
	      return g;
	    });
	  };
	
	  /*
	   * Performs a exclusive map waiting for the first to finish before subscribing to another observable.
	   * Observables that come in between subscriptions will be dropped on the floor.
	   * @param {Function} selector Selector to invoke for every item in the current subscription.
	   * @param {Any} [thisArg] An optional context to invoke with the selector parameter.
	   * @returns {Observable} An exclusive observable with only the results that happen when subscribed.
	   */
	  observableProto.exclusiveMap = function (selector, thisArg) {
	    var sources = this;
	    return new AnonymousObservable(function (observer) {
	      var index = 0,
	        hasCurrent = false,
	        isStopped = true,
	        m = new SingleAssignmentDisposable(),
	        g = new CompositeDisposable();
	
	      g.add(m);
	
	      m.setDisposable(sources.subscribe(
	        function (innerSource) {
	
	          if (!hasCurrent) {
	            hasCurrent = true;
	
	            innerSubscription = new SingleAssignmentDisposable();
	            g.add(innerSubscription);
	
	            isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
	
	            innerSubscription.setDisposable(innerSource.subscribe(
	              function (x) {
	                var result;
	                try {
	                  result = selector.call(thisArg, x, index++, innerSource);
	                } catch (e) {
	                  observer.onError(e);
	                  return;
	                }
	
	                observer.onNext(result);
	              },
	              observer.onError.bind(observer),
	              function () {
	                g.remove(innerSubscription);
	                hasCurrent = false;
	
	                if (isStopped && g.length === 1) {
	                  observer.onCompleted();
	                }
	              }));
	          }
	        },
	        observer.onError.bind(observer),
	        function () {
	          isStopped = true;
	          if (g.length === 1 && !hasCurrent) {
	            observer.onCompleted();
	          }
	        }));
	      return g;
	    });
	  };
	
	  /** Provides a set of extension methods for virtual time scheduling. */
	  Rx.VirtualTimeScheduler = (function (__super__) {
	
	    function notImplemented() {
	        throw new Error('Not implemented');
	    }
	
	    function localNow() {
	      return this.toDateTimeOffset(this.clock);
	    }
	
	    function scheduleNow(state, action) {
	      return this.scheduleAbsoluteWithState(state, this.clock, action);
	    }
	
	    function scheduleRelative(state, dueTime, action) {
	      return this.scheduleRelativeWithState(state, this.toRelative(dueTime), action);
	    }
	
	    function scheduleAbsolute(state, dueTime, action) {
	      return this.scheduleRelativeWithState(state, this.toRelative(dueTime - this.now()), action);
	    }
	
	    function invokeAction(scheduler, action) {
	      action();
	      return disposableEmpty;
	    }
	
	    inherits(VirtualTimeScheduler, __super__);
	
	    /**
	     * Creates a new virtual time scheduler with the specified initial clock value and absolute time comparer.
	     *
	     * @constructor
	     * @param {Number} initialClock Initial value for the clock.
	     * @param {Function} comparer Comparer to determine causality of events based on absolute time.
	     */
	    function VirtualTimeScheduler(initialClock, comparer) {
	      this.clock = initialClock;
	      this.comparer = comparer;
	      this.isEnabled = false;
	      this.queue = new PriorityQueue(1024);
	      __super__.call(this, localNow, scheduleNow, scheduleRelative, scheduleAbsolute);
	    }
	
	    var VirtualTimeSchedulerPrototype = VirtualTimeScheduler.prototype;
	
	    /**
	     * Adds a relative time value to an absolute time value.
	     * @param {Number} absolute Absolute virtual time value.
	     * @param {Number} relative Relative virtual time value to add.
	     * @return {Number} Resulting absolute virtual time sum value.
	     */
	    VirtualTimeSchedulerPrototype.add = notImplemented;
	
	    /**
	     * Converts an absolute time to a number
	     * @param {Any} The absolute time.
	     * @returns {Number} The absolute time in ms
	     */
	    VirtualTimeSchedulerPrototype.toDateTimeOffset = notImplemented;
	
	    /**
	     * Converts the TimeSpan value to a relative virtual time value.
	     * @param {Number} timeSpan TimeSpan value to convert.
	     * @return {Number} Corresponding relative virtual time value.
	     */
	    VirtualTimeSchedulerPrototype.toRelative = notImplemented;
	
	    /**
	     * Schedules a periodic piece of work by dynamically discovering the scheduler's capabilities. The periodic task will be emulated using recursive scheduling.
	     * @param {Mixed} state Initial state passed to the action upon the first iteration.
	     * @param {Number} period Period for running the work periodically.
	     * @param {Function} action Action to be executed, potentially updating the state.
	     * @returns {Disposable} The disposable object used to cancel the scheduled recurring action (best effort).
	     */
	    VirtualTimeSchedulerPrototype.schedulePeriodicWithState = function (state, period, action) {
	      var s = new SchedulePeriodicRecursive(this, state, period, action);
	      return s.start();
	    };
	
	    /**
	     * Schedules an action to be executed after dueTime.
	     * @param {Mixed} state State passed to the action to be executed.
	     * @param {Number} dueTime Relative time after which to execute the action.
	     * @param {Function} action Action to be executed.
	     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
	     */
	    VirtualTimeSchedulerPrototype.scheduleRelativeWithState = function (state, dueTime, action) {
	      var runAt = this.add(this.clock, dueTime);
	      return this.scheduleAbsoluteWithState(state, runAt, action);
	    };
	
	    /**
	     * Schedules an action to be executed at dueTime.
	     * @param {Number} dueTime Relative time after which to execute the action.
	     * @param {Function} action Action to be executed.
	     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
	     */
	    VirtualTimeSchedulerPrototype.scheduleRelative = function (dueTime, action) {
	      return this.scheduleRelativeWithState(action, dueTime, invokeAction);
	    };
	
	    /**
	     * Starts the virtual time scheduler.
	     */
	    VirtualTimeSchedulerPrototype.start = function () {
	      if (!this.isEnabled) {
	        this.isEnabled = true;
	        do {
	          var next = this.getNext();
	          if (next !== null) {
	            this.comparer(next.dueTime, this.clock) > 0 && (this.clock = next.dueTime);
	            next.invoke();
	          } else {
	            this.isEnabled = false;
	          }
	        } while (this.isEnabled);
	      }
	    };
	
	    /**
	     * Stops the virtual time scheduler.
	     */
	    VirtualTimeSchedulerPrototype.stop = function () {
	      this.isEnabled = false;
	    };
	
	    /**
	     * Advances the scheduler's clock to the specified time, running all work till that point.
	     * @param {Number} time Absolute time to advance the scheduler's clock to.
	     */
	    VirtualTimeSchedulerPrototype.advanceTo = function (time) {
	      var dueToClock = this.comparer(this.clock, time);
	      if (this.comparer(this.clock, time) > 0) {
	        throw new Error(argumentOutOfRange);
	      }
	      if (dueToClock === 0) {
	        return;
	      }
	      if (!this.isEnabled) {
	        this.isEnabled = true;
	        do {
	          var next = this.getNext();
	          if (next !== null && this.comparer(next.dueTime, time) <= 0) {
	            this.comparer(next.dueTime, this.clock) > 0 && (this.clock = next.dueTime);
	            next.invoke();
	          } else {
	            this.isEnabled = false;
	          }
	        } while (this.isEnabled);
	        this.clock = time;
	      }
	    };
	
	    /**
	     * Advances the scheduler's clock by the specified relative time, running all work scheduled for that timespan.
	     * @param {Number} time Relative time to advance the scheduler's clock by.
	     */
	    VirtualTimeSchedulerPrototype.advanceBy = function (time) {
	      var dt = this.add(this.clock, time),
	          dueToClock = this.comparer(this.clock, dt);
	      if (dueToClock > 0) { throw new Error(argumentOutOfRange); }
	      if (dueToClock === 0) {  return; }
	
	      this.advanceTo(dt);
	    };
	
	    /**
	     * Advances the scheduler's clock by the specified relative time.
	     * @param {Number} time Relative time to advance the scheduler's clock by.
	     */
	    VirtualTimeSchedulerPrototype.sleep = function (time) {
	      var dt = this.add(this.clock, time);
	      if (this.comparer(this.clock, dt) >= 0) { throw new Error(argumentOutOfRange); }
	
	      this.clock = dt;
	    };
	
	    /**
	     * Gets the next scheduled item to be executed.
	     * @returns {ScheduledItem} The next scheduled item.
	     */
	    VirtualTimeSchedulerPrototype.getNext = function () {
	      while (this.queue.length > 0) {
	        var next = this.queue.peek();
	        if (next.isCancelled()) {
	          this.queue.dequeue();
	        } else {
	          return next;
	        }
	      }
	      return null;
	    };
	
	    /**
	     * Schedules an action to be executed at dueTime.
	     * @param {Scheduler} scheduler Scheduler to execute the action on.
	     * @param {Number} dueTime Absolute time at which to execute the action.
	     * @param {Function} action Action to be executed.
	     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
	     */
	    VirtualTimeSchedulerPrototype.scheduleAbsolute = function (dueTime, action) {
	      return this.scheduleAbsoluteWithState(action, dueTime, invokeAction);
	    };
	
	    /**
	     * Schedules an action to be executed at dueTime.
	     * @param {Mixed} state State passed to the action to be executed.
	     * @param {Number} dueTime Absolute time at which to execute the action.
	     * @param {Function} action Action to be executed.
	     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).
	     */
	    VirtualTimeSchedulerPrototype.scheduleAbsoluteWithState = function (state, dueTime, action) {
	      var self = this;
	
	      function run(scheduler, state1) {
	        self.queue.remove(si);
	        return action(scheduler, state1);
	      }
	
	      var si = new ScheduledItem(this, state, run, dueTime, this.comparer);
	      this.queue.enqueue(si);
	
	      return si.disposable;
	    };
	
	    return VirtualTimeScheduler;
	  }(Scheduler));
	
	  /** Provides a virtual time scheduler that uses Date for absolute time and number for relative time. */
	  Rx.HistoricalScheduler = (function (__super__) {
	    inherits(HistoricalScheduler, __super__);
	
	    /**
	     * Creates a new historical scheduler with the specified initial clock value.
	     * @constructor
	     * @param {Number} initialClock Initial value for the clock.
	     * @param {Function} comparer Comparer to determine causality of events based on absolute time.
	     */
	    function HistoricalScheduler(initialClock, comparer) {
	      var clock = initialClock == null ? 0 : initialClock;
	      var cmp = comparer || defaultSubComparer;
	      __super__.call(this, clock, cmp);
	    }
	
	    var HistoricalSchedulerProto = HistoricalScheduler.prototype;
	
	    /**
	     * Adds a relative time value to an absolute time value.
	     * @param {Number} absolute Absolute virtual time value.
	     * @param {Number} relative Relative virtual time value to add.
	     * @return {Number} Resulting absolute virtual time sum value.
	     */
	    HistoricalSchedulerProto.add = function (absolute, relative) {
	      return absolute + relative;
	    };
	
	    HistoricalSchedulerProto.toDateTimeOffset = function (absolute) {
	      return new Date(absolute).getTime();
	    };
	
	    /**
	     * Converts the TimeSpan value to a relative virtual time value.
	     * @memberOf HistoricalScheduler
	     * @param {Number} timeSpan TimeSpan value to convert.
	     * @return {Number} Corresponding relative virtual time value.
	     */
	    HistoricalSchedulerProto.toRelative = function (timeSpan) {
	      return timeSpan;
	    };
	
	    return HistoricalScheduler;
	  }(Rx.VirtualTimeScheduler));
	
	  var AnonymousObservable = Rx.AnonymousObservable = (function (__super__) {
	    inherits(AnonymousObservable, __super__);
	
	    // Fix subscriber to check for undefined or function returned to decorate as Disposable
	    function fixSubscriber(subscriber) {
	      if (subscriber && typeof subscriber.dispose === 'function') { return subscriber; }
	
	      return typeof subscriber === 'function' ?
	        disposableCreate(subscriber) :
	        disposableEmpty;
	    }
	
	    function AnonymousObservable(subscribe) {
	      if (!(this instanceof AnonymousObservable)) {
	        return new AnonymousObservable(subscribe);
	      }
	
	      function s(observer) {
	        var setDisposable = function () {
	          try {
	            autoDetachObserver.setDisposable(fixSubscriber(subscribe(autoDetachObserver)));
	          } catch (e) {
	            if (!autoDetachObserver.fail(e)) {
	              throw e;
	            }
	          }
	        };
	
	        var autoDetachObserver = new AutoDetachObserver(observer);
	        if (currentThreadScheduler.scheduleRequired()) {
	          currentThreadScheduler.schedule(setDisposable);
	        } else {
	          setDisposable();
	        }
	
	        return autoDetachObserver;
	      }
	
	      __super__.call(this, s);
	    }
	
	    return AnonymousObservable;
	
	  }(Observable));
	
	    /** @private */
	    var AutoDetachObserver = (function (_super) {
	        inherits(AutoDetachObserver, _super);
	
	        function AutoDetachObserver(observer) {
	            _super.call(this);
	            this.observer = observer;
	            this.m = new SingleAssignmentDisposable();
	        }
	
	        var AutoDetachObserverPrototype = AutoDetachObserver.prototype;
	
	        AutoDetachObserverPrototype.next = function (value) {
	            var noError = false;
	            try {
	                this.observer.onNext(value);
	                noError = true;
	            } catch (e) {
	                throw e;
	            } finally {
	                if (!noError) {
	                    this.dispose();
	                }
	            }
	        };
	
	        AutoDetachObserverPrototype.error = function (exn) {
	            try {
	                this.observer.onError(exn);
	            } catch (e) {
	                throw e;
	            } finally {
	                this.dispose();
	            }
	        };
	
	        AutoDetachObserverPrototype.completed = function () {
	            try {
	                this.observer.onCompleted();
	            } catch (e) {
	                throw e;
	            } finally {
	                this.dispose();
	            }
	        };
	
	        AutoDetachObserverPrototype.setDisposable = function (value) { this.m.setDisposable(value); };
	        AutoDetachObserverPrototype.getDisposable = function (value) { return this.m.getDisposable(); };
	        /* @private */
	        AutoDetachObserverPrototype.disposable = function (value) {
	            return arguments.length ? this.getDisposable() : setDisposable(value);
	        };
	
	        AutoDetachObserverPrototype.dispose = function () {
	            _super.prototype.dispose.call(this);
	            this.m.dispose();
	        };
	
	        return AutoDetachObserver;
	    }(AbstractObserver));
	
	  var GroupedObservable = (function (__super__) {
	    inherits(GroupedObservable, __super__);
	
	    function subscribe(observer) {
	      return this.underlyingObservable.subscribe(observer);
	    }
	
	    function GroupedObservable(key, underlyingObservable, mergedDisposable) {
	      __super__.call(this, subscribe);
	      this.key = key;
	      this.underlyingObservable = !mergedDisposable ?
	        underlyingObservable :
	        new AnonymousObservable(function (observer) {
	          return new CompositeDisposable(mergedDisposable.getDisposable(), underlyingObservable.subscribe(observer));
	        });
	    }
	
	    return GroupedObservable;
	  }(Observable));
	
	    /**
	     *  Represents an object that is both an observable sequence as well as an observer.
	     *  Each notification is broadcasted to all subscribed observers.
	     */
	    var Subject = Rx.Subject = (function (_super) {
	        function subscribe(observer) {
	            checkDisposed.call(this);
	            if (!this.isStopped) {
	                this.observers.push(observer);
	                return new InnerSubscription(this, observer);
	            }
	            if (this.exception) {
	                observer.onError(this.exception);
	                return disposableEmpty;
	            }
	            observer.onCompleted();
	            return disposableEmpty;
	        }
	
	        inherits(Subject, _super);
	
	        /**
	         * Creates a subject.
	         * @constructor
	         */
	        function Subject() {
	            _super.call(this, subscribe);
	            this.isDisposed = false,
	            this.isStopped = false,
	            this.observers = [];
	        }
	
	        addProperties(Subject.prototype, Observer, {
	            /**
	             * Indicates whether the subject has observers subscribed to it.
	             * @returns {Boolean} Indicates whether the subject has observers subscribed to it.
	             */
	            hasObservers: function () {
	                return this.observers.length > 0;
	            },
	            /**
	             * Notifies all subscribed observers about the end of the sequence.
	             */
	            onCompleted: function () {
	                checkDisposed.call(this);
	                if (!this.isStopped) {
	                    var os = this.observers.slice(0);
	                    this.isStopped = true;
	                    for (var i = 0, len = os.length; i < len; i++) {
	                        os[i].onCompleted();
	                    }
	
	                    this.observers = [];
	                }
	            },
	            /**
	             * Notifies all subscribed observers about the exception.
	             * @param {Mixed} error The exception to send to all observers.
	             */
	            onError: function (exception) {
	                checkDisposed.call(this);
	                if (!this.isStopped) {
	                    var os = this.observers.slice(0);
	                    this.isStopped = true;
	                    this.exception = exception;
	                    for (var i = 0, len = os.length; i < len; i++) {
	                        os[i].onError(exception);
	                    }
	
	                    this.observers = [];
	                }
	            },
	            /**
	             * Notifies all subscribed observers about the arrival of the specified element in the sequence.
	             * @param {Mixed} value The value to send to all observers.
	             */
	            onNext: function (value) {
	                checkDisposed.call(this);
	                if (!this.isStopped) {
	                    var os = this.observers.slice(0);
	                    for (var i = 0, len = os.length; i < len; i++) {
	                        os[i].onNext(value);
	                    }
	                }
	            },
	            /**
	             * Unsubscribe all observers and release resources.
	             */
	            dispose: function () {
	                this.isDisposed = true;
	                this.observers = null;
	            }
	        });
	
	        /**
	         * Creates a subject from the specified observer and observable.
	         * @param {Observer} observer The observer used to send messages to the subject.
	         * @param {Observable} observable The observable used to subscribe to messages sent from the subject.
	         * @returns {Subject} Subject implemented using the given observer and observable.
	         */
	        Subject.create = function (observer, observable) {
	            return new AnonymousSubject(observer, observable);
	        };
	
	        return Subject;
	    }(Observable));
	
	  /**
	   *  Represents the result of an asynchronous operation.
	   *  The last value before the OnCompleted notification, or the error received through OnError, is sent to all subscribed observers.
	   */
	  var AsyncSubject = Rx.AsyncSubject = (function (__super__) {
	
	    function subscribe(observer) {
	      checkDisposed.call(this);
	
	      if (!this.isStopped) {
	        this.observers.push(observer);
	        return new InnerSubscription(this, observer);
	      }
	
	      var ex = this.exception,
	        hv = this.hasValue,
	        v = this.value;
	
	      if (ex) {
	        observer.onError(ex);
	      } else if (hv) {
	        observer.onNext(v);
	        observer.onCompleted();
	      } else {
	        observer.onCompleted();
	      }
	
	      return disposableEmpty;
	    }
	
	    inherits(AsyncSubject, __super__);
	
	    /**
	     * Creates a subject that can only receive one value and that value is cached for all future observations.
	     * @constructor
	     */
	    function AsyncSubject() {
	      __super__.call(this, subscribe);
	
	      this.isDisposed = false;
	      this.isStopped = false;
	      this.value = null;
	      this.hasValue = false;
	      this.observers = [];
	      this.exception = null;
	    }
	
	    addProperties(AsyncSubject.prototype, Observer, {
	      /**
	       * Indicates whether the subject has observers subscribed to it.
	       * @returns {Boolean} Indicates whether the subject has observers subscribed to it.
	       */
	      hasObservers: function () {
	        checkDisposed.call(this);
	        return this.observers.length > 0;
	      },
	      /**
	       * Notifies all subscribed observers about the end of the sequence, also causing the last received value to be sent out (if any).
	       */
	      onCompleted: function () {
	        var o, i, len;
	        checkDisposed.call(this);
	        if (!this.isStopped) {
	          this.isStopped = true;
	          var os = this.observers.slice(0),
	            v = this.value,
	            hv = this.hasValue;
	
	          if (hv) {
	            for (i = 0, len = os.length; i < len; i++) {
	              o = os[i];
	              o.onNext(v);
	              o.onCompleted();
	            }
	          } else {
	            for (i = 0, len = os.length; i < len; i++) {
	              os[i].onCompleted();
	            }
	          }
	
	          this.observers = [];
	        }
	      },
	      /**
	       * Notifies all subscribed observers about the error.
	       * @param {Mixed} error The Error to send to all observers.
	       */
	      onError: function (error) {
	        checkDisposed.call(this);
	        if (!this.isStopped) {
	          var os = this.observers.slice(0);
	          this.isStopped = true;
	          this.exception = error;
	
	          for (var i = 0, len = os.length; i < len; i++) {
	            os[i].onError(error);
	          }
	
	          this.observers = [];
	        }
	      },
	      /**
	       * Sends a value to the subject. The last value received before successful termination will be sent to all subscribed and future observers.
	       * @param {Mixed} value The value to store in the subject.
	       */
	      onNext: function (value) {
	        checkDisposed.call(this);
	        if (this.isStopped) { return; }
	        this.value = value;
	        this.hasValue = true;
	      },
	      /**
	       * Unsubscribe all observers and release resources.
	       */
	      dispose: function () {
	        this.isDisposed = true;
	        this.observers = null;
	        this.exception = null;
	        this.value = null;
	      }
	    });
	
	    return AsyncSubject;
	  }(Observable));
	
	  var AnonymousSubject = Rx.AnonymousSubject = (function (__super__) {
	    inherits(AnonymousSubject, __super__);
	
	    function AnonymousSubject(observer, observable) {
	      this.observer = observer;
	      this.observable = observable;
	      __super__.call(this, this.observable.subscribe.bind(this.observable));
	    }
	
	    addProperties(AnonymousSubject.prototype, Observer, {
	      onCompleted: function () {
	        this.observer.onCompleted();
	      },
	      onError: function (exception) {
	        this.observer.onError(exception);
	      },
	      onNext: function (value) {
	        this.observer.onNext(value);
	      }
	    });
	
	    return AnonymousSubject;
	  }(Observable));
	
	    if (true) {
	        root.Rx = Rx;
	
	        !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	            return Rx;
	        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (freeExports && freeModule) {
	        // in Node.js or RingoJS
	        if (moduleExports) {
	            (freeModule.exports = Rx).Rx = Rx;
	        } else {
	          freeExports.Rx = Rx;
	        }
	    } else {
	        // in a browser or Rhino
	        root.Rx = Rx;
	    }
	
	}.call(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)(module), (function() { return this; }()), __webpack_require__(22)))

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var
	    _ = __webpack_require__(1).lodash,
	    Rx = __webpack_require__(18),
	    adapter = __webpack_require__(19),
	    engine = __webpack_require__(14),
	    parser = engine.parser,
	    renderer = engine.render,
	    diff = engine.diff,
	    dispatcher = __webpack_require__(15);
	
	__webpack_require__(20);
	__webpack_require__(21);
	
	var emptyTuneName = "Untitled Tune";
	
	module.exports = function(ractive, context) {
	
	    renderer.initialize();
	
	    var lines = [];
	
	    ractive.set("title", emptyTuneName);
	
	    //incorporates an elements index into its object
	    function addIndexToObject(element, index) {
	        return {
	            raw: element,
	            i: index
	        };
	    }
	
	    //composition root
	    var mainObservable = Rx.Observable.fromRactive(ractive, 'inputValue')
	        .throttle(25)
	        .selectMany(diff)
	        .map(parser)
	        .map(renderer.onNext)
	        .subscribe(function(a) {
	            if (!a.error) {
	                ractive.set("errors", "");
	            } else {
	                ractive.set("errors", a.error_details.message);
	            }
	            //if(a.action != "del")console.log(a.parsed); 
	            /*if(a.type_class === "data" && a.parsed[0].type === "title") {
	                    if(!(a.action === "del") && a.parsed[0].data.length > 0) {
	                        ractive.set("title", a.parsed[0].data);
	                    } else {
	                        ractive.set("title", emptyTuneName);
	                    }                
	                }  */
	        });
	
	    var oldStart = -1, oldStop = -1;
	    function checkTextAreaSelection() {
	        var field = document.getElementById("abc"),
	            start = field.value.substr(0, field.selectionStart).split("\n").length,
	            stop = field.value.substr(0, field.selectionEnd).split("\n").length;
	
	        if(start != oldStart || stop != oldStop) {
	            dispatcher.send({
	                type: "selection-changed",
	                start: start,
	                stop: stop
	            });
	            oldStart = start;
	            oldStop = stop;
	        }
	    }
	
	    //handle events
	    ractive.on({
	        "navigate_back": function(event) {
	            window.location.hash = "";
	        },
	        "editor_mouseup": function() {
	            var field = document.getElementById("abc");
	            checkTextAreaSelection();
	        },
	        "editor_keyup": function() {
	            var field = document.getElementById("abc");
	            if (field.scrollHeight > field.clientHeight) {
	                console.log("grow");
	                field.style.height = field.scrollHeight + "px";
	            }
	
	            checkTextAreaSelection();
	        },
	        "app_mouseup": function() {
	            checkTextAreaSelection();
	        }
	    });
	
	};

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var $ = __webpack_require__(1).jquery;
	
	var
	    Rx = __webpack_require__(18),
	    adapter = __webpack_require__(19),
	    fade = __webpack_require__(20),
	    fly = __webpack_require__(21),
	    toastr = __webpack_require__(1).toastr;
	
	
	module.exports = function(ractive, context) {
	
	    ractive.set("loggedIn", false);
	
	    ractive.on('new_tune', function(event) {
	        window.location.hash = "editor";
	    });
	
	    $.getJSON("/api/tunes")
	        .then(function(data) {
	            ractive.set("tuneNames", data);
	        });
	
	    $.getJSON("/api/user/current")
	        .then(function(data) {
	            console.log("CURRENT USER", data);
	            ractive.set("loggedIn", true);
	            ractive.set("user", data);
	        });
	
	    ractive.set("filterTuneNames", function(tuneNames, filter) {
	        if (filter.length <= 0) return tuneNames;
	        return tuneNames.filter(function(a) {
	            return a.name.toLowerCase().lastIndexOf(filter.toLowerCase(), 0) === 0;
	        });
	    });
	
	    // toastr.success("YAY");
	};

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = {
		parser: __webpack_require__(23),
		render: __webpack_require__(24),
		diff: __webpack_require__(25)
	};

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	var Rx = __webpack_require__(1).Rx,
		_ = __webpack_require__(1).lodash;
	
	var subscribers = [];
	
	function send(data) {
		//console.log("DISPATCH", data);
		_(subscribers).forEach(function(sub) {
			sub(data);
		});
	}
	
	function subscribe(func) {
		subscribers.push(func);
	}
	
	module.exports = {
		subscribe: subscribe,
		send: send
	};

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	module.exports={"v":1,"t":[{"t":7,"e":"div","a":{"class":"header row"},"t1":"fade","v":{"mouseup":"app_mouseup"},"f":[{"t":7,"e":"div","a":{"class":"back-button"},"v":{"click":"navigate_back"},"f":[{"t":7,"e":"p","f":[{"t":7,"e":"i","a":{"class":"fa fa-arrow-left"}}]}]}," ",{"t":7,"e":"div","a":{"class":"central-menu"},"f":[{"t":7,"e":"h3","a":{"class":"tune-title"},"f":[{"t":2,"r":"title"}]}," ",{"t":7,"e":"br"}," ",{"t":7,"e":"div","a":{"class":"flat-button"},"f":[{"t":7,"e":"p","f":["File"]}]}," ",{"t":7,"e":"div","a":{"class":"flat-button"},"f":[{"t":7,"e":"p","f":["Edit"]}]}]}," ",{"t":7,"e":"div","a":{"class":"user-box"},"f":[{"t":4,"n":50,"x":{"r":["loggedIn"],"s":"_0===false"},"f":[{"t":7,"e":"a","a":{"href":"/auth/google","class":"google-button"},"f":[{"t":7,"e":"span","a":{"class":"fa fa-google-plus"}}," Google"]}]},{"t":4,"n":51,"f":[{"t":7,"e":"span","f":["Hi ",{"t":2,"r":"user.name.givenName"}]}," ",{"t":7,"e":"a","a":{"href":"/logout"},"f":["Log out"]}],"x":{"r":["loggedIn"],"s":"_0===false"}}]}]}," ",{"t":7,"e":"div","a":{"class":"row toolbar"},"v":{"mouseup":"app_mouseup"},"f":[{"t":2,"r":"errors"}]}," ",{"t":7,"e":"div","a":{"class":"row editor"},"t1":"fade","v":{"mouseup":"app_mouseup"},"f":[{"t":7,"e":"div","a":{"class":"column third","id":"abc-container"},"f":[{"t":7,"e":"textarea","a":{"id":"abc","value":[{"t":2,"r":"inputValue"}],"placeholder":"Start typing a tune..","spellcheck":"false"},"v":{"keyup":"editor_keyup","mouseup":"editor_mouseup","paste":"editor_paste"}}]}," ",{"t":7,"e":"div","a":{"class":"column two-thirds","id":"canvas"},"f":[]}]}]};

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	module.exports={"v":1,"t":[{"t":7,"e":"div","a":{"class":"header row coloured"},"t1":"fade","f":[{"t":7,"e":"div","a":{"class":"central-menu"},"f":[{"t":7,"e":"h1","f":["Welcome to WebABC"]},{"t":7,"e":"small","f":["Version 0.0.1"]}]}," "]}," ",{"t":7,"e":"div","a":{"class":"row editor"},"f":[{"t":7,"e":"div","a":{"class":"column quarter right-divide"},"t1":{"n":"fade","a":[{"delay":100}]},"f":[{"t":7,"e":"div","a":{"class":"text-area-padding"},"f":[{"t":7,"e":"h3","f":["Recent Tunes"]}," ",{"t":7,"e":"div","a":{"id":"search-box"},"f":[{"t":7,"e":"i","a":{"class":"fa fa-search"}}," ",{"t":7,"e":"input","v":{"change":"updated_search"},"a":{"type":"text","value":[{"t":2,"r":"search_filter"}]}}]}," ",{"t":7,"e":"ul","a":{"class":"item-list"},"f":[{"t":4,"n":52,"x":{"r":["filterTuneNames","tuneNames","search_filter"],"s":"_0(_1,_2)"},"f":[{"t":7,"e":"li","v":{"click":"new_tune"},"f":[{"t":2,"r":"name"},{"t":7,"e":"br"},{"t":7,"e":"small","f":["12/09/2014 - Reel - Gm"]}]}]}]}]}]}," ",{"t":7,"e":"div","a":{"class":"column three-quarters","id":"task-pane"},"t1":{"n":"fade","a":[{"delay":200}]},"f":[{"t":7,"e":"div","a":{"class":"tile-button-container"},"f":[{"t":7,"e":"div","a":{"class":"tile-button"},"v":{"click":"new_tune"},"f":[{"t":7,"e":"h4","f":["+ New Tune"]}]}]}]}]}]};

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	
	    Rx = __webpack_require__(1).Rx;
	
	    'use strict';
	    
	    //create RxObserveables from ractive observe
	    Rx.Observable.fromRactive = function(ractive, name) {
	        return Rx.Observable.create(function(observer) {
	            ractive.observe(name, function(newValue, oldValue) {
	                observer.onNext({ newValue: newValue, oldValue: oldValue});
	            });
	        });       
	    }
	    
	    //create RxObserveables from lexer
	    Rx.Observable.fromJsLex = function(lexer, inputValue) {
	        return Rx.Observable.create(function(observer) {
	            lexer.lex(inputValue, function(a) { observer.onNext(a); });
	        });       
	    }    
	    module.exports = Rx;


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	/*
	
		ractive-adaptors-rxjs
		======================
	
		Version 0.1.0.
	
		RxJS adaptor for Ractive
	
		==========================
	
		Troubleshooting: If you're using a module system in your app (AMD or
		something more nodey) then you may need to change the paths below,
		where it says `require( 'ractive' )` or `define([ 'ractive' ]...)`.
	
		==========================
	
		Usage: Include this file on your page below Ractive, e.g:
	
		    <script src='lib/ractive.js'></script>
		    <script src='lib/rxjs.js'></script>
		    <script src='lib/ractive-adaptors-rxjs.js'></script>
	
		Or, if you're using a module loader, require this module:
	
		    // requiring the plugin will 'activate' it - no need to use
		    // the return value
		    require( 'ractive-adaptors-rxjs' );
	
		Then, tell Ractive to use the `RxJS` adaptor:
	
			ractive = new Ractive({
				el: 'body',
				template: myTemplate,
				adapt: 'RxJS',
				data: {
					foo: someReactiveProperty
				}
			});
	
	*/
	
	(function ( global, factory ) {
	
		factory( __webpack_require__( 1).Ractive, __webpack_require__(1).Rx );
		
	
	}( typeof window !== 'undefined' ? window : this, function ( Ractive, Rx ) {
	
		'use strict';
	
		var RxWrapper = function ( ractive, observable, keypath ) {
			var self = this;
	
			this.ractive = ractive;
			this.value = observable;
			this.keypath = keypath;
	
			this.dispose = observable.subscribe( function ( value ) {
				if ( self.updating ) {
					return;
				}
	
				self._value = value;
	
				self.updating = true;
				ractive.set( keypath, value );
				self.updating = false;
			});
		};
	
		RxWrapper.prototype = {
			get: function () {
				return this._value;
			},
			teardown: function () {
				this.dispose();
			},
			reset: function ( value ) {
				if ( this.updating ) {
					return;
				}
	
				if ( value instanceof Rx.Observable ) {
					return false;
				}
	
				this.updating = true;
				// TODO how do you set the value of a Rx.Observable?!
				this.updating = false;
			}
		};
	
		Ractive.adaptors.RxJS = {
			filter: function ( object ) {
				return object instanceof Rx.Observable;
			},
			wrap: function ( ractive, observable, keypath ) {
				return new RxWrapper( ractive, observable, keypath );
			}
		};
	
	}));

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	
		ractive-transitions-fade
		========================
	
		Version 0.1.2.
	
		This plugin does exactly what it says on the tin - it fades elements
		in and out, using CSS transitions. You can control the following
		properties: `duration`, `delay` and `easing` (which must be a valid
		CSS transition timing function, and defaults to `linear`).
	
		The `duration` property is in milliseconds, and defaults to 300 (you
		can also use `fast` or `slow` instead of a millisecond value, which
		equate to 200 and 600 respectively). As a shorthand, you can use
		`intro='fade:500'` instead of `intro='fade:{"duration":500}'` - this
		applies to many other transition plugins as well.
	
		If an element has an opacity other than 1 (whether directly, because
		of an inline style, or indirectly because of a CSS rule), it will be
		respected. You can override the target opacity of an intro fade by
		specifying a `to` property between 0 and 1.
	
		==========================
	
		Troubleshooting: If you're using a module system in your app (AMD or
		something more nodey) then you may need to change the paths below,
		where it says `require( 'Ractive' )` or `define([ 'Ractive' ]...)`.
	
		==========================
	
		Usage: Include this file on your page below Ractive, e.g:
	
		    <script src='lib/ractive.js'></script>
		    <script src='lib/ractive-transitions-fade.js'></script>
	
		Or, if you're using a module loader, require this module:
	
		    // requiring the plugin will 'activate' it - no need to use
		    // the return value
		    require( 'ractive-transitions-fade' );
	
		Add a fade transition like so:
	
		    <div intro='fade'>this will fade in</div>
	
	*/
	
	(function ( global, factory ) {
	
		'use strict';
	
		// Common JS (i.e. browserify) environment
		if ( typeof module !== 'undefined' && module.exports && "function" === 'function' ) {
			factory( __webpack_require__( 1 ).Ractive );
		}
	
		// AMD?
		else if ( true ) {
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(6) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}
	
		// browser global
		else if ( global.Ractive ) {
			factory( global.Ractive );
		}
	
		else {
			throw new Error( 'Could not find Ractive! It must be loaded before the ractive-transitions-fade plugin' );
		}
	
	}( typeof window !== 'undefined' ? window : this, function ( Ractive ) {
	
		'use strict';
	
		var fade, defaults;
	
		defaults = {
			delay: 0,
			duration: 300,
			easing: 'linear'
		};
	
		fade = function ( t, params ) {
			var targetOpacity;
	
			params = t.processParams( params, defaults );
	
			if ( t.isIntro ) {
				targetOpacity = t.getStyle( 'opacity' );
				t.setStyle( 'opacity', 0 );
			} else {
				targetOpacity = 0;
			}
	
			t.animateStyle( 'opacity', targetOpacity, params ).then( t.complete );
		};
	
		Ractive.transitions.fade = fade;
	
	}));

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	
		ractive-transitions-fly
		=======================
	
		Version 0.1.3.
	
		This transition uses CSS transforms to 'fly' elements to their
		natural location on the page, fading in from transparent as they go.
		By default, they will fly in from left.
	
		==========================
	
		Troubleshooting: If you're using a module system in your app (AMD or
		something more nodey) then you may need to change the paths below,
		where it says `require( 'ractive' )` or `define([ 'ractive' ]...)`.
	
		==========================
	
		Usage: Include this file on your page below Ractive, e.g:
	
		    <script src='lib/ractive.js'></script>
		    <script src='lib/ractive-transitions-fly.js'></script>
	
		Or, if you're using a module loader, require this module:
	
		    // requiring the plugin will 'activate' it - no need to use
		    // the return value
		    require( 'ractive-transitions-fly' );
	
		You can adjust the following parameters: `x`, `y`, `duration`,
		`delay` and `easing`.
	
	*/
	
	(function ( global, factory ) {
	
		'use strict';
	
		// Common JS (i.e. browserify) environment
		if ( typeof module !== 'undefined' && module.exports && "function" === 'function' ) {
			factory( __webpack_require__( 1 ).Ractive );
		}
	
		// AMD?
		else if ( true ) {
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(6) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}
	
		// browser global
		else if ( global.Ractive ) {
			factory( global.Ractive );
		}
	
		else {
			throw new Error( 'Could not find Ractive! It must be loaded before the ractive-transitions-fly plugin' );
		}
	
	}( typeof window !== 'undefined' ? window : this, function ( Ractive ) {
	
		'use strict';
	
		var fly, addPx, defaults;
	
		defaults = {
			duration: 400,
			easing: 'easeOut',
			opacity: 0,
			x: -500,
			y: 0
		};
	
		addPx = function ( num ) {
			if ( num === 0 || typeof num === 'string' ) {
				return num;
			}
	
			return num + 'px';
		};
	
		fly = function ( t, params ) {
			var x, y, offscreen, target;
	
			params = t.processParams( params, defaults );
	
			x = addPx( params.x );
			y = addPx( params.y );
	
			offscreen = {
				transform: 'translate(' + x + ',' + y + ')',
				opacity: 0
			};
	
			if ( t.isIntro ) {
				// animate to the current style
				target = t.getStyle([ 'opacity', 'transform' ]);
	
				// set offscreen style
				t.setStyle( offscreen );
			} else {
				target = offscreen;
			}
	
			t.animateStyle( target, params ).then( t.complete );
		};
	
		Ractive.transitions.fly = fly;
	
	}));

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	// shim for using process in browser
	
	var process = module.exports = {};
	
	process.nextTick = (function () {
	    var canSetImmediate = typeof window !== 'undefined'
	    && window.setImmediate;
	    var canPost = typeof window !== 'undefined'
	    && window.postMessage && window.addEventListener
	    ;
	
	    if (canSetImmediate) {
	        return function (f) { return window.setImmediate(f) };
	    }
	
	    if (canPost) {
	        var queue = [];
	        window.addEventListener('message', function (ev) {
	            var source = ev.source;
	            if ((source === window || source === null) && ev.data === 'process-tick') {
	                ev.stopPropagation();
	                if (queue.length > 0) {
	                    var fn = queue.shift();
	                    fn();
	                }
	            }
	        }, true);
	
	        return function nextTick(fn) {
	            queue.push(fn);
	            window.postMessage('process-tick', '*');
	        };
	    }
	
	    return function nextTick(fn) {
	        setTimeout(fn, 0);
	    };
	})();
	
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	}
	
	// TODO(shtylman)
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var
	    lexer = __webpack_require__(28),
	    data_tables = __webpack_require__(27),
	    _ = __webpack_require__(1).lodash,
	    enums = __webpack_require__(26),
	
	    cache = {},
	    drawableIndex = 0,
	    decorationstack = [];
	
	function ParserException(message) {
	    this.message = message;
	    this.name = "ParserException";
	}
	
	function parseNote(lexer, parsed) {
	    var newNote = {
	        type: "note",
	        type_class: "drawable",
	        notelength: 1
	    };
	
	    while (lexer[0] && lexer[0].subType === "decoration") {
	        lexer.shift();
	    }
	
	    if (lexer[0].subType == "accidental") {
	        newNote.accidental = lexer.shift().data;
	    }
	
	    if (!lexer[0] || lexer[0].subType !== "letter") {
	        lexer.shift();
	        return new ParserException("Missing note name");
	    }
	
	    if (lexer[0] && lexer[0].subType == "letter") {
	        newNote.note = lexer.shift().data;
	        newNote.pitch = data_tables.notes[newNote.note].pitch;
	        newNote.octave = data_tables.notes[newNote.note].octave;
	        newNote.pos = data_tables.notes[newNote.note].pos;
	    }
	
	    if (lexer[0] && lexer[0].subType == "pitch") {
	        newNote.octave += lexer.shift().data;
	    }
	
	    if (lexer[0] && lexer[0].subType == "length") {
	        newNote.notelength = lexer.shift().data;
	    }
	
	    parsed.weight += newNote.notelength;
	    parsed.symbols.push(newNote);
	}
	
	function parseRest(lexer) {
	    var newRest = {};
	
	    newRest.type_class = lexer[0].subType === "visible" ? "drawable" : "hidden";
	    newRest.type = lexer[0].data === "short" ? "beat_rest" : "bar_rest";
	
	    lexer.shift();
	
	    if (lexer[0] && lexer[0].subType == "length") {
	        newRest.notelength = lexer.shift().data;
	    }
	
	    return newRest;
	}
	
	/**
	 * Parses a group of notes
	 * @param  {Array} The output array for the entire parse process
	 * @param  {Array} The input array of lexed tokens
	 * @param  {String} The name of the type of note group
	 * @param  {String} The type of token that starts the note group
	 * @param  {String} The type of token that ends the note group
	 * @return {Boolean} Returns TRUE if the specified note group was found
	 */
	function noteGroup(parsed, lexed, name, start, stop) {
	    if (lexed[0].type === start) {
	        lexed.shift();
	
	        var groupNotes = [];
	
	        while (lexed.length > 0 && lexed[0].type != stop) {
	            if (lexed[0].type === "note") {
	                groupNotes.push(parseNote(lexed));
	                continue;
	            } else {
	                /*throw new*/
	                groupNotes.push(new ParserException("Only notes are allowed in " + name + "s"));
	                lexed.shift();
	                continue;
	            }
	        }
	
	        parsed.push({
	            type: name,
	            type_class: "drawable",
	            notes: groupNotes
	        });
	
	        lexed.shift();
	        return true;
	    }
	
	    if (lexed[0].type === stop) {
	        parsed.push(new ParserException("Closing " + name + " found before starting it"));
	        lexed.shift();
	        return true;
	    }
	
	    return false;
	}
	
	/**
	 * A recursive decent parser that combines lexed tokens into a meaningful data structure
	 * @param  {Array} An array of lexed tokens
	 * @return {Array} An array of parsed symbols
	 */
	function parse(lexed) {
	
	    var parsed = {
	        symbols: [],
	        weight: 0
	    };
	
	    while (lexed.length > 0) {
	        if (lexed[0].type === "err") {
	            /*throw new*/
	            parsed.symbols.push(new ParserException("Unrecognised sequence: " + lexed[0].data));
	            lexed.shift();
	            continue;
	        }
	
	        if (lexed[0].type_class === "data") {
	            lexed.shift();
	            continue;
	        }
	
	        if (lexed[0].type === "beam") {
	            lexed.shift();
	            continue;
	        }
	
	        if (lexed[0].type === "chord_annotation") {
	            parsed.symbols.push({
	                type_class: "drawable",
	                type: "chord_annotation",
	                text: lexed[0].data
	            });
	            lexed.shift();
	            continue;
	        }
	
	        if (lexed[0].type === "note") {
	            parseNote(lexed, parsed);
	            continue;
	        }
	
	        if (lexed[0].type === "rest") {
	            parsed.symbols.push(parseRest(lexed));
	            parsed.weight += 1;
	            continue;
	        }
	
	        if (lexed[0].type === "space") {
	            parsed.symbols.push({
	                type: "space",
	                type_class: "hidden"
	            });
	            lexed.shift();
	            continue;
	        }
	
	        if (noteGroup(parsed, lexed, "chord", "chord_start", "chord_stop")) continue;
	        if (noteGroup(parsed, lexed, "slur", "slur_start", "slur_stop")) continue;
	        if (noteGroup(parsed, lexed, "grace", "grace_start", "grace_stop")) continue;
	
	        if (lexed[0].type === "barline") {
	            lexed.shift();
	            parsed.symbols.push({
	                type: "barline",
	                type_class: "drawable"
	            });
	            parsed.weight += 1;
	            continue;
	        }
	    }
	
	    return parsed;
	}
	
	module.exports = function(line) {
	
	    if (line.action !== enums.line_actions.move) {
	        try {
	            var lexed = lexer(line.raw);
	
	            if (lexed.length > 0) {
	
	                var parseOutput = parse(lexed)
	                line.parsed = parseOutput.symbols;
	                line.weight = parseOutput.weight;
	
	                if (!(lexed.length === 1 && lexer[0].type_class === "data")) {
	                    line.type_class = enums.line_types.drawable;
	                } else {
	                    line.type_class = enums.line_types.data;
	                }
	            } else {
	                line.parsed = [];
	                line.type_class = enums.line_types.hidden;
	            }
	        } catch(err) {
	            console.log("ERR", err);
	            line.type_class = enums.line_types.hidden;
	            line.error_details = err;
	            line.error = true;
	        }
	
	    }
	
	    return line;
	}

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var
	    _ = __webpack_require__(1).lodash,
	    svg = __webpack_require__(1).svgjs, 
	    enums = __webpack_require__(26),
	    stave_symbols = __webpack_require__(29),
	    add_data_fields = __webpack_require__(30).add,
	    remove_data_fields = __webpack_require__(30).remove,
	    glyphs = __webpack_require__(31),
	    dispatcher = __webpack_require__(15),
	    data_tables = __webpack_require__(27);
	
	var
	    draw,
	    scoreLines,
	    lineHeight = 80,
	    lineWidth = 1024,
	    selectedLine;
	
	var selectionRects = [];
	
	var arrangeGroups = function() {
	    var offset = 1;
	
	    //if (data.title != null) offset = 4;
	
	    for (var i = 0; i < scoreLines.length; i++) {
	        if (scoreLines[i] === undefined) continue;
	
	        if (scoreLines[i] != 0) {
	            scoreLines[i].move(50, lineHeight * offset);
	            offset += 1;
	        }
	    }
	}
	 
	var handler = [];
	
	handler[(enums.line_actions.add << 2) + enums.line_types.drawable] = function(a) {
	
	    if (scoreLines[a.i] === undefined) {
	        scoreLines[a.i] = draw.group();
	    } else {
	        scoreLines.splice(a.i, 0, draw.group());
	    }
	
	    var groupDraw = scoreLines[a.i];
	
	    for (var i = 0; i < 5; i++) {
	        groupDraw.rect(lineWidth, 1).move(0, i * 8).attr({
	            fill: 'black'
	        });
	    }
	
	    groupDraw.rect(1, 32).move(0, 0).attr({
	        fill: 'black'
	    });
	
	    groupDraw.rect(1, 32).move(1024, 0).attr({
	        fill: 'black'
	    });
	
	    if(a.i === selectedLine) {
	        selectionRects.push(groupDraw.rect(4, 34).move(-8, 0).attr({ fill: '#223378' }))
	    }
	
	    groupDraw.select = function() {
	        selectionRects.push(groupDraw.rect(4, 34).move(-8, 0).attr({ fill: '#223378' }));    
	    }
	
	    stave_symbols.treble_clef(groupDraw);
	
	    var pos_mod = lineWidth/(a.weight+1);
	
	    for (var j = 0, totalOffset = 1; j < a.parsed.length; j++) {
	
	        var currentSymbol = a.parsed[j];
	
	        if(!_(Object.keys(stave_symbols)).contains(currentSymbol.type)) {
	            console.log("Wanted to draw a " + currentSymbol.type + " don't know how");
	            continue;
	        }
	
	        stave_symbols[currentSymbol.type](groupDraw, currentSymbol, pos_mod * totalOffset);
	
	        if(_.isFunction(data_tables.symbol_width[currentSymbol.type])) {
	            totalOffset += data_tables.symbol_width[currentSymbol.type](currentSymbol);
	        } else {
	            totalOffset += data_tables.symbol_width[currentSymbol.type];
	        }
	    }
	};
	
	handler[(enums.line_actions.delete << 2) + enums.line_types.drawable] = function(a) {
	    if (scoreLines[a.i]) scoreLines[a.i].remove();
	    scoreLines[a.i] = undefined;
	};
	
	handler[(enums.line_actions.add << 2) + enums.line_types.data] = function(a) {
	
	    scoreLines[a.i] = 0;
	
	    if (add_data_fields[a.parsed[0].type] === undefined) {
	        console.log("NOT YET IMPLEMENTED");
	        return;
	    }
	
	    add_data_fields[a.parsed[0].type](a);
	};
	
	handler[(enums.line_actions.delete << 2) + enums.line_types.data] = function(a) {
	
	    scoreLines[a.i] = undefined;
	    if (remove_data_fields[a.parsed[0].type] === undefined) {
	        console.log("NOT YET IMPLEMENTED");
	        return;
	    }
	
	    remove_data_fields[a.parsed[0].type](a);
	};
	
	handler[(enums.line_actions.add << 2) + enums.line_types.hidden] = function(a) {
	    scoreLines[a.i] = 0;
	};
	
	handler[(enums.line_actions.delete << 2) + enums.line_types.hidden] = function(a) {
	    scoreLines[a.i] = undefined;
	}
	
	handler[(enums.line_actions.move << 2) + enums.line_types.drawable] =
	    handler[(enums.line_actions.move << 2) + enums.line_types.data] =
	    handler[(enums.line_actions.move << 2) + enums.line_types.hidden] = function(a) {
	        if (a.i < a.j) {
	            scoreLines[a.i] = scoreLines[a.j];
	            scoreLines[a.j] = undefined;
	        }
	        console.log("MOV", scoreLines);
	}
	
	//exported functions
	module.exports = {
	    initialize: function(canvasSelector) {
	        draw = svg('canvas');
	        draw.path(glyphs["flags.u8th"].d).attr({ fill: 'black'}).move(10,10).scale(1);
	        scoreLines = [];
	
	        dispatcher.subscribe(function(a) {
	            if(a.type === "selection-changed") {
	                _(selectionRects).forEach(function(sr) { sr.remove(); });
	                selectedLine = a.start - 1;
	                if(scoreLines[selectedLine]) {
	                    scoreLines[selectedLine].select();
	                }
	            }
	        });
	    },
	
	    onNext: function(a) {
	        if(!a.error) {
	            handler[(a.action << 2) + a.type_class](a);
	            arrangeGroups();
	            scoreLines = scoreLines.slice(0, a.newLength);            
	        }
	        return a;
	    }
	
	};

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	 //select many:
	 var Rx = __webpack_require__(18),
	  enums = __webpack_require__(26);
	
	 module.exports = function(change) {
	
	     return Rx.Observable.create(function(observer) {
	
	         var
	             newSplit = (change.newValue || "").split('\n'),
	             oldSplit = (change.oldValue || "").split('\n'),
	             newLength = Math.max(newSplit.length, oldSplit.length);
	
	         function get_diff(matrix, a1, a2, x, y) {
	             if (x > 0 && y > 0 && a1[y - 1] === a2[x - 1]) {
	                 get_diff(matrix, a1, a2, x - 1, y - 1);
	                 //make_row(x, y, ' ', a1[y-1]);
	                 if (x !== y)
	                     observer.onNext({
	                         action: enums.line_actions.move,
	                         i: x - 1,
	                         j: y - 1,
	                         newLength: newLength
	                     });
	             } else {
	                 if (x > 0 && (y === 0 || matrix[y][x - 1] >= matrix[y - 1][x])) {
	                     get_diff(matrix, a1, a2, x - 1, y);
	                     //make_row(x, '', '+', a2[x-1]);
	                     observer.onNext({
	                         raw: a2[x - 1],
	                         i: x - 1,
	                         action: enums.line_actions.add,
	                         newLength: newLength
	                     });
	                 } else if (y > 0 && (x === 0 || matrix[y][x - 1] < matrix[y - 1][x])) {
	                     get_diff(matrix, a1, a2, x, y - 1);
	                     //make_row('', y, '-', a1[y-1]);
	                     observer.onNext({
	                         raw: a1[y - 1],
	                         i: y - 1,
	                         action: enums.line_actions.delete,
	                         newLength: newLength
	                     });
	                 } else {
	                     return;
	                 }
	             }
	         }
	
	         function diff(a1, a2) {
	             var matrix = new Array(a1.length + 1);
	             var x, y;
	
	             for (y = 0; y < matrix.length; y++) {
	                 matrix[y] = new Array(a2.length + 1);
	
	                 for (x = 0; x < matrix[y].length; x++) {
	                     matrix[y][x] = 0;
	                 }
	             }
	
	             for (y = 1; y < matrix.length; y++) {
	                 for (x = 1; x < matrix[y].length; x++) {
	                     if (a1[y - 1] === a2[x - 1]) {
	                         matrix[y][x] = 1 + matrix[y - 1][x - 1];
	                     } else {
	                         matrix[y][x] = Math.max(matrix[y - 1][x], matrix[y][x - 1]);
	                     }
	                 }
	             }
	
	             get_diff(matrix, a1, a2, x - 1, y - 1);
	         }
	
	         diff(oldSplit, newSplit);
	         //observer.onNext({ action: "endofinput" });
	     });
	 }

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var line_types = {
		"drawable": 0,
		"data": 1,
		"hidden": 2
	};
	
	var line_actions = {
		"delete": 0,
		"add": 1,
		"move": 2
	};
	
	Object.freeze(line_types);
	Object.freeze(line_actions);
	
	module.exports = {
		line_types: line_types,
		line_actions: line_actions
	};

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var data_tables = {};
	
	data_tables["notes"] = {
	    "C": {
	        octave: 4,
	        pitch: 60,
	        pos: 0
	    },
	    "D": {
	        octave: 4,
	        pitch: 62,
	        pos: 1
	    },
	    "E": {
	        octave: 4,
	        pitch: 64,
	        pos: 2
	    },
	    "F": {
	        octave: 4,
	        pitch: 65,
	        pos: 3
	    },
	    "G": {
	        octave: 4,
	        pitch: 67,
	        pos: 4
	    },
	    "A": {
	        octave: 4,
	        pitch: 69,
	        pos: 5
	    },
	    "B": {
	        octave: 4,
	        pitch: 71,
	        pos: 6
	    },
	    "c": {
	        octave: 5,
	        pitch: 60,
	        pos: 7
	    },
	    "d": {
	        octave: 5,
	        pitch: 62,
	        pos: 8
	    },
	    "e": {
	        octave: 5,
	        pitch: 64,
	        pos: 9
	    },
	    "f": {
	        octave: 5,
	        pitch: 65,
	        pos: 10
	    },
	    "g": {
	        octave: 5,
	        pitch: 67,
	        pos: 11
	    },
	    "a": {
	        octave: 5,
	        pitch: 69,
	        pos: 12
	    },
	    "b": {
	        octave: 5,
	        pitch: 71,
	        pos: 13
	    },
	};
	
	data_tables.symbol_width = {
	    "note": function(note) {
	        return note.notelength;
	    },
	    "rest": 1,
	    "beat_rest": 1,
	    "barline": 1
	};
	
	module.exports = data_tables;

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var
	    _ = __webpack_require__(1).lodash,
	    Lexer = __webpack_require__(1).lex;
	
	//////////////////////
	// HELPER FUNCTIONS //
	//////////////////////
	var simpleType = function(name) {
	    return function() {
	        return {
	            type: name
	        };
	    }
	}
	
	var charCountInString = function(string, character) {
	    return string.split(character).length - 1;
	}
	
	var addSimpleStringInformationField = function(spec, key, type) {
	    spec.start[key + ": *([^\n]*)\n?"] = function(data) {
	        return {
	            type_class: "data",
	            type: type,
	            data: data
	        }
	    }
	}
	
	
	////////////////////////////////
	//            LEXER           //
	////////////////////////////////
	
	var lexer = new Lexer;
	
	///////////
	// NOTES //
	///////////
	lexer.addRule(/([A-Ga-g])/, function(note) {
	    return {
	        type: "note",
	        subType: "letter",
	        data: note
	    }
	});
	
	///////////
	// RESTS //
	///////////
	lexer.addRule(/z/, function() {
	    return {
	        type: "rest",
	        subType: "visible",
	        data: "short"
	    }
	}).addRule(/x/, function() {
	    return {
	        type: "rest",
	        subType: "invisible",
	        data: "short"
	    }
	}).addRule(/Z/, function() {
	    return {
	        type: "rest",
	        subType: "visible",
	        data: "long"
	    }
	}).addRule(/X/, function() {
	    return {
	        type: "rest",
	        subType: "invisible",
	        data: "long"
	    }
	});
	
	///////////////////////////////
	// NOTE AND REST DECORATIONS //
	///////////////////////////////
	lexer.addRule(/([0-9]+)\/?([0-9]+)?/, function(all, notelength, notedenom) {
	    return {
	        type: "note",
	        subType: "length",
	        data: notedenom && notedenom.length > 0 ? parseFloat(notelength) / parseFloat(notedenom) : parseInt(notelength),
	    }
	}).addRule(/([',]+)/, function(pitchModifier) {
	    return {
	        type: "note",
	        subType: "pitch",
	        data: charCountInString(pitchModifier, "'") - charCountInString(pitchModifier, ",")
	    }
	}).addRule(/(_|\^|=|__|\^\^)/, function(accidental) {
	    return {
	        type: "note",
	        subType: "accidental",
	        data: accidental
	    }
	}).addRule(/"([^"]+)"/, function(data) {
	    return {
	        type: "chord_annotation",
	        data: data
	    }
	}).addRule(/!([^!]+)!/, function(data) {
	    return {
	        type: "decoration",
	        data: data
	    }
	});
	
	///////////////
	// BAR LINES //
	///////////////
	lexer.addRule(/\|/, function() {
	    return {
	        type: "barline"
	    }
	}).addRule(/\|\]/, function() {
	    return {
	        type: "barline"
	    }
	}).addRule(/\|\|/, function() {
	    return {
	        type: "barline"
	    }
	}).addRule(/\[\|/, function() {
	    return {
	        type: "barline"
	    }
	}).addRule(/:\|/, function() {
	    return {
	        type: "barline"
	    }
	}).addRule(/\|:/, function() {
	    return {
	        type: "barline"
	    }
	}).addRule(/::/, function() {
	    return {
	        type: "barline"
	    }
	});
	
	/////////////////
	// NOTE GROUPS //
	/////////////////
	lexer.addRule(/\[/, function() {
	    return {
	        type: "chord_start"
	    }
	}).addRule(/\]/, function() {
	    return {
	        type: "chord_stop"
	    }
	
	}).addRule(/{/, function() {
	    return {
	        type: "grace_start"
	    }
	}).addRule(/}/, function() {
	    return {
	        type: "grace_stop"
	    }
	}).addRule(/\(/, function() {
	    return {
	        type: "slur_start"
	    }
	}).addRule(/\)/, function() {
	    return {
	        type: "slur_stop"
	    }
	});
	
	
	
	///////////
	// OTHER //
	///////////
	lexer.addRule(/ /, function() {
	    return {
	        type: "space"
	    }
	}).addRule(/`/, function() {
	    return {
	        type: "beam"
	    }
	});
	
	module.exports = function(input) {
	    lexer.setInput(input);
	    var output = [];
	    for(var i=0, data = lexer.lex(); data != undefined; data = lexer.lex()) {
	        output[i] = data;
	        i++;
	    }
	    return output;
	};

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var drawing_functions = {},
	    randomColor = __webpack_require__(32),
	    glyphs = __webpack_require__(31),
	    _ = __webpack_require__(1).lodash;
	
	drawing_functions.note = function(line, currentNote, totalOffset, force_down_stem) {
	
	    var notedot = null;
	
	    var noteGroup = line.group();
	
	    var color = '#000';
	
	    if(currentNote.notelength < 4) {
	        //notedot = noteGroup.ellipse(10, 8).attr({
	        //    fill: color
	        //});
	        notedot = noteGroup.path(glyphs["noteheads.quarter"].d).attr({ fill: 'black'}).move(0,4);
	    } else if (currentNote.notelength < 8){
	        notedot = noteGroup.path(glyphs["noteheads.half"].d).attr({ fill: 'black'}).move(0,4);
	    } else {
	        notedot = noteGroup.path(glyphs["noteheads.whole"].d).attr({ fill: 'black'}).move(0,4);
	    }
	
	    if(currentNote.notelength < 8) {
	        if (currentNote.pos > 5 || force_down_stem === 1) {
	            noteGroup.line(0, 8, 0, 34).stroke({
	                width: 1,
	                color: color
	            });
	            if(currentNote.notelength == 1) noteGroup.path(glyphs["flags.u8th"].d).attr({ fill: 'black'}).scale(1.2, -0.9).move(0,-38);
	        } else {
	            noteGroup.line(0, 4.5, 0, -24).stroke({
	                width: 1,
	                color: color
	            });
	            notedot.move(-10, 0);
	            if(currentNote.notelength == 1) noteGroup.path(glyphs["flags.u8th"].d).attr({ fill: 'black'}).move(0,-24).scale(1);
	        }
	    }
	
	    noteGroup.move(totalOffset, 36 - (currentNote.pos * 4));
	};
	
	drawing_functions.barline = function(line, currentSymbol, totalOffset) {
	    line.rect(1, 32).move(totalOffset, 0).attr({
	        fill: 'black'
	    });
	};
	
	drawing_functions.space = _.noop;
	
	drawing_functions.beat_rest = function(line, currentSymbol, totalOffset) {
	    line.path(glyphs["rests.quarter"].d).attr({ fill: 'black'}).move(totalOffset,6);
	}
	
	drawing_functions.treble_clef = function(line) {
	    line.path(glyphs["clefs.G"].d).attr({ fill: 'black'}).move(8,-12);
	}
	
	module.exports = drawing_functions;

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var data = {};
	
	var informationFieldFunctions = {
	    "title": function(a, draw) {
	        if (data.title) data.title.remove();
	        data.title = draw.text(a.parsed[0].data).font({
	            family: 'Georgia',
	            size: 32,
	            anchor: 'middle',
	            leading: '1.5em'
	        }).move(400, 0);
	    },
	    "rhythm": function(a, draw) {
	        if (data.rhythm) data.rhythm.remove();
	        data.rhythm = draw.text(a.parsed[0].data).font({
	            family: 'Georgia',
	            size: 16,
	            anchor: 'middle',
	            leading: '1.5em'
	        }).move(20, 60);
	    }
	}
	
	var delInformationFieldFunctions = {
	    "title": function(a) {
	        data.title.remove();
	        data.title = null;
	    },
	    "rhythm": function(a) {
	        data.rhythm.remove();
	        data.rhythm = null;
	    }
	}
	
	module.exports = {
	    add: informationFieldFunctions,
	    remove: delInformationFieldFunctions
	};

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = {
	    "0": {
	        "w": 10.78,
	        "h": 14.959,
	        "d": "M4.83,-14.97c0.33,-0.03,1.11,0,1.47,0.06c1.68,0.36,2.97,1.59,3.78,3.6c1.2,2.97,0.81,6.96,-0.9,9.27c-0.78,1.08,-1.71,1.71,-2.91,1.95c-0.45,0.09,-1.32,0.09,-1.77,0c-0.81,-0.18,-1.47,-0.51,-2.07,-1.02c-2.34,-2.07,-3.15,-6.72,-1.74,-10.2c0.87,-2.16,2.28,-3.42,4.14,-3.66zm1.11,0.87c-0.21,-0.06,-0.69,-0.09,-0.87,-0.06c-0.54,0.12,-0.87,0.42,-1.17,0.99c-0.36,0.66,-0.51,1.56,-0.6,3c-0.03,0.75,-0.03,4.59,0,5.31c0.09,1.5,0.27,2.4,0.6,3.06c0.24,0.48,0.57,0.78,0.96,0.9c0.27,0.09,0.78,0.09,1.05,0c0.39,-0.12,0.72,-0.42,0.96,-0.9c0.33,-0.66,0.51,-1.56,0.6,-3.06c0.03,-0.72,0.03,-4.56,0,-5.31c-0.09,-1.47,-0.27,-2.37,-0.6,-3.03c-0.24,-0.48,-0.54,-0.78,-0.93,-0.9z"
	    },
	    "1": {
	        "w": 8.94,
	        "h": 15.058,
	        "d": "M3.3,-15.06c0.06,-0.06,0.21,-0.03,0.66,0.15c0.81,0.39,1.08,0.39,1.83,0.03c0.21,-0.09,0.39,-0.15,0.42,-0.15c0.12,0,0.21,0.09,0.27,0.21c0.06,0.12,0.06,0.33,0.06,5.94c0,3.93,0,5.85,0.03,6.03c0.06,0.36,0.15,0.69,0.27,0.96c0.36,0.75,0.93,1.17,1.68,1.26c0.3,0.03,0.39,0.09,0.39,0.3c0,0.15,-0.03,0.18,-0.09,0.24c-0.06,0.06,-0.09,0.06,-0.48,0.06c-0.42,0,-0.69,-0.03,-2.1,-0.24c-0.9,-0.15,-1.77,-0.15,-2.67,0c-1.41,0.21,-1.68,0.24,-2.1,0.24c-0.39,0,-0.42,0,-0.48,-0.06c-0.06,-0.06,-0.06,-0.09,-0.06,-0.24c0,-0.21,0.06,-0.27,0.36,-0.3c0.75,-0.09,1.32,-0.51,1.68,-1.26c0.12,-0.27,0.21,-0.6,0.27,-0.96c0.03,-0.18,0.03,-1.59,0.03,-4.29c0,-3.87,0,-4.05,-0.06,-4.14c-0.09,-0.15,-0.18,-0.24,-0.39,-0.24c-0.12,0,-0.15,0.03,-0.21,0.06c-0.03,0.06,-0.45,0.99,-0.96,2.13c-0.48,1.14,-0.9,2.1,-0.93,2.16c-0.06,0.15,-0.21,0.24,-0.33,0.24c-0.24,0,-0.42,-0.18,-0.42,-0.39c0,-0.06,3.27,-7.62,3.33,-7.74z"
	    },
	    "2": {
	        "w": 10.764,
	        "h": 14.993,
	        "d": "M4.23,-14.97c0.57,-0.06,1.68,0,2.34,0.18c0.69,0.18,1.5,0.54,2.01,0.9c1.35,0.96,1.95,2.25,1.77,3.81c-0.15,1.35,-0.66,2.34,-1.68,3.15c-0.6,0.48,-1.44,0.93,-3.12,1.65c-1.32,0.57,-1.8,0.81,-2.37,1.14c-0.57,0.33,-0.57,0.33,-0.24,0.27c0.39,-0.09,1.26,-0.09,1.68,0c0.72,0.15,1.41,0.45,2.1,0.9c0.99,0.63,1.86,0.87,2.55,0.75c0.24,-0.06,0.42,-0.15,0.57,-0.3c0.12,-0.09,0.3,-0.42,0.3,-0.51c0,-0.09,0.12,-0.21,0.24,-0.24c0.18,-0.03,0.39,0.12,0.39,0.3c0,0.12,-0.15,0.57,-0.3,0.87c-0.54,1.02,-1.56,1.74,-2.79,2.01c-0.42,0.09,-1.23,0.09,-1.62,0.03c-0.81,-0.18,-1.32,-0.45,-2.01,-1.11c-0.45,-0.45,-0.63,-0.57,-0.96,-0.69c-0.84,-0.27,-1.89,0.12,-2.25,0.9c-0.12,0.21,-0.21,0.54,-0.21,0.72c0,0.12,-0.12,0.21,-0.27,0.24c-0.15,0,-0.27,-0.03,-0.33,-0.15c-0.09,-0.21,0.09,-1.08,0.33,-1.71c0.24,-0.66,0.66,-1.26,1.29,-1.89c0.45,-0.45,0.9,-0.81,1.92,-1.56c1.29,-0.93,1.89,-1.44,2.34,-1.98c0.87,-1.05,1.26,-2.19,1.2,-3.63c-0.06,-1.29,-0.39,-2.31,-0.96,-2.91c-0.36,-0.33,-0.72,-0.51,-1.17,-0.54c-0.84,-0.03,-1.53,0.42,-1.59,1.05c-0.03,0.33,0.12,0.6,0.57,1.14c0.45,0.54,0.54,0.87,0.42,1.41c-0.15,0.63,-0.54,1.11,-1.08,1.38c-0.63,0.33,-1.2,0.33,-1.83,0c-0.24,-0.12,-0.33,-0.18,-0.54,-0.39c-0.18,-0.18,-0.27,-0.3,-0.36,-0.51c-0.24,-0.45,-0.27,-0.84,-0.21,-1.38c0.12,-0.75,0.45,-1.41,1.02,-1.98c0.72,-0.72,1.74,-1.17,2.85,-1.32z"
	    },
	    "3": {
	        "w": 9.735,
	        "h": 14.967,
	        "d": "M3.78,-14.97c0.3,-0.03,1.41,0,1.83,0.06c2.22,0.3,3.51,1.32,3.72,2.91c0.03,0.33,0.03,1.26,-0.03,1.65c-0.12,0.84,-0.48,1.47,-1.05,1.77c-0.27,0.15,-0.36,0.24,-0.45,0.39c-0.09,0.21,-0.09,0.36,0,0.57c0.09,0.15,0.18,0.24,0.51,0.39c0.75,0.42,1.23,1.14,1.41,2.13c0.06,0.42,0.06,1.35,0,1.71c-0.18,0.81,-0.48,1.38,-1.02,1.95c-0.75,0.72,-1.8,1.2,-3.18,1.38c-0.42,0.06,-1.56,0.06,-1.95,0c-1.89,-0.33,-3.18,-1.29,-3.51,-2.64c-0.03,-0.12,-0.03,-0.33,-0.03,-0.6c0,-0.36,0,-0.42,0.06,-0.63c0.12,-0.3,0.27,-0.51,0.51,-0.75c0.24,-0.24,0.45,-0.39,0.75,-0.51c0.21,-0.06,0.27,-0.06,0.6,-0.06c0.33,0,0.39,0,0.6,0.06c0.3,0.12,0.51,0.27,0.75,0.51c0.36,0.33,0.57,0.75,0.6,1.2c0,0.21,0,0.27,-0.06,0.42c-0.09,0.18,-0.12,0.24,-0.54,0.54c-0.51,0.36,-0.63,0.54,-0.6,0.87c0.06,0.54,0.54,0.9,1.38,0.99c0.36,0.06,0.72,0.03,0.96,-0.06c0.81,-0.27,1.29,-1.23,1.44,-2.79c0.03,-0.45,0.03,-1.95,-0.03,-2.37c-0.09,-0.75,-0.33,-1.23,-0.75,-1.44c-0.33,-0.18,-0.45,-0.18,-1.98,-0.18c-1.35,0,-1.41,0,-1.5,-0.06c-0.18,-0.12,-0.24,-0.39,-0.12,-0.6c0.12,-0.15,0.15,-0.15,1.68,-0.15c1.5,0,1.62,0,1.89,-0.15c0.18,-0.09,0.42,-0.36,0.54,-0.57c0.18,-0.42,0.27,-0.9,0.3,-1.95c0.03,-1.2,-0.06,-1.8,-0.36,-2.37c-0.24,-0.48,-0.63,-0.81,-1.14,-0.96c-0.3,-0.06,-1.08,-0.06,-1.38,0.03c-0.6,0.15,-0.9,0.42,-0.96,0.84c-0.03,0.3,0.06,0.45,0.63,0.84c0.33,0.24,0.42,0.39,0.45,0.63c0.03,0.72,-0.57,1.5,-1.32,1.65c-1.05,0.27,-2.1,-0.57,-2.1,-1.65c0,-0.45,0.15,-0.96,0.39,-1.38c0.12,-0.21,0.54,-0.63,0.81,-0.81c0.57,-0.42,1.38,-0.69,2.25,-0.81z"
	    },
	    "4": {
	        "w": 11.795,
	        "h": 14.994,
	        "d": "M8.64,-14.94c0.27,-0.09,0.42,-0.12,0.54,-0.03c0.09,0.06,0.15,0.21,0.15,0.3c-0.03,0.06,-1.92,2.31,-4.23,5.04c-2.31,2.73,-4.23,4.98,-4.26,5.01c-0.03,0.06,0.12,0.06,2.55,0.06l2.61,0l0,-2.37c0,-2.19,0.03,-2.37,0.06,-2.46c0.03,-0.06,0.21,-0.18,0.57,-0.42c1.08,-0.72,1.38,-1.08,1.86,-2.16c0.12,-0.3,0.24,-0.54,0.27,-0.57c0.12,-0.12,0.39,-0.06,0.45,0.12c0.06,0.09,0.06,0.57,0.06,3.96l0,3.9l1.08,0c1.05,0,1.11,0,1.2,0.06c0.24,0.15,0.24,0.54,0,0.69c-0.09,0.06,-0.15,0.06,-1.2,0.06l-1.08,0l0,0.33c0,0.57,0.09,1.11,0.3,1.53c0.36,0.75,0.93,1.17,1.68,1.26c0.3,0.03,0.39,0.09,0.39,0.3c0,0.15,-0.03,0.18,-0.09,0.24c-0.06,0.06,-0.09,0.06,-0.48,0.06c-0.42,0,-0.69,-0.03,-2.1,-0.24c-0.9,-0.15,-1.77,-0.15,-2.67,0c-1.41,0.21,-1.68,0.24,-2.1,0.24c-0.39,0,-0.42,0,-0.48,-0.06c-0.06,-0.06,-0.06,-0.09,-0.06,-0.24c0,-0.21,0.06,-0.27,0.36,-0.3c0.75,-0.09,1.32,-0.51,1.68,-1.26c0.21,-0.42,0.3,-0.96,0.3,-1.53l0,-0.33l-2.7,0c-2.91,0,-2.85,0,-3.09,-0.15c-0.18,-0.12,-0.3,-0.39,-0.27,-0.54c0.03,-0.06,0.18,-0.24,0.33,-0.45c0.75,-0.9,1.59,-2.07,2.13,-3.03c0.33,-0.54,0.84,-1.62,1.05,-2.16c0.57,-1.41,0.84,-2.64,0.9,-4.05c0.03,-0.63,0.06,-0.72,0.24,-0.81l0.12,-0.06l0.45,0.12c0.66,0.18,1.02,0.24,1.47,0.27c0.6,0.03,1.23,-0.09,2.01,-0.33z"
	    },
	    "5": {
	        "w": 10.212,
	        "h": 14.997,
	        "d": "M1.02,-14.94c0.12,-0.09,0.03,-0.09,1.08,0.06c2.49,0.36,4.35,0.36,6.96,-0.06c0.57,-0.09,0.66,-0.06,0.81,0.06c0.15,0.18,0.12,0.24,-0.15,0.51c-1.29,1.26,-3.24,2.04,-5.58,2.31c-0.6,0.09,-1.2,0.12,-1.71,0.12c-0.39,0,-0.45,0,-0.57,0.06c-0.09,0.06,-0.15,0.12,-0.21,0.21l-0.06,0.12l0,1.65l0,1.65l0.21,-0.21c0.66,-0.57,1.41,-0.96,2.19,-1.14c0.33,-0.06,1.41,-0.06,1.95,0c2.61,0.36,4.02,1.74,4.26,4.14c0.03,0.45,0.03,1.08,-0.03,1.44c-0.18,1.02,-0.78,2.01,-1.59,2.7c-0.72,0.57,-1.62,1.02,-2.49,1.2c-1.38,0.27,-3.03,0.06,-4.2,-0.54c-1.08,-0.54,-1.71,-1.32,-1.86,-2.28c-0.09,-0.69,0.09,-1.29,0.57,-1.74c0.24,-0.24,0.45,-0.39,0.75,-0.51c0.21,-0.06,0.27,-0.06,0.6,-0.06c0.33,0,0.39,0,0.6,0.06c0.3,0.12,0.51,0.27,0.75,0.51c0.36,0.33,0.57,0.75,0.6,1.2c0,0.21,0,0.27,-0.06,0.42c-0.09,0.18,-0.12,0.24,-0.54,0.54c-0.18,0.12,-0.36,0.3,-0.42,0.33c-0.36,0.42,-0.18,0.99,0.36,1.26c0.51,0.27,1.47,0.36,2.01,0.27c0.93,-0.21,1.47,-1.17,1.65,-2.91c0.06,-0.45,0.06,-1.89,0,-2.31c-0.15,-1.2,-0.51,-2.1,-1.05,-2.55c-0.21,-0.18,-0.54,-0.36,-0.81,-0.39c-0.3,-0.06,-0.84,-0.03,-1.26,0.06c-0.93,0.18,-1.65,0.6,-2.16,1.2c-0.15,0.21,-0.27,0.3,-0.39,0.3c-0.15,0,-0.3,-0.09,-0.36,-0.18c-0.06,-0.09,-0.06,-0.15,-0.06,-3.66c0,-3.39,0,-3.57,0.06,-3.66c0.03,-0.06,0.09,-0.15,0.15,-0.18z"
	    },
	    "6": {
	        "w": 9.956,
	        "h": 14.982,
	        "d": "M4.98,-14.97c0.36,-0.03,1.2,0,1.59,0.06c0.9,0.15,1.68,0.51,2.25,1.05c0.57,0.51,0.87,1.23,0.84,1.98c-0.03,0.51,-0.21,0.9,-0.6,1.26c-0.24,0.24,-0.45,0.39,-0.75,0.51c-0.21,0.06,-0.27,0.06,-0.6,0.06c-0.33,0,-0.39,0,-0.6,-0.06c-0.3,-0.12,-0.51,-0.27,-0.75,-0.51c-0.39,-0.36,-0.57,-0.78,-0.57,-1.26c0,-0.27,0,-0.3,0.09,-0.42c0.03,-0.09,0.18,-0.21,0.3,-0.3c0.12,-0.09,0.3,-0.21,0.39,-0.27c0.09,-0.06,0.21,-0.18,0.27,-0.24c0.06,-0.12,0.09,-0.15,0.09,-0.33c0,-0.18,-0.03,-0.24,-0.09,-0.36c-0.24,-0.39,-0.75,-0.6,-1.38,-0.57c-0.54,0.03,-0.9,0.18,-1.23,0.48c-0.81,0.72,-1.08,2.16,-0.96,5.37l0,0.63l0.3,-0.12c0.78,-0.27,1.29,-0.33,2.1,-0.27c1.47,0.12,2.49,0.54,3.27,1.29c0.48,0.51,0.81,1.11,0.96,1.89c0.06,0.27,0.06,0.42,0.06,0.93c0,0.54,0,0.69,-0.06,0.96c-0.15,0.78,-0.48,1.38,-0.96,1.89c-0.54,0.51,-1.17,0.87,-1.98,1.08c-1.14,0.3,-2.4,0.33,-3.24,0.03c-1.5,-0.48,-2.64,-1.89,-3.27,-4.02c-0.36,-1.23,-0.51,-2.82,-0.42,-4.08c0.3,-3.66,2.28,-6.3,4.95,-6.66zm0.66,7.41c-0.27,-0.09,-0.81,-0.12,-1.08,-0.06c-0.72,0.18,-1.08,0.69,-1.23,1.71c-0.06,0.54,-0.06,3,0,3.54c0.18,1.26,0.72,1.77,1.8,1.74c0.39,-0.03,0.63,-0.09,0.9,-0.27c0.66,-0.42,0.9,-1.32,0.9,-3.24c0,-2.22,-0.36,-3.12,-1.29,-3.42z"
	    },
	    "7": {
	        "w": 10.561,
	        "h": 15.093,
	        "d": "M0.21,-14.97c0.21,-0.06,0.45,0,0.54,0.15c0.06,0.09,0.06,0.15,0.06,0.39c0,0.24,0,0.33,0.06,0.42c0.06,0.12,0.21,0.24,0.27,0.24c0.03,0,0.12,-0.12,0.24,-0.21c0.96,-1.2,2.58,-1.35,3.99,-0.42c0.15,0.12,0.42,0.3,0.54,0.45c0.48,0.39,0.81,0.57,1.29,0.6c0.69,0.03,1.5,-0.3,2.13,-0.87c0.09,-0.09,0.27,-0.3,0.39,-0.45c0.12,-0.15,0.24,-0.27,0.3,-0.3c0.18,-0.06,0.39,0.03,0.51,0.21c0.06,0.18,0.06,0.24,-0.27,0.72c-0.18,0.24,-0.54,0.78,-0.78,1.17c-2.37,3.54,-3.54,6.27,-3.87,9c-0.03,0.33,-0.03,0.66,-0.03,1.26c0,0.9,0,1.08,0.15,1.89c0.06,0.45,0.06,0.48,0.03,0.6c-0.06,0.09,-0.21,0.21,-0.3,0.21c-0.03,0,-0.27,-0.06,-0.54,-0.15c-0.84,-0.27,-1.11,-0.3,-1.65,-0.3c-0.57,0,-0.84,0.03,-1.56,0.27c-0.6,0.18,-0.69,0.21,-0.81,0.15c-0.12,-0.06,-0.21,-0.18,-0.21,-0.3c0,-0.15,0.6,-1.44,1.2,-2.61c1.14,-2.22,2.73,-4.68,5.1,-8.01c0.21,-0.27,0.36,-0.48,0.33,-0.48c0,0,-0.12,0.06,-0.27,0.12c-0.54,0.3,-0.99,0.39,-1.56,0.39c-0.75,0.03,-1.2,-0.18,-1.83,-0.75c-0.99,-0.9,-1.83,-1.17,-2.31,-0.72c-0.18,0.15,-0.36,0.51,-0.45,0.84c-0.06,0.24,-0.06,0.33,-0.09,1.98c0,1.62,-0.03,1.74,-0.06,1.8c-0.15,0.24,-0.54,0.24,-0.69,0c-0.06,-0.09,-0.06,-0.15,-0.06,-3.57c0,-3.42,0,-3.48,0.06,-3.57c0.03,-0.06,0.09,-0.12,0.15,-0.15z"
	    },
	    "8": {
	        "w": 10.926,
	        "h": 14.989,
	        "d": "M4.98,-14.97c0.33,-0.03,1.02,-0.03,1.32,0c1.32,0.12,2.49,0.6,3.21,1.32c0.39,0.39,0.66,0.81,0.78,1.29c0.09,0.36,0.09,1.08,0,1.44c-0.21,0.84,-0.66,1.59,-1.59,2.55l-0.3,0.3l0.27,0.18c1.47,0.93,2.31,2.31,2.25,3.75c-0.03,0.75,-0.24,1.35,-0.63,1.95c-0.45,0.66,-1.02,1.14,-1.83,1.53c-1.8,0.87,-4.2,0.87,-6,0.03c-1.62,-0.78,-2.52,-2.16,-2.46,-3.66c0.06,-0.99,0.54,-1.77,1.8,-2.97c0.54,-0.51,0.54,-0.54,0.48,-0.57c-0.39,-0.27,-0.96,-0.78,-1.2,-1.14c-0.75,-1.11,-0.87,-2.4,-0.3,-3.6c0.69,-1.35,2.25,-2.25,4.2,-2.4zm1.53,0.69c-0.42,-0.09,-1.11,-0.12,-1.38,-0.06c-0.3,0.06,-0.6,0.18,-0.81,0.3c-0.21,0.12,-0.6,0.51,-0.72,0.72c-0.51,0.87,-0.42,1.89,0.21,2.52c0.21,0.21,0.36,0.3,1.95,1.23c0.96,0.54,1.74,0.99,1.77,1.02c0.09,0,0.63,-0.6,0.99,-1.11c0.21,-0.36,0.48,-0.87,0.57,-1.23c0.06,-0.24,0.06,-0.36,0.06,-0.72c0,-0.45,-0.03,-0.66,-0.15,-0.99c-0.39,-0.81,-1.29,-1.44,-2.49,-1.68zm-1.44,8.07l-1.89,-1.08c-0.03,0,-0.18,0.15,-0.39,0.33c-1.2,1.08,-1.65,1.95,-1.59,3c0.09,1.59,1.35,2.85,3.21,3.24c0.33,0.06,0.45,0.06,0.93,0.06c0.63,0,0.81,-0.03,1.29,-0.27c0.9,-0.42,1.47,-1.41,1.41,-2.4c-0.06,-0.66,-0.39,-1.29,-0.9,-1.65c-0.12,-0.09,-1.05,-0.63,-2.07,-1.23z"
	    },
	    "9": {
	        "w": 9.959,
	        "h": 14.986,
	        "d": "M4.23,-14.97c0.42,-0.03,1.29,0,1.62,0.06c0.51,0.12,0.93,0.3,1.38,0.57c1.53,1.02,2.52,3.24,2.73,5.94c0.18,2.55,-0.48,4.98,-1.83,6.57c-1.05,1.26,-2.4,1.89,-3.93,1.83c-1.23,-0.06,-2.31,-0.45,-3.03,-1.14c-0.57,-0.51,-0.87,-1.23,-0.84,-1.98c0.03,-0.51,0.21,-0.9,0.6,-1.26c0.24,-0.24,0.45,-0.39,0.75,-0.51c0.21,-0.06,0.27,-0.06,0.6,-0.06c0.33,0,0.39,0,0.6,0.06c0.3,0.12,0.51,0.27,0.75,0.51c0.39,0.36,0.57,0.78,0.57,1.26c0,0.27,0,0.3,-0.09,0.42c-0.03,0.09,-0.18,0.21,-0.3,0.3c-0.12,0.09,-0.3,0.21,-0.39,0.27c-0.09,0.06,-0.21,0.18,-0.27,0.24c-0.06,0.12,-0.06,0.15,-0.06,0.33c0,0.18,0,0.24,0.06,0.36c0.24,0.39,0.75,0.6,1.38,0.57c0.54,-0.03,0.9,-0.18,1.23,-0.48c0.81,-0.72,1.08,-2.16,0.96,-5.37l0,-0.63l-0.3,0.12c-0.78,0.27,-1.29,0.33,-2.1,0.27c-1.47,-0.12,-2.49,-0.54,-3.27,-1.29c-0.48,-0.51,-0.81,-1.11,-0.96,-1.89c-0.06,-0.27,-0.06,-0.42,-0.06,-0.96c0,-0.51,0,-0.66,0.06,-0.93c0.15,-0.78,0.48,-1.38,0.96,-1.89c0.15,-0.12,0.33,-0.27,0.42,-0.36c0.69,-0.51,1.62,-0.81,2.76,-0.93zm1.17,0.66c-0.21,-0.06,-0.57,-0.06,-0.81,-0.03c-0.78,0.12,-1.26,0.69,-1.41,1.74c-0.12,0.63,-0.15,1.95,-0.09,2.79c0.12,1.71,0.63,2.4,1.77,2.46c1.08,0.03,1.62,-0.48,1.8,-1.74c0.06,-0.54,0.06,-3,0,-3.54c-0.15,-1.05,-0.51,-1.53,-1.26,-1.68z"
	    },
	    "rests.whole": {
	        "w": 11.25,
	        "h": 4.68,
	        "d": "M0.06,0.03l0.09,-0.06l5.46,0l5.49,0l0.09,0.06l0.06,0.09l0,2.19l0,2.19l-0.06,0.09l-0.09,0.06l-5.49,0l-5.46,0l-0.09,-0.06l-0.06,-0.09l0,-2.19l0,-2.19z"
	    },
	    "rests.half": {
	        "w": 11.25,
	        "h": 4.68,
	        "d": "M0.06,-4.62l0.09,-0.06l5.46,0l5.49,0l0.09,0.06l0.06,0.09l0,2.19l0,2.19l-0.06,0.09l-0.09,0.06l-5.49,0l-5.46,0l-0.09,-0.06l-0.06,-0.09l0,-2.19l0,-2.19z"
	    },
	    "rests.quarter": {
	        "w": 7.888,
	        "h": 21.435,
	        "d": "M1.89,-11.82c0.12,-0.06,0.24,-0.06,0.36,-0.03c0.09,0.06,4.74,5.58,4.86,5.82c0.21,0.39,0.15,0.78,-0.15,1.26c-0.24,0.33,-0.72,0.81,-1.62,1.56c-0.45,0.36,-0.87,0.75,-0.96,0.84c-0.93,0.99,-1.14,2.49,-0.6,3.63c0.18,0.39,0.27,0.48,1.32,1.68c1.92,2.25,1.83,2.16,1.83,2.34c0,0.18,-0.18,0.36,-0.36,0.39c-0.15,0,-0.27,-0.06,-0.48,-0.27c-0.75,-0.75,-2.46,-1.29,-3.39,-1.08c-0.45,0.09,-0.69,0.27,-0.9,0.69c-0.12,0.3,-0.21,0.66,-0.24,1.14c-0.03,0.66,0.09,1.35,0.3,2.01c0.15,0.42,0.24,0.66,0.45,0.96c0.18,0.24,0.18,0.33,0.03,0.42c-0.12,0.06,-0.18,0.03,-0.45,-0.3c-1.08,-1.38,-2.07,-3.36,-2.4,-4.83c-0.27,-1.05,-0.15,-1.77,0.27,-2.07c0.21,-0.12,0.42,-0.15,0.87,-0.15c0.87,0.06,2.1,0.39,3.3,0.9l0.39,0.18l-1.65,-1.95c-2.52,-2.97,-2.61,-3.09,-2.7,-3.27c-0.09,-0.24,-0.12,-0.48,-0.03,-0.75c0.15,-0.48,0.57,-0.96,1.83,-2.01c0.45,-0.36,0.84,-0.72,0.93,-0.78c0.69,-0.75,1.02,-1.8,0.9,-2.79c-0.06,-0.33,-0.21,-0.84,-0.39,-1.11c-0.09,-0.15,-0.45,-0.6,-0.81,-1.05c-0.36,-0.42,-0.69,-0.81,-0.72,-0.87c-0.09,-0.18,0,-0.42,0.21,-0.51z"
	    },
	    "rests.8th": {
	        "w": 7.534,
	        "h": 13.883,
	        "d": "M1.68,-6.12c0.66,-0.09,1.23,0.09,1.68,0.51c0.27,0.3,0.39,0.54,0.57,1.26c0.09,0.33,0.18,0.66,0.21,0.72c0.12,0.27,0.33,0.45,0.6,0.48c0.12,0,0.18,0,0.33,-0.09c0.39,-0.18,1.32,-1.29,1.68,-1.98c0.09,-0.21,0.24,-0.3,0.39,-0.3c0.12,0,0.27,0.09,0.33,0.18c0.03,0.06,-0.27,1.11,-1.86,6.42c-1.02,3.48,-1.89,6.39,-1.92,6.42c0,0.03,-0.12,0.12,-0.24,0.15c-0.18,0.09,-0.21,0.09,-0.45,0.09c-0.24,0,-0.3,0,-0.48,-0.06c-0.09,-0.06,-0.21,-0.12,-0.21,-0.15c-0.06,-0.03,0.15,-0.57,1.68,-4.92c0.96,-2.67,1.74,-4.89,1.71,-4.89l-0.51,0.15c-1.08,0.36,-1.74,0.48,-2.55,0.48c-0.66,0,-0.84,-0.03,-1.32,-0.27c-1.32,-0.63,-1.77,-2.16,-1.02,-3.3c0.33,-0.45,0.84,-0.81,1.38,-0.9z"
	    },
	    "rests.16th": {
	        "w": 9.724,
	        "h": 21.383,
	        "d": "M3.33,-6.12c0.66,-0.09,1.23,0.09,1.68,0.51c0.27,0.3,0.39,0.54,0.57,1.26c0.09,0.33,0.18,0.66,0.21,0.72c0.15,0.39,0.57,0.57,0.87,0.42c0.39,-0.18,1.2,-1.23,1.62,-2.07c0.06,-0.15,0.24,-0.24,0.36,-0.24c0.12,0,0.27,0.09,0.33,0.18c0.03,0.06,-0.45,1.86,-2.67,10.17c-1.5,5.55,-2.73,10.14,-2.76,10.17c-0.03,0.03,-0.12,0.12,-0.24,0.15c-0.18,0.09,-0.21,0.09,-0.45,0.09c-0.24,0,-0.3,0,-0.48,-0.06c-0.09,-0.06,-0.21,-0.12,-0.21,-0.15c-0.06,-0.03,0.12,-0.57,1.44,-4.92c0.81,-2.67,1.47,-4.86,1.47,-4.89c-0.03,0,-0.27,0.06,-0.54,0.15c-1.08,0.36,-1.77,0.48,-2.58,0.48c-0.66,0,-0.84,-0.03,-1.32,-0.27c-1.32,-0.63,-1.77,-2.16,-1.02,-3.3c0.72,-1.05,2.22,-1.23,3.06,-0.42c0.3,0.33,0.42,0.6,0.6,1.38c0.09,0.45,0.21,0.78,0.33,0.9c0.09,0.09,0.27,0.18,0.45,0.21c0.12,0,0.18,0,0.33,-0.09c0.33,-0.15,1.02,-0.93,1.41,-1.59c0.12,-0.21,0.18,-0.39,0.39,-1.08c0.66,-2.1,1.17,-3.84,1.17,-3.87c0,0,-0.21,0.06,-0.42,0.15c-0.51,0.15,-1.2,0.33,-1.68,0.42c-0.33,0.06,-0.51,0.06,-0.96,0.06c-0.66,0,-0.84,-0.03,-1.32,-0.27c-1.32,-0.63,-1.77,-2.16,-1.02,-3.3c0.33,-0.45,0.84,-0.81,1.38,-0.9z"
	    },
	    "rests.32nd": {
	        "w": 11.373,
	        "h": 28.883,
	        "d": "M4.23,-13.62c0.66,-0.09,1.23,0.09,1.68,0.51c0.27,0.3,0.39,0.54,0.57,1.26c0.09,0.33,0.18,0.66,0.21,0.72c0.12,0.27,0.33,0.45,0.6,0.48c0.12,0,0.18,0,0.27,-0.06c0.33,-0.21,0.99,-1.11,1.44,-1.98c0.09,-0.24,0.21,-0.33,0.39,-0.33c0.12,0,0.27,0.09,0.33,0.18c0.03,0.06,-0.57,2.67,-3.21,13.89c-1.8,7.62,-3.3,13.89,-3.3,13.92c-0.03,0.06,-0.12,0.12,-0.24,0.18c-0.21,0.09,-0.24,0.09,-0.48,0.09c-0.24,0,-0.3,0,-0.48,-0.06c-0.09,-0.06,-0.21,-0.12,-0.21,-0.15c-0.06,-0.03,0.09,-0.57,1.23,-4.92c0.69,-2.67,1.26,-4.86,1.29,-4.89c0,-0.03,-0.12,-0.03,-0.48,0.12c-1.17,0.39,-2.22,0.57,-3,0.54c-0.42,-0.03,-0.75,-0.12,-1.11,-0.3c-1.32,-0.63,-1.77,-2.16,-1.02,-3.3c0.72,-1.05,2.22,-1.23,3.06,-0.42c0.3,0.33,0.42,0.6,0.6,1.38c0.09,0.45,0.21,0.78,0.33,0.9c0.12,0.09,0.3,0.18,0.48,0.21c0.12,0,0.18,0,0.3,-0.09c0.42,-0.21,1.29,-1.29,1.56,-1.89c0.03,-0.12,1.23,-4.59,1.23,-4.65c0,-0.03,-0.18,0.03,-0.39,0.12c-0.63,0.18,-1.2,0.36,-1.74,0.45c-0.39,0.06,-0.54,0.06,-1.02,0.06c-0.66,0,-0.84,-0.03,-1.32,-0.27c-1.32,-0.63,-1.77,-2.16,-1.02,-3.3c0.72,-1.05,2.22,-1.23,3.06,-0.42c0.3,0.33,0.42,0.6,0.6,1.38c0.09,0.45,0.21,0.78,0.33,0.9c0.18,0.18,0.51,0.27,0.72,0.15c0.3,-0.12,0.69,-0.57,1.08,-1.17c0.42,-0.6,0.39,-0.51,1.05,-3.03c0.33,-1.26,0.6,-2.31,0.6,-2.34c0,0,-0.21,0.03,-0.45,0.12c-0.57,0.18,-1.14,0.33,-1.62,0.42c-0.33,0.06,-0.51,0.06,-0.96,0.06c-0.66,0,-0.84,-0.03,-1.32,-0.27c-1.32,-0.63,-1.77,-2.16,-1.02,-3.3c0.33,-0.45,0.84,-0.81,1.38,-0.9z"
	    },
	    "rests.64th": {
	        "w": 12.453,
	        "h": 36.383,
	        "d": "M5.13,-13.62c0.66,-0.09,1.23,0.09,1.68,0.51c0.27,0.3,0.39,0.54,0.57,1.26c0.15,0.63,0.21,0.81,0.33,0.96c0.18,0.21,0.54,0.3,0.75,0.18c0.24,-0.12,0.63,-0.66,1.08,-1.56c0.33,-0.66,0.39,-0.72,0.6,-0.72c0.12,0,0.27,0.09,0.33,0.18c0.03,0.06,-0.69,3.66,-3.54,17.64c-1.95,9.66,-3.57,17.61,-3.57,17.64c-0.03,0.06,-0.12,0.12,-0.24,0.18c-0.21,0.09,-0.24,0.09,-0.48,0.09c-0.24,0,-0.3,0,-0.48,-0.06c-0.09,-0.06,-0.21,-0.12,-0.21,-0.15c-0.06,-0.03,0.06,-0.57,1.05,-4.95c0.6,-2.7,1.08,-4.89,1.08,-4.92c0,0,-0.24,0.06,-0.51,0.15c-0.66,0.24,-1.2,0.36,-1.77,0.48c-0.42,0.06,-0.57,0.06,-1.05,0.06c-0.69,0,-0.87,-0.03,-1.35,-0.27c-1.32,-0.63,-1.77,-2.16,-1.02,-3.3c0.72,-1.05,2.22,-1.23,3.06,-0.42c0.3,0.33,0.42,0.6,0.6,1.38c0.09,0.45,0.21,0.78,0.33,0.9c0.09,0.09,0.27,0.18,0.45,0.21c0.21,0.03,0.39,-0.09,0.72,-0.42c0.45,-0.45,1.02,-1.26,1.17,-1.65c0.03,-0.09,0.27,-1.14,0.54,-2.34c0.27,-1.2,0.48,-2.19,0.51,-2.22c0,-0.03,-0.09,-0.03,-0.48,0.12c-1.17,0.39,-2.22,0.57,-3,0.54c-0.42,-0.03,-0.75,-0.12,-1.11,-0.3c-1.32,-0.63,-1.77,-2.16,-1.02,-3.3c0.36,-0.54,0.96,-0.87,1.65,-0.93c0.54,-0.03,1.02,0.15,1.41,0.54c0.27,0.3,0.39,0.54,0.57,1.26c0.09,0.33,0.18,0.66,0.21,0.72c0.15,0.39,0.57,0.57,0.9,0.42c0.36,-0.18,1.2,-1.26,1.47,-1.89c0.03,-0.09,0.3,-1.2,0.57,-2.43l0.51,-2.28l-0.54,0.18c-1.11,0.36,-1.8,0.48,-2.61,0.48c-0.66,0,-0.84,-0.03,-1.32,-0.27c-1.32,-0.63,-1.77,-2.16,-1.02,-3.3c0.36,-0.54,0.96,-0.87,1.65,-0.93c0.54,-0.03,1.02,0.15,1.41,0.54c0.27,0.3,0.39,0.54,0.57,1.26c0.15,0.63,0.21,0.81,0.33,0.96c0.21,0.21,0.54,0.3,0.75,0.18c0.36,-0.18,0.93,-0.93,1.29,-1.68c0.12,-0.24,0.18,-0.48,0.63,-2.55l0.51,-2.31c0,-0.03,-0.18,0.03,-0.39,0.12c-1.14,0.36,-2.1,0.54,-2.82,0.51c-0.42,-0.03,-0.75,-0.12,-1.11,-0.3c-1.32,-0.63,-1.77,-2.16,-1.02,-3.3c0.33,-0.45,0.84,-0.81,1.38,-0.9z"
	    },
	    "rests.128th": {
	        "w": 12.992,
	        "h": 43.883,
	        "d": "M6.03,-21.12c0.66,-0.09,1.23,0.09,1.68,0.51c0.27,0.3,0.39,0.54,0.57,1.26c0.09,0.33,0.18,0.66,0.21,0.72c0.12,0.27,0.33,0.45,0.6,0.48c0.21,0,0.33,-0.06,0.54,-0.36c0.15,-0.21,0.54,-0.93,0.78,-1.47c0.15,-0.33,0.18,-0.39,0.3,-0.48c0.18,-0.09,0.45,0,0.51,0.15c0.03,0.09,-7.11,42.75,-7.17,42.84c-0.03,0.03,-0.15,0.09,-0.24,0.15c-0.18,0.06,-0.24,0.06,-0.45,0.06c-0.24,0,-0.3,0,-0.48,-0.06c-0.09,-0.06,-0.21,-0.12,-0.21,-0.15c-0.06,-0.03,0.03,-0.57,0.84,-4.98c0.51,-2.7,0.93,-4.92,0.9,-4.92c0,0,-0.15,0.06,-0.36,0.12c-0.78,0.27,-1.62,0.48,-2.31,0.57c-0.15,0.03,-0.54,0.03,-0.81,0.03c-0.66,0,-0.84,-0.03,-1.32,-0.27c-1.32,-0.63,-1.77,-2.16,-1.02,-3.3c0.36,-0.54,0.96,-0.87,1.65,-0.93c0.54,-0.03,1.02,0.15,1.41,0.54c0.27,0.3,0.39,0.54,0.57,1.26c0.09,0.33,0.18,0.66,0.21,0.72c0.12,0.27,0.33,0.45,0.63,0.48c0.12,0,0.18,0,0.3,-0.09c0.42,-0.21,1.14,-1.11,1.5,-1.83c0.12,-0.27,0.12,-0.27,0.54,-2.52c0.24,-1.23,0.42,-2.25,0.39,-2.25c0,0,-0.24,0.06,-0.51,0.18c-1.26,0.39,-2.25,0.57,-3.06,0.54c-0.42,-0.03,-0.75,-0.12,-1.11,-0.3c-1.32,-0.63,-1.77,-2.16,-1.02,-3.3c0.36,-0.54,0.96,-0.87,1.65,-0.93c0.54,-0.03,1.02,0.15,1.41,0.54c0.27,0.3,0.39,0.54,0.57,1.26c0.15,0.63,0.21,0.81,0.33,0.96c0.18,0.21,0.51,0.3,0.75,0.18c0.36,-0.15,1.05,-0.99,1.41,-1.77l0.15,-0.3l0.42,-2.25c0.21,-1.26,0.42,-2.28,0.39,-2.28l-0.51,0.15c-1.11,0.39,-1.89,0.51,-2.7,0.51c-0.66,0,-0.84,-0.03,-1.32,-0.27c-1.32,-0.63,-1.77,-2.16,-1.02,-3.3c0.36,-0.54,0.96,-0.87,1.65,-0.93c0.54,-0.03,1.02,0.15,1.41,0.54c0.27,0.3,0.39,0.54,0.57,1.26c0.15,0.63,0.21,0.81,0.33,0.96c0.18,0.18,0.48,0.27,0.72,0.21c0.33,-0.12,1.14,-1.26,1.41,-1.95c0,-0.09,0.21,-1.11,0.45,-2.34c0.21,-1.2,0.39,-2.22,0.39,-2.28c0.03,-0.03,0,-0.03,-0.45,0.12c-0.57,0.18,-1.2,0.33,-1.71,0.42c-0.3,0.06,-0.51,0.06,-0.93,0.06c-0.66,0,-0.84,-0.03,-1.32,-0.27c-1.32,-0.63,-1.77,-2.16,-1.02,-3.3c0.36,-0.54,0.96,-0.87,1.65,-0.93c0.54,-0.03,1.02,0.15,1.41,0.54c0.27,0.3,0.39,0.54,0.57,1.26c0.09,0.33,0.18,0.66,0.21,0.72c0.12,0.27,0.33,0.45,0.6,0.48c0.18,0,0.36,-0.09,0.57,-0.33c0.33,-0.36,0.78,-1.14,0.93,-1.56c0.03,-0.12,0.24,-1.2,0.45,-2.4c0.24,-1.2,0.42,-2.22,0.42,-2.28c0.03,-0.03,0,-0.03,-0.39,0.09c-1.05,0.36,-1.8,0.48,-2.58,0.48c-0.63,0,-0.84,-0.03,-1.29,-0.27c-1.32,-0.63,-1.77,-2.16,-1.02,-3.3c0.33,-0.45,0.84,-0.81,1.38,-0.9z"
	    },
	    "accidentals.sharp": {
	        "w": 8.25,
	        "h": 22.462,
	        "d": "M5.73,-11.19c0.21,-0.12,0.54,-0.03,0.66,0.24c0.06,0.12,0.06,0.21,0.06,2.31c0,1.23,0,2.22,0.03,2.22c0,0,0.27,-0.12,0.6,-0.24c0.69,-0.27,0.78,-0.3,0.96,-0.15c0.21,0.15,0.21,0.18,0.21,1.38c0,1.02,0,1.11,-0.06,1.2c-0.03,0.06,-0.09,0.12,-0.12,0.15c-0.06,0.03,-0.42,0.21,-0.84,0.36l-0.75,0.33l-0.03,2.43c0,1.32,0,2.43,0.03,2.43c0,0,0.27,-0.12,0.6,-0.24c0.69,-0.27,0.78,-0.3,0.96,-0.15c0.21,0.15,0.21,0.18,0.21,1.38c0,1.02,0,1.11,-0.06,1.2c-0.03,0.06,-0.09,0.12,-0.12,0.15c-0.06,0.03,-0.42,0.21,-0.84,0.36l-0.75,0.33l-0.03,2.52c0,2.28,-0.03,2.55,-0.06,2.64c-0.21,0.36,-0.72,0.36,-0.93,0c-0.03,-0.09,-0.06,-0.33,-0.06,-2.43l0,-2.31l-1.29,0.51l-1.26,0.51l0,2.43c0,2.58,0,2.52,-0.15,2.67c-0.06,0.09,-0.27,0.18,-0.36,0.18c-0.12,0,-0.33,-0.09,-0.39,-0.18c-0.15,-0.15,-0.15,-0.09,-0.15,-2.43c0,-1.23,0,-2.22,-0.03,-2.22c0,0,-0.27,0.12,-0.6,0.24c-0.69,0.27,-0.78,0.3,-0.96,0.15c-0.21,-0.15,-0.21,-0.18,-0.21,-1.38c0,-1.02,0,-1.11,0.06,-1.2c0.03,-0.06,0.09,-0.12,0.12,-0.15c0.06,-0.03,0.42,-0.21,0.84,-0.36l0.78,-0.33l0,-2.43c0,-1.32,0,-2.43,-0.03,-2.43c0,0,-0.27,0.12,-0.6,0.24c-0.69,0.27,-0.78,0.3,-0.96,0.15c-0.21,-0.15,-0.21,-0.18,-0.21,-1.38c0,-1.02,0,-1.11,0.06,-1.2c0.03,-0.06,0.09,-0.12,0.12,-0.15c0.06,-0.03,0.42,-0.21,0.84,-0.36l0.78,-0.33l0,-2.52c0,-2.28,0.03,-2.55,0.06,-2.64c0.21,-0.36,0.72,-0.36,0.93,0c0.03,0.09,0.06,0.33,0.06,2.43l0.03,2.31l1.26,-0.51l1.26,-0.51l0,-2.43c0,-2.28,0,-2.43,0.06,-2.55c0.06,-0.12,0.12,-0.18,0.27,-0.24zm-0.33,10.65l0,-2.43l-1.29,0.51l-1.26,0.51l0,2.46l0,2.43l0.09,-0.03c0.06,-0.03,0.63,-0.27,1.29,-0.51l1.17,-0.48l0,-2.46z"
	    },
	    "accidentals.halfsharp": {
	        "w": 5.25,
	        "h": 20.174,
	        "d": "M2.43,-10.05c0.21,-0.12,0.54,-0.03,0.66,0.24c0.06,0.12,0.06,0.21,0.06,2.01c0,1.05,0,1.89,0.03,1.89l0.72,-0.48c0.69,-0.48,0.69,-0.51,0.87,-0.51c0.15,0,0.18,0.03,0.27,0.09c0.21,0.15,0.21,0.18,0.21,1.41c0,1.11,-0.03,1.14,-0.09,1.23c-0.03,0.03,-0.48,0.39,-1.02,0.75l-0.99,0.66l0,2.37c0,1.32,0,2.37,0.03,2.37l0.72,-0.48c0.69,-0.48,0.69,-0.51,0.87,-0.51c0.15,0,0.18,0.03,0.27,0.09c0.21,0.15,0.21,0.18,0.21,1.41c0,1.11,-0.03,1.14,-0.09,1.23c-0.03,0.03,-0.48,0.39,-1.02,0.75l-0.99,0.66l0,2.25c0,1.95,0,2.28,-0.06,2.37c-0.06,0.12,-0.12,0.21,-0.24,0.27c-0.27,0.12,-0.54,0.03,-0.69,-0.24c-0.06,-0.12,-0.06,-0.21,-0.06,-2.01c0,-1.05,0,-1.89,-0.03,-1.89l-0.72,0.48c-0.69,0.48,-0.69,0.48,-0.87,0.48c-0.15,0,-0.18,0,-0.27,-0.06c-0.21,-0.15,-0.21,-0.18,-0.21,-1.41c0,-1.11,0.03,-1.14,0.09,-1.23c0.03,-0.03,0.48,-0.39,1.02,-0.75l0.99,-0.66l0,-2.37c0,-1.32,0,-2.37,-0.03,-2.37l-0.72,0.48c-0.69,0.48,-0.69,0.48,-0.87,0.48c-0.15,0,-0.18,0,-0.27,-0.06c-0.21,-0.15,-0.21,-0.18,-0.21,-1.41c0,-1.11,0.03,-1.14,0.09,-1.23c0.03,-0.03,0.48,-0.39,1.02,-0.75l0.99,-0.66l0,-2.25c0,-2.13,0,-2.28,0.06,-2.4c0.06,-0.12,0.12,-0.18,0.27,-0.24z"
	    },
	    "accidentals.nat": {
	        "w": 5.411,
	        "h": 22.8,
	        "d": "M0.204,-11.4c0.24,-0.06,0.78,0,0.99,0.15c0.03,0.03,0.03,0.48,0,2.61c-0.03,1.44,-0.03,2.61,-0.03,2.61c0,0.03,0.75,-0.09,1.68,-0.24c0.96,-0.18,1.71,-0.27,1.74,-0.27c0.15,0.03,0.27,0.15,0.36,0.3l0.06,0.12l0.09,8.67c0.09,6.96,0.12,8.67,0.09,8.67c-0.03,0.03,-0.12,0.06,-0.21,0.09c-0.24,0.09,-0.72,0.09,-0.96,0c-0.09,-0.03,-0.18,-0.06,-0.21,-0.09c-0.03,-0.03,-0.03,-0.48,0,-2.61c0.03,-1.44,0.03,-2.61,0.03,-2.61c0,-0.03,-0.75,0.09,-1.68,0.24c-0.96,0.18,-1.71,0.27,-1.74,0.27c-0.15,-0.03,-0.27,-0.15,-0.36,-0.3l-0.06,-0.15l-0.09,-7.53c-0.06,-4.14,-0.09,-8.04,-0.12,-8.67l0,-1.11l0.15,-0.06c0.09,-0.03,0.21,-0.06,0.27,-0.09zm3.75,8.4c0,-0.33,0,-0.42,-0.03,-0.42c-0.12,0,-2.79,0.45,-2.79,0.48c-0.03,0,-0.09,6.3,-0.09,6.33c0.03,0,2.79,-0.45,2.82,-0.48c0,0,0.09,-4.53,0.09,-5.91z"
	    },
	    "accidentals.flat": {
	        "w": 6.75,
	        "h": 18.801,
	        "d": "M-0.36,-14.07c0.33,-0.06,0.87,0,1.08,0.15c0.06,0.03,0.06,0.36,-0.03,5.25c-0.06,2.85,-0.09,5.19,-0.09,5.19c0,0.03,0.12,-0.03,0.24,-0.12c0.63,-0.42,1.41,-0.66,2.19,-0.72c0.81,-0.03,1.47,0.21,2.04,0.78c0.57,0.54,0.87,1.26,0.93,2.04c0.03,0.57,-0.09,1.08,-0.36,1.62c-0.42,0.81,-1.02,1.38,-2.82,2.61c-1.14,0.78,-1.44,1.02,-1.8,1.44c-0.18,0.18,-0.39,0.39,-0.45,0.42c-0.27,0.18,-0.57,0.15,-0.81,-0.06c-0.06,-0.09,-0.12,-0.18,-0.15,-0.27c-0.03,-0.06,-0.09,-3.27,-0.18,-8.34c-0.09,-4.53,-0.15,-8.58,-0.18,-9.03l0,-0.78l0.12,-0.06c0.06,-0.03,0.18,-0.09,0.27,-0.12zm3.18,11.01c-0.21,-0.12,-0.54,-0.15,-0.81,-0.06c-0.54,0.15,-0.99,0.63,-1.17,1.26c-0.06,0.3,-0.12,2.88,-0.06,3.87c0.03,0.42,0.03,0.81,0.06,0.9l0.03,0.12l0.45,-0.39c0.63,-0.54,1.26,-1.17,1.56,-1.59c0.3,-0.42,0.6,-0.99,0.72,-1.41c0.18,-0.69,0.09,-1.47,-0.18,-2.07c-0.15,-0.3,-0.33,-0.51,-0.6,-0.63z"
	    },
	    "accidentals.halfflat": {
	        "w": 6.728,
	        "h": 18.801,
	        "d": "M4.83,-14.07c0.33,-0.06,0.87,0,1.08,0.15c0.06,0.03,0.06,0.6,-0.12,9.06c-0.09,5.55,-0.15,9.06,-0.18,9.12c-0.03,0.09,-0.09,0.18,-0.15,0.27c-0.24,0.21,-0.54,0.24,-0.81,0.06c-0.06,-0.03,-0.27,-0.24,-0.45,-0.42c-0.36,-0.42,-0.66,-0.66,-1.8,-1.44c-1.23,-0.84,-1.83,-1.32,-2.25,-1.77c-0.66,-0.78,-0.96,-1.56,-0.93,-2.46c0.09,-1.41,1.11,-2.58,2.4,-2.79c0.3,-0.06,0.84,-0.03,1.23,0.06c0.54,0.12,1.08,0.33,1.53,0.63c0.12,0.09,0.24,0.15,0.24,0.12c0,0,-0.12,-8.37,-0.18,-9.75l0,-0.66l0.12,-0.06c0.06,-0.03,0.18,-0.09,0.27,-0.12zm-1.65,10.95c-0.6,-0.18,-1.08,0.09,-1.38,0.69c-0.27,0.6,-0.36,1.38,-0.18,2.07c0.12,0.42,0.42,0.99,0.72,1.41c0.3,0.42,0.93,1.05,1.56,1.59l0.48,0.39l0,-0.12c0.03,-0.09,0.03,-0.48,0.06,-0.9c0.03,-0.57,0.03,-1.08,0,-2.22c-0.03,-1.62,-0.03,-1.62,-0.24,-2.07c-0.21,-0.42,-0.6,-0.75,-1.02,-0.84z"
	    },
	    "accidentals.dblflat": {
	        "w": 11.613,
	        "h": 18.804,
	        "d": "M-0.36,-14.07c0.33,-0.06,0.87,0,1.08,0.15c0.06,0.03,0.06,0.33,-0.03,4.89c-0.06,2.67,-0.09,5.01,-0.09,5.22l0,0.36l0.15,-0.15c0.36,-0.3,0.75,-0.51,1.2,-0.63c0.33,-0.09,0.96,-0.09,1.26,-0.03c0.27,0.09,0.63,0.27,0.87,0.45l0.21,0.15l0,-0.27c0,-0.15,-0.03,-2.43,-0.09,-5.1c-0.09,-4.56,-0.09,-4.86,-0.03,-4.89c0.15,-0.12,0.39,-0.15,0.72,-0.15c0.3,0,0.54,0.03,0.69,0.15c0.06,0.03,0.06,0.33,-0.03,4.95c-0.06,2.7,-0.09,5.04,-0.09,5.22l0.03,0.3l0.21,-0.15c0.69,-0.48,1.44,-0.69,2.28,-0.69c0.51,0,0.78,0.03,1.2,0.21c1.32,0.63,2.01,2.28,1.53,3.69c-0.21,0.57,-0.51,1.02,-1.05,1.56c-0.42,0.42,-0.81,0.72,-1.92,1.5c-1.26,0.87,-1.5,1.08,-1.86,1.5c-0.39,0.45,-0.54,0.54,-0.81,0.51c-0.18,0,-0.21,0,-0.33,-0.06l-0.21,-0.21l-0.06,-0.12l-0.03,-0.99c-0.03,-0.54,-0.03,-1.29,-0.06,-1.68l0,-0.69l-0.21,0.24c-0.36,0.42,-0.75,0.75,-1.8,1.62c-1.02,0.84,-1.2,0.99,-1.44,1.38c-0.36,0.51,-0.54,0.6,-0.9,0.51c-0.15,-0.03,-0.39,-0.27,-0.42,-0.42c-0.03,-0.06,-0.09,-3.27,-0.18,-8.34c-0.09,-4.53,-0.15,-8.58,-0.18,-9.03l0,-0.78l0.12,-0.06c0.06,-0.03,0.18,-0.09,0.27,-0.12zm2.52,10.98c-0.18,-0.09,-0.48,-0.12,-0.66,-0.06c-0.39,0.15,-0.69,0.54,-0.84,1.14c-0.06,0.24,-0.06,0.39,-0.09,1.74c-0.03,1.44,0,2.73,0.06,3.18l0.03,0.15l0.27,-0.27c0.93,-0.96,1.5,-1.95,1.74,-3.06c0.06,-0.27,0.06,-0.39,0.06,-0.96c0,-0.54,0,-0.69,-0.06,-0.93c-0.09,-0.51,-0.27,-0.81,-0.51,-0.93zm5.43,0c-0.18,-0.09,-0.51,-0.12,-0.72,-0.06c-0.54,0.12,-0.96,0.63,-1.17,1.26c-0.06,0.3,-0.12,2.88,-0.06,3.9c0.03,0.42,0.03,0.81,0.06,0.9l0.03,0.12l0.36,-0.3c0.42,-0.36,1.02,-0.96,1.29,-1.29c0.36,-0.45,0.66,-0.99,0.81,-1.41c0.42,-1.23,0.15,-2.76,-0.6,-3.12z"
	    },
	    "accidentals.dblsharp": {
	        "w": 7.961,
	        "h": 7.977,
	        "d": "M-0.186,-3.96c0.06,-0.03,0.12,-0.06,0.15,-0.06c0.09,0,2.76,0.27,2.79,0.3c0.12,0.03,0.15,0.12,0.15,0.51c0.06,0.96,0.24,1.59,0.57,2.1c0.06,0.09,0.15,0.21,0.18,0.24l0.09,0.06l0.09,-0.06c0.03,-0.03,0.12,-0.15,0.18,-0.24c0.33,-0.51,0.51,-1.14,0.57,-2.1c0,-0.39,0.03,-0.45,0.12,-0.51c0.03,0,0.66,-0.09,1.44,-0.15c1.47,-0.15,1.5,-0.15,1.56,-0.03c0.03,0.06,0,0.42,-0.09,1.44c-0.09,0.72,-0.15,1.35,-0.15,1.38c0,0.03,-0.03,0.09,-0.06,0.12c-0.06,0.06,-0.12,0.09,-0.51,0.09c-1.08,0.06,-1.8,0.3,-2.28,0.75l-0.12,0.09l0.09,0.09c0.12,0.15,0.39,0.33,0.63,0.45c0.42,0.18,0.96,0.27,1.68,0.33c0.39,0,0.45,0.03,0.51,0.09c0.03,0.03,0.06,0.09,0.06,0.12c0,0.03,0.06,0.66,0.15,1.38c0.09,1.02,0.12,1.38,0.09,1.44c-0.06,0.12,-0.09,0.12,-1.56,-0.03c-0.78,-0.06,-1.41,-0.15,-1.44,-0.15c-0.09,-0.06,-0.12,-0.12,-0.12,-0.54c-0.06,-0.93,-0.24,-1.56,-0.57,-2.07c-0.06,-0.09,-0.15,-0.21,-0.18,-0.24l-0.09,-0.06l-0.09,0.06c-0.03,0.03,-0.12,0.15,-0.18,0.24c-0.33,0.51,-0.51,1.14,-0.57,2.07c0,0.42,-0.03,0.48,-0.12,0.54c-0.03,0,-0.66,0.09,-1.44,0.15c-1.47,0.15,-1.5,0.15,-1.56,0.03c-0.03,-0.06,0,-0.42,0.09,-1.44c0.09,-0.72,0.15,-1.35,0.15,-1.38c0,-0.03,0.03,-0.09,0.06,-0.12c0.06,-0.06,0.12,-0.09,0.51,-0.09c0.72,-0.06,1.26,-0.15,1.68,-0.33c0.24,-0.12,0.51,-0.3,0.63,-0.45l0.09,-0.09l-0.12,-0.09c-0.48,-0.45,-1.2,-0.69,-2.28,-0.75c-0.39,0,-0.45,-0.03,-0.51,-0.09c-0.03,-0.03,-0.06,-0.09,-0.06,-0.12c0,-0.03,-0.06,-0.63,-0.12,-1.38c-0.09,-0.72,-0.15,-1.35,-0.15,-1.38z"
	    },
	    "dots.dot": {
	        "w": 3.45,
	        "h": 3.45,
	        "d": "M1.32,-1.68c0.09,-0.03,0.27,-0.06,0.39,-0.06c0.96,0,1.74,0.78,1.74,1.71c0,0.96,-0.78,1.74,-1.71,1.74c-0.96,0,-1.74,-0.78,-1.74,-1.71c0,-0.78,0.54,-1.5,1.32,-1.68z"
	    },
	    "noteheads.dbl": {
	        "w": 16.83,
	        "h": 8.145,
	        "d": "M-0.69,-4.02c0.18,-0.09,0.36,-0.09,0.54,0c0.18,0.09,0.24,0.15,0.33,0.3c0.06,0.15,0.06,0.18,0.06,1.41l0,1.23l0.12,-0.18c0.72,-1.26,2.64,-2.31,4.86,-2.64c0.81,-0.15,1.11,-0.15,2.13,-0.15c0.99,0,1.29,0,2.1,0.15c0.75,0.12,1.38,0.27,2.04,0.54c1.35,0.51,2.34,1.26,2.82,2.1l0.12,0.18l0,-1.23c0,-1.2,0,-1.26,0.06,-1.38c0.09,-0.18,0.15,-0.24,0.33,-0.33c0.18,-0.09,0.36,-0.09,0.54,0c0.18,0.09,0.24,0.15,0.33,0.3l0.06,0.15l0,3.54l0,3.54l-0.06,0.15c-0.09,0.18,-0.15,0.24,-0.33,0.33c-0.18,0.09,-0.36,0.09,-0.54,0c-0.18,-0.09,-0.24,-0.15,-0.33,-0.33c-0.06,-0.12,-0.06,-0.18,-0.06,-1.38l0,-1.23l-0.12,0.18c-0.48,0.84,-1.47,1.59,-2.82,2.1c-0.84,0.33,-1.71,0.54,-2.85,0.66c-0.45,0.06,-2.16,0.06,-2.61,0c-1.14,-0.12,-2.01,-0.33,-2.85,-0.66c-1.35,-0.51,-2.34,-1.26,-2.82,-2.1l-0.12,-0.18l0,1.23c0,1.23,0,1.26,-0.06,1.38c-0.09,0.18,-0.15,0.24,-0.33,0.33c-0.18,0.09,-0.36,0.09,-0.54,0c-0.18,-0.09,-0.24,-0.15,-0.33,-0.33l-0.06,-0.15l0,-3.54c0,-3.48,0,-3.54,0.06,-3.66c0.09,-0.18,0.15,-0.24,0.33,-0.33zm7.71,0.63c-0.36,-0.06,-0.9,-0.06,-1.14,0c-0.3,0.03,-0.66,0.24,-0.87,0.42c-0.6,0.54,-0.9,1.62,-0.75,2.82c0.12,0.93,0.51,1.68,1.11,2.31c0.75,0.72,1.83,1.2,2.85,1.26c1.05,0.06,1.83,-0.54,2.1,-1.65c0.21,-0.9,0.12,-1.95,-0.24,-2.82c-0.36,-0.81,-1.08,-1.53,-1.95,-1.95c-0.3,-0.15,-0.78,-0.3,-1.11,-0.39z"
	    },
	    "noteheads.whole": {
	        "w": 14.985,
	        "h": 8.097,
	        "d": "M6.51,-4.05c0.51,-0.03,2.01,0,2.52,0.03c1.41,0.18,2.64,0.51,3.72,1.08c1.2,0.63,1.95,1.41,2.19,2.31c0.09,0.33,0.09,0.9,0,1.23c-0.24,0.9,-0.99,1.68,-2.19,2.31c-1.08,0.57,-2.28,0.9,-3.75,1.08c-0.66,0.06,-2.31,0.06,-2.97,0c-1.47,-0.18,-2.67,-0.51,-3.75,-1.08c-1.2,-0.63,-1.95,-1.41,-2.19,-2.31c-0.09,-0.33,-0.09,-0.9,0,-1.23c0.24,-0.9,0.99,-1.68,2.19,-2.31c1.2,-0.63,2.61,-0.99,4.23,-1.11zm0.57,0.66c-0.87,-0.15,-1.53,0,-2.04,0.51c-0.15,0.15,-0.24,0.27,-0.33,0.48c-0.24,0.51,-0.36,1.08,-0.33,1.77c0.03,0.69,0.18,1.26,0.42,1.77c0.6,1.17,1.74,1.98,3.18,2.22c1.11,0.21,1.95,-0.15,2.34,-0.99c0.24,-0.51,0.36,-1.08,0.33,-1.8c-0.06,-1.11,-0.45,-2.04,-1.17,-2.76c-0.63,-0.63,-1.47,-1.05,-2.4,-1.2z"
	    },
	    "noteheads.half": {
	        "w": 10.37,
	        "h": 8.132,
	        "d": "M7.44,-4.05c0.06,-0.03,0.27,-0.03,0.48,-0.03c1.05,0,1.71,0.24,2.1,0.81c0.42,0.6,0.45,1.35,0.18,2.4c-0.42,1.59,-1.14,2.73,-2.16,3.39c-1.41,0.93,-3.18,1.44,-5.4,1.53c-1.17,0.03,-1.89,-0.21,-2.28,-0.81c-0.42,-0.6,-0.45,-1.35,-0.18,-2.4c0.42,-1.59,1.14,-2.73,2.16,-3.39c0.63,-0.42,1.23,-0.72,1.98,-0.96c0.9,-0.3,1.65,-0.42,3.12,-0.54zm1.29,0.87c-0.27,-0.09,-0.63,-0.12,-0.9,-0.03c-0.72,0.24,-1.53,0.69,-3.27,1.8c-2.34,1.5,-3.3,2.25,-3.57,2.79c-0.36,0.72,-0.06,1.5,0.66,1.77c0.24,0.12,0.69,0.09,0.99,0c0.84,-0.3,1.92,-0.93,4.14,-2.37c1.62,-1.08,2.37,-1.71,2.61,-2.19c0.36,-0.72,0.06,-1.5,-0.66,-1.77z"
	    },
	    "noteheads.quarter": {
	        "w": 9.81,
	        "h": 8.094,
	        "d": "M6.09,-4.05c0.36,-0.03,1.2,0,1.53,0.06c1.17,0.24,1.89,0.84,2.16,1.83c0.06,0.18,0.06,0.3,0.06,0.66c0,0.45,0,0.63,-0.15,1.08c-0.66,2.04,-3.06,3.93,-5.52,4.38c-0.54,0.09,-1.44,0.09,-1.83,0.03c-1.23,-0.27,-1.98,-0.87,-2.25,-1.86c-0.06,-0.18,-0.06,-0.3,-0.06,-0.66c0,-0.45,0,-0.63,0.15,-1.08c0.24,-0.78,0.75,-1.53,1.44,-2.22c1.2,-1.2,2.85,-2.01,4.47,-2.22z"
	    },
	    "scripts.ufermata": {
	        "w": 19.748,
	        "h": 11.289,
	        "d": "M-0.75,-10.77c0.12,0,0.45,-0.03,0.69,-0.03c2.91,-0.03,5.55,1.53,7.41,4.35c1.17,1.71,1.95,3.72,2.43,6.03c0.12,0.51,0.12,0.57,0.03,0.69c-0.12,0.21,-0.48,0.27,-0.69,0.12c-0.12,-0.09,-0.18,-0.24,-0.27,-0.69c-0.78,-3.63,-3.42,-6.54,-6.78,-7.38c-0.78,-0.21,-1.2,-0.24,-2.07,-0.24c-0.63,0,-0.84,0,-1.2,0.06c-1.83,0.27,-3.42,1.08,-4.8,2.37c-1.41,1.35,-2.4,3.21,-2.85,5.19c-0.09,0.45,-0.15,0.6,-0.27,0.69c-0.21,0.15,-0.57,0.09,-0.69,-0.12c-0.09,-0.12,-0.09,-0.18,0.03,-0.69c0.33,-1.62,0.78,-3,1.47,-4.38c1.77,-3.54,4.44,-5.67,7.56,-5.97zm0.33,7.47c1.38,-0.3,2.58,0.9,2.31,2.25c-0.15,0.72,-0.78,1.35,-1.47,1.5c-1.38,0.27,-2.58,-0.93,-2.31,-2.31c0.15,-0.69,0.78,-1.29,1.47,-1.44z"
	    },
	    "scripts.dfermata": {
	        "w": 19.744,
	        "h": 11.274,
	        "d": "M-9.63,-0.42c0.15,-0.09,0.36,-0.06,0.51,0.03c0.12,0.09,0.18,0.24,0.27,0.66c0.78,3.66,3.42,6.57,6.78,7.41c0.78,0.21,1.2,0.24,2.07,0.24c0.63,0,0.84,0,1.2,-0.06c1.83,-0.27,3.42,-1.08,4.8,-2.37c1.41,-1.35,2.4,-3.21,2.85,-5.22c0.09,-0.42,0.15,-0.57,0.27,-0.66c0.21,-0.15,0.57,-0.09,0.69,0.12c0.09,0.12,0.09,0.18,-0.03,0.69c-0.33,1.62,-0.78,3,-1.47,4.38c-1.92,3.84,-4.89,6,-8.31,6c-3.42,0,-6.39,-2.16,-8.31,-6c-0.48,-0.96,-0.84,-1.92,-1.14,-2.97c-0.18,-0.69,-0.42,-1.74,-0.42,-1.92c0,-0.12,0.09,-0.27,0.24,-0.33zm9.21,0c1.2,-0.27,2.34,0.63,2.34,1.86c0,0.9,-0.66,1.68,-1.5,1.89c-1.38,0.27,-2.58,-0.93,-2.31,-2.31c0.15,-0.69,0.78,-1.29,1.47,-1.44z"
	    },
	    "scripts.sforzato": {
	        "w": 13.5,
	        "h": 7.5,
	        "d": "M-6.45,-3.69c0.06,-0.03,0.15,-0.06,0.18,-0.06c0.06,0,2.85,0.72,6.24,1.59l6.33,1.65c0.33,0.06,0.45,0.21,0.45,0.51c0,0.3,-0.12,0.45,-0.45,0.51l-6.33,1.65c-3.39,0.87,-6.18,1.59,-6.21,1.59c-0.21,0,-0.48,-0.24,-0.51,-0.45c0,-0.15,0.06,-0.36,0.18,-0.45c0.09,-0.06,0.87,-0.27,3.84,-1.05c2.04,-0.54,3.84,-0.99,4.02,-1.02c0.15,-0.06,1.14,-0.24,2.22,-0.42c1.05,-0.18,1.92,-0.36,1.92,-0.36c0,0,-0.87,-0.18,-1.92,-0.36c-1.08,-0.18,-2.07,-0.36,-2.22,-0.42c-0.18,-0.03,-1.98,-0.48,-4.02,-1.02c-2.97,-0.78,-3.75,-0.99,-3.84,-1.05c-0.12,-0.09,-0.18,-0.3,-0.18,-0.45c0.03,-0.15,0.15,-0.3,0.3,-0.39z"
	    },
	    "scripts.staccato": {
	        "w": 2.989,
	        "h": 3.004,
	        "d": "M-0.36,-1.47c0.93,-0.21,1.86,0.51,1.86,1.47c0,0.93,-0.87,1.65,-1.8,1.47c-0.54,-0.12,-1.02,-0.57,-1.14,-1.08c-0.21,-0.81,0.27,-1.65,1.08,-1.86z"
	    },
	    "scripts.tenuto": {
	        "w": 8.985,
	        "h": 1.08,
	        "d": "M-4.2,-0.48l0.12,-0.06l4.08,0l4.08,0l0.12,0.06c0.39,0.21,0.39,0.75,0,0.96l-0.12,0.06l-4.08,0l-4.08,0l-0.12,-0.06c-0.39,-0.21,-0.39,-0.75,0,-0.96z"
	    },
	    "scripts.umarcato": {
	        "w": 7.5,
	        "h": 8.245,
	        "d": "M-0.15,-8.19c0.15,-0.12,0.36,-0.03,0.45,0.15c0.21,0.42,3.45,7.65,3.45,7.71c0,0.12,-0.12,0.27,-0.21,0.3c-0.03,0.03,-0.51,0.03,-1.14,0.03c-1.05,0,-1.08,0,-1.17,-0.06c-0.09,-0.06,-0.24,-0.36,-1.17,-2.4c-0.57,-1.29,-1.05,-2.34,-1.08,-2.34c0,-0.03,-0.51,1.02,-1.08,2.34c-0.93,2.07,-1.08,2.34,-1.14,2.4c-0.06,0.03,-0.15,0.06,-0.18,0.06c-0.15,0,-0.33,-0.18,-0.33,-0.33c0,-0.06,3.24,-7.32,3.45,-7.71c0.03,-0.06,0.09,-0.15,0.15,-0.15z"
	    },
	    "scripts.dmarcato": {
	        "w": 7.5,
	        "h": 8.25,
	        "d": "M-3.57,0.03c0.03,0,0.57,-0.03,1.17,-0.03c1.05,0,1.08,0,1.17,0.06c0.09,0.06,0.24,0.36,1.17,2.4c0.57,1.29,1.05,2.34,1.08,2.34c0,0.03,0.51,-1.02,1.08,-2.34c0.93,-2.07,1.08,-2.34,1.14,-2.4c0.06,-0.03,0.15,-0.06,0.18,-0.06c0.15,0,0.33,0.18,0.33,0.33c0,0.09,-3.45,7.74,-3.54,7.83c-0.12,0.12,-0.3,0.12,-0.42,0c-0.09,-0.09,-3.54,-7.74,-3.54,-7.83c0,-0.09,0.12,-0.27,0.18,-0.3z"
	    },
	    "scripts.stopped": {
	        "w": 8.295,
	        "h": 8.295,
	        "d": "M-0.27,-4.08c0.18,-0.09,0.36,-0.09,0.54,0c0.18,0.09,0.24,0.15,0.33,0.3l0.06,0.15l0,1.5l0,1.47l1.47,0l1.5,0l0.15,0.06c0.15,0.09,0.21,0.15,0.3,0.33c0.09,0.18,0.09,0.36,0,0.54c-0.09,0.18,-0.15,0.24,-0.33,0.33c-0.12,0.06,-0.18,0.06,-1.62,0.06l-1.47,0l0,1.47l0,1.47l-0.06,0.15c-0.09,0.18,-0.15,0.24,-0.33,0.33c-0.18,0.09,-0.36,0.09,-0.54,0c-0.18,-0.09,-0.24,-0.15,-0.33,-0.33l-0.06,-0.15l0,-1.47l0,-1.47l-1.47,0c-1.44,0,-1.5,0,-1.62,-0.06c-0.18,-0.09,-0.24,-0.15,-0.33,-0.33c-0.09,-0.18,-0.09,-0.36,0,-0.54c0.09,-0.18,0.15,-0.24,0.33,-0.33l0.15,-0.06l1.47,0l1.47,0l0,-1.47c0,-1.44,0,-1.5,0.06,-1.62c0.09,-0.18,0.15,-0.24,0.33,-0.33z"
	    },
	    "scripts.upbow": {
	        "w": 9.73,
	        "h": 15.608,
	        "d": "M-4.65,-15.54c0.12,-0.09,0.36,-0.06,0.48,0.03c0.03,0.03,0.09,0.09,0.12,0.15c0.03,0.06,0.66,2.13,1.41,4.62c1.35,4.41,1.38,4.56,2.01,6.96l0.63,2.46l0.63,-2.46c0.63,-2.4,0.66,-2.55,2.01,-6.96c0.75,-2.49,1.38,-4.56,1.41,-4.62c0.06,-0.15,0.18,-0.21,0.36,-0.24c0.15,0,0.3,0.06,0.39,0.18c0.15,0.21,0.24,-0.18,-2.1,7.56c-1.2,3.96,-2.22,7.32,-2.25,7.41c0,0.12,-0.06,0.27,-0.09,0.3c-0.12,0.21,-0.6,0.21,-0.72,0c-0.03,-0.03,-0.09,-0.18,-0.09,-0.3c-0.03,-0.09,-1.05,-3.45,-2.25,-7.41c-2.34,-7.74,-2.25,-7.35,-2.1,-7.56c0.03,-0.03,0.09,-0.09,0.15,-0.12z"
	    },
	    "scripts.downbow": {
	        "w": 11.22,
	        "h": 9.992,
	        "d": "M-5.55,-9.93l0.09,-0.06l5.46,0l5.46,0l0.09,0.06l0.06,0.09l0,4.77c0,5.28,0,4.89,-0.18,5.01c-0.18,0.12,-0.42,0.06,-0.54,-0.12c-0.06,-0.09,-0.06,-0.18,-0.06,-2.97l0,-2.85l-4.83,0l-4.83,0l0,2.85c0,2.79,0,2.88,-0.06,2.97c-0.15,0.24,-0.51,0.24,-0.66,0c-0.06,-0.09,-0.06,-0.21,-0.06,-4.89l0,-4.77z"
	    },
	    "scripts.turn": {
	        "w": 16.366,
	        "h": 7.893,
	        "d": "M-4.77,-3.9c0.36,-0.06,1.05,-0.06,1.44,0.03c0.78,0.15,1.5,0.51,2.34,1.14c0.6,0.45,1.05,0.87,2.22,2.01c1.11,1.08,1.62,1.5,2.22,1.86c0.6,0.36,1.32,0.57,1.92,0.57c0.9,0,1.71,-0.57,1.89,-1.35c0.24,-0.93,-0.39,-1.89,-1.35,-2.1l-0.15,-0.06l-0.09,0.15c-0.03,0.09,-0.15,0.24,-0.24,0.33c-0.72,0.72,-2.04,0.54,-2.49,-0.36c-0.48,-0.93,0.03,-1.86,1.17,-2.19c0.3,-0.09,1.02,-0.09,1.35,0c0.99,0.27,1.74,0.87,2.25,1.83c0.69,1.41,0.63,3,-0.21,4.26c-0.21,0.3,-0.69,0.81,-0.99,1.02c-0.3,0.21,-0.84,0.45,-1.17,0.54c-1.23,0.36,-2.49,0.15,-3.72,-0.6c-0.75,-0.48,-1.41,-1.02,-2.85,-2.46c-1.11,-1.08,-1.62,-1.5,-2.22,-1.86c-0.6,-0.36,-1.32,-0.57,-1.92,-0.57c-0.9,0,-1.71,0.57,-1.89,1.35c-0.24,0.93,0.39,1.89,1.35,2.1l0.15,0.06l0.09,-0.15c0.03,-0.09,0.15,-0.24,0.24,-0.33c0.72,-0.72,2.04,-0.54,2.49,0.36c0.48,0.93,-0.03,1.86,-1.17,2.19c-0.3,0.09,-1.02,0.09,-1.35,0c-0.99,-0.27,-1.74,-0.87,-2.25,-1.83c-0.69,-1.41,-0.63,-3,0.21,-4.26c0.21,-0.3,0.69,-0.81,0.99,-1.02c0.48,-0.33,1.11,-0.57,1.74,-0.66z"
	    },
	    "scripts.trill": {
	        "w": 17.963,
	        "h": 16.49,
	        "d": "M-0.51,-16.02c0.12,-0.09,0.21,-0.18,0.21,-0.18l-0.81,4.02l-0.81,4.02c0.03,0,0.51,-0.27,1.08,-0.6c0.6,-0.3,1.14,-0.63,1.26,-0.66c1.14,-0.54,2.31,-0.6,3.09,-0.18c0.27,0.15,0.54,0.36,0.6,0.51l0.06,0.12l0.21,-0.21c0.9,-0.81,2.22,-0.99,3.12,-0.42c0.6,0.42,0.9,1.14,0.78,2.07c-0.15,1.29,-1.05,2.31,-1.95,2.25c-0.48,-0.03,-0.78,-0.3,-0.96,-0.81c-0.09,-0.27,-0.09,-0.9,-0.03,-1.2c0.21,-0.75,0.81,-1.23,1.59,-1.32l0.24,-0.03l-0.09,-0.12c-0.51,-0.66,-1.62,-0.63,-2.31,0.03c-0.39,0.42,-0.3,0.09,-1.23,4.77l-0.81,4.14c-0.03,0,-0.12,-0.03,-0.21,-0.09c-0.33,-0.15,-0.54,-0.18,-0.99,-0.18c-0.42,0,-0.66,0.03,-1.05,0.18c-0.12,0.06,-0.21,0.09,-0.21,0.09c0,-0.03,0.36,-1.86,0.81,-4.11c0.9,-4.47,0.87,-4.26,0.69,-4.53c-0.21,-0.36,-0.66,-0.51,-1.17,-0.36c-0.15,0.06,-2.22,1.14,-2.58,1.38c-0.12,0.09,-0.12,0.09,-0.21,0.6l-0.09,0.51l0.21,0.24c0.63,0.75,1.02,1.47,1.2,2.19c0.06,0.27,0.06,0.36,0.06,0.81c0,0.42,0,0.54,-0.06,0.78c-0.15,0.54,-0.33,0.93,-0.63,1.35c-0.18,0.24,-0.57,0.63,-0.81,0.78c-0.24,0.15,-0.63,0.36,-0.84,0.42c-0.27,0.06,-0.66,0.06,-0.87,0.03c-0.81,-0.18,-1.32,-1.05,-1.38,-2.46c-0.03,-0.6,0.03,-0.99,0.33,-2.46c0.21,-1.08,0.24,-1.32,0.21,-1.29c-1.2,0.48,-2.4,0.75,-3.21,0.72c-0.69,-0.06,-1.17,-0.3,-1.41,-0.72c-0.39,-0.75,-0.12,-1.8,0.66,-2.46c0.24,-0.18,0.69,-0.42,1.02,-0.51c0.69,-0.18,1.53,-0.15,2.31,0.09c0.3,0.09,0.75,0.3,0.99,0.45c0.12,0.09,0.15,0.09,0.15,0.03c0.03,-0.03,0.33,-1.59,0.72,-3.45c0.36,-1.86,0.66,-3.42,0.69,-3.45c0,-0.03,0.03,-0.03,0.21,0.03c0.21,0.06,0.27,0.06,0.48,0.06c0.42,-0.03,0.78,-0.18,1.26,-0.48c0.15,-0.12,0.36,-0.27,0.48,-0.39zm-5.73,7.68c-0.27,-0.03,-0.96,-0.06,-1.2,-0.03c-0.81,0.12,-1.35,0.57,-1.5,1.2c-0.18,0.66,0.12,1.14,0.75,1.29c0.66,0.12,1.92,-0.12,3.18,-0.66l0.33,-0.15l0.09,-0.39c0.06,-0.21,0.09,-0.42,0.09,-0.45c0,-0.03,-0.45,-0.3,-0.75,-0.45c-0.27,-0.15,-0.66,-0.27,-0.99,-0.36zm4.29,3.63c-0.24,-0.39,-0.51,-0.75,-0.51,-0.69c-0.06,0.12,-0.39,1.92,-0.45,2.28c-0.09,0.54,-0.12,1.14,-0.06,1.38c0.06,0.42,0.21,0.6,0.51,0.57c0.39,-0.06,0.75,-0.48,0.93,-1.14c0.09,-0.33,0.09,-1.05,0,-1.38c-0.09,-0.39,-0.24,-0.69,-0.42,-1.02z"
	    },
	    "scripts.segno": {
	        "w": 15,
	        "h": 22.504,
	        "d": "M-3.72,-11.22c0.78,-0.09,1.59,0.03,2.31,0.42c1.2,0.6,2.01,1.71,2.31,3.09c0.09,0.42,0.09,1.2,0.03,1.5c-0.15,0.45,-0.39,0.81,-0.66,0.93c-0.33,0.18,-0.84,0.21,-1.23,0.15c-0.81,-0.18,-1.32,-0.93,-1.26,-1.89c0.03,-0.36,0.09,-0.57,0.24,-0.9c0.15,-0.33,0.45,-0.6,0.72,-0.75c0.12,-0.06,0.18,-0.09,0.18,-0.12c0,-0.03,-0.03,-0.15,-0.09,-0.24c-0.18,-0.45,-0.54,-0.87,-0.96,-1.08c-1.11,-0.57,-2.34,-0.18,-2.88,0.9c-0.24,0.51,-0.33,1.11,-0.24,1.83c0.27,1.92,1.5,3.54,3.93,5.13c0.48,0.33,1.26,0.78,1.29,0.78c0.03,0,1.35,-2.19,2.94,-4.89l2.88,-4.89l0.84,0l0.87,0l-0.03,0.06c-0.15,0.21,-6.15,10.41,-6.15,10.44c0,0,0.21,0.15,0.48,0.27c2.61,1.47,4.35,3.03,5.13,4.65c1.14,2.34,0.51,5.07,-1.44,6.39c-0.66,0.42,-1.32,0.63,-2.13,0.69c-2.01,0.09,-3.81,-1.41,-4.26,-3.54c-0.09,-0.42,-0.09,-1.2,-0.03,-1.5c0.15,-0.45,0.39,-0.81,0.66,-0.93c0.33,-0.18,0.84,-0.21,1.23,-0.15c0.81,0.18,1.32,0.93,1.26,1.89c-0.03,0.36,-0.09,0.57,-0.24,0.9c-0.15,0.33,-0.45,0.6,-0.72,0.75c-0.12,0.06,-0.18,0.09,-0.18,0.12c0,0.03,0.03,0.15,0.09,0.24c0.18,0.45,0.54,0.87,0.96,1.08c1.11,0.57,2.34,0.18,2.88,-0.9c0.24,-0.51,0.33,-1.11,0.24,-1.83c-0.27,-1.92,-1.5,-3.54,-3.93,-5.13c-0.48,-0.33,-1.26,-0.78,-1.29,-0.78c-0.03,0,-1.35,2.19,-2.91,4.89l-2.88,4.89l-0.87,0l-0.87,0l0.03,-0.06c0.15,-0.21,6.15,-10.41,6.15,-10.44c0,0,-0.21,-0.15,-0.48,-0.3c-2.61,-1.44,-4.35,-3,-5.13,-4.62c-0.9,-1.89,-0.72,-4.02,0.48,-5.52c0.69,-0.84,1.68,-1.41,2.73,-1.53zm8.76,9.09c0.03,-0.03,0.15,-0.03,0.27,-0.03c0.33,0.03,0.57,0.18,0.72,0.48c0.09,0.18,0.09,0.57,0,0.75c-0.09,0.18,-0.21,0.3,-0.36,0.39c-0.15,0.06,-0.21,0.06,-0.39,0.06c-0.21,0,-0.27,0,-0.39,-0.06c-0.3,-0.15,-0.48,-0.45,-0.48,-0.75c0,-0.39,0.24,-0.72,0.63,-0.84zm-10.53,2.61c0.03,-0.03,0.15,-0.03,0.27,-0.03c0.33,0.03,0.57,0.18,0.72,0.48c0.09,0.18,0.09,0.57,0,0.75c-0.09,0.18,-0.21,0.3,-0.36,0.39c-0.15,0.06,-0.21,0.06,-0.39,0.06c-0.21,0,-0.27,0,-0.39,-0.06c-0.3,-0.15,-0.48,-0.45,-0.48,-0.75c0,-0.39,0.24,-0.72,0.63,-0.84z"
	    },
	    "scripts.coda": {
	        "w": 16.035,
	        "h": 21.062,
	        "d": "M-0.21,-10.47c0.18,-0.12,0.42,-0.06,0.54,0.12c0.06,0.09,0.06,0.18,0.06,1.5l0,1.38l0.18,0c0.39,0.06,0.96,0.24,1.38,0.48c1.68,0.93,2.82,3.24,3.03,6.12c0.03,0.24,0.03,0.45,0.03,0.45c0,0.03,0.6,0.03,1.35,0.03c1.5,0,1.47,0,1.59,0.18c0.09,0.12,0.09,0.3,0,0.42c-0.12,0.18,-0.09,0.18,-1.59,0.18c-0.75,0,-1.35,0,-1.35,0.03c0,0,0,0.21,-0.03,0.42c-0.24,3.15,-1.53,5.58,-3.45,6.36c-0.27,0.12,-0.72,0.24,-0.96,0.27l-0.18,0l0,1.38c0,1.32,0,1.41,-0.06,1.5c-0.15,0.24,-0.51,0.24,-0.66,0c-0.06,-0.09,-0.06,-0.18,-0.06,-1.5l0,-1.38l-0.18,0c-0.39,-0.06,-0.96,-0.24,-1.38,-0.48c-1.68,-0.93,-2.82,-3.24,-3.03,-6.15c-0.03,-0.21,-0.03,-0.42,-0.03,-0.42c0,-0.03,-0.6,-0.03,-1.35,-0.03c-1.5,0,-1.47,0,-1.59,-0.18c-0.09,-0.12,-0.09,-0.3,0,-0.42c0.12,-0.18,0.09,-0.18,1.59,-0.18c0.75,0,1.35,0,1.35,-0.03c0,0,0,-0.21,0.03,-0.45c0.24,-3.12,1.53,-5.55,3.45,-6.33c0.27,-0.12,0.72,-0.24,0.96,-0.27l0.18,0l0,-1.38c0,-1.53,0,-1.5,0.18,-1.62zm-0.18,6.93c0,-2.97,0,-3.15,-0.06,-3.15c-0.09,0,-0.51,0.15,-0.66,0.21c-0.87,0.51,-1.38,1.62,-1.56,3.51c-0.06,0.54,-0.12,1.59,-0.12,2.16l0,0.42l1.2,0l1.2,0l0,-3.15zm1.17,-3.06c-0.09,-0.03,-0.21,-0.06,-0.27,-0.09l-0.12,0l0,3.15l0,3.15l1.2,0l1.2,0l0,-0.81c-0.06,-2.4,-0.33,-3.69,-0.93,-4.59c-0.27,-0.39,-0.66,-0.69,-1.08,-0.81zm-1.17,10.14l0,-3.15l-1.2,0l-1.2,0l0,0.81c0.03,0.96,0.06,1.47,0.15,2.13c0.24,2.04,0.96,3.12,2.13,3.36l0.12,0l0,-3.15zm3.18,-2.34l0,-0.81l-1.2,0l-1.2,0l0,3.15l0,3.15l0.12,0c1.17,-0.24,1.89,-1.32,2.13,-3.36c0.09,-0.66,0.12,-1.17,0.15,-2.13z"
	    },
	    "scripts.comma": {
	        "w": 3.042,
	        "h": 9.237,
	        "d": "M1.14,-4.62c0.3,-0.12,0.69,-0.03,0.93,0.15c0.12,0.12,0.36,0.45,0.51,0.78c0.9,1.77,0.54,4.05,-1.08,6.75c-0.36,0.63,-0.87,1.38,-0.96,1.44c-0.18,0.12,-0.42,0.06,-0.54,-0.12c-0.09,-0.18,-0.09,-0.3,0.12,-0.6c0.96,-1.44,1.44,-2.97,1.38,-4.35c-0.06,-0.93,-0.3,-1.68,-0.78,-2.46c-0.27,-0.39,-0.33,-0.63,-0.24,-0.96c0.09,-0.27,0.36,-0.54,0.66,-0.63z"
	    },
	    "scripts.roll": {
	        "w": 10.817,
	        "h": 6.125,
	        "d": "M1.95,-6c0.21,-0.09,0.36,-0.09,0.57,0c0.39,0.15,0.63,0.39,1.47,1.35c0.66,0.75,0.78,0.87,1.08,1.05c0.75,0.45,1.65,0.42,2.4,-0.06c0.12,-0.09,0.27,-0.27,0.54,-0.6c0.42,-0.54,0.51,-0.63,0.69,-0.63c0.09,0,0.3,0.12,0.36,0.21c0.09,0.12,0.12,0.3,0.03,0.42c-0.06,0.12,-3.15,3.9,-3.3,4.08c-0.06,0.06,-0.18,0.12,-0.27,0.18c-0.27,0.12,-0.6,0.06,-0.99,-0.27c-0.27,-0.21,-0.42,-0.39,-1.08,-1.14c-0.63,-0.72,-0.81,-0.9,-1.17,-1.08c-0.36,-0.18,-0.57,-0.21,-0.99,-0.21c-0.39,0,-0.63,0.03,-0.93,0.18c-0.36,0.15,-0.51,0.27,-0.9,0.81c-0.24,0.27,-0.45,0.51,-0.48,0.54c-0.12,0.09,-0.27,0.06,-0.39,0c-0.24,-0.15,-0.33,-0.39,-0.21,-0.6c0.09,-0.12,3.18,-3.87,3.33,-4.02c0.06,-0.06,0.18,-0.15,0.24,-0.21z"
	    },
	    "scripts.prall": {
	        "w": 15.011,
	        "h": 7.5,
	        "d": "M-4.38,-3.69c0.06,-0.03,0.18,-0.06,0.24,-0.06c0.3,0,0.27,-0.03,1.89,1.95l1.53,1.83c0.03,0,0.57,-0.84,1.23,-1.83c1.14,-1.68,1.23,-1.83,1.35,-1.89c0.06,-0.03,0.18,-0.06,0.24,-0.06c0.3,0,0.27,-0.03,1.89,1.95l1.53,1.83l0.48,-0.69c0.51,-0.78,0.54,-0.84,0.69,-0.9c0.42,-0.18,0.87,0.15,0.81,0.6c-0.03,0.12,-0.3,0.51,-1.5,2.37c-1.38,2.07,-1.5,2.22,-1.62,2.28c-0.06,0.03,-0.18,0.06,-0.24,0.06c-0.3,0,-0.27,0.03,-1.89,-1.95l-1.53,-1.83c-0.03,0,-0.57,0.84,-1.23,1.83c-1.14,1.68,-1.23,1.83,-1.35,1.89c-0.06,0.03,-0.18,0.06,-0.24,0.06c-0.3,0,-0.27,0.03,-1.89,-1.95l-1.53,-1.83l-0.48,0.69c-0.51,0.78,-0.54,0.84,-0.69,0.9c-0.42,0.18,-0.87,-0.15,-0.81,-0.6c0.03,-0.12,0.3,-0.51,1.5,-2.37c1.38,-2.07,1.5,-2.22,1.62,-2.28z"
	    },
	    "scripts.mordent": {
	        "w": 15.011,
	        "h": 10.012,
	        "d": "M-0.21,-4.95c0.27,-0.15,0.63,0,0.75,0.27c0.06,0.12,0.06,0.24,0.06,1.44l0,1.29l0.57,-0.84c0.51,-0.75,0.57,-0.84,0.69,-0.9c0.06,-0.03,0.18,-0.06,0.24,-0.06c0.3,0,0.27,-0.03,1.89,1.95l1.53,1.83l0.48,-0.69c0.51,-0.78,0.54,-0.84,0.69,-0.9c0.42,-0.18,0.87,0.15,0.81,0.6c-0.03,0.12,-0.3,0.51,-1.5,2.37c-1.38,2.07,-1.5,2.22,-1.62,2.28c-0.06,0.03,-0.18,0.06,-0.24,0.06c-0.3,0,-0.27,0.03,-1.83,-1.89c-0.81,-0.99,-1.5,-1.8,-1.53,-1.86c-0.06,-0.03,-0.06,-0.03,-0.12,0.03c-0.06,0.06,-0.06,0.15,-0.06,2.28c0,1.95,0,2.25,-0.06,2.34c-0.18,0.45,-0.81,0.48,-1.05,0.03c-0.03,-0.06,-0.06,-0.24,-0.06,-1.41l0,-1.35l-0.57,0.84c-0.54,0.78,-0.6,0.87,-0.72,0.93c-0.06,0.03,-0.18,0.06,-0.24,0.06c-0.3,0,-0.27,0.03,-1.89,-1.95l-1.53,-1.83l-0.48,0.69c-0.51,0.78,-0.54,0.84,-0.69,0.9c-0.42,0.18,-0.87,-0.15,-0.81,-0.6c0.03,-0.12,0.3,-0.51,1.5,-2.37c1.38,-2.07,1.5,-2.22,1.62,-2.28c0.06,-0.03,0.18,-0.06,0.24,-0.06c0.3,0,0.27,-0.03,1.89,1.95l1.53,1.83c0.03,0,0.06,-0.06,0.09,-0.09c0.06,-0.12,0.06,-0.15,0.06,-2.28c0,-1.92,0,-2.22,0.06,-2.31c0.06,-0.15,0.15,-0.24,0.3,-0.3z"
	    },
	    "flags.u8th": {
	        "w": 6.692,
	        "h": 22.59,
	        "d": "M-0.42,3.75l0,-3.75l0.21,0l0.21,0l0,0.18c0,0.3,0.06,0.84,0.12,1.23c0.24,1.53,0.9,3.12,2.13,5.16l0.99,1.59c0.87,1.44,1.38,2.34,1.77,3.09c0.81,1.68,1.2,3.06,1.26,4.53c0.03,1.53,-0.21,3.27,-0.75,5.01c-0.21,0.69,-0.51,1.5,-0.6,1.59c-0.09,0.12,-0.27,0.21,-0.42,0.21c-0.15,0,-0.42,-0.12,-0.51,-0.21c-0.15,-0.18,-0.18,-0.42,-0.09,-0.66c0.15,-0.33,0.45,-1.2,0.57,-1.62c0.42,-1.38,0.6,-2.58,0.6,-3.9c0,-0.66,0,-0.81,-0.06,-1.11c-0.39,-2.07,-1.8,-4.26,-4.59,-7.14l-0.42,-0.45l-0.21,0l-0.21,0l0,-3.75z"
	    },
	    "flags.u16th": {
	        "w": 6.693,
	        "h": 26.337,
	        "d": "M-0.42,7.5l0,-7.5l0.21,0l0.21,0l0,0.39c0.06,1.08,0.39,2.19,0.99,3.39c0.45,0.9,0.87,1.59,1.95,3.12c1.29,1.86,1.77,2.64,2.22,3.57c0.45,0.93,0.72,1.8,0.87,2.64c0.06,0.51,0.06,1.5,0,1.92c-0.12,0.6,-0.3,1.2,-0.54,1.71l-0.09,0.24l0.18,0.45c0.51,1.2,0.72,2.22,0.69,3.42c-0.06,1.53,-0.39,3.03,-0.99,4.53c-0.3,0.75,-0.36,0.81,-0.57,0.9c-0.15,0.09,-0.33,0.06,-0.48,0c-0.18,-0.09,-0.27,-0.18,-0.33,-0.33c-0.09,-0.18,-0.06,-0.3,0.12,-0.75c0.66,-1.41,1.02,-2.88,1.08,-4.32c0,-0.6,-0.03,-1.05,-0.18,-1.59c-0.3,-1.2,-0.99,-2.4,-2.25,-3.87c-0.42,-0.48,-1.53,-1.62,-2.19,-2.22l-0.45,-0.42l-0.03,1.11l0,1.11l-0.21,0l-0.21,0l0,-7.5zm1.65,0.09c-0.3,-0.3,-0.69,-0.72,-0.9,-0.87l-0.33,-0.33l0,0.15c0,0.3,0.06,0.81,0.15,1.26c0.27,1.29,0.87,2.61,2.04,4.29c0.15,0.24,0.6,0.87,0.96,1.38l1.08,1.53l0.42,0.63c0.03,0,0.12,-0.36,0.21,-0.72c0.06,-0.33,0.06,-1.2,0,-1.62c-0.33,-1.71,-1.44,-3.48,-3.63,-5.7z"
	    },
	    "flags.u32nd": {
	        "w": 6.697,
	        "h": 32.145,
	        "d": "M-0.42,11.247l0,-11.25l0.21,0l0.21,0l0,0.36c0.09,1.68,0.69,3.27,2.07,5.46l0.87,1.35c1.02,1.62,1.47,2.37,1.86,3.18c0.48,1.02,0.78,1.92,0.93,2.88c0.06,0.48,0.06,1.5,0,1.89c-0.09,0.42,-0.21,0.87,-0.36,1.26l-0.12,0.3l0.15,0.39c0.69,1.56,0.84,2.88,0.54,4.38c-0.09,0.45,-0.27,1.08,-0.45,1.47l-0.12,0.24l0.18,0.36c0.33,0.72,0.57,1.56,0.69,2.34c0.12,1.02,-0.06,2.52,-0.42,3.84c-0.27,0.93,-0.75,2.13,-0.93,2.31c-0.18,0.15,-0.45,0.18,-0.66,0.09c-0.18,-0.09,-0.27,-0.18,-0.33,-0.33c-0.09,-0.18,-0.06,-0.3,0.06,-0.6c0.21,-0.36,0.42,-0.9,0.57,-1.38c0.51,-1.41,0.69,-3.06,0.48,-4.08c-0.15,-0.81,-0.57,-1.68,-1.2,-2.55c-0.72,-0.99,-1.83,-2.13,-3.3,-3.33l-0.48,-0.42l-0.03,1.53l0,1.56l-0.21,0l-0.21,0l0,-11.25zm1.26,-3.96c-0.27,-0.3,-0.54,-0.6,-0.66,-0.72l-0.18,-0.21l0,0.42c0.06,0.87,0.24,1.74,0.66,2.67c0.36,0.87,0.96,1.86,1.92,3.18c0.21,0.33,0.63,0.87,0.87,1.23c0.27,0.39,0.6,0.84,0.75,1.08l0.27,0.39l0.03,-0.12c0.12,-0.45,0.15,-1.05,0.09,-1.59c-0.27,-1.86,-1.38,-3.78,-3.75,-6.33zm-0.27,6.09c-0.27,-0.21,-0.48,-0.42,-0.51,-0.45c-0.06,-0.03,-0.06,-0.03,-0.06,0.21c0,0.9,0.3,2.04,0.81,3.09c0.48,1.02,0.96,1.77,2.37,3.63c0.6,0.78,1.05,1.44,1.29,1.77c0.06,0.12,0.15,0.21,0.15,0.18c0.03,-0.03,0.18,-0.57,0.24,-0.87c0.06,-0.45,0.06,-1.32,-0.03,-1.74c-0.09,-0.48,-0.24,-0.9,-0.51,-1.44c-0.66,-1.35,-1.83,-2.7,-3.75,-4.38z"
	    },
	    "flags.u64th": {
	        "w": 6.682,
	        "h": 39.694,
	        "d": "M-0.42,15l0,-15l0.21,0l0.21,0l0,0.36c0.06,1.2,0.39,2.37,1.02,3.66c0.39,0.81,0.84,1.56,1.8,3.09c0.81,1.26,1.05,1.68,1.35,2.22c0.87,1.5,1.35,2.79,1.56,4.08c0.06,0.54,0.06,1.56,-0.03,2.04c-0.09,0.48,-0.21,0.99,-0.36,1.35l-0.12,0.27l0.12,0.27c0.09,0.15,0.21,0.45,0.27,0.66c0.69,1.89,0.63,3.66,-0.18,5.46l-0.18,0.39l0.15,0.33c0.3,0.66,0.51,1.44,0.63,2.1c0.06,0.48,0.06,1.35,0,1.71c-0.15,0.57,-0.42,1.2,-0.78,1.68l-0.21,0.27l0.18,0.33c0.57,1.05,0.93,2.13,1.02,3.18c0.06,0.72,0,1.83,-0.21,2.79c-0.18,1.02,-0.63,2.34,-1.02,3.09c-0.15,0.33,-0.48,0.45,-0.78,0.3c-0.18,-0.09,-0.27,-0.18,-0.33,-0.33c-0.09,-0.18,-0.06,-0.3,0.03,-0.54c0.75,-1.5,1.23,-3.45,1.17,-4.89c-0.06,-1.02,-0.42,-2.01,-1.17,-3.15c-0.48,-0.72,-1.02,-1.35,-1.89,-2.22c-0.57,-0.57,-1.56,-1.5,-1.92,-1.77l-0.12,-0.09l0,1.68l0,1.68l-0.21,0l-0.21,0l0,-15zm0.93,-8.07c-0.27,-0.3,-0.48,-0.54,-0.51,-0.54c0,0,0,0.69,0.03,1.02c0.15,1.47,0.75,2.94,2.04,4.83l1.08,1.53c0.39,0.57,0.84,1.2,0.99,1.44c0.15,0.24,0.3,0.45,0.3,0.45c0,0,0.03,-0.09,0.06,-0.21c0.36,-1.59,-0.15,-3.33,-1.47,-5.4c-0.63,-0.93,-1.35,-1.83,-2.52,-3.12zm0.06,6.72c-0.24,-0.21,-0.48,-0.42,-0.51,-0.45l-0.06,-0.06l0,0.33c0,1.2,0.3,2.34,0.93,3.6c0.45,0.9,0.96,1.68,2.25,3.51c0.39,0.54,0.84,1.17,1.02,1.44c0.21,0.33,0.33,0.51,0.33,0.48c0.06,-0.09,0.21,-0.63,0.3,-0.99c0.06,-0.33,0.06,-0.45,0.06,-0.96c0,-0.6,-0.03,-0.84,-0.18,-1.35c-0.3,-1.08,-1.02,-2.28,-2.13,-3.57c-0.39,-0.45,-1.44,-1.47,-2.01,-1.98zm0,6.72c-0.24,-0.21,-0.48,-0.39,-0.51,-0.42l-0.06,-0.06l0,0.33c0,1.41,0.45,2.82,1.38,4.35c0.42,0.72,0.72,1.14,1.86,2.73c0.36,0.45,0.75,0.99,0.87,1.2c0.15,0.21,0.3,0.36,0.3,0.36c0.06,0,0.3,-0.48,0.39,-0.75c0.09,-0.36,0.12,-0.63,0.12,-1.05c-0.06,-1.05,-0.45,-2.04,-1.2,-3.18c-0.57,-0.87,-1.11,-1.53,-2.07,-2.49c-0.36,-0.33,-0.84,-0.78,-1.08,-1.02z"
	    },
	    "flags.d8th": {
	        "w": 8.492,
	        "h": 21.691,
	        "d": "M5.67,-21.63c0.24,-0.12,0.54,-0.06,0.69,0.15c0.06,0.06,0.21,0.36,0.39,0.66c0.84,1.77,1.26,3.36,1.32,5.1c0.03,1.29,-0.21,2.37,-0.81,3.63c-0.6,1.23,-1.26,2.13,-3.21,4.38c-1.35,1.53,-1.86,2.19,-2.4,2.97c-0.63,0.93,-1.11,1.92,-1.38,2.79c-0.15,0.54,-0.27,1.35,-0.27,1.8l0,0.15l-0.21,0l-0.21,0l0,-3.75l0,-3.75l0.21,0l0.21,0l0.48,-0.3c1.83,-1.11,3.12,-2.1,4.17,-3.12c0.78,-0.81,1.32,-1.53,1.71,-2.31c0.45,-0.93,0.6,-1.74,0.51,-2.88c-0.12,-1.56,-0.63,-3.18,-1.47,-4.68c-0.12,-0.21,-0.15,-0.33,-0.06,-0.51c0.06,-0.15,0.15,-0.24,0.33,-0.33z"
	    },
	    "flags.ugrace": {
	        "w": 12.019,
	        "h": 9.954,
	        "d": "M6.03,6.93c0.15,-0.09,0.33,-0.06,0.51,0c0.15,0.09,0.21,0.15,0.3,0.33c0.09,0.18,0.06,0.39,-0.03,0.54c-0.06,0.15,-10.89,8.88,-11.07,8.97c-0.15,0.09,-0.33,0.06,-0.48,0c-0.18,-0.09,-0.24,-0.15,-0.33,-0.33c-0.09,-0.18,-0.06,-0.39,0.03,-0.54c0.06,-0.15,10.89,-8.88,11.07,-8.97z"
	    },
	    "flags.dgrace": {
	        "w": 15.12,
	        "h": 9.212,
	        "d": "M-6.06,-15.93c0.18,-0.09,0.33,-0.12,0.48,-0.06c0.18,0.09,14.01,8.04,14.1,8.1c0.12,0.12,0.18,0.33,0.18,0.51c-0.03,0.21,-0.15,0.39,-0.36,0.48c-0.18,0.09,-0.33,0.12,-0.48,0.06c-0.18,-0.09,-14.01,-8.04,-14.1,-8.1c-0.12,-0.12,-0.18,-0.33,-0.18,-0.51c0.03,-0.21,0.15,-0.39,0.36,-0.48z"
	    },
	    "flags.d16th": {
	        "w": 8.475,
	        "h": 22.591,
	        "d": "M6.84,-22.53c0.27,-0.12,0.57,-0.06,0.72,0.15c0.15,0.15,0.33,0.87,0.45,1.56c0.06,0.33,0.06,1.35,0,1.65c-0.06,0.33,-0.15,0.78,-0.27,1.11c-0.12,0.33,-0.45,0.96,-0.66,1.32l-0.18,0.27l0.09,0.18c0.48,1.02,0.72,2.25,0.69,3.3c-0.06,1.23,-0.42,2.28,-1.26,3.45c-0.57,0.87,-0.99,1.32,-3,3.39c-1.56,1.56,-2.22,2.4,-2.76,3.45c-0.42,0.84,-0.66,1.8,-0.66,2.55l0,0.15l-0.21,0l-0.21,0l0,-7.5l0,-7.5l0.21,0l0.21,0l0,1.14l0,1.11l0.27,-0.15c1.11,-0.57,1.77,-0.99,2.52,-1.47c2.37,-1.56,3.69,-3.15,4.05,-4.83c0.03,-0.18,0.03,-0.39,0.03,-0.78c0,-0.6,-0.03,-0.93,-0.24,-1.5c-0.06,-0.18,-0.12,-0.39,-0.15,-0.45c-0.03,-0.24,0.12,-0.48,0.36,-0.6zm-0.63,7.5c-0.06,-0.18,-0.15,-0.36,-0.15,-0.36c-0.03,0,-0.03,0.03,-0.06,0.06c-0.06,0.12,-0.96,1.02,-1.95,1.98c-0.63,0.57,-1.26,1.17,-1.44,1.35c-1.53,1.62,-2.28,2.85,-2.55,4.32c-0.03,0.18,-0.03,0.54,-0.06,0.99l0,0.69l0.18,-0.09c0.93,-0.54,2.1,-1.29,2.82,-1.83c0.69,-0.51,1.02,-0.81,1.53,-1.29c1.86,-1.89,2.37,-3.66,1.68,-5.82z"
	    },
	    "flags.d32nd": {
	        "w": 8.475,
	        "h": 29.191,
	        "d": "M6.794,-29.13c0.27,-0.12,0.57,-0.06,0.72,0.15c0.12,0.12,0.27,0.63,0.36,1.11c0.33,1.59,0.06,3.06,-0.81,4.47l-0.18,0.27l0.09,0.15c0.12,0.24,0.33,0.69,0.45,1.05c0.63,1.83,0.45,3.57,-0.57,5.22l-0.18,0.3l0.15,0.27c0.42,0.87,0.6,1.71,0.57,2.61c-0.06,1.29,-0.48,2.46,-1.35,3.78c-0.54,0.81,-0.93,1.29,-2.46,3c-0.51,0.54,-1.05,1.17,-1.26,1.41c-1.56,1.86,-2.25,3.36,-2.37,5.01l0,0.33l-0.21,0l-0.21,0l0,-11.25l0,-11.25l0.21,0l0.21,0l0,1.35l0.03,1.35l0.78,-0.39c1.38,-0.69,2.34,-1.26,3.24,-1.92c1.38,-1.02,2.28,-2.13,2.64,-3.21c0.15,-0.48,0.18,-0.72,0.18,-1.29c0,-0.57,-0.06,-0.9,-0.24,-1.47c-0.06,-0.18,-0.12,-0.39,-0.15,-0.45c-0.03,-0.24,0.12,-0.48,0.36,-0.6zm-0.63,7.2c-0.09,-0.18,-0.12,-0.21,-0.12,-0.15c-0.03,0.09,-1.02,1.08,-2.04,2.04c-1.17,1.08,-1.65,1.56,-2.07,2.04c-0.84,0.96,-1.38,1.86,-1.68,2.76c-0.21,0.57,-0.27,0.99,-0.3,1.65l0,0.54l0.66,-0.33c3.57,-1.86,5.49,-3.69,5.94,-5.7c0.06,-0.39,0.06,-1.2,-0.03,-1.65c-0.06,-0.39,-0.24,-0.9,-0.36,-1.2zm-0.06,7.2c-0.06,-0.15,-0.12,-0.33,-0.15,-0.45l-0.06,-0.18l-0.18,0.21l-1.83,1.83c-0.87,0.9,-1.77,1.8,-1.95,2.01c-1.08,1.29,-1.62,2.31,-1.89,3.51c-0.06,0.3,-0.06,0.51,-0.09,0.93l0,0.57l0.09,-0.06c0.75,-0.45,1.89,-1.26,2.52,-1.74c0.81,-0.66,1.74,-1.53,2.22,-2.16c1.26,-1.53,1.68,-3.06,1.32,-4.47z"
	    },
	    "flags.d64th": {
	        "w": 8.485,
	        "h": 32.932,
	        "d": "M7.08,-32.88c0.3,-0.12,0.66,-0.03,0.78,0.24c0.18,0.33,0.27,2.1,0.15,2.64c-0.09,0.39,-0.21,0.78,-0.39,1.08l-0.15,0.3l0.09,0.27c0.03,0.12,0.09,0.45,0.12,0.69c0.27,1.44,0.18,2.55,-0.3,3.6l-0.12,0.33l0.06,0.42c0.27,1.35,0.33,2.82,0.21,3.63c-0.12,0.6,-0.3,1.23,-0.57,1.8l-0.15,0.27l0.03,0.42c0.06,1.02,0.06,2.7,0.03,3.06c-0.15,1.47,-0.66,2.76,-1.74,4.41c-0.45,0.69,-0.75,1.11,-1.74,2.37c-1.05,1.38,-1.5,1.98,-1.95,2.73c-0.93,1.5,-1.38,2.82,-1.44,4.2l0,0.42l-0.21,0l-0.21,0l0,-15l0,-15l0.21,0l0.21,0l0,1.86l0,1.89c0,0,0.21,-0.03,0.45,-0.09c2.22,-0.39,4.08,-1.11,5.19,-2.01c0.63,-0.54,1.02,-1.14,1.2,-1.8c0.06,-0.3,0.06,-1.14,-0.03,-1.65c-0.03,-0.18,-0.06,-0.39,-0.09,-0.48c-0.03,-0.24,0.12,-0.48,0.36,-0.6zm-0.45,6.15c-0.03,-0.18,-0.06,-0.42,-0.06,-0.54l-0.03,-0.18l-0.33,0.3c-0.42,0.36,-0.87,0.72,-1.68,1.29c-1.98,1.38,-2.25,1.59,-2.85,2.16c-0.75,0.69,-1.23,1.44,-1.47,2.19c-0.15,0.45,-0.18,0.63,-0.21,1.35l0,0.66l0.39,-0.18c1.83,-0.9,3.45,-1.95,4.47,-2.91c0.93,-0.9,1.53,-1.83,1.74,-2.82c0.06,-0.33,0.06,-0.87,0.03,-1.32zm-0.27,4.86c-0.03,-0.21,-0.06,-0.36,-0.06,-0.36c0,-0.03,-0.12,0.09,-0.24,0.24c-0.39,0.48,-0.99,1.08,-2.16,2.19c-1.47,1.38,-1.92,1.83,-2.46,2.49c-0.66,0.87,-1.08,1.74,-1.29,2.58c-0.09,0.42,-0.15,0.87,-0.15,1.44l0,0.54l0.48,-0.33c1.5,-1.02,2.58,-1.89,3.51,-2.82c1.47,-1.47,2.25,-2.85,2.4,-4.26c0.03,-0.39,0.03,-1.17,-0.03,-1.71zm-0.66,7.68c0.03,-0.15,0.03,-0.6,0.03,-0.99l0,-0.72l-0.27,0.33l-1.74,1.98c-1.77,1.92,-2.43,2.76,-2.97,3.9c-0.51,1.02,-0.72,1.77,-0.75,2.91c0,0.63,0,0.63,0.06,0.6c0.03,-0.03,0.3,-0.27,0.63,-0.54c0.66,-0.6,1.86,-1.8,2.31,-2.31c1.65,-1.89,2.52,-3.54,2.7,-5.16z"
	    },
	    "clefs.C": {
	        "w": 20.31,
	        "h": 29.97,
	        "d": "M0.06,-14.94l0.09,-0.06l1.92,0l1.92,0l0.09,0.06l0.06,0.09l0,14.85l0,14.82l-0.06,0.09l-0.09,0.06l-1.92,0l-1.92,0l-0.09,-0.06l-0.06,-0.09l0,-14.82l0,-14.85zm5.37,0c0.09,-0.06,0.09,-0.06,0.57,-0.06c0.45,0,0.45,0,0.54,0.06l0.06,0.09l0,7.14l0,7.11l0.09,-0.06c0.18,-0.18,0.72,-0.84,0.96,-1.2c0.3,-0.45,0.66,-1.17,0.84,-1.65c0.36,-0.9,0.57,-1.83,0.6,-2.79c0.03,-0.48,0.03,-0.54,0.09,-0.63c0.12,-0.18,0.36,-0.21,0.54,-0.12c0.18,0.09,0.21,0.15,0.24,0.66c0.06,0.87,0.21,1.56,0.57,2.22c0.51,1.02,1.26,1.68,2.22,1.92c0.21,0.06,0.33,0.06,0.78,0.06c0.45,0,0.57,0,0.84,-0.06c0.45,-0.12,0.81,-0.33,1.08,-0.6c0.57,-0.57,0.87,-1.41,0.99,-2.88c0.06,-0.54,0.06,-3,0,-3.57c-0.21,-2.58,-0.84,-3.87,-2.16,-4.5c-0.48,-0.21,-1.17,-0.36,-1.77,-0.36c-0.69,0,-1.29,0.27,-1.5,0.72c-0.06,0.15,-0.06,0.21,-0.06,0.42c0,0.24,0,0.3,0.06,0.45c0.12,0.24,0.24,0.39,0.63,0.66c0.42,0.3,0.57,0.48,0.69,0.72c0.06,0.15,0.06,0.21,0.06,0.48c0,0.39,-0.03,0.63,-0.21,0.96c-0.3,0.6,-0.87,1.08,-1.5,1.26c-0.27,0.06,-0.87,0.06,-1.14,0c-0.78,-0.24,-1.44,-0.87,-1.65,-1.68c-0.12,-0.42,-0.09,-1.17,0.09,-1.71c0.51,-1.65,1.98,-2.82,3.81,-3.09c0.84,-0.09,2.46,0.03,3.51,0.27c2.22,0.57,3.69,1.8,4.44,3.75c0.36,0.93,0.57,2.13,0.57,3.36c0,1.44,-0.48,2.73,-1.38,3.81c-1.26,1.5,-3.27,2.43,-5.28,2.43c-0.48,0,-0.51,0,-0.75,-0.09c-0.15,-0.03,-0.48,-0.21,-0.78,-0.36c-0.69,-0.36,-0.87,-0.42,-1.26,-0.42c-0.27,0,-0.3,0,-0.51,0.09c-0.57,0.3,-0.81,0.9,-0.81,2.1c0,1.23,0.24,1.83,0.81,2.13c0.21,0.09,0.24,0.09,0.51,0.09c0.39,0,0.57,-0.06,1.26,-0.42c0.3,-0.15,0.63,-0.33,0.78,-0.36c0.24,-0.09,0.27,-0.09,0.75,-0.09c2.01,0,4.02,0.93,5.28,2.4c0.9,1.11,1.38,2.4,1.38,3.84c0,1.5,-0.3,2.88,-0.84,3.96c-0.78,1.59,-2.19,2.64,-4.17,3.15c-1.05,0.24,-2.67,0.36,-3.51,0.27c-1.83,-0.27,-3.3,-1.44,-3.81,-3.09c-0.18,-0.54,-0.21,-1.29,-0.09,-1.74c0.15,-0.6,0.63,-1.2,1.23,-1.47c0.36,-0.18,0.57,-0.21,0.99,-0.21c0.42,0,0.63,0.03,1.02,0.21c0.42,0.21,0.84,0.63,1.05,1.05c0.18,0.36,0.21,0.6,0.21,0.96c0,0.3,0,0.36,-0.06,0.51c-0.12,0.24,-0.27,0.42,-0.69,0.72c-0.57,0.42,-0.69,0.63,-0.69,1.08c0,0.24,0,0.3,0.06,0.45c0.12,0.21,0.3,0.39,0.57,0.54c0.42,0.18,0.87,0.21,1.53,0.15c1.08,-0.15,1.8,-0.57,2.34,-1.32c0.54,-0.75,0.84,-1.83,0.99,-3.51c0.06,-0.57,0.06,-3.03,0,-3.57c-0.12,-1.47,-0.42,-2.31,-0.99,-2.88c-0.27,-0.27,-0.63,-0.48,-1.08,-0.6c-0.27,-0.06,-0.39,-0.06,-0.84,-0.06c-0.45,0,-0.57,0,-0.78,0.06c-1.14,0.27,-2.01,1.17,-2.46,2.49c-0.21,0.57,-0.3,0.99,-0.33,1.65c-0.03,0.51,-0.06,0.57,-0.24,0.66c-0.12,0.06,-0.27,0.06,-0.39,0c-0.21,-0.09,-0.21,-0.15,-0.24,-0.75c-0.09,-1.92,-0.78,-3.72,-2.01,-5.19c-0.18,-0.21,-0.36,-0.42,-0.39,-0.45l-0.09,-0.06l0,7.11l0,7.14l-0.06,0.09c-0.09,0.06,-0.09,0.06,-0.54,0.06c-0.48,0,-0.48,0,-0.57,-0.06l-0.06,-0.09l0,-14.82l0,-14.85z"
	    },
	    "clefs.F": {
	        "w": 20.153,
	        "h": 23.142,
	        "d": "M6.3,-7.8c0.36,-0.03,1.65,0,2.13,0.03c3.6,0.42,6.03,2.1,6.93,4.86c0.27,0.84,0.36,1.5,0.36,2.58c0,0.9,-0.03,1.35,-0.18,2.16c-0.78,3.78,-3.54,7.08,-8.37,9.96c-1.74,1.05,-3.87,2.13,-6.18,3.12c-0.39,0.18,-0.75,0.33,-0.81,0.36c-0.06,0.03,-0.15,0.06,-0.18,0.06c-0.15,0,-0.33,-0.18,-0.33,-0.33c0,-0.15,0.06,-0.21,0.51,-0.48c3,-1.77,5.13,-3.21,6.84,-4.74c0.51,-0.45,1.59,-1.5,1.95,-1.95c1.89,-2.19,2.88,-4.32,3.15,-6.78c0.06,-0.42,0.06,-1.77,0,-2.19c-0.24,-2.01,-0.93,-3.63,-2.04,-4.71c-0.63,-0.63,-1.29,-1.02,-2.07,-1.2c-1.62,-0.39,-3.36,0.15,-4.56,1.44c-0.54,0.6,-1.05,1.47,-1.32,2.22l-0.09,0.21l0.24,-0.12c0.39,-0.21,0.63,-0.24,1.11,-0.24c0.3,0,0.45,0,0.66,0.06c1.92,0.48,2.85,2.55,1.95,4.38c-0.45,0.99,-1.41,1.62,-2.46,1.71c-1.47,0.09,-2.91,-0.87,-3.39,-2.25c-0.18,-0.57,-0.21,-1.32,-0.03,-2.28c0.39,-2.25,1.83,-4.2,3.81,-5.19c0.69,-0.36,1.59,-0.6,2.37,-0.69zm11.58,2.52c0.84,-0.21,1.71,0.3,1.89,1.14c0.3,1.17,-0.72,2.19,-1.89,1.89c-0.99,-0.21,-1.5,-1.32,-1.02,-2.25c0.18,-0.39,0.6,-0.69,1.02,-0.78zm0,7.5c0.84,-0.21,1.71,0.3,1.89,1.14c0.21,0.87,-0.3,1.71,-1.14,1.89c-0.87,0.21,-1.71,-0.3,-1.89,-1.14c-0.21,-0.84,0.3,-1.71,1.14,-1.89z"
	    },
	    "clefs.G": {
	        "w": 19.051,
	        "h": 57.057,
	        "d": "M9.69,-37.41c0.09,-0.09,0.24,-0.06,0.36,0c0.12,0.09,0.57,0.6,0.96,1.11c1.77,2.34,3.21,5.85,3.57,8.73c0.21,1.56,0.03,3.27,-0.45,4.86c-0.69,2.31,-1.92,4.47,-4.23,7.44c-0.3,0.39,-0.57,0.72,-0.6,0.75c-0.03,0.06,0,0.15,0.18,0.78c0.54,1.68,1.38,4.44,1.68,5.49l0.09,0.42l0.39,0c1.47,0.09,2.76,0.51,3.96,1.29c1.83,1.23,3.06,3.21,3.39,5.52c0.09,0.45,0.12,1.29,0.06,1.74c-0.09,1.02,-0.33,1.83,-0.75,2.73c-0.84,1.71,-2.28,3.06,-4.02,3.72l-0.33,0.12l0.03,1.26c0,1.74,-0.06,3.63,-0.21,4.62c-0.45,3.06,-2.19,5.49,-4.47,6.21c-0.57,0.18,-0.9,0.21,-1.59,0.21c-0.69,0,-1.02,-0.03,-1.65,-0.21c-1.14,-0.27,-2.13,-0.84,-2.94,-1.65c-0.99,-0.99,-1.56,-2.16,-1.71,-3.54c-0.09,-0.81,0.06,-1.53,0.45,-2.13c0.63,-0.99,1.83,-1.56,3,-1.53c1.5,0.09,2.64,1.32,2.73,2.94c0.06,1.47,-0.93,2.7,-2.37,2.97c-0.45,0.06,-0.84,0.03,-1.29,-0.09l-0.21,-0.09l0.09,0.12c0.39,0.54,0.78,0.93,1.32,1.26c1.35,0.87,3.06,1.02,4.35,0.36c1.44,-0.72,2.52,-2.28,2.97,-4.35c0.15,-0.66,0.24,-1.5,0.3,-3.03c0.03,-0.84,0.03,-2.94,0,-3c-0.03,0,-0.18,0,-0.36,0.03c-0.66,0.12,-0.99,0.12,-1.83,0.12c-1.05,0,-1.71,-0.06,-2.61,-0.3c-4.02,-0.99,-7.11,-4.35,-7.8,-8.46c-0.12,-0.66,-0.12,-0.99,-0.12,-1.83c0,-0.84,0,-1.14,0.15,-1.92c0.36,-2.28,1.41,-4.62,3.3,-7.29l2.79,-3.6c0.54,-0.66,0.96,-1.2,0.96,-1.23c0,-0.03,-0.09,-0.33,-0.18,-0.69c-0.96,-3.21,-1.41,-5.28,-1.59,-7.68c-0.12,-1.38,-0.15,-3.09,-0.06,-3.96c0.33,-2.67,1.38,-5.07,3.12,-7.08c0.36,-0.42,0.99,-1.05,1.17,-1.14zm2.01,4.71c-0.15,-0.3,-0.3,-0.54,-0.3,-0.54c-0.03,0,-0.18,0.09,-0.3,0.21c-2.4,1.74,-3.87,4.2,-4.26,7.11c-0.06,0.54,-0.06,1.41,-0.03,1.89c0.09,1.29,0.48,3.12,1.08,5.22c0.15,0.42,0.24,0.78,0.24,0.81c0,0.03,0.84,-1.11,1.23,-1.68c1.89,-2.73,2.88,-5.07,3.15,-7.53c0.09,-0.57,0.12,-1.74,0.06,-2.37c-0.09,-1.23,-0.27,-1.92,-0.87,-3.12zm-2.94,20.7c-0.21,-0.72,-0.39,-1.32,-0.42,-1.32c0,0,-1.2,1.47,-1.86,2.37c-2.79,3.63,-4.02,6.3,-4.35,9.3c-0.03,0.21,-0.03,0.69,-0.03,1.08c0,0.69,0,0.75,0.06,1.11c0.12,0.54,0.27,0.99,0.51,1.47c0.69,1.38,1.83,2.55,3.42,3.42c0.96,0.54,2.07,0.9,3.21,1.08c0.78,0.12,2.04,0.12,2.94,-0.03c0.51,-0.06,0.45,-0.03,0.42,-0.3c-0.24,-3.33,-0.72,-6.33,-1.62,-10.08c-0.09,-0.39,-0.18,-0.75,-0.18,-0.78c-0.03,-0.03,-0.42,0,-0.81,0.09c-0.9,0.18,-1.65,0.57,-2.22,1.14c-0.72,0.72,-1.08,1.65,-1.05,2.64c0.06,0.96,0.48,1.83,1.23,2.58c0.36,0.36,0.72,0.63,1.17,0.9c0.33,0.18,0.36,0.21,0.42,0.33c0.18,0.42,-0.18,0.9,-0.6,0.87c-0.18,-0.03,-0.84,-0.36,-1.26,-0.63c-0.78,-0.51,-1.38,-1.11,-1.86,-1.83c-1.77,-2.7,-0.99,-6.42,1.71,-8.19c0.3,-0.21,0.81,-0.48,1.17,-0.63c0.3,-0.09,1.02,-0.3,1.14,-0.3c0.06,0,0.09,0,0.09,-0.03c0.03,-0.03,-0.51,-1.92,-1.23,-4.26zm3.78,7.41c-0.18,-0.03,-0.36,-0.06,-0.39,-0.06c-0.03,0,0,0.21,0.18,1.02c0.75,3.18,1.26,6.3,1.5,9.09c0.06,0.72,0,0.69,0.51,0.42c0.78,-0.36,1.44,-0.96,1.98,-1.77c1.08,-1.62,1.2,-3.69,0.3,-5.55c-0.81,-1.62,-2.31,-2.79,-4.08,-3.15z"
	    },
	    "clefs.perc": {
	        "w": 9.99,
	        "h": 14.97,
	        "d": "M5.07,-7.44l0.09,-0.06l1.53,0l1.53,0l0.09,0.06l0.06,0.09l0,7.35l0,7.32l-0.06,0.09l-0.09,0.06l-1.53,0l-1.53,0l-0.09,-0.06l-0.06,-0.09l0,-7.32l0,-7.35zm6.63,0l0.09,-0.06l1.53,0l1.53,0l0.09,0.06l0.06,0.09l0,7.35l0,7.32l-0.06,0.09l-0.09,0.06l-1.53,0l-1.53,0l-0.09,-0.06l-0.06,-0.09l0,-7.32l0,-7.35z"
	    },
	    "timesig.common": {
	        "w": 13.038,
	        "h": 15.697,
	        "d": "M6.66,-7.826c0.72,-0.06,1.41,-0.03,1.98,0.09c1.2,0.27,2.34,0.96,3.09,1.92c0.63,0.81,1.08,1.86,1.14,2.73c0.06,1.02,-0.51,1.92,-1.44,2.22c-0.24,0.09,-0.3,0.09,-0.63,0.09c-0.33,0,-0.42,0,-0.63,-0.06c-0.66,-0.24,-1.14,-0.63,-1.41,-1.2c-0.15,-0.3,-0.21,-0.51,-0.24,-0.9c-0.06,-1.08,0.57,-2.04,1.56,-2.37c0.18,-0.06,0.27,-0.06,0.63,-0.06l0.45,0c0.06,0.03,0.09,0.03,0.09,0c0,0,-0.09,-0.12,-0.24,-0.27c-1.02,-1.11,-2.55,-1.68,-4.08,-1.5c-1.29,0.15,-2.04,0.69,-2.4,1.74c-0.36,0.93,-0.42,1.89,-0.42,5.37c0,2.97,0.06,3.96,0.24,4.77c0.24,1.08,0.63,1.68,1.41,2.07c0.81,0.39,2.16,0.45,3.18,0.09c1.29,-0.45,2.37,-1.53,3.03,-2.97c0.15,-0.33,0.33,-0.87,0.39,-1.17c0.09,-0.24,0.15,-0.36,0.3,-0.39c0.21,-0.03,0.42,0.15,0.39,0.36c-0.06,0.39,-0.42,1.38,-0.69,1.89c-0.96,1.8,-2.49,2.94,-4.23,3.18c-0.99,0.12,-2.58,-0.06,-3.63,-0.45c-0.96,-0.36,-1.71,-0.84,-2.4,-1.5c-1.11,-1.11,-1.8,-2.61,-2.04,-4.56c-0.06,-0.6,-0.06,-2.01,0,-2.61c0.24,-1.95,0.9,-3.45,2.01,-4.56c0.69,-0.66,1.44,-1.11,2.37,-1.47c0.63,-0.24,1.47,-0.42,2.22,-0.48z"
	    },
	    "timesig.cut": {
	        "w": 13.038,
	        "h": 20.97,
	        "d": "M6.24,-10.44c0.09,-0.06,0.09,-0.06,0.48,-0.06c0.36,0,0.36,0,0.45,0.06l0.06,0.09l0,1.23l0,1.26l0.27,0c1.26,0,2.49,0.45,3.48,1.29c1.05,0.87,1.8,2.28,1.89,3.48c0.06,1.02,-0.51,1.92,-1.44,2.22c-0.24,0.09,-0.3,0.09,-0.63,0.09c-0.33,0,-0.42,0,-0.63,-0.06c-0.66,-0.24,-1.14,-0.63,-1.41,-1.2c-0.15,-0.3,-0.21,-0.51,-0.24,-0.9c-0.06,-1.08,0.57,-2.04,1.56,-2.37c0.18,-0.06,0.27,-0.06,0.63,-0.06l0.45,0c0.06,0.03,0.09,0.03,0.09,0c0,-0.03,-0.45,-0.51,-0.66,-0.69c-0.87,-0.69,-1.83,-1.05,-2.94,-1.11l-0.42,0l0,7.17l0,7.14l0.42,0c0.69,-0.03,1.23,-0.18,1.86,-0.51c1.05,-0.51,1.89,-1.47,2.46,-2.7c0.15,-0.33,0.33,-0.87,0.39,-1.17c0.09,-0.24,0.15,-0.36,0.3,-0.39c0.21,-0.03,0.42,0.15,0.39,0.36c-0.03,0.24,-0.21,0.78,-0.39,1.2c-0.96,2.37,-2.94,3.9,-5.13,3.9l-0.3,0l0,1.26l0,1.23l-0.06,0.09c-0.09,0.06,-0.09,0.06,-0.45,0.06c-0.39,0,-0.39,0,-0.48,-0.06l-0.06,-0.09l0,-1.29l0,-1.29l-0.21,-0.03c-1.23,-0.21,-2.31,-0.63,-3.21,-1.29c-0.15,-0.09,-0.45,-0.36,-0.66,-0.57c-1.11,-1.11,-1.8,-2.61,-2.04,-4.56c-0.06,-0.6,-0.06,-2.01,0,-2.61c0.24,-1.95,0.93,-3.45,2.04,-4.59c0.42,-0.39,0.78,-0.66,1.26,-0.93c0.75,-0.45,1.65,-0.75,2.61,-0.9l0.21,-0.03l0,-1.29l0,-1.29zm-0.06,10.44c0,-5.58,0,-6.99,-0.03,-6.99c-0.15,0,-0.63,0.27,-0.87,0.45c-0.45,0.36,-0.75,0.93,-0.93,1.77c-0.18,0.81,-0.24,1.8,-0.24,4.74c0,2.97,0.06,3.96,0.24,4.77c0.24,1.08,0.66,1.68,1.41,2.07c0.12,0.06,0.3,0.12,0.33,0.15l0.09,0l0,-6.96z"
	    },
	    "f": {
	        "w": 16.155,
	        "h": 19.445,
	        "d": "M9.93,-14.28c1.53,-0.18,2.88,0.45,3.12,1.5c0.12,0.51,0,1.32,-0.27,1.86c-0.15,0.3,-0.42,0.57,-0.63,0.69c-0.69,0.36,-1.56,0.03,-1.83,-0.69c-0.09,-0.24,-0.09,-0.69,0,-0.87c0.06,-0.12,0.21,-0.24,0.45,-0.42c0.42,-0.24,0.57,-0.45,0.6,-0.72c0.03,-0.33,-0.09,-0.39,-0.63,-0.42c-0.3,0,-0.45,0,-0.6,0.03c-0.81,0.21,-1.35,0.93,-1.74,2.46c-0.06,0.27,-0.48,2.25,-0.48,2.31c0,0.03,0.39,0.03,0.9,0.03c0.72,0,0.9,0,0.99,0.06c0.42,0.15,0.45,0.72,0.03,0.9c-0.12,0.06,-0.24,0.06,-1.17,0.06l-1.05,0l-0.78,2.55c-0.45,1.41,-0.87,2.79,-0.96,3.06c-0.87,2.37,-2.37,4.74,-3.78,5.91c-1.05,0.9,-2.04,1.23,-3.09,1.08c-1.11,-0.18,-1.89,-0.78,-2.04,-1.59c-0.12,-0.66,0.15,-1.71,0.54,-2.19c0.69,-0.75,1.86,-0.54,2.22,0.39c0.06,0.15,0.09,0.27,0.09,0.48c0,0.24,-0.03,0.27,-0.12,0.42c-0.03,0.09,-0.15,0.18,-0.27,0.27c-0.09,0.06,-0.27,0.21,-0.36,0.27c-0.24,0.18,-0.36,0.36,-0.39,0.6c-0.03,0.33,0.09,0.39,0.63,0.42c0.42,0,0.63,-0.03,0.9,-0.15c0.6,-0.3,0.96,-0.96,1.38,-2.64c0.09,-0.42,0.63,-2.55,1.17,-4.77l1.02,-4.08c0,-0.03,-0.36,-0.03,-0.81,-0.03c-0.72,0,-0.81,0,-0.93,-0.06c-0.42,-0.18,-0.39,-0.75,0.03,-0.9c0.09,-0.06,0.27,-0.06,1.05,-0.06l0.96,0l0,-0.09c0.06,-0.18,0.3,-0.72,0.51,-1.17c1.2,-2.46,3.3,-4.23,5.34,-4.5z"
	    },
	    "m": {
	        "w": 14.687,
	        "h": 9.126,
	        "d": "M2.79,-8.91c0.09,0,0.3,-0.03,0.45,-0.03c0.24,0.03,0.3,0.03,0.45,0.12c0.36,0.15,0.63,0.54,0.75,1.02l0.03,0.21l0.33,-0.3c0.69,-0.69,1.38,-1.02,2.07,-1.02c0.27,0,0.33,0,0.48,0.06c0.21,0.09,0.48,0.36,0.63,0.6c0.03,0.09,0.12,0.27,0.18,0.42c0.03,0.15,0.09,0.27,0.12,0.27c0,0,0.09,-0.09,0.18,-0.21c0.33,-0.39,0.87,-0.81,1.29,-0.99c0.78,-0.33,1.47,-0.21,2.01,0.33c0.3,0.33,0.48,0.69,0.6,1.14c0.09,0.42,0.06,0.54,-0.54,3.06c-0.33,1.29,-0.57,2.4,-0.57,2.43c0,0.12,0.09,0.21,0.21,0.21c0.24,0,0.75,-0.3,1.2,-0.72c0.45,-0.39,0.6,-0.45,0.78,-0.27c0.18,0.18,0.09,0.36,-0.45,0.87c-1.05,0.96,-1.83,1.47,-2.58,1.71c-0.93,0.33,-1.53,0.21,-1.8,-0.33c-0.06,-0.15,-0.06,-0.21,-0.06,-0.45c0,-0.24,0.03,-0.48,0.6,-2.82c0.42,-1.71,0.6,-2.64,0.63,-2.79c0.03,-0.57,-0.3,-0.75,-0.84,-0.48c-0.24,0.12,-0.54,0.39,-0.66,0.63c-0.03,0.09,-0.42,1.38,-0.9,3c-0.9,3.15,-0.84,3,-1.14,3.15l-0.15,0.09l-0.78,0c-0.6,0,-0.78,0,-0.84,-0.06c-0.09,-0.03,-0.18,-0.18,-0.18,-0.27c0,-0.03,0.36,-1.38,0.84,-2.97c0.57,-2.04,0.81,-2.97,0.84,-3.12c0.03,-0.54,-0.3,-0.72,-0.84,-0.45c-0.24,0.12,-0.57,0.42,-0.66,0.63c-0.06,0.09,-0.51,1.44,-1.05,2.97c-0.51,1.56,-0.99,2.85,-0.99,2.91c-0.06,0.12,-0.21,0.24,-0.36,0.3c-0.12,0.06,-0.21,0.06,-0.9,0.06c-0.6,0,-0.78,0,-0.84,-0.06c-0.09,-0.03,-0.18,-0.18,-0.18,-0.27c0,-0.03,0.45,-1.38,0.99,-2.97c1.05,-3.18,1.05,-3.18,0.93,-3.45c-0.12,-0.27,-0.39,-0.3,-0.72,-0.15c-0.54,0.27,-1.14,1.17,-1.56,2.4c-0.06,0.15,-0.15,0.3,-0.18,0.36c-0.21,0.21,-0.57,0.27,-0.72,0.09c-0.09,-0.09,-0.06,-0.21,0.06,-0.63c0.48,-1.26,1.26,-2.46,2.01,-3.21c0.57,-0.54,1.2,-0.87,1.83,-1.02z"
	    },
	    "p": {
	        "w": 14.689,
	        "h": 13.127,
	        "d": "M1.92,-8.7c0.27,-0.09,0.81,-0.06,1.11,0.03c0.54,0.18,0.93,0.51,1.17,0.99c0.09,0.15,0.15,0.33,0.18,0.36l0,0.12l0.3,-0.27c0.66,-0.6,1.35,-1.02,2.13,-1.2c0.21,-0.06,0.33,-0.06,0.78,-0.06c0.45,0,0.51,0,0.84,0.09c1.29,0.33,2.07,1.32,2.25,2.79c0.09,0.81,-0.09,2.01,-0.45,2.79c-0.54,1.26,-1.86,2.55,-3.18,3.03c-0.45,0.18,-0.81,0.24,-1.29,0.24c-0.69,-0.03,-1.35,-0.18,-1.86,-0.45c-0.3,-0.15,-0.51,-0.18,-0.69,-0.09c-0.09,0.03,-0.18,0.09,-0.18,0.12c-0.09,0.12,-1.05,2.94,-1.05,3.06c0,0.24,0.18,0.48,0.51,0.63c0.18,0.06,0.54,0.15,0.75,0.15c0.21,0,0.36,0.06,0.42,0.18c0.12,0.18,0.06,0.42,-0.12,0.54c-0.09,0.03,-0.15,0.03,-0.78,0c-1.98,-0.15,-3.81,-0.15,-5.79,0c-0.63,0.03,-0.69,0.03,-0.78,0c-0.24,-0.15,-0.24,-0.57,0.03,-0.66c0.06,-0.03,0.48,-0.09,0.99,-0.12c0.87,-0.06,1.11,-0.09,1.35,-0.21c0.18,-0.06,0.33,-0.18,0.39,-0.3c0.06,-0.12,3.24,-9.42,3.27,-9.6c0.06,-0.33,0.03,-0.57,-0.15,-0.69c-0.09,-0.06,-0.12,-0.06,-0.3,-0.06c-0.69,0.06,-1.53,1.02,-2.28,2.61c-0.09,0.21,-0.21,0.45,-0.27,0.51c-0.09,0.12,-0.33,0.24,-0.48,0.24c-0.18,0,-0.36,-0.15,-0.36,-0.3c0,-0.24,0.78,-1.83,1.26,-2.55c0.72,-1.11,1.47,-1.74,2.28,-1.92zm5.37,1.47c-0.27,-0.12,-0.75,-0.03,-1.14,0.21c-0.75,0.48,-1.47,1.68,-1.89,3.15c-0.45,1.47,-0.42,2.34,0,2.7c0.45,0.39,1.26,0.21,1.83,-0.36c0.51,-0.51,0.99,-1.68,1.38,-3.27c0.3,-1.17,0.33,-1.74,0.15,-2.13c-0.09,-0.15,-0.15,-0.21,-0.33,-0.3z"
	    },
	    "r": {
	        "w": 9.41,
	        "h": 9.132,
	        "d": "M6.33,-9.12c0.27,-0.03,0.93,0,1.2,0.06c0.84,0.21,1.23,0.81,1.02,1.53c-0.24,0.75,-0.9,1.17,-1.56,0.96c-0.33,-0.09,-0.51,-0.3,-0.66,-0.75c-0.03,-0.12,-0.09,-0.24,-0.12,-0.3c-0.09,-0.15,-0.3,-0.24,-0.48,-0.24c-0.57,0,-1.38,0.54,-1.65,1.08c-0.06,0.15,-0.33,1.17,-0.9,3.27c-0.57,2.31,-0.81,3.12,-0.87,3.21c-0.03,0.06,-0.12,0.15,-0.18,0.21l-0.12,0.06l-0.81,0.03c-0.69,0,-0.81,0,-0.9,-0.03c-0.09,-0.06,-0.18,-0.21,-0.18,-0.3c0,-0.06,0.39,-1.62,0.9,-3.51c0.84,-3.24,0.87,-3.45,0.87,-3.72c0,-0.21,0,-0.27,-0.03,-0.36c-0.12,-0.15,-0.21,-0.24,-0.42,-0.24c-0.24,0,-0.45,0.15,-0.78,0.42c-0.33,0.36,-0.45,0.54,-0.72,1.14c-0.03,0.12,-0.21,0.24,-0.36,0.27c-0.12,0,-0.15,0,-0.24,-0.06c-0.18,-0.12,-0.18,-0.21,-0.06,-0.54c0.21,-0.57,0.42,-0.93,0.78,-1.32c0.54,-0.51,1.2,-0.81,1.95,-0.87c0.81,-0.03,1.53,0.3,1.92,0.87l0.12,0.18l0.09,-0.09c0.57,-0.45,1.41,-0.84,2.19,-0.96z"
	    },
	    "s": {
	        "w": 6.632,
	        "h": 8.758,
	        "d": "M4.47,-8.73c0.09,0,0.36,-0.03,0.57,-0.03c0.75,0.03,1.29,0.24,1.71,0.63c0.51,0.54,0.66,1.26,0.36,1.83c-0.24,0.42,-0.63,0.57,-1.11,0.42c-0.33,-0.09,-0.6,-0.36,-0.6,-0.57c0,-0.03,0.06,-0.21,0.15,-0.39c0.12,-0.21,0.15,-0.33,0.18,-0.48c0,-0.24,-0.06,-0.48,-0.15,-0.6c-0.15,-0.21,-0.42,-0.24,-0.75,-0.15c-0.27,0.06,-0.48,0.18,-0.69,0.36c-0.39,0.39,-0.51,0.96,-0.33,1.38c0.09,0.21,0.42,0.51,0.78,0.72c1.11,0.69,1.59,1.11,1.89,1.68c0.21,0.39,0.24,0.78,0.15,1.29c-0.18,1.2,-1.17,2.16,-2.52,2.52c-1.02,0.24,-1.95,0.12,-2.7,-0.42c-0.72,-0.51,-0.99,-1.47,-0.6,-2.19c0.24,-0.48,0.72,-0.63,1.17,-0.42c0.33,0.18,0.54,0.45,0.57,0.81c0,0.21,-0.03,0.3,-0.33,0.51c-0.33,0.24,-0.39,0.42,-0.27,0.69c0.06,0.15,0.21,0.27,0.45,0.33c0.3,0.09,0.87,0.09,1.2,0c0.75,-0.21,1.23,-0.72,1.29,-1.35c0.03,-0.42,-0.15,-0.81,-0.54,-1.2c-0.24,-0.24,-0.48,-0.42,-1.41,-1.02c-0.69,-0.42,-1.05,-0.93,-1.05,-1.47c0,-0.39,0.12,-0.87,0.3,-1.23c0.27,-0.57,0.78,-1.05,1.38,-1.35c0.24,-0.12,0.63,-0.27,0.9,-0.3z"
	    },
	    "z": {
	        "w": 8.573,
	        "h": 8.743,
	        "d": "M2.64,-7.95c0.36,-0.09,0.81,-0.03,1.71,0.27c0.78,0.21,0.96,0.27,1.74,0.3c0.87,0.06,1.02,0.03,1.38,-0.21c0.21,-0.15,0.33,-0.15,0.48,-0.06c0.15,0.09,0.21,0.3,0.15,0.45c-0.03,0.06,-1.26,1.26,-2.76,2.67l-2.73,2.55l0.54,0.03c0.54,0.03,0.72,0.03,2.01,0.15c0.36,0.03,0.9,0.06,1.2,0.09c0.66,0,0.81,-0.03,1.02,-0.24c0.3,-0.3,0.39,-0.72,0.27,-1.23c-0.06,-0.27,-0.06,-0.27,-0.03,-0.39c0.15,-0.3,0.54,-0.27,0.69,0.03c0.15,0.33,0.27,1.02,0.27,1.5c0,1.47,-1.11,2.7,-2.52,2.79c-0.57,0.03,-1.02,-0.09,-2.01,-0.51c-1.02,-0.42,-1.23,-0.48,-2.13,-0.54c-0.81,-0.06,-0.96,-0.03,-1.26,0.18c-0.12,0.06,-0.24,0.12,-0.27,0.12c-0.27,0,-0.45,-0.3,-0.36,-0.51c0.03,-0.06,1.32,-1.32,2.91,-2.79l2.88,-2.73c-0.03,0,-0.21,0.03,-0.42,0.06c-0.21,0.03,-0.78,0.09,-1.23,0.12c-1.11,0.12,-1.23,0.15,-1.95,0.27c-0.72,0.15,-1.17,0.18,-1.29,0.09c-0.27,-0.18,-0.21,-0.75,0.12,-1.26c0.39,-0.6,0.93,-1.02,1.59,-1.2z"
	    },
	    "+": {
	        "w": 7.507,
	        "h": 7.515,
	        "d": "M3.48,-11.19c0.18,-0.09,0.36,-0.09,0.54,0c0.18,0.09,0.24,0.15,0.33,0.3l0.06,0.15l0,1.29l0,1.29l1.29,0c1.23,0,1.29,0,1.41,0.06c0.06,0.03,0.15,0.09,0.18,0.12c0.12,0.09,0.21,0.33,0.21,0.48c0,0.15,-0.09,0.39,-0.21,0.48c-0.03,0.03,-0.12,0.09,-0.18,0.12c-0.12,0.06,-0.18,0.06,-1.41,0.06l-1.29,0l0,1.29c0,1.23,0,1.29,-0.06,1.41c-0.09,0.18,-0.15,0.24,-0.3,0.33c-0.21,0.09,-0.39,0.09,-0.57,0c-0.18,-0.09,-0.24,-0.15,-0.33,-0.33c-0.06,-0.12,-0.06,-0.18,-0.06,-1.41l0,-1.29l-1.29,0c-1.23,0,-1.29,0,-1.41,-0.06c-0.18,-0.09,-0.24,-0.15,-0.33,-0.33c-0.09,-0.18,-0.09,-0.36,0,-0.54c0.09,-0.18,0.15,-0.24,0.33,-0.33l0.15,-0.06l1.26,0l1.29,0l0,-1.29c0,-1.23,0,-1.29,0.06,-1.41c0.09,-0.18,0.15,-0.24,0.33,-0.33z"
	    },
	    ",": {
	        "w": 3.452,
	        "h": 8.143,
	        "d": "M1.32,-3.36c0.57,-0.15,1.17,0.03,1.59,0.45c0.45,0.45,0.6,0.96,0.51,1.89c-0.09,1.23,-0.42,2.46,-0.99,3.93c-0.3,0.72,-0.72,1.62,-0.78,1.68c-0.18,0.21,-0.51,0.18,-0.66,-0.06c-0.03,-0.06,-0.06,-0.15,-0.06,-0.18c0,-0.06,0.12,-0.33,0.24,-0.63c0.84,-1.8,1.02,-2.61,0.69,-3.24c-0.12,-0.24,-0.27,-0.36,-0.75,-0.6c-0.36,-0.15,-0.42,-0.21,-0.6,-0.39c-0.69,-0.69,-0.69,-1.71,0,-2.4c0.21,-0.21,0.51,-0.39,0.81,-0.45z"
	    },
	    "-": {
	        "w": 5.001,
	        "h": 0.81,
	        "d": "M0.18,-5.34c0.09,-0.06,0.15,-0.06,2.31,-0.06c2.46,0,2.37,0,2.46,0.21c0.12,0.21,0.03,0.42,-0.15,0.54c-0.09,0.06,-0.15,0.06,-2.28,0.06c-2.16,0,-2.22,0,-2.31,-0.06c-0.27,-0.15,-0.27,-0.54,-0.03,-0.69z"
	    },
	    ".": {
	        "w": 3.413,
	        "h": 3.402,
	        "d": "M1.32,-3.36c1.05,-0.27,2.1,0.57,2.1,1.65c0,1.08,-1.05,1.92,-2.1,1.65c-0.9,-0.21,-1.5,-1.14,-1.26,-2.04c0.12,-0.63,0.63,-1.11,1.26,-1.26z"
	    }
	};

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;;(function(root, factory) {
	
	  // Support AMD
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	
	  // Support CommonJS
	  } else if (typeof exports === 'object') {
	    var randomColor = factory();
	    
	    // Support NodeJS & Component, which allow module.exports to be a function
	    if (typeof module === 'object' && module && module.exports) {
	      exports = module.exports = randomColor;
	    }
	    
	    // Support CommonJS 1.1.1 spec
	    exports.randomColor = randomColor;
	  
	  // Support vanilla script loading
	  } else {
	    root.randomColor = factory();
	  };
	
	}(this, function() {
	
	  // Shared color dictionary
	  var colorDictionary = {};
	
	  // Populate the color dictionary
	  loadColorBounds();
	
	  var randomColor = function(options) {
	    options = options || {};
	
	    var H,S,B;
	
	    // Check if we need to generate multiple colors
	    if (options.count) {
	
	      var totalColors = options.count,
	          colors = [];
	
	      options.count = false;
	
	      while (totalColors > colors.length) {
	        colors.push(randomColor(options));
	      }
	
	      return colors;
	    }
	
	    // First we pick a hue (H)
	    H = pickHue(options);
	
	    // Then use H to determine saturation (S)
	    S = pickSaturation(H, options);
	
	    // Then use S and H to determine brightness (B).
	    B = pickBrightness(H, S, options);
	
	    // Then we return the HSB color in the desired format
	    return setFormat([H,S,B], options);
	  };
	
	  function pickHue (options) {
	
	    var hueRange = getHueRange(options.hue),
	        hue = randomWithin(hueRange);
	
	    // Instead of storing red as two seperate ranges,
	    // we group them, using negative numbers
	    if (hue < 0) {hue = 360 + hue}
	
	    return hue;
	
	  }
	
	  function pickSaturation (hue, options) {
	
	    if (options.luminosity === 'random') {
	      return randomWithin([0,100]);
	    }
	
	    if (options.hue === 'monochrome') {
	      return 0;
	    }
	
	    var saturationRange = getSaturationRange(hue);
	
	    var sMin = saturationRange[0],
	        sMax = saturationRange[1];
	
	    switch (options.luminosity) {
	
	      case 'bright':
	        sMin = 55;
	        break;
	
	      case 'dark':
	        sMin = sMax - 10;
	        break;
	
	      case 'light':
	        sMax = 55;
	        break;
	   }
	
	    return randomWithin([sMin, sMax]);
	
	  }
	
	  function pickBrightness (H, S, options) {
	
	    var brightness,
	        bMin = getMinimumBrightness(H, S),
	        bMax = 100;
	
	    switch (options.luminosity) {
	
	      case 'dark':
	        bMax = bMin + 20;
	        break;
	
	      case 'light':
	        bMin = (bMax + bMin)/2;
	        break;
	
	      case 'random':
	        bMin = 0;
	        bMax = 100;
	        break;
	    }
	
	    return randomWithin([bMin, bMax]);
	
	  }
	
	  function setFormat (hsv, options) {
	
	    switch (options.format) {
	
	      case 'hsvArray':
	        return hsv;
	
	      case 'hsv':
	        return colorString('hsv', hsv);
	
	      case 'rgbArray':
	        return HSVtoRGB(hsv);
	
	      case 'rgb':
	        return colorString('rgb', HSVtoRGB(hsv));
	
	      default:
	        return HSVtoHex(hsv);
	    }
	
	  }
	
	  function getMinimumBrightness(H, S) {
	
	    var lowerBounds = getColorInfo(H).lowerBounds;
	
	    for (var i = 0; i < lowerBounds.length - 1; i++) {
	
	      var s1 = lowerBounds[i][0],
	          v1 = lowerBounds[i][1];
	
	      var s2 = lowerBounds[i+1][0],
	          v2 = lowerBounds[i+1][1];
	
	      if (S >= s1 && S <= s2) {
	
	         var m = (v2 - v1)/(s2 - s1),
	             b = v1 - m*s1;
	
	         return m*S + b;
	      }
	
	    }
	
	    return 0;
	  }
	
	  function getHueRange (colorInput) {
	
	    if (typeof parseInt(colorInput) === 'number') {
	
	      var number = parseInt(colorInput);
	
	      if (number < 360 && number > 0) {
	        return [number, number];
	      }
	
	    }
	
	    if (typeof colorInput === 'string') {
	
	      if (colorDictionary[colorInput]) {
	        var color = colorDictionary[colorInput];
	        if (color.hueRange) {return color.hueRange}
	      }
	    }
	
	    return [0,360];
	
	  }
	
	  function getSaturationRange (hue) {
	    return getColorInfo(hue).saturationRange;
	  }
	
	  function getColorInfo (hue) {
	
	    // Maps red colors to make picking hue easier
	    if (hue >= 334 && hue <= 360) {
	      hue-= 360;
	    }
	
	    for (var colorName in colorDictionary) {
	       var color = colorDictionary[colorName];
	       if (color.hueRange &&
	           hue >= color.hueRange[0] &&
	           hue <= color.hueRange[1]) {
	          return colorDictionary[colorName];
	       }
	    } return 'Color not found';
	  }
	
	  function randomWithin (range) {
	    return Math.floor(range[0] + Math.random()*(range[1] + 1 - range[0]));
	  }
	
	  function shiftHue (h, degrees) {
	    return (h + degrees)%360;
	  }
	
	  function HSVtoHex (hsv){
	
	    var rgb = HSVtoRGB(hsv);
	
	    function componentToHex(c) {
	        var hex = c.toString(16);
	        return hex.length == 1 ? "0" + hex : hex;
	    }
	
	    var hex = "#" + componentToHex(rgb[0]) + componentToHex(rgb[1]) + componentToHex(rgb[2]);
	
	    return hex;
	
	  }
	
	  function defineColor (name, hueRange, lowerBounds) {
	
	    var sMin = lowerBounds[0][0],
	        sMax = lowerBounds[lowerBounds.length - 1][0],
	
	        bMin = lowerBounds[lowerBounds.length - 1][1],
	        bMax = lowerBounds[0][1];
	
	    colorDictionary[name] = {
	      hueRange: hueRange,
	      lowerBounds: lowerBounds,
	      saturationRange: [sMin, sMax],
	      brightnessRange: [bMin, bMax]
	    };
	
	  }
	
	  function loadColorBounds () {
	
	    defineColor(
	      'monochrome',
	      null,
	      [[0,0],[100,0]]
	    );
	
	    defineColor(
	      'red',
	      [-26,18],
	      [[20,100],[30,92],[40,89],[50,85],[60,78],[70,70],[80,60],[90,55],[100,50]]
	    );
	
	    defineColor(
	      'orange',
	      [19,46],
	      [[20,100],[30,93],[40,88],[50,86],[60,85],[70,70],[100,70]]
	    );
	
	    defineColor(
	      'yellow',
	      [47,62],
	      [[25,100],[40,94],[50,89],[60,86],[70,84],[80,82],[90,80],[100,75]]
	    );
	
	    defineColor(
	      'green',
	      [63,158],
	      [[30,100],[40,90],[50,85],[60,81],[70,74],[80,64],[90,50],[100,40]]
	    );
	
	    defineColor(
	      'blue',
	      [159, 257],
	      [[20,100],[30,86],[40,80],[50,74],[60,60],[70,52],[80,44],[90,39],[100,35]]
	    );
	
	    defineColor(
	      'purple',
	      [258, 282],
	      [[20,100],[30,87],[40,79],[50,70],[60,65],[70,59],[80,52],[90,45],[100,42]]
	    );
	
	    defineColor(
	      'pink',
	      [283, 334],
	      [[20,100],[30,90],[40,86],[60,84],[80,80],[90,75],[100,73]]
	    );
	
	  }
	
	  function HSVtoRGB (hsv) {
	
	    // this doesn't work for the values of 0 and 360
	    // here's the hacky fix
	    var h = hsv[0];
	    if (h === 0) {h = 1}
	    if (h === 360) {h = 359}
	
	    // Rebase the h,s,v values
	    h = h/360;
	    var s = hsv[1]/100,
	        v = hsv[2]/100;
	
	    var h_i = Math.floor(h*6),
	      f = h * 6 - h_i,
	      p = v * (1 - s),
	      q = v * (1 - f*s),
	      t = v * (1 - (1 - f)*s),
	      r = 256,
	      g = 256,
	      b = 256;
	
	    switch(h_i) {
	      case 0: r = v, g = t, b = p;  break;
	      case 1: r = q, g = v, b = p;  break;
	      case 2: r = p, g = v, b = t;  break;
	      case 3: r = p, g = q, b = v;  break;
	      case 4: r = t, g = p, b = v;  break;
	      case 5: r = v, g = p, b = q;  break;
	    }
	    var result = [Math.floor(r*255), Math.floor(g*255), Math.floor(b*255)];
	    return result;
	  }
	
	  function colorString (prefix, values) {
	    return prefix + '(' + values.join(', ') + ')';
	  }
	
	  return randomColor;
	}));

/***/ }
]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9lbmdpbmUvdmVuZG9yLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2Rpc3QvbG9kYXNoLmNvbXBhdC5qcyIsIndlYnBhY2s6Ly8vLi9yb3V0ZXMvY29uZmlnLnJvdXRlLmpzIiwid2VicGFjazovLy8uL34vdG9hc3RyL3RvYXN0ci5qcyIsIndlYnBhY2s6Ly8vLi9+L2xleC9sZXhlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhY3RpdmUvcmFjdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3N2Zy5qcy9kaXN0L3N2Zy5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4L2Rpc3QvcnguYWxsLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vYXBwL2VkaXRvci9lZGl0b3IuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2FtZC1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vYXBwL2hvbWUvaG9tZS5qcyIsIndlYnBhY2s6Ly8vLi9lbmdpbmUvZW5naW5lLmpzIiwid2VicGFjazovLy8uL2VuZ2luZS9kaXNwYXRjaGVyLmpzIiwid2VicGFjazovLy8uL2FwcC9lZGl0b3IvZWRpdG9yLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYXBwL2hvbWUvaG9tZS5odG1sIiwid2VicGFjazovLy8uL2VuZ2luZS9zY3JpcHRzL3J4LmhlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9lbmdpbmUvc2NyaXB0cy9hZGFwdG9ycy9yYWN0aXZlLWFkYXB0b3JzLXJ4anMuanMiLCJ3ZWJwYWNrOi8vLy4vZW5naW5lL3NjcmlwdHMvdHJhbnNpdGlvbnMvcmFjdGl2ZS50cmFuc2l0aW9ucy5mYWRlLmpzIiwid2VicGFjazovLy8uL2VuZ2luZS9zY3JpcHRzL3RyYW5zaXRpb25zL3JhY3RpdmUudHJhbnNpdGlvbnMuZmx5LmpzIiwid2VicGFjazovLy8od2VicGFjaykvfi9ub2RlLWxpYnMtYnJvd3Nlci9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9lbmdpbmUvcGFyc2VyLmpzIiwid2VicGFjazovLy8uL2VuZ2luZS9yZW5kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZW5naW5lL2RpZmYuanMiLCJ3ZWJwYWNrOi8vLy4vZW5naW5lL3R5cGVzLmpzIiwid2VicGFjazovLy8uL2VuZ2luZS9kYXRhX3RhYmxlcy5qcyIsIndlYnBhY2s6Ly8vLi9lbmdpbmUvbGV4ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZW5naW5lL3JlbmRlcmluZy9zdGF2ZV9zeW1ib2xzLmpzIiwid2VicGFjazovLy8uL2VuZ2luZS9yZW5kZXJpbmcvZGF0YV9maWVsZHMuanMiLCJ3ZWJwYWNrOi8vLy4vZW5naW5lL3JlbmRlcmluZy9nbHlwaHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW5kb21jb2xvci9yYW5kb21Db2xvci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHOzs7Ozs7bUNDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBMkM7QUFDM0M7QUFDQSw0REFBMkQ7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCLE1BQU0sYUFBYSxPQUFPOztBQUVwRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLE1BQU07QUFDbkIsY0FBYSxFQUFFO0FBQ2YsY0FBYSxPQUFPO0FBQ3BCLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsT0FBTztBQUNwQixjQUFhLEVBQUU7QUFDZixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXNEOztBQUV0RDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLE9BQU87QUFDcEIsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCLGNBQWEsT0FBTztBQUNwQixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsTUFBTTtBQUNuQixnQkFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLE9BQU87QUFDcEIsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsRUFBRTtBQUNmLGdCQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsb0JBQW9CO0FBQ2pDLGNBQWEsT0FBTztBQUNwQixjQUFhLE9BQU87QUFDcEIsZ0JBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLE9BQU87QUFDcEIsZ0JBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQjtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0EsUUFBTyxXQUFXO0FBQ2xCO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUZBQXNGO0FBQ3RGLDREQUEyRDtBQUMzRCx1RkFBc0Y7QUFDdEYsa0NBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsRUFBRTtBQUNqQixrQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsRUFBRTtBQUNqQixnQkFBZSxRQUFRO0FBQ3ZCLGtCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBNkIsWUFBWSxFQUFFO0FBQzNDLHFCQUFvQixzQkFBc0I7QUFDMUM7O0FBRUEseUJBQXdCO0FBQ3hCLGtDQUFpQyxpQkFBaUI7QUFDbEQsK0JBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTJFLGdCQUFnQjtBQUMzRixRQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixrQkFBaUIsT0FBTztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUSwrQkFBK0I7QUFDdkM7QUFDQSxTQUFRO0FBQ1I7QUFDQSw4Q0FBNkMsWUFBWTtBQUN6RDtBQUNBLFdBQVU7QUFDVjtBQUNBLDRDQUEyQywwQ0FBMEM7QUFDckY7QUFDQSw2Q0FBNEM7QUFDNUM7QUFDQSxTQUFRLEtBQUssR0FBRyxRQUFRO0FBQ3hCLFNBQVE7QUFDUixnREFBK0MsWUFBWSwwQ0FBMEMsZ0NBQWdDLHNCQUFzQjtBQUMzSjtBQUNBLFNBQVEsT0FBTyxLQUFLLE9BQU87QUFDM0I7O0FBRUE7QUFDQSxtRUFBa0U7QUFDbEU7O0FBRUE7QUFDQSw2RkFBNEY7QUFDNUY7O0FBRUEsK0JBQThCLGlDQUFpQyx5REFBeUQsRUFBRSxrQ0FBa0MsaUZBQWlGOztBQUU3TztBQUNBLHVKQUFzSixtQ0FBbUMsaUNBQWlDO0FBQzFOO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQSxzQkFBcUI7QUFDckI7QUFDQSxvQkFBbUI7QUFDbkIsU0FBUTtBQUNSLDRDQUEyQztBQUMzQyw0QkFBMkIseURBQXlELEVBQUU7QUFDdEY7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQSxzQkFBcUI7QUFDckI7QUFDQSxvQkFBbUI7QUFDbkI7QUFDQSxvREFBbUQsMFFBQTBRO0FBQzdULG1CQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0EsU0FBUSxPQUFPO0FBQ2Y7QUFDQSxvQkFBbUI7QUFDbkI7O0FBRUE7O0FBRUE7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsU0FBUTs7QUFFUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCLGtCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsRUFBRTtBQUNqQixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLFNBQVM7QUFDeEIsZ0JBQWUsTUFBTTtBQUNyQixnQkFBZSxNQUFNO0FBQ3JCLGtCQUFpQixFQUFFO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGtCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxFQUFFO0FBQ2pCLGdCQUFlLEVBQUU7QUFDakIsZ0JBQWUsT0FBTztBQUN0QixrQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCLGtCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckIsZ0JBQWUsTUFBTTtBQUNyQixrQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckIsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLE9BQU87QUFDdEIsa0JBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxFQUFFO0FBQ2pCLGdCQUFlLEVBQUU7QUFDakIsZ0JBQWUsU0FBUztBQUN4QixnQkFBZSxTQUFTO0FBQ3hCLGdCQUFlLE1BQU07QUFDckIsZ0JBQWUsTUFBTTtBQUNyQixrQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLFNBQVM7QUFDeEIsZ0JBQWUsTUFBTTtBQUNyQixnQkFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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VTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsRUFBRTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLE1BQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7Ozs7Ozs7O0FDcC9ORDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFFQTtBQUNBLDZCQUE0QjtBQUM1QixrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVU7QUFDVixVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUSxHQUFHO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSw2QkFBNkI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSx3QkFBd0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsd0JBQXdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCO0FBQzVCO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNEI7QUFDNUI7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixxREFBcUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBLGtDQUFpQyxVQUFVLEVBQUUsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFxRSxFQUFFLGNBQWMsRUFBRTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFpRDtBQUNqRDtBQUNBLGdDQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjLGlFQUFpRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBdUQsT0FBTyxLQUFLO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTRELFdBQVc7QUFDdkU7QUFDQSxXQUFVLGFBQWEsU0FBUyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWlDLHdCQUF3QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxXQUFVLE1BQU07QUFDaEI7QUFDQSxlQUFjLE1BQU0sY0FBYztBQUNsQztBQUNBLHlCQUF3QixNQUFNLGtCQUFrQixTQUFTO0FBQ3pELFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlHQUF3RztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUEsdUNBQXNDLEdBQUc7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNEIsS0FBSyxLQUFLO0FBQ3RDLHFDQUFvQyxLQUFLLEtBQUs7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0Esa0NBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBLG1DQUFrQyxHQUFHO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUEscUNBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1AsUUFBTztBQUNQO0FBQ0E7QUFDQSxTQUFRO0FBQ1IsU0FBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFtRCxjQUFjO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0EsMkJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUErQixRQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxTQUFTO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQLE9BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXVDLDRDQUE0QztBQUNuRjtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBLFdBQVUsZUFBZTtBQUN6QjtBQUNBO0FBQ0EsV0FBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQSx5QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsSUFBSTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWMsc0JBQXNCO0FBQ3BDLEtBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQWtDLDRCQUE0QiwrQkFBK0I7QUFDN0Y7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsaURBQWlEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsS0FBSTtBQUNKO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QixlQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsK0JBQThCLFlBQVk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLHlCQUF3QixLQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsc0RBQXNEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXFDLDBCQUEwQix5QkFBeUI7QUFDeEY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0EsOEJBQTZCLFVBQVU7QUFDdkM7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0EsS0FBSTtBQUNKO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0IsS0FBSztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxvQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQixzQkFBc0I7QUFDMUM7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0Esb0JBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTCxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTixNQUFLO0FBQ0w7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUEsd0xBQXVMO0FBQ3ZMO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1IsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTixNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSx1QkFBc0I7QUFDdEI7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW1ELE1BQU07QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQLE9BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQSxpREFBZ0QsS0FBSztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBLGdEQUErQyxVQUFVO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFxQyxVQUFVO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsYUFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsaUVBQWdFLE9BQU87QUFDdkU7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBcUMsWUFBWSxLQUFLLFVBQVU7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXVEO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF1RCxLQUFLO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSixJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBcUIsS0FBSyxLQUFLO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTBDO0FBQzFDO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULFNBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNO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QUNoQjtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1IsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBQzs7Ozs7OzttRUMxZ2NEO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUNBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFrQyxlQUFlLFVBQVUsU0FBUztBQUNwRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF1QyxJQUFJOztBQUUzQztBQUNBLGdDQUErQixFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUU7O0FBRXpEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtCQUE4QixJQUFJOztBQUVsQztBQUNBOztBQUVBO0FBQ0EsNkJBQTRCLEdBQUc7O0FBRS9CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQSxJQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF3RCxRQUFRO0FBQ2hFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwREFBeUQsUUFBUTtBQUNqRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUc7Ozs7QUFJSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUF5RCxRQUFRO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBEQUF5RCxRQUFRO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseURBQXdELFFBQVE7QUFDaEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBMkMsUUFBUTtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUE4QyxRQUFRO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFXO0FBQ1g7O0FBRUEsWUFBVztBQUNYOztBQUVBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXFDLFFBQVE7QUFDN0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFVBQVM7QUFDVDs7QUFFQSxVQUFTO0FBQ1Q7O0FBRUEsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMEMsUUFBUTtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFnQyxRQUFRO0FBQ3hDOztBQUVBOztBQUVBLFVBQVM7QUFDVDtBQUNBOztBQUVBLFVBQVM7QUFDVDtBQUNBOztBQUVBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBUztBQUNUO0FBQ0E7O0FBRUEsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBLFlBQVc7QUFDWDtBQUNBLDJCQUEwQjs7QUFFMUI7QUFDQSw0QkFBMkIsY0FBYztBQUN6QztBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQXlDLFFBQVE7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFnRCxRQUFRO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBb0MsUUFBUTtBQUM1Qzs7QUFFQTtBQUNBLHFDQUFvQyxRQUFRO0FBQzVDOztBQUVBO0FBQ0EscUNBQW9DLFFBQVE7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCLHFCQUFxQjtBQUM5QyxjQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUI7QUFDbkI7QUFDQTs7QUFFQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLFlBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBNkI7O0FBRTdCLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFnQztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSCxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBb0Isa0NBQWtDOztBQUV0RDtBQUNBOztBQUVBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUIsK0NBQStDO0FBQ3BFLHNCQUFxQiwrQ0FBK0M7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUIsK0NBQStDO0FBQ3BFLHNCQUFxQiwrQ0FBK0M7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUEsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsK0RBQStEO0FBQzlFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBc0MsK0JBQStCOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBMkMsUUFBUTtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXOztBQUVYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBcUMsUUFBUTtBQUM3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw4QkFBNkIsWUFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EseUJBQXdCLG9CQUFvQjtBQUM1Qzs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFHOzs7O0FBSUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQXlDLFFBQVE7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBaUQsUUFBUTtBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBaUQsUUFBUTtBQUN6RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0RBQXFELFFBQVE7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBTztBQUNQO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTBDLFFBQVE7QUFDbEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQStDO0FBQy9DOztBQUVBLElBQUc7O0FBRUg7QUFDQSxtREFBdUIsYUFBYTtBQUNwQztBQUNBOztBQUVBLDBCO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTBDLFFBQVE7QUFDbEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFD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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCOztBQUVsQjtBQUNBLG9CQUFtQiwwQkFBMEI7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLG9CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTRDLFFBQVE7QUFDcEQ7QUFDQSwwQ0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTRDLFFB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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFDLEc7Ozs7OztBQ3RHRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxlQUFlO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsRUFBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFDLEc7Ozs7OztBQ3BHRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsRUFBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVB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QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTRCLHVCQUF1QjtBQUNuRCxPQUFNO0FBQ04sRzs7Ozs7O0FDN0VBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEc7Ozs7OztBQ3BCQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Qjs7Ozs7O0FDdEZBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUEsRUFBQyxZQUFZO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsRUFBQyxZQUFZO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7O0FBSUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxxQ0FBb0MsbUJBQW1CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRzs7Ozs7O0FDck1BOztBQUVBLDJCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYLHVFQUFzRSxlQUFlO0FBQ3JGLE1BQUs7QUFDTCxvRUFBbUUsZUFBZTtBQUNsRixNQUFLO0FBQ0wscUVBQW9FLGVBQWU7QUFDbkY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYiwwRkFBeUYsZUFBZTtBQUN4RyxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsMEZBQXlGLGVBQWU7QUFDeEc7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBLGdEQUErQyxlQUFlO0FBQzlEOztBQUVBO0FBQ0EsMENBQXlDLGVBQWU7QUFDeEQ7O0FBRUEsb0M7Ozs7OztBQzlEQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRzs7Ozs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEc7Ozs7OztBQ25YQSxrR0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBLEVBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBa0I7O0FBRWxCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW1CLDRCQUE0Qjs7QUFFL0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCLHFCQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFrQztBQUNsQyxtQ0FBa0M7QUFDbEMsbUNBQWtDO0FBQ2xDLG1DQUFrQztBQUNsQyxtQ0FBa0M7QUFDbEMsbUNBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUMsRyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cdGxvZGFzaDogcmVxdWlyZSgnbG9kYXNoJyksXHJcblx0c3ZnanM6IHJlcXVpcmUoJ3N2Zy5qcycpLFxyXG5cdGxleDogcmVxdWlyZSgnbGV4JyksXHJcblx0UmFjdGl2ZTogcmVxdWlyZSgncmFjdGl2ZScpLFxyXG4gICAgdG9hc3RyOiByZXF1aXJlKCd0b2FzdHInKSxcclxuICAgIFJ4OiByZXF1aXJlKCdyeCcpLFxyXG4gICAganF1ZXJ5OiByZXF1aXJlKCdqcXVlcnknKVxyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9lbmdpbmUvdmVuZG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMVxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIiwiLyoqXG4gKiBAbGljZW5zZVxuICogTG8tRGFzaCAyLjQuMSAoQ3VzdG9tIEJ1aWxkKSA8aHR0cDovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggLW8gLi9kaXN0L2xvZGFzaC5jb21wYXQuanNgXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDEzIFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjUuMiA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTMgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cDovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuOyhmdW5jdGlvbigpIHtcblxuICAvKiogVXNlZCBhcyBhIHNhZmUgcmVmZXJlbmNlIGZvciBgdW5kZWZpbmVkYCBpbiBwcmUgRVM1IGVudmlyb25tZW50cyAqL1xuICB2YXIgdW5kZWZpbmVkO1xuXG4gIC8qKiBVc2VkIHRvIHBvb2wgYXJyYXlzIGFuZCBvYmplY3RzIHVzZWQgaW50ZXJuYWxseSAqL1xuICB2YXIgYXJyYXlQb29sID0gW10sXG4gICAgICBvYmplY3RQb29sID0gW107XG5cbiAgLyoqIFVzZWQgdG8gZ2VuZXJhdGUgdW5pcXVlIElEcyAqL1xuICB2YXIgaWRDb3VudGVyID0gMDtcblxuICAvKiogVXNlZCBpbnRlcm5hbGx5IHRvIGluZGljYXRlIHZhcmlvdXMgdGhpbmdzICovXG4gIHZhciBpbmRpY2F0b3JPYmplY3QgPSB7fTtcblxuICAvKiogVXNlZCB0byBwcmVmaXgga2V5cyB0byBhdm9pZCBpc3N1ZXMgd2l0aCBgX19wcm90b19fYCBhbmQgcHJvcGVydGllcyBvbiBgT2JqZWN0LnByb3RvdHlwZWAgKi9cbiAgdmFyIGtleVByZWZpeCA9ICtuZXcgRGF0ZSArICcnO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBzaXplIHdoZW4gb3B0aW1pemF0aW9ucyBhcmUgZW5hYmxlZCBmb3IgbGFyZ2UgYXJyYXlzICovXG4gIHZhciBsYXJnZUFycmF5U2l6ZSA9IDc1O1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBtYXggc2l6ZSBvZiB0aGUgYGFycmF5UG9vbGAgYW5kIGBvYmplY3RQb29sYCAqL1xuICB2YXIgbWF4UG9vbFNpemUgPSA0MDtcblxuICAvKiogVXNlZCB0byBkZXRlY3QgYW5kIHRlc3Qgd2hpdGVzcGFjZSAqL1xuICB2YXIgd2hpdGVzcGFjZSA9IChcbiAgICAvLyB3aGl0ZXNwYWNlXG4gICAgJyBcXHRcXHgwQlxcZlxceEEwXFx1ZmVmZicgK1xuXG4gICAgLy8gbGluZSB0ZXJtaW5hdG9yc1xuICAgICdcXG5cXHJcXHUyMDI4XFx1MjAyOScgK1xuXG4gICAgLy8gdW5pY29kZSBjYXRlZ29yeSBcIlpzXCIgc3BhY2Ugc2VwYXJhdG9yc1xuICAgICdcXHUxNjgwXFx1MTgwZVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwJ1xuICApO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGVtcHR5IHN0cmluZyBsaXRlcmFscyBpbiBjb21waWxlZCB0ZW1wbGF0ZSBzb3VyY2UgKi9cbiAgdmFyIHJlRW1wdHlTdHJpbmdMZWFkaW5nID0gL1xcYl9fcCBcXCs9ICcnOy9nLFxuICAgICAgcmVFbXB0eVN0cmluZ01pZGRsZSA9IC9cXGIoX19wIFxcKz0pICcnIFxcKy9nLFxuICAgICAgcmVFbXB0eVN0cmluZ1RyYWlsaW5nID0gLyhfX2VcXCguKj9cXCl8XFxiX190XFwpKSBcXCtcXG4nJzsvZztcblxuICAvKipcbiAgICogVXNlZCB0byBtYXRjaCBFUzYgdGVtcGxhdGUgZGVsaW1pdGVyc1xuICAgKiBodHRwOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1saXRlcmFscy1zdHJpbmctbGl0ZXJhbHNcbiAgICovXG4gIHZhciByZUVzVGVtcGxhdGUgPSAvXFwkXFx7KFteXFxcXH1dKig/OlxcXFwuW15cXFxcfV0qKSopXFx9L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggcmVnZXhwIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzICovXG4gIHZhciByZUZsYWdzID0gL1xcdyokLztcblxuICAvKiogVXNlZCB0byBkZXRlY3RlZCBuYW1lZCBmdW5jdGlvbnMgKi9cbiAgdmFyIHJlRnVuY05hbWUgPSAvXlxccypmdW5jdGlvblsgXFxuXFxyXFx0XStcXHcvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIFwiaW50ZXJwb2xhdGVcIiB0ZW1wbGF0ZSBkZWxpbWl0ZXJzICovXG4gIHZhciByZUludGVycG9sYXRlID0gLzwlPShbXFxzXFxTXSs/KSU+L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyB3aGl0ZXNwYWNlIGFuZCB6ZXJvcyB0byBiZSByZW1vdmVkICovXG4gIHZhciByZUxlYWRpbmdTcGFjZXNBbmRaZXJvcyA9IFJlZ0V4cCgnXlsnICsgd2hpdGVzcGFjZSArICddKjArKD89LiQpJyk7XG5cbiAgLyoqIFVzZWQgdG8gZW5zdXJlIGNhcHR1cmluZyBvcmRlciBvZiB0ZW1wbGF0ZSBkZWxpbWl0ZXJzICovXG4gIHZhciByZU5vTWF0Y2ggPSAvKCReKS87XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGZ1bmN0aW9ucyBjb250YWluaW5nIGEgYHRoaXNgIHJlZmVyZW5jZSAqL1xuICB2YXIgcmVUaGlzID0gL1xcYnRoaXNcXGIvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHVuZXNjYXBlZCBjaGFyYWN0ZXJzIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscyAqL1xuICB2YXIgcmVVbmVzY2FwZWRTdHJpbmcgPSAvWydcXG5cXHJcXHRcXHUyMDI4XFx1MjAyOVxcXFxdL2c7XG5cbiAgLyoqIFVzZWQgdG8gYXNzaWduIGRlZmF1bHQgYGNvbnRleHRgIG9iamVjdCBwcm9wZXJ0aWVzICovXG4gIHZhciBjb250ZXh0UHJvcHMgPSBbXG4gICAgJ0FycmF5JywgJ0Jvb2xlYW4nLCAnRGF0ZScsICdFcnJvcicsICdGdW5jdGlvbicsICdNYXRoJywgJ051bWJlcicsICdPYmplY3QnLFxuICAgICdSZWdFeHAnLCAnU3RyaW5nJywgJ18nLCAnYXR0YWNoRXZlbnQnLCAnY2xlYXJUaW1lb3V0JywgJ2lzRmluaXRlJywgJ2lzTmFOJyxcbiAgICAncGFyc2VJbnQnLCAnc2V0VGltZW91dCdcbiAgXTtcblxuICAvKiogVXNlZCB0byBmaXggdGhlIEpTY3JpcHQgW1tEb250RW51bV1dIGJ1ZyAqL1xuICB2YXIgc2hhZG93ZWRQcm9wcyA9IFtcbiAgICAnY29uc3RydWN0b3InLCAnaGFzT3duUHJvcGVydHknLCAnaXNQcm90b3R5cGVPZicsICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICAgJ3RvTG9jYWxlU3RyaW5nJywgJ3RvU3RyaW5nJywgJ3ZhbHVlT2YnXG4gIF07XG5cbiAgLyoqIFVzZWQgdG8gbWFrZSB0ZW1wbGF0ZSBzb3VyY2VVUkxzIGVhc2llciB0byBpZGVudGlmeSAqL1xuICB2YXIgdGVtcGxhdGVDb3VudGVyID0gMDtcblxuICAvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHNob3J0Y3V0cyAqL1xuICB2YXIgYXJnc0NsYXNzID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgICBhcnJheUNsYXNzID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICAgIGJvb2xDbGFzcyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICAgIGRhdGVDbGFzcyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICAgIGVycm9yQ2xhc3MgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgICAgZnVuY0NsYXNzID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICAgIG51bWJlckNsYXNzID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgICBvYmplY3RDbGFzcyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgICAgcmVnZXhwQ2xhc3MgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICAgIHN0cmluZ0NsYXNzID0gJ1tvYmplY3QgU3RyaW5nXSc7XG5cbiAgLyoqIFVzZWQgdG8gaWRlbnRpZnkgb2JqZWN0IGNsYXNzaWZpY2F0aW9ucyB0aGF0IGBfLmNsb25lYCBzdXBwb3J0cyAqL1xuICB2YXIgY2xvbmVhYmxlQ2xhc3NlcyA9IHt9O1xuICBjbG9uZWFibGVDbGFzc2VzW2Z1bmNDbGFzc10gPSBmYWxzZTtcbiAgY2xvbmVhYmxlQ2xhc3Nlc1thcmdzQ2xhc3NdID0gY2xvbmVhYmxlQ2xhc3Nlc1thcnJheUNsYXNzXSA9XG4gIGNsb25lYWJsZUNsYXNzZXNbYm9vbENsYXNzXSA9IGNsb25lYWJsZUNsYXNzZXNbZGF0ZUNsYXNzXSA9XG4gIGNsb25lYWJsZUNsYXNzZXNbbnVtYmVyQ2xhc3NdID0gY2xvbmVhYmxlQ2xhc3Nlc1tvYmplY3RDbGFzc10gPVxuICBjbG9uZWFibGVDbGFzc2VzW3JlZ2V4cENsYXNzXSA9IGNsb25lYWJsZUNsYXNzZXNbc3RyaW5nQ2xhc3NdID0gdHJ1ZTtcblxuICAvKiogVXNlZCBhcyBhbiBpbnRlcm5hbCBgXy5kZWJvdW5jZWAgb3B0aW9ucyBvYmplY3QgKi9cbiAgdmFyIGRlYm91bmNlT3B0aW9ucyA9IHtcbiAgICAnbGVhZGluZyc6IGZhbHNlLFxuICAgICdtYXhXYWl0JzogMCxcbiAgICAndHJhaWxpbmcnOiBmYWxzZVxuICB9O1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIGZvciBgX19iaW5kRGF0YV9fYCAqL1xuICB2YXIgZGVzY3JpcHRvciA9IHtcbiAgICAnY29uZmlndXJhYmxlJzogZmFsc2UsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBudWxsLFxuICAgICd3cml0YWJsZSc6IGZhbHNlXG4gIH07XG5cbiAgLyoqIFVzZWQgYXMgdGhlIGRhdGEgb2JqZWN0IGZvciBgaXRlcmF0b3JUZW1wbGF0ZWAgKi9cbiAgdmFyIGl0ZXJhdG9yRGF0YSA9IHtcbiAgICAnYXJncyc6ICcnLFxuICAgICdhcnJheSc6IG51bGwsXG4gICAgJ2JvdHRvbSc6ICcnLFxuICAgICdmaXJzdEFyZyc6ICcnLFxuICAgICdpbml0JzogJycsXG4gICAgJ2tleXMnOiBudWxsLFxuICAgICdsb29wJzogJycsXG4gICAgJ3NoYWRvd2VkUHJvcHMnOiBudWxsLFxuICAgICdzdXBwb3J0JzogbnVsbCxcbiAgICAndG9wJzogJycsXG4gICAgJ3VzZUhhcyc6IGZhbHNlXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIHZhbHVlcyBhcmUgb2YgdGhlIGxhbmd1YWdlIHR5cGUgT2JqZWN0ICovXG4gIHZhciBvYmplY3RUeXBlcyA9IHtcbiAgICAnYm9vbGVhbic6IGZhbHNlLFxuICAgICdmdW5jdGlvbic6IHRydWUsXG4gICAgJ29iamVjdCc6IHRydWUsXG4gICAgJ251bWJlcic6IGZhbHNlLFxuICAgICdzdHJpbmcnOiBmYWxzZSxcbiAgICAndW5kZWZpbmVkJzogZmFsc2VcbiAgfTtcblxuICAvKiogVXNlZCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscyAqL1xuICB2YXIgc3RyaW5nRXNjYXBlcyA9IHtcbiAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICBcIidcIjogXCInXCIsXG4gICAgJ1xcbic6ICduJyxcbiAgICAnXFxyJzogJ3InLFxuICAgICdcXHQnOiAndCcsXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xuICB9O1xuXG4gIC8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0ICovXG4gIHZhciByb290ID0gKG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdykgfHwgdGhpcztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgICovXG4gIHZhciBmcmVlRXhwb3J0cyA9IG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgICovXG4gIHZhciBmcmVlTW9kdWxlID0gb2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4gIC8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AgKi9cbiAgdmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHMgJiYgZnJlZUV4cG9ydHM7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcyBvciBCcm93c2VyaWZpZWQgY29kZSBhbmQgdXNlIGl0IGFzIGByb290YCAqL1xuICB2YXIgZnJlZUdsb2JhbCA9IG9iamVjdFR5cGVzW3R5cGVvZiBnbG9iYWxdICYmIGdsb2JhbDtcbiAgaWYgKGZyZWVHbG9iYWwgJiYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsKSkge1xuICAgIHJvb3QgPSBmcmVlR2xvYmFsO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYmluYXJ5IHNlYXJjaGVzXG4gICAqIG9yIGBmcm9tSW5kZXhgIGNvbnN0cmFpbnRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlIG9yIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgIHZhciBpbmRleCA9IChmcm9tSW5kZXggfHwgMCkgLSAxLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogQW4gaW1wbGVtZW50YXRpb24gb2YgYF8uY29udGFpbnNgIGZvciBjYWNoZSBvYmplY3RzIHRoYXQgbWltaWNzIHRoZSByZXR1cm5cbiAgICogc2lnbmF0dXJlIG9mIGBfLmluZGV4T2ZgIGJ5IHJldHVybmluZyBgMGAgaWYgdGhlIHZhbHVlIGlzIGZvdW5kLCBlbHNlIGAtMWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYDBgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGNhY2hlSW5kZXhPZihjYWNoZSwgdmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICBjYWNoZSA9IGNhY2hlLmNhY2hlO1xuXG4gICAgaWYgKHR5cGUgPT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgIHJldHVybiBjYWNoZVt2YWx1ZV0gPyAwIDogLTE7XG4gICAgfVxuICAgIGlmICh0eXBlICE9ICdudW1iZXInICYmIHR5cGUgIT0gJ3N0cmluZycpIHtcbiAgICAgIHR5cGUgPSAnb2JqZWN0JztcbiAgICB9XG4gICAgdmFyIGtleSA9IHR5cGUgPT0gJ251bWJlcicgPyB2YWx1ZSA6IGtleVByZWZpeCArIHZhbHVlO1xuICAgIGNhY2hlID0gKGNhY2hlID0gY2FjaGVbdHlwZV0pICYmIGNhY2hlW2tleV07XG5cbiAgICByZXR1cm4gdHlwZSA9PSAnb2JqZWN0J1xuICAgICAgPyAoY2FjaGUgJiYgYmFzZUluZGV4T2YoY2FjaGUsIHZhbHVlKSA+IC0xID8gMCA6IC0xKVxuICAgICAgOiAoY2FjaGUgPyAwIDogLTEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBnaXZlbiB2YWx1ZSB0byB0aGUgY29ycmVzcG9uZGluZyBjYWNoZSBvYmplY3QuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFkZCB0byB0aGUgY2FjaGUuXG4gICAqL1xuICBmdW5jdGlvbiBjYWNoZVB1c2godmFsdWUpIHtcbiAgICB2YXIgY2FjaGUgPSB0aGlzLmNhY2hlLFxuICAgICAgICB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG4gICAgaWYgKHR5cGUgPT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgIGNhY2hlW3ZhbHVlXSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlICE9ICdudW1iZXInICYmIHR5cGUgIT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHlwZSA9ICdvYmplY3QnO1xuICAgICAgfVxuICAgICAgdmFyIGtleSA9IHR5cGUgPT0gJ251bWJlcicgPyB2YWx1ZSA6IGtleVByZWZpeCArIHZhbHVlLFxuICAgICAgICAgIHR5cGVDYWNoZSA9IGNhY2hlW3R5cGVdIHx8IChjYWNoZVt0eXBlXSA9IHt9KTtcblxuICAgICAgaWYgKHR5cGUgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgKHR5cGVDYWNoZVtrZXldIHx8ICh0eXBlQ2FjaGVba2V5XSA9IFtdKSkucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlQ2FjaGVba2V5XSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8ubWF4YCBhbmQgYF8ubWluYCBhcyB0aGUgZGVmYXVsdCBjYWxsYmFjayB3aGVuIGEgZ2l2ZW5cbiAgICogY29sbGVjdGlvbiBpcyBhIHN0cmluZyB2YWx1ZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSBjaGFyYWN0ZXIgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29kZSB1bml0IG9mIGdpdmVuIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIGNoYXJBdENhbGxiYWNrKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLmNoYXJDb2RlQXQoMCk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgc29ydEJ5YCB0byBjb21wYXJlIHRyYW5zZm9ybWVkIGBjb2xsZWN0aW9uYCBlbGVtZW50cywgc3RhYmxlIHNvcnRpbmdcbiAgICogdGhlbSBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gY29tcGFyZSB0byBgYmAuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29tcGFyZSB0byBgYWAuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIG9mIGAxYCBvciBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gY29tcGFyZUFzY2VuZGluZyhhLCBiKSB7XG4gICAgdmFyIGFjID0gYS5jcml0ZXJpYSxcbiAgICAgICAgYmMgPSBiLmNyaXRlcmlhLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhYy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHZhbHVlID0gYWNbaW5kZXhdLFxuICAgICAgICAgIG90aGVyID0gYmNbaW5kZXhdO1xuXG4gICAgICBpZiAodmFsdWUgIT09IG90aGVyKSB7XG4gICAgICAgIGlmICh2YWx1ZSA+IG90aGVyIHx8IHR5cGVvZiB2YWx1ZSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA8IG90aGVyIHx8IHR5cGVvZiBvdGhlciA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBGaXhlcyBhbiBgQXJyYXkjc29ydGAgYnVnIGluIHRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgYXBwbGljYXRpb25zXG4gICAgLy8gdGhhdCBjYXVzZXMgaXQsIHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlcywgdG8gcmV0dXJuIHRoZSBzYW1lIHZhbHVlIGZvclxuICAgIC8vIGBhYCBhbmQgYGJgLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL3B1bGwvMTI0N1xuICAgIC8vXG4gICAgLy8gVGhpcyBhbHNvIGVuc3VyZXMgYSBzdGFibGUgc29ydCBpbiBWOCBhbmQgb3RoZXIgZW5naW5lcy5cbiAgICAvLyBTZWUgaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9OTBcbiAgICByZXR1cm4gYS5pbmRleCAtIGIuaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNhY2hlIG9iamVjdCB0byBvcHRpbWl6ZSBsaW5lYXIgc2VhcmNoZXMgb2YgbGFyZ2UgYXJyYXlzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAqIEByZXR1cm5zIHtudWxsfE9iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgb2JqZWN0IG9yIGBudWxsYCBpZiBjYWNoaW5nIHNob3VsZCBub3QgYmUgdXNlZC5cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUNhY2hlKGFycmF5KSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgZmlyc3QgPSBhcnJheVswXSxcbiAgICAgICAgbWlkID0gYXJyYXlbKGxlbmd0aCAvIDIpIHwgMF0sXG4gICAgICAgIGxhc3QgPSBhcnJheVtsZW5ndGggLSAxXTtcblxuICAgIGlmIChmaXJzdCAmJiB0eXBlb2YgZmlyc3QgPT0gJ29iamVjdCcgJiZcbiAgICAgICAgbWlkICYmIHR5cGVvZiBtaWQgPT0gJ29iamVjdCcgJiYgbGFzdCAmJiB0eXBlb2YgbGFzdCA9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgY2FjaGUgPSBnZXRPYmplY3QoKTtcbiAgICBjYWNoZVsnZmFsc2UnXSA9IGNhY2hlWydudWxsJ10gPSBjYWNoZVsndHJ1ZSddID0gY2FjaGVbJ3VuZGVmaW5lZCddID0gZmFsc2U7XG5cbiAgICB2YXIgcmVzdWx0ID0gZ2V0T2JqZWN0KCk7XG4gICAgcmVzdWx0LmFycmF5ID0gYXJyYXk7XG4gICAgcmVzdWx0LmNhY2hlID0gY2FjaGU7XG4gICAgcmVzdWx0LnB1c2ggPSBjYWNoZVB1c2g7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgcmVzdWx0LnB1c2goYXJyYXlbaW5kZXhdKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGB0ZW1wbGF0ZWAgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZFxuICAgKiBzdHJpbmcgbGl0ZXJhbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXRjaCBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIGVzY2FwZVN0cmluZ0NoYXIobWF0Y2gpIHtcbiAgICByZXR1cm4gJ1xcXFwnICsgc3RyaW5nRXNjYXBlc1ttYXRjaF07XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbiBhcnJheSBmcm9tIHRoZSBhcnJheSBwb29sIG9yIGNyZWF0ZXMgYSBuZXcgb25lIGlmIHRoZSBwb29sIGlzIGVtcHR5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBhcnJheSBmcm9tIHRoZSBwb29sLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0QXJyYXkoKSB7XG4gICAgcmV0dXJuIGFycmF5UG9vbC5wb3AoKSB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuIG9iamVjdCBmcm9tIHRoZSBvYmplY3QgcG9vbCBvciBjcmVhdGVzIGEgbmV3IG9uZSBpZiB0aGUgcG9vbCBpcyBlbXB0eS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIG9iamVjdCBmcm9tIHRoZSBwb29sLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0T2JqZWN0KCkge1xuICAgIHJldHVybiBvYmplY3RQb29sLnBvcCgpIHx8IHtcbiAgICAgICdhcnJheSc6IG51bGwsXG4gICAgICAnY2FjaGUnOiBudWxsLFxuICAgICAgJ2NyaXRlcmlhJzogbnVsbCxcbiAgICAgICdmYWxzZSc6IGZhbHNlLFxuICAgICAgJ2luZGV4JzogMCxcbiAgICAgICdudWxsJzogZmFsc2UsXG4gICAgICAnbnVtYmVyJzogbnVsbCxcbiAgICAgICdvYmplY3QnOiBudWxsLFxuICAgICAgJ3B1c2gnOiBudWxsLFxuICAgICAgJ3N0cmluZyc6IG51bGwsXG4gICAgICAndHJ1ZSc6IGZhbHNlLFxuICAgICAgJ3VuZGVmaW5lZCc6IGZhbHNlLFxuICAgICAgJ3ZhbHVlJzogbnVsbFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBET00gbm9kZSBpbiBJRSA8IDkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBET00gbm9kZSwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gaXNOb2RlKHZhbHVlKSB7XG4gICAgLy8gSUUgPCA5IHByZXNlbnRzIERPTSBub2RlcyBhcyBgT2JqZWN0YCBvYmplY3RzIGV4Y2VwdCB0aGV5IGhhdmUgYHRvU3RyaW5nYFxuICAgIC8vIG1ldGhvZHMgdGhhdCBhcmUgYHR5cGVvZmAgXCJzdHJpbmdcIiBhbmQgc3RpbGwgY2FuIGNvZXJjZSBub2RlcyB0byBzdHJpbmdzXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZS50b1N0cmluZyAhPSAnZnVuY3Rpb24nICYmIHR5cGVvZiAodmFsdWUgKyAnJykgPT0gJ3N0cmluZyc7XG4gIH1cblxuICAvKipcbiAgICogUmVsZWFzZXMgdGhlIGdpdmVuIGFycmF5IGJhY2sgdG8gdGhlIGFycmF5IHBvb2wuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIHJlbGVhc2UuXG4gICAqL1xuICBmdW5jdGlvbiByZWxlYXNlQXJyYXkoYXJyYXkpIHtcbiAgICBhcnJheS5sZW5ndGggPSAwO1xuICAgIGlmIChhcnJheVBvb2wubGVuZ3RoIDwgbWF4UG9vbFNpemUpIHtcbiAgICAgIGFycmF5UG9vbC5wdXNoKGFycmF5KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVsZWFzZXMgdGhlIGdpdmVuIG9iamVjdCBiYWNrIHRvIHRoZSBvYmplY3QgcG9vbC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcmVsZWFzZS5cbiAgICovXG4gIGZ1bmN0aW9uIHJlbGVhc2VPYmplY3Qob2JqZWN0KSB7XG4gICAgdmFyIGNhY2hlID0gb2JqZWN0LmNhY2hlO1xuICAgIGlmIChjYWNoZSkge1xuICAgICAgcmVsZWFzZU9iamVjdChjYWNoZSk7XG4gICAgfVxuICAgIG9iamVjdC5hcnJheSA9IG9iamVjdC5jYWNoZSA9IG9iamVjdC5jcml0ZXJpYSA9IG9iamVjdC5vYmplY3QgPSBvYmplY3QubnVtYmVyID0gb2JqZWN0LnN0cmluZyA9IG9iamVjdC52YWx1ZSA9IG51bGw7XG4gICAgaWYgKG9iamVjdFBvb2wubGVuZ3RoIDwgbWF4UG9vbFNpemUpIHtcbiAgICAgIG9iamVjdFBvb2wucHVzaChvYmplY3QpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTbGljZXMgdGhlIGBjb2xsZWN0aW9uYCBmcm9tIHRoZSBgc3RhcnRgIGluZGV4IHVwIHRvLCBidXQgbm90IGluY2x1ZGluZyxcbiAgICogdGhlIGBlbmRgIGluZGV4LlxuICAgKlxuICAgKiBOb3RlOiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgaW5zdGVhZCBvZiBgQXJyYXkjc2xpY2VgIHRvIHN1cHBvcnQgbm9kZSBsaXN0c1xuICAgKiBpbiBJRSA8IDkgYW5kIHRvIGVuc3VyZSBkZW5zZSBhcnJheXMgYXJlIHJldHVybmVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2xpY2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgaW5kZXguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBpbmRleC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBzbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgIHN0YXJ0IHx8IChzdGFydCA9IDApO1xuICAgIGlmICh0eXBlb2YgZW5kID09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlbmQgPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgfVxuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBlbmQgLSBzdGFydCB8fCAwLFxuICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGggPCAwID8gMCA6IGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IGFycmF5W3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgbG9kYXNoYCBmdW5jdGlvbiB1c2luZyB0aGUgZ2l2ZW4gY29udGV4dCBvYmplY3QuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHQ9cm9vdF0gVGhlIGNvbnRleHQgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gcnVuSW5Db250ZXh0KGNvbnRleHQpIHtcbiAgICAvLyBBdm9pZCBpc3N1ZXMgd2l0aCBzb21lIEVTMyBlbnZpcm9ubWVudHMgdGhhdCBhdHRlbXB0IHRvIHVzZSB2YWx1ZXMsIG5hbWVkXG4gICAgLy8gYWZ0ZXIgYnVpbHQtaW4gY29uc3RydWN0b3JzIGxpa2UgYE9iamVjdGAsIGZvciB0aGUgY3JlYXRpb24gb2YgbGl0ZXJhbHMuXG4gICAgLy8gRVM1IGNsZWFycyB0aGlzIHVwIGJ5IHN0YXRpbmcgdGhhdCBsaXRlcmFscyBtdXN0IHVzZSBidWlsdC1pbiBjb25zdHJ1Y3RvcnMuXG4gICAgLy8gU2VlIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTEuMS41LlxuICAgIGNvbnRleHQgPSBjb250ZXh0ID8gXy5kZWZhdWx0cyhyb290Lk9iamVjdCgpLCBjb250ZXh0LCBfLnBpY2socm9vdCwgY29udGV4dFByb3BzKSkgOiByb290O1xuXG4gICAgLyoqIE5hdGl2ZSBjb25zdHJ1Y3RvciByZWZlcmVuY2VzICovXG4gICAgdmFyIEFycmF5ID0gY29udGV4dC5BcnJheSxcbiAgICAgICAgQm9vbGVhbiA9IGNvbnRleHQuQm9vbGVhbixcbiAgICAgICAgRGF0ZSA9IGNvbnRleHQuRGF0ZSxcbiAgICAgICAgRXJyb3IgPSBjb250ZXh0LkVycm9yLFxuICAgICAgICBGdW5jdGlvbiA9IGNvbnRleHQuRnVuY3Rpb24sXG4gICAgICAgIE1hdGggPSBjb250ZXh0Lk1hdGgsXG4gICAgICAgIE51bWJlciA9IGNvbnRleHQuTnVtYmVyLFxuICAgICAgICBPYmplY3QgPSBjb250ZXh0Lk9iamVjdCxcbiAgICAgICAgUmVnRXhwID0gY29udGV4dC5SZWdFeHAsXG4gICAgICAgIFN0cmluZyA9IGNvbnRleHQuU3RyaW5nLFxuICAgICAgICBUeXBlRXJyb3IgPSBjb250ZXh0LlR5cGVFcnJvcjtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIGBBcnJheWAgbWV0aG9kIHJlZmVyZW5jZXMuXG4gICAgICpcbiAgICAgKiBOb3JtYWxseSBgQXJyYXkucHJvdG90eXBlYCB3b3VsZCBzdWZmaWNlLCBob3dldmVyLCB1c2luZyBhbiBhcnJheSBsaXRlcmFsXG4gICAgICogYXZvaWRzIGlzc3VlcyBpbiBOYXJ3aGFsLlxuICAgICAqL1xuICAgIHZhciBhcnJheVJlZiA9IFtdO1xuXG4gICAgLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyAqL1xuICAgIHZhciBlcnJvclByb3RvID0gRXJyb3IucHJvdG90eXBlLFxuICAgICAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgICAgIHN0cmluZ1Byb3RvID0gU3RyaW5nLnByb3RvdHlwZTtcblxuICAgIC8qKiBVc2VkIHRvIHJlc3RvcmUgdGhlIG9yaWdpbmFsIGBfYCByZWZlcmVuY2UgaW4gYG5vQ29uZmxpY3RgICovXG4gICAgdmFyIG9sZERhc2ggPSBjb250ZXh0Ll87XG5cbiAgICAvKiogVXNlZCB0byByZXNvbHZlIHRoZSBpbnRlcm5hbCBbW0NsYXNzXV0gb2YgdmFsdWVzICovXG4gICAgdmFyIHRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlICovXG4gICAgdmFyIHJlTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gICAgICBTdHJpbmcodG9TdHJpbmcpXG4gICAgICAgIC5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpXG4gICAgICAgIC5yZXBsYWNlKC90b1N0cmluZ3wgZm9yIFteXFxdXSsvZywgJy4qPycpICsgJyQnXG4gICAgKTtcblxuICAgIC8qKiBOYXRpdmUgbWV0aG9kIHNob3J0Y3V0cyAqL1xuICAgIHZhciBjZWlsID0gTWF0aC5jZWlsLFxuICAgICAgICBjbGVhclRpbWVvdXQgPSBjb250ZXh0LmNsZWFyVGltZW91dCxcbiAgICAgICAgZmxvb3IgPSBNYXRoLmZsb29yLFxuICAgICAgICBmblRvU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nLFxuICAgICAgICBnZXRQcm90b3R5cGVPZiA9IGlzTmF0aXZlKGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKSAmJiBnZXRQcm90b3R5cGVPZixcbiAgICAgICAgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgICAgcHVzaCA9IGFycmF5UmVmLnB1c2gsXG4gICAgICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gICAgICAgIHNldFRpbWVvdXQgPSBjb250ZXh0LnNldFRpbWVvdXQsXG4gICAgICAgIHNwbGljZSA9IGFycmF5UmVmLnNwbGljZSxcbiAgICAgICAgdW5zaGlmdCA9IGFycmF5UmVmLnVuc2hpZnQ7XG5cbiAgICAvKiogVXNlZCB0byBzZXQgbWV0YSBkYXRhIG9uIGZ1bmN0aW9ucyAqL1xuICAgIHZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgICAgIC8vIElFIDggb25seSBhY2NlcHRzIERPTSBlbGVtZW50c1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG8gPSB7fSxcbiAgICAgICAgICAgIGZ1bmMgPSBpc05hdGl2ZShmdW5jID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KSAmJiBmdW5jLFxuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYyhvLCBvLCBvKSAmJiBmdW5jO1xuICAgICAgfSBjYXRjaChlKSB7IH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSgpKTtcblxuICAgIC8qIE5hdGl2ZSBtZXRob2Qgc2hvcnRjdXRzIGZvciBtZXRob2RzIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzICovXG4gICAgdmFyIG5hdGl2ZUNyZWF0ZSA9IGlzTmF0aXZlKG5hdGl2ZUNyZWF0ZSA9IE9iamVjdC5jcmVhdGUpICYmIG5hdGl2ZUNyZWF0ZSxcbiAgICAgICAgbmF0aXZlSXNBcnJheSA9IGlzTmF0aXZlKG5hdGl2ZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KSAmJiBuYXRpdmVJc0FycmF5LFxuICAgICAgICBuYXRpdmVJc0Zpbml0ZSA9IGNvbnRleHQuaXNGaW5pdGUsXG4gICAgICAgIG5hdGl2ZUlzTmFOID0gY29udGV4dC5pc05hTixcbiAgICAgICAgbmF0aXZlS2V5cyA9IGlzTmF0aXZlKG5hdGl2ZUtleXMgPSBPYmplY3Qua2V5cykgJiYgbmF0aXZlS2V5cyxcbiAgICAgICAgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluLFxuICAgICAgICBuYXRpdmVQYXJzZUludCA9IGNvbnRleHQucGFyc2VJbnQsXG4gICAgICAgIG5hdGl2ZVJhbmRvbSA9IE1hdGgucmFuZG9tO1xuXG4gICAgLyoqIFVzZWQgdG8gbG9va3VwIGEgYnVpbHQtaW4gY29uc3RydWN0b3IgYnkgW1tDbGFzc11dICovXG4gICAgdmFyIGN0b3JCeUNsYXNzID0ge307XG4gICAgY3RvckJ5Q2xhc3NbYXJyYXlDbGFzc10gPSBBcnJheTtcbiAgICBjdG9yQnlDbGFzc1tib29sQ2xhc3NdID0gQm9vbGVhbjtcbiAgICBjdG9yQnlDbGFzc1tkYXRlQ2xhc3NdID0gRGF0ZTtcbiAgICBjdG9yQnlDbGFzc1tmdW5jQ2xhc3NdID0gRnVuY3Rpb247XG4gICAgY3RvckJ5Q2xhc3Nbb2JqZWN0Q2xhc3NdID0gT2JqZWN0O1xuICAgIGN0b3JCeUNsYXNzW251bWJlckNsYXNzXSA9IE51bWJlcjtcbiAgICBjdG9yQnlDbGFzc1tyZWdleHBDbGFzc10gPSBSZWdFeHA7XG4gICAgY3RvckJ5Q2xhc3Nbc3RyaW5nQ2xhc3NdID0gU3RyaW5nO1xuXG4gICAgLyoqIFVzZWQgdG8gYXZvaWQgaXRlcmF0aW5nIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgaW4gSUUgPCA5ICovXG4gICAgdmFyIG5vbkVudW1Qcm9wcyA9IHt9O1xuICAgIG5vbkVudW1Qcm9wc1thcnJheUNsYXNzXSA9IG5vbkVudW1Qcm9wc1tkYXRlQ2xhc3NdID0gbm9uRW51bVByb3BzW251bWJlckNsYXNzXSA9IHsgJ2NvbnN0cnVjdG9yJzogdHJ1ZSwgJ3RvTG9jYWxlU3RyaW5nJzogdHJ1ZSwgJ3RvU3RyaW5nJzogdHJ1ZSwgJ3ZhbHVlT2YnOiB0cnVlIH07XG4gICAgbm9uRW51bVByb3BzW2Jvb2xDbGFzc10gPSBub25FbnVtUHJvcHNbc3RyaW5nQ2xhc3NdID0geyAnY29uc3RydWN0b3InOiB0cnVlLCAndG9TdHJpbmcnOiB0cnVlLCAndmFsdWVPZic6IHRydWUgfTtcbiAgICBub25FbnVtUHJvcHNbZXJyb3JDbGFzc10gPSBub25FbnVtUHJvcHNbZnVuY0NsYXNzXSA9IG5vbkVudW1Qcm9wc1tyZWdleHBDbGFzc10gPSB7ICdjb25zdHJ1Y3Rvcic6IHRydWUsICd0b1N0cmluZyc6IHRydWUgfTtcbiAgICBub25FbnVtUHJvcHNbb2JqZWN0Q2xhc3NdID0geyAnY29uc3RydWN0b3InOiB0cnVlIH07XG5cbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gc2hhZG93ZWRQcm9wcy5sZW5ndGg7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGtleSA9IHNoYWRvd2VkUHJvcHNbbGVuZ3RoXTtcbiAgICAgICAgZm9yICh2YXIgY2xhc3NOYW1lIGluIG5vbkVudW1Qcm9wcykge1xuICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG5vbkVudW1Qcm9wcywgY2xhc3NOYW1lKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChub25FbnVtUHJvcHNbY2xhc3NOYW1lXSwga2V5KSkge1xuICAgICAgICAgICAgbm9uRW51bVByb3BzW2NsYXNzTmFtZV1ba2V5XSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0oKSk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCBvYmplY3Qgd2hpY2ggd3JhcHMgdGhlIGdpdmVuIHZhbHVlIHRvIGVuYWJsZSBpbnR1aXRpdmVcbiAgICAgKiBtZXRob2QgY2hhaW5pbmcuXG4gICAgICpcbiAgICAgKiBJbiBhZGRpdGlvbiB0byBMby1EYXNoIG1ldGhvZHMsIHdyYXBwZXJzIGFsc28gaGF2ZSB0aGUgZm9sbG93aW5nIGBBcnJheWAgbWV0aG9kczpcbiAgICAgKiBgY29uY2F0YCwgYGpvaW5gLCBgcG9wYCwgYHB1c2hgLCBgcmV2ZXJzZWAsIGBzaGlmdGAsIGBzbGljZWAsIGBzb3J0YCwgYHNwbGljZWAsXG4gICAgICogYW5kIGB1bnNoaWZ0YFxuICAgICAqXG4gICAgICogQ2hhaW5pbmcgaXMgc3VwcG9ydGVkIGluIGN1c3RvbSBidWlsZHMgYXMgbG9uZyBhcyB0aGUgYHZhbHVlYCBtZXRob2QgaXNcbiAgICAgKiBpbXBsaWNpdGx5IG9yIGV4cGxpY2l0bHkgaW5jbHVkZWQgaW4gdGhlIGJ1aWxkLlxuICAgICAqXG4gICAgICogVGhlIGNoYWluYWJsZSB3cmFwcGVyIGZ1bmN0aW9ucyBhcmU6XG4gICAgICogYGFmdGVyYCwgYGFzc2lnbmAsIGBiaW5kYCwgYGJpbmRBbGxgLCBgYmluZEtleWAsIGBjaGFpbmAsIGBjb21wYWN0YCxcbiAgICAgKiBgY29tcG9zZWAsIGBjb25jYXRgLCBgY291bnRCeWAsIGBjcmVhdGVgLCBgY3JlYXRlQ2FsbGJhY2tgLCBgY3VycnlgLFxuICAgICAqIGBkZWJvdW5jZWAsIGBkZWZhdWx0c2AsIGBkZWZlcmAsIGBkZWxheWAsIGBkaWZmZXJlbmNlYCwgYGZpbHRlcmAsIGBmbGF0dGVuYCxcbiAgICAgKiBgZm9yRWFjaGAsIGBmb3JFYWNoUmlnaHRgLCBgZm9ySW5gLCBgZm9ySW5SaWdodGAsIGBmb3JPd25gLCBgZm9yT3duUmlnaHRgLFxuICAgICAqIGBmdW5jdGlvbnNgLCBgZ3JvdXBCeWAsIGBpbmRleEJ5YCwgYGluaXRpYWxgLCBgaW50ZXJzZWN0aW9uYCwgYGludmVydGAsXG4gICAgICogYGludm9rZWAsIGBrZXlzYCwgYG1hcGAsIGBtYXhgLCBgbWVtb2l6ZWAsIGBtZXJnZWAsIGBtaW5gLCBgb2JqZWN0YCwgYG9taXRgLFxuICAgICAqIGBvbmNlYCwgYHBhaXJzYCwgYHBhcnRpYWxgLCBgcGFydGlhbFJpZ2h0YCwgYHBpY2tgLCBgcGx1Y2tgLCBgcHVsbGAsIGBwdXNoYCxcbiAgICAgKiBgcmFuZ2VgLCBgcmVqZWN0YCwgYHJlbW92ZWAsIGByZXN0YCwgYHJldmVyc2VgLCBgc2h1ZmZsZWAsIGBzbGljZWAsIGBzb3J0YCxcbiAgICAgKiBgc29ydEJ5YCwgYHNwbGljZWAsIGB0YXBgLCBgdGhyb3R0bGVgLCBgdGltZXNgLCBgdG9BcnJheWAsIGB0cmFuc2Zvcm1gLFxuICAgICAqIGB1bmlvbmAsIGB1bmlxYCwgYHVuc2hpZnRgLCBgdW56aXBgLCBgdmFsdWVzYCwgYHdoZXJlYCwgYHdpdGhvdXRgLCBgd3JhcGAsXG4gICAgICogYW5kIGB6aXBgXG4gICAgICpcbiAgICAgKiBUaGUgbm9uLWNoYWluYWJsZSB3cmFwcGVyIGZ1bmN0aW9ucyBhcmU6XG4gICAgICogYGNsb25lYCwgYGNsb25lRGVlcGAsIGBjb250YWluc2AsIGBlc2NhcGVgLCBgZXZlcnlgLCBgZmluZGAsIGBmaW5kSW5kZXhgLFxuICAgICAqIGBmaW5kS2V5YCwgYGZpbmRMYXN0YCwgYGZpbmRMYXN0SW5kZXhgLCBgZmluZExhc3RLZXlgLCBgaGFzYCwgYGlkZW50aXR5YCxcbiAgICAgKiBgaW5kZXhPZmAsIGBpc0FyZ3VtZW50c2AsIGBpc0FycmF5YCwgYGlzQm9vbGVhbmAsIGBpc0RhdGVgLCBgaXNFbGVtZW50YCxcbiAgICAgKiBgaXNFbXB0eWAsIGBpc0VxdWFsYCwgYGlzRmluaXRlYCwgYGlzRnVuY3Rpb25gLCBgaXNOYU5gLCBgaXNOdWxsYCwgYGlzTnVtYmVyYCxcbiAgICAgKiBgaXNPYmplY3RgLCBgaXNQbGFpbk9iamVjdGAsIGBpc1JlZ0V4cGAsIGBpc1N0cmluZ2AsIGBpc1VuZGVmaW5lZGAsIGBqb2luYCxcbiAgICAgKiBgbGFzdEluZGV4T2ZgLCBgbWl4aW5gLCBgbm9Db25mbGljdGAsIGBwYXJzZUludGAsIGBwb3BgLCBgcmFuZG9tYCwgYHJlZHVjZWAsXG4gICAgICogYHJlZHVjZVJpZ2h0YCwgYHJlc3VsdGAsIGBzaGlmdGAsIGBzaXplYCwgYHNvbWVgLCBgc29ydGVkSW5kZXhgLCBgcnVuSW5Db250ZXh0YCxcbiAgICAgKiBgdGVtcGxhdGVgLCBgdW5lc2NhcGVgLCBgdW5pcXVlSWRgLCBhbmQgYHZhbHVlYFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgZnVuY3Rpb25zIGBmaXJzdGAgYW5kIGBsYXN0YCByZXR1cm4gd3JhcHBlZCB2YWx1ZXMgd2hlbiBgbmAgaXNcbiAgICAgKiBwcm92aWRlZCwgb3RoZXJ3aXNlIHRoZXkgcmV0dXJuIHVud3JhcHBlZCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBFeHBsaWNpdCBjaGFpbmluZyBjYW4gYmUgZW5hYmxlZCBieSB1c2luZyB0aGUgYF8uY2hhaW5gIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBuYW1lIF9cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5pbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhIGBsb2Rhc2hgIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDIsIDNdKTtcbiAgICAgKlxuICAgICAqIC8vIHJldHVybnMgYW4gdW53cmFwcGVkIHZhbHVlXG4gICAgICogd3JhcHBlZC5yZWR1Y2UoZnVuY3Rpb24oc3VtLCBudW0pIHtcbiAgICAgKiAgIHJldHVybiBzdW0gKyBudW07XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gNlxuICAgICAqXG4gICAgICogLy8gcmV0dXJucyBhIHdyYXBwZWQgdmFsdWVcbiAgICAgKiB2YXIgc3F1YXJlcyA9IHdyYXBwZWQubWFwKGZ1bmN0aW9uKG51bSkge1xuICAgICAqICAgcmV0dXJuIG51bSAqIG51bTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShzcXVhcmVzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KHNxdWFyZXMudmFsdWUoKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvZGFzaCh2YWx1ZSkge1xuICAgICAgLy8gZG9uJ3Qgd3JhcCBpZiBhbHJlYWR5IHdyYXBwZWQsIGV2ZW4gaWYgd3JhcHBlZCBieSBhIGRpZmZlcmVudCBgbG9kYXNoYCBjb25zdHJ1Y3RvclxuICAgICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgIWlzQXJyYXkodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdfX3dyYXBwZWRfXycpKVxuICAgICAgID8gdmFsdWVcbiAgICAgICA6IG5ldyBsb2Rhc2hXcmFwcGVyKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGZhc3QgcGF0aCBmb3IgY3JlYXRpbmcgYGxvZGFzaGAgd3JhcHBlciBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjaGFpbkFsbCBBIGZsYWcgdG8gZW5hYmxlIGNoYWluaW5nIGZvciBhbGwgbWV0aG9kc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2Rhc2hXcmFwcGVyKHZhbHVlLCBjaGFpbkFsbCkge1xuICAgICAgdGhpcy5fX2NoYWluX18gPSAhIWNoYWluQWxsO1xuICAgICAgdGhpcy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgIH1cbiAgICAvLyBlbnN1cmUgYG5ldyBsb2Rhc2hXcmFwcGVyYCBpcyBhbiBpbnN0YW5jZSBvZiBgbG9kYXNoYFxuICAgIGxvZGFzaFdyYXBwZXIucHJvdG90eXBlID0gbG9kYXNoLnByb3RvdHlwZTtcblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCB1c2VkIHRvIGZsYWcgZW52aXJvbm1lbnRzIGZlYXR1cmVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICovXG4gICAgdmFyIHN1cHBvcnQgPSBsb2Rhc2guc3VwcG9ydCA9IHt9O1xuXG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGN0b3IgPSBmdW5jdGlvbigpIHsgdGhpcy54ID0gMTsgfSxcbiAgICAgICAgICBvYmplY3QgPSB7ICcwJzogMSwgJ2xlbmd0aCc6IDEgfSxcbiAgICAgICAgICBwcm9wcyA9IFtdO1xuXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IHsgJ3ZhbHVlT2YnOiAxLCAneSc6IDEgfTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBuZXcgY3RvcikgeyBwcm9wcy5wdXNoKGtleSk7IH1cbiAgICAgIGZvciAoa2V5IGluIGFyZ3VtZW50cykgeyB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGV0ZWN0IGlmIGFuIGBhcmd1bWVudHNgIG9iamVjdCdzIFtbQ2xhc3NdXSBpcyByZXNvbHZhYmxlIChhbGwgYnV0IEZpcmVmb3ggPCA0LCBJRSA8IDkpLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnN1cHBvcnRcbiAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAqL1xuICAgICAgc3VwcG9ydC5hcmdzQ2xhc3MgPSB0b1N0cmluZy5jYWxsKGFyZ3VtZW50cykgPT0gYXJnc0NsYXNzO1xuXG4gICAgICAvKipcbiAgICAgICAqIERldGVjdCBpZiBgYXJndW1lbnRzYCBvYmplY3RzIGFyZSBgT2JqZWN0YCBvYmplY3RzIChhbGwgYnV0IE5hcndoYWwgYW5kIE9wZXJhIDwgMTAuNSkuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICovXG4gICAgICBzdXBwb3J0LmFyZ3NPYmplY3QgPSBhcmd1bWVudHMuY29uc3RydWN0b3IgPT0gT2JqZWN0ICYmICEoYXJndW1lbnRzIGluc3RhbmNlb2YgQXJyYXkpO1xuXG4gICAgICAvKipcbiAgICAgICAqIERldGVjdCBpZiBgbmFtZWAgb3IgYG1lc3NhZ2VgIHByb3BlcnRpZXMgb2YgYEVycm9yLnByb3RvdHlwZWAgYXJlXG4gICAgICAgKiBlbnVtZXJhYmxlIGJ5IGRlZmF1bHQuIChJRSA8IDksIFNhZmFyaSA8IDUuMSlcbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy5zdXBwb3J0XG4gICAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICAgKi9cbiAgICAgIHN1cHBvcnQuZW51bUVycm9yUHJvcHMgPSBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGVycm9yUHJvdG8sICdtZXNzYWdlJykgfHwgcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlcnJvclByb3RvLCAnbmFtZScpO1xuXG4gICAgICAvKipcbiAgICAgICAqIERldGVjdCBpZiBgcHJvdG90eXBlYCBwcm9wZXJ0aWVzIGFyZSBlbnVtZXJhYmxlIGJ5IGRlZmF1bHQuXG4gICAgICAgKlxuICAgICAgICogRmlyZWZveCA8IDMuNiwgT3BlcmEgPiA5LjUwIC0gT3BlcmEgPCAxMS42MCwgYW5kIFNhZmFyaSA8IDUuMVxuICAgICAgICogKGlmIHRoZSBwcm90b3R5cGUgb3IgYSBwcm9wZXJ0eSBvbiB0aGUgcHJvdG90eXBlIGhhcyBiZWVuIHNldClcbiAgICAgICAqIGluY29ycmVjdGx5IHNldHMgYSBmdW5jdGlvbidzIGBwcm90b3R5cGVgIHByb3BlcnR5IFtbRW51bWVyYWJsZV1dXG4gICAgICAgKiB2YWx1ZSB0byBgdHJ1ZWAuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICovXG4gICAgICBzdXBwb3J0LmVudW1Qcm90b3R5cGVzID0gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChjdG9yLCAncHJvdG90eXBlJyk7XG5cbiAgICAgIC8qKlxuICAgICAgICogRGV0ZWN0IGlmIGZ1bmN0aW9ucyBjYW4gYmUgZGVjb21waWxlZCBieSBgRnVuY3Rpb24jdG9TdHJpbmdgXG4gICAgICAgKiAoYWxsIGJ1dCBQUzMgYW5kIG9sZGVyIE9wZXJhIG1vYmlsZSBicm93c2VycyAmIGF2b2lkZWQgaW4gV2luZG93cyA4IGFwcHMpLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnN1cHBvcnRcbiAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAqL1xuICAgICAgc3VwcG9ydC5mdW5jRGVjb21wID0gIWlzTmF0aXZlKGNvbnRleHQuV2luUlRFcnJvcikgJiYgcmVUaGlzLnRlc3QocnVuSW5Db250ZXh0KTtcblxuICAgICAgLyoqXG4gICAgICAgKiBEZXRlY3QgaWYgYEZ1bmN0aW9uI25hbWVgIGlzIHN1cHBvcnRlZCAoYWxsIGJ1dCBJRSkuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICovXG4gICAgICBzdXBwb3J0LmZ1bmNOYW1lcyA9IHR5cGVvZiBGdW5jdGlvbi5uYW1lID09ICdzdHJpbmcnO1xuXG4gICAgICAvKipcbiAgICAgICAqIERldGVjdCBpZiBgYXJndW1lbnRzYCBvYmplY3QgaW5kZXhlcyBhcmUgbm9uLWVudW1lcmFibGVcbiAgICAgICAqIChGaXJlZm94IDwgNCwgSUUgPCA5LCBQaGFudG9tSlMsIFNhZmFyaSA8IDUuMSkuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICovXG4gICAgICBzdXBwb3J0Lm5vbkVudW1BcmdzID0ga2V5ICE9IDA7XG5cbiAgICAgIC8qKlxuICAgICAgICogRGV0ZWN0IGlmIHByb3BlcnRpZXMgc2hhZG93aW5nIHRob3NlIG9uIGBPYmplY3QucHJvdG90eXBlYCBhcmUgbm9uLWVudW1lcmFibGUuXG4gICAgICAgKlxuICAgICAgICogSW4gSUUgPCA5IGFuIG9iamVjdHMgb3duIHByb3BlcnRpZXMsIHNoYWRvd2luZyBub24tZW51bWVyYWJsZSBvbmVzLCBhcmVcbiAgICAgICAqIG1hZGUgbm9uLWVudW1lcmFibGUgYXMgd2VsbCAoYS5rLmEgdGhlIEpTY3JpcHQgW1tEb250RW51bV1dIGJ1ZykuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICovXG4gICAgICBzdXBwb3J0Lm5vbkVudW1TaGFkb3dzID0gIS92YWx1ZU9mLy50ZXN0KHByb3BzKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBEZXRlY3QgaWYgb3duIHByb3BlcnRpZXMgYXJlIGl0ZXJhdGVkIGFmdGVyIGluaGVyaXRlZCBwcm9wZXJ0aWVzIChhbGwgYnV0IElFIDwgOSkuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICovXG4gICAgICBzdXBwb3J0Lm93bkxhc3QgPSBwcm9wc1swXSAhPSAneCc7XG5cbiAgICAgIC8qKlxuICAgICAgICogRGV0ZWN0IGlmIGBBcnJheSNzaGlmdGAgYW5kIGBBcnJheSNzcGxpY2VgIGF1Z21lbnQgYXJyYXktbGlrZSBvYmplY3RzIGNvcnJlY3RseS5cbiAgICAgICAqXG4gICAgICAgKiBGaXJlZm94IDwgMTAsIElFIGNvbXBhdGliaWxpdHkgbW9kZSwgYW5kIElFIDwgOSBoYXZlIGJ1Z2d5IEFycmF5IGBzaGlmdCgpYFxuICAgICAgICogYW5kIGBzcGxpY2UoKWAgZnVuY3Rpb25zIHRoYXQgZmFpbCB0byByZW1vdmUgdGhlIGxhc3QgZWxlbWVudCwgYHZhbHVlWzBdYCxcbiAgICAgICAqIG9mIGFycmF5LWxpa2Ugb2JqZWN0cyBldmVuIHRob3VnaCB0aGUgYGxlbmd0aGAgcHJvcGVydHkgaXMgc2V0IHRvIGAwYC5cbiAgICAgICAqIFRoZSBgc2hpZnQoKWAgbWV0aG9kIGlzIGJ1Z2d5IGluIElFIDggY29tcGF0aWJpbGl0eSBtb2RlLCB3aGlsZSBgc3BsaWNlKClgXG4gICAgICAgKiBpcyBidWdneSByZWdhcmRsZXNzIG9mIG1vZGUgaW4gSUUgPCA5IGFuZCBidWdneSBpbiBjb21wYXRpYmlsaXR5IG1vZGUgaW4gSUUgOS5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy5zdXBwb3J0XG4gICAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICAgKi9cbiAgICAgIHN1cHBvcnQuc3BsaWNlT2JqZWN0cyA9IChhcnJheVJlZi5zcGxpY2UuY2FsbChvYmplY3QsIDAsIDEpLCAhb2JqZWN0WzBdKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBEZXRlY3QgbGFjayBvZiBzdXBwb3J0IGZvciBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgYnkgaW5kZXguXG4gICAgICAgKlxuICAgICAgICogSUUgPCA4IGNhbid0IGFjY2VzcyBjaGFyYWN0ZXJzIGJ5IGluZGV4IGFuZCBJRSA4IGNhbiBvbmx5IGFjY2Vzc1xuICAgICAgICogY2hhcmFjdGVycyBieSBpbmRleCBvbiBzdHJpbmcgbGl0ZXJhbHMuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICovXG4gICAgICBzdXBwb3J0LnVuaW5kZXhlZENoYXJzID0gKCd4J1swXSArIE9iamVjdCgneCcpWzBdKSAhPSAneHgnO1xuXG4gICAgICAvKipcbiAgICAgICAqIERldGVjdCBpZiBhIERPTSBub2RlJ3MgW1tDbGFzc11dIGlzIHJlc29sdmFibGUgKGFsbCBidXQgSUUgPCA5KVxuICAgICAgICogYW5kIHRoYXQgdGhlIEpTIGVuZ2luZSBlcnJvcnMgd2hlbiBhdHRlbXB0aW5nIHRvIGNvZXJjZSBhbiBvYmplY3QgdG9cbiAgICAgICAqIGEgc3RyaW5nIHdpdGhvdXQgYSBgdG9TdHJpbmdgIGZ1bmN0aW9uLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnN1cHBvcnRcbiAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAqL1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3VwcG9ydC5ub2RlQ2xhc3MgPSAhKHRvU3RyaW5nLmNhbGwoZG9jdW1lbnQpID09IG9iamVjdENsYXNzICYmICEoeyAndG9TdHJpbmcnOiAwIH0gKyAnJykpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHN1cHBvcnQubm9kZUNsYXNzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KDEpKTtcblxuICAgIC8qKlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzIHVzZWQgYnkgTG8tRGFzaCBhcmUgc2ltaWxhciB0byB0aG9zZSBpblxuICAgICAqIGVtYmVkZGVkIFJ1YnkgKEVSQikuIENoYW5nZSB0aGUgZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZVxuICAgICAqIGRlbGltaXRlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cbiAgICBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncyA9IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGJlIEhUTUwtZXNjYXBlZC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSBSZWdFeHBcbiAgICAgICAqL1xuICAgICAgJ2VzY2FwZSc6IC88JS0oW1xcc1xcU10rPyklPi9nLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGNvZGUgdG8gYmUgZXZhbHVhdGVkLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIFJlZ0V4cFxuICAgICAgICovXG4gICAgICAnZXZhbHVhdGUnOiAvPCUoW1xcc1xcU10rPyklPi9nLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gaW5qZWN0LlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIFJlZ0V4cFxuICAgICAgICovXG4gICAgICAnaW50ZXJwb2xhdGUnOiByZUludGVycG9sYXRlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gcmVmZXJlbmNlIHRoZSBkYXRhIG9iamVjdCBpbiB0aGUgdGVtcGxhdGUgdGV4dC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgICAqL1xuICAgICAgJ3ZhcmlhYmxlJzogJycsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBpbXBvcnQgdmFyaWFibGVzIGludG8gdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAgICovXG4gICAgICAnaW1wb3J0cyc6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNcbiAgICAgICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgICdfJzogbG9kYXNoXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRlbXBsYXRlIHVzZWQgdG8gY3JlYXRlIGl0ZXJhdG9yIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIGRhdGEgb2JqZWN0IHVzZWQgdG8gcG9wdWxhdGUgdGhlIHRleHQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgaW50ZXJwb2xhdGVkIHRleHQuXG4gICAgICovXG4gICAgdmFyIGl0ZXJhdG9yVGVtcGxhdGUgPSBmdW5jdGlvbihvYmopIHtcblxuICAgICAgdmFyIF9fcCA9ICd2YXIgaW5kZXgsIGl0ZXJhYmxlID0gJyArXG4gICAgICAob2JqLmZpcnN0QXJnKSArXG4gICAgICAnLCByZXN1bHQgPSAnICtcbiAgICAgIChvYmouaW5pdCkgK1xuICAgICAgJztcXG5pZiAoIWl0ZXJhYmxlKSByZXR1cm4gcmVzdWx0O1xcbicgK1xuICAgICAgKG9iai50b3ApICtcbiAgICAgICc7JztcbiAgICAgICBpZiAob2JqLmFycmF5KSB7XG4gICAgICBfX3AgKz0gJ1xcbnZhciBsZW5ndGggPSBpdGVyYWJsZS5sZW5ndGg7IGluZGV4ID0gLTE7XFxuaWYgKCcgK1xuICAgICAgKG9iai5hcnJheSkgK1xuICAgICAgJykgeyAgJztcbiAgICAgICBpZiAoc3VwcG9ydC51bmluZGV4ZWRDaGFycykge1xuICAgICAgX19wICs9ICdcXG4gIGlmIChpc1N0cmluZyhpdGVyYWJsZSkpIHtcXG4gICAgaXRlcmFibGUgPSBpdGVyYWJsZS5zcGxpdChcXCdcXCcpXFxuICB9ICAnO1xuICAgICAgIH1cbiAgICAgIF9fcCArPSAnXFxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xcbiAgICAnICtcbiAgICAgIChvYmoubG9vcCkgK1xuICAgICAgJztcXG4gIH1cXG59XFxuZWxzZSB7ICAnO1xuICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5ub25FbnVtQXJncykge1xuICAgICAgX19wICs9ICdcXG4gIHZhciBsZW5ndGggPSBpdGVyYWJsZS5sZW5ndGg7IGluZGV4ID0gLTE7XFxuICBpZiAobGVuZ3RoICYmIGlzQXJndW1lbnRzKGl0ZXJhYmxlKSkge1xcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xcbiAgICAgIGluZGV4ICs9IFxcJ1xcJztcXG4gICAgICAnICtcbiAgICAgIChvYmoubG9vcCkgK1xuICAgICAgJztcXG4gICAgfVxcbiAgfSBlbHNlIHsgICc7XG4gICAgICAgfVxuXG4gICAgICAgaWYgKHN1cHBvcnQuZW51bVByb3RvdHlwZXMpIHtcbiAgICAgIF9fcCArPSAnXFxuICB2YXIgc2tpcFByb3RvID0gdHlwZW9mIGl0ZXJhYmxlID09IFxcJ2Z1bmN0aW9uXFwnO1xcbiAgJztcbiAgICAgICB9XG5cbiAgICAgICBpZiAoc3VwcG9ydC5lbnVtRXJyb3JQcm9wcykge1xuICAgICAgX19wICs9ICdcXG4gIHZhciBza2lwRXJyb3JQcm9wcyA9IGl0ZXJhYmxlID09PSBlcnJvclByb3RvIHx8IGl0ZXJhYmxlIGluc3RhbmNlb2YgRXJyb3I7XFxuICAnO1xuICAgICAgIH1cblxuICAgICAgICAgIHZhciBjb25kaXRpb25zID0gW107ICAgIGlmIChzdXBwb3J0LmVudW1Qcm90b3R5cGVzKSB7IGNvbmRpdGlvbnMucHVzaCgnIShza2lwUHJvdG8gJiYgaW5kZXggPT0gXCJwcm90b3R5cGVcIiknKTsgfSAgICBpZiAoc3VwcG9ydC5lbnVtRXJyb3JQcm9wcykgIHsgY29uZGl0aW9ucy5wdXNoKCchKHNraXBFcnJvclByb3BzICYmIChpbmRleCA9PSBcIm1lc3NhZ2VcIiB8fCBpbmRleCA9PSBcIm5hbWVcIikpJyk7IH1cblxuICAgICAgIGlmIChvYmoudXNlSGFzICYmIG9iai5rZXlzKSB7XG4gICAgICBfX3AgKz0gJ1xcbiAgdmFyIG93bkluZGV4ID0gLTEsXFxuICAgICAgb3duUHJvcHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgaXRlcmFibGVdICYmIGtleXMoaXRlcmFibGUpLFxcbiAgICAgIGxlbmd0aCA9IG93blByb3BzID8gb3duUHJvcHMubGVuZ3RoIDogMDtcXG5cXG4gIHdoaWxlICgrK293bkluZGV4IDwgbGVuZ3RoKSB7XFxuICAgIGluZGV4ID0gb3duUHJvcHNbb3duSW5kZXhdO1xcbic7XG4gICAgICAgICAgaWYgKGNvbmRpdGlvbnMubGVuZ3RoKSB7XG4gICAgICBfX3AgKz0gJyAgICBpZiAoJyArXG4gICAgICAoY29uZGl0aW9ucy5qb2luKCcgJiYgJykpICtcbiAgICAgICcpIHtcXG4gICc7XG4gICAgICAgfVxuICAgICAgX19wICs9XG4gICAgICAob2JqLmxvb3ApICtcbiAgICAgICc7ICAgICc7XG4gICAgICAgaWYgKGNvbmRpdGlvbnMubGVuZ3RoKSB7XG4gICAgICBfX3AgKz0gJ1xcbiAgICB9JztcbiAgICAgICB9XG4gICAgICBfX3AgKz0gJ1xcbiAgfSAgJztcbiAgICAgICB9IGVsc2Uge1xuICAgICAgX19wICs9ICdcXG4gIGZvciAoaW5kZXggaW4gaXRlcmFibGUpIHtcXG4nO1xuICAgICAgICAgIGlmIChvYmoudXNlSGFzKSB7IGNvbmRpdGlvbnMucHVzaChcImhhc093blByb3BlcnR5LmNhbGwoaXRlcmFibGUsIGluZGV4KVwiKTsgfSAgICBpZiAoY29uZGl0aW9ucy5sZW5ndGgpIHtcbiAgICAgIF9fcCArPSAnICAgIGlmICgnICtcbiAgICAgIChjb25kaXRpb25zLmpvaW4oJyAmJiAnKSkgK1xuICAgICAgJykge1xcbiAgJztcbiAgICAgICB9XG4gICAgICBfX3AgKz1cbiAgICAgIChvYmoubG9vcCkgK1xuICAgICAgJzsgICAgJztcbiAgICAgICBpZiAoY29uZGl0aW9ucy5sZW5ndGgpIHtcbiAgICAgIF9fcCArPSAnXFxuICAgIH0nO1xuICAgICAgIH1cbiAgICAgIF9fcCArPSAnXFxuICB9ICAgICc7XG4gICAgICAgaWYgKHN1cHBvcnQubm9uRW51bVNoYWRvd3MpIHtcbiAgICAgIF9fcCArPSAnXFxuXFxuICBpZiAoaXRlcmFibGUgIT09IG9iamVjdFByb3RvKSB7XFxuICAgIHZhciBjdG9yID0gaXRlcmFibGUuY29uc3RydWN0b3IsXFxuICAgICAgICBpc1Byb3RvID0gaXRlcmFibGUgPT09IChjdG9yICYmIGN0b3IucHJvdG90eXBlKSxcXG4gICAgICAgIGNsYXNzTmFtZSA9IGl0ZXJhYmxlID09PSBzdHJpbmdQcm90byA/IHN0cmluZ0NsYXNzIDogaXRlcmFibGUgPT09IGVycm9yUHJvdG8gPyBlcnJvckNsYXNzIDogdG9TdHJpbmcuY2FsbChpdGVyYWJsZSksXFxuICAgICAgICBub25FbnVtID0gbm9uRW51bVByb3BzW2NsYXNzTmFtZV07XFxuICAgICAgJztcbiAgICAgICBmb3IgKGsgPSAwOyBrIDwgNzsgaysrKSB7XG4gICAgICBfX3AgKz0gJ1xcbiAgICBpbmRleCA9IFxcJycgK1xuICAgICAgKG9iai5zaGFkb3dlZFByb3BzW2tdKSArXG4gICAgICAnXFwnO1xcbiAgICBpZiAoKCEoaXNQcm90byAmJiBub25FbnVtW2luZGV4XSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbChpdGVyYWJsZSwgaW5kZXgpKSc7XG4gICAgICAgICAgICAgIGlmICghb2JqLnVzZUhhcykge1xuICAgICAgX19wICs9ICcgfHwgKCFub25FbnVtW2luZGV4XSAmJiBpdGVyYWJsZVtpbmRleF0gIT09IG9iamVjdFByb3RvW2luZGV4XSknO1xuICAgICAgIH1cbiAgICAgIF9fcCArPSAnKSB7XFxuICAgICAgJyArXG4gICAgICAob2JqLmxvb3ApICtcbiAgICAgICc7XFxuICAgIH0gICAgICAnO1xuICAgICAgIH1cbiAgICAgIF9fcCArPSAnXFxuICB9ICAgICc7XG4gICAgICAgfVxuXG4gICAgICAgfVxuXG4gICAgICAgaWYgKG9iai5hcnJheSB8fCBzdXBwb3J0Lm5vbkVudW1BcmdzKSB7XG4gICAgICBfX3AgKz0gJ1xcbn0nO1xuICAgICAgIH1cbiAgICAgIF9fcCArPVxuICAgICAgKG9iai5ib3R0b20pICtcbiAgICAgICc7XFxucmV0dXJuIHJlc3VsdCc7XG5cbiAgICAgIHJldHVybiBfX3BcbiAgICB9O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5iaW5kYCB0aGF0IGNyZWF0ZXMgdGhlIGJvdW5kIGZ1bmN0aW9uIGFuZFxuICAgICAqIHNldHMgaXRzIG1ldGEgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYmluZERhdGEgVGhlIGJpbmQgZGF0YSBhcnJheS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQmluZChiaW5kRGF0YSkge1xuICAgICAgdmFyIGZ1bmMgPSBiaW5kRGF0YVswXSxcbiAgICAgICAgICBwYXJ0aWFsQXJncyA9IGJpbmREYXRhWzJdLFxuICAgICAgICAgIHRoaXNBcmcgPSBiaW5kRGF0YVs0XTtcblxuICAgICAgZnVuY3Rpb24gYm91bmQoKSB7XG4gICAgICAgIC8vIGBGdW5jdGlvbiNiaW5kYCBzcGVjXG4gICAgICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMy40LjVcbiAgICAgICAgaWYgKHBhcnRpYWxBcmdzKSB7XG4gICAgICAgICAgLy8gYXZvaWQgYGFyZ3VtZW50c2Agb2JqZWN0IGRlb3B0aW1pemF0aW9ucyBieSB1c2luZyBgc2xpY2VgIGluc3RlYWRcbiAgICAgICAgICAvLyBvZiBgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGxgIGFuZCBub3QgYXNzaWduaW5nIGBhcmd1bWVudHNgIHRvIGFcbiAgICAgICAgICAvLyB2YXJpYWJsZSBhcyBhIHRlcm5hcnkgZXhwcmVzc2lvblxuICAgICAgICAgIHZhciBhcmdzID0gc2xpY2UocGFydGlhbEFyZ3MpO1xuICAgICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtaW1pYyB0aGUgY29uc3RydWN0b3IncyBgcmV0dXJuYCBiZWhhdmlvclxuICAgICAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDEzLjIuMlxuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgLy8gZW5zdXJlIGBuZXcgYm91bmRgIGlzIGFuIGluc3RhbmNlIG9mIGBmdW5jYFxuICAgICAgICAgIHZhciB0aGlzQmluZGluZyA9IGJhc2VDcmVhdGUoZnVuYy5wcm90b3R5cGUpLFxuICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzIHx8IGFyZ3VtZW50cyk7XG4gICAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiB0aGlzQmluZGluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzIHx8IGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICBzZXRCaW5kRGF0YShib3VuZCwgYmluZERhdGEpO1xuICAgICAgcmV0dXJuIGJvdW5kO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCB3aXRob3V0IGFyZ3VtZW50IGp1Z2dsaW5nIG9yIHN1cHBvcnRcbiAgICAgKiBmb3IgYHRoaXNBcmdgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcD1mYWxzZV0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0E9W11dIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQj1bXV0gQXNzb2NpYXRlcyBjbG9uZXMgd2l0aCBzb3VyY2UgY291bnRlcnBhcnRzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBpc0RlZXAsIGNhbGxiYWNrLCBzdGFja0EsIHN0YWNrQikge1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjYWxsYmFjayh2YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gaW5zcGVjdCBbW0NsYXNzXV1cbiAgICAgIHZhciBpc09iaiA9IGlzT2JqZWN0KHZhbHVlKTtcbiAgICAgIGlmIChpc09iaikge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICAgIGlmICghY2xvbmVhYmxlQ2xhc3Nlc1tjbGFzc05hbWVdIHx8ICghc3VwcG9ydC5ub2RlQ2xhc3MgJiYgaXNOb2RlKHZhbHVlKSkpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN0b3IgPSBjdG9yQnlDbGFzc1tjbGFzc05hbWVdO1xuICAgICAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgICAgIGNhc2UgYm9vbENsYXNzOlxuICAgICAgICAgIGNhc2UgZGF0ZUNsYXNzOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBjdG9yKCt2YWx1ZSk7XG5cbiAgICAgICAgICBjYXNlIG51bWJlckNsYXNzOlxuICAgICAgICAgIGNhc2Ugc3RyaW5nQ2xhc3M6XG4gICAgICAgICAgICByZXR1cm4gbmV3IGN0b3IodmFsdWUpO1xuXG4gICAgICAgICAgY2FzZSByZWdleHBDbGFzczpcbiAgICAgICAgICAgIHJlc3VsdCA9IGN0b3IodmFsdWUuc291cmNlLCByZUZsYWdzLmV4ZWModmFsdWUpKTtcbiAgICAgICAgICAgIHJlc3VsdC5sYXN0SW5kZXggPSB2YWx1ZS5sYXN0SW5kZXg7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgLy8gY2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBjb3JyZXNwb25kaW5nIGNsb25lXG4gICAgICAgIHZhciBpbml0ZWRTdGFjayA9ICFzdGFja0E7XG4gICAgICAgIHN0YWNrQSB8fCAoc3RhY2tBID0gZ2V0QXJyYXkoKSk7XG4gICAgICAgIHN0YWNrQiB8fCAoc3RhY2tCID0gZ2V0QXJyYXkoKSk7XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IHN0YWNrQS5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgIGlmIChzdGFja0FbbGVuZ3RoXSA9PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YWNrQltsZW5ndGhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBpc0FyciA/IGN0b3IodmFsdWUubGVuZ3RoKSA6IHt9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGlzQXJyID8gc2xpY2UodmFsdWUpIDogYXNzaWduKHt9LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICAvLyBhZGQgYXJyYXkgcHJvcGVydGllcyBhc3NpZ25lZCBieSBgUmVnRXhwI2V4ZWNgXG4gICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdpbmRleCcpKSB7XG4gICAgICAgICAgcmVzdWx0LmluZGV4ID0gdmFsdWUuaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdpbnB1dCcpKSB7XG4gICAgICAgICAgcmVzdWx0LmlucHV0ID0gdmFsdWUuaW5wdXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGV4aXQgZm9yIHNoYWxsb3cgY2xvbmVcbiAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICAvLyBhZGQgdGhlIHNvdXJjZSB2YWx1ZSB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHNcbiAgICAgIC8vIGFuZCBhc3NvY2lhdGUgaXQgd2l0aCBpdHMgY2xvbmVcbiAgICAgIHN0YWNrQS5wdXNoKHZhbHVlKTtcbiAgICAgIHN0YWNrQi5wdXNoKHJlc3VsdCk7XG5cbiAgICAgIC8vIHJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cylcbiAgICAgIChpc0FyciA/IGJhc2VFYWNoIDogZm9yT3duKSh2YWx1ZSwgZnVuY3Rpb24ob2JqVmFsdWUsIGtleSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IGJhc2VDbG9uZShvYmpWYWx1ZSwgaXNEZWVwLCBjYWxsYmFjaywgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChpbml0ZWRTdGFjaykge1xuICAgICAgICByZWxlYXNlQXJyYXkoc3RhY2tBKTtcbiAgICAgICAgcmVsZWFzZUFycmF5KHN0YWNrQik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAgICAgKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDcmVhdGUocHJvdG90eXBlLCBwcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3QocHJvdG90eXBlKSA/IG5hdGl2ZUNyZWF0ZShwcm90b3R5cGUpIDoge307XG4gICAgfVxuICAgIC8vIGZhbGxiYWNrIGZvciBicm93c2VycyB3aXRob3V0IGBPYmplY3QuY3JlYXRlYFxuICAgIGlmICghbmF0aXZlQ3JlYXRlKSB7XG4gICAgICBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBPYmplY3QoKSB7fVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocHJvdG90eXBlKSB7XG4gICAgICAgICAgaWYgKGlzT2JqZWN0KHByb3RvdHlwZSkpIHtcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IE9iamVjdDtcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0IHx8IGNvbnRleHQuT2JqZWN0KCk7XG4gICAgICAgIH07XG4gICAgICB9KCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZUNhbGxiYWNrYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNyZWF0aW5nXG4gICAgICogXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IFtmdW5jPWlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyZ0NvdW50XSBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0aGUgY2FsbGJhY2sgYWNjZXB0cy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ3JlYXRlQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBpZGVudGl0eTtcbiAgICAgIH1cbiAgICAgIC8vIGV4aXQgZWFybHkgZm9yIG5vIGB0aGlzQXJnYCBvciBhbHJlYWR5IGJvdW5kIGJ5IGBGdW5jdGlvbiNiaW5kYFxuICAgICAgaWYgKHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnIHx8ICEoJ3Byb3RvdHlwZScgaW4gZnVuYykpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICB9XG4gICAgICB2YXIgYmluZERhdGEgPSBmdW5jLl9fYmluZERhdGFfXztcbiAgICAgIGlmICh0eXBlb2YgYmluZERhdGEgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHN1cHBvcnQuZnVuY05hbWVzKSB7XG4gICAgICAgICAgYmluZERhdGEgPSAhZnVuYy5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIGJpbmREYXRhID0gYmluZERhdGEgfHwgIXN1cHBvcnQuZnVuY0RlY29tcDtcbiAgICAgICAgaWYgKCFiaW5kRGF0YSkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBmblRvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgICAgICAgaWYgKCFzdXBwb3J0LmZ1bmNOYW1lcykge1xuICAgICAgICAgICAgYmluZERhdGEgPSAhcmVGdW5jTmFtZS50ZXN0KHNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghYmluZERhdGEpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrcyBpZiBgZnVuY2AgcmVmZXJlbmNlcyB0aGUgYHRoaXNgIGtleXdvcmQgYW5kIHN0b3JlcyB0aGUgcmVzdWx0XG4gICAgICAgICAgICBiaW5kRGF0YSA9IHJlVGhpcy50ZXN0KHNvdXJjZSk7XG4gICAgICAgICAgICBzZXRCaW5kRGF0YShmdW5jLCBiaW5kRGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBleGl0IGVhcmx5IGlmIHRoZXJlIGFyZSBubyBgdGhpc2AgcmVmZXJlbmNlcyBvciBgZnVuY2AgaXMgYm91bmRcbiAgICAgIGlmIChiaW5kRGF0YSA9PT0gZmFsc2UgfHwgKGJpbmREYXRhICE9PSB0cnVlICYmIGJpbmREYXRhWzFdICYgMSkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGFyZ0NvdW50KSB7XG4gICAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGEsIGIpO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJpbmQoZnVuYywgdGhpc0FyZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGNyZWF0ZVdyYXBwZXJgIHRoYXQgY3JlYXRlcyB0aGUgd3JhcHBlciBhbmRcbiAgICAgKiBzZXRzIGl0cyBtZXRhIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGJpbmREYXRhIFRoZSBiaW5kIGRhdGEgYXJyYXkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNyZWF0ZVdyYXBwZXIoYmluZERhdGEpIHtcbiAgICAgIHZhciBmdW5jID0gYmluZERhdGFbMF0sXG4gICAgICAgICAgYml0bWFzayA9IGJpbmREYXRhWzFdLFxuICAgICAgICAgIHBhcnRpYWxBcmdzID0gYmluZERhdGFbMl0sXG4gICAgICAgICAgcGFydGlhbFJpZ2h0QXJncyA9IGJpbmREYXRhWzNdLFxuICAgICAgICAgIHRoaXNBcmcgPSBiaW5kRGF0YVs0XSxcbiAgICAgICAgICBhcml0eSA9IGJpbmREYXRhWzVdO1xuXG4gICAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIDEsXG4gICAgICAgICAgaXNCaW5kS2V5ID0gYml0bWFzayAmIDIsXG4gICAgICAgICAgaXNDdXJyeSA9IGJpdG1hc2sgJiA0LFxuICAgICAgICAgIGlzQ3VycnlCb3VuZCA9IGJpdG1hc2sgJiA4LFxuICAgICAgICAgIGtleSA9IGZ1bmM7XG5cbiAgICAgIGZ1bmN0aW9uIGJvdW5kKCkge1xuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBpc0JpbmQgPyB0aGlzQXJnIDogdGhpcztcbiAgICAgICAgaWYgKHBhcnRpYWxBcmdzKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShwYXJ0aWFsQXJncyk7XG4gICAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWFsUmlnaHRBcmdzIHx8IGlzQ3VycnkpIHtcbiAgICAgICAgICBhcmdzIHx8IChhcmdzID0gc2xpY2UoYXJndW1lbnRzKSk7XG4gICAgICAgICAgaWYgKHBhcnRpYWxSaWdodEFyZ3MpIHtcbiAgICAgICAgICAgIHB1c2guYXBwbHkoYXJncywgcGFydGlhbFJpZ2h0QXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0N1cnJ5ICYmIGFyZ3MubGVuZ3RoIDwgYXJpdHkpIHtcbiAgICAgICAgICAgIGJpdG1hc2sgfD0gMTYgJiB+MzI7XG4gICAgICAgICAgICByZXR1cm4gYmFzZUNyZWF0ZVdyYXBwZXIoW2Z1bmMsIChpc0N1cnJ5Qm91bmQgPyBiaXRtYXNrIDogYml0bWFzayAmIH4zKSwgYXJncywgbnVsbCwgdGhpc0FyZywgYXJpdHldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXJncyB8fCAoYXJncyA9IGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChpc0JpbmRLZXkpIHtcbiAgICAgICAgICBmdW5jID0gdGhpc0JpbmRpbmdba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgdGhpc0JpbmRpbmcgPSBiYXNlQ3JlYXRlKGZ1bmMucHJvdG90eXBlKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG4gICAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiB0aGlzQmluZGluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG4gICAgICB9XG4gICAgICBzZXRCaW5kRGF0YShib3VuZCwgYmluZERhdGEpO1xuICAgICAgcmV0dXJuIGJvdW5kO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmRpZmZlcmVuY2VgIHRoYXQgYWNjZXB0cyBhIHNpbmdsZSBhcnJheVxuICAgICAqIG9mIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgYXJyYXkgb2YgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICBpc0xhcmdlID0gbGVuZ3RoID49IGxhcmdlQXJyYXlTaXplICYmIGluZGV4T2YgPT09IGJhc2VJbmRleE9mLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICBpZiAoaXNMYXJnZSkge1xuICAgICAgICB2YXIgY2FjaGUgPSBjcmVhdGVDYWNoZSh2YWx1ZXMpO1xuICAgICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgICBpbmRleE9mID0gY2FjaGVJbmRleE9mO1xuICAgICAgICAgIHZhbHVlcyA9IGNhY2hlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzTGFyZ2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAoaW5kZXhPZih2YWx1ZXMsIHZhbHVlKSA8IDApIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0xhcmdlKSB7XG4gICAgICAgIHJlbGVhc2VPYmplY3QodmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgb3IgYHRoaXNBcmdgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU2hhbGxvdz1mYWxzZV0gQSBmbGFnIHRvIHJlc3RyaWN0IGZsYXR0ZW5pbmcgdG8gYSBzaW5nbGUgbGV2ZWwuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3Q9ZmFsc2VdIEEgZmxhZyB0byByZXN0cmljdCBmbGF0dGVuaW5nIHRvIGFycmF5cyBhbmQgYGFyZ3VtZW50c2Agb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc3RhcnQgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBpc1NoYWxsb3csIGlzU3RyaWN0LCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBpbmRleCA9IChmcm9tSW5kZXggfHwgMCkgLSAxLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLmxlbmd0aCA9PSAnbnVtYmVyJ1xuICAgICAgICAgICAgJiYgKGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICAgICAgICAvLyByZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpXG4gICAgICAgICAgaWYgKCFpc1NoYWxsb3cpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYmFzZUZsYXR0ZW4odmFsdWUsIGlzU2hhbGxvdywgaXNTdHJpY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdmFsSW5kZXggPSAtMSxcbiAgICAgICAgICAgICAgdmFsTGVuZ3RoID0gdmFsdWUubGVuZ3RoLFxuICAgICAgICAgICAgICByZXNJbmRleCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgICAgICAgICByZXN1bHQubGVuZ3RoICs9IHZhbExlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoKyt2YWxJbmRleCA8IHZhbExlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWVbdmFsSW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAsIHdpdGhvdXQgc3VwcG9ydCBmb3IgYHRoaXNBcmdgIGJpbmRpbmcsXG4gICAgICogdGhhdCBhbGxvd3MgcGFydGlhbCBcIl8ud2hlcmVcIiBzdHlsZSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBhIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gYiBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXNXaGVyZT1mYWxzZV0gQSBmbGFnIHRvIGluZGljYXRlIHBlcmZvcm1pbmcgcGFydGlhbCBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIGBhYCBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIFRyYWNrcyB0cmF2ZXJzZWQgYGJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNFcXVhbChhLCBiLCBjYWxsYmFjaywgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIC8vIHVzZWQgdG8gaW5kaWNhdGUgdGhhdCB3aGVuIGNvbXBhcmluZyBvYmplY3RzLCBgYWAgaGFzIGF0IGxlYXN0IHRoZSBwcm9wZXJ0aWVzIG9mIGBiYFxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjYWxsYmFjayhhLCBiKTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXR1cm4gISFyZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGV4aXQgZWFybHkgZm9yIGlkZW50aWNhbCB2YWx1ZXNcbiAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIC8vIHRyZWF0IGArMGAgdnMuIGAtMGAgYXMgbm90IGVxdWFsXG4gICAgICAgIHJldHVybiBhICE9PSAwIHx8ICgxIC8gYSA9PSAxIC8gYik7XG4gICAgICB9XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiBhLFxuICAgICAgICAgIG90aGVyVHlwZSA9IHR5cGVvZiBiO1xuXG4gICAgICAvLyBleGl0IGVhcmx5IGZvciB1bmxpa2UgcHJpbWl0aXZlIHZhbHVlc1xuICAgICAgaWYgKGEgPT09IGEgJiZcbiAgICAgICAgICAhKGEgJiYgb2JqZWN0VHlwZXNbdHlwZV0pICYmXG4gICAgICAgICAgIShiICYmIG9iamVjdFR5cGVzW290aGVyVHlwZV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIGV4aXQgZWFybHkgZm9yIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgYXZvaWRpbmcgRVMzJ3MgRnVuY3Rpb24jY2FsbCBiZWhhdmlvclxuICAgICAgLy8gaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS4zLjQuNFxuICAgICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgICB9XG4gICAgICAvLyBjb21wYXJlIFtbQ2xhc3NdXSBuYW1lc1xuICAgICAgdmFyIGNsYXNzTmFtZSA9IHRvU3RyaW5nLmNhbGwoYSksXG4gICAgICAgICAgb3RoZXJDbGFzcyA9IHRvU3RyaW5nLmNhbGwoYik7XG5cbiAgICAgIGlmIChjbGFzc05hbWUgPT0gYXJnc0NsYXNzKSB7XG4gICAgICAgIGNsYXNzTmFtZSA9IG9iamVjdENsYXNzO1xuICAgICAgfVxuICAgICAgaWYgKG90aGVyQ2xhc3MgPT0gYXJnc0NsYXNzKSB7XG4gICAgICAgIG90aGVyQ2xhc3MgPSBvYmplY3RDbGFzcztcbiAgICAgIH1cbiAgICAgIGlmIChjbGFzc05hbWUgIT0gb3RoZXJDbGFzcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgICBjYXNlIGJvb2xDbGFzczpcbiAgICAgICAgY2FzZSBkYXRlQ2xhc3M6XG4gICAgICAgICAgLy8gY29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1iZXJzLCBkYXRlcyB0byBtaWxsaXNlY29uZHMgYW5kIGJvb2xlYW5zXG4gICAgICAgICAgLy8gdG8gYDFgIG9yIGAwYCB0cmVhdGluZyBpbnZhbGlkIGRhdGVzIGNvZXJjZWQgdG8gYE5hTmAgYXMgbm90IGVxdWFsXG4gICAgICAgICAgcmV0dXJuICthID09ICtiO1xuXG4gICAgICAgIGNhc2UgbnVtYmVyQ2xhc3M6XG4gICAgICAgICAgLy8gdHJlYXQgYE5hTmAgdnMuIGBOYU5gIGFzIGVxdWFsXG4gICAgICAgICAgcmV0dXJuIChhICE9ICthKVxuICAgICAgICAgICAgPyBiICE9ICtiXG4gICAgICAgICAgICAvLyBidXQgdHJlYXQgYCswYCB2cy4gYC0wYCBhcyBub3QgZXF1YWxcbiAgICAgICAgICAgIDogKGEgPT0gMCA/ICgxIC8gYSA9PSAxIC8gYikgOiBhID09ICtiKTtcblxuICAgICAgICBjYXNlIHJlZ2V4cENsYXNzOlxuICAgICAgICBjYXNlIHN0cmluZ0NsYXNzOlxuICAgICAgICAgIC8vIGNvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgKGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMTAuNi40KVxuICAgICAgICAgIC8vIHRyZWF0IHN0cmluZyBwcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCBpbnN0YW5jZXMgYXMgZXF1YWxcbiAgICAgICAgICByZXR1cm4gYSA9PSBTdHJpbmcoYik7XG4gICAgICB9XG4gICAgICB2YXIgaXNBcnIgPSBjbGFzc05hbWUgPT0gYXJyYXlDbGFzcztcbiAgICAgIGlmICghaXNBcnIpIHtcbiAgICAgICAgLy8gdW53cmFwIGFueSBgbG9kYXNoYCB3cmFwcGVkIHZhbHVlc1xuICAgICAgICB2YXIgYVdyYXBwZWQgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKGEsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICAgICAgYldyYXBwZWQgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKGIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgICAgIGlmIChhV3JhcHBlZCB8fCBiV3JhcHBlZCkge1xuICAgICAgICAgIHJldHVybiBiYXNlSXNFcXVhbChhV3JhcHBlZCA/IGEuX193cmFwcGVkX18gOiBhLCBiV3JhcHBlZCA/IGIuX193cmFwcGVkX18gOiBiLCBjYWxsYmFjaywgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGV4aXQgZm9yIGZ1bmN0aW9ucyBhbmQgRE9NIG5vZGVzXG4gICAgICAgIGlmIChjbGFzc05hbWUgIT0gb2JqZWN0Q2xhc3MgfHwgKCFzdXBwb3J0Lm5vZGVDbGFzcyAmJiAoaXNOb2RlKGEpIHx8IGlzTm9kZShiKSkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGluIG9sZGVyIHZlcnNpb25zIG9mIE9wZXJhLCBgYXJndW1lbnRzYCBvYmplY3RzIGhhdmUgYEFycmF5YCBjb25zdHJ1Y3RvcnNcbiAgICAgICAgdmFyIGN0b3JBID0gIXN1cHBvcnQuYXJnc09iamVjdCAmJiBpc0FyZ3VtZW50cyhhKSA/IE9iamVjdCA6IGEuY29uc3RydWN0b3IsXG4gICAgICAgICAgICBjdG9yQiA9ICFzdXBwb3J0LmFyZ3NPYmplY3QgJiYgaXNBcmd1bWVudHMoYikgPyBPYmplY3QgOiBiLmNvbnN0cnVjdG9yO1xuXG4gICAgICAgIC8vIG5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsXG4gICAgICAgIGlmIChjdG9yQSAhPSBjdG9yQiAmJlxuICAgICAgICAgICAgICAhKGlzRnVuY3Rpb24oY3RvckEpICYmIGN0b3JBIGluc3RhbmNlb2YgY3RvckEgJiYgaXNGdW5jdGlvbihjdG9yQikgJiYgY3RvckIgaW5zdGFuY2VvZiBjdG9yQikgJiZcbiAgICAgICAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gYSAmJiAnY29uc3RydWN0b3InIGluIGIpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGFzc3VtZSBjeWNsaWMgc3RydWN0dXJlcyBhcmUgZXF1YWxcbiAgICAgIC8vIHRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWMgc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xXG4gICAgICAvLyBzZWN0aW9uIDE1LjEyLjMsIGFic3RyYWN0IG9wZXJhdGlvbiBgSk9gIChodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEyLjMpXG4gICAgICB2YXIgaW5pdGVkU3RhY2sgPSAhc3RhY2tBO1xuICAgICAgc3RhY2tBIHx8IChzdGFja0EgPSBnZXRBcnJheSgpKTtcbiAgICAgIHN0YWNrQiB8fCAoc3RhY2tCID0gZ2V0QXJyYXkoKSk7XG5cbiAgICAgIHZhciBsZW5ndGggPSBzdGFja0EubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChzdGFja0FbbGVuZ3RoXSA9PSBhKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YWNrQltsZW5ndGhdID09IGI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBzaXplID0gMDtcbiAgICAgIHJlc3VsdCA9IHRydWU7XG5cbiAgICAgIC8vIGFkZCBgYWAgYW5kIGBiYCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHNcbiAgICAgIHN0YWNrQS5wdXNoKGEpO1xuICAgICAgc3RhY2tCLnB1c2goYik7XG5cbiAgICAgIC8vIHJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cylcbiAgICAgIGlmIChpc0Fycikge1xuICAgICAgICAvLyBjb21wYXJlIGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeVxuICAgICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgICAgc2l6ZSA9IGIubGVuZ3RoO1xuICAgICAgICByZXN1bHQgPSBzaXplID09IGxlbmd0aDtcblxuICAgICAgICBpZiAocmVzdWx0IHx8IGlzV2hlcmUpIHtcbiAgICAgICAgICAvLyBkZWVwIGNvbXBhcmUgdGhlIGNvbnRlbnRzLCBpZ25vcmluZyBub24tbnVtZXJpYyBwcm9wZXJ0aWVzXG4gICAgICAgICAgd2hpbGUgKHNpemUtLSkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gbGVuZ3RoLFxuICAgICAgICAgICAgICAgIHZhbHVlID0gYltzaXplXTtcblxuICAgICAgICAgICAgaWYgKGlzV2hlcmUpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoKHJlc3VsdCA9IGJhc2VJc0VxdWFsKGFbaW5kZXhdLCB2YWx1ZSwgY2FsbGJhY2ssIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKSkpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghKHJlc3VsdCA9IGJhc2VJc0VxdWFsKGFbc2l6ZV0sIHZhbHVlLCBjYWxsYmFjaywgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBkZWVwIGNvbXBhcmUgb2JqZWN0cyB1c2luZyBgZm9ySW5gLCBpbnN0ZWFkIG9mIGBmb3JPd25gLCB0byBhdm9pZCBgT2JqZWN0LmtleXNgXG4gICAgICAgIC8vIHdoaWNoLCBpbiB0aGlzIGNhc2UsIGlzIG1vcmUgY29zdGx5XG4gICAgICAgIGZvckluKGIsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGIpIHtcbiAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXkpKSB7XG4gICAgICAgICAgICAvLyBjb3VudCB0aGUgbnVtYmVyIG9mIHByb3BlcnRpZXMuXG4gICAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgICAvLyBkZWVwIGNvbXBhcmUgZWFjaCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgICAgICAgIHJldHVybiAocmVzdWx0ID0gaGFzT3duUHJvcGVydHkuY2FsbChhLCBrZXkpICYmIGJhc2VJc0VxdWFsKGFba2V5XSwgdmFsdWUsIGNhbGxiYWNrLCBpc1doZXJlLCBzdGFja0EsIHN0YWNrQikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCAmJiAhaXNXaGVyZSkge1xuICAgICAgICAgIC8vIGVuc3VyZSBib3RoIG9iamVjdHMgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllc1xuICAgICAgICAgIGZvckluKGEsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGEpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGtleSkpIHtcbiAgICAgICAgICAgICAgLy8gYHNpemVgIHdpbGwgYmUgYC0xYCBpZiBgYWAgaGFzIG1vcmUgcHJvcGVydGllcyB0aGFuIGBiYFxuICAgICAgICAgICAgICByZXR1cm4gKHJlc3VsdCA9IC0tc2l6ZSA+IC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhY2tBLnBvcCgpO1xuICAgICAgc3RhY2tCLnBvcCgpO1xuXG4gICAgICBpZiAoaW5pdGVkU3RhY2spIHtcbiAgICAgICAgcmVsZWFzZUFycmF5KHN0YWNrQSk7XG4gICAgICAgIHJlbGVhc2VBcnJheShzdGFja0IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBhcmd1bWVudCBqdWdnbGluZyBvciBzdXBwb3J0XG4gICAgICogZm9yIGB0aGlzQXJnYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2luZyBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0E9W11dIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQj1bXV0gQXNzb2NpYXRlcyB2YWx1ZXMgd2l0aCBzb3VyY2UgY291bnRlcnBhcnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgY2FsbGJhY2ssIHN0YWNrQSwgc3RhY2tCKSB7XG4gICAgICAoaXNBcnJheShzb3VyY2UpID8gZm9yRWFjaCA6IGZvck93bikoc291cmNlLCBmdW5jdGlvbihzb3VyY2UsIGtleSkge1xuICAgICAgICB2YXIgZm91bmQsXG4gICAgICAgICAgICBpc0FycixcbiAgICAgICAgICAgIHJlc3VsdCA9IHNvdXJjZSxcbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgaWYgKHNvdXJjZSAmJiAoKGlzQXJyID0gaXNBcnJheShzb3VyY2UpKSB8fCBpc1BsYWluT2JqZWN0KHNvdXJjZSkpKSB7XG4gICAgICAgICAgLy8gYXZvaWQgbWVyZ2luZyBwcmV2aW91c2x5IG1lcmdlZCBjeWNsaWMgc291cmNlc1xuICAgICAgICAgIHZhciBzdGFja0xlbmd0aCA9IHN0YWNrQS5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKHN0YWNrTGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIGlmICgoZm91bmQgPSBzdGFja0Fbc3RhY2tMZW5ndGhdID09IHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBzdGFja0Jbc3RhY2tMZW5ndGhdO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgdmFyIGlzU2hhbGxvdztcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFjayh2YWx1ZSwgc291cmNlKTtcbiAgICAgICAgICAgICAgaWYgKChpc1NoYWxsb3cgPSB0eXBlb2YgcmVzdWx0ICE9ICd1bmRlZmluZWQnKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzU2hhbGxvdykge1xuICAgICAgICAgICAgICB2YWx1ZSA9IGlzQXJyXG4gICAgICAgICAgICAgICAgPyAoaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFtdKVxuICAgICAgICAgICAgICAgIDogKGlzUGxhaW5PYmplY3QodmFsdWUpID8gdmFsdWUgOiB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhZGQgYHNvdXJjZWAgYW5kIGFzc29jaWF0ZWQgYHZhbHVlYCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHNcbiAgICAgICAgICAgIHN0YWNrQS5wdXNoKHNvdXJjZSk7XG4gICAgICAgICAgICBzdGFja0IucHVzaCh2YWx1ZSk7XG5cbiAgICAgICAgICAgIC8vIHJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpXG4gICAgICAgICAgICBpZiAoIWlzU2hhbGxvdykge1xuICAgICAgICAgICAgICBiYXNlTWVyZ2UodmFsdWUsIHNvdXJjZSwgY2FsbGJhY2ssIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFjayh2YWx1ZSwgc291cmNlKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHNvdXJjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZG9tYCB3aXRob3V0IGFyZ3VtZW50IGp1Z2dsaW5nIG9yIHN1cHBvcnRcbiAgICAgKiBmb3IgcmV0dXJuaW5nIGZsb2F0aW5nLXBvaW50IG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0gcG9zc2libGUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGEgcmFuZG9tIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmFuZG9tKG1pbiwgbWF4KSB7XG4gICAgICByZXR1cm4gbWluICsgZmxvb3IobmF0aXZlUmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuaXFgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kc1xuICAgICAqIG9yIGB0aGlzQXJnYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1NvcnRlZD1mYWxzZV0gQSBmbGFnIHRvIGluZGljYXRlIHRoYXQgYGFycmF5YCBpcyBzb3J0ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgZHVwbGljYXRlLXZhbHVlLWZyZWUgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVuaXEoYXJyYXksIGlzU29ydGVkLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHZhciBpc0xhcmdlID0gIWlzU29ydGVkICYmIGxlbmd0aCA+PSBsYXJnZUFycmF5U2l6ZSAmJiBpbmRleE9mID09PSBiYXNlSW5kZXhPZixcbiAgICAgICAgICBzZWVuID0gKGNhbGxiYWNrIHx8IGlzTGFyZ2UpID8gZ2V0QXJyYXkoKSA6IHJlc3VsdDtcblxuICAgICAgaWYgKGlzTGFyZ2UpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gY3JlYXRlQ2FjaGUoc2Vlbik7XG4gICAgICAgIGluZGV4T2YgPSBjYWNoZUluZGV4T2Y7XG4gICAgICAgIHNlZW4gPSBjYWNoZTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gY2FsbGJhY2sgPyBjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGFycmF5KSA6IHZhbHVlO1xuXG4gICAgICAgIGlmIChpc1NvcnRlZFxuICAgICAgICAgICAgICA/ICFpbmRleCB8fCBzZWVuW3NlZW4ubGVuZ3RoIC0gMV0gIT09IGNvbXB1dGVkXG4gICAgICAgICAgICAgIDogaW5kZXhPZihzZWVuLCBjb21wdXRlZCkgPCAwXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sgfHwgaXNMYXJnZSkge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNMYXJnZSkge1xuICAgICAgICByZWxlYXNlQXJyYXkoc2Vlbi5hcnJheSk7XG4gICAgICAgIHJlbGVhc2VPYmplY3Qoc2Vlbik7XG4gICAgICB9IGVsc2UgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHJlbGVhc2VBcnJheShzZWVuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYWdncmVnYXRlcyBhIGNvbGxlY3Rpb24sIGNyZWF0aW5nIGFuIG9iamVjdCBjb21wb3NlZFxuICAgICAqIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIGNvbGxlY3Rpb25cbiAgICAgKiB0aHJvdWdoIGEgY2FsbGJhY2suIFRoZSBnaXZlbiBgc2V0dGVyYCBmdW5jdGlvbiBzZXRzIHRoZSBrZXlzIGFuZCB2YWx1ZXNcbiAgICAgKiBvZiB0aGUgY29tcG9zZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIHNldHRlciBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhZ2dyZWdhdG9yIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUFnZ3JlZ2F0b3Ioc2V0dGVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgICAgaWYgKGlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cbiAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gY29sbGVjdGlvbltpbmRleF07XG4gICAgICAgICAgICBzZXR0ZXIocmVzdWx0LCB2YWx1ZSwgY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSwgY29sbGVjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgIHNldHRlcihyZXN1bHQsIHZhbHVlLCBjYWxsYmFjayh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSwgY29sbGVjdGlvbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCBlaXRoZXIgY3VycmllcyBvciBpbnZva2VzIGBmdW5jYFxuICAgICAqIHdpdGggYW4gb3B0aW9uYWwgYHRoaXNgIGJpbmRpbmcgYW5kIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGZ1bmMgVGhlIGZ1bmN0aW9uIG9yIG1ldGhvZCBuYW1lIHRvIHJlZmVyZW5jZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBvZiBtZXRob2QgZmxhZ3MgdG8gY29tcG9zZS5cbiAgICAgKiAgVGhlIGJpdG1hc2sgbWF5IGJlIGNvbXBvc2VkIG9mIHRoZSBmb2xsb3dpbmcgZmxhZ3M6XG4gICAgICogIDEgLSBgXy5iaW5kYFxuICAgICAqICAyIC0gYF8uYmluZEtleWBcbiAgICAgKiAgNCAtIGBfLmN1cnJ5YFxuICAgICAqICA4IC0gYF8uY3VycnlgIChib3VuZClcbiAgICAgKiAgMTYgLSBgXy5wYXJ0aWFsYFxuICAgICAqICAzMiAtIGBfLnBhcnRpYWxSaWdodGBcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbEFyZ3NdIEFuIGFycmF5IG9mIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlXG4gICAgICogIHByb3ZpZGVkIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxSaWdodEFyZ3NdIEFuIGFycmF5IG9mIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhvc2VcbiAgICAgKiAgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlV3JhcHBlcihmdW5jLCBiaXRtYXNrLCBwYXJ0aWFsQXJncywgcGFydGlhbFJpZ2h0QXJncywgdGhpc0FyZywgYXJpdHkpIHtcbiAgICAgIHZhciBpc0JpbmQgPSBiaXRtYXNrICYgMSxcbiAgICAgICAgICBpc0JpbmRLZXkgPSBiaXRtYXNrICYgMixcbiAgICAgICAgICBpc0N1cnJ5ID0gYml0bWFzayAmIDQsXG4gICAgICAgICAgaXNDdXJyeUJvdW5kID0gYml0bWFzayAmIDgsXG4gICAgICAgICAgaXNQYXJ0aWFsID0gYml0bWFzayAmIDE2LFxuICAgICAgICAgIGlzUGFydGlhbFJpZ2h0ID0gYml0bWFzayAmIDMyO1xuXG4gICAgICBpZiAoIWlzQmluZEtleSAmJiAhaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgfVxuICAgICAgaWYgKGlzUGFydGlhbCAmJiAhcGFydGlhbEFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfjE2O1xuICAgICAgICBpc1BhcnRpYWwgPSBwYXJ0aWFsQXJncyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGlzUGFydGlhbFJpZ2h0ICYmICFwYXJ0aWFsUmlnaHRBcmdzLmxlbmd0aCkge1xuICAgICAgICBiaXRtYXNrICY9IH4zMjtcbiAgICAgICAgaXNQYXJ0aWFsUmlnaHQgPSBwYXJ0aWFsUmlnaHRBcmdzID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgYmluZERhdGEgPSBmdW5jICYmIGZ1bmMuX19iaW5kRGF0YV9fO1xuICAgICAgaWYgKGJpbmREYXRhICYmIGJpbmREYXRhICE9PSB0cnVlKSB7XG4gICAgICAgIC8vIGNsb25lIGBiaW5kRGF0YWBcbiAgICAgICAgYmluZERhdGEgPSBzbGljZShiaW5kRGF0YSk7XG4gICAgICAgIGlmIChiaW5kRGF0YVsyXSkge1xuICAgICAgICAgIGJpbmREYXRhWzJdID0gc2xpY2UoYmluZERhdGFbMl0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiaW5kRGF0YVszXSkge1xuICAgICAgICAgIGJpbmREYXRhWzNdID0gc2xpY2UoYmluZERhdGFbM10pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCBgdGhpc0JpbmRpbmdgIGlzIG5vdCBwcmV2aW91c2x5IGJvdW5kXG4gICAgICAgIGlmIChpc0JpbmQgJiYgIShiaW5kRGF0YVsxXSAmIDEpKSB7XG4gICAgICAgICAgYmluZERhdGFbNF0gPSB0aGlzQXJnO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCBpZiBwcmV2aW91c2x5IGJvdW5kIGJ1dCBub3QgY3VycmVudGx5IChzdWJzZXF1ZW50IGN1cnJpZWQgZnVuY3Rpb25zKVxuICAgICAgICBpZiAoIWlzQmluZCAmJiBiaW5kRGF0YVsxXSAmIDEpIHtcbiAgICAgICAgICBiaXRtYXNrIHw9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IGN1cnJpZWQgYXJpdHkgaWYgbm90IHlldCBzZXRcbiAgICAgICAgaWYgKGlzQ3VycnkgJiYgIShiaW5kRGF0YVsxXSAmIDQpKSB7XG4gICAgICAgICAgYmluZERhdGFbNV0gPSBhcml0eTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhcHBlbmQgcGFydGlhbCBsZWZ0IGFyZ3VtZW50c1xuICAgICAgICBpZiAoaXNQYXJ0aWFsKSB7XG4gICAgICAgICAgcHVzaC5hcHBseShiaW5kRGF0YVsyXSB8fCAoYmluZERhdGFbMl0gPSBbXSksIHBhcnRpYWxBcmdzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhcHBlbmQgcGFydGlhbCByaWdodCBhcmd1bWVudHNcbiAgICAgICAgaWYgKGlzUGFydGlhbFJpZ2h0KSB7XG4gICAgICAgICAgdW5zaGlmdC5hcHBseShiaW5kRGF0YVszXSB8fCAoYmluZERhdGFbM10gPSBbXSksIHBhcnRpYWxSaWdodEFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1lcmdlIGZsYWdzXG4gICAgICAgIGJpbmREYXRhWzFdIHw9IGJpdG1hc2s7XG4gICAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyLmFwcGx5KG51bGwsIGJpbmREYXRhKTtcbiAgICAgIH1cbiAgICAgIC8vIGZhc3QgcGF0aCBmb3IgYF8uYmluZGBcbiAgICAgIHZhciBjcmVhdGVyID0gKGJpdG1hc2sgPT0gMSB8fCBiaXRtYXNrID09PSAxNykgPyBiYXNlQmluZCA6IGJhc2VDcmVhdGVXcmFwcGVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZXIoW2Z1bmMsIGJpdG1hc2ssIHBhcnRpYWxBcmdzLCBwYXJ0aWFsUmlnaHRBcmdzLCB0aGlzQXJnLCBhcml0eV0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgY29tcGlsZWQgaXRlcmF0aW9uIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtvcHRpb25zXSBUaGUgY29tcGlsZSBvcHRpb25zIG9iamVjdChzKS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYXJyYXldIENvZGUgdG8gZGV0ZXJtaW5lIGlmIHRoZSBpdGVyYWJsZSBpcyBhbiBhcnJheSBvciBhcnJheS1saWtlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudXNlSGFzXSBTcGVjaWZ5IHVzaW5nIGBoYXNPd25Qcm9wZXJ0eWAgY2hlY2tzIGluIHRoZSBvYmplY3QgbG9vcC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5rZXlzXSBBIHJlZmVyZW5jZSB0byBgXy5rZXlzYCBmb3IgdXNlIGluIG93biBwcm9wZXJ0eSBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmFyZ3NdIEEgY29tbWEgc2VwYXJhdGVkIHN0cmluZyBvZiBpdGVyYXRpb24gZnVuY3Rpb24gYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50b3BdIENvZGUgdG8gZXhlY3V0ZSBiZWZvcmUgdGhlIGl0ZXJhdGlvbiBicmFuY2hlcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubG9vcF0gQ29kZSB0byBleGVjdXRlIGluIHRoZSBvYmplY3QgbG9vcC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYm90dG9tXSBDb2RlIHRvIGV4ZWN1dGUgYWZ0ZXIgdGhlIGl0ZXJhdGlvbiBicmFuY2hlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUl0ZXJhdG9yKCkge1xuICAgICAgLy8gZGF0YSBwcm9wZXJ0aWVzXG4gICAgICBpdGVyYXRvckRhdGEuc2hhZG93ZWRQcm9wcyA9IHNoYWRvd2VkUHJvcHM7XG5cbiAgICAgIC8vIGl0ZXJhdG9yIG9wdGlvbnNcbiAgICAgIGl0ZXJhdG9yRGF0YS5hcnJheSA9IGl0ZXJhdG9yRGF0YS5ib3R0b20gPSBpdGVyYXRvckRhdGEubG9vcCA9IGl0ZXJhdG9yRGF0YS50b3AgPSAnJztcbiAgICAgIGl0ZXJhdG9yRGF0YS5pbml0ID0gJ2l0ZXJhYmxlJztcbiAgICAgIGl0ZXJhdG9yRGF0YS51c2VIYXMgPSB0cnVlO1xuXG4gICAgICAvLyBtZXJnZSBvcHRpb25zIGludG8gYSB0ZW1wbGF0ZSBkYXRhIG9iamVjdFxuICAgICAgZm9yICh2YXIgb2JqZWN0LCBpbmRleCA9IDA7IG9iamVjdCA9IGFyZ3VtZW50c1tpbmRleF07IGluZGV4KyspIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIGl0ZXJhdG9yRGF0YVtrZXldID0gb2JqZWN0W2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBhcmdzID0gaXRlcmF0b3JEYXRhLmFyZ3M7XG4gICAgICBpdGVyYXRvckRhdGEuZmlyc3RBcmcgPSAvXlteLF0rLy5leGVjKGFyZ3MpWzBdO1xuXG4gICAgICAvLyBjcmVhdGUgdGhlIGZ1bmN0aW9uIGZhY3RvcnlcbiAgICAgIHZhciBmYWN0b3J5ID0gRnVuY3Rpb24oXG4gICAgICAgICAgJ2Jhc2VDcmVhdGVDYWxsYmFjaywgZXJyb3JDbGFzcywgZXJyb3JQcm90bywgaGFzT3duUHJvcGVydHksICcgK1xuICAgICAgICAgICdpbmRpY2F0b3JPYmplY3QsIGlzQXJndW1lbnRzLCBpc0FycmF5LCBpc1N0cmluZywga2V5cywgb2JqZWN0UHJvdG8sICcgK1xuICAgICAgICAgICdvYmplY3RUeXBlcywgbm9uRW51bVByb3BzLCBzdHJpbmdDbGFzcywgc3RyaW5nUHJvdG8sIHRvU3RyaW5nJyxcbiAgICAgICAgJ3JldHVybiBmdW5jdGlvbignICsgYXJncyArICcpIHtcXG4nICsgaXRlcmF0b3JUZW1wbGF0ZShpdGVyYXRvckRhdGEpICsgJ1xcbn0nXG4gICAgICApO1xuXG4gICAgICAvLyByZXR1cm4gdGhlIGNvbXBpbGVkIGZ1bmN0aW9uXG4gICAgICByZXR1cm4gZmFjdG9yeShcbiAgICAgICAgYmFzZUNyZWF0ZUNhbGxiYWNrLCBlcnJvckNsYXNzLCBlcnJvclByb3RvLCBoYXNPd25Qcm9wZXJ0eSxcbiAgICAgICAgaW5kaWNhdG9yT2JqZWN0LCBpc0FyZ3VtZW50cywgaXNBcnJheSwgaXNTdHJpbmcsIGl0ZXJhdG9yRGF0YS5rZXlzLCBvYmplY3RQcm90byxcbiAgICAgICAgb2JqZWN0VHlwZXMsIG5vbkVudW1Qcm9wcywgc3RyaW5nQ2xhc3MsIHN0cmluZ1Byb3RvLCB0b1N0cmluZ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBlc2NhcGVgIHRvIGNvbnZlcnQgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWF0Y2ggVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlc2NhcGVIdG1sQ2hhcihtYXRjaCkge1xuICAgICAgcmV0dXJuIGh0bWxFc2NhcGVzW21hdGNoXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhcHByb3ByaWF0ZSBcImluZGV4T2ZcIiBmdW5jdGlvbi4gSWYgdGhlIGBfLmluZGV4T2ZgIG1ldGhvZCBpc1xuICAgICAqIGN1c3RvbWl6ZWQsIHRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGN1c3RvbSBtZXRob2QsIG90aGVyd2lzZSBpdCByZXR1cm5zXG4gICAgICogdGhlIGBiYXNlSW5kZXhPZmAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgXCJpbmRleE9mXCIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0SW5kZXhPZigpIHtcbiAgICAgIHZhciByZXN1bHQgPSAocmVzdWx0ID0gbG9kYXNoLmluZGV4T2YpID09PSBpbmRleE9mID8gYmFzZUluZGV4T2YgOiByZXN1bHQ7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05hdGl2ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nICYmIHJlTmF0aXZlLnRlc3QodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgYHRoaXNgIGJpbmRpbmcgZGF0YSBvbiBhIGdpdmVuIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBzZXQgZGF0YSBvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZSBUaGUgZGF0YSBhcnJheSB0byBzZXQuXG4gICAgICovXG4gICAgdmFyIHNldEJpbmREYXRhID0gIWRlZmluZVByb3BlcnR5ID8gbm9vcCA6IGZ1bmN0aW9uKGZ1bmMsIHZhbHVlKSB7XG4gICAgICBkZXNjcmlwdG9yLnZhbHVlID0gdmFsdWU7XG4gICAgICBkZWZpbmVQcm9wZXJ0eShmdW5jLCAnX19iaW5kRGF0YV9fJywgZGVzY3JpcHRvcik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEEgZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gb2YgYGlzUGxhaW5PYmplY3RgIHdoaWNoIGNoZWNrcyBpZiBhIGdpdmVuIHZhbHVlXG4gICAgICogaXMgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLCBhc3N1bWluZyBvYmplY3RzIGNyZWF0ZWRcbiAgICAgKiBieSB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IgaGF2ZSBubyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFuZCB0aGF0XG4gICAgICogdGhlcmUgYXJlIG5vIGBPYmplY3QucHJvdG90eXBlYCBleHRlbnNpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNoaW1Jc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICB2YXIgY3RvcixcbiAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgIC8vIGF2b2lkIG5vbiBPYmplY3Qgb2JqZWN0cywgYGFyZ3VtZW50c2Agb2JqZWN0cywgYW5kIERPTSBlbGVtZW50c1xuICAgICAgaWYgKCEodmFsdWUgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gb2JqZWN0Q2xhc3MpIHx8XG4gICAgICAgICAgKGN0b3IgPSB2YWx1ZS5jb25zdHJ1Y3RvciwgaXNGdW5jdGlvbihjdG9yKSAmJiAhKGN0b3IgaW5zdGFuY2VvZiBjdG9yKSkgfHxcbiAgICAgICAgICAoIXN1cHBvcnQuYXJnc0NsYXNzICYmIGlzQXJndW1lbnRzKHZhbHVlKSkgfHxcbiAgICAgICAgICAoIXN1cHBvcnQubm9kZUNsYXNzICYmIGlzTm9kZSh2YWx1ZSkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIElFIDwgOSBpdGVyYXRlcyBpbmhlcml0ZWQgcHJvcGVydGllcyBiZWZvcmUgb3duIHByb3BlcnRpZXMuIElmIHRoZSBmaXJzdFxuICAgICAgLy8gaXRlcmF0ZWQgcHJvcGVydHkgaXMgYW4gb2JqZWN0J3Mgb3duIHByb3BlcnR5IHRoZW4gdGhlcmUgYXJlIG5vIGluaGVyaXRlZFxuICAgICAgLy8gZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgICAgaWYgKHN1cHBvcnQub3duTGFzdCkge1xuICAgICAgICBmb3JJbih2YWx1ZSwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCAhPT0gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBJbiBtb3N0IGVudmlyb25tZW50cyBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcyBhcmUgaXRlcmF0ZWQgYmVmb3JlXG4gICAgICAvLyBpdHMgaW5oZXJpdGVkIHByb3BlcnRpZXMuIElmIHRoZSBsYXN0IGl0ZXJhdGVkIHByb3BlcnR5IGlzIGFuIG9iamVjdCdzXG4gICAgICAvLyBvd24gcHJvcGVydHkgdGhlbiB0aGVyZSBhcmUgbm8gaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgIGZvckluKHZhbHVlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIHJlc3VsdCA9IGtleTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHR5cGVvZiByZXN1bHQgPT0gJ3VuZGVmaW5lZCcgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgcmVzdWx0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGB1bmVzY2FwZWAgdG8gY29udmVydCBIVE1MIGVudGl0aWVzIHRvIGNoYXJhY3RlcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtYXRjaCBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gdW5lc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmVzY2FwZUh0bWxDaGFyKG1hdGNoKSB7XG4gICAgICByZXR1cm4gaHRtbFVuZXNjYXBlc1ttYXRjaF07XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogKGZ1bmN0aW9uKCkgeyByZXR1cm4gXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpOyB9KSgxLCAyLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUubGVuZ3RoID09ICdudW1iZXInICYmXG4gICAgICAgIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IGFyZ3NDbGFzcyB8fCBmYWxzZTtcbiAgICB9XG4gICAgLy8gZmFsbGJhY2sgZm9yIGJyb3dzZXJzIHRoYXQgY2FuJ3QgZGV0ZWN0IGBhcmd1bWVudHNgIG9iamVjdHMgYnkgW1tDbGFzc11dXG4gICAgaWYgKCFzdXBwb3J0LmFyZ3NDbGFzcykge1xuICAgICAgaXNBcmd1bWVudHMgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZS5sZW5ndGggPT0gJ251bWJlcicgJiZcbiAgICAgICAgICBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiYgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKSB8fCBmYWxzZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIChmdW5jdGlvbigpIHsgcmV0dXJuIF8uaXNBcnJheShhcmd1bWVudHMpOyB9KSgpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgdmFyIGlzQXJyYXkgPSBuYXRpdmVJc0FycmF5IHx8IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZS5sZW5ndGggPT0gJ251bWJlcicgJiZcbiAgICAgICAgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJyYXlDbGFzcyB8fCBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQSBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbiBvZiBgT2JqZWN0LmtleXNgIHdoaWNoIHByb2R1Y2VzIGFuIGFycmF5IG9mIHRoZVxuICAgICAqIGdpdmVuIG9iamVjdCdzIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICB2YXIgc2hpbUtleXMgPSBjcmVhdGVJdGVyYXRvcih7XG4gICAgICAnYXJncyc6ICdvYmplY3QnLFxuICAgICAgJ2luaXQnOiAnW10nLFxuICAgICAgJ3RvcCc6ICdpZiAoIShvYmplY3RUeXBlc1t0eXBlb2Ygb2JqZWN0XSkpIHJldHVybiByZXN1bHQnLFxuICAgICAgJ2xvb3AnOiAncmVzdWx0LnB1c2goaW5kZXgpJ1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBjb21wb3NlZCBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ua2V5cyh7ICdvbmUnOiAxLCAndHdvJzogMiwgJ3RocmVlJzogMyB9KTtcbiAgICAgKiAvLyA9PiBbJ29uZScsICd0d28nLCAndGhyZWUnXSAocHJvcGVydHkgb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGVudmlyb25tZW50cylcbiAgICAgKi9cbiAgICB2YXIga2V5cyA9ICFuYXRpdmVLZXlzID8gc2hpbUtleXMgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoKHN1cHBvcnQuZW51bVByb3RvdHlwZXMgJiYgdHlwZW9mIG9iamVjdCA9PSAnZnVuY3Rpb24nKSB8fFxuICAgICAgICAgIChzdXBwb3J0Lm5vbkVudW1BcmdzICYmIG9iamVjdC5sZW5ndGggJiYgaXNBcmd1bWVudHMob2JqZWN0KSkpIHtcbiAgICAgICAgcmV0dXJuIHNoaW1LZXlzKG9iamVjdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICAgIH07XG5cbiAgICAvKiogUmV1c2FibGUgaXRlcmF0b3Igb3B0aW9ucyBzaGFyZWQgYnkgYGVhY2hgLCBgZm9ySW5gLCBhbmQgYGZvck93bmAgKi9cbiAgICB2YXIgZWFjaEl0ZXJhdG9yT3B0aW9ucyA9IHtcbiAgICAgICdhcmdzJzogJ2NvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnJyxcbiAgICAgICd0b3AnOiBcImNhbGxiYWNrID0gY2FsbGJhY2sgJiYgdHlwZW9mIHRoaXNBcmcgPT0gJ3VuZGVmaW5lZCcgPyBjYWxsYmFjayA6IGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMylcIixcbiAgICAgICdhcnJheSc6IFwidHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJ1wiLFxuICAgICAgJ2tleXMnOiBrZXlzLFxuICAgICAgJ2xvb3AnOiAnaWYgKGNhbGxiYWNrKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pID09PSBmYWxzZSkgcmV0dXJuIHJlc3VsdCdcbiAgICB9O1xuXG4gICAgLyoqIFJldXNhYmxlIGl0ZXJhdG9yIG9wdGlvbnMgZm9yIGBhc3NpZ25gIGFuZCBgZGVmYXVsdHNgICovXG4gICAgdmFyIGRlZmF1bHRzSXRlcmF0b3JPcHRpb25zID0ge1xuICAgICAgJ2FyZ3MnOiAnb2JqZWN0LCBzb3VyY2UsIGd1YXJkJyxcbiAgICAgICd0b3AnOlxuICAgICAgICAndmFyIGFyZ3MgPSBhcmd1bWVudHMsXFxuJyArXG4gICAgICAgICcgICAgYXJnc0luZGV4ID0gMCxcXG4nICtcbiAgICAgICAgXCIgICAgYXJnc0xlbmd0aCA9IHR5cGVvZiBndWFyZCA9PSAnbnVtYmVyJyA/IDIgOiBhcmdzLmxlbmd0aDtcXG5cIiArXG4gICAgICAgICd3aGlsZSAoKythcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XFxuJyArXG4gICAgICAgICcgIGl0ZXJhYmxlID0gYXJnc1thcmdzSW5kZXhdO1xcbicgK1xuICAgICAgICAnICBpZiAoaXRlcmFibGUgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSkgeycsXG4gICAgICAna2V5cyc6IGtleXMsXG4gICAgICAnbG9vcCc6IFwiaWYgKHR5cGVvZiByZXN1bHRbaW5kZXhdID09ICd1bmRlZmluZWQnKSByZXN1bHRbaW5kZXhdID0gaXRlcmFibGVbaW5kZXhdXCIsXG4gICAgICAnYm90dG9tJzogJyAgfVxcbn0nXG4gICAgfTtcblxuICAgIC8qKiBSZXVzYWJsZSBpdGVyYXRvciBvcHRpb25zIGZvciBgZm9ySW5gIGFuZCBgZm9yT3duYCAqL1xuICAgIHZhciBmb3JPd25JdGVyYXRvck9wdGlvbnMgPSB7XG4gICAgICAndG9wJzogJ2lmICghb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSkgcmV0dXJuIHJlc3VsdDtcXG4nICsgZWFjaEl0ZXJhdG9yT3B0aW9ucy50b3AsXG4gICAgICAnYXJyYXknOiBmYWxzZVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGNvbnZlcnQgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzOlxuICAgICAqXG4gICAgICogVGhvdWdoIHRoZSBgPmAgY2hhcmFjdGVyIGlzIGVzY2FwZWQgZm9yIHN5bW1ldHJ5LCBjaGFyYWN0ZXJzIGxpa2UgYD5gIGFuZCBgL2BcbiAgICAgKiBkb24ndCByZXF1aXJlIGVzY2FwaW5nIGluIEhUTUwgYW5kIGhhdmUgbm8gc3BlY2lhbCBtZWFuaW5nIHVubGVzcyB0aGV5J3JlIHBhcnRcbiAgICAgKiBvZiBhIHRhZyBvciBhbiB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUuXG4gICAgICogaHR0cDovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvYW1iaWd1b3VzLWFtcGVyc2FuZHMgKHVuZGVyIFwic2VtaS1yZWxhdGVkIGZ1biBmYWN0XCIpXG4gICAgICovXG4gICAgdmFyIGh0bWxFc2NhcGVzID0ge1xuICAgICAgJyYnOiAnJmFtcDsnLFxuICAgICAgJzwnOiAnJmx0OycsXG4gICAgICAnPic6ICcmZ3Q7JyxcbiAgICAgICdcIic6ICcmcXVvdDsnLFxuICAgICAgXCInXCI6ICcmIzM5OydcbiAgICB9O1xuXG4gICAgLyoqIFVzZWQgdG8gY29udmVydCBIVE1MIGVudGl0aWVzIHRvIGNoYXJhY3RlcnMgKi9cbiAgICB2YXIgaHRtbFVuZXNjYXBlcyA9IGludmVydChodG1sRXNjYXBlcyk7XG5cbiAgICAvKiogVXNlZCB0byBtYXRjaCBIVE1MIGVudGl0aWVzIGFuZCBIVE1MIGNoYXJhY3RlcnMgKi9cbiAgICB2YXIgcmVFc2NhcGVkSHRtbCA9IFJlZ0V4cCgnKCcgKyBrZXlzKGh0bWxVbmVzY2FwZXMpLmpvaW4oJ3wnKSArICcpJywgJ2cnKSxcbiAgICAgICAgcmVVbmVzY2FwZWRIdG1sID0gUmVnRXhwKCdbJyArIGtleXMoaHRtbEVzY2FwZXMpLmpvaW4oJycpICsgJ10nLCAnZycpO1xuXG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiBjb21waWxlZCB0byBpdGVyYXRlIGBhcmd1bWVudHNgIG9iamVjdHMsIGFycmF5cywgb2JqZWN0cywgYW5kXG4gICAgICogc3RyaW5ncyBjb25zaXN0ZW5seSBhY3Jvc3MgZW52aXJvbm1lbnRzLCBleGVjdXRpbmcgdGhlIGNhbGxiYWNrIGZvciBlYWNoXG4gICAgICogZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvbi4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuIENhbGxiYWNrcyBtYXkgZXhpdFxuICAgICAqIGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdHxzdHJpbmd9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqL1xuICAgIHZhciBiYXNlRWFjaCA9IGNyZWF0ZUl0ZXJhdG9yKGVhY2hJdGVyYXRvck9wdGlvbnMpO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdChzKSB0byB0aGUgZGVzdGluYXRpb25cbiAgICAgKiBvYmplY3QuIFN1YnNlcXVlbnQgc291cmNlcyB3aWxsIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91c1xuICAgICAqIHNvdXJjZXMuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZCB0byBwcm9kdWNlIHRoZVxuICAgICAqIGFzc2lnbmVkIHZhbHVlcy4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHR3b1xuICAgICAqIGFyZ3VtZW50czsgKG9iamVjdFZhbHVlLCBzb3VyY2VWYWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBhbGlhcyBleHRlbmRcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZV0gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25pbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAnbmFtZSc6ICdmcmVkJyB9LCB7ICdlbXBsb3llcic6ICdzbGF0ZScgfSk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJywgJ2VtcGxveWVyJzogJ3NsYXRlJyB9XG4gICAgICpcbiAgICAgKiB2YXIgZGVmYXVsdHMgPSBfLnBhcnRpYWxSaWdodChfLmFzc2lnbiwgZnVuY3Rpb24oYSwgYikge1xuICAgICAqICAgcmV0dXJuIHR5cGVvZiBhID09ICd1bmRlZmluZWQnID8gYiA6IGE7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnbmFtZSc6ICdiYXJuZXknIH07XG4gICAgICogZGVmYXVsdHMob2JqZWN0LCB7ICduYW1lJzogJ2ZyZWQnLCAnZW1wbG95ZXInOiAnc2xhdGUnIH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnYmFybmV5JywgJ2VtcGxveWVyJzogJ3NsYXRlJyB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbiA9IGNyZWF0ZUl0ZXJhdG9yKGRlZmF1bHRzSXRlcmF0b3JPcHRpb25zLCB7XG4gICAgICAndG9wJzpcbiAgICAgICAgZGVmYXVsdHNJdGVyYXRvck9wdGlvbnMudG9wLnJlcGxhY2UoJzsnLFxuICAgICAgICAgICc7XFxuJyArXG4gICAgICAgICAgXCJpZiAoYXJnc0xlbmd0aCA+IDMgJiYgdHlwZW9mIGFyZ3NbYXJnc0xlbmd0aCAtIDJdID09ICdmdW5jdGlvbicpIHtcXG5cIiArXG4gICAgICAgICAgJyAgdmFyIGNhbGxiYWNrID0gYmFzZUNyZWF0ZUNhbGxiYWNrKGFyZ3NbLS1hcmdzTGVuZ3RoIC0gMV0sIGFyZ3NbYXJnc0xlbmd0aC0tXSwgMik7XFxuJyArXG4gICAgICAgICAgXCJ9IGVsc2UgaWYgKGFyZ3NMZW5ndGggPiAyICYmIHR5cGVvZiBhcmdzW2FyZ3NMZW5ndGggLSAxXSA9PSAnZnVuY3Rpb24nKSB7XFxuXCIgK1xuICAgICAgICAgICcgIGNhbGxiYWNrID0gYXJnc1stLWFyZ3NMZW5ndGhdO1xcbicgK1xuICAgICAgICAgICd9J1xuICAgICAgICApLFxuICAgICAgJ2xvb3AnOiAncmVzdWx0W2luZGV4XSA9IGNhbGxiYWNrID8gY2FsbGJhY2socmVzdWx0W2luZGV4XSwgaXRlcmFibGVbaW5kZXhdKSA6IGl0ZXJhYmxlW2luZGV4XSdcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdmFsdWVgLiBJZiBgaXNEZWVwYCBpcyBgdHJ1ZWAgbmVzdGVkIG9iamVjdHMgd2lsbCBhbHNvXG4gICAgICogYmUgY2xvbmVkLCBvdGhlcndpc2UgdGhleSB3aWxsIGJlIGFzc2lnbmVkIGJ5IHJlZmVyZW5jZS4gSWYgYSBjYWxsYmFja1xuICAgICAqIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWQgdG8gcHJvZHVjZSB0aGUgY2xvbmVkIHZhbHVlcy4gSWYgdGhlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdW5kZWZpbmVkYCBjbG9uaW5nIHdpbGwgYmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuXG4gICAgICogVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwPWZhbHNlXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgc2hhbGxvdyA9IF8uY2xvbmUoY2hhcmFjdGVycyk7XG4gICAgICogc2hhbGxvd1swXSA9PT0gY2hhcmFjdGVyc1swXTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiB2YXIgZGVlcCA9IF8uY2xvbmUoY2hhcmFjdGVycywgdHJ1ZSk7XG4gICAgICogZGVlcFswXSA9PT0gY2hhcmFjdGVyc1swXTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5taXhpbih7XG4gICAgICogICAnY2xvbmUnOiBfLnBhcnRpYWxSaWdodChfLmNsb25lLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgICByZXR1cm4gXy5pc0VsZW1lbnQodmFsdWUpID8gdmFsdWUuY2xvbmVOb2RlKGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgKiAgIH0pXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiB2YXIgY2xvbmUgPSBfLmNsb25lKGRvY3VtZW50LmJvZHkpO1xuICAgICAqIGNsb25lLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZSh2YWx1ZSwgaXNEZWVwLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgLy8gYWxsb3dzIHdvcmtpbmcgd2l0aCBcIkNvbGxlY3Rpb25zXCIgbWV0aG9kcyB3aXRob3V0IHVzaW5nIHRoZWlyIGBpbmRleGBcbiAgICAgIC8vIGFuZCBgY29sbGVjdGlvbmAgYXJndW1lbnRzIGZvciBgaXNEZWVwYCBhbmQgYGNhbGxiYWNrYFxuICAgICAgaWYgKHR5cGVvZiBpc0RlZXAgIT0gJ2Jvb2xlYW4nICYmIGlzRGVlcCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXNBcmcgPSBjYWxsYmFjaztcbiAgICAgICAgY2FsbGJhY2sgPSBpc0RlZXA7XG4gICAgICAgIGlzRGVlcCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgaXNEZWVwLCB0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJyAmJiBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZGVlcCBjbG9uZSBvZiBgdmFsdWVgLiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmVcbiAgICAgKiBleGVjdXRlZCB0byBwcm9kdWNlIHRoZSBjbG9uZWQgdmFsdWVzLiBJZiB0aGUgY2FsbGJhY2sgcmV0dXJucyBgdW5kZWZpbmVkYFxuICAgICAqIGNsb25pbmcgd2lsbCBiZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvXG4gICAgICogYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGUgc3RydWN0dXJlZCBjbG9uZSBhbGdvcml0aG0uIEZ1bmN0aW9uc1xuICAgICAqIGFuZCBET00gbm9kZXMgYXJlICoqbm90KiogY2xvbmVkLiBUaGUgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBhcmd1bWVudHNgIG9iamVjdHMgYW5kXG4gICAgICogb2JqZWN0cyBjcmVhdGVkIGJ5IGNvbnN0cnVjdG9ycyBvdGhlciB0aGFuIGBPYmplY3RgIGFyZSBjbG9uZWQgdG8gcGxhaW4gYE9iamVjdGAgb2JqZWN0cy5cbiAgICAgKiBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNpbnRlcm5hbC1zdHJ1Y3R1cmVkLWNsb25pbmctYWxnb3JpdGhtLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBkZWVwIGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIGRlZXAgPSBfLmNsb25lRGVlcChjaGFyYWN0ZXJzKTtcbiAgICAgKiBkZWVwWzBdID09PSBjaGFyYWN0ZXJzWzBdO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiB2YXIgdmlldyA9IHtcbiAgICAgKiAgICdsYWJlbCc6ICdkb2NzJyxcbiAgICAgKiAgICdub2RlJzogZWxlbWVudFxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgY2xvbmUgPSBfLmNsb25lRGVlcCh2aWV3LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgcmV0dXJuIF8uaXNFbGVtZW50KHZhbHVlKSA/IHZhbHVlLmNsb25lTm9kZSh0cnVlKSA6IHVuZGVmaW5lZDtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGNsb25lLm5vZGUgPT0gdmlldy5ub2RlO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVEZWVwKHZhbHVlLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgdHJ1ZSwgdHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicgJiYgYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoZSBnaXZlbiBgcHJvdG90eXBlYCBvYmplY3QuIElmIGFcbiAgICAgKiBgcHJvcGVydGllc2Agb2JqZWN0IGlzIHByb3ZpZGVkIGl0cyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFyZSBhc3NpZ25lZFxuICAgICAqIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIFRoZSBwcm9wZXJ0aWVzIHRvIGFzc2lnbiB0byB0aGUgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIFNoYXBlKCkge1xuICAgICAqICAgdGhpcy54ID0gMDtcbiAgICAgKiAgIHRoaXMueSA9IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gQ2lyY2xlKCkge1xuICAgICAqICAgU2hhcGUuY2FsbCh0aGlzKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBDaXJjbGUucHJvdG90eXBlID0gXy5jcmVhdGUoU2hhcGUucHJvdG90eXBlLCB7ICdjb25zdHJ1Y3Rvcic6IENpcmNsZSB9KTtcbiAgICAgKlxuICAgICAqIHZhciBjaXJjbGUgPSBuZXcgQ2lyY2xlO1xuICAgICAqIGNpcmNsZSBpbnN0YW5jZW9mIENpcmNsZTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBjaXJjbGUgaW5zdGFuY2VvZiBTaGFwZTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHByb3RvdHlwZSwgcHJvcGVydGllcykge1xuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VDcmVhdGUocHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzID8gYXNzaWduKHJlc3VsdCwgcHJvcGVydGllcykgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3QocykgdG8gdGhlIGRlc3RpbmF0aW9uXG4gICAgICogb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllcyB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAuIE9uY2UgYVxuICAgICAqIHByb3BlcnR5IGlzIHNldCwgYWRkaXRpb25hbCBkZWZhdWx0cyBvZiB0aGUgc2FtZSBwcm9wZXJ0eSB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEFsbG93cyB3b3JraW5nIHdpdGggYF8ucmVkdWNlYCB3aXRob3V0IHVzaW5nIGl0c1xuICAgICAqICBga2V5YCBhbmQgYG9iamVjdGAgYXJndW1lbnRzIGFzIHNvdXJjZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnbmFtZSc6ICdiYXJuZXknIH07XG4gICAgICogXy5kZWZhdWx0cyhvYmplY3QsIHsgJ25hbWUnOiAnZnJlZCcsICdlbXBsb3llcic6ICdzbGF0ZScgfSk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdiYXJuZXknLCAnZW1wbG95ZXInOiAnc2xhdGUnIH1cbiAgICAgKi9cbiAgICB2YXIgZGVmYXVsdHMgPSBjcmVhdGVJdGVyYXRvcihkZWZhdWx0c0l0ZXJhdG9yT3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRJbmRleGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUga2V5IG9mIHRoZVxuICAgICAqIGZpcnN0IGVsZW1lbnQgdGhhdCBwYXNzZXMgdGhlIGNhbGxiYWNrIGNoZWNrLCBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlclxuICAgICAqICBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkIHRvXG4gICAgICogIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFJldHVybnMgdGhlIGtleSBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSB7XG4gICAgICogICAnYmFybmV5JzogeyAgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAgICogICAnZnJlZCc6IHsgICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdibG9ja2VkJzogZmFsc2UgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZpbmRLZXkoY2hhcmFjdGVycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLmFnZSA8IDQwO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdiYXJuZXknIChwcm9wZXJ0eSBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZW52aXJvbm1lbnRzKVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kS2V5KGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDEgfSk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRLZXkoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kS2V5KG9iamVjdCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICBmb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCkpIHtcbiAgICAgICAgICByZXN1bHQgPSBrZXk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kS2V5YCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYSBgY29sbGVjdGlvbmAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyXG4gICAgICogIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWQgdG9cbiAgICAgKiAgY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IHtcbiAgICAgKiAgICdiYXJuZXknOiB7ICAnYWdlJzogMzYsICdibG9ja2VkJzogdHJ1ZSB9LFxuICAgICAqICAgJ2ZyZWQnOiB7ICAgICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICdhZ2UnOiAxLCAgJ2Jsb2NrZWQnOiB0cnVlIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5maW5kTGFzdEtleShjaGFyYWN0ZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlIDwgNDA7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gcmV0dXJucyBgcGViYmxlc2AsIGFzc3VtaW5nIGBfLmZpbmRLZXlgIHJldHVybnMgYGJhcm5leWBcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RLZXkoY2hhcmFjdGVycywgeyAnYWdlJzogNDAgfSk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRMYXN0S2V5KGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZExhc3RLZXkob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIGZvck93blJpZ2h0KG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpKSB7XG4gICAgICAgICAgcmVzdWx0ID0ga2V5O1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdCxcbiAgICAgKiBleGVjdXRpbmcgdGhlIGNhbGxiYWNrIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgXG4gICAgICogYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBDYWxsYmFja3MgbWF5IGV4aXRcbiAgICAgKiBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIFNoYXBlKCkge1xuICAgICAqICAgdGhpcy54ID0gMDtcbiAgICAgKiAgIHRoaXMueSA9IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogU2hhcGUucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICogICB0aGlzLnggKz0geDtcbiAgICAgKiAgIHRoaXMueSArPSB5O1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZvckluKG5ldyBTaGFwZSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICd4JywgJ3knLCBhbmQgJ21vdmUnIChwcm9wZXJ0eSBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZW52aXJvbm1lbnRzKVxuICAgICAqL1xuICAgIHZhciBmb3JJbiA9IGNyZWF0ZUl0ZXJhdG9yKGVhY2hJdGVyYXRvck9wdGlvbnMsIGZvck93bkl0ZXJhdG9yT3B0aW9ucywge1xuICAgICAgJ3VzZUhhcyc6IGZhbHNlXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckluYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYSBgY29sbGVjdGlvbmAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIFNoYXBlKCkge1xuICAgICAqICAgdGhpcy54ID0gMDtcbiAgICAgKiAgIHRoaXMueSA9IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogU2hhcGUucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICogICB0aGlzLnggKz0geDtcbiAgICAgKiAgIHRoaXMueSArPSB5O1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZvckluUmlnaHQobmV3IFNoYXBlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGxvZ3MgJ21vdmUnLCAneScsIGFuZCAneCcgYXNzdW1pbmcgYF8uZm9ySW4gYCBsb2dzICd4JywgJ3knLCBhbmQgJ21vdmUnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9ySW5SaWdodChvYmplY3QsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcGFpcnMgPSBbXTtcblxuICAgICAgZm9ySW4ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIHBhaXJzLnB1c2goa2V5LCB2YWx1ZSk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIGxlbmd0aCA9IHBhaXJzLmxlbmd0aDtcbiAgICAgIGNhbGxiYWNrID0gYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoY2FsbGJhY2socGFpcnNbbGVuZ3RoLS1dLCBwYWlyc1tsZW5ndGhdLCBvYmplY3QpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBhbiBvYmplY3QsIGV4ZWN1dGluZyB0aGUgY2FsbGJhY2tcbiAgICAgKiBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOyAodmFsdWUsIGtleSwgb2JqZWN0KS4gQ2FsbGJhY2tzIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieVxuICAgICAqIGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZvck93bih7ICcwJzogJ3plcm8nLCAnMSc6ICdvbmUnLCAnbGVuZ3RoJzogMiB9LCBmdW5jdGlvbihudW0sIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICcwJywgJzEnLCBhbmQgJ2xlbmd0aCcgKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICovXG4gICAgdmFyIGZvck93biA9IGNyZWF0ZUl0ZXJhdG9yKGVhY2hJdGVyYXRvck9wdGlvbnMsIGZvck93bkl0ZXJhdG9yT3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvck93bmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGEgYGNvbGxlY3Rpb25gIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZvck93blJpZ2h0KHsgJzAnOiAnemVybycsICcxJzogJ29uZScsICdsZW5ndGgnOiAyIH0sIGZ1bmN0aW9uKG51bSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGxvZ3MgJ2xlbmd0aCcsICcxJywgYW5kICcwJyBhc3N1bWluZyBgXy5mb3JPd25gIGxvZ3MgJzAnLCAnMScsIGFuZCAnbGVuZ3RoJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvck93blJpZ2h0KG9iamVjdCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBwcm9wcyA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgIGNhbGxiYWNrID0gYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKG9iamVjdFtrZXldLCBrZXksIG9iamVjdCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNvcnRlZCBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBvZiBhbGwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLFxuICAgICAqIG93biBhbmQgaW5oZXJpdGVkLCBvZiBgb2JqZWN0YCB0aGF0IGhhdmUgZnVuY3Rpb24gdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIG1ldGhvZHNcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyB0aGF0IGhhdmUgZnVuY3Rpb24gdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZ1bmN0aW9ucyhfKTtcbiAgICAgKiAvLyA9PiBbJ2FsbCcsICdhbnknLCAnYmluZCcsICdiaW5kQWxsJywgJ2Nsb25lJywgJ2NvbXBhY3QnLCAnY29tcG9zZScsIC4uLl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbnMob2JqZWN0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBmb3JJbihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0LnNvcnQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eSBuYW1lIGV4aXN0cyBhcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiBgb2JqZWN0YCxcbiAgICAgKiBpbnN0ZWFkIG9mIGFuIGluaGVyaXRlZCBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGtleSBpcyBhIGRpcmVjdCBwcm9wZXJ0eSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmhhcyh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSwgJ2InKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzKG9iamVjdCwga2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID8gaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgOiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgaW52ZXJ0ZWQga2V5cyBhbmQgdmFsdWVzIG9mIHRoZSBnaXZlbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZlcnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3JlYXRlZCBpbnZlcnRlZCBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW52ZXJ0KHsgJ2ZpcnN0JzogJ2ZyZWQnLCAnc2Vjb25kJzogJ2Jhcm5leScgfSk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6ICdmaXJzdCcsICdiYXJuZXknOiAnc2Vjb25kJyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gaW52ZXJ0KG9iamVjdCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcHJvcHMgPSBrZXlzKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICByZXN1bHRbb2JqZWN0W2tleV1dID0ga2V5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJvb2xlYW4gdmFsdWUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIGJvb2xlYW4gdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Jvb2xlYW4obnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2UgfHxcbiAgICAgICAgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IGJvb2xDbGFzcyB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGRhdGUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIGRhdGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0RhdGUobmV3IERhdGUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0RhdGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gZGF0ZUNsYXNzIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIERPTSBlbGVtZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFbGVtZW50KGRvY3VtZW50LmJvZHkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMSB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBlbXB0eS4gQXJyYXlzLCBzdHJpbmdzLCBvciBgYXJndW1lbnRzYCBvYmplY3RzIHdpdGggYVxuICAgICAqIGxlbmd0aCBvZiBgMGAgYW5kIG9iamVjdHMgd2l0aCBubyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFyZSBjb25zaWRlcmVkXG4gICAgICogXCJlbXB0eVwiLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBlbXB0eSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KHt9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoJycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKHZhbHVlKSxcbiAgICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cbiAgICAgIGlmICgoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MgfHwgY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzIHx8XG4gICAgICAgICAgKHN1cHBvcnQuYXJnc0NsYXNzID8gY2xhc3NOYW1lID09IGFyZ3NDbGFzcyA6IGlzQXJndW1lbnRzKHZhbHVlKSkpIHx8XG4gICAgICAgICAgKGNsYXNzTmFtZSA9PSBvYmplY3RDbGFzcyAmJiB0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInICYmIGlzRnVuY3Rpb24odmFsdWUuc3BsaWNlKSkpIHtcbiAgICAgICAgcmV0dXJuICFsZW5ndGg7XG4gICAgICB9XG4gICAgICBmb3JPd24odmFsdWUsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKHJlc3VsdCA9IGZhbHNlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlXG4gICAgICogZXF1aXZhbGVudCB0byBlYWNoIG90aGVyLiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWRcbiAgICAgKiB0byBjb21wYXJlIHZhbHVlcy4gSWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYHVuZGVmaW5lZGAgY29tcGFyaXNvbnMgd2lsbFxuICAgICAqIGJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZFxuICAgICAqIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOyAoYSwgYikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gYSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IGIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ25hbWUnOiAnZnJlZCcgfTtcbiAgICAgKiB2YXIgY29weSA9IHsgJ25hbWUnOiAnZnJlZCcgfTtcbiAgICAgKlxuICAgICAqIG9iamVjdCA9PSBjb3B5O1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRXF1YWwob2JqZWN0LCBjb3B5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiB2YXIgd29yZHMgPSBbJ2hlbGxvJywgJ2dvb2RieWUnXTtcbiAgICAgKiB2YXIgb3RoZXJXb3JkcyA9IFsnaGknLCAnZ29vZGJ5ZSddO1xuICAgICAqXG4gICAgICogXy5pc0VxdWFsKHdvcmRzLCBvdGhlcldvcmRzLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgICogICB2YXIgcmVHcmVldCA9IC9eKD86aGVsbG98aGkpJC9pLFxuICAgICAqICAgICAgIGFHcmVldCA9IF8uaXNTdHJpbmcoYSkgJiYgcmVHcmVldC50ZXN0KGEpLFxuICAgICAqICAgICAgIGJHcmVldCA9IF8uaXNTdHJpbmcoYikgJiYgcmVHcmVldC50ZXN0KGIpO1xuICAgICAqXG4gICAgICogICByZXR1cm4gKGFHcmVldCB8fCBiR3JlZXQpID8gKGFHcmVldCA9PSBiR3JlZXQpIDogdW5kZWZpbmVkO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VxdWFsKGEsIGIsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gYmFzZUlzRXF1YWwoYSwgYiwgdHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicgJiYgYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMsIG9yIGNhbiBiZSBjb2VyY2VkIHRvLCBhIGZpbml0ZSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIGlzIG5vdCB0aGUgc2FtZSBhcyBuYXRpdmUgYGlzRmluaXRlYCB3aGljaCB3aWxsIHJldHVybiB0cnVlIGZvclxuICAgICAqIGJvb2xlYW5zIGFuZCBlbXB0eSBzdHJpbmdzLiBTZWUgaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS4xLjIuNS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGZpbml0ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKC0xMDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoJzEwJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSh0cnVlKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSgnJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGaW5pdGUodmFsdWUpIHtcbiAgICAgIHJldHVybiBuYXRpdmVJc0Zpbml0ZSh2YWx1ZSkgJiYgIW5hdGl2ZUlzTmFOKHBhcnNlRmxvYXQodmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRnVuY3Rpb24oXyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJztcbiAgICB9XG4gICAgLy8gZmFsbGJhY2sgZm9yIG9sZGVyIHZlcnNpb25zIG9mIENocm9tZSBhbmQgU2FmYXJpXG4gICAgaWYgKGlzRnVuY3Rpb24oL3gvKSkge1xuICAgICAgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBmdW5jQ2xhc3M7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZSBsYW5ndWFnZSB0eXBlIG9mIE9iamVjdC5cbiAgICAgKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KHt9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdCgxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgICAvLyBjaGVjayBpZiB0aGUgdmFsdWUgaXMgdGhlIEVDTUFTY3JpcHQgbGFuZ3VhZ2UgdHlwZSBvZiBPYmplY3RcbiAgICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4OFxuICAgICAgLy8gYW5kIGF2b2lkIGEgVjggYnVnXG4gICAgICAvLyBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxXG4gICAgICByZXR1cm4gISEodmFsdWUgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIHZhbHVlXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYE5hTmAuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIGlzIG5vdCB0aGUgc2FtZSBhcyBuYXRpdmUgYGlzTmFOYCB3aGljaCB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yXG4gICAgICogYHVuZGVmaW5lZGAgYW5kIG90aGVyIG5vbi1udW1lcmljIHZhbHVlcy4gU2VlIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMS4yLjQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKE5hTik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hTihuZXcgTnVtYmVyKE5hTikpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGlzTmFOKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hTih1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOYU4odmFsdWUpIHtcbiAgICAgIC8vIGBOYU5gIGFzIGEgcHJpbWl0aXZlIGlzIHRoZSBvbmx5IHZhbHVlIHRoYXQgaXMgbm90IGVxdWFsIHRvIGl0c2VsZlxuICAgICAgLy8gKHBlcmZvcm0gdGhlIFtbQ2xhc3NdXSBjaGVjayBmaXJzdCB0byBhdm9pZCBlcnJvcnMgd2l0aCBzb21lIGhvc3Qgb2JqZWN0cyBpbiBJRSlcbiAgICAgIHJldHVybiBpc051bWJlcih2YWx1ZSkgJiYgdmFsdWUgIT0gK3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGBudWxsYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTnVsbChudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVsbCh1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdWxsKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBOb3RlOiBgTmFOYCBpcyBjb25zaWRlcmVkIGEgbnVtYmVyLiBTZWUgaHR0cDovL2VzNS5naXRodWIuaW8vI3g4LjUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKDguNCAqIDUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgICB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gbnVtYmVyQ2xhc3MgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBTaGFwZSgpIHtcbiAgICAgKiAgIHRoaXMueCA9IDA7XG4gICAgICogICB0aGlzLnkgPSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChuZXcgU2hhcGUpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIHZhciBpc1BsYWluT2JqZWN0ID0gIWdldFByb3RvdHlwZU9mID8gc2hpbUlzUGxhaW5PYmplY3QgOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKCEodmFsdWUgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gb2JqZWN0Q2xhc3MpIHx8ICghc3VwcG9ydC5hcmdzQ2xhc3MgJiYgaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YsXG4gICAgICAgICAgb2JqUHJvdG8gPSBpc05hdGl2ZSh2YWx1ZU9mKSAmJiAob2JqUHJvdG8gPSBnZXRQcm90b3R5cGVPZih2YWx1ZU9mKSkgJiYgZ2V0UHJvdG90eXBlT2Yob2JqUHJvdG8pO1xuXG4gICAgICByZXR1cm4gb2JqUHJvdG9cbiAgICAgICAgPyAodmFsdWUgPT0gb2JqUHJvdG8gfHwgZ2V0UHJvdG90eXBlT2YodmFsdWUpID09IG9ialByb3RvKVxuICAgICAgICA6IHNoaW1Jc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzUmVnRXhwKC9mcmVkLyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUmVnRXhwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIHZhbHVlXSAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSByZWdleHBDbGFzcyB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgc3RyaW5nLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTdHJpbmcoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHxcbiAgICAgICAgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN0cmluZ0NsYXNzIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1VuZGVmaW5lZCh2b2lkIDApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAndW5kZWZpbmVkJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYXMgYG9iamVjdGAgYW5kIHZhbHVlcyBnZW5lcmF0ZWQgYnlcbiAgICAgKiBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGUgcHJvcGVydHkgb2YgYG9iamVjdGAgdGhyb3VnaCB0aGUgY2FsbGJhY2suXG4gICAgICogVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cztcbiAgICAgKiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIHZhbHVlcyBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGBjYWxsYmFja2AgZXhlY3V0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcFZhbHVlcyh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDN9ICwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gKiAzOyB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMywgJ2InOiA2LCAnYyc6IDkgfVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSB7XG4gICAgICogICAnZnJlZCc6IHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWFwVmFsdWVzKGNoYXJhY3RlcnMsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogNDAsICdwZWJibGVzJzogMSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwVmFsdWVzKG9iamVjdCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcblxuICAgICAgZm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBtZXJnZXMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiB0aGUgc291cmNlIG9iamVjdChzKSwgdGhhdFxuICAgICAqIGRvbid0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAgaW50byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LiBTdWJzZXF1ZW50IHNvdXJjZXNcbiAgICAgKiB3aWxsIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLiBJZiBhIGNhbGxiYWNrIGlzXG4gICAgICogcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZCB0byBwcm9kdWNlIHRoZSBtZXJnZWQgdmFsdWVzIG9mIHRoZSBkZXN0aW5hdGlvblxuICAgICAqIGFuZCBzb3VyY2UgcHJvcGVydGllcy4gSWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYHVuZGVmaW5lZGAgbWVyZ2luZyB3aWxsXG4gICAgICogYmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAgICogaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM7IChvYmplY3RWYWx1ZSwgc291cmNlVmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2luZyBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG5hbWVzID0ge1xuICAgICAqICAgJ2NoYXJhY3RlcnMnOiBbXG4gICAgICogICAgIHsgJ25hbWUnOiAnYmFybmV5JyB9LFxuICAgICAqICAgICB7ICduYW1lJzogJ2ZyZWQnIH1cbiAgICAgKiAgIF1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGFnZXMgPSB7XG4gICAgICogICAnY2hhcmFjdGVycyc6IFtcbiAgICAgKiAgICAgeyAnYWdlJzogMzYgfSxcbiAgICAgKiAgICAgeyAnYWdlJzogNDAgfVxuICAgICAqICAgXVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLm1lcmdlKG5hbWVzLCBhZ2VzKTtcbiAgICAgKiAvLyA9PiB7ICdjaGFyYWN0ZXJzJzogW3sgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sIHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9XSB9XG4gICAgICpcbiAgICAgKiB2YXIgZm9vZCA9IHtcbiAgICAgKiAgICdmcnVpdHMnOiBbJ2FwcGxlJ10sXG4gICAgICogICAndmVnZXRhYmxlcyc6IFsnYmVldCddXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBvdGhlckZvb2QgPSB7XG4gICAgICogICAnZnJ1aXRzJzogWydiYW5hbmEnXSxcbiAgICAgKiAgICd2ZWdldGFibGVzJzogWydjYXJyb3QnXVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLm1lcmdlKGZvb2QsIG90aGVyRm9vZCwgZnVuY3Rpb24oYSwgYikge1xuICAgICAqICAgcmV0dXJuIF8uaXNBcnJheShhKSA/IGEuY29uY2F0KGIpIDogdW5kZWZpbmVkO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2ZydWl0cyc6IFsnYXBwbGUnLCAnYmFuYW5hJ10sICd2ZWdldGFibGVzJzogWydiZWV0JywgJ2NhcnJvdF0gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlKG9iamVjdCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgbGVuZ3RoID0gMjtcblxuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG4gICAgICAvLyBhbGxvd3Mgd29ya2luZyB3aXRoIGBfLnJlZHVjZWAgYW5kIGBfLnJlZHVjZVJpZ2h0YCB3aXRob3V0IHVzaW5nXG4gICAgICAvLyB0aGVpciBgaW5kZXhgIGFuZCBgY29sbGVjdGlvbmAgYXJndW1lbnRzXG4gICAgICBpZiAodHlwZW9mIGFyZ3NbMl0gIT0gJ251bWJlcicpIHtcbiAgICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAobGVuZ3RoID4gMyAmJiB0eXBlb2YgYXJnc1tsZW5ndGggLSAyXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGJhc2VDcmVhdGVDYWxsYmFjayhhcmdzWy0tbGVuZ3RoIC0gMV0sIGFyZ3NbbGVuZ3RoLS1dLCAyKTtcbiAgICAgIH0gZWxzZSBpZiAobGVuZ3RoID4gMiAmJiB0eXBlb2YgYXJnc1tsZW5ndGggLSAxXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gYXJnc1stLWxlbmd0aF07XG4gICAgICB9XG4gICAgICB2YXIgc291cmNlcyA9IHNsaWNlKGFyZ3VtZW50cywgMSwgbGVuZ3RoKSxcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIHN0YWNrQSA9IGdldEFycmF5KCksXG4gICAgICAgICAgc3RhY2tCID0gZ2V0QXJyYXkoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlc1tpbmRleF0sIGNhbGxiYWNrLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICB9XG4gICAgICByZWxlYXNlQXJyYXkoc3RhY2tBKTtcbiAgICAgIHJlbGVhc2VBcnJheShzdGFja0IpO1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2hhbGxvdyBjbG9uZSBvZiBgb2JqZWN0YCBleGNsdWRpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAqIFByb3BlcnR5IG5hbWVzIG1heSBiZSBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXMgYXJyYXlzIG9mXG4gICAgICogcHJvcGVydHkgbmFtZXMuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZCBmb3IgZWFjaFxuICAgICAqIHByb3BlcnR5IG9mIGBvYmplY3RgIG9taXR0aW5nIHRoZSBwcm9wZXJ0aWVzIHRoZSBjYWxsYmFjayByZXR1cm5zIHRydWV5XG4gICAgICogZm9yLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzO1xuICAgICAqICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258Li4uc3RyaW5nfHN0cmluZ1tdfSBbY2FsbGJhY2tdIFRoZSBwcm9wZXJ0aWVzIHRvIG9taXQgb3IgdGhlXG4gICAgICogIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IHdpdGhvdXQgdGhlIG9taXR0ZWQgcHJvcGVydGllcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5vbWl0KHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9LCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJyB9XG4gICAgICpcbiAgICAgKiBfLm9taXQoeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9taXQob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IFtdO1xuICAgICAgICBmb3JJbihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICBwcm9wcy5wdXNoKGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcm9wcyA9IGJhc2VEaWZmZXJlbmNlKHByb3BzLCBiYXNlRmxhdHRlbihhcmd1bWVudHMsIHRydWUsIGZhbHNlLCAxKSk7XG5cbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gb2JqZWN0W2tleV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgZm9ySW4ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgICBpZiAoIWNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHR3byBkaW1lbnNpb25hbCBhcnJheSBvZiBhbiBvYmplY3QncyBrZXktdmFsdWUgcGFpcnMsXG4gICAgICogaS5lLiBgW1trZXkxLCB2YWx1ZTFdLCBba2V5MiwgdmFsdWUyXV1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgbmV3IGFycmF5IG9mIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWlycyh7ICdiYXJuZXknOiAzNiwgJ2ZyZWQnOiA0MCB9KTtcbiAgICAgKiAvLyA9PiBbWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDQwXV0gKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFpcnMob2JqZWN0KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBwcm9wcyA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IFtrZXksIG9iamVjdFtrZXldXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYG9iamVjdGAgY29tcG9zZWQgb2YgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAqIFByb3BlcnR5IG5hbWVzIG1heSBiZSBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXMgYXJyYXlzIG9mXG4gICAgICogcHJvcGVydHkgbmFtZXMuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZCBmb3IgZWFjaFxuICAgICAqIHByb3BlcnR5IG9mIGBvYmplY3RgIHBpY2tpbmcgdGhlIHByb3BlcnRpZXMgdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXlcbiAgICAgKiBmb3IuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7XG4gICAgICogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnwuLi5zdHJpbmd8c3RyaW5nW119IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXJcbiAgICAgKiAgaXRlcmF0aW9uIG9yIHByb3BlcnR5IG5hbWVzIHRvIHBpY2ssIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIHByb3BlcnR5XG4gICAgICogIG5hbWVzIG9yIGFycmF5cyBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgcGlja2VkIHByb3BlcnRpZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGljayh7ICduYW1lJzogJ2ZyZWQnLCAnX3VzZXJpZCc6ICdmcmVkMScgfSwgJ25hbWUnKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2ZyZWQnIH1cbiAgICAgKlxuICAgICAqIF8ucGljayh7ICduYW1lJzogJ2ZyZWQnLCAnX3VzZXJpZCc6ICdmcmVkMScgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgcmV0dXJuIGtleS5jaGFyQXQoMCkgIT0gJ18nO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBpY2sob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgcHJvcHMgPSBiYXNlRmxhdHRlbihhcmd1bWVudHMsIHRydWUsIGZhbHNlLCAxKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGlzT2JqZWN0KG9iamVjdCkgPyBwcm9wcy5sZW5ndGggOiAwO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgZm9ySW4ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0KSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBhbHRlcm5hdGl2ZSB0byBgXy5yZWR1Y2VgIHRoaXMgbWV0aG9kIHRyYW5zZm9ybXMgYG9iamVjdGAgdG8gYSBuZXdcbiAgICAgKiBgYWNjdW11bGF0b3JgIG9iamVjdCB3aGljaCBpcyB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgZWFjaCBvZiBpdHMgb3duXG4gICAgICogZW51bWVyYWJsZSBwcm9wZXJ0aWVzIHRocm91Z2ggYSBjYWxsYmFjaywgd2l0aCBlYWNoIGNhbGxiYWNrIGV4ZWN1dGlvblxuICAgICAqIHBvdGVudGlhbGx5IG11dGF0aW5nIHRoZSBgYWNjdW11bGF0b3JgIG9iamVjdC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvXG4gICAgICogYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM7IChhY2N1bXVsYXRvciwgdmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKiBDYWxsYmFja3MgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBjdXN0b20gYWNjdW11bGF0b3IgdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc3F1YXJlcyA9IF8udHJhbnNmb3JtKFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMF0sIGZ1bmN0aW9uKHJlc3VsdCwgbnVtKSB7XG4gICAgICogICBudW0gKj0gbnVtO1xuICAgICAqICAgaWYgKG51bSAlIDIpIHtcbiAgICAgKiAgICAgcmV0dXJuIHJlc3VsdC5wdXNoKG51bSkgPCAzO1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsxLCA5LCAyNV1cbiAgICAgKlxuICAgICAqIHZhciBtYXBwZWQgPSBfLnRyYW5zZm9ybSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSwgZnVuY3Rpb24ocmVzdWx0LCBudW0sIGtleSkge1xuICAgICAqICAgcmVzdWx0W2tleV0gPSBudW0gKiAzO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAzLCAnYic6IDYsICdjJzogOSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtKG9iamVjdCwgY2FsbGJhY2ssIGFjY3VtdWxhdG9yLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KG9iamVjdCk7XG4gICAgICBpZiAoYWNjdW11bGF0b3IgPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjdG9yID0gb2JqZWN0ICYmIG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgICAgICAgcHJvdG8gPSBjdG9yICYmIGN0b3IucHJvdG90eXBlO1xuXG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBiYXNlQ3JlYXRlKHByb3RvKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCA0KTtcbiAgICAgICAgKGlzQXJyID8gYmFzZUVhY2ggOiBmb3JPd24pKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgb2JqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBjb21wb3NlZCBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnZhbHVlcyh7ICdvbmUnOiAxLCAndHdvJzogMiwgJ3RocmVlJzogMyB9KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM10gKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsdWVzKG9iamVjdCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcHJvcHMgPSBrZXlzKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBvYmplY3RbcHJvcHNbaW5kZXhdXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzIGZyb20gdGhlIHNwZWNpZmllZCBpbmRleGVzLCBvciBrZXlzLCBvZiB0aGVcbiAgICAgKiBgY29sbGVjdGlvbmAuIEluZGV4ZXMgbWF5IGJlIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cyBvciBhcyBhcnJheXNcbiAgICAgKiBvZiBpbmRleGVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0gey4uLihudW1iZXJ8bnVtYmVyW118c3RyaW5nfHN0cmluZ1tdKX0gW2luZGV4XSBUaGUgaW5kZXhlcyBvZiBgY29sbGVjdGlvbmBcbiAgICAgKiAgIHRvIHJldHJpZXZlLCBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBpbmRleGVzIG9yIGFycmF5cyBvZiBpbmRleGVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBlbGVtZW50cyBjb3JyZXNwb25kaW5nIHRvIHRoZVxuICAgICAqICBwcm92aWRlZCBpbmRleGVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmF0KFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ10sIFswLCAyLCA0XSk7XG4gICAgICogLy8gPT4gWydhJywgJ2MnLCAnZSddXG4gICAgICpcbiAgICAgKiBfLmF0KFsnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcyddLCAwLCAyKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXQoY29sbGVjdGlvbikge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBwcm9wcyA9IGJhc2VGbGF0dGVuKGFyZ3MsIHRydWUsIGZhbHNlLCAxKSxcbiAgICAgICAgICBsZW5ndGggPSAoYXJnc1syXSAmJiBhcmdzWzJdW2FyZ3NbMV1dID09PSBjb2xsZWN0aW9uKSA/IDEgOiBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgaWYgKHN1cHBvcnQudW5pbmRleGVkQ2hhcnMgJiYgaXNTdHJpbmcoY29sbGVjdGlvbikpIHtcbiAgICAgICAgY29sbGVjdGlvbiA9IGNvbGxlY3Rpb24uc3BsaXQoJycpO1xuICAgICAgfVxuICAgICAgd2hpbGUoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gY29sbGVjdGlvbltwcm9wc1tpbmRleF1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBnaXZlbiB2YWx1ZSBpcyBwcmVzZW50IGluIGEgY29sbGVjdGlvbiB1c2luZyBzdHJpY3QgZXF1YWxpdHlcbiAgICAgKiBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCBpcyB1c2VkIGFzIHRoZVxuICAgICAqIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgaW5jbHVkZVxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIGNoZWNrIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdGFyZ2V0YCBlbGVtZW50IGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY29udGFpbnMoWzEsIDIsIDNdLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmNvbnRhaW5zKFsxLCAyLCAzXSwgMSwgMik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uY29udGFpbnMoeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH0sICdmcmVkJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5jb250YWlucygncGViYmxlcycsICdlYicpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb250YWlucyhjb2xsZWN0aW9uLCB0YXJnZXQsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgICBmcm9tSW5kZXggPSAoZnJvbUluZGV4IDwgMCA/IG5hdGl2ZU1heCgwLCBsZW5ndGggKyBmcm9tSW5kZXgpIDogZnJvbUluZGV4KSB8fCAwO1xuICAgICAgaWYgKGlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICAgICAgcmVzdWx0ID0gaW5kZXhPZihjb2xsZWN0aW9uLCB0YXJnZXQsIGZyb21JbmRleCkgPiAtMTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICByZXN1bHQgPSAoaXNTdHJpbmcoY29sbGVjdGlvbikgPyBjb2xsZWN0aW9uLmluZGV4T2YodGFyZ2V0LCBmcm9tSW5kZXgpIDogaW5kZXhPZihjb2xsZWN0aW9uLCB0YXJnZXQsIGZyb21JbmRleCkpID4gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGlmICgrK2luZGV4ID49IGZyb21JbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuICEocmVzdWx0ID0gdmFsdWUgPT09IHRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJvdWdoIHRoZSBjYWxsYmFjay4gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVcbiAgICAgKiBvZiBlYWNoIGtleSBpcyB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBrZXkgd2FzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjay5cbiAgICAgKiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzO1xuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY291bnRCeShbNC4zLCA2LjEsIDYuNF0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gTWF0aC5mbG9vcihudW0pOyB9KTtcbiAgICAgKiAvLyA9PiB7ICc0JzogMSwgJzYnOiAyIH1cbiAgICAgKlxuICAgICAqIF8uY291bnRCeShbNC4zLCA2LjEsIDYuNF0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gdGhpcy5mbG9vcihudW0pOyB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiB7ICc0JzogMSwgJzYnOiAyIH1cbiAgICAgKlxuICAgICAqIF8uY291bnRCeShbJ29uZScsICd0d28nLCAndGhyZWUnXSwgJ2xlbmd0aCcpO1xuICAgICAqIC8vID0+IHsgJzMnOiAyLCAnNSc6IDEgfVxuICAgICAqL1xuICAgIHZhciBjb3VudEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSA/IHJlc3VsdFtrZXldKysgOiByZXN1bHRba2V5XSA9IDEpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBjYWxsYmFjayByZXR1cm5zIHRydWV5IHZhbHVlIGZvciAqKmFsbCoqIGVsZW1lbnRzIG9mXG4gICAgICogYSBjb2xsZWN0aW9uLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGFsbFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3NlZCB0aGUgY2FsbGJhY2sgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ldmVyeShbdHJ1ZSwgMSwgbnVsbCwgJ3llcyddKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmV2ZXJ5KGNoYXJhY3RlcnMsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmV2ZXJ5KGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDM2IH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZlcnkoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgICBpZiAoaXNBcnJheShjb2xsZWN0aW9uKSkge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKCEocmVzdWx0ID0gISFjYWxsYmFjayhjb2xsZWN0aW9uW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gKHJlc3VsdCA9ICEhY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGEgY29sbGVjdGlvbiwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50c1xuICAgICAqIHRoZSBjYWxsYmFjayByZXR1cm5zIHRydWV5IGZvci4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmRcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBzZWxlY3RcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGVsZW1lbnRzIHRoYXQgcGFzc2VkIHRoZSBjYWxsYmFjayBjaGVjay5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGV2ZW5zID0gXy5maWx0ZXIoWzEsIDIsIDMsIDQsIDUsIDZdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSAlIDIgPT0gMDsgfSk7XG4gICAgICogLy8gPT4gWzIsIDQsIDZdXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maWx0ZXIoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfV1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmlsdGVyKGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDM2IH0pO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbHRlcihjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgICBpZiAoaXNBcnJheShjb2xsZWN0aW9uKSkge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gY29sbGVjdGlvbltpbmRleF07XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBhIGNvbGxlY3Rpb24sIHJldHVybmluZyB0aGUgZmlyc3QgZWxlbWVudCB0aGF0XG4gICAgICogdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkgZm9yLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZFxuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGRldGVjdCwgZmluZFdoZXJlXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2Jsb2NrZWQnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZChjaGFyYWN0ZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlIDwgNDA7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kKGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDEgfSk7XG4gICAgICogLy8gPT4gIHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxLCAnYmxvY2tlZCc6IGZhbHNlIH1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgIGlmIChpc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBjb2xsZWN0aW9uW2luZGV4XTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYSBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0KFsxLCAyLCAzLCA0XSwgZnVuY3Rpb24obnVtKSB7XG4gICAgICogICByZXR1cm4gbnVtICUgMiA9PSAxO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTGFzdChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIGZvckVhY2hSaWdodChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGEgY29sbGVjdGlvbiwgZXhlY3V0aW5nIHRoZSBjYWxsYmFjayBmb3IgZWFjaFxuICAgICAqIGVsZW1lbnQuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLiBDYWxsYmFja3MgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5XG4gICAgICogZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIE5vdGU6IEFzIHdpdGggb3RoZXIgXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMsIG9iamVjdHMgd2l0aCBhIGBsZW5ndGhgIHByb3BlcnR5XG4gICAgICogYXJlIGl0ZXJhdGVkIGxpa2UgYXJyYXlzLiBUbyBhdm9pZCB0aGlzIGJlaGF2aW9yIGBfLmZvckluYCBvciBgXy5mb3JPd25gXG4gICAgICogbWF5IGJlIHVzZWQgZm9yIG9iamVjdCBpdGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZWFjaFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdHxzdHJpbmd9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSkuZm9yRWFjaChmdW5jdGlvbihudW0pIHsgY29uc29sZS5sb2cobnVtKTsgfSkuam9pbignLCcpO1xuICAgICAqIC8vID0+IGxvZ3MgZWFjaCBudW1iZXIgYW5kIHJldHVybnMgJzEsMiwzJ1xuICAgICAqXG4gICAgICogXy5mb3JFYWNoKHsgJ29uZSc6IDEsICd0d28nOiAyLCAndGhyZWUnOiAzIH0sIGZ1bmN0aW9uKG51bSkgeyBjb25zb2xlLmxvZyhudW0pOyB9KTtcbiAgICAgKiAvLyA9PiBsb2dzIGVhY2ggbnVtYmVyIGFuZCByZXR1cm5zIHRoZSBvYmplY3QgKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yRWFjaChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgaWYgKGNhbGxiYWNrICYmIHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnICYmIGlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmIChjYWxsYmFjayhjb2xsZWN0aW9uW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckVhY2hgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBhIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZWFjaFJpZ2h0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fHN0cmluZ30gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKS5mb3JFYWNoUmlnaHQoZnVuY3Rpb24obnVtKSB7IGNvbnNvbGUubG9nKG51bSk7IH0pLmpvaW4oJywnKTtcbiAgICAgKiAvLyA9PiBsb2dzIGVhY2ggbnVtYmVyIGZyb20gcmlnaHQgdG8gbGVmdCBhbmQgcmV0dXJucyAnMywyLDEnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yRWFjaFJpZ2h0KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaXRlcmFibGUgPSBjb2xsZWN0aW9uLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG5cbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgJiYgdHlwZW9mIHRoaXNBcmcgPT0gJ3VuZGVmaW5lZCcgPyBjYWxsYmFjayA6IGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICBpZiAoaXNBcnJheShjb2xsZWN0aW9uKSkge1xuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2soY29sbGVjdGlvbltsZW5ndGhdLCBsZW5ndGgsIGNvbGxlY3Rpb24pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIGxlbmd0aCAhPSAnbnVtYmVyJykge1xuICAgICAgICAgIHZhciBwcm9wcyA9IGtleXMoY29sbGVjdGlvbik7XG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuICAgICAgICB9IGVsc2UgaWYgKHN1cHBvcnQudW5pbmRleGVkQ2hhcnMgJiYgaXNTdHJpbmcoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICBpdGVyYWJsZSA9IGNvbGxlY3Rpb24uc3BsaXQoJycpO1xuICAgICAgICB9XG4gICAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICBrZXkgPSBwcm9wcyA/IHByb3BzWy0tbGVuZ3RoXSA6IC0tbGVuZ3RoO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhpdGVyYWJsZVtrZXldLCBrZXksIGNvbGxlY3Rpb24pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBhIGNvbGxlY3Rpb24gdGhyb3VnaCB0aGUgY2FsbGJhY2suIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlXG4gICAgICogb2YgZWFjaCBrZXkgaXMgYW4gYXJyYXkgb2YgdGhlIGVsZW1lbnRzIHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZSBrZXkuXG4gICAgICogVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cztcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZ3JvdXBCeShbNC4yLCA2LjEsIDYuNF0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gTWF0aC5mbG9vcihudW0pOyB9KTtcbiAgICAgKiAvLyA9PiB7ICc0JzogWzQuMl0sICc2JzogWzYuMSwgNi40XSB9XG4gICAgICpcbiAgICAgKiBfLmdyb3VwQnkoWzQuMiwgNi4xLCA2LjRdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIHRoaXMuZmxvb3IobnVtKTsgfSwgTWF0aCk7XG4gICAgICogLy8gPT4geyAnNCc6IFs0LjJdLCAnNic6IFs2LjEsIDYuNF0gfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5ncm91cEJ5KFsnb25lJywgJ3R3bycsICd0aHJlZSddLCAnbGVuZ3RoJyk7XG4gICAgICogLy8gPT4geyAnMyc6IFsnb25lJywgJ3R3byddLCAnNSc6IFsndGhyZWUnXSB9XG4gICAgICovXG4gICAgdmFyIGdyb3VwQnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpID8gcmVzdWx0W2tleV0gOiByZXN1bHRba2V5XSA9IFtdKS5wdXNoKHZhbHVlKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiB0aGUgY29sbGVjdGlvbiB0aHJvdWdoIHRoZSBnaXZlbiBjYWxsYmFjay4gVGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiB2YWx1ZSBvZiBlYWNoIGtleSBpcyB0aGUgbGFzdCBlbGVtZW50IHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZSBrZXkuXG4gICAgICogVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cztcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIga2V5cyA9IFtcbiAgICAgKiAgIHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LFxuICAgICAqICAgeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmluZGV4Qnkoa2V5cywgJ2RpcicpO1xuICAgICAqIC8vID0+IHsgJ2xlZnQnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ3JpZ2h0JzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICpcbiAgICAgKiBfLmluZGV4Qnkoa2V5cywgZnVuY3Rpb24oa2V5KSB7IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGtleS5jb2RlKTsgfSk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAnZCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqXG4gICAgICogXy5pbmRleEJ5KGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGtleSkgeyB0aGlzLmZyb21DaGFyQ29kZShrZXkuY29kZSk7IH0sIFN0cmluZyk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAnZCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqL1xuICAgIHZhciBpbmRleEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBtZXRob2QgbmFtZWQgYnkgYG1ldGhvZE5hbWVgIG9uIGVhY2ggZWxlbWVudCBpbiB0aGUgYGNvbGxlY3Rpb25gXG4gICAgICogcmV0dXJuaW5nIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggaW52b2tlZCBtZXRob2QuIEFkZGl0aW9uYWwgYXJndW1lbnRzXG4gICAgICogd2lsbCBiZSBwcm92aWRlZCB0byBlYWNoIGludm9rZWQgbWV0aG9kLiBJZiBgbWV0aG9kTmFtZWAgaXMgYSBmdW5jdGlvbiBpdFxuICAgICAqIHdpbGwgYmUgaW52b2tlZCBmb3IsIGFuZCBgdGhpc2AgYm91bmQgdG8sIGVhY2ggZWxlbWVudCBpbiB0aGUgYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRvIGludm9rZSBvclxuICAgICAqICB0aGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ10gQXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggaW52b2tlZCBtZXRob2QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW52b2tlKFtbNSwgMSwgN10sIFszLCAyLCAxXV0sICdzb3J0Jyk7XG4gICAgICogLy8gPT4gW1sxLCA1LCA3XSwgWzEsIDIsIDNdXVxuICAgICAqXG4gICAgICogXy5pbnZva2UoWzEyMywgNDU2XSwgU3RyaW5nLnByb3RvdHlwZS5zcGxpdCwgJycpO1xuICAgICAqIC8vID0+IFtbJzEnLCAnMicsICczJ10sIFsnNCcsICc1JywgJzYnXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnZva2UoY29sbGVjdGlvbiwgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDIpLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgaXNGdW5jID0gdHlwZW9mIG1ldGhvZE5hbWUgPT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgPyBsZW5ndGggOiAwKTtcblxuICAgICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXN1bHRbKytpbmRleF0gPSAoaXNGdW5jID8gbWV0aG9kTmFtZSA6IHZhbHVlW21ldGhvZE5hbWVdKS5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB2YWx1ZXMgYnkgcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gdGhlIGNvbGxlY3Rpb25cbiAgICAgKiB0aHJvdWdoIHRoZSBjYWxsYmFjay4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoXG4gICAgICogdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBjb2xsZWN0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGBjYWxsYmFja2AgZXhlY3V0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcChbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtICogMzsgfSk7XG4gICAgICogLy8gPT4gWzMsIDYsIDldXG4gICAgICpcbiAgICAgKiBfLm1hcCh7ICdvbmUnOiAxLCAndHdvJzogMiwgJ3RocmVlJzogMyB9LCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSAqIDM7IH0pO1xuICAgICAqIC8vID0+IFszLCA2LCA5XSAocHJvcGVydHkgb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGVudmlyb25tZW50cylcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5tYXAoY2hhcmFjdGVycywgJ25hbWUnKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXAoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyA/IGxlbmd0aCA6IDApO1xuXG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICBpZiAoaXNBcnJheShjb2xsZWN0aW9uKSkge1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBjYWxsYmFjayhjb2xsZWN0aW9uW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgcmVzdWx0WysraW5kZXhdID0gY2FsbGJhY2sodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIG1heGltdW0gdmFsdWUgb2YgYSBjb2xsZWN0aW9uLiBJZiB0aGUgY29sbGVjdGlvbiBpcyBlbXB0eSBvclxuICAgICAqIGZhbHNleSBgLUluZmluaXR5YCBpcyByZXR1cm5lZC4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkXG4gICAgICogZm9yIGVhY2ggdmFsdWUgaW4gdGhlIGNvbGxlY3Rpb24gdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaCB0aGUgdmFsdWVcbiAgICAgKiBpcyByYW5rZWQuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXgoWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiA4XG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWF4KGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGNocikgeyByZXR1cm4gY2hyLmFnZTsgfSk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1heChjaGFyYWN0ZXJzLCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH07XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF4KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgY29tcHV0ZWQgPSAtSW5maW5pdHksXG4gICAgICAgICAgcmVzdWx0ID0gY29tcHV0ZWQ7XG5cbiAgICAgIC8vIGFsbG93cyB3b3JraW5nIHdpdGggZnVuY3Rpb25zIGxpa2UgYF8ubWFwYCB3aXRob3V0IHVzaW5nXG4gICAgICAvLyB0aGVpciBgaW5kZXhgIGFyZ3VtZW50IGFzIGEgY2FsbGJhY2tcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ2Z1bmN0aW9uJyAmJiB0aGlzQXJnICYmIHRoaXNBcmdbY2FsbGJhY2tdID09PSBjb2xsZWN0aW9uKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFjayA9PSBudWxsICYmIGlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbGxlY3Rpb25baW5kZXhdO1xuICAgICAgICAgIGlmICh2YWx1ZSA+IHJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayA9IChjYWxsYmFjayA9PSBudWxsICYmIGlzU3RyaW5nKGNvbGxlY3Rpb24pKVxuICAgICAgICAgID8gY2hhckF0Q2FsbGJhY2tcbiAgICAgICAgICA6IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICAgIGlmIChjdXJyZW50ID4gY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIGNvbXB1dGVkID0gY3VycmVudDtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgbWluaW11bSB2YWx1ZSBvZiBhIGNvbGxlY3Rpb24uIElmIHRoZSBjb2xsZWN0aW9uIGlzIGVtcHR5IG9yXG4gICAgICogZmFsc2V5IGBJbmZpbml0eWAgaXMgcmV0dXJuZWQuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZFxuICAgICAqIGZvciBlYWNoIHZhbHVlIGluIHRoZSBjb2xsZWN0aW9uIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2ggdGhlIHZhbHVlXG4gICAgICogaXMgcmFua2VkLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWluKFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1pbihjaGFyYWN0ZXJzLCBmdW5jdGlvbihjaHIpIHsgcmV0dXJuIGNoci5hZ2U7IH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1pbihjaGFyYWN0ZXJzLCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaW4oY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBjb21wdXRlZCA9IEluZmluaXR5LFxuICAgICAgICAgIHJlc3VsdCA9IGNvbXB1dGVkO1xuXG4gICAgICAvLyBhbGxvd3Mgd29ya2luZyB3aXRoIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAgd2l0aG91dCB1c2luZ1xuICAgICAgLy8gdGhlaXIgYGluZGV4YCBhcmd1bWVudCBhcyBhIGNhbGxiYWNrXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdmdW5jdGlvbicgJiYgdGhpc0FyZyAmJiB0aGlzQXJnW2NhbGxiYWNrXSA9PT0gY29sbGVjdGlvbikge1xuICAgICAgICBjYWxsYmFjayA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2sgPT0gbnVsbCAmJiBpc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBjb2xsZWN0aW9uW2luZGV4XTtcbiAgICAgICAgICBpZiAodmFsdWUgPCByZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sgPSAoY2FsbGJhY2sgPT0gbnVsbCAmJiBpc1N0cmluZyhjb2xsZWN0aW9uKSlcbiAgICAgICAgICA/IGNoYXJBdENhbGxiYWNrXG4gICAgICAgICAgOiBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHZhciBjdXJyZW50ID0gY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgICBpZiAoY3VycmVudCA8IGNvbXB1dGVkKSB7XG4gICAgICAgICAgICBjb21wdXRlZCA9IGN1cnJlbnQ7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHZhbHVlIG9mIGEgc3BlY2lmaWVkIHByb3BlcnR5IGZyb20gYWxsIGVsZW1lbnRzIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gcGx1Y2suXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnBsdWNrKGNoYXJhY3RlcnMsICduYW1lJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICovXG4gICAgdmFyIHBsdWNrID0gbWFwO1xuXG4gICAgLyoqXG4gICAgICogUmVkdWNlcyBhIGNvbGxlY3Rpb24gdG8gYSB2YWx1ZSB3aGljaCBpcyB0aGUgYWNjdW11bGF0ZWQgcmVzdWx0IG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgaW4gdGhlIGNvbGxlY3Rpb24gdGhyb3VnaCB0aGUgY2FsbGJhY2ssIHdoZXJlIGVhY2ggc3VjY2Vzc2l2ZVxuICAgICAqIGNhbGxiYWNrIGV4ZWN1dGlvbiBjb25zdW1lcyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cyBleGVjdXRpb24uIElmXG4gICAgICogYGFjY3VtdWxhdG9yYCBpcyBub3QgcHJvdmlkZWQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGNvbGxlY3Rpb24gd2lsbCBiZVxuICAgICAqIHVzZWQgYXMgdGhlIGluaXRpYWwgYGFjY3VtdWxhdG9yYCB2YWx1ZS4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYFxuICAgICAqIGFuZCBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM7IChhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZm9sZGwsIGluamVjdFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIEluaXRpYWwgdmFsdWUgb2YgdGhlIGFjY3VtdWxhdG9yLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHN1bSA9IF8ucmVkdWNlKFsxLCAyLCAzXSwgZnVuY3Rpb24oc3VtLCBudW0pIHtcbiAgICAgKiAgIHJldHVybiBzdW0gKyBudW07XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gNlxuICAgICAqXG4gICAgICogdmFyIG1hcHBlZCA9IF8ucmVkdWNlKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LCBmdW5jdGlvbihyZXN1bHQsIG51bSwga2V5KSB7XG4gICAgICogICByZXN1bHRba2V5XSA9IG51bSAqIDM7XG4gICAgICogICByZXR1cm4gcmVzdWx0O1xuICAgICAqIH0sIHt9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMywgJ2InOiA2LCAnYyc6IDkgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZHVjZShjb2xsZWN0aW9uLCBjYWxsYmFjaywgYWNjdW11bGF0b3IsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBub2FjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgNCk7XG5cbiAgICAgIGlmIChpc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cbiAgICAgICAgaWYgKG5vYWNjdW0pIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGNvbGxlY3Rpb25bKytpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGNhbGxiYWNrKGFjY3VtdWxhdG9yLCBjb2xsZWN0aW9uW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IG5vYWNjdW1cbiAgICAgICAgICAgID8gKG5vYWNjdW0gPSBmYWxzZSwgdmFsdWUpXG4gICAgICAgICAgICA6IGNhbGxiYWNrKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucmVkdWNlYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYSBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGZvbGRyXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gSW5pdGlhbCB2YWx1ZSBvZiB0aGUgYWNjdW11bGF0b3IuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgbGlzdCA9IFtbMCwgMV0sIFsyLCAzXSwgWzQsIDVdXTtcbiAgICAgKiB2YXIgZmxhdCA9IF8ucmVkdWNlUmlnaHQobGlzdCwgZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYS5jb25jYXQoYik7IH0sIFtdKTtcbiAgICAgKiAvLyA9PiBbNCwgNSwgMiwgMywgMCwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWR1Y2VSaWdodChjb2xsZWN0aW9uLCBjYWxsYmFjaywgYWNjdW11bGF0b3IsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBub2FjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgNCk7XG4gICAgICBmb3JFYWNoUmlnaHQoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIGFjY3VtdWxhdG9yID0gbm9hY2N1bVxuICAgICAgICAgID8gKG5vYWNjdW0gPSBmYWxzZSwgdmFsdWUpXG4gICAgICAgICAgOiBjYWxsYmFjayhhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5maWx0ZXJgIHRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGVsZW1lbnRzIG9mIGFcbiAgICAgKiBjb2xsZWN0aW9uIHRoYXQgdGhlIGNhbGxiYWNrIGRvZXMgKipub3QqKiByZXR1cm4gdHJ1ZXkgZm9yLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGVsZW1lbnRzIHRoYXQgZmFpbGVkIHRoZSBjYWxsYmFjayBjaGVjay5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9kZHMgPSBfLnJlamVjdChbMSwgMiwgMywgNCwgNSwgNl0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtICUgMiA9PSAwOyB9KTtcbiAgICAgKiAvLyA9PiBbMSwgMywgNV1cbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnJlamVjdChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9XVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5yZWplY3QoY2hhcmFjdGVycywgeyAnYWdlJzogMzYgfSk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVqZWN0KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICByZXR1cm4gZmlsdGVyKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gIWNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSByYW5kb20gZWxlbWVudCBvciBgbmAgcmFuZG9tIGVsZW1lbnRzIGZyb20gYSBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW25dIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBBbGxvd3Mgd29ya2luZyB3aXRoIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGBcbiAgICAgKiAgd2l0aG91dCB1c2luZyB0aGVpciBgaW5kZXhgIGFyZ3VtZW50cyBhcyBgbmAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5kb20gc2FtcGxlKHMpIG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zYW1wbGUoWzEsIDIsIDMsIDRdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZShbMSwgMiwgMywgNF0sIDIpO1xuICAgICAqIC8vID0+IFszLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhbXBsZShjb2xsZWN0aW9uLCBuLCBndWFyZCkge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gJiYgdHlwZW9mIGNvbGxlY3Rpb24ubGVuZ3RoICE9ICdudW1iZXInKSB7XG4gICAgICAgIGNvbGxlY3Rpb24gPSB2YWx1ZXMoY29sbGVjdGlvbik7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQudW5pbmRleGVkQ2hhcnMgJiYgaXNTdHJpbmcoY29sbGVjdGlvbikpIHtcbiAgICAgICAgY29sbGVjdGlvbiA9IGNvbGxlY3Rpb24uc3BsaXQoJycpO1xuICAgICAgfVxuICAgICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkge1xuICAgICAgICByZXR1cm4gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb25bYmFzZVJhbmRvbSgwLCBjb2xsZWN0aW9uLmxlbmd0aCAtIDEpXSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBzaHVmZmxlKGNvbGxlY3Rpb24pO1xuICAgICAgcmVzdWx0Lmxlbmd0aCA9IG5hdGl2ZU1pbihuYXRpdmVNYXgoMCwgbiksIHJlc3VsdC5sZW5ndGgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHNodWZmbGVkIHZhbHVlcywgdXNpbmcgYSB2ZXJzaW9uIG9mIHRoZSBGaXNoZXItWWF0ZXNcbiAgICAgKiBzaHVmZmxlLiBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXItWWF0ZXNfc2h1ZmZsZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzaHVmZmxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBzaHVmZmxlZCBjb2xsZWN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNodWZmbGUoWzEsIDIsIDMsIDQsIDUsIDZdKTtcbiAgICAgKiAvLyA9PiBbNCwgMSwgNiwgMywgNSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaHVmZmxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyA/IGxlbmd0aCA6IDApO1xuXG4gICAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciByYW5kID0gYmFzZVJhbmRvbSgwLCArK2luZGV4KTtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IHJlc3VsdFtyYW5kXTtcbiAgICAgICAgcmVzdWx0W3JhbmRdID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc2l6ZSBvZiB0aGUgYGNvbGxlY3Rpb25gIGJ5IHJldHVybmluZyBgY29sbGVjdGlvbi5sZW5ndGhgIGZvciBhcnJheXNcbiAgICAgKiBhbmQgYXJyYXktbGlrZSBvYmplY3RzIG9yIHRoZSBudW1iZXIgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBmb3Igb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYGNvbGxlY3Rpb24ubGVuZ3RoYCBvciBudW1iZXIgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zaXplKFsxLCAyXSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5zaXplKHsgJ29uZSc6IDEsICd0d28nOiAyLCAndGhyZWUnOiAzIH0pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uc2l6ZSgncGViYmxlcycpO1xuICAgICAqIC8vID0+IDdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaXplKGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuICAgICAgcmV0dXJuIHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgPyBsZW5ndGggOiBrZXlzKGNvbGxlY3Rpb24pLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYSB0cnVleSB2YWx1ZSBmb3IgKiphbnkqKiBlbGVtZW50IG9mIGFcbiAgICAgKiBjb2xsZWN0aW9uLiBUaGUgZnVuY3Rpb24gcmV0dXJucyBhcyBzb29uIGFzIGl0IGZpbmRzIGEgcGFzc2luZyB2YWx1ZSBhbmRcbiAgICAgKiBkb2VzIG5vdCBpdGVyYXRlIG92ZXIgdGhlIGVudGlyZSBjb2xsZWN0aW9uLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG9cbiAgICAgKiBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGFueVxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VkIHRoZSBjYWxsYmFjayBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvbWUoW251bGwsIDAsICd5ZXMnLCBmYWxzZV0sIEJvb2xlYW4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnNvbWUoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnNvbWUoY2hhcmFjdGVycywgeyAnYWdlJzogMSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvbWUoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgIGlmIChpc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAoKHJlc3VsdCA9IGNhbGxiYWNrKGNvbGxlY3Rpb25baW5kZXhdLCBpbmRleCwgY29sbGVjdGlvbikpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHJldHVybiAhKHJlc3VsdCA9IGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhIXJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzLCBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyIGJ5IHRoZSByZXN1bHRzIG9mXG4gICAgICogcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uIHRocm91Z2ggdGhlIGNhbGxiYWNrLiBUaGlzIG1ldGhvZFxuICAgICAqIHBlcmZvcm1zIGEgc3RhYmxlIHNvcnQsIHRoYXQgaXMsIGl0IHdpbGwgcHJlc2VydmUgdGhlIG9yaWdpbmFsIHNvcnQgb3JkZXJcbiAgICAgKiBvZiBlcXVhbCBlbGVtZW50cy4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoXG4gICAgICogdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY29sbGVjdGlvblxuICAgICAqIHdpbGwgYmUgc29ydGVkIGJ5IGVhY2ggcHJvcGVydHkgdmFsdWUuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2Ygc29ydGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRCeShbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gTWF0aC5zaW4obnVtKTsgfSk7XG4gICAgICogLy8gPT4gWzMsIDEsIDJdXG4gICAgICpcbiAgICAgKiBfLnNvcnRCeShbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gdGhpcy5zaW4obnVtKTsgfSwgTWF0aCk7XG4gICAgICogLy8gPT4gWzMsIDEsIDJdXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYWdlJzogMjYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdhZ2UnOiAzMCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWFwKF8uc29ydEJ5KGNoYXJhY3RlcnMsICdhZ2UnKSwgXy52YWx1ZXMpO1xuICAgICAqIC8vID0+IFtbJ2Jhcm5leScsIDI2XSwgWydmcmVkJywgMzBdLCBbJ2Jhcm5leScsIDM2XSwgWydmcmVkJywgNDBdXVxuICAgICAqXG4gICAgICogLy8gc29ydGluZyBieSBtdWx0aXBsZSBwcm9wZXJ0aWVzXG4gICAgICogXy5tYXAoXy5zb3J0QnkoY2hhcmFjdGVycywgWyduYW1lJywgJ2FnZSddKSwgXy52YWx1ZXMpO1xuICAgICAqIC8vID0gPiBbWydiYXJuZXknLCAyNl0sIFsnYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCAzMF0sIFsnZnJlZCcsIDQwXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0QnkoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGlzQXJyID0gaXNBcnJheShjYWxsYmFjayksXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheSh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInID8gbGVuZ3RoIDogMCk7XG5cbiAgICAgIGlmICghaXNBcnIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgfVxuICAgICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSByZXN1bHRbKytpbmRleF0gPSBnZXRPYmplY3QoKTtcbiAgICAgICAgaWYgKGlzQXJyKSB7XG4gICAgICAgICAgb2JqZWN0LmNyaXRlcmlhID0gbWFwKGNhbGxiYWNrLCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIChvYmplY3QuY3JpdGVyaWEgPSBnZXRBcnJheSgpKVswXSA9IGNhbGxiYWNrKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdC5pbmRleCA9IGluZGV4O1xuICAgICAgICBvYmplY3QudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH0pO1xuXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuICAgICAgcmVzdWx0LnNvcnQoY29tcGFyZUFzY2VuZGluZyk7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IHJlc3VsdFtsZW5ndGhdO1xuICAgICAgICByZXN1bHRbbGVuZ3RoXSA9IG9iamVjdC52YWx1ZTtcbiAgICAgICAgaWYgKCFpc0Fycikge1xuICAgICAgICAgIHJlbGVhc2VBcnJheShvYmplY3QuY3JpdGVyaWEpO1xuICAgICAgICB9XG4gICAgICAgIHJlbGVhc2VPYmplY3Qob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGBjb2xsZWN0aW9uYCB0byBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGNvbnZlcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogKGZ1bmN0aW9uKCkgeyByZXR1cm4gXy50b0FycmF5KGFyZ3VtZW50cykuc2xpY2UoMSk7IH0pKDEsIDIsIDMsIDQpO1xuICAgICAqIC8vID0+IFsyLCAzLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvQXJyYXkoY29sbGVjdGlvbikge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gJiYgdHlwZW9mIGNvbGxlY3Rpb24ubGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiAoc3VwcG9ydC51bmluZGV4ZWRDaGFycyAmJiBpc1N0cmluZyhjb2xsZWN0aW9uKSlcbiAgICAgICAgICA/IGNvbGxlY3Rpb24uc3BsaXQoJycpXG4gICAgICAgICAgOiBzbGljZShjb2xsZWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZXMoY29sbGVjdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gb2YgZWFjaCBlbGVtZW50IGluIGEgYGNvbGxlY3Rpb25gIHRvIHRoZSBnaXZlblxuICAgICAqIGBwcm9wZXJ0aWVzYCBvYmplY3QsIHJldHVybmluZyBhbiBhcnJheSBvZiBhbGwgZWxlbWVudHMgdGhhdCBoYXZlIGVxdWl2YWxlbnRcbiAgICAgKiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIGZpbHRlciBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBnaXZlbiBwcm9wZXJ0aWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAncGV0cyc6IFsnaG9wcHknXSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAsICdwZXRzJzogWydiYWJ5IHB1c3MnLCAnZGlubyddIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy53aGVyZShjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAzNiB9KTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdwZXRzJzogWydob3BweSddIH1dXG4gICAgICpcbiAgICAgKiBfLndoZXJlKGNoYXJhY3RlcnMsIHsgJ3BldHMnOiBbJ2Rpbm8nXSB9KTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwLCAncGV0cyc6IFsnYmFieSBwdXNzJywgJ2Rpbm8nXSB9XVxuICAgICAqL1xuICAgIHZhciB3aGVyZSA9IGZpbHRlcjtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB3aXRoIGFsbCBmYWxzZXkgdmFsdWVzIHJlbW92ZWQuIFRoZSB2YWx1ZXMgYGZhbHNlYCwgYG51bGxgLFxuICAgICAqIGAwYCwgYFwiXCJgLCBgdW5kZWZpbmVkYCwgYW5kIGBOYU5gIGFyZSBhbGwgZmFsc2V5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY29tcGFjdChbMCwgMSwgZmFsc2UsIDIsICcnLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcGFjdChhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGV4Y2x1ZGluZyBhbGwgdmFsdWVzIG9mIHRoZSBwcm92aWRlZCBhcnJheXMgdXNpbmcgc3RyaWN0XG4gICAgICogZXF1YWxpdHkgZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSBhcnJheXMgb2YgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kaWZmZXJlbmNlKFsxLCAyLCAzLCA0LCA1XSwgWzUsIDIsIDEwXSk7XG4gICAgICogLy8gPT4gWzEsIDMsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGlmZmVyZW5jZShhcnJheSkge1xuICAgICAgcmV0dXJuIGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUsIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnQgdGhhdCBwYXNzZXMgdGhlIGNhbGxiYWNrIGNoZWNrLCBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2Jsb2NrZWQnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZEluZGV4KGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci5hZ2UgPCAyMDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRJbmRleChjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAzNiB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRJbmRleChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayhhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRJbmRleGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGEgYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiB0cnVlIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2Jsb2NrZWQnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kTGFzdEluZGV4KGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci5hZ2UgPiAzMDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgoY2hhcmFjdGVycywgeyAnYWdlJzogMzYgfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kTGFzdEluZGV4KGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRMYXN0SW5kZXgoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayhhcnJheVtsZW5ndGhdLCBsZW5ndGgsIGFycmF5KSkge1xuICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBmaXJzdCBlbGVtZW50IG9yIGZpcnN0IGBuYCBlbGVtZW50cyBvZiBhbiBhcnJheS4gSWYgYSBjYWxsYmFja1xuICAgICAqIGlzIHByb3ZpZGVkIGVsZW1lbnRzIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5IGFyZSByZXR1cm5lZCBhcyBsb25nXG4gICAgICogYXMgdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgaGVhZCwgdGFrZVxuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8bnVtYmVyfHN0cmluZ30gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBlbGVtZW50IG9yIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gcmV0dXJuLiBJZiBhIHByb3BlcnR5IG5hbWUgb3JcbiAgICAgKiAgb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZCB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIlxuICAgICAqICBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50KHMpIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmlyc3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiBfLmZpcnN0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLmZpcnN0KFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7XG4gICAgICogICByZXR1cm4gbnVtIDwgMztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2Jsb2NrZWQnOiBmYWxzZSwgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ25hJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmlyc3QoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdiYXJuZXknLCAnYmxvY2tlZCc6IHRydWUsICdlbXBsb3llcic6ICdzbGF0ZScgfV1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5maXJzdChjaGFyYWN0ZXJzLCB7ICdlbXBsb3llcic6ICdzbGF0ZScgfSksICduYW1lJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlyc3QoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbiA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdudW1iZXInICYmIGNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgY2FsbGJhY2soYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgbisrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gY2FsbGJhY2s7XG4gICAgICAgIGlmIChuID09IG51bGwgfHwgdGhpc0FyZykge1xuICAgICAgICAgIHJldHVybiBhcnJheSA/IGFycmF5WzBdIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2xpY2UoYXJyYXksIDAsIG5hdGl2ZU1pbihuYXRpdmVNYXgoMCwgbiksIGxlbmd0aCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZsYXR0ZW5zIGEgbmVzdGVkIGFycmF5ICh0aGUgbmVzdGluZyBjYW4gYmUgdG8gYW55IGRlcHRoKS4gSWYgYGlzU2hhbGxvd2BcbiAgICAgKiBpcyB0cnVleSwgdGhlIGFycmF5IHdpbGwgb25seSBiZSBmbGF0dGVuZWQgYSBzaW5nbGUgbGV2ZWwuIElmIGEgY2FsbGJhY2tcbiAgICAgKiBpcyBwcm92aWRlZCBlYWNoIGVsZW1lbnQgb2YgdGhlIGFycmF5IGlzIHBhc3NlZCB0aHJvdWdoIHRoZSBjYWxsYmFjayBiZWZvcmVcbiAgICAgKiBmbGF0dGVuaW5nLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU2hhbGxvdz1mYWxzZV0gQSBmbGFnIHRvIHJlc3RyaWN0IGZsYXR0ZW5pbmcgdG8gYSBzaW5nbGUgbGV2ZWwuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW4oWzEsIFsyXSwgWzMsIFtbNF1dXV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0XTtcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbihbMSwgWzJdLCBbMywgW1s0XV1dXSwgdHJ1ZSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIFtbNF1dXTtcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzAsICdwZXRzJzogWydob3BweSddIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ3BldHMnOiBbJ2JhYnkgcHVzcycsICdkaW5vJ10gfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZsYXR0ZW4oY2hhcmFjdGVycywgJ3BldHMnKTtcbiAgICAgKiAvLyA9PiBbJ2hvcHB5JywgJ2JhYnkgcHVzcycsICdkaW5vJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuKGFycmF5LCBpc1NoYWxsb3csIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAvLyBqdWdnbGUgYXJndW1lbnRzXG4gICAgICBpZiAodHlwZW9mIGlzU2hhbGxvdyAhPSAnYm9vbGVhbicgJiYgaXNTaGFsbG93ICE9IG51bGwpIHtcbiAgICAgICAgdGhpc0FyZyA9IGNhbGxiYWNrO1xuICAgICAgICBjYWxsYmFjayA9ICh0eXBlb2YgaXNTaGFsbG93ICE9ICdmdW5jdGlvbicgJiYgdGhpc0FyZyAmJiB0aGlzQXJnW2lzU2hhbGxvd10gPT09IGFycmF5KSA/IG51bGwgOiBpc1NoYWxsb3c7XG4gICAgICAgIGlzU2hhbGxvdyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgYXJyYXkgPSBtYXAoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihhcnJheSwgaXNTaGFsbG93KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgdmFsdWVgIGlzIGZvdW5kIHVzaW5nXG4gICAgICogc3RyaWN0IGVxdWFsaXR5IGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC4gSWYgdGhlIGFycmF5IGlzIGFscmVhZHkgc29ydGVkXG4gICAgICogcHJvdmlkaW5nIGB0cnVlYCBmb3IgYGZyb21JbmRleGAgd2lsbCBydW4gYSBmYXN0ZXIgYmluYXJ5IHNlYXJjaC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtib29sZWFufG51bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20gb3IgYHRydWVgXG4gICAgICogIHRvIHBlcmZvcm0gYSBiaW5hcnkgc2VhcmNoIG9uIGEgc29ydGVkIGFycmF5LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlIG9yIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5kZXhPZihbMSwgMiwgMywgMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIF8uaW5kZXhPZihbMSwgMiwgMywgMSwgMiwgM10sIDIsIDMpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8uaW5kZXhPZihbMSwgMSwgMiwgMiwgMywgM10sIDIsIHRydWUpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgICBpZiAodHlwZW9mIGZyb21JbmRleCA9PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgICBmcm9tSW5kZXggPSAoZnJvbUluZGV4IDwgMCA/IG5hdGl2ZU1heCgwLCBsZW5ndGggKyBmcm9tSW5kZXgpIDogZnJvbUluZGV4IHx8IDApO1xuICAgICAgfSBlbHNlIGlmIChmcm9tSW5kZXgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gc29ydGVkSW5kZXgoYXJyYXksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGFycmF5W2luZGV4XSA9PT0gdmFsdWUgPyBpbmRleCA6IC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBidXQgdGhlIGxhc3QgZWxlbWVudCBvciBsYXN0IGBuYCBlbGVtZW50cyBvZiBhbiBhcnJheS4gSWYgYVxuICAgICAqIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGVsZW1lbnRzIGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5IGFyZSBleGNsdWRlZCBmcm9tXG4gICAgICogdGhlIHJlc3VsdCBhcyBsb25nIGFzIHRoZSBjYWxsYmFjayByZXR1cm5zIHRydWV5LiBUaGUgY2FsbGJhY2sgaXMgYm91bmRcbiAgICAgKiB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxudW1iZXJ8c3RyaW5nfSBbY2FsbGJhY2s9MV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgZWxlbWVudCBvciB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGV4Y2x1ZGUuIElmIGEgcHJvcGVydHkgbmFtZSBvclxuICAgICAqICBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiXG4gICAgICogIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbml0aWFsKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLmluaXRpYWwoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8uaW5pdGlhbChbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkge1xuICAgICAqICAgcmV0dXJuIG51bSA+IDE7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdibG9ja2VkJzogZmFsc2UsICdlbXBsb3llcic6ICdzbGF0ZScgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdibG9ja2VkJzogdHJ1ZSwgICdlbXBsb3llcic6ICdzbGF0ZScgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdibG9ja2VkJzogdHJ1ZSwgICdlbXBsb3llcic6ICduYScgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmluaXRpYWwoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2Jsb2NrZWQnOiBmYWxzZSwgJ2VtcGxveWVyJzogJ3NsYXRlJyB9XVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmluaXRpYWwoY2hhcmFjdGVycywgeyAnZW1wbG95ZXInOiAnbmEnIH0pLCAnbmFtZScpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRpYWwoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbiA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdudW1iZXInICYmIGNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gbGVuZ3RoO1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICAgIHdoaWxlIChpbmRleC0tICYmIGNhbGxiYWNrKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIG4rKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IChjYWxsYmFjayA9PSBudWxsIHx8IHRoaXNBcmcpID8gMSA6IGNhbGxiYWNrIHx8IG47XG4gICAgICB9XG4gICAgICByZXR1cm4gc2xpY2UoYXJyYXksIDAsIG5hdGl2ZU1pbihuYXRpdmVNYXgoMCwgbGVuZ3RoIC0gbiksIGxlbmd0aCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcyBwcmVzZW50IGluIGFsbCBwcm92aWRlZCBhcnJheXMgdXNpbmdcbiAgICAgKiBzdHJpY3QgZXF1YWxpdHkgZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheV0gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBzaGFyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludGVyc2VjdGlvbihbMSwgMiwgM10sIFs1LCAyLCAxLCA0XSwgWzIsIDFdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnRlcnNlY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICAgIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgIGNhY2hlcyA9IGdldEFycmF5KCksXG4gICAgICAgICAgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcbiAgICAgICAgICB0cnVzdEluZGV4T2YgPSBpbmRleE9mID09PSBiYXNlSW5kZXhPZixcbiAgICAgICAgICBzZWVuID0gZ2V0QXJyYXkoKTtcblxuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHNbYXJnc0luZGV4XTtcbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkge1xuICAgICAgICAgIGFyZ3MucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgY2FjaGVzLnB1c2godHJ1c3RJbmRleE9mICYmIHZhbHVlLmxlbmd0aCA+PSBsYXJnZUFycmF5U2l6ZSAmJlxuICAgICAgICAgICAgY3JlYXRlQ2FjaGUoYXJnc0luZGV4ID8gYXJnc1thcmdzSW5kZXhdIDogc2VlbikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgYXJyYXkgPSBhcmdzWzBdLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBjYWNoZSA9IGNhY2hlc1swXTtcbiAgICAgICAgdmFsdWUgPSBhcnJheVtpbmRleF07XG5cbiAgICAgICAgaWYgKChjYWNoZSA/IGNhY2hlSW5kZXhPZihjYWNoZSwgdmFsdWUpIDogaW5kZXhPZihzZWVuLCB2YWx1ZSkpIDwgMCkge1xuICAgICAgICAgIGFyZ3NJbmRleCA9IGFyZ3NMZW5ndGg7XG4gICAgICAgICAgKGNhY2hlIHx8IHNlZW4pLnB1c2godmFsdWUpO1xuICAgICAgICAgIHdoaWxlICgtLWFyZ3NJbmRleCkge1xuICAgICAgICAgICAgY2FjaGUgPSBjYWNoZXNbYXJnc0luZGV4XTtcbiAgICAgICAgICAgIGlmICgoY2FjaGUgPyBjYWNoZUluZGV4T2YoY2FjaGUsIHZhbHVlKSA6IGluZGV4T2YoYXJnc1thcmdzSW5kZXhdLCB2YWx1ZSkpIDwgMCkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAoYXJnc0xlbmd0aC0tKSB7XG4gICAgICAgIGNhY2hlID0gY2FjaGVzW2FyZ3NMZW5ndGhdO1xuICAgICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgICByZWxlYXNlT2JqZWN0KGNhY2hlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVsZWFzZUFycmF5KGNhY2hlcyk7XG4gICAgICByZWxlYXNlQXJyYXkoc2Vlbik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxhc3QgZWxlbWVudCBvciBsYXN0IGBuYCBlbGVtZW50cyBvZiBhbiBhcnJheS4gSWYgYSBjYWxsYmFjayBpc1xuICAgICAqIHByb3ZpZGVkIGVsZW1lbnRzIGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5IGFyZSByZXR1cm5lZCBhcyBsb25nIGFzIHRoZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fG51bWJlcnxzdHJpbmd9IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgZWxlbWVudCBvciB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHJldHVybi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yXG4gICAgICogIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWQgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCJcbiAgICAgKiAgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50KHMpIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubGFzdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8ubGFzdChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogXy5sYXN0KFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7XG4gICAgICogICByZXR1cm4gbnVtID4gMTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2Jsb2NrZWQnOiBmYWxzZSwgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ25hJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5sYXN0KGNoYXJhY3RlcnMsICdibG9ja2VkJyksICduYW1lJyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5sYXN0KGNoYXJhY3RlcnMsIHsgJ2VtcGxveWVyJzogJ25hJyB9KTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdwZWJibGVzJywgJ2Jsb2NrZWQnOiB0cnVlLCAnZW1wbG95ZXInOiAnbmEnIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGFzdChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBuID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ251bWJlcicgJiYgY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICB2YXIgaW5kZXggPSBsZW5ndGg7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgd2hpbGUgKGluZGV4LS0gJiYgY2FsbGJhY2soYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgbisrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gY2FsbGJhY2s7XG4gICAgICAgIGlmIChuID09IG51bGwgfHwgdGhpc0FyZykge1xuICAgICAgICAgIHJldHVybiBhcnJheSA/IGFycmF5W2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2xpY2UoYXJyYXksIG5hdGl2ZU1heCgwLCBsZW5ndGggLSBuKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGxhc3Qgb2NjdXJyZW5jZSBvZiBgdmFsdWVgIGlzIGZvdW5kIHVzaW5nIHN0cmljdFxuICAgICAqIGVxdWFsaXR5IGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0IGlzIHVzZWRcbiAgICAgKiBhcyB0aGUgb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD1hcnJheS5sZW5ndGgtMV0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlIG9yIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDMsIDEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLmxhc3RJbmRleE9mKFsxLCAyLCAzLCAxLCAyLCAzXSwgMiwgMyk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgaW5kZXggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBpZiAodHlwZW9mIGZyb21JbmRleCA9PSAnbnVtYmVyJykge1xuICAgICAgICBpbmRleCA9IChmcm9tSW5kZXggPCAwID8gbmF0aXZlTWF4KDAsIGluZGV4ICsgZnJvbUluZGV4KSA6IG5hdGl2ZU1pbihmcm9tSW5kZXgsIGluZGV4IC0gMSkpICsgMTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgcHJvdmlkZWQgdmFsdWVzIGZyb20gdGhlIGdpdmVuIGFycmF5IHVzaW5nIHN0cmljdCBlcXVhbGl0eSBmb3JcbiAgICAgKiBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlXSBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDMsIDEsIDIsIDNdO1xuICAgICAqIF8ucHVsbChhcnJheSwgMiwgMyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1bGwoYXJyYXkpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGFyZ3NJbmRleCA9IDAsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIHZhbHVlID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgaW5kZXgtLSwgMSk7XG4gICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG51bWJlcnMgKHBvc2l0aXZlIGFuZC9vciBuZWdhdGl2ZSkgcHJvZ3Jlc3NpbmcgZnJvbVxuICAgICAqIGBzdGFydGAgdXAgdG8gYnV0IG5vdCBpbmNsdWRpbmcgYGVuZGAuIElmIGBzdGFydGAgaXMgbGVzcyB0aGFuIGBzdG9wYCBhXG4gICAgICogemVyby1sZW5ndGggcmFuZ2UgaXMgY3JlYXRlZCB1bmxlc3MgYSBuZWdhdGl2ZSBgc3RlcGAgaXMgc3BlY2lmaWVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RlcD0xXSBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgcmFuZ2UgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoNCk7XG4gICAgICogLy8gPT4gWzAsIDEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDEsIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0XVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwLCAyMCwgNSk7XG4gICAgICogLy8gPT4gWzAsIDUsIDEwLCAxNV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCwgLTQsIC0xKTtcbiAgICAgKiAvLyA9PiBbMCwgLTEsIC0yLCAtM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMSwgNCwgMCk7XG4gICAgICogLy8gPT4gWzEsIDEsIDFdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCkge1xuICAgICAgc3RhcnQgPSArc3RhcnQgfHwgMDtcbiAgICAgIHN0ZXAgPSB0eXBlb2Ygc3RlcCA9PSAnbnVtYmVyJyA/IHN0ZXAgOiAoK3N0ZXAgfHwgMSk7XG5cbiAgICAgIGlmIChlbmQgPT0gbnVsbCkge1xuICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfVxuICAgICAgLy8gdXNlIGBBcnJheShsZW5ndGgpYCBzbyBlbmdpbmVzIGxpa2UgQ2hha3JhIGFuZCBWOCBhdm9pZCBzbG93ZXIgbW9kZXNcbiAgICAgIC8vIGh0dHA6Ly95b3V0dS5iZS9YQXFJcEdVOFpaayN0PTE3bTI1c1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KDAsIGNlaWwoKGVuZCAtIHN0YXJ0KSAvIChzdGVwIHx8IDEpKSksXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IHN0YXJ0O1xuICAgICAgICBzdGFydCArPSBzdGVwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBlbGVtZW50cyBmcm9tIGFuIGFycmF5IHRoYXQgdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkgZm9yXG4gICAgICogYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYFxuICAgICAqIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzLCA0LCA1LCA2XTtcbiAgICAgKiB2YXIgZXZlbnMgPSBfLnJlbW92ZShhcnJheSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gJSAyID09IDA7IH0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAzLCA1XVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZXZlbnMpO1xuICAgICAqIC8vID0+IFsyLCA0LCA2XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZShhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgc3BsaWNlLmNhbGwoYXJyYXksIGluZGV4LS0sIDEpO1xuICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5pbml0aWFsYCB0aGlzIG1ldGhvZCBnZXRzIGFsbCBidXQgdGhlIGZpcnN0IGVsZW1lbnQgb3JcbiAgICAgKiBmaXJzdCBgbmAgZWxlbWVudHMgb2YgYW4gYXJyYXkuIElmIGEgY2FsbGJhY2sgZnVuY3Rpb24gaXMgcHJvdmlkZWQgZWxlbWVudHNcbiAgICAgKiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheSBhcmUgZXhjbHVkZWQgZnJvbSB0aGUgcmVzdWx0IGFzIGxvbmcgYXMgdGhlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyB0cnVleS4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBkcm9wLCB0YWlsXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxudW1iZXJ8c3RyaW5nfSBbY2FsbGJhY2s9MV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgZWxlbWVudCBvciB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGV4Y2x1ZGUuIElmIGEgcHJvcGVydHkgbmFtZSBvclxuICAgICAqICBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiXG4gICAgICogIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZXN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiBfLnJlc3QoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKlxuICAgICAqIF8ucmVzdChbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkge1xuICAgICAqICAgcmV0dXJuIG51bSA8IDM7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdibG9ja2VkJzogdHJ1ZSwgICdlbXBsb3llcic6ICdzbGF0ZScgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdibG9ja2VkJzogZmFsc2UsICAnZW1wbG95ZXInOiAnc2xhdGUnIH0sXG4gICAgICogICB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYmxvY2tlZCc6IHRydWUsICdlbXBsb3llcic6ICduYScgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8ucmVzdChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpLCAnbmFtZScpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucmVzdChjaGFyYWN0ZXJzLCB7ICdlbXBsb3llcic6ICdzbGF0ZScgfSk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAncGViYmxlcycsICdibG9ja2VkJzogdHJ1ZSwgJ2VtcGxveWVyJzogJ25hJyB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc3QoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdudW1iZXInICYmIGNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG4gPSAwLFxuICAgICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoICYmIGNhbGxiYWNrKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIG4rKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IChjYWxsYmFjayA9PSBudWxsIHx8IHRoaXNBcmcpID8gMSA6IG5hdGl2ZU1heCgwLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2xpY2UoYXJyYXksIG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZXMgYSBiaW5hcnkgc2VhcmNoIHRvIGRldGVybWluZSB0aGUgc21hbGxlc3QgaW5kZXggYXQgd2hpY2ggYSB2YWx1ZVxuICAgICAqIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGEgZ2l2ZW4gc29ydGVkIGFycmF5IGluIG9yZGVyIHRvIG1haW50YWluIHRoZSBzb3J0XG4gICAgICogb3JkZXIgb2YgdGhlIGFycmF5LiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWQgZm9yXG4gICAgICogYHZhbHVlYCBhbmQgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgdG8gY29tcHV0ZSB0aGVpciBzb3J0IHJhbmtpbmcuIFRoZVxuICAgICAqIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4KFsyMCwgMzAsIDUwXSwgNDApO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uc29ydGVkSW5kZXgoW3sgJ3gnOiAyMCB9LCB7ICd4JzogMzAgfSwgeyAneCc6IDUwIH1dLCB7ICd4JzogNDAgfSwgJ3gnKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiB2YXIgZGljdCA9IHtcbiAgICAgKiAgICd3b3JkVG9OdW1iZXInOiB7ICd0d2VudHknOiAyMCwgJ3RoaXJ0eSc6IDMwLCAnZm91cnR5JzogNDAsICdmaWZ0eSc6IDUwIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleChbJ3R3ZW50eScsICd0aGlydHknLCAnZmlmdHknXSwgJ2ZvdXJ0eScsIGZ1bmN0aW9uKHdvcmQpIHtcbiAgICAgKiAgIHJldHVybiBkaWN0LndvcmRUb051bWJlclt3b3JkXTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4KFsndHdlbnR5JywgJ3RoaXJ0eScsICdmaWZ0eSddLCAnZm91cnR5JywgZnVuY3Rpb24od29yZCkge1xuICAgICAqICAgcmV0dXJuIHRoaXMud29yZFRvTnVtYmVyW3dvcmRdO1xuICAgICAqIH0sIGRpY3QpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRJbmRleChhcnJheSwgdmFsdWUsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbG93ID0gMCxcbiAgICAgICAgICBoaWdoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiBsb3c7XG5cbiAgICAgIC8vIGV4cGxpY2l0bHkgcmVmZXJlbmNlIGBpZGVudGl0eWAgZm9yIGJldHRlciBpbmxpbmluZyBpbiBGaXJlZm94XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAxKSA6IGlkZW50aXR5O1xuICAgICAgdmFsdWUgPSBjYWxsYmFjayh2YWx1ZSk7XG5cbiAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgIHZhciBtaWQgPSAobG93ICsgaGlnaCkgPj4+IDE7XG4gICAgICAgIChjYWxsYmFjayhhcnJheVttaWRdKSA8IHZhbHVlKVxuICAgICAgICAgID8gbG93ID0gbWlkICsgMVxuICAgICAgICAgIDogaGlnaCA9IG1pZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsb3c7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzLCBpbiBvcmRlciwgb2YgdGhlIHByb3ZpZGVkIGFycmF5cyB1c2luZ1xuICAgICAqIHN0cmljdCBlcXVhbGl0eSBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5XSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlvbihbMSwgMiwgM10sIFs1LCAyLCAxLCA0XSwgWzIsIDFdKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNSwgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlvbigpIHtcbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZHVwbGljYXRlLXZhbHVlLWZyZWUgdmVyc2lvbiBvZiBhbiBhcnJheSB1c2luZyBzdHJpY3QgZXF1YWxpdHlcbiAgICAgKiBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuIElmIHRoZSBhcnJheSBpcyBzb3J0ZWQsIHByb3ZpZGluZ1xuICAgICAqIGB0cnVlYCBmb3IgYGlzU29ydGVkYCB3aWxsIHVzZSBhIGZhc3RlciBhbGdvcml0aG0uIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWRcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCBpcyBwYXNzZWQgdGhyb3VnaCB0aGUgY2FsbGJhY2sgYmVmb3JlIHVuaXF1ZW5lc3NcbiAgICAgKiBpcyBjb21wdXRlZC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyB1bmlxdWVcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTb3J0ZWQ9ZmFsc2VdIEEgZmxhZyB0byBpbmRpY2F0ZSB0aGF0IGBhcnJheWAgaXMgc29ydGVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgZHVwbGljYXRlLXZhbHVlLWZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcShbMSwgMiwgMSwgMywgMV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy51bmlxKFsxLCAxLCAyLCAyLCAzXSwgdHJ1ZSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnVuaXEoWydBJywgJ2InLCAnQycsICdhJywgJ0InLCAnYyddLCBmdW5jdGlvbihsZXR0ZXIpIHsgcmV0dXJuIGxldHRlci50b0xvd2VyQ2FzZSgpOyB9KTtcbiAgICAgKiAvLyA9PiBbJ0EnLCAnYicsICdDJ11cbiAgICAgKlxuICAgICAqIF8udW5pcShbMSwgMi41LCAzLCAxLjUsIDIsIDMuNV0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gdGhpcy5mbG9vcihudW0pOyB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiBbMSwgMi41LCAzXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy51bmlxKFt7ICd4JzogMSB9LCB7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEgfSwgeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxKGFycmF5LCBpc1NvcnRlZCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIC8vIGp1Z2dsZSBhcmd1bWVudHNcbiAgICAgIGlmICh0eXBlb2YgaXNTb3J0ZWQgIT0gJ2Jvb2xlYW4nICYmIGlzU29ydGVkICE9IG51bGwpIHtcbiAgICAgICAgdGhpc0FyZyA9IGNhbGxiYWNrO1xuICAgICAgICBjYWxsYmFjayA9ICh0eXBlb2YgaXNTb3J0ZWQgIT0gJ2Z1bmN0aW9uJyAmJiB0aGlzQXJnICYmIHRoaXNBcmdbaXNTb3J0ZWRdID09PSBhcnJheSkgPyBudWxsIDogaXNTb3J0ZWQ7XG4gICAgICAgIGlzU29ydGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYXJyYXksIGlzU29ydGVkLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBleGNsdWRpbmcgYWxsIHByb3ZpZGVkIHZhbHVlcyB1c2luZyBzdHJpY3QgZXF1YWxpdHkgZm9yXG4gICAgICogY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbHRlci5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZV0gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ud2l0aG91dChbMSwgMiwgMSwgMCwgMywgMSwgNF0sIDAsIDEpO1xuICAgICAqIC8vID0+IFsyLCAzLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdpdGhvdXQoYXJyYXkpIHtcbiAgICAgIHJldHVybiBiYXNlRGlmZmVyZW5jZShhcnJheSwgc2xpY2UoYXJndW1lbnRzLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB0aGF0IGlzIHRoZSBzeW1tZXRyaWMgZGlmZmVyZW5jZSBvZiB0aGUgcHJvdmlkZWQgYXJyYXlzLlxuICAgICAqIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N5bW1ldHJpY19kaWZmZXJlbmNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheV0gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ueG9yKFsxLCAyLCAzXSwgWzUsIDIsIDEsIDRdKTtcbiAgICAgKiAvLyA9PiBbMywgNSwgNF1cbiAgICAgKlxuICAgICAqIF8ueG9yKFsxLCAyLCA1XSwgWzIsIDMsIDVdLCBbMywgNCwgNV0pO1xuICAgICAqIC8vID0+IFsxLCA0LCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHhvcigpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgIGlmIChpc0FycmF5KGFycmF5KSB8fCBpc0FyZ3VtZW50cyhhcnJheSkpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVzdWx0XG4gICAgICAgICAgICA/IGJhc2VVbmlxKGJhc2VEaWZmZXJlbmNlKHJlc3VsdCwgYXJyYXkpLmNvbmNhdChiYXNlRGlmZmVyZW5jZShhcnJheSwgcmVzdWx0KSkpXG4gICAgICAgICAgICA6IGFycmF5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0IHx8IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cywgdGhlIGZpcnN0IG9mIHdoaWNoIGNvbnRhaW5zIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBhcnJheXMsIHRoZSBzZWNvbmQgb2Ygd2hpY2ggY29udGFpbnMgdGhlIHNlY29uZFxuICAgICAqIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBhcnJheXMsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyB1bnppcFxuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXldIEFycmF5cyB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcChbJ2ZyZWQnLCAnYmFybmV5J10sIFszMCwgNDBdLCBbdHJ1ZSwgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBbWydmcmVkJywgMzAsIHRydWVdLCBbJ2Jhcm5leScsIDQwLCBmYWxzZV1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gemlwKCkge1xuICAgICAgdmFyIGFycmF5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHMgOiBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IG1heChwbHVjayhhcnJheSwgJ2xlbmd0aCcpKSA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoIDwgMCA/IDAgOiBsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gcGx1Y2soYXJyYXksIGluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgZnJvbSBhcnJheXMgb2YgYGtleXNgIGFuZCBgdmFsdWVzYC4gUHJvdmlkZVxuICAgICAqIGVpdGhlciBhIHNpbmdsZSB0d28gZGltZW5zaW9uYWwgYXJyYXksIGkuZS4gYFtba2V5MSwgdmFsdWUxXSwgW2tleTIsIHZhbHVlMl1dYFxuICAgICAqIG9yIHR3byBhcnJheXMsIG9uZSBvZiBga2V5c2AgYW5kIG9uZSBvZiBjb3JyZXNwb25kaW5nIGB2YWx1ZXNgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIG9iamVjdFxuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBrZXlzIFRoZSBhcnJheSBvZiBrZXlzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXM9W11dIFRoZSBhcnJheSBvZiB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIGdpdmVuIGtleXMgYW5kXG4gICAgICogIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcE9iamVjdChbJ2ZyZWQnLCAnYmFybmV5J10sIFszMCwgNDBdKTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogMzAsICdiYXJuZXknOiA0MCB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gemlwT2JqZWN0KGtleXMsIHZhbHVlcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0ga2V5cyA/IGtleXMubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgaWYgKCF2YWx1ZXMgJiYgbGVuZ3RoICYmICFpc0FycmF5KGtleXNbMF0pKSB7XG4gICAgICAgIHZhbHVlcyA9IFtdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSkge1xuICAgICAgICAgIHJlc3VsdFtrZXlbMF1dID0ga2V5WzFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgYGZ1bmNgLCB3aXRoICB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kXG4gICAgICogYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLCBvbmx5IGFmdGVyIGJlaW5nIGNhbGxlZCBgbmAgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0aGUgZnVuY3Rpb24gbXVzdCBiZSBjYWxsZWQgYmVmb3JlXG4gICAgICogIGBmdW5jYCBpcyBleGVjdXRlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc2F2ZXMgPSBbJ3Byb2ZpbGUnLCAnc2V0dGluZ3MnXTtcbiAgICAgKlxuICAgICAqIHZhciBkb25lID0gXy5hZnRlcihzYXZlcy5sZW5ndGgsIGZ1bmN0aW9uKCkge1xuICAgICAqICAgY29uc29sZS5sb2coJ0RvbmUgc2F2aW5nIScpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5mb3JFYWNoKHNhdmVzLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICogICBhc3luY1NhdmUoeyAndHlwZSc6IHR5cGUsICdjb21wbGV0ZSc6IGRvbmUgfSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyAnRG9uZSBzYXZpbmchJywgYWZ0ZXIgYWxsIHNhdmVzIGhhdmUgY29tcGxldGVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWZ0ZXIobiwgZnVuYykge1xuICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgtLW4gPCAxKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCBwcmVwZW5kcyBhbnkgYWRkaXRpb25hbCBgYmluZGAgYXJndW1lbnRzIHRvIHRob3NlXG4gICAgICogcHJvdmlkZWQgdG8gdGhlIGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmddIEFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBmdW5jdGlvbihncmVldGluZykge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgdGhpcy5uYW1lO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBmdW5jID0gXy5iaW5kKGZ1bmMsIHsgJ25hbWUnOiAnZnJlZCcgfSwgJ2hpJyk7XG4gICAgICogZnVuYygpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbmQoZnVuYywgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAyXG4gICAgICAgID8gY3JlYXRlV3JhcHBlcihmdW5jLCAxNywgc2xpY2UoYXJndW1lbnRzLCAyKSwgbnVsbCwgdGhpc0FyZylcbiAgICAgICAgOiBjcmVhdGVXcmFwcGVyKGZ1bmMsIDEsIG51bGwsIG51bGwsIHRoaXNBcmcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJpbmRzIG1ldGhvZHMgb2YgYW4gb2JqZWN0IHRvIHRoZSBvYmplY3QgaXRzZWxmLCBvdmVyd3JpdGluZyB0aGUgZXhpc3RpbmdcbiAgICAgKiBtZXRob2QuIE1ldGhvZCBuYW1lcyBtYXkgYmUgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzIG9yIGFzIGFycmF5c1xuICAgICAqIG9mIG1ldGhvZCBuYW1lcy4gSWYgbm8gbWV0aG9kIG5hbWVzIGFyZSBwcm92aWRlZCBhbGwgdGhlIGZ1bmN0aW9uIHByb3BlcnRpZXNcbiAgICAgKiBvZiBgb2JqZWN0YCB3aWxsIGJlIGJvdW5kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiaW5kIGFuZCBhc3NpZ24gdGhlIGJvdW5kIG1ldGhvZHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi5zdHJpbmd9IFttZXRob2ROYW1lXSBUaGUgb2JqZWN0IG1ldGhvZCBuYW1lcyB0b1xuICAgICAqICBiaW5kLCBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBtZXRob2QgbmFtZXMgb3IgYXJyYXlzIG9mIG1ldGhvZCBuYW1lcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdmlldyA9IHtcbiAgICAgKiAgICdsYWJlbCc6ICdkb2NzJyxcbiAgICAgKiAgICdvbkNsaWNrJzogZnVuY3Rpb24oKSB7IGNvbnNvbGUubG9nKCdjbGlja2VkICcgKyB0aGlzLmxhYmVsKTsgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmJpbmRBbGwodmlldyk7XG4gICAgICogalF1ZXJ5KCcjZG9jcycpLm9uKCdjbGljaycsIHZpZXcub25DbGljayk7XG4gICAgICogLy8gPT4gbG9ncyAnY2xpY2tlZCBkb2NzJywgd2hlbiB0aGUgYnV0dG9uIGlzIGNsaWNrZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5kQWxsKG9iamVjdCkge1xuICAgICAgdmFyIGZ1bmNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBiYXNlRmxhdHRlbihhcmd1bWVudHMsIHRydWUsIGZhbHNlLCAxKSA6IGZ1bmN0aW9ucyhvYmplY3QpLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gZnVuY3MubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gZnVuY3NbaW5kZXhdO1xuICAgICAgICBvYmplY3Rba2V5XSA9IGNyZWF0ZVdyYXBwZXIob2JqZWN0W2tleV0sIDEsIG51bGwsIG51bGwsIG9iamVjdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCwgaW52b2tlcyB0aGUgbWV0aG9kIGF0IGBvYmplY3Rba2V5XWBcbiAgICAgKiBhbmQgcHJlcGVuZHMgYW55IGFkZGl0aW9uYWwgYGJpbmRLZXlgIGFyZ3VtZW50cyB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgYm91bmRcbiAgICAgKiBmdW5jdGlvbi4gVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIGBfLmJpbmRgIGJ5IGFsbG93aW5nIGJvdW5kIGZ1bmN0aW9ucyB0b1xuICAgICAqIHJlZmVyZW5jZSBtZXRob2RzIHRoYXQgd2lsbCBiZSByZWRlZmluZWQgb3IgZG9uJ3QgeWV0IGV4aXN0LlxuICAgICAqIFNlZSBodHRwOi8vbWljaGF1eC5jYS9hcnRpY2xlcy9sYXp5LWZ1bmN0aW9uLWRlZmluaXRpb24tcGF0dGVybi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdGhlIG1ldGhvZCBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ10gQXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge1xuICAgICAqICAgJ25hbWUnOiAnZnJlZCcsXG4gICAgICogICAnZ3JlZXQnOiBmdW5jdGlvbihncmVldGluZykge1xuICAgICAqICAgICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLm5hbWU7XG4gICAgICogICB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5iaW5kS2V5KG9iamVjdCwgJ2dyZWV0JywgJ2hpJyk7XG4gICAgICogZnVuYygpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgICAqXG4gICAgICogb2JqZWN0LmdyZWV0ID0gZnVuY3Rpb24oZ3JlZXRpbmcpIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICd5YSAnICsgdGhpcy5uYW1lICsgJyEnO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBmdW5jKCk7XG4gICAgICogLy8gPT4gJ2hpeWEgZnJlZCEnXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluZEtleShvYmplY3QsIGtleSkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAyXG4gICAgICAgID8gY3JlYXRlV3JhcHBlcihrZXksIDE5LCBzbGljZShhcmd1bWVudHMsIDIpLCBudWxsLCBvYmplY3QpXG4gICAgICAgIDogY3JlYXRlV3JhcHBlcihrZXksIDMsIG51bGwsIG51bGwsIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIHRoZSBwcm92aWRlZCBmdW5jdGlvbnMsXG4gICAgICogd2hlcmUgZWFjaCBmdW5jdGlvbiBjb25zdW1lcyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiB0aGF0IGZvbGxvd3MuXG4gICAgICogRm9yIGV4YW1wbGUsIGNvbXBvc2luZyB0aGUgZnVuY3Rpb25zIGBmKClgLCBgZygpYCwgYW5kIGBoKClgIHByb2R1Y2VzIGBmKGcoaCgpKSlgLlxuICAgICAqIEVhY2ggZnVuY3Rpb24gaXMgZXhlY3V0ZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNvbXBvc2VkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IFtmdW5jXSBGdW5jdGlvbnMgdG8gY29tcG9zZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3NlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHJlYWxOYW1lTWFwID0ge1xuICAgICAqICAgJ3BlYmJsZXMnOiAncGVuZWxvcGUnXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBmb3JtYXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICogICBuYW1lID0gcmVhbE5hbWVNYXBbbmFtZS50b0xvd2VyQ2FzZSgpXSB8fCBuYW1lO1xuICAgICAqICAgcmV0dXJuIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpLnRvTG93ZXJDYXNlKCk7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBncmVldCA9IGZ1bmN0aW9uKGZvcm1hdHRlZCkge1xuICAgICAqICAgcmV0dXJuICdIaXlhICcgKyBmb3JtYXR0ZWQgKyAnISc7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciB3ZWxjb21lID0gXy5jb21wb3NlKGdyZWV0LCBmb3JtYXQpO1xuICAgICAqIHdlbGNvbWUoJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnSGl5YSBQZW5lbG9wZSEnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcG9zZSgpIHtcbiAgICAgIHZhciBmdW5jcyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBsZW5ndGggPSBmdW5jcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuY3NbbGVuZ3RoXSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgbGVuZ3RoID0gZnVuY3MubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgIGFyZ3MgPSBbZnVuY3NbbGVuZ3RoXS5hcHBseSh0aGlzLCBhcmdzKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB3aGljaCBhY2NlcHRzIG9uZSBvciBtb3JlIGFyZ3VtZW50cyBvZiBgZnVuY2AgdGhhdCB3aGVuXG4gICAgICogaW52b2tlZCBlaXRoZXIgZXhlY3V0ZXMgYGZ1bmNgIHJldHVybmluZyBpdHMgcmVzdWx0LCBpZiBhbGwgYGZ1bmNgIGFyZ3VtZW50c1xuICAgICAqIGhhdmUgYmVlbiBwcm92aWRlZCwgb3IgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBvbmUgb3IgbW9yZSBvZiB0aGVcbiAgICAgKiByZW1haW5pbmcgYGZ1bmNgIGFyZ3VtZW50cywgYW5kIHNvIG9uLiBUaGUgYXJpdHkgb2YgYGZ1bmNgIGNhbiBiZSBzcGVjaWZpZWRcbiAgICAgKiBpZiBgZnVuYy5sZW5ndGhgIGlzIG5vdCBzdWZmaWNpZW50LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHk9ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGN1cnJpZWQgPSBfLmN1cnJ5KGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGEgKyBiICsgYyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEpKDIpKDMpO1xuICAgICAqIC8vID0+IDZcbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMikoMyk7XG4gICAgICogLy8gPT4gNlxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyLCAzKTtcbiAgICAgKiAvLyA9PiA2XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VycnkoZnVuYywgYXJpdHkpIHtcbiAgICAgIGFyaXR5ID0gdHlwZW9mIGFyaXR5ID09ICdudW1iZXInID8gYXJpdHkgOiAoK2FyaXR5IHx8IGZ1bmMubGVuZ3RoKTtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKGZ1bmMsIDQsIG51bGwsIG51bGwsIG51bGwsIGFyaXR5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGRlbGF5IHRoZSBleGVjdXRpb24gb2YgYGZ1bmNgIHVudGlsIGFmdGVyXG4gICAgICogYHdhaXRgIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSBpdCB3YXMgaW52b2tlZC5cbiAgICAgKiBQcm92aWRlIGFuIG9wdGlvbnMgb2JqZWN0IHRvIGluZGljYXRlIHRoYXQgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uXG4gICAgICogdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBTdWJzZXF1ZW50IGNhbGxzXG4gICAgICogdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBjYWxsLlxuICAgICAqXG4gICAgICogTm90ZTogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCBgZnVuY2Agd2lsbCBiZSBjYWxsZWRcbiAgICAgKiBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIGlzXG4gICAgICogaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV0gU3BlY2lmeSBleGVjdXRpb24gb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF0gVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGNhbGxlZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdIFNwZWNpZnkgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gYXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eFxuICAgICAqIHZhciBsYXp5TGF5b3V0ID0gXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCk7XG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIGxhenlMYXlvdXQpO1xuICAgICAqXG4gICAgICogLy8gZXhlY3V0ZSBgc2VuZE1haWxgIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHNcbiAgICAgKiBqUXVlcnkoJyNwb3N0Ym94Jykub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gICAgICogICAnbGVhZGluZyc6IHRydWUsXG4gICAgICogICAndHJhaWxpbmcnOiBmYWxzZVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gZW5zdXJlIGBiYXRjaExvZ2AgaXMgZXhlY3V0ZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHNcbiAgICAgKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gICAgICogc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHtcbiAgICAgKiAgICdtYXhXYWl0JzogMTAwMFxuICAgICAqIH0sIGZhbHNlKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgYXJncyxcbiAgICAgICAgICBtYXhUaW1lb3V0SWQsXG4gICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgIHN0YW1wLFxuICAgICAgICAgIHRoaXNBcmcsXG4gICAgICAgICAgdGltZW91dElkLFxuICAgICAgICAgIHRyYWlsaW5nQ2FsbCxcbiAgICAgICAgICBsYXN0Q2FsbGVkID0gMCxcbiAgICAgICAgICBtYXhXYWl0ID0gZmFsc2UsXG4gICAgICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgIH1cbiAgICAgIHdhaXQgPSBuYXRpdmVNYXgoMCwgd2FpdCkgfHwgMDtcbiAgICAgIGlmIChvcHRpb25zID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBsZWFkaW5nID0gdHJ1ZTtcbiAgICAgICAgdHJhaWxpbmcgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgbGVhZGluZyA9IG9wdGlvbnMubGVhZGluZztcbiAgICAgICAgbWF4V2FpdCA9ICdtYXhXYWl0JyBpbiBvcHRpb25zICYmIChuYXRpdmVNYXgod2FpdCwgb3B0aW9ucy5tYXhXYWl0KSB8fCAwKTtcbiAgICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyBvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgICB9XG4gICAgICB2YXIgZGVsYXllZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3coKSAtIHN0YW1wKTtcbiAgICAgICAgaWYgKHJlbWFpbmluZyA8PSAwKSB7XG4gICAgICAgICAgaWYgKG1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KG1heFRpbWVvdXRJZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpc0NhbGxlZCA9IHRyYWlsaW5nQ2FsbDtcbiAgICAgICAgICBtYXhUaW1lb3V0SWQgPSB0aW1lb3V0SWQgPSB0cmFpbGluZ0NhbGwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKGlzQ2FsbGVkKSB7XG4gICAgICAgICAgICBsYXN0Q2FsbGVkID0gbm93KCk7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKCF0aW1lb3V0SWQgJiYgIW1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgICBhcmdzID0gdGhpc0FyZyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZGVsYXllZCwgcmVtYWluaW5nKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIG1heERlbGF5ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRpbWVvdXRJZCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIG1heFRpbWVvdXRJZCA9IHRpbWVvdXRJZCA9IHRyYWlsaW5nQ2FsbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRyYWlsaW5nIHx8IChtYXhXYWl0ICE9PSB3YWl0KSkge1xuICAgICAgICAgIGxhc3RDYWxsZWQgPSBub3coKTtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgIGlmICghdGltZW91dElkICYmICFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGFyZ3MgPSB0aGlzQXJnID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgc3RhbXAgPSBub3coKTtcbiAgICAgICAgdGhpc0FyZyA9IHRoaXM7XG4gICAgICAgIHRyYWlsaW5nQ2FsbCA9IHRyYWlsaW5nICYmICh0aW1lb3V0SWQgfHwgIWxlYWRpbmcpO1xuXG4gICAgICAgIGlmIChtYXhXYWl0ID09PSBmYWxzZSkge1xuICAgICAgICAgIHZhciBsZWFkaW5nQ2FsbCA9IGxlYWRpbmcgJiYgIXRpbWVvdXRJZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIW1heFRpbWVvdXRJZCAmJiAhbGVhZGluZykge1xuICAgICAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVtYWluaW5nID0gbWF4V2FpdCAtIChzdGFtcCAtIGxhc3RDYWxsZWQpLFxuICAgICAgICAgICAgICBpc0NhbGxlZCA9IHJlbWFpbmluZyA8PSAwO1xuXG4gICAgICAgICAgaWYgKGlzQ2FsbGVkKSB7XG4gICAgICAgICAgICBpZiAobWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICAgIG1heFRpbWVvdXRJZCA9IGNsZWFyVGltZW91dChtYXhUaW1lb3V0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoIW1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgbWF4VGltZW91dElkID0gc2V0VGltZW91dChtYXhEZWxheWVkLCByZW1haW5pbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDYWxsZWQgJiYgdGltZW91dElkKSB7XG4gICAgICAgICAgdGltZW91dElkID0gY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRpbWVvdXRJZCAmJiB3YWl0ICE9PSBtYXhXYWl0KSB7XG4gICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChkZWxheWVkLCB3YWl0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVhZGluZ0NhbGwpIHtcbiAgICAgICAgICBpc0NhbGxlZCA9IHRydWU7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDYWxsZWQgJiYgIXRpbWVvdXRJZCAmJiAhbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgYXJncyA9IHRoaXNBcmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmVycyBleGVjdXRpbmcgdGhlIGBmdW5jYCBmdW5jdGlvbiB1bnRpbCB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhcyBjbGVhcmVkLlxuICAgICAqIEFkZGl0aW9uYWwgYXJndW1lbnRzIHdpbGwgYmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQgaXMgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWZlci5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmddIEFyZ3VtZW50cyB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmZXIoZnVuY3Rpb24odGV4dCkgeyBjb25zb2xlLmxvZyh0ZXh0KTsgfSwgJ2RlZmVycmVkJyk7XG4gICAgICogLy8gbG9ncyAnZGVmZXJyZWQnIGFmdGVyIG9uZSBvciBtb3JlIG1pbGxpc2Vjb25kc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlZmVyKGZ1bmMpIHtcbiAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgfVxuICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDEpO1xuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTsgfSwgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGBmdW5jYCBmdW5jdGlvbiBhZnRlciBgd2FpdGAgbWlsbGlzZWNvbmRzLiBBZGRpdGlvbmFsIGFyZ3VtZW50c1xuICAgICAqIHdpbGwgYmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQgaXMgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBleGVjdXRpb24uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnXSBBcmd1bWVudHMgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVyIGlkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlbGF5KGZ1bmN0aW9uKHRleHQpIHsgY29uc29sZS5sb2codGV4dCk7IH0sIDEwMDAsICdsYXRlcicpO1xuICAgICAqIC8vID0+IGxvZ3MgJ2xhdGVyJyBhZnRlciBvbmUgc2Vjb25kXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVsYXkoZnVuYywgd2FpdCkge1xuICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMik7XG4gICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHsgZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3MpOyB9LCB3YWl0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICAgICAqIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZCB0byBkZXRlcm1pbmUgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0XG4gICAgICogYmFzZWQgb24gdGhlIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZVxuICAgICAqIGZpcnN0IGFyZ3VtZW50IHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBjYWNoZSBrZXkuXG4gICAgICogVGhlIGBmdW5jYCBpcyBleGVjdXRlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAgICogVGhlIHJlc3VsdCBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBBIGZ1bmN0aW9uIHVzZWQgdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemluZyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZpYm9uYWNjaSA9IF8ubWVtb2l6ZShmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiA8IDIgPyBuIDogZmlib25hY2NpKG4gLSAxKSArIGZpYm9uYWNjaShuIC0gMik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBmaWJvbmFjY2koOSlcbiAgICAgKiAvLyA9PiAzNFxuICAgICAqXG4gICAgICogdmFyIGRhdGEgPSB7XG4gICAgICogICAnZnJlZCc6IHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIC8vIG1vZGlmeWluZyB0aGUgcmVzdWx0IGNhY2hlXG4gICAgICogdmFyIGdldCA9IF8ubWVtb2l6ZShmdW5jdGlvbihuYW1lKSB7IHJldHVybiBkYXRhW25hbWVdOyB9LCBfLmlkZW50aXR5KTtcbiAgICAgKiBnZXQoJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICpcbiAgICAgKiBnZXQuY2FjaGUucGViYmxlcy5uYW1lID0gJ3BlbmVsb3BlJztcbiAgICAgKiBnZXQoJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ3BlbmVsb3BlJywgJ2FnZSc6IDEgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgfVxuICAgICAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjYWNoZSA9IG1lbW9pemVkLmNhY2hlLFxuICAgICAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDoga2V5UHJlZml4ICsgYXJndW1lbnRzWzBdO1xuXG4gICAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGNhY2hlLCBrZXkpXG4gICAgICAgICAgPyBjYWNoZVtrZXldXG4gICAgICAgICAgOiAoY2FjaGVba2V5XSA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICB9XG4gICAgICBtZW1vaXplZC5jYWNoZSA9IHt9O1xuICAgICAgcmV0dXJuIG1lbW9pemVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGlzIHJlc3RyaWN0ZWQgdG8gZXhlY3V0ZSBgZnVuY2Agb25jZS4gUmVwZWF0IGNhbGxzIHRvXG4gICAgICogdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgY2FsbC4gVGhlIGBmdW5jYCBpcyBleGVjdXRlZFxuICAgICAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBpbml0aWFsaXplID0gXy5vbmNlKGNyZWF0ZUFwcGxpY2F0aW9uKTtcbiAgICAgKiBpbml0aWFsaXplKCk7XG4gICAgICogaW5pdGlhbGl6ZSgpO1xuICAgICAqIC8vIGBpbml0aWFsaXplYCBleGVjdXRlcyBgY3JlYXRlQXBwbGljYXRpb25gIG9uY2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbmNlKGZ1bmMpIHtcbiAgICAgIHZhciByYW4sXG4gICAgICAgICAgcmVzdWx0O1xuXG4gICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHJhbikge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmFuID0gdHJ1ZTtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIC8vIGNsZWFyIHRoZSBgZnVuY2AgdmFyaWFibGUgc28gdGhlIGZ1bmN0aW9uIG1heSBiZSBnYXJiYWdlIGNvbGxlY3RlZFxuICAgICAgICBmdW5jID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCBpbnZva2VzIGBmdW5jYCB3aXRoIGFueSBhZGRpdGlvbmFsXG4gICAgICogYHBhcnRpYWxgIGFyZ3VtZW50cyBwcmVwZW5kZWQgdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi4gVGhpc1xuICAgICAqIG1ldGhvZCBpcyBzaW1pbGFyIHRvIGBfLmJpbmRgIGV4Y2VwdCBpdCBkb2VzICoqbm90KiogYWx0ZXIgdGhlIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnXSBBcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBncmVldCA9IGZ1bmN0aW9uKGdyZWV0aW5nLCBuYW1lKSB7IHJldHVybiBncmVldGluZyArICcgJyArIG5hbWU7IH07XG4gICAgICogdmFyIGhpID0gXy5wYXJ0aWFsKGdyZWV0LCAnaGknKTtcbiAgICAgKiBoaSgnZnJlZCcpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnRpYWwoZnVuYykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIoZnVuYywgMTYsIHNsaWNlKGFyZ3VtZW50cywgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucGFydGlhbGAgZXhjZXB0IHRoYXQgYHBhcnRpYWxgIGFyZ3VtZW50cyBhcmVcbiAgICAgKiBhcHBlbmRlZCB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnXSBBcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBkZWZhdWx0c0RlZXAgPSBfLnBhcnRpYWxSaWdodChfLm1lcmdlLCBfLmRlZmF1bHRzKTtcbiAgICAgKlxuICAgICAqIHZhciBvcHRpb25zID0ge1xuICAgICAqICAgJ3ZhcmlhYmxlJzogJ2RhdGEnLFxuICAgICAqICAgJ2ltcG9ydHMnOiB7ICdqcSc6ICQgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBkZWZhdWx0c0RlZXAob3B0aW9ucywgXy50ZW1wbGF0ZVNldHRpbmdzKTtcbiAgICAgKlxuICAgICAqIG9wdGlvbnMudmFyaWFibGVcbiAgICAgKiAvLyA9PiAnZGF0YSdcbiAgICAgKlxuICAgICAqIG9wdGlvbnMuaW1wb3J0c1xuICAgICAqIC8vID0+IHsgJ18nOiBfLCAnanEnOiAkIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJ0aWFsUmlnaHQoZnVuYykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIoZnVuYywgMzIsIG51bGwsIHNsaWNlKGFyZ3VtZW50cywgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGV4ZWN1dGVkLCB3aWxsIG9ubHkgY2FsbCB0aGUgYGZ1bmNgIGZ1bmN0aW9uXG4gICAgICogYXQgbW9zdCBvbmNlIHBlciBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLiBQcm92aWRlIGFuIG9wdGlvbnMgb2JqZWN0IHRvXG4gICAgICogaW5kaWNhdGUgdGhhdCBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2VcbiAgICAgKiBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlIHRocm90dGxlZCBmdW5jdGlvbiB3aWxsXG4gICAgICogcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGNhbGwuXG4gICAgICpcbiAgICAgKiBOb3RlOiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgIGBmdW5jYCB3aWxsIGJlIGNhbGxlZFxuICAgICAqIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gaXNcbiAgICAgKiBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgZXhlY3V0aW9ucyB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9dHJ1ZV0gU3BlY2lmeSBleGVjdXRpb24gb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdIFNwZWNpZnkgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gYXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZ1xuICAgICAqIHZhciB0aHJvdHRsZWQgPSBfLnRocm90dGxlKHVwZGF0ZVBvc2l0aW9uLCAxMDApO1xuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdzY3JvbGwnLCB0aHJvdHRsZWQpO1xuICAgICAqXG4gICAgICogLy8gZXhlY3V0ZSBgcmVuZXdUb2tlbmAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGJ1dCBub3QgbW9yZSB0aGFuIG9uY2UgZXZlcnkgNSBtaW51dGVzXG4gICAgICogalF1ZXJ5KCcuaW50ZXJhY3RpdmUnKS5vbignY2xpY2snLCBfLnRocm90dGxlKHJlbmV3VG9rZW4sIDMwMDAwMCwge1xuICAgICAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAgICAgKiB9KSk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgbGVhZGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBsZWFkaW5nID0gJ2xlYWRpbmcnIGluIG9wdGlvbnMgPyBvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/IG9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgIH1cbiAgICAgIGRlYm91bmNlT3B0aW9ucy5sZWFkaW5nID0gbGVhZGluZztcbiAgICAgIGRlYm91bmNlT3B0aW9ucy5tYXhXYWl0ID0gd2FpdDtcbiAgICAgIGRlYm91bmNlT3B0aW9ucy50cmFpbGluZyA9IHRyYWlsaW5nO1xuXG4gICAgICByZXR1cm4gZGVib3VuY2UoZnVuYywgd2FpdCwgZGVib3VuY2VPcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwcm92aWRlcyBgdmFsdWVgIHRvIHRoZSB3cmFwcGVyIGZ1bmN0aW9uIGFzIGl0c1xuICAgICAqIGZpcnN0IGFyZ3VtZW50LiBBZGRpdGlvbmFsIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZnVuY3Rpb24gYXJlIGFwcGVuZGVkXG4gICAgICogdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIHdyYXBwZXIgZnVuY3Rpb24uIFRoZSB3cmFwcGVyIGlzIGV4ZWN1dGVkIHdpdGhcbiAgICAgKiB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwcGVyIFRoZSB3cmFwcGVyIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgcCA9IF8ud3JhcChfLmVzY2FwZSwgZnVuY3Rpb24oZnVuYywgdGV4dCkge1xuICAgICAqICAgcmV0dXJuICc8cD4nICsgZnVuYyh0ZXh0KSArICc8L3A+JztcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHAoJ0ZyZWQsIFdpbG1hLCAmIFBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnPHA+RnJlZCwgV2lsbWEsICZhbXA7IFBlYmJsZXM8L3A+J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXAodmFsdWUsIHdyYXBwZXIpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKHdyYXBwZXIsIDE2LCBbdmFsdWVdKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnbmFtZSc6ICdmcmVkJyB9O1xuICAgICAqIHZhciBnZXR0ZXIgPSBfLmNvbnN0YW50KG9iamVjdCk7XG4gICAgICogZ2V0dGVyKCkgPT09IG9iamVjdDtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyBhIGNhbGxiYWNrIGJvdW5kIHRvIGFuIG9wdGlvbmFsIGB0aGlzQXJnYC4gSWYgYGZ1bmNgIGlzIGEgcHJvcGVydHlcbiAgICAgKiBuYW1lIHRoZSBjcmVhdGVkIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBmb3IgYSBnaXZlbiBlbGVtZW50LlxuICAgICAqIElmIGBmdW5jYCBpcyBhbiBvYmplY3QgdGhlIGNyZWF0ZWQgY2FsbGJhY2sgd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50c1xuICAgICAqIHRoYXQgY29udGFpbiB0aGUgZXF1aXZhbGVudCBvYmplY3QgcHJvcGVydGllcywgb3RoZXJ3aXNlIGl0IHdpbGwgcmV0dXJuIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHsqfSBbZnVuYz1pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcmdDb3VudF0gVGhlIG51bWJlciBvZiBhcmd1bWVudHMgdGhlIGNhbGxiYWNrIGFjY2VwdHMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGEgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gd3JhcCB0byBjcmVhdGUgY3VzdG9tIGNhbGxiYWNrIHNob3J0aGFuZHNcbiAgICAgKiBfLmNyZWF0ZUNhbGxiYWNrID0gXy53cmFwKF8uY3JlYXRlQ2FsbGJhY2ssIGZ1bmN0aW9uKGZ1bmMsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICogICB2YXIgbWF0Y2ggPSAvXiguKz8pX18oW2dsXXQpKC4rKSQvLmV4ZWMoY2FsbGJhY2spO1xuICAgICAqICAgcmV0dXJuICFtYXRjaCA/IGZ1bmMoY2FsbGJhY2ssIHRoaXNBcmcpIDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICogICAgIHJldHVybiBtYXRjaFsyXSA9PSAnZ3QnID8gb2JqZWN0W21hdGNoWzFdXSA+IG1hdGNoWzNdIDogb2JqZWN0W21hdGNoWzFdXSA8IG1hdGNoWzNdO1xuICAgICAqICAgfTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKGNoYXJhY3RlcnMsICdhZ2VfX2d0MzgnKTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGZ1bmM7XG4gICAgICBpZiAoZnVuYyA9PSBudWxsIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gYmFzZUNyZWF0ZUNhbGxiYWNrKGZ1bmMsIHRoaXNBcmcsIGFyZ0NvdW50KTtcbiAgICAgIH1cbiAgICAgIC8vIGhhbmRsZSBcIl8ucGx1Y2tcIiBzdHlsZSBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAgICBpZiAodHlwZSAhPSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gcHJvcGVydHkoZnVuYyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcHMgPSBrZXlzKGZ1bmMpLFxuICAgICAgICAgIGtleSA9IHByb3BzWzBdLFxuICAgICAgICAgIGEgPSBmdW5jW2tleV07XG5cbiAgICAgIC8vIGhhbmRsZSBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAgICBpZiAocHJvcHMubGVuZ3RoID09IDEgJiYgYSA9PT0gYSAmJiAhaXNPYmplY3QoYSkpIHtcbiAgICAgICAgLy8gZmFzdCBwYXRoIHRoZSBjb21tb24gY2FzZSBvZiBwcm92aWRpbmcgYW4gb2JqZWN0IHdpdGggYSBzaW5nbGVcbiAgICAgICAgLy8gcHJvcGVydHkgY29udGFpbmluZyBhIHByaW1pdGl2ZSB2YWx1ZVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgICAgdmFyIGIgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICByZXR1cm4gYSA9PT0gYiAmJiAoYSAhPT0gMCB8fCAoMSAvIGEgPT0gMSAvIGIpKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgIGlmICghKHJlc3VsdCA9IGJhc2VJc0VxdWFsKG9iamVjdFtwcm9wc1tsZW5ndGhdXSwgZnVuY1twcm9wc1tsZW5ndGhdXSwgbnVsbCwgdHJ1ZSkpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGNoYXJhY3RlcnMgYCZgLCBgPGAsIGA+YCwgYFwiYCwgYW5kIGAnYCBpbiBgc3RyaW5nYCB0byB0aGVpclxuICAgICAqIGNvcnJlc3BvbmRpbmcgSFRNTCBlbnRpdGllcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVzY2FwZSgnRnJlZCwgV2lsbWEsICYgUGViYmxlcycpO1xuICAgICAqIC8vID0+ICdGcmVkLCBXaWxtYSwgJmFtcDsgUGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlc2NhcGUoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nID09IG51bGwgPyAnJyA6IFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVVbmVzY2FwZWRIdG1sLCBlc2NhcGVIdG1sQ2hhcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgcHJvdmlkZWQgdG8gaXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ25hbWUnOiAnZnJlZCcgfTtcbiAgICAgKiBfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdDtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGZ1bmN0aW9uIHByb3BlcnRpZXMgb2YgYSBzb3VyY2Ugb2JqZWN0IHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogSWYgYG9iamVjdGAgaXMgYSBmdW5jdGlvbiBtZXRob2RzIHdpbGwgYmUgYWRkZWQgdG8gaXRzIHByb3RvdHlwZSBhcyB3ZWxsLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBbb2JqZWN0PWxvZGFzaF0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIGZ1bmN0aW9ucyB0byBhZGQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGFpbj10cnVlXSBTcGVjaWZ5IHdoZXRoZXIgdGhlIGZ1bmN0aW9ucyBhZGRlZCBhcmUgY2hhaW5hYmxlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjYXBpdGFsaXplKHN0cmluZykge1xuICAgICAqICAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKS50b0xvd2VyQ2FzZSgpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8ubWl4aW4oeyAnY2FwaXRhbGl6ZSc6IGNhcGl0YWxpemUgfSk7XG4gICAgICogXy5jYXBpdGFsaXplKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ0ZyZWQnXG4gICAgICpcbiAgICAgKiBfKCdmcmVkJykuY2FwaXRhbGl6ZSgpLnZhbHVlKCk7XG4gICAgICogLy8gPT4gJ0ZyZWQnXG4gICAgICpcbiAgICAgKiBfLm1peGluKHsgJ2NhcGl0YWxpemUnOiBjYXBpdGFsaXplIH0sIHsgJ2NoYWluJzogZmFsc2UgfSk7XG4gICAgICogXygnZnJlZCcpLmNhcGl0YWxpemUoKTtcbiAgICAgKiAvLyA9PiAnRnJlZCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaXhpbihvYmplY3QsIHNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgdmFyIGNoYWluID0gdHJ1ZSxcbiAgICAgICAgICBtZXRob2ROYW1lcyA9IHNvdXJjZSAmJiBmdW5jdGlvbnMoc291cmNlKTtcblxuICAgICAgaWYgKCFzb3VyY2UgfHwgKCFvcHRpb25zICYmICFtZXRob2ROYW1lcy5sZW5ndGgpKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgICBvcHRpb25zID0gc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGN0b3IgPSBsb2Rhc2hXcmFwcGVyO1xuICAgICAgICBzb3VyY2UgPSBvYmplY3Q7XG4gICAgICAgIG9iamVjdCA9IGxvZGFzaDtcbiAgICAgICAgbWV0aG9kTmFtZXMgPSBmdW5jdGlvbnMoc291cmNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zID09PSBmYWxzZSkge1xuICAgICAgICBjaGFpbiA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChvcHRpb25zKSAmJiAnY2hhaW4nIGluIG9wdGlvbnMpIHtcbiAgICAgICAgY2hhaW4gPSBvcHRpb25zLmNoYWluO1xuICAgICAgfVxuICAgICAgdmFyIGN0b3IgPSBvYmplY3QsXG4gICAgICAgICAgaXNGdW5jID0gaXNGdW5jdGlvbihjdG9yKTtcblxuICAgICAgZm9yRWFjaChtZXRob2ROYW1lcywgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgZnVuYyA9IG9iamVjdFttZXRob2ROYW1lXSA9IHNvdXJjZVttZXRob2ROYW1lXTtcbiAgICAgICAgaWYgKGlzRnVuYykge1xuICAgICAgICAgIGN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXyxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX18sXG4gICAgICAgICAgICAgICAgYXJncyA9IFt2YWx1ZV07XG5cbiAgICAgICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KG9iamVjdCwgYXJncyk7XG4gICAgICAgICAgICBpZiAoY2hhaW4gfHwgY2hhaW5BbGwpIHtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSByZXN1bHQgJiYgaXNPYmplY3QocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBjdG9yKHJlc3VsdCk7XG4gICAgICAgICAgICAgIHJlc3VsdC5fX2NoYWluX18gPSBjaGFpbkFsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJ0cyB0aGUgJ18nIHZhcmlhYmxlIHRvIGl0cyBwcmV2aW91cyB2YWx1ZSBhbmQgcmV0dXJucyBhIHJlZmVyZW5jZSB0b1xuICAgICAqIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgbG9kYXNoID0gXy5ub0NvbmZsaWN0KCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgICAgIGNvbnRleHQuXyA9IG9sZERhc2g7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIG5vLW9wZXJhdGlvbiBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ25hbWUnOiAnZnJlZCcgfTtcbiAgICAgKiBfLm5vb3Aob2JqZWN0KSA9PT0gdW5kZWZpbmVkO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub29wKCkge1xuICAgICAgLy8gbm8gb3BlcmF0aW9uIHBlcmZvcm1lZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIFVuaXggZXBvY2hcbiAgICAgKiAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHN0YW1wID0gXy5ub3coKTtcbiAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKCkgeyBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApOyB9KTtcbiAgICAgKiAvLyA9PiBsb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBmdW5jdGlvbiB0byBiZSBjYWxsZWRcbiAgICAgKi9cbiAgICB2YXIgbm93ID0gaXNOYXRpdmUobm93ID0gRGF0ZS5ub3cpICYmIG5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGdpdmVuIHZhbHVlIGludG8gYW4gaW50ZWdlciBvZiB0aGUgc3BlY2lmaWVkIHJhZGl4LlxuICAgICAqIElmIGByYWRpeGAgaXMgYHVuZGVmaW5lZGAgb3IgYDBgIGEgYHJhZGl4YCBvZiBgMTBgIGlzIHVzZWQgdW5sZXNzIHRoZVxuICAgICAqIGB2YWx1ZWAgaXMgYSBoZXhhZGVjaW1hbCwgaW4gd2hpY2ggY2FzZSBhIGByYWRpeGAgb2YgYDE2YCBpcyB1c2VkLlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyBtZXRob2QgYXZvaWRzIGRpZmZlcmVuY2VzIGluIG5hdGl2ZSBFUzMgYW5kIEVTNSBgcGFyc2VJbnRgXG4gICAgICogaW1wbGVtZW50YXRpb25zLiBTZWUgaHR0cDovL2VzNS5naXRodWIuaW8vI0UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSB0byBwYXJzZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3JhZGl4XSBUaGUgcmFkaXggdXNlZCB0byBpbnRlcnByZXQgdGhlIHZhbHVlIHRvIHBhcnNlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG5ldyBpbnRlZ2VyIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhcnNlSW50KCcwOCcpO1xuICAgICAqIC8vID0+IDhcbiAgICAgKi9cbiAgICB2YXIgcGFyc2VJbnQgPSBuYXRpdmVQYXJzZUludCh3aGl0ZXNwYWNlICsgJzA4JykgPT0gOCA/IG5hdGl2ZVBhcnNlSW50IDogZnVuY3Rpb24odmFsdWUsIHJhZGl4KSB7XG4gICAgICAvLyBGaXJlZm94IDwgMjEgYW5kIE9wZXJhIDwgMTUgZm9sbG93IHRoZSBFUzMgc3BlY2lmaWVkIGltcGxlbWVudGF0aW9uIG9mIGBwYXJzZUludGBcbiAgICAgIHJldHVybiBuYXRpdmVQYXJzZUludChpc1N0cmluZyh2YWx1ZSkgPyB2YWx1ZS5yZXBsYWNlKHJlTGVhZGluZ1NwYWNlc0FuZFplcm9zLCAnJykgOiB2YWx1ZSwgcmFkaXggfHwgMCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBcIl8ucGx1Y2tcIiBzdHlsZSBmdW5jdGlvbiwgd2hpY2ggcmV0dXJucyB0aGUgYGtleWAgdmFsdWUgb2YgYVxuICAgICAqIGdpdmVuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byByZXRyaWV2ZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgZ2V0TmFtZSA9IF8ucHJvcGVydHkoJ25hbWUnKTtcbiAgICAgKlxuICAgICAqIF8ubWFwKGNoYXJhY3RlcnMsIGdldE5hbWUpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogXy5zb3J0QnkoY2hhcmFjdGVycywgZ2V0TmFtZSk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvcGVydHkoa2V5KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYSByYW5kb20gbnVtYmVyIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgIChpbmNsdXNpdmUpLiBJZiBvbmx5IG9uZVxuICAgICAqIGFyZ3VtZW50IGlzIHByb3ZpZGVkIGEgbnVtYmVyIGJldHdlZW4gYDBgIGFuZCB0aGUgZ2l2ZW4gbnVtYmVyIHdpbGwgYmVcbiAgICAgKiByZXR1cm5lZC4gSWYgYGZsb2F0aW5nYCBpcyB0cnVleSBvciBlaXRoZXIgYG1pbmAgb3IgYG1heGAgYXJlIGZsb2F0cyBhXG4gICAgICogZmxvYXRpbmctcG9pbnQgbnVtYmVyIHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZCBvZiBhbiBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbWluPTBdIFRoZSBtaW5pbXVtIHBvc3NpYmxlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4PTFdIFRoZSBtYXhpbXVtIHBvc3NpYmxlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zsb2F0aW5nPWZhbHNlXSBTcGVjaWZ5IHJldHVybmluZyBhIGZsb2F0aW5nLXBvaW50IG51bWJlci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGEgcmFuZG9tIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5kb20oMCwgNSk7XG4gICAgICogLy8gPT4gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUpO1xuICAgICAqIC8vID0+IGFsc28gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUsIHRydWUpO1xuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oMS4yLCA1LjIpO1xuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMS4yIGFuZCA1LjJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYW5kb20obWluLCBtYXgsIGZsb2F0aW5nKSB7XG4gICAgICB2YXIgbm9NaW4gPSBtaW4gPT0gbnVsbCxcbiAgICAgICAgICBub01heCA9IG1heCA9PSBudWxsO1xuXG4gICAgICBpZiAoZmxvYXRpbmcgPT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIG1pbiA9PSAnYm9vbGVhbicgJiYgbm9NYXgpIHtcbiAgICAgICAgICBmbG9hdGluZyA9IG1pbjtcbiAgICAgICAgICBtaW4gPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFub01heCAmJiB0eXBlb2YgbWF4ID09ICdib29sZWFuJykge1xuICAgICAgICAgIGZsb2F0aW5nID0gbWF4O1xuICAgICAgICAgIG5vTWF4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vTWluICYmIG5vTWF4KSB7XG4gICAgICAgIG1heCA9IDE7XG4gICAgICB9XG4gICAgICBtaW4gPSArbWluIHx8IDA7XG4gICAgICBpZiAobm9NYXgpIHtcbiAgICAgICAgbWF4ID0gbWluO1xuICAgICAgICBtaW4gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF4ID0gK21heCB8fCAwO1xuICAgICAgfVxuICAgICAgaWYgKGZsb2F0aW5nIHx8IG1pbiAlIDEgfHwgbWF4ICUgMSkge1xuICAgICAgICB2YXIgcmFuZCA9IG5hdGl2ZVJhbmRvbSgpO1xuICAgICAgICByZXR1cm4gbmF0aXZlTWluKG1pbiArIChyYW5kICogKG1heCAtIG1pbiArIHBhcnNlRmxvYXQoJzFlLScgKyAoKHJhbmQgKycnKS5sZW5ndGggLSAxKSkpKSwgbWF4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlUmFuZG9tKG1pbiwgbWF4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB0aGUgdmFsdWUgb2YgcHJvcGVydHkgYGtleWAgb24gYG9iamVjdGAuIElmIGBrZXlgIGlzIGEgZnVuY3Rpb25cbiAgICAgKiBpdCB3aWxsIGJlIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYG9iamVjdGAgYW5kIGl0cyByZXN1bHQgcmV0dXJuZWQsXG4gICAgICogZWxzZSB0aGUgcHJvcGVydHkgdmFsdWUgaXMgcmV0dXJuZWQuIElmIGBvYmplY3RgIGlzIGZhbHNleSB0aGVuIGB1bmRlZmluZWRgXG4gICAgICogaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gcmVzb2x2ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7XG4gICAgICogICAnY2hlZXNlJzogJ2NydW1wZXRzJyxcbiAgICAgKiAgICdzdHVmZic6IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICByZXR1cm4gJ25vbnNlbnNlJztcbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnY2hlZXNlJyk7XG4gICAgICogLy8gPT4gJ2NydW1wZXRzJ1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnc3R1ZmYnKTtcbiAgICAgKiAvLyA9PiAnbm9uc2Vuc2UnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdWx0KG9iamVjdCwga2V5KSB7XG4gICAgICBpZiAob2JqZWN0KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbih2YWx1ZSkgPyBvYmplY3Rba2V5XSgpIDogdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBtaWNyby10ZW1wbGF0aW5nIG1ldGhvZCB0aGF0IGhhbmRsZXMgYXJiaXRyYXJ5IGRlbGltaXRlcnMsIHByZXNlcnZlc1xuICAgICAqIHdoaXRlc3BhY2UsIGFuZCBjb3JyZWN0bHkgZXNjYXBlcyBxdW90ZXMgd2l0aGluIGludGVycG9sYXRlZCBjb2RlLlxuICAgICAqXG4gICAgICogTm90ZTogSW4gdGhlIGRldmVsb3BtZW50IGJ1aWxkLCBgXy50ZW1wbGF0ZWAgdXRpbGl6ZXMgc291cmNlVVJMcyBmb3IgZWFzaWVyXG4gICAgICogZGVidWdnaW5nLiBTZWUgaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvZGV2ZWxvcGVydG9vbHMvc291cmNlbWFwcy8jdG9jLXNvdXJjZXVybFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gcHJlY29tcGlsaW5nIHRlbXBsYXRlcyBzZWU6XG4gICAgICogaHR0cDovL2xvZGFzaC5jb20vY3VzdG9tLWJ1aWxkc1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gQ2hyb21lIGV4dGVuc2lvbiBzYW5kYm94ZXMgc2VlOlxuICAgICAqIGh0dHA6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9zdGFibGUvZXh0ZW5zaW9ucy9zYW5kYm94aW5nRXZhbC5odG1sXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHRlbXBsYXRlIHRleHQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIGRhdGEgb2JqZWN0IHVzZWQgdG8gcG9wdWxhdGUgdGhlIHRleHQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmVzY2FwZV0gVGhlIFwiZXNjYXBlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5ldmFsdWF0ZV0gVGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmltcG9ydHNdIEFuIG9iamVjdCB0byBpbXBvcnQgaW50byB0aGUgdGVtcGxhdGUgYXMgbG9jYWwgdmFyaWFibGVzLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5pbnRlcnBvbGF0ZV0gVGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzb3VyY2VVUkxdIFRoZSBzb3VyY2VVUkwgb2YgdGhlIHRlbXBsYXRlJ3MgY29tcGlsZWQgc291cmNlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdmFyaWFibGVdIFRoZSBkYXRhIG9iamVjdCB2YXJpYWJsZSBuYW1lLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxzdHJpbmd9IFJldHVybnMgYSBjb21waWxlZCBmdW5jdGlvbiB3aGVuIG5vIGBkYXRhYCBvYmplY3RcbiAgICAgKiAgaXMgZ2l2ZW4sIGVsc2UgaXQgcmV0dXJucyB0aGUgaW50ZXJwb2xhdGVkIHRleHQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyIHRvIGNyZWF0ZSBhIGNvbXBpbGVkIHRlbXBsYXRlXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IG5hbWUgJT4nKTtcbiAgICAgKiBjb21waWxlZCh7ICduYW1lJzogJ2ZyZWQnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiZXNjYXBlXCIgZGVsaW1pdGVyIHRvIGVzY2FwZSBIVE1MIGluIGRhdGEgcHJvcGVydHkgdmFsdWVzXG4gICAgICogXy50ZW1wbGF0ZSgnPGI+PCUtIHZhbHVlICU+PC9iPicsIHsgJ3ZhbHVlJzogJzxzY3JpcHQ+JyB9KTtcbiAgICAgKiAvLyA9PiAnPGI+Jmx0O3NjcmlwdCZndDs8L2I+J1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIgdG8gZ2VuZXJhdGUgSFRNTFxuICAgICAqIHZhciBsaXN0ID0gJzwlIF8uZm9yRWFjaChwZW9wbGUsIGZ1bmN0aW9uKG5hbWUpIHsgJT48bGk+PCUtIG5hbWUgJT48L2xpPjwlIH0pOyAlPic7XG4gICAgICogXy50ZW1wbGF0ZShsaXN0LCB7ICdwZW9wbGUnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gICAgICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgRVM2IGRlbGltaXRlciBhcyBhbiBhbHRlcm5hdGl2ZSB0byB0aGUgZGVmYXVsdCBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyXG4gICAgICogXy50ZW1wbGF0ZSgnaGVsbG8gJHsgbmFtZSB9JywgeyAnbmFtZSc6ICdwZWJibGVzJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gcGViYmxlcydcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBpbnRlcm5hbCBgcHJpbnRgIGZ1bmN0aW9uIGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzXG4gICAgICogXy50ZW1wbGF0ZSgnPCUgcHJpbnQoXCJoZWxsbyBcIiArIG5hbWUpOyAlPiEnLCB7ICduYW1lJzogJ2Jhcm5leScgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGJhcm5leSEnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBhIGN1c3RvbSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzXG4gICAgICogXy50ZW1wbGF0ZVNldHRpbmdzID0ge1xuICAgICAqICAgJ2ludGVycG9sYXRlJzogL3t7KFtcXHNcXFNdKz8pfX0vZ1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLnRlbXBsYXRlKCdoZWxsbyB7eyBuYW1lIH19IScsIHsgJ25hbWUnOiAnbXVzdGFjaGUnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBtdXN0YWNoZSEnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYGltcG9ydHNgIG9wdGlvbiB0byBpbXBvcnQgalF1ZXJ5XG4gICAgICogdmFyIGxpc3QgPSAnPCUganEuZWFjaChwZW9wbGUsIGZ1bmN0aW9uKG5hbWUpIHsgJT48bGk+PCUtIG5hbWUgJT48L2xpPjwlIH0pOyAlPic7XG4gICAgICogXy50ZW1wbGF0ZShsaXN0LCB7ICdwZW9wbGUnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSwgeyAnaW1wb3J0cyc6IHsgJ2pxJzogalF1ZXJ5IH0gfSk7XG4gICAgICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYHNvdXJjZVVSTGAgb3B0aW9uIHRvIHNwZWNpZnkgYSBjdXN0b20gc291cmNlVVJMIGZvciB0aGUgdGVtcGxhdGVcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gbmFtZSAlPicsIG51bGwsIHsgJ3NvdXJjZVVSTCc6ICcvYmFzaWMvZ3JlZXRpbmcuanN0JyB9KTtcbiAgICAgKiBjb21waWxlZChkYXRhKTtcbiAgICAgKiAvLyA9PiBmaW5kIHRoZSBzb3VyY2Ugb2YgXCJncmVldGluZy5qc3RcIiB1bmRlciB0aGUgU291cmNlcyB0YWIgb3IgUmVzb3VyY2VzIHBhbmVsIG9mIHRoZSB3ZWIgaW5zcGVjdG9yXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYHZhcmlhYmxlYCBvcHRpb24gdG8gZW5zdXJlIGEgd2l0aC1zdGF0ZW1lbnQgaXNuJ3QgdXNlZCBpbiB0aGUgY29tcGlsZWQgdGVtcGxhdGVcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoaSA8JT0gZGF0YS5uYW1lICU+IScsIG51bGwsIHsgJ3ZhcmlhYmxlJzogJ2RhdGEnIH0pO1xuICAgICAqIGNvbXBpbGVkLnNvdXJjZTtcbiAgICAgKiAvLyA9PiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICogICB2YXIgX190LCBfX3AgPSAnJywgX19lID0gXy5lc2NhcGU7XG4gICAgICogICBfX3AgKz0gJ2hpICcgKyAoKF9fdCA9ICggZGF0YS5uYW1lICkpID09IG51bGwgPyAnJyA6IF9fdCkgKyAnISc7XG4gICAgICogICByZXR1cm4gX19wO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgc291cmNlYCBwcm9wZXJ0eSB0byBpbmxpbmUgY29tcGlsZWQgdGVtcGxhdGVzIGZvciBtZWFuaW5nZnVsXG4gICAgICogLy8gbGluZSBudW1iZXJzIGluIGVycm9yIG1lc3NhZ2VzIGFuZCBhIHN0YWNrIHRyYWNlXG4gICAgICogZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4oY3dkLCAnanN0LmpzJyksICdcXFxuICAgICAqICAgdmFyIEpTVCA9IHtcXFxuICAgICAqICAgICBcIm1haW5cIjogJyArIF8udGVtcGxhdGUobWFpblRleHQpLnNvdXJjZSArICdcXFxuICAgICAqICAgfTtcXFxuICAgICAqICcpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRlbXBsYXRlKHRleHQsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgIC8vIGJhc2VkIG9uIEpvaG4gUmVzaWcncyBgdG1wbGAgaW1wbGVtZW50YXRpb25cbiAgICAgIC8vIGh0dHA6Ly9lam9obi5vcmcvYmxvZy9qYXZhc2NyaXB0LW1pY3JvLXRlbXBsYXRpbmcvXG4gICAgICAvLyBhbmQgTGF1cmEgRG9rdG9yb3ZhJ3MgZG9ULmpzXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vb2xhZG8vZG9UXG4gICAgICB2YXIgc2V0dGluZ3MgPSBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncztcbiAgICAgIHRleHQgPSBTdHJpbmcodGV4dCB8fCAnJyk7XG5cbiAgICAgIC8vIGF2b2lkIG1pc3NpbmcgZGVwZW5kZW5jaWVzIHdoZW4gYGl0ZXJhdG9yVGVtcGxhdGVgIGlzIG5vdCBkZWZpbmVkXG4gICAgICBvcHRpb25zID0gZGVmYXVsdHMoe30sIG9wdGlvbnMsIHNldHRpbmdzKTtcblxuICAgICAgdmFyIGltcG9ydHMgPSBkZWZhdWx0cyh7fSwgb3B0aW9ucy5pbXBvcnRzLCBzZXR0aW5ncy5pbXBvcnRzKSxcbiAgICAgICAgICBpbXBvcnRzS2V5cyA9IGtleXMoaW1wb3J0cyksXG4gICAgICAgICAgaW1wb3J0c1ZhbHVlcyA9IHZhbHVlcyhpbXBvcnRzKTtcblxuICAgICAgdmFyIGlzRXZhbHVhdGluZyxcbiAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgaW50ZXJwb2xhdGUgPSBvcHRpb25zLmludGVycG9sYXRlIHx8IHJlTm9NYXRjaCxcbiAgICAgICAgICBzb3VyY2UgPSBcIl9fcCArPSAnXCI7XG5cbiAgICAgIC8vIGNvbXBpbGUgdGhlIHJlZ2V4cCB0byBtYXRjaCBlYWNoIGRlbGltaXRlclxuICAgICAgdmFyIHJlRGVsaW1pdGVycyA9IFJlZ0V4cChcbiAgICAgICAgKG9wdGlvbnMuZXNjYXBlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAgICAgaW50ZXJwb2xhdGUuc291cmNlICsgJ3wnICtcbiAgICAgICAgKGludGVycG9sYXRlID09PSByZUludGVycG9sYXRlID8gcmVFc1RlbXBsYXRlIDogcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICAob3B0aW9ucy5ldmFsdWF0ZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JCdcbiAgICAgICwgJ2cnKTtcblxuICAgICAgdGV4dC5yZXBsYWNlKHJlRGVsaW1pdGVycywgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZVZhbHVlLCBpbnRlcnBvbGF0ZVZhbHVlLCBlc1RlbXBsYXRlVmFsdWUsIGV2YWx1YXRlVmFsdWUsIG9mZnNldCkge1xuICAgICAgICBpbnRlcnBvbGF0ZVZhbHVlIHx8IChpbnRlcnBvbGF0ZVZhbHVlID0gZXNUZW1wbGF0ZVZhbHVlKTtcblxuICAgICAgICAvLyBlc2NhcGUgY2hhcmFjdGVycyB0aGF0IGNhbm5vdCBiZSBpbmNsdWRlZCBpbiBzdHJpbmcgbGl0ZXJhbHNcbiAgICAgICAgc291cmNlICs9IHRleHQuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShyZVVuZXNjYXBlZFN0cmluZywgZXNjYXBlU3RyaW5nQ2hhcik7XG5cbiAgICAgICAgLy8gcmVwbGFjZSBkZWxpbWl0ZXJzIHdpdGggc25pcHBldHNcbiAgICAgICAgaWYgKGVzY2FwZVZhbHVlKSB7XG4gICAgICAgICAgc291cmNlICs9IFwiJyArXFxuX19lKFwiICsgZXNjYXBlVmFsdWUgKyBcIikgK1xcbidcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZhbHVhdGVWYWx1ZSkge1xuICAgICAgICAgIGlzRXZhbHVhdGluZyA9IHRydWU7XG4gICAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlVmFsdWUgKyBcIjtcXG5fX3AgKz0gJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlcnBvbGF0ZVZhbHVlKSB7XG4gICAgICAgICAgc291cmNlICs9IFwiJyArXFxuKChfX3QgPSAoXCIgKyBpbnRlcnBvbGF0ZVZhbHVlICsgXCIpKSA9PSBudWxsID8gJycgOiBfX3QpICtcXG4nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAgICAgLy8gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBwcm9kdWN0cyByZXF1aXJlcyByZXR1cm5pbmcgdGhlIGBtYXRjaGBcbiAgICAgICAgLy8gc3RyaW5nIGluIG9yZGVyIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3QgYG9mZnNldGAgdmFsdWVcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfSk7XG5cbiAgICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAgIC8vIGlmIGB2YXJpYWJsZWAgaXMgbm90IHNwZWNpZmllZCwgd3JhcCBhIHdpdGgtc3RhdGVtZW50IGFyb3VuZCB0aGUgZ2VuZXJhdGVkXG4gICAgICAvLyBjb2RlIHRvIGFkZCB0aGUgZGF0YSBvYmplY3QgdG8gdGhlIHRvcCBvZiB0aGUgc2NvcGUgY2hhaW5cbiAgICAgIHZhciB2YXJpYWJsZSA9IG9wdGlvbnMudmFyaWFibGUsXG4gICAgICAgICAgaGFzVmFyaWFibGUgPSB2YXJpYWJsZTtcblxuICAgICAgaWYgKCFoYXNWYXJpYWJsZSkge1xuICAgICAgICB2YXJpYWJsZSA9ICdvYmonO1xuICAgICAgICBzb3VyY2UgPSAnd2l0aCAoJyArIHZhcmlhYmxlICsgJykge1xcbicgKyBzb3VyY2UgKyAnXFxufVxcbic7XG4gICAgICB9XG4gICAgICAvLyBjbGVhbnVwIGNvZGUgYnkgc3RyaXBwaW5nIGVtcHR5IHN0cmluZ3NcbiAgICAgIHNvdXJjZSA9IChpc0V2YWx1YXRpbmcgPyBzb3VyY2UucmVwbGFjZShyZUVtcHR5U3RyaW5nTGVhZGluZywgJycpIDogc291cmNlKVxuICAgICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nTWlkZGxlLCAnJDEnKVxuICAgICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nVHJhaWxpbmcsICckMTsnKTtcblxuICAgICAgLy8gZnJhbWUgY29kZSBhcyB0aGUgZnVuY3Rpb24gYm9keVxuICAgICAgc291cmNlID0gJ2Z1bmN0aW9uKCcgKyB2YXJpYWJsZSArICcpIHtcXG4nICtcbiAgICAgICAgKGhhc1ZhcmlhYmxlID8gJycgOiB2YXJpYWJsZSArICcgfHwgKCcgKyB2YXJpYWJsZSArICcgPSB7fSk7XFxuJykgK1xuICAgICAgICBcInZhciBfX3QsIF9fcCA9ICcnLCBfX2UgPSBfLmVzY2FwZVwiICtcbiAgICAgICAgKGlzRXZhbHVhdGluZ1xuICAgICAgICAgID8gJywgX19qID0gQXJyYXkucHJvdG90eXBlLmpvaW47XFxuJyArXG4gICAgICAgICAgICBcImZ1bmN0aW9uIHByaW50KCkgeyBfX3AgKz0gX19qLmNhbGwoYXJndW1lbnRzLCAnJykgfVxcblwiXG4gICAgICAgICAgOiAnO1xcbidcbiAgICAgICAgKSArXG4gICAgICAgIHNvdXJjZSArXG4gICAgICAgICdyZXR1cm4gX19wXFxufSc7XG5cbiAgICAgIC8vIFVzZSBhIHNvdXJjZVVSTCBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAgICAgIC8vIGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2RldmVsb3BlcnRvb2xzL3NvdXJjZW1hcHMvI3RvYy1zb3VyY2V1cmxcbiAgICAgIHZhciBzb3VyY2VVUkwgPSAnXFxuLypcXG4vLyMgc291cmNlVVJMPScgKyAob3B0aW9ucy5zb3VyY2VVUkwgfHwgJy9sb2Rhc2gvdGVtcGxhdGUvc291cmNlWycgKyAodGVtcGxhdGVDb3VudGVyKyspICsgJ10nKSArICdcXG4qLyc7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBGdW5jdGlvbihpbXBvcnRzS2V5cywgJ3JldHVybiAnICsgc291cmNlICsgc291cmNlVVJMKS5hcHBseSh1bmRlZmluZWQsIGltcG9ydHNWYWx1ZXMpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGUuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdChkYXRhKTtcbiAgICAgIH1cbiAgICAgIC8vIHByb3ZpZGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uJ3Mgc291cmNlIGJ5IGl0cyBgdG9TdHJpbmdgIG1ldGhvZCwgaW5cbiAgICAgIC8vIHN1cHBvcnRlZCBlbnZpcm9ubWVudHMsIG9yIHRoZSBgc291cmNlYCBwcm9wZXJ0eSBhcyBhIGNvbnZlbmllbmNlIGZvclxuICAgICAgLy8gaW5saW5pbmcgY29tcGlsZWQgdGVtcGxhdGVzIGR1cmluZyB0aGUgYnVpbGQgcHJvY2Vzc1xuICAgICAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGNhbGxiYWNrIGBuYCB0aW1lcywgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzXG4gICAgICogb2YgZWFjaCBjYWxsYmFjayBleGVjdXRpb24uIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWRcbiAgICAgKiB3aXRoIG9uZSBhcmd1bWVudDsgKGluZGV4KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGV4ZWN1dGUgdGhlIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBgY2FsbGJhY2tgIGV4ZWN1dGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGRpY2VSb2xscyA9IF8udGltZXMoMywgXy5wYXJ0aWFsKF8ucmFuZG9tLCAxLCA2KSk7XG4gICAgICogLy8gPT4gWzMsIDYsIDRdXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDMsIGZ1bmN0aW9uKG4pIHsgbWFnZS5jYXN0U3BlbGwobik7IH0pO1xuICAgICAqIC8vID0+IGNhbGxzIGBtYWdlLmNhc3RTcGVsbChuKWAgdGhyZWUgdGltZXMsIHBhc3NpbmcgYG5gIG9mIGAwYCwgYDFgLCBhbmQgYDJgIHJlc3BlY3RpdmVseVxuICAgICAqXG4gICAgICogXy50aW1lcygzLCBmdW5jdGlvbihuKSB7IHRoaXMuY2FzdChuKTsgfSwgbWFnZSk7XG4gICAgICogLy8gPT4gYWxzbyBjYWxscyBgbWFnZS5jYXN0U3BlbGwobilgIHRocmVlIHRpbWVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGltZXMobiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIG4gPSAobiA9ICtuKSA+IC0xID8gbiA6IDA7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICAgICAgY2FsbGJhY2sgPSBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDEpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBjYWxsYmFjayhpbmRleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnZlcnNlIG9mIGBfLmVzY2FwZWAgdGhpcyBtZXRob2QgY29udmVydHMgdGhlIEhUTUwgZW50aXRpZXNcbiAgICAgKiBgJmFtcDtgLCBgJmx0O2AsIGAmZ3Q7YCwgYCZxdW90O2AsIGFuZCBgJiMzOTtgIGluIGBzdHJpbmdgIHRvIHRoZWlyXG4gICAgICogY29ycmVzcG9uZGluZyBjaGFyYWN0ZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byB1bmVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuZXNjYXBlKCdGcmVkLCBCYXJuZXkgJmFtcDsgUGViYmxlcycpO1xuICAgICAqIC8vID0+ICdGcmVkLCBCYXJuZXkgJiBQZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuZXNjYXBlKHN0cmluZykge1xuICAgICAgcmV0dXJuIHN0cmluZyA9PSBudWxsID8gJycgOiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlRXNjYXBlZEh0bWwsIHVuZXNjYXBlSHRtbENoYXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHVuaXF1ZSBJRC4gSWYgYHByZWZpeGAgaXMgcHJvdmlkZWQgdGhlIElEIHdpbGwgYmUgYXBwZW5kZWQgdG8gaXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwcmVmaXhdIFRoZSB2YWx1ZSB0byBwcmVmaXggdGhlIElEIHdpdGguXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5pcXVlIElELlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaXF1ZUlkKCdjb250YWN0XycpO1xuICAgICAqIC8vID0+ICdjb250YWN0XzEwNCdcbiAgICAgKlxuICAgICAqIF8udW5pcXVlSWQoKTtcbiAgICAgKiAvLyA9PiAnMTA1J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXF1ZUlkKHByZWZpeCkge1xuICAgICAgdmFyIGlkID0gKytpZENvdW50ZXI7XG4gICAgICByZXR1cm4gU3RyaW5nKHByZWZpeCA9PSBudWxsID8gJycgOiBwcmVmaXgpICsgaWQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgb2JqZWN0IHRoYXQgd3JhcHMgdGhlIGdpdmVuIHZhbHVlIHdpdGggZXhwbGljaXRcbiAgICAgKiBtZXRob2QgY2hhaW5pbmcgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpbmluZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgd3JhcHBlciBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIHlvdW5nZXN0ID0gXy5jaGFpbihjaGFyYWN0ZXJzKVxuICAgICAqICAgICAuc29ydEJ5KCdhZ2UnKVxuICAgICAqICAgICAubWFwKGZ1bmN0aW9uKGNocikgeyByZXR1cm4gY2hyLm5hbWUgKyAnIGlzICcgKyBjaHIuYWdlOyB9KVxuICAgICAqICAgICAuZmlyc3QoKVxuICAgICAqICAgICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcyBpcyAxJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoYWluKHZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IG5ldyBsb2Rhc2hXcmFwcGVyKHZhbHVlKTtcbiAgICAgIHZhbHVlLl9fY2hhaW5fXyA9IHRydWU7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyBgaW50ZXJjZXB0b3JgIHdpdGggdGhlIGB2YWx1ZWAgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IGFuZCB0aGVuXG4gICAgICogcmV0dXJucyBgdmFsdWVgLiBUaGUgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0byBcInRhcCBpbnRvXCIgYSBtZXRob2RcbiAgICAgKiBjaGFpbiBpbiBvcmRlciB0byBwZXJmb3JtIG9wZXJhdGlvbnMgb24gaW50ZXJtZWRpYXRlIHJlc3VsdHMgd2l0aGluXG4gICAgICogdGhlIGNoYWluLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluaW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvdmlkZSB0byBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdG9yIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgMywgNF0pXG4gICAgICogIC50YXAoZnVuY3Rpb24oYXJyYXkpIHsgYXJyYXkucG9wKCk7IH0pXG4gICAgICogIC5yZXZlcnNlKClcbiAgICAgKiAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFwKHZhbHVlLCBpbnRlcmNlcHRvcikge1xuICAgICAgaW50ZXJjZXB0b3IodmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgZXhwbGljaXQgbWV0aG9kIGNoYWluaW5nIG9uIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBuYW1lIGNoYWluXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5pbmdcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgd3JhcHBlciBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gd2l0aG91dCBleHBsaWNpdCBjaGFpbmluZ1xuICAgICAqIF8oY2hhcmFjdGVycykuZmlyc3QoKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIGV4cGxpY2l0IGNoYWluaW5nXG4gICAgICogXyhjaGFyYWN0ZXJzKS5jaGFpbigpXG4gICAgICogICAuZmlyc3QoKVxuICAgICAqICAgLnBpY2soJ2FnZScpXG4gICAgICogICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiB7ICdhZ2UnOiAzNiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlckNoYWluKCkge1xuICAgICAgdGhpcy5fX2NoYWluX18gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgdGhlIGB0b1N0cmluZ2AgcmVzdWx0IG9mIHRoZSB3cmFwcGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQG5hbWUgdG9TdHJpbmdcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpbmluZ1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZyByZXN1bHQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKS50b1N0cmluZygpO1xuICAgICAqIC8vID0+ICcxLDIsMydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyVG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKHRoaXMuX193cmFwcGVkX18pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSB3cmFwcGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQG5hbWUgdmFsdWVPZlxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIHZhbHVlXG4gICAgICogQGNhdGVnb3J5IENoYWluaW5nXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHdyYXBwZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKS52YWx1ZU9mKCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclZhbHVlT2YoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3dyYXBwZWRfXztcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIGFkZCBmdW5jdGlvbnMgdGhhdCByZXR1cm4gd3JhcHBlZCB2YWx1ZXMgd2hlbiBjaGFpbmluZ1xuICAgIGxvZGFzaC5hZnRlciA9IGFmdGVyO1xuICAgIGxvZGFzaC5hc3NpZ24gPSBhc3NpZ247XG4gICAgbG9kYXNoLmF0ID0gYXQ7XG4gICAgbG9kYXNoLmJpbmQgPSBiaW5kO1xuICAgIGxvZGFzaC5iaW5kQWxsID0gYmluZEFsbDtcbiAgICBsb2Rhc2guYmluZEtleSA9IGJpbmRLZXk7XG4gICAgbG9kYXNoLmNoYWluID0gY2hhaW47XG4gICAgbG9kYXNoLmNvbXBhY3QgPSBjb21wYWN0O1xuICAgIGxvZGFzaC5jb21wb3NlID0gY29tcG9zZTtcbiAgICBsb2Rhc2guY29uc3RhbnQgPSBjb25zdGFudDtcbiAgICBsb2Rhc2guY291bnRCeSA9IGNvdW50Qnk7XG4gICAgbG9kYXNoLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBsb2Rhc2guY3JlYXRlQ2FsbGJhY2sgPSBjcmVhdGVDYWxsYmFjaztcbiAgICBsb2Rhc2guY3VycnkgPSBjdXJyeTtcbiAgICBsb2Rhc2guZGVib3VuY2UgPSBkZWJvdW5jZTtcbiAgICBsb2Rhc2guZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgICBsb2Rhc2guZGVmZXIgPSBkZWZlcjtcbiAgICBsb2Rhc2guZGVsYXkgPSBkZWxheTtcbiAgICBsb2Rhc2guZGlmZmVyZW5jZSA9IGRpZmZlcmVuY2U7XG4gICAgbG9kYXNoLmZpbHRlciA9IGZpbHRlcjtcbiAgICBsb2Rhc2guZmxhdHRlbiA9IGZsYXR0ZW47XG4gICAgbG9kYXNoLmZvckVhY2ggPSBmb3JFYWNoO1xuICAgIGxvZGFzaC5mb3JFYWNoUmlnaHQgPSBmb3JFYWNoUmlnaHQ7XG4gICAgbG9kYXNoLmZvckluID0gZm9ySW47XG4gICAgbG9kYXNoLmZvckluUmlnaHQgPSBmb3JJblJpZ2h0O1xuICAgIGxvZGFzaC5mb3JPd24gPSBmb3JPd247XG4gICAgbG9kYXNoLmZvck93blJpZ2h0ID0gZm9yT3duUmlnaHQ7XG4gICAgbG9kYXNoLmZ1bmN0aW9ucyA9IGZ1bmN0aW9ucztcbiAgICBsb2Rhc2guZ3JvdXBCeSA9IGdyb3VwQnk7XG4gICAgbG9kYXNoLmluZGV4QnkgPSBpbmRleEJ5O1xuICAgIGxvZGFzaC5pbml0aWFsID0gaW5pdGlhbDtcbiAgICBsb2Rhc2guaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uO1xuICAgIGxvZGFzaC5pbnZlcnQgPSBpbnZlcnQ7XG4gICAgbG9kYXNoLmludm9rZSA9IGludm9rZTtcbiAgICBsb2Rhc2gua2V5cyA9IGtleXM7XG4gICAgbG9kYXNoLm1hcCA9IG1hcDtcbiAgICBsb2Rhc2gubWFwVmFsdWVzID0gbWFwVmFsdWVzO1xuICAgIGxvZGFzaC5tYXggPSBtYXg7XG4gICAgbG9kYXNoLm1lbW9pemUgPSBtZW1vaXplO1xuICAgIGxvZGFzaC5tZXJnZSA9IG1lcmdlO1xuICAgIGxvZGFzaC5taW4gPSBtaW47XG4gICAgbG9kYXNoLm9taXQgPSBvbWl0O1xuICAgIGxvZGFzaC5vbmNlID0gb25jZTtcbiAgICBsb2Rhc2gucGFpcnMgPSBwYWlycztcbiAgICBsb2Rhc2gucGFydGlhbCA9IHBhcnRpYWw7XG4gICAgbG9kYXNoLnBhcnRpYWxSaWdodCA9IHBhcnRpYWxSaWdodDtcbiAgICBsb2Rhc2gucGljayA9IHBpY2s7XG4gICAgbG9kYXNoLnBsdWNrID0gcGx1Y2s7XG4gICAgbG9kYXNoLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgbG9kYXNoLnB1bGwgPSBwdWxsO1xuICAgIGxvZGFzaC5yYW5nZSA9IHJhbmdlO1xuICAgIGxvZGFzaC5yZWplY3QgPSByZWplY3Q7XG4gICAgbG9kYXNoLnJlbW92ZSA9IHJlbW92ZTtcbiAgICBsb2Rhc2gucmVzdCA9IHJlc3Q7XG4gICAgbG9kYXNoLnNodWZmbGUgPSBzaHVmZmxlO1xuICAgIGxvZGFzaC5zb3J0QnkgPSBzb3J0Qnk7XG4gICAgbG9kYXNoLnRhcCA9IHRhcDtcbiAgICBsb2Rhc2gudGhyb3R0bGUgPSB0aHJvdHRsZTtcbiAgICBsb2Rhc2gudGltZXMgPSB0aW1lcztcbiAgICBsb2Rhc2gudG9BcnJheSA9IHRvQXJyYXk7XG4gICAgbG9kYXNoLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICBsb2Rhc2gudW5pb24gPSB1bmlvbjtcbiAgICBsb2Rhc2gudW5pcSA9IHVuaXE7XG4gICAgbG9kYXNoLnZhbHVlcyA9IHZhbHVlcztcbiAgICBsb2Rhc2gud2hlcmUgPSB3aGVyZTtcbiAgICBsb2Rhc2gud2l0aG91dCA9IHdpdGhvdXQ7XG4gICAgbG9kYXNoLndyYXAgPSB3cmFwO1xuICAgIGxvZGFzaC54b3IgPSB4b3I7XG4gICAgbG9kYXNoLnppcCA9IHppcDtcbiAgICBsb2Rhc2guemlwT2JqZWN0ID0gemlwT2JqZWN0O1xuXG4gICAgLy8gYWRkIGFsaWFzZXNcbiAgICBsb2Rhc2guY29sbGVjdCA9IG1hcDtcbiAgICBsb2Rhc2guZHJvcCA9IHJlc3Q7XG4gICAgbG9kYXNoLmVhY2ggPSBmb3JFYWNoO1xuICAgIGxvZGFzaC5lYWNoUmlnaHQgPSBmb3JFYWNoUmlnaHQ7XG4gICAgbG9kYXNoLmV4dGVuZCA9IGFzc2lnbjtcbiAgICBsb2Rhc2gubWV0aG9kcyA9IGZ1bmN0aW9ucztcbiAgICBsb2Rhc2gub2JqZWN0ID0gemlwT2JqZWN0O1xuICAgIGxvZGFzaC5zZWxlY3QgPSBmaWx0ZXI7XG4gICAgbG9kYXNoLnRhaWwgPSByZXN0O1xuICAgIGxvZGFzaC51bmlxdWUgPSB1bmlxO1xuICAgIGxvZGFzaC51bnppcCA9IHppcDtcblxuICAgIC8vIGFkZCBmdW5jdGlvbnMgdG8gYGxvZGFzaC5wcm90b3R5cGVgXG4gICAgbWl4aW4obG9kYXNoKTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gYWRkIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB1bndyYXBwZWQgdmFsdWVzIHdoZW4gY2hhaW5pbmdcbiAgICBsb2Rhc2guY2xvbmUgPSBjbG9uZTtcbiAgICBsb2Rhc2guY2xvbmVEZWVwID0gY2xvbmVEZWVwO1xuICAgIGxvZGFzaC5jb250YWlucyA9IGNvbnRhaW5zO1xuICAgIGxvZGFzaC5lc2NhcGUgPSBlc2NhcGU7XG4gICAgbG9kYXNoLmV2ZXJ5ID0gZXZlcnk7XG4gICAgbG9kYXNoLmZpbmQgPSBmaW5kO1xuICAgIGxvZGFzaC5maW5kSW5kZXggPSBmaW5kSW5kZXg7XG4gICAgbG9kYXNoLmZpbmRLZXkgPSBmaW5kS2V5O1xuICAgIGxvZGFzaC5maW5kTGFzdCA9IGZpbmRMYXN0O1xuICAgIGxvZGFzaC5maW5kTGFzdEluZGV4ID0gZmluZExhc3RJbmRleDtcbiAgICBsb2Rhc2guZmluZExhc3RLZXkgPSBmaW5kTGFzdEtleTtcbiAgICBsb2Rhc2guaGFzID0gaGFzO1xuICAgIGxvZGFzaC5pZGVudGl0eSA9IGlkZW50aXR5O1xuICAgIGxvZGFzaC5pbmRleE9mID0gaW5kZXhPZjtcbiAgICBsb2Rhc2guaXNBcmd1bWVudHMgPSBpc0FyZ3VtZW50cztcbiAgICBsb2Rhc2guaXNBcnJheSA9IGlzQXJyYXk7XG4gICAgbG9kYXNoLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcbiAgICBsb2Rhc2guaXNEYXRlID0gaXNEYXRlO1xuICAgIGxvZGFzaC5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG4gICAgbG9kYXNoLmlzRW1wdHkgPSBpc0VtcHR5O1xuICAgIGxvZGFzaC5pc0VxdWFsID0gaXNFcXVhbDtcbiAgICBsb2Rhc2guaXNGaW5pdGUgPSBpc0Zpbml0ZTtcbiAgICBsb2Rhc2guaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG4gICAgbG9kYXNoLmlzTmFOID0gaXNOYU47XG4gICAgbG9kYXNoLmlzTnVsbCA9IGlzTnVsbDtcbiAgICBsb2Rhc2guaXNOdW1iZXIgPSBpc051bWJlcjtcbiAgICBsb2Rhc2guaXNPYmplY3QgPSBpc09iamVjdDtcbiAgICBsb2Rhc2guaXNQbGFpbk9iamVjdCA9IGlzUGxhaW5PYmplY3Q7XG4gICAgbG9kYXNoLmlzUmVnRXhwID0gaXNSZWdFeHA7XG4gICAgbG9kYXNoLmlzU3RyaW5nID0gaXNTdHJpbmc7XG4gICAgbG9kYXNoLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG4gICAgbG9kYXNoLmxhc3RJbmRleE9mID0gbGFzdEluZGV4T2Y7XG4gICAgbG9kYXNoLm1peGluID0gbWl4aW47XG4gICAgbG9kYXNoLm5vQ29uZmxpY3QgPSBub0NvbmZsaWN0O1xuICAgIGxvZGFzaC5ub29wID0gbm9vcDtcbiAgICBsb2Rhc2gubm93ID0gbm93O1xuICAgIGxvZGFzaC5wYXJzZUludCA9IHBhcnNlSW50O1xuICAgIGxvZGFzaC5yYW5kb20gPSByYW5kb207XG4gICAgbG9kYXNoLnJlZHVjZSA9IHJlZHVjZTtcbiAgICBsb2Rhc2gucmVkdWNlUmlnaHQgPSByZWR1Y2VSaWdodDtcbiAgICBsb2Rhc2gucmVzdWx0ID0gcmVzdWx0O1xuICAgIGxvZGFzaC5ydW5JbkNvbnRleHQgPSBydW5JbkNvbnRleHQ7XG4gICAgbG9kYXNoLnNpemUgPSBzaXplO1xuICAgIGxvZGFzaC5zb21lID0gc29tZTtcbiAgICBsb2Rhc2guc29ydGVkSW5kZXggPSBzb3J0ZWRJbmRleDtcbiAgICBsb2Rhc2gudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICBsb2Rhc2gudW5lc2NhcGUgPSB1bmVzY2FwZTtcbiAgICBsb2Rhc2gudW5pcXVlSWQgPSB1bmlxdWVJZDtcblxuICAgIC8vIGFkZCBhbGlhc2VzXG4gICAgbG9kYXNoLmFsbCA9IGV2ZXJ5O1xuICAgIGxvZGFzaC5hbnkgPSBzb21lO1xuICAgIGxvZGFzaC5kZXRlY3QgPSBmaW5kO1xuICAgIGxvZGFzaC5maW5kV2hlcmUgPSBmaW5kO1xuICAgIGxvZGFzaC5mb2xkbCA9IHJlZHVjZTtcbiAgICBsb2Rhc2guZm9sZHIgPSByZWR1Y2VSaWdodDtcbiAgICBsb2Rhc2guaW5jbHVkZSA9IGNvbnRhaW5zO1xuICAgIGxvZGFzaC5pbmplY3QgPSByZWR1Y2U7XG5cbiAgICBtaXhpbihmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB7fVxuICAgICAgZm9yT3duKGxvZGFzaCwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAoIWxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgICBzb3VyY2VbbWV0aG9kTmFtZV0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfSgpLCBmYWxzZSk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIGFkZCBmdW5jdGlvbnMgY2FwYWJsZSBvZiByZXR1cm5pbmcgd3JhcHBlZCBhbmQgdW53cmFwcGVkIHZhbHVlcyB3aGVuIGNoYWluaW5nXG4gICAgbG9kYXNoLmZpcnN0ID0gZmlyc3Q7XG4gICAgbG9kYXNoLmxhc3QgPSBsYXN0O1xuICAgIGxvZGFzaC5zYW1wbGUgPSBzYW1wbGU7XG5cbiAgICAvLyBhZGQgYWxpYXNlc1xuICAgIGxvZGFzaC50YWtlID0gZmlyc3Q7XG4gICAgbG9kYXNoLmhlYWQgPSBmaXJzdDtcblxuICAgIGZvck93bihsb2Rhc2gsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBjYWxsYmFja2FibGUgPSBtZXRob2ROYW1lICE9PSAnc2FtcGxlJztcbiAgICAgIGlmICghbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSkge1xuICAgICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdPSBmdW5jdGlvbihuLCBndWFyZCkge1xuICAgICAgICAgIHZhciBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fLFxuICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jKHRoaXMuX193cmFwcGVkX18sIG4sIGd1YXJkKTtcblxuICAgICAgICAgIHJldHVybiAhY2hhaW5BbGwgJiYgKG4gPT0gbnVsbCB8fCAoZ3VhcmQgJiYgIShjYWxsYmFja2FibGUgJiYgdHlwZW9mIG4gPT0gJ2Z1bmN0aW9uJykpKVxuICAgICAgICAgICAgPyByZXN1bHRcbiAgICAgICAgICAgIDogbmV3IGxvZGFzaFdyYXBwZXIocmVzdWx0LCBjaGFpbkFsbCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBzZW1hbnRpYyB2ZXJzaW9uIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAqL1xuICAgIGxvZGFzaC5WRVJTSU9OID0gJzIuNC4xJztcblxuICAgIC8vIGFkZCBcIkNoYWluaW5nXCIgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyXG4gICAgbG9kYXNoLnByb3RvdHlwZS5jaGFpbiA9IHdyYXBwZXJDaGFpbjtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnRvU3RyaW5nID0gd3JhcHBlclRvU3RyaW5nO1xuICAgIGxvZGFzaC5wcm90b3R5cGUudmFsdWUgPSB3cmFwcGVyVmFsdWVPZjtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnZhbHVlT2YgPSB3cmFwcGVyVmFsdWVPZjtcblxuICAgIC8vIGFkZCBgQXJyYXlgIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB1bndyYXBwZWQgdmFsdWVzXG4gICAgYmFzZUVhY2goWydqb2luJywgJ3BvcCcsICdzaGlmdCddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IGFycmF5UmVmW21ldGhvZE5hbWVdO1xuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXyxcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcy5fX3dyYXBwZWRfXywgYXJndW1lbnRzKTtcblxuICAgICAgICByZXR1cm4gY2hhaW5BbGxcbiAgICAgICAgICA/IG5ldyBsb2Rhc2hXcmFwcGVyKHJlc3VsdCwgY2hhaW5BbGwpXG4gICAgICAgICAgOiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gYWRkIGBBcnJheWAgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIHRoZSBleGlzdGluZyB3cmFwcGVkIHZhbHVlXG4gICAgYmFzZUVhY2goWydwdXNoJywgJ3JldmVyc2UnLCAnc29ydCcsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gYXJyYXlSZWZbbWV0aG9kTmFtZV07XG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmMuYXBwbHkodGhpcy5fX3dyYXBwZWRfXywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gYWRkIGBBcnJheWAgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIG5ldyB3cmFwcGVkIHZhbHVlc1xuICAgIGJhc2VFYWNoKFsnY29uY2F0JywgJ3NsaWNlJywgJ3NwbGljZSddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IGFycmF5UmVmW21ldGhvZE5hbWVdO1xuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IGxvZGFzaFdyYXBwZXIoZnVuYy5hcHBseSh0aGlzLl9fd3JhcHBlZF9fLCBhcmd1bWVudHMpLCB0aGlzLl9fY2hhaW5fXyk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gYXZvaWQgYXJyYXktbGlrZSBvYmplY3QgYnVncyB3aXRoIGBBcnJheSNzaGlmdGAgYW5kIGBBcnJheSNzcGxpY2VgXG4gICAgLy8gaW4gSUUgPCA5LCBGaXJlZm94IDwgMTAsIE5hcndoYWwsIGFuZCBSaW5nb0pTXG4gICAgaWYgKCFzdXBwb3J0LnNwbGljZU9iamVjdHMpIHtcbiAgICAgIGJhc2VFYWNoKFsncG9wJywgJ3NoaWZ0JywgJ3NwbGljZSddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBmdW5jID0gYXJyYXlSZWZbbWV0aG9kTmFtZV0sXG4gICAgICAgICAgICBpc1NwbGljZSA9IG1ldGhvZE5hbWUgPT0gJ3NwbGljZSc7XG5cbiAgICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fLFxuICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX18sXG4gICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodmFsdWUsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBkZWxldGUgdmFsdWVbMF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAoY2hhaW5BbGwgfHwgaXNTcGxpY2UpXG4gICAgICAgICAgICA/IG5ldyBsb2Rhc2hXcmFwcGVyKHJlc3VsdCwgY2hhaW5BbGwpXG4gICAgICAgICAgICA6IHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBsb2Rhc2g7XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvLyBleHBvc2UgTG8tRGFzaFxuICB2YXIgXyA9IHJ1bkluQ29udGV4dCgpO1xuXG4gIC8vIHNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMgbGlrZSByLmpzIGNoZWNrIGZvciBjb25kaXRpb24gcGF0dGVybnMgbGlrZSB0aGUgZm9sbG93aW5nOlxuICBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBFeHBvc2UgTG8tRGFzaCB0byB0aGUgZ2xvYmFsIG9iamVjdCBldmVuIHdoZW4gYW4gQU1EIGxvYWRlciBpcyBwcmVzZW50IGluXG4gICAgLy8gY2FzZSBMby1EYXNoIGlzIGxvYWRlZCB3aXRoIGEgUmVxdWlyZUpTIHNoaW0gY29uZmlnLlxuICAgIC8vIFNlZSBodHRwOi8vcmVxdWlyZWpzLm9yZy9kb2NzL2FwaS5odG1sI2NvbmZpZy1zaGltXG4gICAgcm9vdC5fID0gXztcblxuICAgIC8vIGRlZmluZSBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlIHNvLCB0aHJvdWdoIHBhdGggbWFwcGluZywgaXQgY2FuIGJlXG4gICAgLy8gcmVmZXJlbmNlZCBhcyB0aGUgXCJ1bmRlcnNjb3JlXCIgbW9kdWxlXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF87XG4gICAgfSk7XG4gIH1cbiAgLy8gY2hlY2sgZm9yIGBleHBvcnRzYCBhZnRlciBgZGVmaW5lYCBpbiBjYXNlIGEgYnVpbGQgb3B0aW1pemVyIGFkZHMgYW4gYGV4cG9ydHNgIG9iamVjdFxuICBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG4gICAgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTXG4gICAgaWYgKG1vZHVsZUV4cG9ydHMpIHtcbiAgICAgIChmcmVlTW9kdWxlLmV4cG9ydHMgPSBfKS5fID0gXztcbiAgICB9XG4gICAgLy8gaW4gTmFyd2hhbCBvciBSaGlubyAtcmVxdWlyZVxuICAgIGVsc2Uge1xuICAgICAgZnJlZUV4cG9ydHMuXyA9IF87XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIC8vIGluIGEgYnJvd3NlciBvciBSaGlub1xuICAgIHJvb3QuXyA9IF87XG4gIH1cbn0uY2FsbCh0aGlzKSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9sb2Rhc2gvZGlzdC9sb2Rhc2guY29tcGF0LmpzXG4gKiogbW9kdWxlIGlkID0gMlxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIiwidmFyXHJcbiAgICBob21lID0gcmVxdWlyZSgnYXBwL2hvbWUvaG9tZScpLFxyXG4gICAgZWRpdG9yID0gcmVxdWlyZSgnYXBwL2VkaXRvci9lZGl0b3InKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgXCJcIjoge1xyXG4gICAgICAgIHRlbXBsYXRlOiByZXF1aXJlKFwiYXBwL2hvbWUvaG9tZS5odG1sXCIpLFxyXG4gICAgICAgIG1vZGVsOiBob21lXHJcbiAgICB9LFxyXG4gICAgZWRpdG9yOiB7XHJcbiAgICAgICAgdGVtcGxhdGU6IHJlcXVpcmUoXCJhcHAvZWRpdG9yL2VkaXRvci5odG1sXCIpLFxyXG4gICAgICAgIG1vZGVsOiBlZGl0b3JcclxuICAgIH0sXHJcbiAgICBkb2c6IHtcclxuICAgICAgICB0ZW1wbGF0ZTogXCJob21lXCIsXHJcbiAgICAgICAgbW9kZWw6IHtcclxuICAgICAgICAgICAgdGl0bGU6IFwiVGVzdCBUaXRsZSAyXCIsXHJcbiAgICAgICAgICAgIGJvZHk6IFwiV09PT09PT09PT09PT09PT09PT09PT09Pb29vb29vb29vb29vb29vb29vb29vb29vb29vb1dXV1dXV1dXV1dXV1dXV1dvb29vb29vb29vb29vb29vXCJcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3JvdXRlcy9jb25maWcucm91dGUuanNcbiAqKiBtb2R1bGUgaWQgPSAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iLCIvKlxuICogVG9hc3RyXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE0IEpvaG4gUGFwYSBhbmQgSGFucyBGasOkbGxlbWFyay5cbiAqIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBVc2UsIHJlcHJvZHVjdGlvbiwgZGlzdHJpYnV0aW9uLCBhbmQgbW9kaWZpY2F0aW9uIG9mIHRoaXMgY29kZSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBhbmRcbiAqIGNvbmRpdGlvbnMgb2YgdGhlIE1JVCBsaWNlbnNlLCBhdmFpbGFibGUgYXQgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAqXG4gKiBBdXRob3I6IEpvaG4gUGFwYSBhbmQgSGFucyBGasOkbGxlbWFya1xuICogQVJJQSBTdXBwb3J0OiBHcmV0YSBLcmFmc2lnXG4gKiBQcm9qZWN0OiBodHRwczovL2dpdGh1Yi5jb20vQ29kZVNldmVuL3RvYXN0clxuICovXG47IChmdW5jdGlvbiAoZGVmaW5lKSB7XG4gICAgZGVmaW5lKFsnanF1ZXJ5J10sIGZ1bmN0aW9uICgkKSB7XG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyICRjb250YWluZXI7XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXI7XG4gICAgICAgICAgICB2YXIgdG9hc3RJZCA9IDA7XG4gICAgICAgICAgICB2YXIgdG9hc3RUeXBlID0ge1xuICAgICAgICAgICAgICAgIGVycm9yOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgIGluZm86ICdpbmZvJyxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiAnc3VjY2VzcycsXG4gICAgICAgICAgICAgICAgd2FybmluZzogJ3dhcm5pbmcnXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgdG9hc3RyID0ge1xuICAgICAgICAgICAgICAgIGNsZWFyOiBjbGVhcixcbiAgICAgICAgICAgICAgICByZW1vdmU6IHJlbW92ZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgZ2V0Q29udGFpbmVyOiBnZXRDb250YWluZXIsXG4gICAgICAgICAgICAgICAgaW5mbzogaW5mbyxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiB7fSxcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmU6IHN1YnNjcmliZSxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBzdWNjZXNzLFxuICAgICAgICAgICAgICAgIHZlcnNpb246ICcyLjAuMycsXG4gICAgICAgICAgICAgICAgd2FybmluZzogd2FybmluZ1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIHRvYXN0cjtcblxuICAgICAgICAgICAgLy8jcmVnaW9uIEFjY2Vzc2libGUgTWV0aG9kc1xuICAgICAgICAgICAgZnVuY3Rpb24gZXJyb3IobWVzc2FnZSwgdGl0bGUsIG9wdGlvbnNPdmVycmlkZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub3RpZnkoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0b2FzdFR5cGUuZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIGljb25DbGFzczogZ2V0T3B0aW9ucygpLmljb25DbGFzc2VzLmVycm9yLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zT3ZlcnJpZGU6IG9wdGlvbnNPdmVycmlkZSxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldENvbnRhaW5lcihvcHRpb25zLCBjcmVhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMpIHsgb3B0aW9ucyA9IGdldE9wdGlvbnMoKTsgfVxuICAgICAgICAgICAgICAgICRjb250YWluZXIgPSAkKCcjJyArIG9wdGlvbnMuY29udGFpbmVySWQpO1xuICAgICAgICAgICAgICAgIGlmICgkY29udGFpbmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJGNvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoY3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICRjb250YWluZXIgPSBjcmVhdGVDb250YWluZXIob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAkY29udGFpbmVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBpbmZvKG1lc3NhZ2UsIHRpdGxlLCBvcHRpb25zT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm90aWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdG9hc3RUeXBlLmluZm8sXG4gICAgICAgICAgICAgICAgICAgIGljb25DbGFzczogZ2V0T3B0aW9ucygpLmljb25DbGFzc2VzLmluZm8sXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNPdmVycmlkZTogb3B0aW9uc092ZXJyaWRlLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gc3Vic2NyaWJlKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIgPSBjYWxsYmFjaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gc3VjY2VzcyhtZXNzYWdlLCB0aXRsZSwgb3B0aW9uc092ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vdGlmeSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHRvYXN0VHlwZS5zdWNjZXNzLFxuICAgICAgICAgICAgICAgICAgICBpY29uQ2xhc3M6IGdldE9wdGlvbnMoKS5pY29uQ2xhc3Nlcy5zdWNjZXNzLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zT3ZlcnJpZGU6IG9wdGlvbnNPdmVycmlkZSxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHdhcm5pbmcobWVzc2FnZSwgdGl0bGUsIG9wdGlvbnNPdmVycmlkZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub3RpZnkoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0b2FzdFR5cGUud2FybmluZyxcbiAgICAgICAgICAgICAgICAgICAgaWNvbkNsYXNzOiBnZXRPcHRpb25zKCkuaWNvbkNsYXNzZXMud2FybmluZyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc092ZXJyaWRlOiBvcHRpb25zT3ZlcnJpZGUsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBjbGVhcigkdG9hc3RFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBnZXRPcHRpb25zKCk7XG4gICAgICAgICAgICAgICAgaWYgKCEkY29udGFpbmVyKSB7IGdldENvbnRhaW5lcihvcHRpb25zKTsgfVxuICAgICAgICAgICAgICAgIGlmICghY2xlYXJUb2FzdCgkdG9hc3RFbGVtZW50LCBvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckNvbnRhaW5lcihvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlbW92ZSgkdG9hc3RFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBnZXRPcHRpb25zKCk7XG4gICAgICAgICAgICAgICAgaWYgKCEkY29udGFpbmVyKSB7IGdldENvbnRhaW5lcihvcHRpb25zKTsgfVxuICAgICAgICAgICAgICAgIGlmICgkdG9hc3RFbGVtZW50ICYmICQoJzpmb2N1cycsICR0b2FzdEVsZW1lbnQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVUb2FzdCgkdG9hc3RFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoJGNvbnRhaW5lci5jaGlsZHJlbigpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAkY29udGFpbmVyLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vI2VuZHJlZ2lvblxuXG4gICAgICAgICAgICAvLyNyZWdpb24gSW50ZXJuYWwgTWV0aG9kc1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBjbGVhckNvbnRhaW5lcihvcHRpb25zKXtcbiAgICAgICAgICAgICAgICB2YXIgdG9hc3RzVG9DbGVhciA9ICRjb250YWluZXIuY2hpbGRyZW4oKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gdG9hc3RzVG9DbGVhci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRvYXN0KCQodG9hc3RzVG9DbGVhcltpXSksIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNsZWFyVG9hc3QoJHRvYXN0RWxlbWVudCwgb3B0aW9ucyl7XG4gICAgICAgICAgICAgICAgaWYgKCR0b2FzdEVsZW1lbnQgJiYgJCgnOmZvY3VzJywgJHRvYXN0RWxlbWVudCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICR0b2FzdEVsZW1lbnRbb3B0aW9ucy5oaWRlTWV0aG9kXSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5oaWRlRHVyYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBlYXNpbmc6IG9wdGlvbnMuaGlkZUVhc2luZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7IHJlbW92ZVRvYXN0KCR0b2FzdEVsZW1lbnQpOyB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVDb250YWluZXIob3B0aW9ucykge1xuICAgICAgICAgICAgICAgICRjb250YWluZXIgPSAkKCc8ZGl2Lz4nKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaWQnLCBvcHRpb25zLmNvbnRhaW5lcklkKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3Mob3B0aW9ucy5wb3NpdGlvbkNsYXNzKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignYXJpYS1saXZlJywgJ3BvbGl0ZScpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdyb2xlJywgJ2FsZXJ0Jyk7XG5cbiAgICAgICAgICAgICAgICAkY29udGFpbmVyLmFwcGVuZFRvKCQob3B0aW9ucy50YXJnZXQpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJGNvbnRhaW5lcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0RGVmYXVsdHMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdGFwVG9EaXNtaXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0b2FzdENsYXNzOiAndG9hc3QnLFxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXJJZDogJ3RvYXN0LWNvbnRhaW5lcicsXG4gICAgICAgICAgICAgICAgICAgIGRlYnVnOiBmYWxzZSxcblxuICAgICAgICAgICAgICAgICAgICBzaG93TWV0aG9kOiAnZmFkZUluJywgLy9mYWRlSW4sIHNsaWRlRG93biwgYW5kIHNob3cgYXJlIGJ1aWx0IGludG8galF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgIHNob3dEdXJhdGlvbjogMzAwLFxuICAgICAgICAgICAgICAgICAgICBzaG93RWFzaW5nOiAnc3dpbmcnLCAvL3N3aW5nIGFuZCBsaW5lYXIgYXJlIGJ1aWx0IGludG8galF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgIG9uU2hvd246IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgaGlkZU1ldGhvZDogJ2ZhZGVPdXQnLFxuICAgICAgICAgICAgICAgICAgICBoaWRlRHVyYXRpb246IDEwMDAsXG4gICAgICAgICAgICAgICAgICAgIGhpZGVFYXNpbmc6ICdzd2luZycsXG4gICAgICAgICAgICAgICAgICAgIG9uSGlkZGVuOiB1bmRlZmluZWQsXG5cbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kZWRUaW1lT3V0OiAxMDAwLFxuICAgICAgICAgICAgICAgICAgICBpY29uQ2xhc3Nlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6ICd0b2FzdC1lcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZvOiAndG9hc3QtaW5mbycsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiAndG9hc3Qtc3VjY2VzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuaW5nOiAndG9hc3Qtd2FybmluZydcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaWNvbkNsYXNzOiAndG9hc3QtaW5mbycsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uQ2xhc3M6ICd0b2FzdC10b3AtcmlnaHQnLFxuICAgICAgICAgICAgICAgICAgICB0aW1lT3V0OiA1MDAwLCAvLyBTZXQgdGltZU91dCBhbmQgZXh0ZW5kZWRUaW1lb3V0IHRvIDAgdG8gbWFrZSBpdCBzdGlja3lcbiAgICAgICAgICAgICAgICAgICAgdGl0bGVDbGFzczogJ3RvYXN0LXRpdGxlJyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUNsYXNzOiAndG9hc3QtbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogJ2JvZHknLFxuICAgICAgICAgICAgICAgICAgICBjbG9zZUh0bWw6ICc8YnV0dG9uPiZ0aW1lczs8L2J1dHRvbj4nLFxuICAgICAgICAgICAgICAgICAgICBuZXdlc3RPblRvcDogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHB1Ymxpc2goYXJncykge1xuICAgICAgICAgICAgICAgIGlmICghbGlzdGVuZXIpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIoYXJncyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG5vdGlmeShtYXApIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGdldE9wdGlvbnMoKSxcbiAgICAgICAgICAgICAgICAgICAgaWNvbkNsYXNzID0gbWFwLmljb25DbGFzcyB8fCBvcHRpb25zLmljb25DbGFzcztcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKG1hcC5vcHRpb25zT3ZlcnJpZGUpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gJC5leHRlbmQob3B0aW9ucywgbWFwLm9wdGlvbnNPdmVycmlkZSk7XG4gICAgICAgICAgICAgICAgICAgIGljb25DbGFzcyA9IG1hcC5vcHRpb25zT3ZlcnJpZGUuaWNvbkNsYXNzIHx8IGljb25DbGFzcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0b2FzdElkKys7XG5cbiAgICAgICAgICAgICAgICAkY29udGFpbmVyID0gZ2V0Q29udGFpbmVyKG9wdGlvbnMsIHRydWUpO1xuICAgICAgICAgICAgICAgIHZhciBpbnRlcnZhbElkID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgJHRvYXN0RWxlbWVudCA9ICQoJzxkaXYvPicpLFxuICAgICAgICAgICAgICAgICAgICAkdGl0bGVFbGVtZW50ID0gJCgnPGRpdi8+JyksXG4gICAgICAgICAgICAgICAgICAgICRtZXNzYWdlRWxlbWVudCA9ICQoJzxkaXYvPicpLFxuICAgICAgICAgICAgICAgICAgICAkY2xvc2VFbGVtZW50ID0gJChvcHRpb25zLmNsb3NlSHRtbCksXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9hc3RJZDogdG9hc3RJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiAndmlzaWJsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWU6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwOiBtYXBcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmIChtYXAuaWNvbkNsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICR0b2FzdEVsZW1lbnQuYWRkQ2xhc3Mob3B0aW9ucy50b2FzdENsYXNzKS5hZGRDbGFzcyhpY29uQ2xhc3MpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChtYXAudGl0bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRpdGxlRWxlbWVudC5hcHBlbmQobWFwLnRpdGxlKS5hZGRDbGFzcyhvcHRpb25zLnRpdGxlQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICAkdG9hc3RFbGVtZW50LmFwcGVuZCgkdGl0bGVFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobWFwLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgJG1lc3NhZ2VFbGVtZW50LmFwcGVuZChtYXAubWVzc2FnZSkuYWRkQ2xhc3Mob3B0aW9ucy5tZXNzYWdlQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICAkdG9hc3RFbGVtZW50LmFwcGVuZCgkbWVzc2FnZUVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmNsb3NlQnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICRjbG9zZUVsZW1lbnQuYWRkQ2xhc3MoJ3RvYXN0LWNsb3NlLWJ1dHRvbicpLmF0dHIoXCJyb2xlXCIsIFwiYnV0dG9uXCIpO1xuICAgICAgICAgICAgICAgICAgICAkdG9hc3RFbGVtZW50LnByZXBlbmQoJGNsb3NlRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgJHRvYXN0RWxlbWVudC5oaWRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubmV3ZXN0T25Ub3ApIHtcbiAgICAgICAgICAgICAgICAgICAgJGNvbnRhaW5lci5wcmVwZW5kKCR0b2FzdEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICRjb250YWluZXIuYXBwZW5kKCR0b2FzdEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgJHRvYXN0RWxlbWVudFtvcHRpb25zLnNob3dNZXRob2RdKFxuICAgICAgICAgICAgICAgICAgICB7IGR1cmF0aW9uOiBvcHRpb25zLnNob3dEdXJhdGlvbiwgZWFzaW5nOiBvcHRpb25zLnNob3dFYXNpbmcsIGNvbXBsZXRlOiBvcHRpb25zLm9uU2hvd24gfVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy50aW1lT3V0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbElkID0gc2V0VGltZW91dChoaWRlVG9hc3QsIG9wdGlvbnMudGltZU91dCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgJHRvYXN0RWxlbWVudC5ob3ZlcihzdGlja0Fyb3VuZCwgZGVsYXllZEhpZGVUb2FzdCk7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLm9uY2xpY2sgJiYgb3B0aW9ucy50YXBUb0Rpc21pc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRvYXN0RWxlbWVudC5jbGljayhoaWRlVG9hc3QpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmNsb3NlQnV0dG9uICYmICRjbG9zZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgJGNsb3NlRWxlbWVudC5jbGljayhmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCBldmVudC5zdG9wUHJvcGFnYXRpb24gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYoIGV2ZW50LmNhbmNlbEJ1YmJsZSAhPT0gdW5kZWZpbmVkICYmIGV2ZW50LmNhbmNlbEJ1YmJsZSAhPT0gdHJ1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaGlkZVRvYXN0KHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbmNsaWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICR0b2FzdEVsZW1lbnQuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbmNsaWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRlVG9hc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcHVibGlzaChyZXNwb25zZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kZWJ1ZyAmJiBjb25zb2xlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gJHRvYXN0RWxlbWVudDtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGhpZGVUb2FzdChvdmVycmlkZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoJCgnOmZvY3VzJywgJHRvYXN0RWxlbWVudCkubGVuZ3RoICYmICFvdmVycmlkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdG9hc3RFbGVtZW50W29wdGlvbnMuaGlkZU1ldGhvZF0oe1xuICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuaGlkZUR1cmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWFzaW5nOiBvcHRpb25zLmhpZGVFYXNpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZVRvYXN0KCR0b2FzdEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm9uSGlkZGVuICYmIHJlc3BvbnNlLnN0YXRlICE9PSAnaGlkZGVuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uSGlkZGVuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnN0YXRlID0gJ2hpZGRlbic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuZW5kVGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVibGlzaChyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRlbGF5ZWRIaWRlVG9hc3QoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnRpbWVPdXQgPiAwIHx8IG9wdGlvbnMuZXh0ZW5kZWRUaW1lT3V0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWxJZCA9IHNldFRpbWVvdXQoaGlkZVRvYXN0LCBvcHRpb25zLmV4dGVuZGVkVGltZU91dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzdGlja0Fyb3VuZCgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGludGVydmFsSWQpO1xuICAgICAgICAgICAgICAgICAgICAkdG9hc3RFbGVtZW50LnN0b3AodHJ1ZSwgdHJ1ZSlbb3B0aW9ucy5zaG93TWV0aG9kXShcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgZHVyYXRpb246IG9wdGlvbnMuc2hvd0R1cmF0aW9uLCBlYXNpbmc6IG9wdGlvbnMuc2hvd0Vhc2luZyB9XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRPcHRpb25zKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkLmV4dGVuZCh7fSwgZ2V0RGVmYXVsdHMoKSwgdG9hc3RyLm9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiByZW1vdmVUb2FzdCgkdG9hc3RFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKCEkY29udGFpbmVyKSB7ICRjb250YWluZXIgPSBnZXRDb250YWluZXIoKTsgfVxuICAgICAgICAgICAgICAgIGlmICgkdG9hc3RFbGVtZW50LmlzKCc6dmlzaWJsZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJHRvYXN0RWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAkdG9hc3RFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoJGNvbnRhaW5lci5jaGlsZHJlbigpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAkY29udGFpbmVyLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vI2VuZHJlZ2lvblxuXG4gICAgICAgIH0pKCk7XG4gICAgfSk7XG59KHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uIChkZXBzLCBmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7IC8vTm9kZVxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnanF1ZXJ5JykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvd1sndG9hc3RyJ10gPSBmYWN0b3J5KHdpbmRvd1snalF1ZXJ5J10pO1xuICAgIH1cbn0pKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi90b2FzdHIvdG9hc3RyLmpzXG4gKiogbW9kdWxlIGlkID0gNFxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIiwiaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSBtb2R1bGUuZXhwb3J0cyA9IExleGVyO1xuXG5MZXhlci5kZWZ1bmN0ID0gZnVuY3Rpb24gKGNoYXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCBcIiArICh0aGlzLmluZGV4IC0gMSkgKyBcIjogXCIgKyBjaGFyKTtcbn07XG5cbmZ1bmN0aW9uIExleGVyKGRlZnVuY3QpIHtcbiAgICBpZiAodHlwZW9mIGRlZnVuY3QgIT09IFwiZnVuY3Rpb25cIikgZGVmdW5jdCA9IExleGVyLmRlZnVuY3Q7XG5cbiAgICB2YXIgdG9rZW5zID0gW107XG4gICAgdmFyIHJ1bGVzID0gW107XG4gICAgdmFyIHJlbW92ZSA9IDA7XG4gICAgdGhpcy5zdGF0ZSA9IDA7XG4gICAgdGhpcy5pbmRleCA9IDA7XG4gICAgdGhpcy5pbnB1dCA9IFwiXCI7XG5cbiAgICB0aGlzLmFkZFJ1bGUgPSBmdW5jdGlvbiAocGF0dGVybiwgYWN0aW9uLCBzdGFydCkge1xuICAgICAgICB2YXIgZ2xvYmFsID0gcGF0dGVybi5nbG9iYWw7XG5cbiAgICAgICAgaWYgKCFnbG9iYWwpIHtcbiAgICAgICAgICAgIHZhciBmbGFncyA9IFwiZ1wiO1xuICAgICAgICAgICAgaWYgKHBhdHRlcm4ubXVsdGlsaW5lKSBmbGFncyArPSBcIm1cIjtcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuLmlnbm9yZUNhc2UpIGZsYWdzICs9IFwiaVwiO1xuICAgICAgICAgICAgcGF0dGVybiA9IG5ldyBSZWdFeHAocGF0dGVybi5zb3VyY2UsIGZsYWdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3RhcnQpICE9PSBcIltvYmplY3QgQXJyYXldXCIpIHN0YXJ0ID0gWzBdO1xuXG4gICAgICAgIHJ1bGVzLnB1c2goe1xuICAgICAgICAgICAgcGF0dGVybjogcGF0dGVybixcbiAgICAgICAgICAgIGdsb2JhbDogZ2xvYmFsLFxuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgICBzdGFydDogc3RhcnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHRoaXMuc2V0SW5wdXQgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgcmVtb3ZlID0gMDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDA7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLmxleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGgpIHJldHVybiB0b2tlbnMuc2hpZnQoKTtcblxuICAgICAgICB0aGlzLnJlamVjdCA9IHRydWU7XG5cbiAgICAgICAgd2hpbGUgKHRoaXMuaW5kZXggPD0gdGhpcy5pbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBtYXRjaGVzID0gc2Nhbi5jYWxsKHRoaXMpLnNwbGljZShyZW1vdmUpO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleDtcblxuICAgICAgICAgICAgd2hpbGUgKG1hdGNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IG1hdGNoZXMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG1hdGNoLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IG1hdGNoLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSBsZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZSsrO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IG1hdGNoLmFjdGlvbi5hcHBseSh0aGlzLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWplY3QpIHRoaXMuaW5kZXggPSByZXN1bHQuaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0b2tlbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiW29iamVjdCBBcnJheV1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMgPSB0b2tlbi5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2VuWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoKSByZW1vdmUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dDtcblxuICAgICAgICAgICAgaWYgKGluZGV4IDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IGRlZnVuY3QuY2FsbCh0aGlzLCBpbnB1dC5jaGFyQXQodGhpcy5pbmRleCsrKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW4gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodG9rZW4pID09PSBcIltvYmplY3QgQXJyYXldXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMgPSB0b2tlbi5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggIT09IGluZGV4KSByZW1vdmUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlamVjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaGVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdCA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHNjYW4oKSB7XG4gICAgICAgIHZhciBtYXRjaGVzID0gW107XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG5cbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgdmFyIGxhc3RJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXQ7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHJ1bGVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcnVsZSA9IHJ1bGVzW2ldO1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gcnVsZS5zdGFydDtcbiAgICAgICAgICAgIHZhciBzdGF0ZXMgPSBzdGFydC5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmICgoIXN0YXRlcyB8fCBzdGFydC5pbmRleE9mKHN0YXRlKSA+PSAwKSB8fFxuICAgICAgICAgICAgICAgIChzdGF0ZSAlIDIgJiYgc3RhdGVzID09PSAxICYmICFzdGFydFswXSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF0dGVybiA9IHJ1bGUucGF0dGVybjtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuLmxhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcGF0dGVybi5leGVjKGlucHV0KTtcblxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LmluZGV4ID09PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGogPSBtYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IHJ1bGUuYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiByZXN1bHRbMF0ubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChydWxlLmdsb2JhbCkgaW5kZXggPSBqO1xuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgtLWogPiBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGsgPSBqIC0gMTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXNbal0ubGVuZ3RoID4gbWF0Y2hlc1trXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcGxlID0gbWF0Y2hlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzW2pdID0gbWF0Y2hlc1trXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzW2tdID0gdGVtcGxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hdGNoZXM7XG4gICAgfVxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbGV4L2xleGVyLmpzXG4gKiogbW9kdWxlIGlkID0gNVxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIiwiLypcblx0cmFjdGl2ZS5qcyB2MC42LjFcblx0MjAxNC0xMC0yNSAtIGNvbW1pdCAzYTU3NmViMyBcblxuXHRodHRwOi8vcmFjdGl2ZWpzLm9yZ1xuXHRodHRwOi8vdHdpdHRlci5jb20vUmFjdGl2ZUpTXG5cblx0UmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuKi9cblxuKCBmdW5jdGlvbiggZ2xvYmFsICkge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgbm9Db25mbGljdCA9IGdsb2JhbC5SYWN0aXZlO1xuXG5cdC8qIGNvbmZpZy9kZWZhdWx0cy9vcHRpb25zLmpzICovXG5cdHZhciBvcHRpb25zID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG5cdFx0XHQvLyByZW5kZXIgcGxhY2VtZW50OlxuXHRcdFx0ZWw6IHZvaWQgMCxcblx0XHRcdGFwcGVuZDogZmFsc2UsXG5cdFx0XHQvLyB0ZW1wbGF0ZTpcblx0XHRcdHRlbXBsYXRlOiB7XG5cdFx0XHRcdHY6IDEsXG5cdFx0XHRcdHQ6IFtdXG5cdFx0XHR9LFxuXHRcdFx0eWllbGQ6IG51bGwsXG5cdFx0XHQvLyBwYXJzZTpcblx0XHRcdHByZXNlcnZlV2hpdGVzcGFjZTogZmFsc2UsXG5cdFx0XHRzYW5pdGl6ZTogZmFsc2UsXG5cdFx0XHRzdHJpcENvbW1lbnRzOiB0cnVlLFxuXHRcdFx0Ly8gZGF0YSAmIGJpbmRpbmc6XG5cdFx0XHRkYXRhOiB7fSxcblx0XHRcdGNvbXB1dGVkOiB7fSxcblx0XHRcdG1hZ2ljOiBmYWxzZSxcblx0XHRcdG1vZGlmeUFycmF5czogdHJ1ZSxcblx0XHRcdGFkYXB0OiBbXSxcblx0XHRcdGlzb2xhdGVkOiBmYWxzZSxcblx0XHRcdHR3b3dheTogdHJ1ZSxcblx0XHRcdGxhenk6IGZhbHNlLFxuXHRcdFx0Ly8gdHJhbnNpdGlvbnM6XG5cdFx0XHRub0ludHJvOiBmYWxzZSxcblx0XHRcdHRyYW5zaXRpb25zRW5hYmxlZDogdHJ1ZSxcblx0XHRcdGNvbXBsZXRlOiB2b2lkIDAsXG5cdFx0XHQvLyBjc3M6XG5cdFx0XHRub0Nzc1RyYW5zZm9ybTogZmFsc2UsXG5cdFx0XHQvLyBkZWJ1Zzpcblx0XHRcdGRlYnVnOiBmYWxzZVxuXHRcdH07XG5cdFx0cmV0dXJuIGRlZmF1bHRPcHRpb25zO1xuXHR9KCk7XG5cblx0LyogY29uZmlnL2RlZmF1bHRzL2Vhc2luZy5qcyAqL1xuXHR2YXIgZWFzaW5nID0ge1xuXHRcdGxpbmVhcjogZnVuY3Rpb24oIHBvcyApIHtcblx0XHRcdHJldHVybiBwb3M7XG5cdFx0fSxcblx0XHRlYXNlSW46IGZ1bmN0aW9uKCBwb3MgKSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5wb3coIHBvcywgMyApO1xuXHRcdH0sXG5cdFx0ZWFzZU91dDogZnVuY3Rpb24oIHBvcyApIHtcblx0XHRcdHJldHVybiBNYXRoLnBvdyggcG9zIC0gMSwgMyApICsgMTtcblx0XHR9LFxuXHRcdGVhc2VJbk91dDogZnVuY3Rpb24oIHBvcyApIHtcblx0XHRcdGlmICggKCBwb3MgLz0gMC41ICkgPCAxICkge1xuXHRcdFx0XHRyZXR1cm4gMC41ICogTWF0aC5wb3coIHBvcywgMyApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIDAuNSAqICggTWF0aC5wb3coIHBvcyAtIDIsIDMgKSArIDIgKTtcblx0XHR9XG5cdH07XG5cblx0LyogY2lyY3VsYXIuanMgKi9cblx0dmFyIGNpcmN1bGFyID0gW107XG5cblx0LyogdXRpbHMvaGFzT3duUHJvcGVydHkuanMgKi9cblx0dmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cblx0LyogdXRpbHMvaXNBcnJheS5qcyAqL1xuXHR2YXIgaXNBcnJheSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblx0XHQvLyB0aGFua3MsIGh0dHA6Ly9wZXJmZWN0aW9ua2lsbHMuY29tL2luc3RhbmNlb2YtY29uc2lkZXJlZC1oYXJtZnVsLW9yLWhvdy10by13cml0ZS1hLXJvYnVzdC1pc2FycmF5L1xuXHRcdHJldHVybiBmdW5jdGlvbiggdGhpbmcgKSB7XG5cdFx0XHRyZXR1cm4gdG9TdHJpbmcuY2FsbCggdGhpbmcgKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcblx0XHR9O1xuXHR9KCk7XG5cblx0LyogdXRpbHMvaXNPYmplY3QuanMgKi9cblx0dmFyIGlzT2JqZWN0ID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXHRcdHJldHVybiBmdW5jdGlvbiggdGhpbmcgKSB7XG5cdFx0XHRyZXR1cm4gdGhpbmcgJiYgdG9TdHJpbmcuY2FsbCggdGhpbmcgKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cdFx0fTtcblx0fSgpO1xuXG5cdC8qIHV0aWxzL2lzTnVtZXJpYy5qcyAqL1xuXHR2YXIgaXNOdW1lcmljID0gZnVuY3Rpb24oIHRoaW5nICkge1xuXHRcdHJldHVybiAhaXNOYU4oIHBhcnNlRmxvYXQoIHRoaW5nICkgKSAmJiBpc0Zpbml0ZSggdGhpbmcgKTtcblx0fTtcblxuXHQvKiBjb25maWcvZGVmYXVsdHMvaW50ZXJwb2xhdG9ycy5qcyAqL1xuXHR2YXIgaW50ZXJwb2xhdG9ycyA9IGZ1bmN0aW9uKCBjaXJjdWxhciwgaGFzT3duUHJvcGVydHksIGlzQXJyYXksIGlzT2JqZWN0LCBpc051bWVyaWMgKSB7XG5cblx0XHR2YXIgaW50ZXJwb2xhdG9ycywgaW50ZXJwb2xhdGUsIGNzc0xlbmd0aFBhdHRlcm47XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRpbnRlcnBvbGF0ZSA9IGNpcmN1bGFyLmludGVycG9sYXRlO1xuXHRcdH0gKTtcblx0XHRjc3NMZW5ndGhQYXR0ZXJuID0gL14oWystXT9bMC05XStcXC4/KD86WzAtOV0rKT8pKHB4fGVtfGV4fCV8aW58Y218bW18cHR8cGMpJC87XG5cdFx0aW50ZXJwb2xhdG9ycyA9IHtcblx0XHRcdG51bWJlcjogZnVuY3Rpb24oIGZyb20sIHRvICkge1xuXHRcdFx0XHR2YXIgZGVsdGE7XG5cdFx0XHRcdGlmICggIWlzTnVtZXJpYyggZnJvbSApIHx8ICFpc051bWVyaWMoIHRvICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZnJvbSA9ICtmcm9tO1xuXHRcdFx0XHR0byA9ICt0bztcblx0XHRcdFx0ZGVsdGEgPSB0byAtIGZyb207XG5cdFx0XHRcdGlmICggIWRlbHRhICkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBmcm9tO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB0ICkge1xuXHRcdFx0XHRcdHJldHVybiBmcm9tICsgdCAqIGRlbHRhO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblx0XHRcdGFycmF5OiBmdW5jdGlvbiggZnJvbSwgdG8gKSB7XG5cdFx0XHRcdHZhciBpbnRlcm1lZGlhdGUsIGludGVycG9sYXRvcnMsIGxlbiwgaTtcblx0XHRcdFx0aWYgKCAhaXNBcnJheSggZnJvbSApIHx8ICFpc0FycmF5KCB0byApICkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGludGVybWVkaWF0ZSA9IFtdO1xuXHRcdFx0XHRpbnRlcnBvbGF0b3JzID0gW107XG5cdFx0XHRcdGkgPSBsZW4gPSBNYXRoLm1pbiggZnJvbS5sZW5ndGgsIHRvLmxlbmd0aCApO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpbnRlcnBvbGF0b3JzWyBpIF0gPSBpbnRlcnBvbGF0ZSggZnJvbVsgaSBdLCB0b1sgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gc3VycGx1cyB2YWx1ZXMgLSBkb24ndCBpbnRlcnBvbGF0ZSwgYnV0IGRvbid0IGV4Y2x1ZGUgdGhlbSBlaXRoZXJcblx0XHRcdFx0Zm9yICggaSA9IGxlbjsgaSA8IGZyb20ubGVuZ3RoOyBpICs9IDEgKSB7XG5cdFx0XHRcdFx0aW50ZXJtZWRpYXRlWyBpIF0gPSBmcm9tWyBpIF07XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yICggaSA9IGxlbjsgaSA8IHRvLmxlbmd0aDsgaSArPSAxICkge1xuXHRcdFx0XHRcdGludGVybWVkaWF0ZVsgaSBdID0gdG9bIGkgXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHQgKSB7XG5cdFx0XHRcdFx0dmFyIGkgPSBsZW47XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpbnRlcm1lZGlhdGVbIGkgXSA9IGludGVycG9sYXRvcnNbIGkgXSggdCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gaW50ZXJtZWRpYXRlO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblx0XHRcdG9iamVjdDogZnVuY3Rpb24oIGZyb20sIHRvICkge1xuXHRcdFx0XHR2YXIgcHJvcGVydGllcywgbGVuLCBpbnRlcnBvbGF0b3JzLCBpbnRlcm1lZGlhdGUsIHByb3A7XG5cdFx0XHRcdGlmICggIWlzT2JqZWN0KCBmcm9tICkgfHwgIWlzT2JqZWN0KCB0byApICkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHByb3BlcnRpZXMgPSBbXTtcblx0XHRcdFx0aW50ZXJtZWRpYXRlID0ge307XG5cdFx0XHRcdGludGVycG9sYXRvcnMgPSB7fTtcblx0XHRcdFx0Zm9yICggcHJvcCBpbiBmcm9tICkge1xuXHRcdFx0XHRcdGlmICggaGFzT3duUHJvcGVydHkuY2FsbCggZnJvbSwgcHJvcCApICkge1xuXHRcdFx0XHRcdFx0aWYgKCBoYXNPd25Qcm9wZXJ0eS5jYWxsKCB0bywgcHJvcCApICkge1xuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0aWVzLnB1c2goIHByb3AgKTtcblx0XHRcdFx0XHRcdFx0aW50ZXJwb2xhdG9yc1sgcHJvcCBdID0gaW50ZXJwb2xhdGUoIGZyb21bIHByb3AgXSwgdG9bIHByb3AgXSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0aW50ZXJtZWRpYXRlWyBwcm9wIF0gPSBmcm9tWyBwcm9wIF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAoIHByb3AgaW4gdG8gKSB7XG5cdFx0XHRcdFx0aWYgKCBoYXNPd25Qcm9wZXJ0eS5jYWxsKCB0bywgcHJvcCApICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKCBmcm9tLCBwcm9wICkgKSB7XG5cdFx0XHRcdFx0XHRpbnRlcm1lZGlhdGVbIHByb3AgXSA9IHRvWyBwcm9wIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGxlbiA9IHByb3BlcnRpZXMubGVuZ3RoO1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHQgKSB7XG5cdFx0XHRcdFx0dmFyIGkgPSBsZW4sXG5cdFx0XHRcdFx0XHRwcm9wO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0cHJvcCA9IHByb3BlcnRpZXNbIGkgXTtcblx0XHRcdFx0XHRcdGludGVybWVkaWF0ZVsgcHJvcCBdID0gaW50ZXJwb2xhdG9yc1sgcHJvcCBdKCB0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBpbnRlcm1lZGlhdGU7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gaW50ZXJwb2xhdG9ycztcblx0fSggY2lyY3VsYXIsIGhhc093biwgaXNBcnJheSwgaXNPYmplY3QsIGlzTnVtZXJpYyApO1xuXG5cdC8qIGNvbmZpZy9zdmcuanMgKi9cblx0dmFyIHN2ZyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHN2Zztcblx0XHRpZiAoIHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRzdmcgPSBmYWxzZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3ZnID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSggJ2h0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ZlYXR1cmUjQmFzaWNTdHJ1Y3R1cmUnLCAnMS4xJyApO1xuXHRcdH1cblx0XHRyZXR1cm4gc3ZnO1xuXHR9KCk7XG5cblx0LyogdXRpbHMvd2Fybi5qcyAqL1xuXHR2YXIgd2FybiA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0LyogZ2xvYmFsIGNvbnNvbGUgKi9cblx0XHR2YXIgd2Fybiwgd2FybmVkID0ge307XG5cdFx0aWYgKCB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUud2FybiA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY29uc29sZS53YXJuLmFwcGx5ID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0d2FybiA9IGZ1bmN0aW9uKCBtZXNzYWdlLCBhbGxvd0R1cGxpY2F0ZXMgKSB7XG5cdFx0XHRcdGlmICggIWFsbG93RHVwbGljYXRlcyApIHtcblx0XHRcdFx0XHRpZiAoIHdhcm5lZFsgbWVzc2FnZSBdICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3YXJuZWRbIG1lc3NhZ2UgXSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnJWNSYWN0aXZlLmpzOiAlYycgKyBtZXNzYWdlLCAnY29sb3I6IHJnYigxMTQsIDE1NywgNTIpOycsICdjb2xvcjogcmdiKDg1LCA4NSwgODUpOycgKTtcblx0XHRcdH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdhcm4gPSBmdW5jdGlvbigpIHt9O1xuXHRcdH1cblx0XHRyZXR1cm4gd2Fybjtcblx0fSgpO1xuXG5cdC8qIGNvbmZpZy9lcnJvcnMuanMgKi9cblx0dmFyIGVycm9ycyA9IHtcblx0XHRtaXNzaW5nUGFyc2VyOiAnTWlzc2luZyBSYWN0aXZlLnBhcnNlIC0gY2Fubm90IHBhcnNlIHRlbXBsYXRlLiBFaXRoZXIgcHJlcGFyc2Ugb3IgdXNlIHRoZSB2ZXJzaW9uIHRoYXQgaW5jbHVkZXMgdGhlIHBhcnNlcicsXG5cdFx0bWVyZ2VDb21wYXJpc29uRmFpbDogJ01lcmdlIG9wZXJhdGlvbjogY29tcGFyaXNvbiBmYWlsZWQuIEZhbGxpbmcgYmFjayB0byBpZGVudGl0eSBjaGVja2luZycsXG5cdFx0bm9Db21wb25lbnRFdmVudEFyZ3VtZW50czogJ0NvbXBvbmVudHMgY3VycmVudGx5IG9ubHkgc3VwcG9ydCBzaW1wbGUgZXZlbnRzIC0geW91IGNhbm5vdCBpbmNsdWRlIGFyZ3VtZW50cy4gU29ycnkhJyxcblx0XHRub1RlbXBsYXRlRm9yUGFydGlhbDogJ0NvdWxkIG5vdCBmaW5kIHRlbXBsYXRlIGZvciBwYXJ0aWFsIFwie25hbWV9XCInLFxuXHRcdG5vTmVzdGVkUGFydGlhbHM6ICdQYXJ0aWFscyAoe3s+e25hbWV9fX0pIGNhbm5vdCBjb250YWluIG5lc3RlZCBpbmxpbmUgcGFydGlhbHMnLFxuXHRcdGV2YWx1YXRpb25FcnJvcjogJ0Vycm9yIGV2YWx1YXRpbmcgXCJ7dW5pcXVlU3RyaW5nfVwiOiB7ZXJyfScsXG5cdFx0YmFkQXJndW1lbnRzOiAnQmFkIGFyZ3VtZW50cyBcInthcmd1bWVudHN9XCIuIElcXCdtIG5vdCBhbGxvd2VkIHRvIGFyZ3VlIHVubGVzcyB5b3VcXCd2ZSBwYWlkLicsXG5cdFx0ZmFpbGVkQ29tcHV0YXRpb246ICdGYWlsZWQgdG8gY29tcHV0ZSBcIntrZXl9XCI6IHtlcnJ9Jyxcblx0XHRtaXNzaW5nUGx1Z2luOiAnTWlzc2luZyBcIntuYW1lfVwiIHtwbHVnaW59IHBsdWdpbi4gWW91IG1heSBuZWVkIHRvIGRvd25sb2FkIGEge3BsdWdpbn0gdmlhIGh0dHA6Ly9kb2NzLnJhY3RpdmVqcy5vcmcvbGF0ZXN0L3BsdWdpbnMje3BsdWdpbn1zJyxcblx0XHRiYWRSYWRpb0lucHV0QmluZGluZzogJ0EgcmFkaW8gaW5wdXQgY2FuIGhhdmUgdHdvLXdheSBiaW5kaW5nIG9uIGl0cyBuYW1lIGF0dHJpYnV0ZSwgb3IgaXRzIGNoZWNrZWQgYXR0cmlidXRlIC0gbm90IGJvdGgnLFxuXHRcdG5vUmVnaXN0cnlGdW5jdGlvblJldHVybjogJ0EgZnVuY3Rpb24gd2FzIHNwZWNpZmllZCBmb3IgXCJ7bmFtZX1cIiB7cmVnaXN0cnl9LCBidXQgbm8ge3JlZ2lzdHJ5fSB3YXMgcmV0dXJuZWQnLFxuXHRcdGRlZmF1bHRFbFNwZWNpZmllZDogJ1RoZSA8e25hbWV9Lz4gY29tcG9uZW50IGhhcyBhIGRlZmF1bHQgYGVsYCBwcm9wZXJ0eTsgaXQgaGFzIGJlZW4gZGlzcmVnYXJkZWQnLFxuXHRcdG5vRWxlbWVudFByb3h5RXZlbnRXaWxkY2FyZHM6ICdPbmx5IGNvbXBvbmVudCBwcm94eS1ldmVudHMgbWF5IGNvbnRhaW4gXCIqXCIgd2lsZGNhcmRzLCA8e2VsZW1lbnR9IG9uLXtldmVudH0vPiBpcyBub3QgdmFsaWQuJyxcblx0XHRtZXRob2REZXByZWNhdGVkOiAnVGhlIG1ldGhvZCBcIntkZXByZWNhdGVkfVwiIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgXCJ7cmVwbGFjZW1lbnR9XCIgYW5kIHdpbGwgbGlrZWx5IGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS4gU2VlIGh0dHA6Ly9kb2NzLnJhY3RpdmVqcy5vcmcvbGF0ZXN0L21pZ3JhdGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nXG5cdH07XG5cblx0LyogdXRpbHMvbG9nLmpzICovXG5cdHZhciBsb2cgPSBmdW5jdGlvbiggY29uc29sZXdhcm4sIGVycm9ycyApIHtcblxuXHRcdHZhciBsb2cgPSB7XG5cdFx0XHR3YXJuOiBmdW5jdGlvbiggb3B0aW9ucywgcGFzc3RocnUgKSB7XG5cdFx0XHRcdGlmICggIW9wdGlvbnMuZGVidWcgJiYgIXBhc3N0aHJ1ICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLndhcm5BbHdheXMoIG9wdGlvbnMgKTtcblx0XHRcdH0sXG5cdFx0XHR3YXJuQWx3YXlzOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdFx0dGhpcy5sb2dnZXIoIGdldE1lc3NhZ2UoIG9wdGlvbnMgKSwgb3B0aW9ucy5hbGxvd0R1cGxpY2F0ZXMgKTtcblx0XHRcdH0sXG5cdFx0XHRlcnJvcjogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHRoaXMuZXJyb3JPbmx5KCBvcHRpb25zICk7XG5cdFx0XHRcdGlmICggIW9wdGlvbnMuZGVidWcgKSB7XG5cdFx0XHRcdFx0dGhpcy53YXJuKCBvcHRpb25zLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRlcnJvck9ubHk6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0XHRpZiAoIG9wdGlvbnMuZGVidWcgKSB7XG5cdFx0XHRcdFx0dGhpcy5jcml0aWNhbCggb3B0aW9ucyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0Y3JpdGljYWw6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0XHR2YXIgZXJyID0gb3B0aW9ucy5lcnIgfHwgbmV3IEVycm9yKCBnZXRNZXNzYWdlKCBvcHRpb25zICkgKTtcblx0XHRcdFx0dGhpcy50aHJvd2VyKCBlcnIgKTtcblx0XHRcdH0sXG5cdFx0XHRsb2dnZXI6IGNvbnNvbGV3YXJuLFxuXHRcdFx0dGhyb3dlcjogZnVuY3Rpb24oIGVyciApIHtcblx0XHRcdFx0dGhyb3cgZXJyO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBnZXRNZXNzYWdlKCBvcHRpb25zICkge1xuXHRcdFx0dmFyIG1lc3NhZ2UgPSBlcnJvcnNbIG9wdGlvbnMubWVzc2FnZSBdIHx8IG9wdGlvbnMubWVzc2FnZSB8fCAnJztcblx0XHRcdHJldHVybiBpbnRlcnBvbGF0ZSggbWVzc2FnZSwgb3B0aW9ucy5hcmdzICk7XG5cdFx0fVxuXHRcdC8vIHNpbXBsZSBpbnRlcnBvbGF0aW9uLiBwcm9iYWJseSBxdWlja2VyIChhbmQgYmV0dGVyKSBvdXQgdGhlcmUsXG5cdFx0Ly8gYnV0IGxvZyBpcyBub3QgaW4gZ29sZGVuIHBhdGggb2YgZXhlY3V0aW9uLCBvbmx5IGV4Y2VwdGlvbnNcblx0XHRmdW5jdGlvbiBpbnRlcnBvbGF0ZSggbWVzc2FnZSwgYXJncyApIHtcblx0XHRcdHJldHVybiBtZXNzYWdlLnJlcGxhY2UoIC97KFtee31dKil9L2csIGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0XHRyZXR1cm4gYXJnc1sgYiBdO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbG9nO1xuXHR9KCB3YXJuLCBlcnJvcnMgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvaG9va3MvSG9vay5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzaGFyZWRfaG9va3NfSG9vayA9IGZ1bmN0aW9uKCBsb2cgKSB7XG5cblx0XHR2YXIgZGVwcmVjYXRpb25zID0ge1xuXHRcdFx0Y29uc3RydWN0OiB7XG5cdFx0XHRcdGRlcHJlY2F0ZWQ6ICdiZWZvcmVJbml0Jyxcblx0XHRcdFx0cmVwbGFjZW1lbnQ6ICdvbmNvbnN0cnVjdCdcblx0XHRcdH0sXG5cdFx0XHRyZW5kZXI6IHtcblx0XHRcdFx0ZGVwcmVjYXRlZDogJ2luaXQnLFxuXHRcdFx0XHRtZXNzYWdlOiAnVGhlIFwiaW5pdFwiIG1ldGhvZCBoYXMgYmVlbiBkZXByZWNhdGVkICcgKyAnYW5kIHdpbGwgbGlrZWx5IGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS4gJyArICdZb3UgY2FuIGVpdGhlciB1c2UgdGhlIFwib25pbml0XCIgbWV0aG9kIHdoaWNoIHdpbGwgZmlyZSAnICsgJ29ubHkgb25jZSBwcmlvciB0bywgYW5kIHJlZ2FyZGxlc3Mgb2YsIGFueSBldmVudHVhbCByYWN0aXZlICcgKyAnaW5zdGFuY2UgYmVpbmcgcmVuZGVyZWQsIG9yIGlmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgJyArICdyZW5kZXJlZCBET00sIHVzZSBcIm9ucmVuZGVyXCIgaW5zdGVhZC4gJyArICdTZWUgaHR0cDovL2RvY3MucmFjdGl2ZWpzLm9yZy9sYXRlc3QvbWlncmF0aW5nIGZvciBtb3JlIGluZm9ybWF0aW9uLidcblx0XHRcdH0sXG5cdFx0XHRjb21wbGV0ZToge1xuXHRcdFx0XHRkZXByZWNhdGVkOiAnY29tcGxldGUnLFxuXHRcdFx0XHRyZXBsYWNlbWVudDogJ29uY29tcGxldGUnXG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIEhvb2soIGV2ZW50ICkge1xuXHRcdFx0dGhpcy5ldmVudCA9IGV2ZW50O1xuXHRcdFx0dGhpcy5tZXRob2QgPSAnb24nICsgZXZlbnQ7XG5cdFx0XHR0aGlzLmRlcHJlY2F0ZSA9IGRlcHJlY2F0aW9uc1sgZXZlbnQgXTtcblx0XHR9XG5cdFx0SG9vay5wcm90b3R5cGUuZmlyZSA9IGZ1bmN0aW9uKCByYWN0aXZlLCBhcmcgKSB7XG5cdFx0XHRmdW5jdGlvbiBjYWxsKCBtZXRob2QgKSB7XG5cdFx0XHRcdGlmICggcmFjdGl2ZVsgbWV0aG9kIF0gKSB7XG5cdFx0XHRcdFx0YXJnID8gcmFjdGl2ZVsgbWV0aG9kIF0oIGFyZyApIDogcmFjdGl2ZVsgbWV0aG9kIF0oKTtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y2FsbCggdGhpcy5tZXRob2QgKTtcblx0XHRcdGlmICggIXJhY3RpdmVbIHRoaXMubWV0aG9kIF0gJiYgdGhpcy5kZXByZWNhdGUgJiYgY2FsbCggdGhpcy5kZXByZWNhdGUuZGVwcmVjYXRlZCApICkge1xuXHRcdFx0XHRsb2cud2FybkFsd2F5cygge1xuXHRcdFx0XHRcdGRlYnVnOiByYWN0aXZlLmRlYnVnLFxuXHRcdFx0XHRcdG1lc3NhZ2U6IHRoaXMuZGVwcmVjYXRlLm1lc3NhZ2UgfHwgJ21ldGhvZERlcHJlY2F0ZWQnLFxuXHRcdFx0XHRcdGFyZ3M6IHRoaXMuZGVwcmVjYXRlXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdGFyZyA/IHJhY3RpdmUuZmlyZSggdGhpcy5ldmVudCwgYXJnICkgOiByYWN0aXZlLmZpcmUoIHRoaXMuZXZlbnQgKTtcblx0XHR9O1xuXHRcdHJldHVybiBIb29rO1xuXHR9KCBsb2cgKTtcblxuXHQvKiB1dGlscy9yZW1vdmVGcm9tQXJyYXkuanMgKi9cblx0dmFyIHJlbW92ZUZyb21BcnJheSA9IGZ1bmN0aW9uKCBhcnJheSwgbWVtYmVyICkge1xuXHRcdHZhciBpbmRleCA9IGFycmF5LmluZGV4T2YoIG1lbWJlciApO1xuXHRcdGlmICggaW5kZXggIT09IC0xICkge1xuXHRcdFx0YXJyYXkuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiB1dGlscy9Qcm9taXNlLmpzICovXG5cdHZhciBQcm9taXNlID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIF9Qcm9taXNlLCBQRU5ESU5HID0ge30sXG5cdFx0XHRGVUxGSUxMRUQgPSB7fSxcblx0XHRcdFJFSkVDVEVEID0ge307XG5cdFx0aWYgKCB0eXBlb2YgUHJvbWlzZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdC8vIHVzZSBuYXRpdmUgUHJvbWlzZVxuXHRcdFx0X1Byb21pc2UgPSBQcm9taXNlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRfUHJvbWlzZSA9IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRcdFx0dmFyIGZ1bGZpbGxlZEhhbmRsZXJzID0gW10sXG5cdFx0XHRcdFx0cmVqZWN0ZWRIYW5kbGVycyA9IFtdLFxuXHRcdFx0XHRcdHN0YXRlID0gUEVORElORyxcblx0XHRcdFx0XHRyZXN1bHQsIGRpc3BhdGNoSGFuZGxlcnMsIG1ha2VSZXNvbHZlciwgZnVsZmlsLCByZWplY3QsIHByb21pc2U7XG5cdFx0XHRcdG1ha2VSZXNvbHZlciA9IGZ1bmN0aW9uKCBuZXdTdGF0ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdFx0aWYgKCBzdGF0ZSAhPT0gUEVORElORyApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmVzdWx0ID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRzdGF0ZSA9IG5ld1N0YXRlO1xuXHRcdFx0XHRcdFx0ZGlzcGF0Y2hIYW5kbGVycyA9IG1ha2VEaXNwYXRjaGVyKCBzdGF0ZSA9PT0gRlVMRklMTEVEID8gZnVsZmlsbGVkSGFuZGxlcnMgOiByZWplY3RlZEhhbmRsZXJzLCByZXN1bHQgKTtcblx0XHRcdFx0XHRcdC8vIGRpc3BhdGNoIG9uRnVsZmlsbGVkIGFuZCBvblJlamVjdGVkIGhhbmRsZXJzIGFzeW5jaHJvbm91c2x5XG5cdFx0XHRcdFx0XHR3YWl0KCBkaXNwYXRjaEhhbmRsZXJzICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblx0XHRcdFx0ZnVsZmlsID0gbWFrZVJlc29sdmVyKCBGVUxGSUxMRUQgKTtcblx0XHRcdFx0cmVqZWN0ID0gbWFrZVJlc29sdmVyKCBSRUpFQ1RFRCApO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCBmdWxmaWwsIHJlamVjdCApO1xuXHRcdFx0XHR9IGNhdGNoICggZXJyICkge1xuXHRcdFx0XHRcdHJlamVjdCggZXJyICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cHJvbWlzZSA9IHtcblx0XHRcdFx0XHQvLyBgdGhlbigpYCByZXR1cm5zIGEgUHJvbWlzZSAtIDIuMi43XG5cdFx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkICkge1xuXHRcdFx0XHRcdFx0dmFyIHByb21pc2UyID0gbmV3IF9Qcm9taXNlKCBmdW5jdGlvbiggZnVsZmlsLCByZWplY3QgKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBwcm9jZXNzUmVzb2x1dGlvbkhhbmRsZXIgPSBmdW5jdGlvbiggaGFuZGxlciwgaGFuZGxlcnMsIGZvcndhcmQgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gMi4yLjEuMVxuXHRcdFx0XHRcdFx0XHRcdGlmICggdHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRoYW5kbGVycy5wdXNoKCBmdW5jdGlvbiggcDFyZXN1bHQgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZhciB4O1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHggPSBoYW5kbGVyKCBwMXJlc3VsdCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIHByb21pc2UyLCB4LCBmdWxmaWwsIHJlamVjdCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoICggZXJyICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlamVjdCggZXJyICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gRm9yd2FyZCB0aGUgcmVzdWx0IG9mIHByb21pc2UxIHRvIHByb21pc2UyLCBpZiByZXNvbHV0aW9uIGhhbmRsZXJzXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBhcmUgbm90IGdpdmVuXG5cdFx0XHRcdFx0XHRcdFx0XHRoYW5kbGVycy5wdXNoKCBmb3J3YXJkICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHQvLyAyLjJcblx0XHRcdFx0XHRcdFx0cHJvY2Vzc1Jlc29sdXRpb25IYW5kbGVyKCBvbkZ1bGZpbGxlZCwgZnVsZmlsbGVkSGFuZGxlcnMsIGZ1bGZpbCApO1xuXHRcdFx0XHRcdFx0XHRwcm9jZXNzUmVzb2x1dGlvbkhhbmRsZXIoIG9uUmVqZWN0ZWQsIHJlamVjdGVkSGFuZGxlcnMsIHJlamVjdCApO1xuXHRcdFx0XHRcdFx0XHRpZiAoIHN0YXRlICE9PSBQRU5ESU5HICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIElmIHRoZSBwcm9taXNlIGhhcyByZXNvbHZlZCBhbHJlYWR5LCBkaXNwYXRjaCB0aGUgYXBwcm9wcmlhdGUgaGFuZGxlcnMgYXN5bmNocm9ub3VzbHlcblx0XHRcdFx0XHRcdFx0XHR3YWl0KCBkaXNwYXRjaEhhbmRsZXJzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdHJldHVybiBwcm9taXNlMjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHRcdHByb21pc2VbICdjYXRjaCcgXSA9IGZ1bmN0aW9uKCBvblJlamVjdGVkICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLnRoZW4oIG51bGwsIG9uUmVqZWN0ZWQgKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0XHR9O1xuXHRcdFx0X1Byb21pc2UuYWxsID0gZnVuY3Rpb24oIHByb21pc2VzICkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IF9Qcm9taXNlKCBmdW5jdGlvbiggZnVsZmlsLCByZWplY3QgKSB7XG5cdFx0XHRcdFx0dmFyIHJlc3VsdCA9IFtdLFxuXHRcdFx0XHRcdFx0cGVuZGluZywgaSwgcHJvY2Vzc1Byb21pc2U7XG5cdFx0XHRcdFx0aWYgKCAhcHJvbWlzZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0ZnVsZmlsKCByZXN1bHQgKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHJvY2Vzc1Byb21pc2UgPSBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRcdHByb21pc2VzWyBpIF0udGhlbiggZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRbIGkgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHRpZiAoICEtLXBlbmRpbmcgKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZnVsZmlsKCByZXN1bHQgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSwgcmVqZWN0ICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRwZW5kaW5nID0gaSA9IHByb21pc2VzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdHByb2Nlc3NQcm9taXNlKCBpICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9O1xuXHRcdFx0X1Byb21pc2UucmVzb2x2ZSA9IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBfUHJvbWlzZSggZnVuY3Rpb24oIGZ1bGZpbCApIHtcblx0XHRcdFx0XHRmdWxmaWwoIHZhbHVlICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH07XG5cdFx0XHRfUHJvbWlzZS5yZWplY3QgPSBmdW5jdGlvbiggcmVhc29uICkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IF9Qcm9taXNlKCBmdW5jdGlvbiggZnVsZmlsLCByZWplY3QgKSB7XG5cdFx0XHRcdFx0cmVqZWN0KCByZWFzb24gKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0X19leHBvcnQgPSBfUHJvbWlzZTtcblx0XHQvLyBUT0RPIHVzZSBNdXRhdGlvbk9ic2VydmVycyBvciBzb21ldGhpbmcgdG8gc2ltdWxhdGUgc2V0SW1tZWRpYXRlXG5cdFx0ZnVuY3Rpb24gd2FpdCggY2FsbGJhY2sgKSB7XG5cdFx0XHRzZXRUaW1lb3V0KCBjYWxsYmFjaywgMCApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG1ha2VEaXNwYXRjaGVyKCBoYW5kbGVycywgcmVzdWx0ICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgaGFuZGxlcjtcblx0XHRcdFx0d2hpbGUgKCBoYW5kbGVyID0gaGFuZGxlcnMuc2hpZnQoKSApIHtcblx0XHRcdFx0XHRoYW5kbGVyKCByZXN1bHQgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZXNvbHZlKCBwcm9taXNlLCB4LCBmdWxmaWwsIHJlamVjdCApIHtcblx0XHRcdC8vIFByb21pc2UgUmVzb2x1dGlvbiBQcm9jZWR1cmVcblx0XHRcdHZhciB0aGVuO1xuXHRcdFx0Ly8gMi4zLjFcblx0XHRcdGlmICggeCA9PT0gcHJvbWlzZSApIHtcblx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ0EgcHJvbWlzZVxcJ3MgZnVsZmlsbG1lbnQgaGFuZGxlciBjYW5ub3QgcmV0dXJuIHRoZSBzYW1lIHByb21pc2UnICk7XG5cdFx0XHR9XG5cdFx0XHQvLyAyLjMuMlxuXHRcdFx0aWYgKCB4IGluc3RhbmNlb2YgX1Byb21pc2UgKSB7XG5cdFx0XHRcdHgudGhlbiggZnVsZmlsLCByZWplY3QgKTtcblx0XHRcdH0gZWxzZSBpZiAoIHggJiYgKCB0eXBlb2YgeCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHggPT09ICdmdW5jdGlvbicgKSApIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR0aGVuID0geC50aGVuO1xuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRyZWplY3QoIGUgKTtcblx0XHRcdFx0XHQvLyAyLjMuMy4yXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIDIuMy4zLjNcblx0XHRcdFx0aWYgKCB0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0XHR2YXIgY2FsbGVkLCByZXNvbHZlUHJvbWlzZSwgcmVqZWN0UHJvbWlzZTtcblx0XHRcdFx0XHRyZXNvbHZlUHJvbWlzZSA9IGZ1bmN0aW9uKCB5ICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjYWxsZWQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNhbGxlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKCBwcm9taXNlLCB5LCBmdWxmaWwsIHJlamVjdCApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0cmVqZWN0UHJvbWlzZSA9IGZ1bmN0aW9uKCByICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjYWxsZWQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNhbGxlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRyZWplY3QoIHIgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHR0aGVuLmNhbGwoIHgsIHJlc29sdmVQcm9taXNlLCByZWplY3RQcm9taXNlICk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFjYWxsZWQgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIDIuMy4zLjMuNC4xXG5cdFx0XHRcdFx0XHRcdHJlamVjdCggZSApO1xuXHRcdFx0XHRcdFx0XHQvLyAyLjMuMy4zLjQuMlxuXHRcdFx0XHRcdFx0XHRjYWxsZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZ1bGZpbCggeCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmdWxmaWwoIHggKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCk7XG5cblx0LyogdXRpbHMvbm9ybWFsaXNlUmVmLmpzICovXG5cdHZhciBub3JtYWxpc2VSZWYgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciByZWdleCA9IC9cXFtcXHMqKFxcKnxbMC05XXxbMS05XVswLTldKylcXHMqXFxdL2c7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIG5vcm1hbGlzZVJlZiggcmVmICkge1xuXHRcdFx0cmV0dXJuICggcmVmIHx8ICcnICkucmVwbGFjZSggcmVnZXgsICcuJDEnICk7XG5cdFx0fTtcblx0fSgpO1xuXG5cdC8qIHNoYXJlZC9nZXRJbm5lckNvbnRleHQuanMgKi9cblx0dmFyIGdldElubmVyQ29udGV4dCA9IGZ1bmN0aW9uKCBmcmFnbWVudCApIHtcblx0XHRkbyB7XG5cdFx0XHRpZiAoIGZyYWdtZW50LmNvbnRleHQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIGZyYWdtZW50LmNvbnRleHQ7XG5cdFx0XHR9XG5cdFx0fSB3aGlsZSAoIGZyYWdtZW50ID0gZnJhZ21lbnQucGFyZW50ICk7XG5cdFx0cmV0dXJuICcnO1xuXHR9O1xuXG5cdC8qIHV0aWxzL2lzRXF1YWwuanMgKi9cblx0dmFyIGlzRXF1YWwgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRpZiAoIGEgPT09IG51bGwgJiYgYiA9PT0gbnVsbCApIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiBhID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgYiA9PT0gJ29iamVjdCcgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiBhID09PSBiO1xuXHR9O1xuXG5cdC8qIHNoYXJlZC9jcmVhdGVDb21wb25lbnRCaW5kaW5nLmpzICovXG5cdHZhciBjcmVhdGVDb21wb25lbnRCaW5kaW5nID0gZnVuY3Rpb24oIGNpcmN1bGFyLCBpc0VxdWFsICkge1xuXG5cdFx0dmFyIHJ1bmxvb3A7XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcnVubG9vcCA9IGNpcmN1bGFyLnJ1bmxvb3A7XG5cdFx0fSApO1xuXHRcdHZhciBCaW5kaW5nID0gZnVuY3Rpb24oIHJhY3RpdmUsIGtleXBhdGgsIG90aGVySW5zdGFuY2UsIG90aGVyS2V5cGF0aCApIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dGhpcy5yb290ID0gcmFjdGl2ZTtcblx0XHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG5cdFx0XHR0aGlzLm90aGVySW5zdGFuY2UgPSBvdGhlckluc3RhbmNlO1xuXHRcdFx0dGhpcy5vdGhlcktleXBhdGggPSBvdGhlcktleXBhdGg7XG5cdFx0XHR0aGlzLmxvY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMkMC51cGRhdGluZyA9IHRydWU7XG5cdFx0XHR9O1xuXHRcdFx0dGhpcy51bmxvY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMkMC51cGRhdGluZyA9IGZhbHNlO1xuXHRcdFx0fTtcblx0XHRcdHRoaXMuYmluZCgpO1xuXHRcdFx0dGhpcy52YWx1ZSA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KCB0aGlzLmtleXBhdGggKTtcblx0XHR9O1xuXHRcdEJpbmRpbmcucHJvdG90eXBlID0ge1xuXHRcdFx0aXNMb2NrZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy51cGRhdGluZyB8fCB0aGlzLmNvdW50ZXJwYXJ0ICYmIHRoaXMuY291bnRlcnBhcnQudXBkYXRpbmc7XG5cdFx0XHR9LFxuXHRcdFx0c2h1ZmZsZTogZnVuY3Rpb24oIG5ld0luZGljZXMsIHZhbHVlICkge1xuXHRcdFx0XHR0aGlzLnByb3BhZ2F0ZUNoYW5nZSggdmFsdWUsIG5ld0luZGljZXMgKTtcblx0XHRcdH0sXG5cdFx0XHRzZXRWYWx1ZTogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHR0aGlzLnByb3BhZ2F0ZUNoYW5nZSggdmFsdWUgKTtcblx0XHRcdH0sXG5cdFx0XHRwcm9wYWdhdGVDaGFuZ2U6IGZ1bmN0aW9uKCB2YWx1ZSwgbmV3SW5kaWNlcyApIHtcblx0XHRcdFx0dmFyIG90aGVyO1xuXHRcdFx0XHQvLyBPbmx5ICp5b3UqIGNhbiBwcmV2ZW50IGluZmluaXRlIGxvb3BzXG5cdFx0XHRcdGlmICggdGhpcy5pc0xvY2tlZCgpICkge1xuXHRcdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhaXNFcXVhbCggdmFsdWUsIHRoaXMudmFsdWUgKSApIHtcblx0XHRcdFx0XHR0aGlzLmxvY2soKTtcblx0XHRcdFx0XHQvLyBUT0RPIG1heWJlIHRoZSBjYXNlIHRoYXQgYHZhbHVlID09PSB0aGlzLnZhbHVlYCAtIHNob3VsZCB0aGF0IHJlc3VsdFxuXHRcdFx0XHRcdC8vIGluIGFuIHVwZGF0ZSByYXRoZXIgdGhhbiBhIHNldD9cblx0XHRcdFx0XHQvLyBpZiB0aGUgb3RoZXIgdmlld21vZGVsIGlzIGFscmVhZHkgbG9ja2VkIHVwLCBuZWVkIHRvIGRvIGEgZGVmZXJyZWQgdXBkYXRlXG5cdFx0XHRcdFx0aWYgKCAhcnVubG9vcC5hZGRWaWV3bW9kZWwoIG90aGVyID0gdGhpcy5vdGhlckluc3RhbmNlLnZpZXdtb2RlbCApICYmIHRoaXMuY291bnRlcnBhcnQudmFsdWUgIT09IHZhbHVlICkge1xuXHRcdFx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcnVubG9vcC5hZGRWaWV3bW9kZWwoIG90aGVyICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggbmV3SW5kaWNlcyApIHtcblx0XHRcdFx0XHRcdG90aGVyLnNtYXJ0VXBkYXRlKCB0aGlzLm90aGVyS2V5cGF0aCwgdmFsdWUsIG5ld0luZGljZXMgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKCBpc1NldHRhYmxlKCBvdGhlciwgdGhpcy5vdGhlcktleXBhdGggKSApIHtcblx0XHRcdFx0XHRcdFx0b3RoZXIuc2V0KCB0aGlzLm90aGVyS2V5cGF0aCwgdmFsdWUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRcdC8vIFRPRE8gd2lsbCB0aGUgY291bnRlcnBhcnQgdXBkYXRlIGFmdGVyIHRoaXMgbGluZSwgZHVyaW5nXG5cdFx0XHRcdFx0Ly8gdGhlIHJ1bmxvb3AgZW5kIGN5Y2xlPyBtYXkgYmUgYSBwcm9ibGVtLi4uXG5cdFx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIHRoaXMudW5sb2NrICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRyZWZpbmVWYWx1ZTogZnVuY3Rpb24oIGtleXBhdGhzICkge1xuXHRcdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdFx0dmFyIG90aGVyO1xuXHRcdFx0XHRpZiAoIHRoaXMuaXNMb2NrZWQoKSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5sb2NrKCk7XG5cdFx0XHRcdHJ1bmxvb3AuYWRkVmlld21vZGVsKCBvdGhlciA9IHRoaXMub3RoZXJJbnN0YW5jZS52aWV3bW9kZWwgKTtcblx0XHRcdFx0a2V5cGF0aHMubWFwKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcyQwLm90aGVyS2V5cGF0aCArIGtleXBhdGguc3Vic3RyKCB0aGlzJDAua2V5cGF0aC5sZW5ndGggKTtcblx0XHRcdFx0fSApLmZvckVhY2goIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdHJldHVybiBvdGhlci5tYXJrKCBrZXlwYXRoICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIHRoaXMudW5sb2NrICk7XG5cdFx0XHR9LFxuXHRcdFx0YmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwucmVnaXN0ZXIoIHRoaXMua2V5cGF0aCwgdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdHJlYmluZDogZnVuY3Rpb24oIG5ld0tleXBhdGggKSB7XG5cdFx0XHRcdHRoaXMudW5iaW5kKCk7XG5cdFx0XHRcdHRoaXMua2V5cGF0aCA9IG5ld0tleXBhdGg7XG5cdFx0XHRcdHRoaXMuY291bnRlcnBhcnQub3RoZXJLZXlwYXRoID0gbmV3S2V5cGF0aDtcblx0XHRcdFx0dGhpcy5iaW5kKCk7XG5cdFx0XHR9LFxuXHRcdFx0dW5iaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC51bnJlZ2lzdGVyKCB0aGlzLmtleXBhdGgsIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gaXNTZXR0YWJsZSggdmlld21vZGVsLCBrZXlwYXRoICkge1xuXHRcdFx0dmFyIGNvbXB1dGVkID0gdmlld21vZGVsLmNvbXB1dGF0aW9uc1sga2V5cGF0aCBdO1xuXHRcdFx0cmV0dXJuICFjb21wdXRlZCB8fCBjb21wdXRlZC5zZXR0ZXI7XG5cdFx0fVxuXHRcdHJldHVybiBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnRCaW5kaW5nKCBjb21wb25lbnQsIHBhcmVudEluc3RhbmNlLCBwYXJlbnRLZXlwYXRoLCBjaGlsZEtleXBhdGggKSB7XG5cdFx0XHR2YXIgaGFzaCwgY2hpbGRJbnN0YW5jZSwgYmluZGluZ3MsIHBhcmVudFRvQ2hpbGRCaW5kaW5nLCBjaGlsZFRvUGFyZW50QmluZGluZztcblx0XHRcdGhhc2ggPSBwYXJlbnRLZXlwYXRoICsgJz0nICsgY2hpbGRLZXlwYXRoO1xuXHRcdFx0YmluZGluZ3MgPSBjb21wb25lbnQuYmluZGluZ3M7XG5cdFx0XHRpZiAoIGJpbmRpbmdzWyBoYXNoIF0gKSB7XG5cdFx0XHRcdC8vIFRPRE8gZG9lcyB0aGlzIGV2ZXIgaGFwcGVuP1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRjaGlsZEluc3RhbmNlID0gY29tcG9uZW50Lmluc3RhbmNlO1xuXHRcdFx0cGFyZW50VG9DaGlsZEJpbmRpbmcgPSBuZXcgQmluZGluZyggcGFyZW50SW5zdGFuY2UsIHBhcmVudEtleXBhdGgsIGNoaWxkSW5zdGFuY2UsIGNoaWxkS2V5cGF0aCApO1xuXHRcdFx0YmluZGluZ3MucHVzaCggcGFyZW50VG9DaGlsZEJpbmRpbmcgKTtcblx0XHRcdGlmICggY2hpbGRJbnN0YW5jZS50d293YXkgKSB7XG5cdFx0XHRcdGNoaWxkVG9QYXJlbnRCaW5kaW5nID0gbmV3IEJpbmRpbmcoIGNoaWxkSW5zdGFuY2UsIGNoaWxkS2V5cGF0aCwgcGFyZW50SW5zdGFuY2UsIHBhcmVudEtleXBhdGggKTtcblx0XHRcdFx0YmluZGluZ3MucHVzaCggY2hpbGRUb1BhcmVudEJpbmRpbmcgKTtcblx0XHRcdFx0cGFyZW50VG9DaGlsZEJpbmRpbmcuY291bnRlcnBhcnQgPSBjaGlsZFRvUGFyZW50QmluZGluZztcblx0XHRcdFx0Y2hpbGRUb1BhcmVudEJpbmRpbmcuY291bnRlcnBhcnQgPSBwYXJlbnRUb0NoaWxkQmluZGluZztcblx0XHRcdH1cblx0XHRcdGJpbmRpbmdzWyBoYXNoIF0gPSBwYXJlbnRUb0NoaWxkQmluZGluZztcblx0XHR9O1xuXHR9KCBjaXJjdWxhciwgaXNFcXVhbCApO1xuXG5cdC8qIHNoYXJlZC9yZXNvbHZlUmVmLmpzICovXG5cdHZhciByZXNvbHZlUmVmID0gZnVuY3Rpb24oIG5vcm1hbGlzZVJlZiwgZ2V0SW5uZXJDb250ZXh0LCBjcmVhdGVDb21wb25lbnRCaW5kaW5nICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBhbmNlc3RvckVycm9yTWVzc2FnZSwgZ2V0T3B0aW9ucztcblx0XHRhbmNlc3RvckVycm9yTWVzc2FnZSA9ICdDb3VsZCBub3QgcmVzb2x2ZSByZWZlcmVuY2UgLSB0b28gbWFueSBcIi4uL1wiIHByZWZpeGVzJztcblx0XHRnZXRPcHRpb25zID0ge1xuXHRcdFx0ZXZhbHVhdGVXcmFwcGVkOiB0cnVlXG5cdFx0fTtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIHJlc29sdmVSZWYoIHJhY3RpdmUsIHJlZiwgZnJhZ21lbnQsIGlzUGFyZW50TG9va3VwICkge1xuXHRcdFx0dmFyIGNvbnRleHQsIGtleSwgaW5kZXgsIGtleXBhdGgsIHBhcmVudFZhbHVlLCBoYXNDb250ZXh0Q2hhaW4sIHBhcmVudEtleXMsIGNoaWxkS2V5cywgcGFyZW50S2V5cGF0aCwgY2hpbGRLZXlwYXRoO1xuXHRcdFx0cmVmID0gbm9ybWFsaXNlUmVmKCByZWYgKTtcblx0XHRcdC8vIElmIGEgcmVmZXJlbmNlIGJlZ2lucyAnfi8nLCBpdCdzIGEgdG9wLWxldmVsIHJlZmVyZW5jZVxuXHRcdFx0aWYgKCByZWYuc3Vic3RyKCAwLCAyICkgPT09ICd+LycgKSB7XG5cdFx0XHRcdHJldHVybiByZWYuc3Vic3RyaW5nKCAyICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBJZiBhIHJlZmVyZW5jZSBiZWdpbnMgd2l0aCAnLicsIGl0J3MgZWl0aGVyIGEgcmVzdHJpY3RlZCByZWZlcmVuY2Ugb3Jcblx0XHRcdC8vIGFuIGFuY2VzdG9yIHJlZmVyZW5jZS4uLlxuXHRcdFx0aWYgKCByZWYuY2hhckF0KCAwICkgPT09ICcuJyApIHtcblx0XHRcdFx0cmV0dXJuIHJlc29sdmVBbmNlc3RvclJlZmVyZW5jZSggZ2V0SW5uZXJDb250ZXh0KCBmcmFnbWVudCApLCByZWYgKTtcblx0XHRcdH1cblx0XHRcdC8vIC4uLm90aGVyd2lzZSB3ZSBuZWVkIHRvIGZpbmQgdGhlIGtleXBhdGhcblx0XHRcdGtleSA9IHJlZi5zcGxpdCggJy4nIClbIDAgXTtcblx0XHRcdC8vIGdldCgpIGluIHZpZXdtb2RlbCBjcmVhdGlvbiBtZWFucyBubyBmcmFnbWVudCAoeWV0KVxuXHRcdFx0ZnJhZ21lbnQgPSBmcmFnbWVudCB8fCB7fTtcblx0XHRcdGRvIHtcblx0XHRcdFx0Y29udGV4dCA9IGZyYWdtZW50LmNvbnRleHQ7XG5cdFx0XHRcdGlmICggIWNvbnRleHQgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aGFzQ29udGV4dENoYWluID0gdHJ1ZTtcblx0XHRcdFx0cGFyZW50VmFsdWUgPSByYWN0aXZlLnZpZXdtb2RlbC5nZXQoIGNvbnRleHQsIGdldE9wdGlvbnMgKTtcblx0XHRcdFx0aWYgKCBwYXJlbnRWYWx1ZSAmJiAoIHR5cGVvZiBwYXJlbnRWYWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHBhcmVudFZhbHVlID09PSAnZnVuY3Rpb24nICkgJiYga2V5IGluIHBhcmVudFZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiBjb250ZXh0ICsgJy4nICsgcmVmO1xuXHRcdFx0XHR9XG5cdFx0XHR9IHdoaWxlICggZnJhZ21lbnQgPSBmcmFnbWVudC5wYXJlbnQgKTtcblx0XHRcdC8vIFJvb3QvY29tcHV0ZWQgcHJvcGVydHk/XG5cdFx0XHRpZiAoIGtleSBpbiByYWN0aXZlLmRhdGEgfHwga2V5IGluIHJhY3RpdmUudmlld21vZGVsLmNvbXB1dGF0aW9ucyApIHtcblx0XHRcdFx0cmV0dXJuIHJlZjtcblx0XHRcdH1cblx0XHRcdC8vIElmIHRoaXMgaXMgYW4gaW5saW5lIGNvbXBvbmVudCwgYW5kIGl0J3Mgbm90IGlzb2xhdGVkLCB3ZVxuXHRcdFx0Ly8gY2FuIHRyeSBnb2luZyB1cCB0aGUgc2NvcGUgY2hhaW5cblx0XHRcdGlmICggcmFjdGl2ZS5fcGFyZW50ICYmICFyYWN0aXZlLmlzb2xhdGVkICkge1xuXHRcdFx0XHRoYXNDb250ZXh0Q2hhaW4gPSB0cnVlO1xuXHRcdFx0XHRmcmFnbWVudCA9IHJhY3RpdmUuY29tcG9uZW50LnBhcmVudEZyYWdtZW50O1xuXHRcdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSBpbmRleCByZWZzXG5cdFx0XHRcdGlmICggZnJhZ21lbnQuaW5kZXhSZWZzICYmICggaW5kZXggPSBmcmFnbWVudC5pbmRleFJlZnNbIHJlZiBdICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHQvLyBDcmVhdGUgYW4gaW5kZXggcmVmIGJpbmRpbmcsIHNvIHRoYXQgaXQgY2FuIGJlIHJlYm91bmQgbGV0dGVyIGlmIG5lY2Vzc2FyeS5cblx0XHRcdFx0XHQvLyBJdCBkb2Vzbid0IGhhdmUgYW4gYWxpYXMgc2luY2UgaXQncyBhbiBpbXBsaWNpdCBiaW5kaW5nLCBoZW5jZSBgLi4uWyByZWYgXSA9IHJlZmBcblx0XHRcdFx0XHRyYWN0aXZlLmNvbXBvbmVudC5pbmRleFJlZkJpbmRpbmdzWyByZWYgXSA9IHJlZjtcblx0XHRcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5zZXQoIHJlZiwgaW5kZXgsIHRydWUgKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0a2V5cGF0aCA9IHJlc29sdmVSZWYoIHJhY3RpdmUuX3BhcmVudCwgcmVmLCBmcmFnbWVudCwgdHJ1ZSApO1xuXHRcdFx0XHRpZiAoIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0Ly8gV2UgbmVlZCB0byBjcmVhdGUgYW4gaW50ZXItY29tcG9uZW50IGJpbmRpbmdcblx0XHRcdFx0XHQvLyBJZiBwYXJlbnQga2V5cGF0aCBpcyAnb25lLmZvbycgYW5kIGNoaWxkIGlzICd0d28uZm9vJywgd2UgYmluZFxuXHRcdFx0XHRcdC8vICdvbmUnIHRvICd0d28nIGFzIGl0J3MgbW9yZSBlZmZpY2llbnQgYW5kIGF2b2lkcyBlZGdlIGNhc2VzXG5cdFx0XHRcdFx0cGFyZW50S2V5cyA9IGtleXBhdGguc3BsaXQoICcuJyApO1xuXHRcdFx0XHRcdGNoaWxkS2V5cyA9IHJlZi5zcGxpdCggJy4nICk7XG5cdFx0XHRcdFx0d2hpbGUgKCBwYXJlbnRLZXlzLmxlbmd0aCA+IDEgJiYgY2hpbGRLZXlzLmxlbmd0aCA+IDEgJiYgcGFyZW50S2V5c1sgcGFyZW50S2V5cy5sZW5ndGggLSAxIF0gPT09IGNoaWxkS2V5c1sgY2hpbGRLZXlzLmxlbmd0aCAtIDEgXSApIHtcblx0XHRcdFx0XHRcdHBhcmVudEtleXMucG9wKCk7XG5cdFx0XHRcdFx0XHRjaGlsZEtleXMucG9wKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBhcmVudEtleXBhdGggPSBwYXJlbnRLZXlzLmpvaW4oICcuJyApO1xuXHRcdFx0XHRcdGNoaWxkS2V5cGF0aCA9IGNoaWxkS2V5cy5qb2luKCAnLicgKTtcblx0XHRcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5zZXQoIGNoaWxkS2V5cGF0aCwgcmFjdGl2ZS5fcGFyZW50LnZpZXdtb2RlbC5nZXQoIHBhcmVudEtleXBhdGggKSwgdHJ1ZSApO1xuXHRcdFx0XHRcdGNyZWF0ZUNvbXBvbmVudEJpbmRpbmcoIHJhY3RpdmUuY29tcG9uZW50LCByYWN0aXZlLl9wYXJlbnQsIHBhcmVudEtleXBhdGgsIGNoaWxkS2V5cGF0aCApO1xuXHRcdFx0XHRcdHJldHVybiByZWY7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIElmIHRoZXJlJ3Mgbm8gY29udGV4dCBjaGFpbiwgYW5kIHRoZSBpbnN0YW5jZSBpcyBlaXRoZXIgYSkgaXNvbGF0ZWQgb3Jcblx0XHRcdC8vIGIpIGFuIG9ycGhhbiwgdGhlbiB3ZSBrbm93IHRoYXQgdGhlIGtleXBhdGggaXMgaWRlbnRpY2FsIHRvIHRoZSByZWZlcmVuY2Vcblx0XHRcdGlmICggIWlzUGFyZW50TG9va3VwICYmICFoYXNDb250ZXh0Q2hhaW4gKSB7XG5cdFx0XHRcdC8vIHRoZSBkYXRhIG9iamVjdCBuZWVkcyB0byBoYXZlIGEgcHJvcGVydHkgYnkgdGhpcyBuYW1lLFxuXHRcdFx0XHQvLyB0byBwcmV2ZW50IGZ1dHVyZSBmYWlsZWQgbG9va3Vwc1xuXHRcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5zZXQoIHJlZiwgdW5kZWZpbmVkICk7XG5cdFx0XHRcdHJldHVybiByZWY7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHJhY3RpdmUudmlld21vZGVsLmdldCggcmVmICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJlZjtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcmVzb2x2ZUFuY2VzdG9yUmVmZXJlbmNlKCBiYXNlQ29udGV4dCwgcmVmICkge1xuXHRcdFx0dmFyIGNvbnRleHRLZXlzO1xuXHRcdFx0Ly8ge3sufX0gbWVhbnMgJ2N1cnJlbnQgY29udGV4dCdcblx0XHRcdGlmICggcmVmID09PSAnLicgKVxuXHRcdFx0XHRyZXR1cm4gYmFzZUNvbnRleHQ7XG5cdFx0XHRjb250ZXh0S2V5cyA9IGJhc2VDb250ZXh0ID8gYmFzZUNvbnRleHQuc3BsaXQoICcuJyApIDogW107XG5cdFx0XHQvLyBhbmNlc3RvciByZWZlcmVuY2VzIChzdGFydGluZyBcIi4uL1wiKSBnbyB1cCB0aGUgdHJlZVxuXHRcdFx0aWYgKCByZWYuc3Vic3RyKCAwLCAzICkgPT09ICcuLi8nICkge1xuXHRcdFx0XHR3aGlsZSAoIHJlZi5zdWJzdHIoIDAsIDMgKSA9PT0gJy4uLycgKSB7XG5cdFx0XHRcdFx0aWYgKCAhY29udGV4dEtleXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBhbmNlc3RvckVycm9yTWVzc2FnZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb250ZXh0S2V5cy5wb3AoKTtcblx0XHRcdFx0XHRyZWYgPSByZWYuc3Vic3RyaW5nKCAzICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGV4dEtleXMucHVzaCggcmVmICk7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0S2V5cy5qb2luKCAnLicgKTtcblx0XHRcdH1cblx0XHRcdC8vIG5vdCBhbiBhbmNlc3RvciByZWZlcmVuY2UgLSBtdXN0IGJlIGEgcmVzdHJpY3RlZCByZWZlcmVuY2UgKHByZXBlbmRlZCB3aXRoIFwiLlwiIG9yIFwiLi9cIilcblx0XHRcdGlmICggIWJhc2VDb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVmLnJlcGxhY2UoIC9eXFwuXFwvPy8sICcnICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYmFzZUNvbnRleHQgKyByZWYucmVwbGFjZSggL15cXC5cXC8vLCAnLicgKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBub3JtYWxpc2VSZWYsIGdldElubmVyQ29udGV4dCwgY3JlYXRlQ29tcG9uZW50QmluZGluZyApO1xuXG5cdC8qIGdsb2JhbC9UcmFuc2l0aW9uTWFuYWdlci5qcyAqL1xuXHR2YXIgVHJhbnNpdGlvbk1hbmFnZXIgPSBmdW5jdGlvbiggcmVtb3ZlRnJvbUFycmF5ICkge1xuXG5cdFx0dmFyIFRyYW5zaXRpb25NYW5hZ2VyID0gZnVuY3Rpb24oIGNhbGxiYWNrLCBwYXJlbnQgKSB7XG5cdFx0XHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0XHR0aGlzLnBhcmVudCA9IHBhcmVudDtcblx0XHRcdHRoaXMuaW50cm9zID0gW107XG5cdFx0XHR0aGlzLm91dHJvcyA9IFtdO1xuXHRcdFx0dGhpcy5jaGlsZHJlbiA9IFtdO1xuXHRcdFx0dGhpcy50b3RhbENoaWxkcmVuID0gdGhpcy5vdXRyb0NoaWxkcmVuID0gMDtcblx0XHRcdHRoaXMuZGV0YWNoUXVldWUgPSBbXTtcblx0XHRcdHRoaXMub3V0cm9zQ29tcGxldGUgPSBmYWxzZTtcblx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRwYXJlbnQuYWRkQ2hpbGQoIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdFRyYW5zaXRpb25NYW5hZ2VyLnByb3RvdHlwZSA9IHtcblx0XHRcdGFkZENoaWxkOiBmdW5jdGlvbiggY2hpbGQgKSB7XG5cdFx0XHRcdHRoaXMuY2hpbGRyZW4ucHVzaCggY2hpbGQgKTtcblx0XHRcdFx0dGhpcy50b3RhbENoaWxkcmVuICs9IDE7XG5cdFx0XHRcdHRoaXMub3V0cm9DaGlsZHJlbiArPSAxO1xuXHRcdFx0fSxcblx0XHRcdGRlY3JlbWVudE91dHJvczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMub3V0cm9DaGlsZHJlbiAtPSAxO1xuXHRcdFx0XHRjaGVjayggdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdGRlY3JlbWVudFRvdGFsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy50b3RhbENoaWxkcmVuIC09IDE7XG5cdFx0XHRcdGNoZWNrKCB0aGlzICk7XG5cdFx0XHR9LFxuXHRcdFx0YWRkOiBmdW5jdGlvbiggdHJhbnNpdGlvbiApIHtcblx0XHRcdFx0dmFyIGxpc3QgPSB0cmFuc2l0aW9uLmlzSW50cm8gPyB0aGlzLmludHJvcyA6IHRoaXMub3V0cm9zO1xuXHRcdFx0XHRsaXN0LnB1c2goIHRyYW5zaXRpb24gKTtcblx0XHRcdH0sXG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCB0cmFuc2l0aW9uICkge1xuXHRcdFx0XHR2YXIgbGlzdCA9IHRyYW5zaXRpb24uaXNJbnRybyA/IHRoaXMuaW50cm9zIDogdGhpcy5vdXRyb3M7XG5cdFx0XHRcdHJlbW92ZUZyb21BcnJheSggbGlzdCwgdHJhbnNpdGlvbiApO1xuXHRcdFx0XHRjaGVjayggdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdGluaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnJlYWR5ID0gdHJ1ZTtcblx0XHRcdFx0Y2hlY2soIHRoaXMgKTtcblx0XHRcdH0sXG5cdFx0XHRkZXRhY2hOb2RlczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuZGV0YWNoUXVldWUuZm9yRWFjaCggZGV0YWNoICk7XG5cdFx0XHRcdHRoaXMuY2hpbGRyZW4uZm9yRWFjaCggZGV0YWNoTm9kZXMgKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZGV0YWNoKCBlbGVtZW50ICkge1xuXHRcdFx0ZWxlbWVudC5kZXRhY2goKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBkZXRhY2hOb2RlcyggdG0gKSB7XG5cdFx0XHR0bS5kZXRhY2hOb2RlcygpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNoZWNrKCB0bSApIHtcblx0XHRcdGlmICggIXRtLnJlYWR5IHx8IHRtLm91dHJvcy5sZW5ndGggfHwgdG0ub3V0cm9DaGlsZHJlbiApXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdC8vIElmIGFsbCBvdXRyb3MgYXJlIGNvbXBsZXRlLCBhbmQgd2UgaGF2ZW4ndCBhbHJlYWR5IGRvbmUgdGhpcyxcblx0XHRcdC8vIHdlIG5vdGlmeSB0aGUgcGFyZW50IGlmIHRoZXJlIGlzIG9uZSwgb3RoZXJ3aXNlXG5cdFx0XHQvLyBzdGFydCBkZXRhY2hpbmcgbm9kZXNcblx0XHRcdGlmICggIXRtLm91dHJvc0NvbXBsZXRlICkge1xuXHRcdFx0XHRpZiAoIHRtLnBhcmVudCApIHtcblx0XHRcdFx0XHR0bS5wYXJlbnQuZGVjcmVtZW50T3V0cm9zKCB0bSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRtLmRldGFjaE5vZGVzKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dG0ub3V0cm9zQ29tcGxldGUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gT25jZSBldmVyeXRoaW5nIGlzIGRvbmUsIHdlIGNhbiBub3RpZnkgcGFyZW50IHRyYW5zaXRpb25cblx0XHRcdC8vIG1hbmFnZXIgYW5kIGNhbGwgdGhlIGNhbGxiYWNrXG5cdFx0XHRpZiAoICF0bS5pbnRyb3MubGVuZ3RoICYmICF0bS50b3RhbENoaWxkcmVuICkge1xuXHRcdFx0XHRpZiAoIHR5cGVvZiB0bS5jYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0XHR0bS5jYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggdG0ucGFyZW50ICkge1xuXHRcdFx0XHRcdHRtLnBhcmVudC5kZWNyZW1lbnRUb3RhbCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBUcmFuc2l0aW9uTWFuYWdlcjtcblx0fSggcmVtb3ZlRnJvbUFycmF5ICk7XG5cblx0LyogZ2xvYmFsL3J1bmxvb3AuanMgKi9cblx0dmFyIHJ1bmxvb3AgPSBmdW5jdGlvbiggY2lyY3VsYXIsIEhvb2ssIHJlbW92ZUZyb21BcnJheSwgUHJvbWlzZSwgcmVzb2x2ZVJlZiwgVHJhbnNpdGlvbk1hbmFnZXIgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIGJhdGNoLCBydW5sb29wLCB1bnJlc29sdmVkID0gW10sXG5cdFx0XHRjaGFuZ2VIb29rID0gbmV3IEhvb2soICdjaGFuZ2UnICk7XG5cdFx0cnVubG9vcCA9IHtcblx0XHRcdHN0YXJ0OiBmdW5jdGlvbiggaW5zdGFuY2UsIHJldHVyblByb21pc2UgKSB7XG5cdFx0XHRcdHZhciBwcm9taXNlLCBmdWxmaWxQcm9taXNlO1xuXHRcdFx0XHRpZiAoIHJldHVyblByb21pc2UgKSB7XG5cdFx0XHRcdFx0cHJvbWlzZSA9IG5ldyBQcm9taXNlKCBmdW5jdGlvbiggZiApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmdWxmaWxQcm9taXNlID0gZjtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YmF0Y2ggPSB7XG5cdFx0XHRcdFx0cHJldmlvdXNCYXRjaDogYmF0Y2gsXG5cdFx0XHRcdFx0dHJhbnNpdGlvbk1hbmFnZXI6IG5ldyBUcmFuc2l0aW9uTWFuYWdlciggZnVsZmlsUHJvbWlzZSwgYmF0Y2ggJiYgYmF0Y2gudHJhbnNpdGlvbk1hbmFnZXIgKSxcblx0XHRcdFx0XHR2aWV3czogW10sXG5cdFx0XHRcdFx0dGFza3M6IFtdLFxuXHRcdFx0XHRcdHZpZXdtb2RlbHM6IFtdLFxuXHRcdFx0XHRcdGluc3RhbmNlOiBpbnN0YW5jZVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAoIGluc3RhbmNlICkge1xuXHRcdFx0XHRcdGJhdGNoLnZpZXdtb2RlbHMucHVzaCggaW5zdGFuY2Uudmlld21vZGVsICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0XHR9LFxuXHRcdFx0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0Zmx1c2hDaGFuZ2VzKCk7XG5cdFx0XHRcdGJhdGNoLnRyYW5zaXRpb25NYW5hZ2VyLmluaXQoKTtcblx0XHRcdFx0aWYgKCAhYmF0Y2gucHJldmlvdXNCYXRjaCAmJiAhIWJhdGNoLmluc3RhbmNlIClcblx0XHRcdFx0XHRiYXRjaC5pbnN0YW5jZS52aWV3bW9kZWwuY2hhbmdlcyA9IFtdO1xuXHRcdFx0XHRiYXRjaCA9IGJhdGNoLnByZXZpb3VzQmF0Y2g7XG5cdFx0XHR9LFxuXHRcdFx0YWRkVmlld21vZGVsOiBmdW5jdGlvbiggdmlld21vZGVsICkge1xuXHRcdFx0XHRpZiAoIGJhdGNoICkge1xuXHRcdFx0XHRcdGlmICggYmF0Y2gudmlld21vZGVscy5pbmRleE9mKCB2aWV3bW9kZWwgKSA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0XHRiYXRjaC52aWV3bW9kZWxzLnB1c2goIHZpZXdtb2RlbCApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmlld21vZGVsLmFwcGx5Q2hhbmdlcygpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHJlZ2lzdGVyVHJhbnNpdGlvbjogZnVuY3Rpb24oIHRyYW5zaXRpb24gKSB7XG5cdFx0XHRcdHRyYW5zaXRpb24uX21hbmFnZXIgPSBiYXRjaC50cmFuc2l0aW9uTWFuYWdlcjtcblx0XHRcdFx0YmF0Y2gudHJhbnNpdGlvbk1hbmFnZXIuYWRkKCB0cmFuc2l0aW9uICk7XG5cdFx0XHR9LFxuXHRcdFx0YWRkVmlldzogZnVuY3Rpb24oIHZpZXcgKSB7XG5cdFx0XHRcdGJhdGNoLnZpZXdzLnB1c2goIHZpZXcgKTtcblx0XHRcdH0sXG5cdFx0XHRhZGRVbnJlc29sdmVkOiBmdW5jdGlvbiggdGhpbmcgKSB7XG5cdFx0XHRcdHVucmVzb2x2ZWQucHVzaCggdGhpbmcgKTtcblx0XHRcdH0sXG5cdFx0XHRyZW1vdmVVbnJlc29sdmVkOiBmdW5jdGlvbiggdGhpbmcgKSB7XG5cdFx0XHRcdHJlbW92ZUZyb21BcnJheSggdW5yZXNvbHZlZCwgdGhpbmcgKTtcblx0XHRcdH0sXG5cdFx0XHQvLyBzeW5jaHJvbmlzZSBub2RlIGRldGFjaG1lbnRzIHdpdGggdHJhbnNpdGlvbiBlbmRzXG5cdFx0XHRkZXRhY2hXaGVuUmVhZHk6IGZ1bmN0aW9uKCB0aGluZyApIHtcblx0XHRcdFx0YmF0Y2gudHJhbnNpdGlvbk1hbmFnZXIuZGV0YWNoUXVldWUucHVzaCggdGhpbmcgKTtcblx0XHRcdH0sXG5cdFx0XHRzY2hlZHVsZVRhc2s6IGZ1bmN0aW9uKCB0YXNrLCBwb3N0UmVuZGVyICkge1xuXHRcdFx0XHR2YXIgX2JhdGNoO1xuXHRcdFx0XHRpZiAoICFiYXRjaCApIHtcblx0XHRcdFx0XHR0YXNrKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0X2JhdGNoID0gYmF0Y2g7XG5cdFx0XHRcdFx0d2hpbGUgKCBwb3N0UmVuZGVyICYmIF9iYXRjaC5wcmV2aW91c0JhdGNoICkge1xuXHRcdFx0XHRcdFx0Ly8gdGhpcyBjYW4ndCBoYXBwZW4gdW50aWwgdGhlIERPTSBoYXMgYmVlbiBmdWxseSB1cGRhdGVkXG5cdFx0XHRcdFx0XHQvLyBvdGhlcndpc2UgaW4gc29tZSBzaXR1YXRpb25zICh3aXRoIGNvbXBvbmVudHMgaW5zaWRlIGVsZW1lbnRzKVxuXHRcdFx0XHRcdFx0Ly8gdHJhbnNpdGlvbnMgYW5kIGRlY29yYXRvcnMgd2lsbCBpbml0aWFsaXNlIHByZW1hdHVyZWx5XG5cdFx0XHRcdFx0XHRfYmF0Y2ggPSBfYmF0Y2gucHJldmlvdXNCYXRjaDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0X2JhdGNoLnRhc2tzLnB1c2goIHRhc2sgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0Y2lyY3VsYXIucnVubG9vcCA9IHJ1bmxvb3A7XG5cdFx0X19leHBvcnQgPSBydW5sb29wO1xuXG5cdFx0ZnVuY3Rpb24gZmx1c2hDaGFuZ2VzKCkge1xuXHRcdFx0dmFyIGksIHRoaW5nLCBjaGFuZ2VIYXNoO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBiYXRjaC52aWV3bW9kZWxzLmxlbmd0aDsgaSArPSAxICkge1xuXHRcdFx0XHR0aGluZyA9IGJhdGNoLnZpZXdtb2RlbHNbIGkgXTtcblx0XHRcdFx0Y2hhbmdlSGFzaCA9IHRoaW5nLmFwcGx5Q2hhbmdlcygpO1xuXHRcdFx0XHRpZiAoIGNoYW5nZUhhc2ggKSB7XG5cdFx0XHRcdFx0Y2hhbmdlSG9vay5maXJlKCB0aGluZy5yYWN0aXZlLCBjaGFuZ2VIYXNoICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGJhdGNoLnZpZXdtb2RlbHMubGVuZ3RoID0gMDtcblx0XHRcdGF0dGVtcHRLZXlwYXRoUmVzb2x1dGlvbigpO1xuXHRcdFx0Ly8gTm93IHRoYXQgY2hhbmdlcyBoYXZlIGJlZW4gZnVsbHkgcHJvcGFnYXRlZCwgd2UgY2FuIHVwZGF0ZSB0aGUgRE9NXG5cdFx0XHQvLyBhbmQgY29tcGxldGUgb3RoZXIgdGFza3Ncblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgYmF0Y2gudmlld3MubGVuZ3RoOyBpICs9IDEgKSB7XG5cdFx0XHRcdGJhdGNoLnZpZXdzWyBpIF0udXBkYXRlKCk7XG5cdFx0XHR9XG5cdFx0XHRiYXRjaC52aWV3cy5sZW5ndGggPSAwO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBiYXRjaC50YXNrcy5sZW5ndGg7IGkgKz0gMSApIHtcblx0XHRcdFx0YmF0Y2gudGFza3NbIGkgXSgpO1xuXHRcdFx0fVxuXHRcdFx0YmF0Y2gudGFza3MubGVuZ3RoID0gMDtcblx0XHRcdC8vIElmIHVwZGF0aW5nIHRoZSB2aWV3IGNhdXNlZCBzb21lIG1vZGVsIGJsb3diYWNrIC0gZS5nLiBhIHRyaXBsZVxuXHRcdFx0Ly8gY29udGFpbmluZyA8b3B0aW9uPiBlbGVtZW50cyBjYXVzZWQgdGhlIGJpbmRpbmcgb24gdGhlIDxzZWxlY3Q+XG5cdFx0XHQvLyB0byB1cGRhdGUgLSB0aGVuIHdlIHN0YXJ0IG92ZXJcblx0XHRcdGlmICggYmF0Y2gudmlld21vZGVscy5sZW5ndGggKVxuXHRcdFx0XHRyZXR1cm4gZmx1c2hDaGFuZ2VzKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYXR0ZW1wdEtleXBhdGhSZXNvbHV0aW9uKCkge1xuXHRcdFx0dmFyIGksIGl0ZW0sIGtleXBhdGgsIHJlc29sdmVkO1xuXHRcdFx0aSA9IHVucmVzb2x2ZWQubGVuZ3RoO1xuXHRcdFx0Ly8gc2VlIGlmIHdlIGNhbiByZXNvbHZlIGFueSB1bnJlc29sdmVkIHJlZmVyZW5jZXNcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpdGVtID0gdW5yZXNvbHZlZFsgaSBdO1xuXHRcdFx0XHRpZiAoIGl0ZW0ua2V5cGF0aCApIHtcblx0XHRcdFx0XHQvLyBpdCByZXNvbHZlZCBzb21lIG90aGVyIHdheS4gVE9ETyBob3c/IHR3by13YXkgYmluZGluZz8gU2VlbXNcblx0XHRcdFx0XHQvLyB3ZWlyZCB0aGF0IHdlJ2Qgc3RpbGwgZW5kIHVwIGhlcmVcblx0XHRcdFx0XHR1bnJlc29sdmVkLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICgga2V5cGF0aCA9IHJlc29sdmVSZWYoIGl0ZW0ucm9vdCwgaXRlbS5yZWYsIGl0ZW0ucGFyZW50RnJhZ21lbnQgKSApIHtcblx0XHRcdFx0XHQoIHJlc29sdmVkIHx8ICggcmVzb2x2ZWQgPSBbXSApICkucHVzaCgge1xuXHRcdFx0XHRcdFx0aXRlbTogaXRlbSxcblx0XHRcdFx0XHRcdGtleXBhdGg6IGtleXBhdGhcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0dW5yZXNvbHZlZC5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCByZXNvbHZlZCApIHtcblx0XHRcdFx0cmVzb2x2ZWQuZm9yRWFjaCggcmVzb2x2ZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlc29sdmUoIHJlc29sdmVkICkge1xuXHRcdFx0cmVzb2x2ZWQuaXRlbS5yZXNvbHZlKCByZXNvbHZlZC5rZXlwYXRoICk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggY2lyY3VsYXIsIFJhY3RpdmUkc2hhcmVkX2hvb2tzX0hvb2ssIHJlbW92ZUZyb21BcnJheSwgUHJvbWlzZSwgcmVzb2x2ZVJlZiwgVHJhbnNpdGlvbk1hbmFnZXIgKTtcblxuXHQvKiB1dGlscy9jcmVhdGVCcmFuY2guanMgKi9cblx0dmFyIGNyZWF0ZUJyYW5jaCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIG51bWVyaWMgPSAvXlxccypbMC05XStcXHMqJC87XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRyZXR1cm4gbnVtZXJpYy50ZXN0KCBrZXkgKSA/IFtdIDoge307XG5cdFx0fTtcblx0fSgpO1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvZ2V0L21hZ2ljQWRhcHRvci5qcyAqL1xuXHR2YXIgdmlld21vZGVsJGdldF9tYWdpY0FkYXB0b3IgPSBmdW5jdGlvbiggcnVubG9vcCwgY3JlYXRlQnJhbmNoLCBpc0FycmF5ICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBtYWdpY0FkYXB0b3IsIE1hZ2ljV3JhcHBlcjtcblx0XHR0cnkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB7fSwgJ3Rlc3QnLCB7XG5cdFx0XHRcdHZhbHVlOiAwXG5cdFx0XHR9ICk7XG5cdFx0XHRtYWdpY0FkYXB0b3IgPSB7XG5cdFx0XHRcdGZpbHRlcjogZnVuY3Rpb24oIG9iamVjdCwga2V5cGF0aCwgcmFjdGl2ZSApIHtcblx0XHRcdFx0XHR2YXIga2V5cywga2V5LCBwYXJlbnRLZXlwYXRoLCBwYXJlbnRXcmFwcGVyLCBwYXJlbnRWYWx1ZTtcblx0XHRcdFx0XHRpZiAoICFrZXlwYXRoICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRrZXlzID0ga2V5cGF0aC5zcGxpdCggJy4nICk7XG5cdFx0XHRcdFx0a2V5ID0ga2V5cy5wb3AoKTtcblx0XHRcdFx0XHRwYXJlbnRLZXlwYXRoID0ga2V5cy5qb2luKCAnLicgKTtcblx0XHRcdFx0XHQvLyBJZiB0aGUgcGFyZW50IHZhbHVlIGlzIGEgd3JhcHBlciwgb3RoZXIgdGhhbiBhIG1hZ2ljIHdyYXBwZXIsXG5cdFx0XHRcdFx0Ly8gd2Ugc2hvdWxkbid0IHdyYXAgdGhpcyBwcm9wZXJ0eVxuXHRcdFx0XHRcdGlmICggKCBwYXJlbnRXcmFwcGVyID0gcmFjdGl2ZS52aWV3bW9kZWwud3JhcHBlZFsgcGFyZW50S2V5cGF0aCBdICkgJiYgIXBhcmVudFdyYXBwZXIubWFnaWMgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBhcmVudFZhbHVlID0gcmFjdGl2ZS5nZXQoIHBhcmVudEtleXBhdGggKTtcblx0XHRcdFx0XHQvLyBpZiBwYXJlbnRWYWx1ZSBpcyBhbiBhcnJheSB0aGF0IGRvZXNuJ3QgaW5jbHVkZSB0aGlzIG1lbWJlcixcblx0XHRcdFx0XHQvLyB3ZSBzaG91bGQgcmV0dXJuIGZhbHNlIG90aGVyd2lzZSBsZW5ndGhzIHdpbGwgZ2V0IG1lc3NlZCB1cFxuXHRcdFx0XHRcdGlmICggaXNBcnJheSggcGFyZW50VmFsdWUgKSAmJiAvXlswLTldKyQvLnRlc3QoIGtleSApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gcGFyZW50VmFsdWUgJiYgKCB0eXBlb2YgcGFyZW50VmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYXJlbnRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJyApO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR3cmFwOiBmdW5jdGlvbiggcmFjdGl2ZSwgcHJvcGVydHksIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBNYWdpY1dyYXBwZXIoIHJhY3RpdmUsIHByb3BlcnR5LCBrZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRNYWdpY1dyYXBwZXIgPSBmdW5jdGlvbiggcmFjdGl2ZSwgdmFsdWUsIGtleXBhdGggKSB7XG5cdFx0XHRcdHZhciBrZXlzLCBvYmpLZXlwYXRoLCB0ZW1wbGF0ZSwgc2libGluZ3M7XG5cdFx0XHRcdHRoaXMubWFnaWMgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLnJhY3RpdmUgPSByYWN0aXZlO1xuXHRcdFx0XHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdGtleXMgPSBrZXlwYXRoLnNwbGl0KCAnLicgKTtcblx0XHRcdFx0dGhpcy5wcm9wID0ga2V5cy5wb3AoKTtcblx0XHRcdFx0b2JqS2V5cGF0aCA9IGtleXMuam9pbiggJy4nICk7XG5cdFx0XHRcdHRoaXMub2JqID0gb2JqS2V5cGF0aCA/IHJhY3RpdmUuZ2V0KCBvYmpLZXlwYXRoICkgOiByYWN0aXZlLmRhdGE7XG5cdFx0XHRcdHRlbXBsYXRlID0gdGhpcy5vcmlnaW5hbERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKCB0aGlzLm9iaiwgdGhpcy5wcm9wICk7XG5cdFx0XHRcdC8vIEhhcyB0aGlzIHByb3BlcnR5IGFscmVhZHkgYmVlbiB3cmFwcGVkP1xuXHRcdFx0XHRpZiAoIHRlbXBsYXRlICYmIHRlbXBsYXRlLnNldCAmJiAoIHNpYmxpbmdzID0gdGVtcGxhdGUuc2V0Ll9yYWN0aXZlV3JhcHBlcnMgKSApIHtcblx0XHRcdFx0XHQvLyBZZXMuIFJlZ2lzdGVyIHRoaXMgd3JhcHBlciB0byB0aGlzIHByb3BlcnR5LCBpZiBpdCBoYXNuJ3QgYmVlbiBhbHJlYWR5XG5cdFx0XHRcdFx0aWYgKCBzaWJsaW5ncy5pbmRleE9mKCB0aGlzICkgPT09IC0xICkge1xuXHRcdFx0XHRcdFx0c2libGluZ3MucHVzaCggdGhpcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gTm8sIGl0IGhhc24ndCBiZWVuIHdyYXBwZWRcblx0XHRcdFx0Y3JlYXRlQWNjZXNzb3JzKCB0aGlzLCB2YWx1ZSwgdGVtcGxhdGUgKTtcblx0XHRcdH07XG5cdFx0XHRNYWdpY1dyYXBwZXIucHJvdG90eXBlID0ge1xuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLnZhbHVlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRyZXNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdGlmICggdGhpcy51cGRhdGluZyApIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy51cGRhdGluZyA9IHRydWU7XG5cdFx0XHRcdFx0dGhpcy5vYmpbIHRoaXMucHJvcCBdID0gdmFsdWU7XG5cdFx0XHRcdFx0Ly8gdHJpZ2dlciBzZXQoKSBhY2Nlc3NvclxuXHRcdFx0XHRcdHJ1bmxvb3AuYWRkVmlld21vZGVsKCB0aGlzLnJhY3RpdmUudmlld21vZGVsICk7XG5cdFx0XHRcdFx0dGhpcy5yYWN0aXZlLnZpZXdtb2RlbC5tYXJrKCB0aGlzLmtleXBhdGggKTtcblx0XHRcdFx0XHR0aGlzLnVwZGF0aW5nID0gZmFsc2U7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNldDogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLnVwZGF0aW5nICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoICF0aGlzLm9ialsgdGhpcy5wcm9wIF0gKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnVwZGF0aW5nID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHRoaXMub2JqWyB0aGlzLnByb3AgXSA9IGNyZWF0ZUJyYW5jaCgga2V5ICk7XG5cdFx0XHRcdFx0XHR0aGlzLnVwZGF0aW5nID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMub2JqWyB0aGlzLnByb3AgXVsga2V5IF0gPSB2YWx1ZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciB0ZW1wbGF0ZSwgc2V0LCB2YWx1ZSwgd3JhcHBlcnMsIGluZGV4O1xuXHRcdFx0XHRcdC8vIElmIHRoaXMgbWV0aG9kIHdhcyBjYWxsZWQgYmVjYXVzZSB0aGUgY2FjaGUgd2FzIGJlaW5nIGNsZWFyZWQgYXMgYVxuXHRcdFx0XHRcdC8vIHJlc3VsdCBvZiBhIHNldCgpL3VwZGF0ZSgpIGNhbGwgbWFkZSBieSB0aGlzIHdyYXBwZXIsIHdlIHJldHVybiBmYWxzZVxuXHRcdFx0XHRcdC8vIHNvIHRoYXQgaXQgZG9lc24ndCBnZXQgdG9ybiBkb3duXG5cdFx0XHRcdFx0aWYgKCB0aGlzLnVwZGF0aW5nICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0ZW1wbGF0ZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoIHRoaXMub2JqLCB0aGlzLnByb3AgKTtcblx0XHRcdFx0XHRzZXQgPSB0ZW1wbGF0ZSAmJiB0ZW1wbGF0ZS5zZXQ7XG5cdFx0XHRcdFx0aWYgKCAhc2V0ICkge1xuXHRcdFx0XHRcdFx0Ly8gbW9zdCBsaWtlbHksIHRoaXMgd2FzIGFuIGFycmF5IG1lbWJlciB0aGF0IHdhcyBzcGxpY2VkIG91dFxuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3cmFwcGVycyA9IHNldC5fcmFjdGl2ZVdyYXBwZXJzO1xuXHRcdFx0XHRcdGluZGV4ID0gd3JhcHBlcnMuaW5kZXhPZiggdGhpcyApO1xuXHRcdFx0XHRcdGlmICggaW5kZXggIT09IC0xICkge1xuXHRcdFx0XHRcdFx0d3JhcHBlcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBMYXN0IG9uZSBvdXQsIHR1cm4gb2ZmIHRoZSBsaWdodHNcblx0XHRcdFx0XHRpZiAoICF3cmFwcGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IHRoaXMub2JqWyB0aGlzLnByb3AgXTtcblx0XHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcy5vYmosIHRoaXMucHJvcCwgdGhpcy5vcmlnaW5hbERlc2NyaXB0b3IgfHwge1xuXHRcdFx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR0aGlzLm9ialsgdGhpcy5wcm9wIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoIGVyciApIHtcblx0XHRcdG1hZ2ljQWRhcHRvciA9IGZhbHNlO1xuXHRcdH1cblx0XHRfX2V4cG9ydCA9IG1hZ2ljQWRhcHRvcjtcblxuXHRcdGZ1bmN0aW9uIGNyZWF0ZUFjY2Vzc29ycyggb3JpZ2luYWxXcmFwcGVyLCB2YWx1ZSwgdGVtcGxhdGUgKSB7XG5cdFx0XHR2YXIgb2JqZWN0LCBwcm9wZXJ0eSwgb2xkR2V0LCBvbGRTZXQsIGdldCwgc2V0O1xuXHRcdFx0b2JqZWN0ID0gb3JpZ2luYWxXcmFwcGVyLm9iajtcblx0XHRcdHByb3BlcnR5ID0gb3JpZ2luYWxXcmFwcGVyLnByb3A7XG5cdFx0XHQvLyBJcyB0aGlzIHRlbXBsYXRlIGNvbmZpZ3VyYWJsZT9cblx0XHRcdGlmICggdGVtcGxhdGUgJiYgIXRlbXBsYXRlLmNvbmZpZ3VyYWJsZSApIHtcblx0XHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gYXJyYXkgbGVuZ3RoXG5cdFx0XHRcdGlmICggcHJvcGVydHkgPT09ICdsZW5ndGgnICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdDYW5ub3QgdXNlIG1hZ2ljIG1vZGUgd2l0aCBwcm9wZXJ0eSBcIicgKyBwcm9wZXJ0eSArICdcIiAtIG9iamVjdCBpcyBub3QgY29uZmlndXJhYmxlJyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gVGltZSB0byB3cmFwIHRoaXMgcHJvcGVydHlcblx0XHRcdGlmICggdGVtcGxhdGUgKSB7XG5cdFx0XHRcdG9sZEdldCA9IHRlbXBsYXRlLmdldDtcblx0XHRcdFx0b2xkU2V0ID0gdGVtcGxhdGUuc2V0O1xuXHRcdFx0fVxuXHRcdFx0Z2V0ID0gb2xkR2V0IHx8IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHR9O1xuXHRcdFx0c2V0ID0gZnVuY3Rpb24oIHYgKSB7XG5cdFx0XHRcdGlmICggb2xkU2V0ICkge1xuXHRcdFx0XHRcdG9sZFNldCggdiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhbHVlID0gb2xkR2V0ID8gb2xkR2V0KCkgOiB2O1xuXHRcdFx0XHRzZXQuX3JhY3RpdmVXcmFwcGVycy5mb3JFYWNoKCB1cGRhdGVXcmFwcGVyICk7XG5cdFx0XHR9O1xuXG5cdFx0XHRmdW5jdGlvbiB1cGRhdGVXcmFwcGVyKCB3cmFwcGVyICkge1xuXHRcdFx0XHR2YXIga2V5cGF0aCwgcmFjdGl2ZTtcblx0XHRcdFx0d3JhcHBlci52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRpZiAoIHdyYXBwZXIudXBkYXRpbmcgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJhY3RpdmUgPSB3cmFwcGVyLnJhY3RpdmU7XG5cdFx0XHRcdGtleXBhdGggPSB3cmFwcGVyLmtleXBhdGg7XG5cdFx0XHRcdHdyYXBwZXIudXBkYXRpbmcgPSB0cnVlO1xuXHRcdFx0XHRydW5sb29wLnN0YXJ0KCByYWN0aXZlICk7XG5cdFx0XHRcdHJhY3RpdmUudmlld21vZGVsLm1hcmsoIGtleXBhdGggKTtcblx0XHRcdFx0cnVubG9vcC5lbmQoKTtcblx0XHRcdFx0d3JhcHBlci51cGRhdGluZyA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQ3JlYXRlIGFuIGFycmF5IG9mIHdyYXBwZXJzLCBpbiBjYXNlIG90aGVyIGtleXBhdGhzL3JhY3RpdmVzIGRlcGVuZCBvbiB0aGlzIHByb3BlcnR5LlxuXHRcdFx0Ly8gSGFuZGlseSwgd2UgY2FuIHN0b3JlIHRoZW0gYXMgYSBwcm9wZXJ0eSBvZiB0aGUgc2V0IGZ1bmN0aW9uLiBZYXkgSmF2YVNjcmlwdC5cblx0XHRcdHNldC5fcmFjdGl2ZVdyYXBwZXJzID0gWyBvcmlnaW5hbFdyYXBwZXIgXTtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb2JqZWN0LCBwcm9wZXJ0eSwge1xuXHRcdFx0XHRnZXQ6IGdldCxcblx0XHRcdFx0c2V0OiBzZXQsXG5cdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0fSApO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIHJ1bmxvb3AsIGNyZWF0ZUJyYW5jaCwgaXNBcnJheSApO1xuXG5cdC8qIGNvbmZpZy9tYWdpYy5qcyAqL1xuXHR2YXIgbWFnaWMgPSBmdW5jdGlvbiggbWFnaWNBZGFwdG9yICkge1xuXG5cdFx0cmV0dXJuICEhbWFnaWNBZGFwdG9yO1xuXHR9KCB2aWV3bW9kZWwkZ2V0X21hZ2ljQWRhcHRvciApO1xuXG5cdC8qIGNvbmZpZy9uYW1lc3BhY2VzLmpzICovXG5cdHZhciBuYW1lc3BhY2VzID0ge1xuXHRcdGh0bWw6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJyxcblx0XHRtYXRobWw6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJyxcblx0XHRzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG5cdFx0eGxpbms6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcblx0XHR4bWw6ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnLFxuXHRcdHhtbG5zOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nXG5cdH07XG5cblx0LyogdXRpbHMvY3JlYXRlRWxlbWVudC5qcyAqL1xuXHR2YXIgY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uKCBzdmcsIG5hbWVzcGFjZXMgKSB7XG5cblx0XHR2YXIgY3JlYXRlRWxlbWVudDtcblx0XHQvLyBUZXN0IGZvciBTVkcgc3VwcG9ydFxuXHRcdGlmICggIXN2ZyApIHtcblx0XHRcdGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiggdHlwZSwgbnMgKSB7XG5cdFx0XHRcdGlmICggbnMgJiYgbnMgIT09IG5hbWVzcGFjZXMuaHRtbCApIHtcblx0XHRcdFx0XHR0aHJvdyAnVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgbmFtZXNwYWNlcyBvdGhlciB0aGFuIGh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwuIFRoZSBtb3N0IGxpa2VseSBjYXVzZSBvZiB0aGlzIGVycm9yIGlzIHRoYXQgeW91XFwncmUgdHJ5aW5nIHRvIHJlbmRlciBTVkcgaW4gYW4gb2xkZXIgYnJvd3Nlci4gU2VlIGh0dHA6Ly9kb2NzLnJhY3RpdmVqcy5vcmcvbGF0ZXN0L3N2Zy1hbmQtb2xkZXItYnJvd3NlcnMgZm9yIG1vcmUgaW5mb3JtYXRpb24nO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCB0eXBlICk7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24oIHR5cGUsIG5zICkge1xuXHRcdFx0XHRpZiAoICFucyB8fCBucyA9PT0gbmFtZXNwYWNlcy5odG1sICkge1xuXHRcdFx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCB0eXBlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyggbnMsIHR5cGUgKTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBjcmVhdGVFbGVtZW50O1xuXHR9KCBzdmcsIG5hbWVzcGFjZXMgKTtcblxuXHQvKiBjb25maWcvaXNDbGllbnQuanMgKi9cblx0dmFyIGlzQ2xpZW50ID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgaXNDbGllbnQgPSB0eXBlb2YgZG9jdW1lbnQgPT09ICdvYmplY3QnO1xuXHRcdHJldHVybiBpc0NsaWVudDtcblx0fSgpO1xuXG5cdC8qIHV0aWxzL2RlZmluZVByb3BlcnR5LmpzICovXG5cdHZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uKCBpc0NsaWVudCApIHtcblxuXHRcdHZhciBkZWZpbmVQcm9wZXJ0eTtcblx0XHR0cnkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB7fSwgJ3Rlc3QnLCB7XG5cdFx0XHRcdHZhbHVlOiAwXG5cdFx0XHR9ICk7XG5cdFx0XHRpZiAoIGlzQ2xpZW50ICkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICksICd0ZXN0Jywge1xuXHRcdFx0XHRcdHZhbHVlOiAwXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXHRcdH0gY2F0Y2ggKCBlcnIgKSB7XG5cdFx0XHQvLyBPYmplY3QuZGVmaW5lUHJvcGVydHkgZG9lc24ndCBleGlzdCwgb3Igd2UncmUgaW4gSUU4IHdoZXJlIHlvdSBjYW5cblx0XHRcdC8vIG9ubHkgdXNlIGl0IHdpdGggRE9NIG9iamVjdHMgKHdoYXQgdGhlIGZ1Y2sgd2VyZSB5b3Ugc21va2luZywgTVNGVD8pXG5cdFx0XHRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uKCBvYmosIHByb3AsIGRlc2MgKSB7XG5cdFx0XHRcdG9ialsgcHJvcCBdID0gZGVzYy52YWx1ZTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBkZWZpbmVQcm9wZXJ0eTtcblx0fSggaXNDbGllbnQgKTtcblxuXHQvKiB1dGlscy9kZWZpbmVQcm9wZXJ0aWVzLmpzICovXG5cdHZhciBkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24oIGNyZWF0ZUVsZW1lbnQsIGRlZmluZVByb3BlcnR5LCBpc0NsaWVudCApIHtcblxuXHRcdHZhciBkZWZpbmVQcm9wZXJ0aWVzO1xuXHRcdHRyeSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcygge30sIHtcblx0XHRcdFx0XHR0ZXN0OiB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogMFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fSBjYXRjaCAoIGVyciApIHtcblx0XHRcdFx0Ly8gVE9ETyBob3cgZG8gd2UgYWNjb3VudCBmb3IgdGhpcz8gbm9NYWdpYyA9IHRydWU7XG5cdFx0XHRcdHRocm93IGVycjtcblx0XHRcdH1cblx0XHRcdGlmICggaXNDbGllbnQgKSB7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBjcmVhdGVFbGVtZW50KCAnZGl2JyApLCB7XG5cdFx0XHRcdFx0dGVzdDoge1xuXHRcdFx0XHRcdFx0dmFsdWU6IDBcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdGRlZmluZVByb3BlcnRpZXMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcblx0XHR9IGNhdGNoICggZXJyICkge1xuXHRcdFx0ZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uKCBvYmosIHByb3BzICkge1xuXHRcdFx0XHR2YXIgcHJvcDtcblx0XHRcdFx0Zm9yICggcHJvcCBpbiBwcm9wcyApIHtcblx0XHRcdFx0XHRpZiAoIHByb3BzLmhhc093blByb3BlcnR5KCBwcm9wICkgKSB7XG5cdFx0XHRcdFx0XHRkZWZpbmVQcm9wZXJ0eSggb2JqLCBwcm9wLCBwcm9wc1sgcHJvcCBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gZGVmaW5lUHJvcGVydGllcztcblx0fSggY3JlYXRlRWxlbWVudCwgZGVmaW5lUHJvcGVydHksIGlzQ2xpZW50ICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2hhcmVkL2FkZC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzaGFyZWRfYWRkID0gZnVuY3Rpb24oIGlzTnVtZXJpYyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBhZGQoIHJvb3QsIGtleXBhdGgsIGQgKSB7XG5cdFx0XHR2YXIgdmFsdWU7XG5cdFx0XHRpZiAoIHR5cGVvZiBrZXlwYXRoICE9PSAnc3RyaW5nJyB8fCAhaXNOdW1lcmljKCBkICkgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0JhZCBhcmd1bWVudHMnICk7XG5cdFx0XHR9XG5cdFx0XHR2YWx1ZSA9ICtyb290LmdldCgga2V5cGF0aCApIHx8IDA7XG5cdFx0XHRpZiAoICFpc051bWVyaWMoIHZhbHVlICkgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0Nhbm5vdCBhZGQgdG8gYSBub24tbnVtZXJpYyB2YWx1ZScgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByb290LnNldCgga2V5cGF0aCwgdmFsdWUgKyBkICk7XG5cdFx0fTtcblx0fSggaXNOdW1lcmljICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvYWRkLmpzICovXG5cdHZhciBSYWN0aXZlJGFkZCA9IGZ1bmN0aW9uKCBhZGQgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRhZGQoIGtleXBhdGgsIGQgKSB7XG5cdFx0XHRyZXR1cm4gYWRkKCB0aGlzLCBrZXlwYXRoLCBkID09PSB1bmRlZmluZWQgPyAxIDogK2QgKTtcblx0XHR9O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9hZGQgKTtcblxuXHQvKiB1dGlscy9ub3JtYWxpc2VLZXlwYXRoLmpzICovXG5cdHZhciBub3JtYWxpc2VLZXlwYXRoID0gZnVuY3Rpb24oIG5vcm1hbGlzZVJlZiApIHtcblxuXHRcdHZhciBsZWFkaW5nRG90ID0gL15cXC4rLztcblx0XHRyZXR1cm4gZnVuY3Rpb24gbm9ybWFsaXNlS2V5cGF0aCgga2V5cGF0aCApIHtcblx0XHRcdHJldHVybiBub3JtYWxpc2VSZWYoIGtleXBhdGggKS5yZXBsYWNlKCBsZWFkaW5nRG90LCAnJyApO1xuXHRcdH07XG5cdH0oIG5vcm1hbGlzZVJlZiApO1xuXG5cdC8qIGNvbmZpZy92ZW5kb3JzLmpzICovXG5cdHZhciB2ZW5kb3JzID0gW1xuXHRcdCdvJyxcblx0XHQnbXMnLFxuXHRcdCdtb3onLFxuXHRcdCd3ZWJraXQnXG5cdF07XG5cblx0LyogdXRpbHMvcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmpzICovXG5cdHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiggdmVuZG9ycyApIHtcblxuXHRcdHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cdFx0Ly8gSWYgd2luZG93IGRvZXNuJ3QgZXhpc3QsIHdlIGRvbid0IG5lZWQgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG5cdFx0aWYgKCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxpcmlzaC8xNTc5NjcxXG5cdFx0XHQoIGZ1bmN0aW9uKCB2ZW5kb3JzLCBsYXN0VGltZSwgd2luZG93ICkge1xuXHRcdFx0XHR2YXIgeCwgc2V0VGltZW91dDtcblx0XHRcdFx0aWYgKCB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKCB4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK3ggKSB7XG5cdFx0XHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvd1sgdmVuZG9yc1sgeCBdICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZScgXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICkge1xuXHRcdFx0XHRcdHNldFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dDtcblx0XHRcdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0dmFyIGN1cnJUaW1lLCB0aW1lVG9DYWxsLCBpZDtcblx0XHRcdFx0XHRcdGN1cnJUaW1lID0gRGF0ZS5ub3coKTtcblx0XHRcdFx0XHRcdHRpbWVUb0NhbGwgPSBNYXRoLm1heCggMCwgMTYgLSAoIGN1cnJUaW1lIC0gbGFzdFRpbWUgKSApO1xuXHRcdFx0XHRcdFx0aWQgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soIGN1cnJUaW1lICsgdGltZVRvQ2FsbCApO1xuXHRcdFx0XHRcdFx0fSwgdGltZVRvQ2FsbCApO1xuXHRcdFx0XHRcdFx0bGFzdFRpbWUgPSBjdXJyVGltZSArIHRpbWVUb0NhbGw7XG5cdFx0XHRcdFx0XHRyZXR1cm4gaWQ7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0fSggdmVuZG9ycywgMCwgd2luZG93ICkgKTtcblx0XHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cdFx0fVxuXHRcdHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cdH0oIHZlbmRvcnMgKTtcblxuXHQvKiB1dGlscy9nZXRUaW1lLmpzICovXG5cdHZhciBnZXRUaW1lID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgZ2V0VGltZTtcblx0XHRpZiAoIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wZXJmb3JtYW5jZSAmJiB0eXBlb2Ygd2luZG93LnBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdGdldFRpbWUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcblx0XHRcdH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGdldFRpbWUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIERhdGUubm93KCk7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gZ2V0VGltZTtcblx0fSgpO1xuXG5cdC8qIHNoYXJlZC9hbmltYXRpb25zLmpzICovXG5cdHZhciBhbmltYXRpb25zID0gZnVuY3Rpb24oIHJBRiwgZ2V0VGltZSwgcnVubG9vcCApIHtcblxuXHRcdHZhciBxdWV1ZSA9IFtdO1xuXHRcdHZhciBhbmltYXRpb25zID0ge1xuXHRcdFx0dGljazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBpLCBhbmltYXRpb24sIG5vdztcblx0XHRcdFx0bm93ID0gZ2V0VGltZSgpO1xuXHRcdFx0XHRydW5sb29wLnN0YXJ0KCk7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpICs9IDEgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uID0gcXVldWVbIGkgXTtcblx0XHRcdFx0XHRpZiAoICFhbmltYXRpb24udGljayggbm93ICkgKSB7XG5cdFx0XHRcdFx0XHQvLyBhbmltYXRpb24gaXMgY29tcGxldGUsIHJlbW92ZSBpdCBmcm9tIHRoZSBzdGFjaywgYW5kIGRlY3JlbWVudCBpIHNvIHdlIGRvbid0IG1pc3Mgb25lXG5cdFx0XHRcdFx0XHRxdWV1ZS5zcGxpY2UoIGktLSwgMSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRydW5sb29wLmVuZCgpO1xuXHRcdFx0XHRpZiAoIHF1ZXVlLmxlbmd0aCApIHtcblx0XHRcdFx0XHRyQUYoIGFuaW1hdGlvbnMudGljayApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGFuaW1hdGlvbnMucnVubmluZyA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0YWRkOiBmdW5jdGlvbiggYW5pbWF0aW9uICkge1xuXHRcdFx0XHRxdWV1ZS5wdXNoKCBhbmltYXRpb24gKTtcblx0XHRcdFx0aWYgKCAhYW5pbWF0aW9ucy5ydW5uaW5nICkge1xuXHRcdFx0XHRcdGFuaW1hdGlvbnMucnVubmluZyA9IHRydWU7XG5cdFx0XHRcdFx0ckFGKCBhbmltYXRpb25zLnRpY2sgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdC8vIFRPRE8gb3B0aW1pc2UgdGhpc1xuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBrZXlwYXRoLCByb290ICkge1xuXHRcdFx0XHR2YXIgaSA9IHF1ZXVlLmxlbmd0aCxcblx0XHRcdFx0XHRhbmltYXRpb247XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGFuaW1hdGlvbiA9IHF1ZXVlWyBpIF07XG5cdFx0XHRcdFx0aWYgKCBhbmltYXRpb24ucm9vdCA9PT0gcm9vdCAmJiBhbmltYXRpb24ua2V5cGF0aCA9PT0ga2V5cGF0aCApIHtcblx0XHRcdFx0XHRcdGFuaW1hdGlvbi5zdG9wKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gYW5pbWF0aW9ucztcblx0fSggcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBnZXRUaW1lLCBydW5sb29wICk7XG5cblx0LyogY29uZmlnL29wdGlvbnMvY3NzL3RyYW5zZm9ybS5qcyAqL1xuXHR2YXIgdHJhbnNmb3JtID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIHNlbGVjdG9yc1BhdHRlcm4gPSAvKD86XnxcXH0pP1xccyooW15cXHtcXH1dKylcXHMqXFx7L2csXG5cdFx0XHRjb21tZW50c1BhdHRlcm4gPSAvXFwvXFwqLio/XFwqXFwvL2csXG5cdFx0XHRzZWxlY3RvclVuaXRQYXR0ZXJuID0gLygoPzooPzpcXFtbXlxcXStdXFxdKXwoPzpbXlxcc1xcK1xcPlxcfjpdKSkrKSgoPzo6W15cXHNcXCtcXD5cXH5dKyk/XFxzKltcXHNcXCtcXD5cXH5dPylcXHMqL2csXG5cdFx0XHRtZWRpYVF1ZXJ5UGF0dGVybiA9IC9eQG1lZGlhLyxcblx0XHRcdGRhdGFSdmNHdWlkUGF0dGVybiA9IC9cXFtkYXRhLXJ2Y2d1aWQ9XCJbYS16MC05LV0rXCJdL2c7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiB0cmFuc2Zvcm1Dc3MoIGNzcywgZ3VpZCApIHtcblx0XHRcdHZhciB0cmFuc2Zvcm1lZCwgYWRkR3VpZDtcblx0XHRcdGFkZEd1aWQgPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdHZhciBzZWxlY3RvclVuaXRzLCBtYXRjaCwgdW5pdCwgZGF0YUF0dHIsIGJhc2UsIHByZXBlbmRlZCwgYXBwZW5kZWQsIGksIHRyYW5zZm9ybWVkID0gW107XG5cdFx0XHRcdHNlbGVjdG9yVW5pdHMgPSBbXTtcblx0XHRcdFx0d2hpbGUgKCBtYXRjaCA9IHNlbGVjdG9yVW5pdFBhdHRlcm4uZXhlYyggc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRzZWxlY3RvclVuaXRzLnB1c2goIHtcblx0XHRcdFx0XHRcdHN0cjogbWF0Y2hbIDAgXSxcblx0XHRcdFx0XHRcdGJhc2U6IG1hdGNoWyAxIF0sXG5cdFx0XHRcdFx0XHRtb2RpZmllcnM6IG1hdGNoWyAyIF1cblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gRm9yIGVhY2ggc2ltcGxlIHNlbGVjdG9yIHdpdGhpbiB0aGUgc2VsZWN0b3IsIHdlIG5lZWQgdG8gY3JlYXRlIGEgdmVyc2lvblxuXHRcdFx0XHQvLyB0aGF0IGEpIGNvbWJpbmVzIHdpdGggdGhlIGd1aWQsIGFuZCBiKSBpcyBpbnNpZGUgdGhlIGd1aWRcblx0XHRcdFx0ZGF0YUF0dHIgPSAnW2RhdGEtcnZjZ3VpZD1cIicgKyBndWlkICsgJ1wiXSc7XG5cdFx0XHRcdGJhc2UgPSBzZWxlY3RvclVuaXRzLm1hcCggZXh0cmFjdFN0cmluZyApO1xuXHRcdFx0XHRpID0gc2VsZWN0b3JVbml0cy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGFwcGVuZGVkID0gYmFzZS5zbGljZSgpO1xuXHRcdFx0XHRcdC8vIFBzZXVkby1zZWxlY3RvcnMgc2hvdWxkIGdvIGFmdGVyIHRoZSBhdHRyaWJ1dGUgc2VsZWN0b3Jcblx0XHRcdFx0XHR1bml0ID0gc2VsZWN0b3JVbml0c1sgaSBdO1xuXHRcdFx0XHRcdGFwcGVuZGVkWyBpIF0gPSB1bml0LmJhc2UgKyBkYXRhQXR0ciArIHVuaXQubW9kaWZpZXJzIHx8ICcnO1xuXHRcdFx0XHRcdHByZXBlbmRlZCA9IGJhc2Uuc2xpY2UoKTtcblx0XHRcdFx0XHRwcmVwZW5kZWRbIGkgXSA9IGRhdGFBdHRyICsgJyAnICsgcHJlcGVuZGVkWyBpIF07XG5cdFx0XHRcdFx0dHJhbnNmb3JtZWQucHVzaCggYXBwZW5kZWQuam9pbiggJyAnICksIHByZXBlbmRlZC5qb2luKCAnICcgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cmFuc2Zvcm1lZC5qb2luKCAnLCAnICk7XG5cdFx0XHR9O1xuXHRcdFx0aWYgKCBkYXRhUnZjR3VpZFBhdHRlcm4udGVzdCggY3NzICkgKSB7XG5cdFx0XHRcdHRyYW5zZm9ybWVkID0gY3NzLnJlcGxhY2UoIGRhdGFSdmNHdWlkUGF0dGVybiwgJ1tkYXRhLXJ2Y2d1aWQ9XCInICsgZ3VpZCArICdcIl0nICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0cmFuc2Zvcm1lZCA9IGNzcy5yZXBsYWNlKCBjb21tZW50c1BhdHRlcm4sICcnICkucmVwbGFjZSggc2VsZWN0b3JzUGF0dGVybiwgZnVuY3Rpb24oIG1hdGNoLCAkMSApIHtcblx0XHRcdFx0XHR2YXIgc2VsZWN0b3JzLCB0cmFuc2Zvcm1lZDtcblx0XHRcdFx0XHQvLyBkb24ndCB0cmFuc2Zvcm0gbWVkaWEgcXVlcmllcyFcblx0XHRcdFx0XHRpZiAoIG1lZGlhUXVlcnlQYXR0ZXJuLnRlc3QoICQxICkgKVxuXHRcdFx0XHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdFx0XHRcdHNlbGVjdG9ycyA9ICQxLnNwbGl0KCAnLCcgKS5tYXAoIHRyaW0gKTtcblx0XHRcdFx0XHR0cmFuc2Zvcm1lZCA9IHNlbGVjdG9ycy5tYXAoIGFkZEd1aWQgKS5qb2luKCAnLCAnICkgKyAnICc7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoLnJlcGxhY2UoICQxLCB0cmFuc2Zvcm1lZCApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJhbnNmb3JtZWQ7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHRyaW0oIHN0ciApIHtcblx0XHRcdGlmICggc3RyLnRyaW0gKSB7XG5cdFx0XHRcdHJldHVybiBzdHIudHJpbSgpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKCAvXlxccysvLCAnJyApLnJlcGxhY2UoIC9cXHMrJC8sICcnICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZXh0cmFjdFN0cmluZyggdW5pdCApIHtcblx0XHRcdHJldHVybiB1bml0LnN0cjtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCk7XG5cblx0LyogY29uZmlnL29wdGlvbnMvY3NzL2Nzcy5qcyAqL1xuXHR2YXIgY3NzID0gZnVuY3Rpb24oIHRyYW5zZm9ybUNzcyApIHtcblxuXHRcdHZhciBjc3NDb25maWcgPSB7XG5cdFx0XHRuYW1lOiAnY3NzJyxcblx0XHRcdGV4dGVuZDogZXh0ZW5kLFxuXHRcdFx0aW5pdDogZnVuY3Rpb24oKSB7fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBleHRlbmQoIFBhcmVudCwgcHJvdG8sIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgZ3VpZCA9IHByb3RvLmNvbnN0cnVjdG9yLl9ndWlkLFxuXHRcdFx0XHRjc3M7XG5cdFx0XHRpZiAoIGNzcyA9IGdldENzcyggb3B0aW9ucy5jc3MsIG9wdGlvbnMsIGd1aWQgKSB8fCBnZXRDc3MoIFBhcmVudC5jc3MsIFBhcmVudCwgZ3VpZCApICkge1xuXHRcdFx0XHRwcm90by5jb25zdHJ1Y3Rvci5jc3MgPSBjc3M7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0Q3NzKCBjc3MsIHRhcmdldCwgZ3VpZCApIHtcblx0XHRcdGlmICggIWNzcyApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRhcmdldC5ub0Nzc1RyYW5zZm9ybSA/IGNzcyA6IHRyYW5zZm9ybUNzcyggY3NzLCBndWlkICk7XG5cdFx0fVxuXHRcdHJldHVybiBjc3NDb25maWc7XG5cdH0oIHRyYW5zZm9ybSApO1xuXG5cdC8qIHV0aWxzL3dyYXBNZXRob2QuanMgKi9cblx0dmFyIHdyYXBNZXRob2QgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uKCBtZXRob2QsIHN1cGVyTWV0aG9kLCBmb3JjZSApIHtcblx0XHRcdGlmICggZm9yY2UgfHwgbmVlZHNTdXBlciggbWV0aG9kLCBzdXBlck1ldGhvZCApICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIGhhc1N1cGVyID0gJ19zdXBlcicgaW4gdGhpcyxcblx0XHRcdFx0XHRcdF9zdXBlciA9IHRoaXMuX3N1cGVyLFxuXHRcdFx0XHRcdFx0cmVzdWx0O1xuXHRcdFx0XHRcdHRoaXMuX3N1cGVyID0gc3VwZXJNZXRob2Q7XG5cdFx0XHRcdFx0cmVzdWx0ID0gbWV0aG9kLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRpZiAoIGhhc1N1cGVyICkge1xuXHRcdFx0XHRcdFx0dGhpcy5fc3VwZXIgPSBfc3VwZXI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gbWV0aG9kO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBuZWVkc1N1cGVyKCBtZXRob2QsIHN1cGVyTWV0aG9kICkge1xuXHRcdFx0cmV0dXJuIHR5cGVvZiBzdXBlck1ldGhvZCA9PT0gJ2Z1bmN0aW9uJyAmJiAvX3N1cGVyLy50ZXN0KCBtZXRob2QgKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCk7XG5cblx0LyogY29uZmlnL29wdGlvbnMvZGF0YS5qcyAqL1xuXHR2YXIgZGF0YSA9IGZ1bmN0aW9uKCB3cmFwICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBkYXRhQ29uZmlnID0ge1xuXHRcdFx0bmFtZTogJ2RhdGEnLFxuXHRcdFx0ZXh0ZW5kOiBleHRlbmQsXG5cdFx0XHRpbml0OiBpbml0LFxuXHRcdFx0cmVzZXQ6IHJlc2V0XG5cdFx0fTtcblx0XHRfX2V4cG9ydCA9IGRhdGFDb25maWc7XG5cblx0XHRmdW5jdGlvbiBjb21iaW5lKCBQYXJlbnQsIHRhcmdldCwgb3B0aW9ucyApIHtcblx0XHRcdHZhciB2YWx1ZSA9IG9wdGlvbnMuZGF0YSB8fCB7fSxcblx0XHRcdFx0cGFyZW50VmFsdWUgPSBnZXRBZGRlZEtleXMoIFBhcmVudC5wcm90b3R5cGUuZGF0YSApO1xuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ2RhdGEgb3B0aW9uIG11c3QgYmUgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb24sIFwiJyArIHZhbHVlICsgJ1wiIGlzIG5vdCB2YWxpZCcgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBkaXNwYXRjaCggcGFyZW50VmFsdWUsIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZXh0ZW5kKCBQYXJlbnQsIHByb3RvLCBvcHRpb25zICkge1xuXHRcdFx0cHJvdG8uZGF0YSA9IGNvbWJpbmUoIFBhcmVudCwgcHJvdG8sIG9wdGlvbnMgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpbml0KCBQYXJlbnQsIHJhY3RpdmUsIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSBvcHRpb25zLmRhdGEsXG5cdFx0XHRcdHJlc3VsdCA9IGNvbWJpbmUoIFBhcmVudCwgcmFjdGl2ZSwgb3B0aW9ucyApO1xuXHRcdFx0aWYgKCB0eXBlb2YgcmVzdWx0ID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRyZXN1bHQgPSByZXN1bHQuY2FsbCggcmFjdGl2ZSwgdmFsdWUgKSB8fCB2YWx1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByYWN0aXZlLmRhdGEgPSByZXN1bHQgfHwge307XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVzZXQoIHJhY3RpdmUgKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdGhpcy5pbml0KCByYWN0aXZlLmNvbnN0cnVjdG9yLCByYWN0aXZlLCByYWN0aXZlICk7XG5cdFx0XHRpZiAoIHJlc3VsdCApIHtcblx0XHRcdFx0cmFjdGl2ZS5kYXRhID0gcmVzdWx0O1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRBZGRlZEtleXMoIHBhcmVudCApIHtcblx0XHRcdC8vIG9ubHkgZm9yIGZ1bmN0aW9ucyB0aGF0IGhhZCBrZXlzIGFkZGVkXG5cdFx0XHRpZiAoIHR5cGVvZiBwYXJlbnQgIT09ICdmdW5jdGlvbicgfHwgIU9iamVjdC5rZXlzKCBwYXJlbnQgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiBwYXJlbnQ7XG5cdFx0XHR9XG5cdFx0XHQvLyBjb3B5IHRoZSBhZGRlZCBrZXlzIHRvIHRlbXAgJ29iamVjdCcsIG90aGVyd2lzZVxuXHRcdFx0Ly8gcGFyZW50IHdvdWxkIGJlIGludGVycHJldGVkIGFzICdmdW5jdGlvbicgYnkgZGlzcGF0Y2hcblx0XHRcdHZhciB0ZW1wID0ge307XG5cdFx0XHRjb3B5KCBwYXJlbnQsIHRlbXAgKTtcblx0XHRcdC8vIHJvbGwgaW4gYWRkZWQga2V5c1xuXHRcdFx0cmV0dXJuIGRpc3BhdGNoKCBwYXJlbnQsIHRlbXAgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBkaXNwYXRjaCggcGFyZW50LCBjaGlsZCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRyZXR1cm4gZXh0ZW5kRm4oIGNoaWxkLCBwYXJlbnQgKTtcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiBwYXJlbnQgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdHJldHVybiBmcm9tRm4oIGNoaWxkLCBwYXJlbnQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBmcm9tUHJvcGVydGllcyggY2hpbGQsIHBhcmVudCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNvcHkoIGZyb20sIHRvLCBmaWxsT25seSApIHtcblx0XHRcdGZvciAoIHZhciBrZXkgaW4gZnJvbSApIHtcblx0XHRcdFx0aWYgKCBmaWxsT25seSAmJiBrZXkgaW4gdG8gKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dG9bIGtleSBdID0gZnJvbVsga2V5IF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZnJvbVByb3BlcnRpZXMoIGNoaWxkLCBwYXJlbnQgKSB7XG5cdFx0XHRjaGlsZCA9IGNoaWxkIHx8IHt9O1xuXHRcdFx0aWYgKCAhcGFyZW50ICkge1xuXHRcdFx0XHRyZXR1cm4gY2hpbGQ7XG5cdFx0XHR9XG5cdFx0XHRjb3B5KCBwYXJlbnQsIGNoaWxkLCB0cnVlICk7XG5cdFx0XHRyZXR1cm4gY2hpbGQ7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZnJvbUZuKCBjaGlsZCwgcGFyZW50Rm4gKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdFx0XHRcdHZhciBrZXlzO1xuXHRcdFx0XHRpZiAoIGNoaWxkICkge1xuXHRcdFx0XHRcdC8vIFRyYWNrIHRoZSBrZXlzIHRoYXQgb3VyIG9uIHRoZSBjaGlsZCxcblx0XHRcdFx0XHQvLyBidXQgbm90IG9uIHRoZSBkYXRhLiBXZSdsbCBuZWVkIHRvIGFwcGx5IHRoZXNlXG5cdFx0XHRcdFx0Ly8gYWZ0ZXIgdGhlIHBhcmVudCBmdW5jdGlvbiByZXR1cm5zLlxuXHRcdFx0XHRcdGtleXMgPSBbXTtcblx0XHRcdFx0XHRmb3IgKCB2YXIga2V5IGluIGNoaWxkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhZGF0YSB8fCAhKCBrZXkgaW4gZGF0YSApICkge1xuXHRcdFx0XHRcdFx0XHRrZXlzLnB1c2goIGtleSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBjYWxsIHRoZSBwYXJlbnQgZm4sIHVzZSBkYXRhIGlmIG5vIHJldHVybiB2YWx1ZVxuXHRcdFx0XHRkYXRhID0gcGFyZW50Rm4uY2FsbCggdGhpcywgZGF0YSApIHx8IGRhdGE7XG5cdFx0XHRcdC8vIENvcHkgY2hpbGQga2V5cyBiYWNrIG9udG8gZGF0YS4gVGhlIGNoaWxkIGtleXNcblx0XHRcdFx0Ly8gc2hvdWxkIHRha2UgcHJlY2VkZW5jZSBvdmVyIHdoYXRldmVyIHRoZVxuXHRcdFx0XHQvLyBwYXJlbnQgZGlkIHdpdGggdGhlIGRhdGEuXG5cdFx0XHRcdGlmICgga2V5cyAmJiBrZXlzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRkYXRhID0gZGF0YSB8fCB7fTtcblx0XHRcdFx0XHRrZXlzLmZvckVhY2goIGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0XHRkYXRhWyBrZXkgXSA9IGNoaWxkWyBrZXkgXTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGV4dGVuZEZuKCBjaGlsZEZuLCBwYXJlbnQgKSB7XG5cdFx0XHR2YXIgcGFyZW50Rm47XG5cdFx0XHRpZiAoIHR5cGVvZiBwYXJlbnQgIT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdC8vIGNvcHkgcHJvcHMgdG8gZGF0YVxuXHRcdFx0XHRwYXJlbnRGbiA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHRcdFx0XHRcdGZyb21Qcm9wZXJ0aWVzKCBkYXRhLCBwYXJlbnQgKTtcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhcmVudEZuID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdFx0XHRcdFx0Ly8gZ2l2ZSBwYXJlbnQgZnVuY3Rpb24gaXQncyBvd24gdGhpcy5fc3VwZXIgY29udGV4dCxcblx0XHRcdFx0XHQvLyBvdGhlcndpc2UgdGhpcy5fc3VwZXIgaXMgZnJvbSBjaGlsZCBhbmRcblx0XHRcdFx0XHQvLyBjYXVzZXMgaW5maW5pdGUgbG9vcFxuXHRcdFx0XHRcdHBhcmVudCA9IHdyYXAoIHBhcmVudCwgZnVuY3Rpb24oKSB7fSwgdHJ1ZSApO1xuXHRcdFx0XHRcdHJldHVybiBwYXJlbnQuY2FsbCggdGhpcywgZGF0YSApIHx8IGRhdGE7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gd3JhcCggY2hpbGRGbiwgcGFyZW50Rm4gKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCB3cmFwTWV0aG9kICk7XG5cblx0LyogY29uZmlnL3R5cGVzLmpzICovXG5cdHZhciB0eXBlcyA9IHtcblx0XHRURVhUOiAxLFxuXHRcdElOVEVSUE9MQVRPUjogMixcblx0XHRUUklQTEU6IDMsXG5cdFx0U0VDVElPTjogNCxcblx0XHRJTlZFUlRFRDogNSxcblx0XHRDTE9TSU5HOiA2LFxuXHRcdEVMRU1FTlQ6IDcsXG5cdFx0UEFSVElBTDogOCxcblx0XHRDT01NRU5UOiA5LFxuXHRcdERFTElNQ0hBTkdFOiAxMCxcblx0XHRNVVNUQUNIRTogMTEsXG5cdFx0VEFHOiAxMixcblx0XHRBVFRSSUJVVEU6IDEzLFxuXHRcdENMT1NJTkdfVEFHOiAxNCxcblx0XHRDT01QT05FTlQ6IDE1LFxuXHRcdE5VTUJFUl9MSVRFUkFMOiAyMCxcblx0XHRTVFJJTkdfTElURVJBTDogMjEsXG5cdFx0QVJSQVlfTElURVJBTDogMjIsXG5cdFx0T0JKRUNUX0xJVEVSQUw6IDIzLFxuXHRcdEJPT0xFQU5fTElURVJBTDogMjQsXG5cdFx0R0xPQkFMOiAyNixcblx0XHRLRVlfVkFMVUVfUEFJUjogMjcsXG5cdFx0UkVGRVJFTkNFOiAzMCxcblx0XHRSRUZJTkVNRU5UOiAzMSxcblx0XHRNRU1CRVI6IDMyLFxuXHRcdFBSRUZJWF9PUEVSQVRPUjogMzMsXG5cdFx0QlJBQ0tFVEVEOiAzNCxcblx0XHRDT05ESVRJT05BTDogMzUsXG5cdFx0SU5GSVhfT1BFUkFUT1I6IDM2LFxuXHRcdElOVk9DQVRJT046IDQwLFxuXHRcdFNFQ1RJT05fSUY6IDUwLFxuXHRcdFNFQ1RJT05fVU5MRVNTOiA1MSxcblx0XHRTRUNUSU9OX0VBQ0g6IDUyLFxuXHRcdFNFQ1RJT05fV0lUSDogNTMsXG5cdFx0U0VDVElPTl9JRl9XSVRIOiA1NFxuXHR9O1xuXG5cdC8qIHV0aWxzL2NyZWF0ZS5qcyAqL1xuXHR2YXIgY3JlYXRlID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgY3JlYXRlO1xuXHRcdHRyeSB7XG5cdFx0XHRPYmplY3QuY3JlYXRlKCBudWxsICk7XG5cdFx0XHRjcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXHRcdH0gY2F0Y2ggKCBlcnIgKSB7XG5cdFx0XHQvLyBzaWdoXG5cdFx0XHRjcmVhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIEYgPSBmdW5jdGlvbigpIHt9O1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHByb3RvLCBwcm9wcyApIHtcblx0XHRcdFx0XHR2YXIgb2JqO1xuXHRcdFx0XHRcdGlmICggcHJvdG8gPT09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4ge307XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdEYucHJvdG90eXBlID0gcHJvdG87XG5cdFx0XHRcdFx0b2JqID0gbmV3IEYoKTtcblx0XHRcdFx0XHRpZiAoIHByb3BzICkge1xuXHRcdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIG9iaiwgcHJvcHMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdFx0fTtcblx0XHRcdH0oKTtcblx0XHR9XG5cdFx0cmV0dXJuIGNyZWF0ZTtcblx0fSgpO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9zaGFyZWQvZXJyb3JzLmpzICovXG5cdHZhciBwYXJzZV9QYXJzZXJfZXhwcmVzc2lvbnNfc2hhcmVkX2Vycm9ycyA9IHtcblx0XHRleHBlY3RlZEV4cHJlc3Npb246ICdFeHBlY3RlZCBhIEphdmFTY3JpcHQgZXhwcmVzc2lvbicsXG5cdFx0ZXhwZWN0ZWRQYXJlbjogJ0V4cGVjdGVkIGNsb3NpbmcgcGFyZW4nXG5cdH07XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvbGl0ZXJhbC9udW1iZXJMaXRlcmFsLmpzICovXG5cdHZhciBudW1iZXJMaXRlcmFsID0gZnVuY3Rpb24oIHR5cGVzICkge1xuXG5cdFx0dmFyIG51bWJlclBhdHRlcm4gPSAvXig/OlsrLV0/KSg/Oig/Oig/OjB8WzEtOV1cXGQqKT9cXC5cXGQrKXwoPzooPzowfFsxLTldXFxkKilcXC4pfCg/OjB8WzEtOV1cXGQqKSkoPzpbZUVdWystXT9cXGQrKT8vO1xuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHJlc3VsdDtcblx0XHRcdGlmICggcmVzdWx0ID0gcGFyc2VyLm1hdGNoUGF0dGVybiggbnVtYmVyUGF0dGVybiApICkge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHQ6IHR5cGVzLk5VTUJFUl9MSVRFUkFMLFxuXHRcdFx0XHRcdHY6IHJlc3VsdFxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0fSggdHlwZXMgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvcHJpbWFyeS9saXRlcmFsL2Jvb2xlYW5MaXRlcmFsLmpzICovXG5cdHZhciBib29sZWFuTGl0ZXJhbCA9IGZ1bmN0aW9uKCB0eXBlcyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHJlbWFpbmluZyA9IHBhcnNlci5yZW1haW5pbmcoKTtcblx0XHRcdGlmICggcmVtYWluaW5nLnN1YnN0ciggMCwgNCApID09PSAndHJ1ZScgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgKz0gNDtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR0OiB0eXBlcy5CT09MRUFOX0xJVEVSQUwsXG5cdFx0XHRcdFx0djogJ3RydWUnXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHJlbWFpbmluZy5zdWJzdHIoIDAsIDUgKSA9PT0gJ2ZhbHNlJyApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyArPSA1O1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHQ6IHR5cGVzLkJPT0xFQU5fTElURVJBTCxcblx0XHRcdFx0XHR2OiAnZmFsc2UnXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHR9KCB0eXBlcyApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L2xpdGVyYWwvc3RyaW5nTGl0ZXJhbC9tYWtlUXVvdGVkU3RyaW5nTWF0Y2hlci5qcyAqL1xuXHR2YXIgbWFrZVF1b3RlZFN0cmluZ01hdGNoZXIgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBzdHJpbmdNaWRkbGVQYXR0ZXJuLCBlc2NhcGVTZXF1ZW5jZVBhdHRlcm4sIGxpbmVDb250aW51YXRpb25QYXR0ZXJuO1xuXHRcdC8vIE1hdGNoIG9uZSBvciBtb3JlIGNoYXJhY3RlcnMgdW50aWw6IFwiLCAnLCBcXCwgb3IgRU9ML0VPRi5cblx0XHQvLyBFT0wvRU9GIGlzIHdyaXR0ZW4gYXMgKD8hLikgKG1lYW5pbmcgdGhlcmUncyBubyBub24tbmV3bGluZSBjaGFyIG5leHQpLlxuXHRcdHN0cmluZ01pZGRsZVBhdHRlcm4gPSAvXig/PS4pW15cIidcXFxcXSs/KD86KD8hLil8KD89W1wiJ1xcXFxdKSkvO1xuXHRcdC8vIE1hdGNoIG9uZSBlc2NhcGUgc2VxdWVuY2UsIGluY2x1ZGluZyB0aGUgYmFja3NsYXNoLlxuXHRcdGVzY2FwZVNlcXVlbmNlUGF0dGVybiA9IC9eXFxcXCg/OlsnXCJcXFxcYmZucnRdfDAoPyFbMC05XSl8eFswLTlhLWZBLUZdezJ9fHVbMC05YS1mQS1GXXs0fXwoPz0uKVtedXgwLTldKS87XG5cdFx0Ly8gTWF0Y2ggb25lIEVTNSBsaW5lIGNvbnRpbnVhdGlvbiAoYmFja3NsYXNoICsgbGluZSB0ZXJtaW5hdG9yKS5cblx0XHRsaW5lQ29udGludWF0aW9uUGF0dGVybiA9IC9eXFxcXCg/OlxcclxcbnxbXFx1MDAwQVxcdTAwMERcXHUyMDI4XFx1MjAyOV0pLztcblx0XHQvLyBIZWxwZXIgZm9yIGRlZmluaW5nIGdldERvdWJsZVF1b3RlZFN0cmluZyBhbmQgZ2V0U2luZ2xlUXVvdGVkU3RyaW5nLlxuXHRcdHJldHVybiBmdW5jdGlvbiggb2tRdW90ZSApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0XHR2YXIgc3RhcnQsIGxpdGVyYWwsIGRvbmUsIG5leHQ7XG5cdFx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdFx0bGl0ZXJhbCA9ICdcIic7XG5cdFx0XHRcdGRvbmUgPSBmYWxzZTtcblx0XHRcdFx0d2hpbGUgKCAhZG9uZSApIHtcblx0XHRcdFx0XHRuZXh0ID0gcGFyc2VyLm1hdGNoUGF0dGVybiggc3RyaW5nTWlkZGxlUGF0dGVybiApIHx8IHBhcnNlci5tYXRjaFBhdHRlcm4oIGVzY2FwZVNlcXVlbmNlUGF0dGVybiApIHx8IHBhcnNlci5tYXRjaFN0cmluZyggb2tRdW90ZSApO1xuXHRcdFx0XHRcdGlmICggbmV4dCApIHtcblx0XHRcdFx0XHRcdGlmICggbmV4dCA9PT0gJ1wiJyApIHtcblx0XHRcdFx0XHRcdFx0bGl0ZXJhbCArPSAnXFxcXFwiJztcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIG5leHQgPT09ICdcXFxcXFwnJyApIHtcblx0XHRcdFx0XHRcdFx0bGl0ZXJhbCArPSAnXFwnJztcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGxpdGVyYWwgKz0gbmV4dDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bmV4dCA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIGxpbmVDb250aW51YXRpb25QYXR0ZXJuICk7XG5cdFx0XHRcdFx0XHRpZiAoIG5leHQgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIGNvbnZlcnQgXFwobmV3bGluZS1saWtlKSBpbnRvIGEgXFx1IGVzY2FwZSwgd2hpY2ggaXMgYWxsb3dlZCBpbiBKU09OXG5cdFx0XHRcdFx0XHRcdGxpdGVyYWwgKz0gJ1xcXFx1JyArICggJzAwMCcgKyBuZXh0LmNoYXJDb2RlQXQoIDEgKS50b1N0cmluZyggMTYgKSApLnNsaWNlKCAtNCApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0ZG9uZSA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGxpdGVyYWwgKz0gJ1wiJztcblx0XHRcdFx0Ly8gdXNlIEpTT04ucGFyc2UgdG8gaW50ZXJwcmV0IGVzY2FwZXNcblx0XHRcdFx0cmV0dXJuIEpTT04ucGFyc2UoIGxpdGVyYWwgKTtcblx0XHRcdH07XG5cdFx0fTtcblx0fSgpO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L2xpdGVyYWwvc3RyaW5nTGl0ZXJhbC9zaW5nbGVRdW90ZWRTdHJpbmcuanMgKi9cblx0dmFyIHNpbmdsZVF1b3RlZFN0cmluZyA9IGZ1bmN0aW9uKCBtYWtlUXVvdGVkU3RyaW5nTWF0Y2hlciApIHtcblxuXHRcdHJldHVybiBtYWtlUXVvdGVkU3RyaW5nTWF0Y2hlciggJ1wiJyApO1xuXHR9KCBtYWtlUXVvdGVkU3RyaW5nTWF0Y2hlciApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L2xpdGVyYWwvc3RyaW5nTGl0ZXJhbC9kb3VibGVRdW90ZWRTdHJpbmcuanMgKi9cblx0dmFyIGRvdWJsZVF1b3RlZFN0cmluZyA9IGZ1bmN0aW9uKCBtYWtlUXVvdGVkU3RyaW5nTWF0Y2hlciApIHtcblxuXHRcdHJldHVybiBtYWtlUXVvdGVkU3RyaW5nTWF0Y2hlciggJ1xcJycgKTtcblx0fSggbWFrZVF1b3RlZFN0cmluZ01hdGNoZXIgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvcHJpbWFyeS9saXRlcmFsL3N0cmluZ0xpdGVyYWwvX3N0cmluZ0xpdGVyYWwuanMgKi9cblx0dmFyIHN0cmluZ0xpdGVyYWwgPSBmdW5jdGlvbiggdHlwZXMsIGdldFNpbmdsZVF1b3RlZFN0cmluZywgZ2V0RG91YmxlUXVvdGVkU3RyaW5nICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgc3RhcnQsIHN0cmluZztcblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnXCInICkgKSB7XG5cdFx0XHRcdHN0cmluZyA9IGdldERvdWJsZVF1b3RlZFN0cmluZyggcGFyc2VyICk7XG5cdFx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJ1wiJyApICkge1xuXHRcdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHQ6IHR5cGVzLlNUUklOR19MSVRFUkFMLFxuXHRcdFx0XHRcdHY6IHN0cmluZ1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICdcXCcnICkgKSB7XG5cdFx0XHRcdHN0cmluZyA9IGdldFNpbmdsZVF1b3RlZFN0cmluZyggcGFyc2VyICk7XG5cdFx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJ1xcJycgKSApIHtcblx0XHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR0OiB0eXBlcy5TVFJJTkdfTElURVJBTCxcblx0XHRcdFx0XHR2OiBzdHJpbmdcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdH0oIHR5cGVzLCBzaW5nbGVRdW90ZWRTdHJpbmcsIGRvdWJsZVF1b3RlZFN0cmluZyApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9zaGFyZWQvcGF0dGVybnMuanMgKi9cblx0dmFyIHBhdHRlcm5zID0ge1xuXHRcdG5hbWU6IC9eW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qL1xuXHR9O1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9zaGFyZWQva2V5LmpzICovXG5cdHZhciBrZXkgPSBmdW5jdGlvbiggZ2V0U3RyaW5nTGl0ZXJhbCwgZ2V0TnVtYmVyTGl0ZXJhbCwgcGF0dGVybnMgKSB7XG5cblx0XHR2YXIgaWRlbnRpZmllciA9IC9eW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qJC87XG5cdFx0Ly8gaHR0cDovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1wcm9wZXJ0aWVzXG5cdFx0Ly8gY2FuIGJlIGFueSBuYW1lLCBzdHJpbmcgbGl0ZXJhbCwgb3IgbnVtYmVyIGxpdGVyYWxcblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciB0b2tlbjtcblx0XHRcdGlmICggdG9rZW4gPSBnZXRTdHJpbmdMaXRlcmFsKCBwYXJzZXIgKSApIHtcblx0XHRcdFx0cmV0dXJuIGlkZW50aWZpZXIudGVzdCggdG9rZW4udiApID8gdG9rZW4udiA6ICdcIicgKyB0b2tlbi52LnJlcGxhY2UoIC9cIi9nLCAnXFxcXFwiJyApICsgJ1wiJztcblx0XHRcdH1cblx0XHRcdGlmICggdG9rZW4gPSBnZXROdW1iZXJMaXRlcmFsKCBwYXJzZXIgKSApIHtcblx0XHRcdFx0cmV0dXJuIHRva2VuLnY7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRva2VuID0gcGFyc2VyLm1hdGNoUGF0dGVybiggcGF0dGVybnMubmFtZSApICkge1xuXHRcdFx0XHRyZXR1cm4gdG9rZW47XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggc3RyaW5nTGl0ZXJhbCwgbnVtYmVyTGl0ZXJhbCwgcGF0dGVybnMgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvcHJpbWFyeS9saXRlcmFsL29iamVjdExpdGVyYWwva2V5VmFsdWVQYWlyLmpzICovXG5cdHZhciBrZXlWYWx1ZVBhaXIgPSBmdW5jdGlvbiggdHlwZXMsIGdldEtleSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBrZXksIHZhbHVlO1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZXR3ZWVuICd7JyBhbmQga2V5XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRrZXkgPSBnZXRLZXkoIHBhcnNlciApO1xuXHRcdFx0aWYgKCBrZXkgPT09IG51bGwgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJldHdlZW4ga2V5IGFuZCAnOidcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdC8vIG5leHQgY2hhcmFjdGVyIG11c3QgYmUgJzonXG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICc6JyApICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZXR3ZWVuICc6JyBhbmQgdmFsdWVcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdC8vIG5leHQgZXhwcmVzc2lvbiBtdXN0IGJlIGEsIHdlbGwuLi4gZXhwcmVzc2lvblxuXHRcdFx0dmFsdWUgPSBwYXJzZXIucmVhZEV4cHJlc3Npb24oKTtcblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR0OiB0eXBlcy5LRVlfVkFMVUVfUEFJUixcblx0XHRcdFx0azoga2V5LFxuXHRcdFx0XHR2OiB2YWx1ZVxuXHRcdFx0fTtcblx0XHR9O1xuXHR9KCB0eXBlcywga2V5ICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvbGl0ZXJhbC9vYmplY3RMaXRlcmFsL2tleVZhbHVlUGFpcnMuanMgKi9cblx0dmFyIGtleVZhbHVlUGFpcnMgPSBmdW5jdGlvbiggZ2V0S2V5VmFsdWVQYWlyICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGdldEtleVZhbHVlUGFpcnMoIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwgcGFpcnMsIHBhaXIsIGtleVZhbHVlUGFpcnM7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRwYWlyID0gZ2V0S2V5VmFsdWVQYWlyKCBwYXJzZXIgKTtcblx0XHRcdGlmICggcGFpciA9PT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRwYWlycyA9IFsgcGFpciBdO1xuXHRcdFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICcsJyApICkge1xuXHRcdFx0XHRrZXlWYWx1ZVBhaXJzID0gZ2V0S2V5VmFsdWVQYWlycyggcGFyc2VyICk7XG5cdFx0XHRcdGlmICggIWtleVZhbHVlUGFpcnMgKSB7XG5cdFx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwYWlycy5jb25jYXQoIGtleVZhbHVlUGFpcnMgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwYWlycztcblx0XHR9O1xuXHR9KCBrZXlWYWx1ZVBhaXIgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvcHJpbWFyeS9saXRlcmFsL29iamVjdExpdGVyYWwvX29iamVjdExpdGVyYWwuanMgKi9cblx0dmFyIG9iamVjdExpdGVyYWwgPSBmdW5jdGlvbiggdHlwZXMsIGdldEtleVZhbHVlUGFpcnMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwga2V5VmFsdWVQYWlycztcblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdC8vIGFsbG93IHdoaXRlc3BhY2Vcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJ3snICkgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRrZXlWYWx1ZVBhaXJzID0gZ2V0S2V5VmFsdWVQYWlycyggcGFyc2VyICk7XG5cdFx0XHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJldHdlZW4gZmluYWwgdmFsdWUgYW5kICd9J1xuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnfScgKSApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHQ6IHR5cGVzLk9CSkVDVF9MSVRFUkFMLFxuXHRcdFx0XHRtOiBrZXlWYWx1ZVBhaXJzXG5cdFx0XHR9O1xuXHRcdH07XG5cdH0oIHR5cGVzLCBrZXlWYWx1ZVBhaXJzICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3NoYXJlZC9leHByZXNzaW9uTGlzdC5qcyAqL1xuXHR2YXIgZXhwcmVzc2lvbkxpc3QgPSBmdW5jdGlvbiggZXJyb3JzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGdldEV4cHJlc3Npb25MaXN0KCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgc3RhcnQsIGV4cHJlc3Npb25zLCBleHByLCBuZXh0O1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0ZXhwciA9IHBhcnNlci5yZWFkRXhwcmVzc2lvbigpO1xuXHRcdFx0aWYgKCBleHByID09PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGV4cHJlc3Npb25zID0gWyBleHByIF07XG5cdFx0XHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJldHdlZW4gZXhwcmVzc2lvbiBhbmQgJywnXG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJywnICkgKSB7XG5cdFx0XHRcdG5leHQgPSBnZXRFeHByZXNzaW9uTGlzdCggcGFyc2VyICk7XG5cdFx0XHRcdGlmICggbmV4dCA9PT0gbnVsbCApIHtcblx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoIGVycm9ycy5leHBlY3RlZEV4cHJlc3Npb24gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRuZXh0LmZvckVhY2goIGFwcGVuZCApO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBhcHBlbmQoIGV4cHJlc3Npb24gKSB7XG5cdFx0XHRcdGV4cHJlc3Npb25zLnB1c2goIGV4cHJlc3Npb24gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBleHByZXNzaW9ucztcblx0XHR9O1xuXHR9KCBwYXJzZV9QYXJzZXJfZXhwcmVzc2lvbnNfc2hhcmVkX2Vycm9ycyApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L2xpdGVyYWwvYXJyYXlMaXRlcmFsLmpzICovXG5cdHZhciBhcnJheUxpdGVyYWwgPSBmdW5jdGlvbiggdHlwZXMsIGdldEV4cHJlc3Npb25MaXN0ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgc3RhcnQsIGV4cHJlc3Npb25MaXN0O1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZWZvcmUgJ1snXG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICdbJyApICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0ZXhwcmVzc2lvbkxpc3QgPSBnZXRFeHByZXNzaW9uTGlzdCggcGFyc2VyICk7XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICddJyApICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dDogdHlwZXMuQVJSQVlfTElURVJBTCxcblx0XHRcdFx0bTogZXhwcmVzc2lvbkxpc3Rcblx0XHRcdH07XG5cdFx0fTtcblx0fSggdHlwZXMsIGV4cHJlc3Npb25MaXN0ICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvbGl0ZXJhbC9fbGl0ZXJhbC5qcyAqL1xuXHR2YXIgbGl0ZXJhbCA9IGZ1bmN0aW9uKCBnZXROdW1iZXJMaXRlcmFsLCBnZXRCb29sZWFuTGl0ZXJhbCwgZ2V0U3RyaW5nTGl0ZXJhbCwgZ2V0T2JqZWN0TGl0ZXJhbCwgZ2V0QXJyYXlMaXRlcmFsICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgbGl0ZXJhbCA9IGdldE51bWJlckxpdGVyYWwoIHBhcnNlciApIHx8IGdldEJvb2xlYW5MaXRlcmFsKCBwYXJzZXIgKSB8fCBnZXRTdHJpbmdMaXRlcmFsKCBwYXJzZXIgKSB8fCBnZXRPYmplY3RMaXRlcmFsKCBwYXJzZXIgKSB8fCBnZXRBcnJheUxpdGVyYWwoIHBhcnNlciApO1xuXHRcdFx0cmV0dXJuIGxpdGVyYWw7XG5cdFx0fTtcblx0fSggbnVtYmVyTGl0ZXJhbCwgYm9vbGVhbkxpdGVyYWwsIHN0cmluZ0xpdGVyYWwsIG9iamVjdExpdGVyYWwsIGFycmF5TGl0ZXJhbCApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L3JlZmVyZW5jZS5qcyAqL1xuXHR2YXIgcmVmZXJlbmNlID0gZnVuY3Rpb24oIHR5cGVzLCBwYXR0ZXJucyApIHtcblxuXHRcdHZhciBkb3RSZWZpbmVtZW50UGF0dGVybiwgYXJyYXlNZW1iZXJQYXR0ZXJuLCBnZXRBcnJheVJlZmluZW1lbnQsIGdsb2JhbHMsIGtleXdvcmRzO1xuXHRcdGRvdFJlZmluZW1lbnRQYXR0ZXJuID0gL15cXC5bYS16QS1aXyQwLTldKy87XG5cdFx0Z2V0QXJyYXlSZWZpbmVtZW50ID0gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciBudW0gPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBhcnJheU1lbWJlclBhdHRlcm4gKTtcblx0XHRcdGlmICggbnVtICkge1xuXHRcdFx0XHRyZXR1cm4gJy4nICsgbnVtO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0XHRhcnJheU1lbWJlclBhdHRlcm4gPSAvXlxcWygwfFsxLTldWzAtOV0qKVxcXS87XG5cdFx0Ly8gaWYgYSByZWZlcmVuY2UgaXMgYSBicm93c2VyIGdsb2JhbCwgd2UgZG9uJ3QgZGVmZXJlbmNlIGl0IGxhdGVyLCBzbyBpdCBuZWVkcyBzcGVjaWFsIHRyZWF0bWVudFxuXHRcdGdsb2JhbHMgPSAvXig/OkFycmF5fGNvbnNvbGV8RGF0ZXxSZWdFeHB8ZGVjb2RlVVJJQ29tcG9uZW50fGRlY29kZVVSSXxlbmNvZGVVUklDb21wb25lbnR8ZW5jb2RlVVJJfGlzRmluaXRlfGlzTmFOfHBhcnNlRmxvYXR8cGFyc2VJbnR8SlNPTnxNYXRofE5hTnx1bmRlZmluZWR8bnVsbCkkLztcblx0XHQvLyBrZXl3b3JkcyBhcmUgbm90IHZhbGlkIHJlZmVyZW5jZXMsIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBgdGhpc2Bcblx0XHRrZXl3b3JkcyA9IC9eKD86YnJlYWt8Y2FzZXxjYXRjaHxjb250aW51ZXxkZWJ1Z2dlcnxkZWZhdWx0fGRlbGV0ZXxkb3xlbHNlfGZpbmFsbHl8Zm9yfGZ1bmN0aW9ufGlmfGlufGluc3RhbmNlb2Z8bmV3fHJldHVybnxzd2l0Y2h8dGhyb3d8dHJ5fHR5cGVvZnx2YXJ8dm9pZHx3aGlsZXx3aXRoKSQvO1xuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0UG9zLCBhbmNlc3RvciwgbmFtZSwgZG90LCBjb21ibywgcmVmaW5lbWVudCwgbGFzdERvdEluZGV4O1xuXHRcdFx0c3RhcnRQb3MgPSBwYXJzZXIucG9zO1xuXHRcdFx0Ly8gd2UgbWlnaHQgaGF2ZSBhIHJvb3QtbGV2ZWwgcmVmZXJlbmNlXG5cdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJ34vJyApICkge1xuXHRcdFx0XHRhbmNlc3RvciA9ICd+Lyc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyB3ZSBtaWdodCBoYXZlIGFuY2VzdG9yIHJlZnMuLi5cblx0XHRcdFx0YW5jZXN0b3IgPSAnJztcblx0XHRcdFx0d2hpbGUgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICcuLi8nICkgKSB7XG5cdFx0XHRcdFx0YW5jZXN0b3IgKz0gJy4uLyc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggIWFuY2VzdG9yICkge1xuXHRcdFx0XHQvLyB3ZSBtaWdodCBoYXZlIGFuIGltcGxpY2l0IGl0ZXJhdG9yIG9yIGEgcmVzdHJpY3RlZCByZWZlcmVuY2Vcblx0XHRcdFx0ZG90ID0gcGFyc2VyLm1hdGNoU3RyaW5nKCAnLi8nICkgfHwgcGFyc2VyLm1hdGNoU3RyaW5nKCAnLicgKSB8fCAnJztcblx0XHRcdH1cblx0XHRcdG5hbWUgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCAvXkAoPzprZXlwYXRofGluZGV4fGtleSkvICkgfHwgcGFyc2VyLm1hdGNoUGF0dGVybiggcGF0dGVybnMubmFtZSApIHx8ICcnO1xuXHRcdFx0Ly8gYnVnIG91dCBpZiBpdCdzIGEga2V5d29yZFxuXHRcdFx0aWYgKCBrZXl3b3Jkcy50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydFBvcztcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHQvLyBpZiB0aGlzIGlzIGEgYnJvd3NlciBnbG9iYWwsIHN0b3AgaGVyZVxuXHRcdFx0aWYgKCAhYW5jZXN0b3IgJiYgIWRvdCAmJiBnbG9iYWxzLnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR0OiB0eXBlcy5HTE9CQUwsXG5cdFx0XHRcdFx0djogbmFtZVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0Y29tYm8gPSAoIGFuY2VzdG9yIHx8IGRvdCApICsgbmFtZTtcblx0XHRcdGlmICggIWNvbWJvICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHdoaWxlICggcmVmaW5lbWVudCA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIGRvdFJlZmluZW1lbnRQYXR0ZXJuICkgfHwgZ2V0QXJyYXlSZWZpbmVtZW50KCBwYXJzZXIgKSApIHtcblx0XHRcdFx0Y29tYm8gKz0gcmVmaW5lbWVudDtcblx0XHRcdH1cblx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnKCcgKSApIHtcblx0XHRcdFx0Ly8gaWYgdGhpcyBpcyBhIG1ldGhvZCBpbnZvY2F0aW9uIChhcyBvcHBvc2VkIHRvIGEgZnVuY3Rpb24pIHdlIG5lZWRcblx0XHRcdFx0Ly8gdG8gc3RyaXAgdGhlIG1ldGhvZCBuYW1lIGZyb20gdGhlIHJlZmVyZW5jZSBjb21ibywgZWxzZSB0aGUgY29udGV4dFxuXHRcdFx0XHQvLyB3aWxsIGJlIHdyb25nXG5cdFx0XHRcdGxhc3REb3RJbmRleCA9IGNvbWJvLmxhc3RJbmRleE9mKCAnLicgKTtcblx0XHRcdFx0aWYgKCBsYXN0RG90SW5kZXggIT09IC0xICkge1xuXHRcdFx0XHRcdGNvbWJvID0gY29tYm8uc3Vic3RyKCAwLCBsYXN0RG90SW5kZXggKTtcblx0XHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnRQb3MgKyBjb21iby5sZW5ndGg7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cGFyc2VyLnBvcyAtPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR0OiB0eXBlcy5SRUZFUkVOQ0UsXG5cdFx0XHRcdG46IGNvbWJvLnJlcGxhY2UoIC9edGhpc1xcLi8sICcuLycgKS5yZXBsYWNlKCAvXnRoaXMkLywgJy4nIClcblx0XHRcdH07XG5cdFx0fTtcblx0fSggdHlwZXMsIHBhdHRlcm5zICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvYnJhY2tldGVkRXhwcmVzc2lvbi5qcyAqL1xuXHR2YXIgYnJhY2tldGVkRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCB0eXBlcywgZXJyb3JzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgc3RhcnQsIGV4cHI7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICcoJyApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGV4cHIgPSBwYXJzZXIucmVhZEV4cHJlc3Npb24oKTtcblx0XHRcdGlmICggIWV4cHIgKSB7XG5cdFx0XHRcdHBhcnNlci5lcnJvciggZXJyb3JzLmV4cGVjdGVkRXhwcmVzc2lvbiApO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnKScgKSApIHtcblx0XHRcdFx0cGFyc2VyLmVycm9yKCBlcnJvcnMuZXhwZWN0ZWRQYXJlbiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dDogdHlwZXMuQlJBQ0tFVEVELFxuXHRcdFx0XHR4OiBleHByXG5cdFx0XHR9O1xuXHRcdH07XG5cdH0oIHR5cGVzLCBwYXJzZV9QYXJzZXJfZXhwcmVzc2lvbnNfc2hhcmVkX2Vycm9ycyApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L19wcmltYXJ5LmpzICovXG5cdHZhciBwcmltYXJ5ID0gZnVuY3Rpb24oIGdldExpdGVyYWwsIGdldFJlZmVyZW5jZSwgZ2V0QnJhY2tldGVkRXhwcmVzc2lvbiApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0cmV0dXJuIGdldExpdGVyYWwoIHBhcnNlciApIHx8IGdldFJlZmVyZW5jZSggcGFyc2VyICkgfHwgZ2V0QnJhY2tldGVkRXhwcmVzc2lvbiggcGFyc2VyICk7XG5cdFx0fTtcblx0fSggbGl0ZXJhbCwgcmVmZXJlbmNlLCBicmFja2V0ZWRFeHByZXNzaW9uICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3NoYXJlZC9yZWZpbmVtZW50LmpzICovXG5cdHZhciByZWZpbmVtZW50ID0gZnVuY3Rpb24oIHR5cGVzLCBlcnJvcnMsIHBhdHRlcm5zICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGdldFJlZmluZW1lbnQoIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwgbmFtZSwgZXhwcjtcblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdC8vIFwiLlwiIG5hbWVcblx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnLicgKSApIHtcblx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRpZiAoIG5hbWUgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBwYXR0ZXJucy5uYW1lICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdHQ6IHR5cGVzLlJFRklORU1FTlQsXG5cdFx0XHRcdFx0XHRuOiBuYW1lXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwYXJzZXIuZXJyb3IoICdFeHBlY3RlZCBhIHByb3BlcnR5IG5hbWUnICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBcIltcIiBleHByZXNzaW9uIFwiXVwiXG5cdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJ1snICkgKSB7XG5cdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0ZXhwciA9IHBhcnNlci5yZWFkRXhwcmVzc2lvbigpO1xuXHRcdFx0XHRpZiAoICFleHByICkge1xuXHRcdFx0XHRcdHBhcnNlci5lcnJvciggZXJyb3JzLmV4cGVjdGVkRXhwcmVzc2lvbiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnXScgKSApIHtcblx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoICdFeHBlY3RlZCBcXCddXFwnJyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dDogdHlwZXMuUkVGSU5FTUVOVCxcblx0XHRcdFx0XHR4OiBleHByXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHR9KCB0eXBlcywgcGFyc2VfUGFyc2VyX2V4cHJlc3Npb25zX3NoYXJlZF9lcnJvcnMsIHBhdHRlcm5zICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL21lbWJlck9ySW52b2NhdGlvbi5qcyAqL1xuXHR2YXIgbWVtYmVyT3JJbnZvY2F0aW9uID0gZnVuY3Rpb24oIHR5cGVzLCBnZXRQcmltYXJ5LCBnZXRFeHByZXNzaW9uTGlzdCwgZ2V0UmVmaW5lbWVudCwgZXJyb3JzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgY3VycmVudCwgZXhwcmVzc2lvbiwgcmVmaW5lbWVudCwgZXhwcmVzc2lvbkxpc3Q7XG5cdFx0XHRleHByZXNzaW9uID0gZ2V0UHJpbWFyeSggcGFyc2VyICk7XG5cdFx0XHRpZiAoICFleHByZXNzaW9uICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHdoaWxlICggZXhwcmVzc2lvbiApIHtcblx0XHRcdFx0Y3VycmVudCA9IHBhcnNlci5wb3M7XG5cdFx0XHRcdGlmICggcmVmaW5lbWVudCA9IGdldFJlZmluZW1lbnQoIHBhcnNlciApICkge1xuXHRcdFx0XHRcdGV4cHJlc3Npb24gPSB7XG5cdFx0XHRcdFx0XHR0OiB0eXBlcy5NRU1CRVIsXG5cdFx0XHRcdFx0XHR4OiBleHByZXNzaW9uLFxuXHRcdFx0XHRcdFx0cjogcmVmaW5lbWVudFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0gZWxzZSBpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJygnICkgKSB7XG5cdFx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRcdGV4cHJlc3Npb25MaXN0ID0gZ2V0RXhwcmVzc2lvbkxpc3QoIHBhcnNlciApO1xuXHRcdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICcpJyApICkge1xuXHRcdFx0XHRcdFx0cGFyc2VyLmVycm9yKCBlcnJvcnMuZXhwZWN0ZWRQYXJlbiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRleHByZXNzaW9uID0ge1xuXHRcdFx0XHRcdFx0dDogdHlwZXMuSU5WT0NBVElPTixcblx0XHRcdFx0XHRcdHg6IGV4cHJlc3Npb25cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGlmICggZXhwcmVzc2lvbkxpc3QgKSB7XG5cdFx0XHRcdFx0XHRleHByZXNzaW9uLm8gPSBleHByZXNzaW9uTGlzdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBleHByZXNzaW9uO1xuXHRcdH07XG5cdH0oIHR5cGVzLCBwcmltYXJ5LCBleHByZXNzaW9uTGlzdCwgcmVmaW5lbWVudCwgcGFyc2VfUGFyc2VyX2V4cHJlc3Npb25zX3NoYXJlZF9lcnJvcnMgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvdHlwZW9mLmpzICovXG5cdHZhciBfdHlwZW9mID0gZnVuY3Rpb24oIHR5cGVzLCBlcnJvcnMsIGdldE1lbWJlck9ySW52b2NhdGlvbiApIHtcblxuXHRcdHZhciBnZXRUeXBlb2YsIG1ha2VQcmVmaXhTZXF1ZW5jZU1hdGNoZXI7XG5cdFx0bWFrZVByZWZpeFNlcXVlbmNlTWF0Y2hlciA9IGZ1bmN0aW9uKCBzeW1ib2wsIGZhbGx0aHJvdWdoICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHRcdHZhciBleHByZXNzaW9uO1xuXHRcdFx0XHRpZiAoIGV4cHJlc3Npb24gPSBmYWxsdGhyb3VnaCggcGFyc2VyICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGV4cHJlc3Npb247XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCBzeW1ib2wgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdGV4cHJlc3Npb24gPSBwYXJzZXIucmVhZEV4cHJlc3Npb24oKTtcblx0XHRcdFx0aWYgKCAhZXhwcmVzc2lvbiApIHtcblx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoIGVycm9ycy5leHBlY3RlZEV4cHJlc3Npb24gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHM6IHN5bWJvbCxcblx0XHRcdFx0XHRvOiBleHByZXNzaW9uLFxuXHRcdFx0XHRcdHQ6IHR5cGVzLlBSRUZJWF9PUEVSQVRPUlxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdC8vIGNyZWF0ZSBhbGwgcHJlZml4IHNlcXVlbmNlIG1hdGNoZXJzLCByZXR1cm4gZ2V0VHlwZW9mXG5cdFx0KCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpLCBsZW4sIG1hdGNoZXIsIHByZWZpeE9wZXJhdG9ycywgZmFsbHRocm91Z2g7XG5cdFx0XHRwcmVmaXhPcGVyYXRvcnMgPSAnISB+ICsgLSB0eXBlb2YnLnNwbGl0KCAnICcgKTtcblx0XHRcdGZhbGx0aHJvdWdoID0gZ2V0TWVtYmVyT3JJbnZvY2F0aW9uO1xuXHRcdFx0Zm9yICggaSA9IDAsIGxlbiA9IHByZWZpeE9wZXJhdG9ycy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0bWF0Y2hlciA9IG1ha2VQcmVmaXhTZXF1ZW5jZU1hdGNoZXIoIHByZWZpeE9wZXJhdG9yc1sgaSBdLCBmYWxsdGhyb3VnaCApO1xuXHRcdFx0XHRmYWxsdGhyb3VnaCA9IG1hdGNoZXI7XG5cdFx0XHR9XG5cdFx0XHQvLyB0eXBlb2Ygb3BlcmF0b3IgaXMgaGlnaGVyIHByZWNlZGVuY2UgdGhhbiBtdWx0aXBsaWNhdGlvbiwgc28gcHJvdmlkZXMgdGhlXG5cdFx0XHQvLyBmYWxsdGhyb3VnaCBmb3IgdGhlIG11bHRpcGxpY2F0aW9uIHNlcXVlbmNlIG1hdGNoZXIgd2UncmUgYWJvdXQgdG8gY3JlYXRlXG5cdFx0XHQvLyAod2UncmUgc2tpcHBpbmcgdm9pZCBhbmQgZGVsZXRlKVxuXHRcdFx0Z2V0VHlwZW9mID0gZmFsbHRocm91Z2g7XG5cdFx0fSgpICk7XG5cdFx0cmV0dXJuIGdldFR5cGVvZjtcblx0fSggdHlwZXMsIHBhcnNlX1BhcnNlcl9leHByZXNzaW9uc19zaGFyZWRfZXJyb3JzLCBtZW1iZXJPckludm9jYXRpb24gKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvbG9naWNhbE9yLmpzICovXG5cdHZhciBsb2dpY2FsT3IgPSBmdW5jdGlvbiggdHlwZXMsIGdldFR5cGVvZiApIHtcblxuXHRcdHZhciBnZXRMb2dpY2FsT3IsIG1ha2VJbmZpeFNlcXVlbmNlTWF0Y2hlcjtcblx0XHRtYWtlSW5maXhTZXF1ZW5jZU1hdGNoZXIgPSBmdW5jdGlvbiggc3ltYm9sLCBmYWxsdGhyb3VnaCApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0XHR2YXIgc3RhcnQsIGxlZnQsIHJpZ2h0O1xuXHRcdFx0XHRsZWZ0ID0gZmFsbHRocm91Z2goIHBhcnNlciApO1xuXHRcdFx0XHRpZiAoICFsZWZ0ICkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIExvb3AgdG8gaGFuZGxlIGxlZnQtcmVjdXJzaW9uIGluIGEgY2FzZSBsaWtlIGBhICogYiAqIGNgIGFuZCBwcm9kdWNlXG5cdFx0XHRcdC8vIGxlZnQgYXNzb2NpYXRpb24sIGkuZS4gYChhICogYikgKiBjYC4gIFRoZSBtYXRjaGVyIGNhbid0IGNhbGwgaXRzZWxmXG5cdFx0XHRcdC8vIHRvIHBhcnNlIGBsZWZ0YCBiZWNhdXNlIHRoYXQgd291bGQgYmUgaW5maW5pdGUgcmVncmVzcy5cblx0XHRcdFx0d2hpbGUgKCB0cnVlICkge1xuXHRcdFx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCBzeW1ib2wgKSApIHtcblx0XHRcdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0XHRcdHJldHVybiBsZWZ0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBpbiBvcGVyYXRvciBtdXN0IG5vdCBiZSBmb2xsb3dlZCBieSBbYS16QS1aXyQwLTldXG5cdFx0XHRcdFx0aWYgKCBzeW1ib2wgPT09ICdpbicgJiYgL1thLXpBLVpfJDAtOV0vLnRlc3QoIHBhcnNlci5yZW1haW5pbmcoKS5jaGFyQXQoIDAgKSApICkge1xuXHRcdFx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGxlZnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0XHQvLyByaWdodCBvcGVyYW5kIG11c3QgYWxzbyBjb25zaXN0IG9mIG9ubHkgaGlnaGVyLXByZWNlZGVuY2Ugb3BlcmF0b3JzXG5cdFx0XHRcdFx0cmlnaHQgPSBmYWxsdGhyb3VnaCggcGFyc2VyICk7XG5cdFx0XHRcdFx0aWYgKCAhcmlnaHQgKSB7XG5cdFx0XHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbGVmdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bGVmdCA9IHtcblx0XHRcdFx0XHRcdHQ6IHR5cGVzLklORklYX09QRVJBVE9SLFxuXHRcdFx0XHRcdFx0czogc3ltYm9sLFxuXHRcdFx0XHRcdFx0bzogW1xuXHRcdFx0XHRcdFx0XHRsZWZ0LFxuXHRcdFx0XHRcdFx0XHRyaWdodFxuXHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fTtcblx0XHQvLyBjcmVhdGUgYWxsIGluZml4IHNlcXVlbmNlIG1hdGNoZXJzLCBhbmQgcmV0dXJuIGdldExvZ2ljYWxPclxuXHRcdCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSwgbGVuLCBtYXRjaGVyLCBpbmZpeE9wZXJhdG9ycywgZmFsbHRocm91Z2g7XG5cdFx0XHQvLyBBbGwgdGhlIGluZml4IG9wZXJhdG9ycyBvbiBvcmRlciBvZiBwcmVjZWRlbmNlIChzb3VyY2U6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL09wZXJhdG9yX1ByZWNlZGVuY2UpXG5cdFx0XHQvLyBFYWNoIHNlcXVlbmNlIG1hdGNoZXIgd2lsbCBpbml0aWFsbHkgZmFsbCB0aHJvdWdoIHRvIGl0cyBoaWdoZXIgcHJlY2VkZW5jZVxuXHRcdFx0Ly8gbmVpZ2hib3VyLCBhbmQgb25seSBhdHRlbXB0IHRvIG1hdGNoIGlmIG9uZSBvZiB0aGUgaGlnaGVyIHByZWNlZGVuY2Ugb3BlcmF0b3JzXG5cdFx0XHQvLyAob3IsIHVsdGltYXRlbHksIGEgbGl0ZXJhbCwgcmVmZXJlbmNlLCBvciBicmFja2V0ZWQgZXhwcmVzc2lvbikgYWxyZWFkeSBtYXRjaGVkXG5cdFx0XHRpbmZpeE9wZXJhdG9ycyA9ICcqIC8gJSArIC0gPDwgPj4gPj4+IDwgPD0gPiA+PSBpbiBpbnN0YW5jZW9mID09ICE9ID09PSAhPT0gJiBeIHwgJiYgfHwnLnNwbGl0KCAnICcgKTtcblx0XHRcdC8vIEEgdHlwZW9mIG9wZXJhdG9yIGlzIGhpZ2hlciBwcmVjZWRlbmNlIHRoYW4gbXVsdGlwbGljYXRpb25cblx0XHRcdGZhbGx0aHJvdWdoID0gZ2V0VHlwZW9mO1xuXHRcdFx0Zm9yICggaSA9IDAsIGxlbiA9IGluZml4T3BlcmF0b3JzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRtYXRjaGVyID0gbWFrZUluZml4U2VxdWVuY2VNYXRjaGVyKCBpbmZpeE9wZXJhdG9yc1sgaSBdLCBmYWxsdGhyb3VnaCApO1xuXHRcdFx0XHRmYWxsdGhyb3VnaCA9IG1hdGNoZXI7XG5cdFx0XHR9XG5cdFx0XHQvLyBMb2dpY2FsIE9SIGlzIHRoZSBmYWxsdGhyb3VnaCBmb3IgdGhlIGNvbmRpdGlvbmFsIG1hdGNoZXJcblx0XHRcdGdldExvZ2ljYWxPciA9IGZhbGx0aHJvdWdoO1xuXHRcdH0oKSApO1xuXHRcdHJldHVybiBnZXRMb2dpY2FsT3I7XG5cdH0oIHR5cGVzLCBfdHlwZW9mICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL2NvbmRpdGlvbmFsLmpzICovXG5cdHZhciBjb25kaXRpb25hbCA9IGZ1bmN0aW9uKCB0eXBlcywgZ2V0TG9naWNhbE9yLCBlcnJvcnMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwgZXhwcmVzc2lvbiwgaWZUcnVlLCBpZkZhbHNlO1xuXHRcdFx0ZXhwcmVzc2lvbiA9IGdldExvZ2ljYWxPciggcGFyc2VyICk7XG5cdFx0XHRpZiAoICFleHByZXNzaW9uICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJz8nICkgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIGV4cHJlc3Npb247XG5cdFx0XHR9XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRpZlRydWUgPSBwYXJzZXIucmVhZEV4cHJlc3Npb24oKTtcblx0XHRcdGlmICggIWlmVHJ1ZSApIHtcblx0XHRcdFx0cGFyc2VyLmVycm9yKCBlcnJvcnMuZXhwZWN0ZWRFeHByZXNzaW9uICk7XG5cdFx0XHR9XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICc6JyApICkge1xuXHRcdFx0XHRwYXJzZXIuZXJyb3IoICdFeHBlY3RlZCBcIjpcIicgKTtcblx0XHRcdH1cblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmRmFsc2UgPSBwYXJzZXIucmVhZEV4cHJlc3Npb24oKTtcblx0XHRcdGlmICggIWlmRmFsc2UgKSB7XG5cdFx0XHRcdHBhcnNlci5lcnJvciggZXJyb3JzLmV4cGVjdGVkRXhwcmVzc2lvbiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dDogdHlwZXMuQ09ORElUSU9OQUwsXG5cdFx0XHRcdG86IFtcblx0XHRcdFx0XHRleHByZXNzaW9uLFxuXHRcdFx0XHRcdGlmVHJ1ZSxcblx0XHRcdFx0XHRpZkZhbHNlXG5cdFx0XHRcdF1cblx0XHRcdH07XG5cdFx0fTtcblx0fSggdHlwZXMsIGxvZ2ljYWxPciwgcGFyc2VfUGFyc2VyX2V4cHJlc3Npb25zX3NoYXJlZF9lcnJvcnMgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvdXRpbHMvZmxhdHRlbkV4cHJlc3Npb24uanMgKi9cblx0dmFyIGZsYXR0ZW5FeHByZXNzaW9uID0gZnVuY3Rpb24oIHR5cGVzLCBpc09iamVjdCApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uKCBleHByZXNzaW9uICkge1xuXHRcdFx0dmFyIHJlZnMgPSBbXSxcblx0XHRcdFx0ZmxhdHRlbmVkO1xuXHRcdFx0ZXh0cmFjdFJlZnMoIGV4cHJlc3Npb24sIHJlZnMgKTtcblx0XHRcdGZsYXR0ZW5lZCA9IHtcblx0XHRcdFx0cjogcmVmcyxcblx0XHRcdFx0czogc3RyaW5naWZ5KCB0aGlzLCBleHByZXNzaW9uLCByZWZzIClcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gZmxhdHRlbmVkO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBxdW90ZVN0cmluZ0xpdGVyYWwoIHN0ciApIHtcblx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSggU3RyaW5nKCBzdHIgKSApO1xuXHRcdH1cblx0XHQvLyBUT0RPIG1heWJlIHJlZmFjdG9yIHRoaXM/XG5cdFx0ZnVuY3Rpb24gZXh0cmFjdFJlZnMoIG5vZGUsIHJlZnMgKSB7XG5cdFx0XHR2YXIgaSwgbGlzdDtcblx0XHRcdGlmICggbm9kZS50ID09PSB0eXBlcy5SRUZFUkVOQ0UgKSB7XG5cdFx0XHRcdGlmICggcmVmcy5pbmRleE9mKCBub2RlLm4gKSA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0cmVmcy51bnNoaWZ0KCBub2RlLm4gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bGlzdCA9IG5vZGUubyB8fCBub2RlLm07XG5cdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdGlmICggaXNPYmplY3QoIGxpc3QgKSApIHtcblx0XHRcdFx0XHRleHRyYWN0UmVmcyggbGlzdCwgcmVmcyApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGkgPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGV4dHJhY3RSZWZzKCBsaXN0WyBpIF0sIHJlZnMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggbm9kZS54ICkge1xuXHRcdFx0XHRleHRyYWN0UmVmcyggbm9kZS54LCByZWZzICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG5vZGUuciApIHtcblx0XHRcdFx0ZXh0cmFjdFJlZnMoIG5vZGUuciwgcmVmcyApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBub2RlLnYgKSB7XG5cdFx0XHRcdGV4dHJhY3RSZWZzKCBub2RlLnYsIHJlZnMgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzdHJpbmdpZnkoIHBhcnNlciwgbm9kZSwgcmVmcyApIHtcblx0XHRcdHZhciBzdHJpbmdpZnlBbGwgPSBmdW5jdGlvbiggaXRlbSApIHtcblx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeSggcGFyc2VyLCBpdGVtLCByZWZzICk7XG5cdFx0XHR9O1xuXHRcdFx0c3dpdGNoICggbm9kZS50ICkge1xuXHRcdFx0XHRjYXNlIHR5cGVzLkJPT0xFQU5fTElURVJBTDpcblx0XHRcdFx0Y2FzZSB0eXBlcy5HTE9CQUw6XG5cdFx0XHRcdGNhc2UgdHlwZXMuTlVNQkVSX0xJVEVSQUw6XG5cdFx0XHRcdFx0cmV0dXJuIG5vZGUudjtcblx0XHRcdFx0Y2FzZSB0eXBlcy5TVFJJTkdfTElURVJBTDpcblx0XHRcdFx0XHRyZXR1cm4gcXVvdGVTdHJpbmdMaXRlcmFsKCBub2RlLnYgKTtcblx0XHRcdFx0Y2FzZSB0eXBlcy5BUlJBWV9MSVRFUkFMOlxuXHRcdFx0XHRcdHJldHVybiAnWycgKyAoIG5vZGUubSA/IG5vZGUubS5tYXAoIHN0cmluZ2lmeUFsbCApLmpvaW4oICcsJyApIDogJycgKSArICddJztcblx0XHRcdFx0Y2FzZSB0eXBlcy5PQkpFQ1RfTElURVJBTDpcblx0XHRcdFx0XHRyZXR1cm4gJ3snICsgKCBub2RlLm0gPyBub2RlLm0ubWFwKCBzdHJpbmdpZnlBbGwgKS5qb2luKCAnLCcgKSA6ICcnICkgKyAnfSc7XG5cdFx0XHRcdGNhc2UgdHlwZXMuS0VZX1ZBTFVFX1BBSVI6XG5cdFx0XHRcdFx0cmV0dXJuIG5vZGUuayArICc6JyArIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLnYsIHJlZnMgKTtcblx0XHRcdFx0Y2FzZSB0eXBlcy5QUkVGSVhfT1BFUkFUT1I6XG5cdFx0XHRcdFx0cmV0dXJuICggbm9kZS5zID09PSAndHlwZW9mJyA/ICd0eXBlb2YgJyA6IG5vZGUucyApICsgc3RyaW5naWZ5KCBwYXJzZXIsIG5vZGUubywgcmVmcyApO1xuXHRcdFx0XHRjYXNlIHR5cGVzLklORklYX09QRVJBVE9SOlxuXHRcdFx0XHRcdHJldHVybiBzdHJpbmdpZnkoIHBhcnNlciwgbm9kZS5vWyAwIF0sIHJlZnMgKSArICggbm9kZS5zLnN1YnN0ciggMCwgMiApID09PSAnaW4nID8gJyAnICsgbm9kZS5zICsgJyAnIDogbm9kZS5zICkgKyBzdHJpbmdpZnkoIHBhcnNlciwgbm9kZS5vWyAxIF0sIHJlZnMgKTtcblx0XHRcdFx0Y2FzZSB0eXBlcy5JTlZPQ0FUSU9OOlxuXHRcdFx0XHRcdHJldHVybiBzdHJpbmdpZnkoIHBhcnNlciwgbm9kZS54LCByZWZzICkgKyAnKCcgKyAoIG5vZGUubyA/IG5vZGUuby5tYXAoIHN0cmluZ2lmeUFsbCApLmpvaW4oICcsJyApIDogJycgKSArICcpJztcblx0XHRcdFx0Y2FzZSB0eXBlcy5CUkFDS0VURUQ6XG5cdFx0XHRcdFx0cmV0dXJuICcoJyArIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLngsIHJlZnMgKSArICcpJztcblx0XHRcdFx0Y2FzZSB0eXBlcy5NRU1CRVI6XG5cdFx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLngsIHJlZnMgKSArIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLnIsIHJlZnMgKTtcblx0XHRcdFx0Y2FzZSB0eXBlcy5SRUZJTkVNRU5UOlxuXHRcdFx0XHRcdHJldHVybiBub2RlLm4gPyAnLicgKyBub2RlLm4gOiAnWycgKyBzdHJpbmdpZnkoIHBhcnNlciwgbm9kZS54LCByZWZzICkgKyAnXSc7XG5cdFx0XHRcdGNhc2UgdHlwZXMuQ09ORElUSU9OQUw6XG5cdFx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLm9bIDAgXSwgcmVmcyApICsgJz8nICsgc3RyaW5naWZ5KCBwYXJzZXIsIG5vZGUub1sgMSBdLCByZWZzICkgKyAnOicgKyBzdHJpbmdpZnkoIHBhcnNlciwgbm9kZS5vWyAyIF0sIHJlZnMgKTtcblx0XHRcdFx0Y2FzZSB0eXBlcy5SRUZFUkVOQ0U6XG5cdFx0XHRcdFx0cmV0dXJuICdfJyArIHJlZnMuaW5kZXhPZiggbm9kZS5uICk7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0cGFyc2VyLmVycm9yKCAnRXhwZWN0ZWQgbGVnYWwgSmF2YVNjcmlwdCcgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCB0eXBlcywgaXNPYmplY3QgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvX1BhcnNlci5qcyAqL1xuXHR2YXIgUGFyc2VyID0gZnVuY3Rpb24oIGNpcmN1bGFyLCBjcmVhdGUsIGhhc093blByb3BlcnR5LCBnZXRDb25kaXRpb25hbCwgZmxhdHRlbkV4cHJlc3Npb24gKSB7XG5cblx0XHR2YXIgUGFyc2VyLCBQYXJzZUVycm9yLCBsZWFkaW5nV2hpdGVzcGFjZSA9IC9eXFxzKy87XG5cdFx0UGFyc2VFcnJvciA9IGZ1bmN0aW9uKCBtZXNzYWdlICkge1xuXHRcdFx0dGhpcy5uYW1lID0gJ1BhcnNlRXJyb3InO1xuXHRcdFx0dGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggbWVzc2FnZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdHRoaXMuc3RhY2sgPSBlLnN0YWNrO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0UGFyc2VFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cdFx0UGFyc2VyID0gZnVuY3Rpb24oIHN0ciwgb3B0aW9ucyApIHtcblx0XHRcdHZhciBpdGVtcywgaXRlbSwgbGluZVN0YXJ0ID0gMDtcblx0XHRcdHRoaXMuc3RyID0gc3RyO1xuXHRcdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRcdHRoaXMucG9zID0gMDtcblx0XHRcdHRoaXMubGluZXMgPSB0aGlzLnN0ci5zcGxpdCggJ1xcbicgKTtcblx0XHRcdHRoaXMubGluZUVuZHMgPSB0aGlzLmxpbmVzLm1hcCggZnVuY3Rpb24oIGxpbmUgKSB7XG5cdFx0XHRcdHZhciBsaW5lRW5kID0gbGluZVN0YXJ0ICsgbGluZS5sZW5ndGggKyAxO1xuXHRcdFx0XHQvLyArMSBmb3IgdGhlIG5ld2xpbmVcblx0XHRcdFx0bGluZVN0YXJ0ID0gbGluZUVuZDtcblx0XHRcdFx0cmV0dXJuIGxpbmVFbmQ7XG5cdFx0XHR9LCAwICk7XG5cdFx0XHQvLyBDdXN0b20gaW5pdCBsb2dpY1xuXHRcdFx0aWYgKCB0aGlzLmluaXQgKVxuXHRcdFx0XHR0aGlzLmluaXQoIHN0ciwgb3B0aW9ucyApO1xuXHRcdFx0aXRlbXMgPSBbXTtcblx0XHRcdHdoaWxlICggdGhpcy5wb3MgPCB0aGlzLnN0ci5sZW5ndGggJiYgKCBpdGVtID0gdGhpcy5yZWFkKCkgKSApIHtcblx0XHRcdFx0aXRlbXMucHVzaCggaXRlbSApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5sZWZ0b3ZlciA9IHRoaXMucmVtYWluaW5nKCk7XG5cdFx0XHR0aGlzLnJlc3VsdCA9IHRoaXMucG9zdFByb2Nlc3MgPyB0aGlzLnBvc3RQcm9jZXNzKCBpdGVtcywgb3B0aW9ucyApIDogaXRlbXM7XG5cdFx0fTtcblx0XHRQYXJzZXIucHJvdG90eXBlID0ge1xuXHRcdFx0cmVhZDogZnVuY3Rpb24oIGNvbnZlcnRlcnMgKSB7XG5cdFx0XHRcdHZhciBwb3MsIGksIGxlbiwgaXRlbTtcblx0XHRcdFx0aWYgKCAhY29udmVydGVycyApXG5cdFx0XHRcdFx0Y29udmVydGVycyA9IHRoaXMuY29udmVydGVycztcblx0XHRcdFx0cG9zID0gdGhpcy5wb3M7XG5cdFx0XHRcdGxlbiA9IGNvbnZlcnRlcnMubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRcdHRoaXMucG9zID0gcG9zO1xuXHRcdFx0XHRcdC8vIHJlc2V0IGZvciBlYWNoIGF0dGVtcHRcblx0XHRcdFx0XHRpZiAoIGl0ZW0gPSBjb252ZXJ0ZXJzWyBpIF0oIHRoaXMgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBpdGVtO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH0sXG5cdFx0XHRyZWFkRXhwcmVzc2lvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIFRoZSBjb25kaXRpb25hbCBvcGVyYXRvciBpcyB0aGUgbG93ZXN0IHByZWNlZGVuY2Ugb3BlcmF0b3IgKGV4Y2VwdCB5aWVsZCxcblx0XHRcdFx0Ly8gYXNzaWdubWVudCBvcGVyYXRvcnMsIGFuZCBjb21tYXMsIG5vbmUgb2Ygd2hpY2ggYXJlIHN1cHBvcnRlZCksIHNvIHdlXG5cdFx0XHRcdC8vIHN0YXJ0IHRoZXJlLiBJZiBpdCBkb2Vzbid0IG1hdGNoLCBpdCAnZmFsbHMgdGhyb3VnaCcgdG8gcHJvZ3Jlc3NpdmVseVxuXHRcdFx0XHQvLyBoaWdoZXIgcHJlY2VkZW5jZSBvcGVyYXRvcnMsIHVudGlsIGl0IGV2ZW50dWFsbHkgbWF0Y2hlcyAob3IgZmFpbHMgdG9cblx0XHRcdFx0Ly8gbWF0Y2gpIGEgJ3ByaW1hcnknIC0gYSBsaXRlcmFsIG9yIGEgcmVmZXJlbmNlLiBUaGlzIHdheSwgdGhlIGFic3RyYWN0IHN5bnRheFxuXHRcdFx0XHQvLyB0cmVlIGhhcyBldmVyeXRoaW5nIGluIGl0cyBwcm9wZXIgcGxhY2UsIGkuZS4gMiArIDMgKiA0ID09PSAxNCwgbm90IDIwLlxuXHRcdFx0XHRyZXR1cm4gZ2V0Q29uZGl0aW9uYWwoIHRoaXMgKTtcblx0XHRcdH0sXG5cdFx0XHRmbGF0dGVuRXhwcmVzc2lvbjogZmxhdHRlbkV4cHJlc3Npb24sXG5cdFx0XHRnZXRMaW5lUG9zOiBmdW5jdGlvbiggY2hhciApIHtcblx0XHRcdFx0dmFyIGxpbmVOdW0gPSAwLFxuXHRcdFx0XHRcdGxpbmVTdGFydCA9IDAsXG5cdFx0XHRcdFx0Y29sdW1uTnVtO1xuXHRcdFx0XHR3aGlsZSAoIGNoYXIgPj0gdGhpcy5saW5lRW5kc1sgbGluZU51bSBdICkge1xuXHRcdFx0XHRcdGxpbmVTdGFydCA9IHRoaXMubGluZUVuZHNbIGxpbmVOdW0gXTtcblx0XHRcdFx0XHRsaW5lTnVtICs9IDE7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29sdW1uTnVtID0gY2hhciAtIGxpbmVTdGFydDtcblx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHRsaW5lTnVtICsgMSxcblx0XHRcdFx0XHRjb2x1bW5OdW0gKyAxLFxuXHRcdFx0XHRcdGNoYXJcblx0XHRcdFx0XTtcblx0XHRcdH0sXG5cdFx0XHRlcnJvcjogZnVuY3Rpb24oIG1lc3NhZ2UgKSB7XG5cdFx0XHRcdHZhciBwb3MsIGxpbmVOdW0sIGNvbHVtbk51bSwgbGluZSwgYW5ub3RhdGlvbiwgZXJyb3I7XG5cdFx0XHRcdHBvcyA9IHRoaXMuZ2V0TGluZVBvcyggdGhpcy5wb3MgKTtcblx0XHRcdFx0bGluZU51bSA9IHBvc1sgMCBdO1xuXHRcdFx0XHRjb2x1bW5OdW0gPSBwb3NbIDEgXTtcblx0XHRcdFx0bGluZSA9IHRoaXMubGluZXNbIHBvc1sgMCBdIC0gMSBdO1xuXHRcdFx0XHRhbm5vdGF0aW9uID0gbGluZSArICdcXG4nICsgbmV3IEFycmF5KCBwb3NbIDEgXSApLmpvaW4oICcgJyApICsgJ14tLS0tJztcblx0XHRcdFx0ZXJyb3IgPSBuZXcgUGFyc2VFcnJvciggbWVzc2FnZSArICcgYXQgbGluZSAnICsgbGluZU51bSArICcgY2hhcmFjdGVyICcgKyBjb2x1bW5OdW0gKyAnOlxcbicgKyBhbm5vdGF0aW9uICk7XG5cdFx0XHRcdGVycm9yLmxpbmUgPSBwb3NbIDAgXTtcblx0XHRcdFx0ZXJyb3IuY2hhcmFjdGVyID0gcG9zWyAxIF07XG5cdFx0XHRcdGVycm9yLnNob3J0TWVzc2FnZSA9IG1lc3NhZ2U7XG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fSxcblx0XHRcdG1hdGNoU3RyaW5nOiBmdW5jdGlvbiggc3RyaW5nICkge1xuXHRcdFx0XHRpZiAoIHRoaXMuc3RyLnN1YnN0ciggdGhpcy5wb3MsIHN0cmluZy5sZW5ndGggKSA9PT0gc3RyaW5nICkge1xuXHRcdFx0XHRcdHRoaXMucG9zICs9IHN0cmluZy5sZW5ndGg7XG5cdFx0XHRcdFx0cmV0dXJuIHN0cmluZztcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdG1hdGNoUGF0dGVybjogZnVuY3Rpb24oIHBhdHRlcm4gKSB7XG5cdFx0XHRcdHZhciBtYXRjaDtcblx0XHRcdFx0aWYgKCBtYXRjaCA9IHBhdHRlcm4uZXhlYyggdGhpcy5yZW1haW5pbmcoKSApICkge1xuXHRcdFx0XHRcdHRoaXMucG9zICs9IG1hdGNoWyAwIF0ubGVuZ3RoO1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaFsgMSBdIHx8IG1hdGNoWyAwIF07XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRhbGxvd1doaXRlc3BhY2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLm1hdGNoUGF0dGVybiggbGVhZGluZ1doaXRlc3BhY2UgKTtcblx0XHRcdH0sXG5cdFx0XHRyZW1haW5pbmc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5zdHIuc3Vic3RyaW5nKCB0aGlzLnBvcyApO1xuXHRcdFx0fSxcblx0XHRcdG5leHRDaGFyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuc3RyLmNoYXJBdCggdGhpcy5wb3MgKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdFBhcnNlci5leHRlbmQgPSBmdW5jdGlvbiggcHJvdG8gKSB7XG5cdFx0XHR2YXIgUGFyZW50ID0gdGhpcyxcblx0XHRcdFx0Q2hpbGQsIGtleTtcblx0XHRcdENoaWxkID0gZnVuY3Rpb24oIHN0ciwgb3B0aW9ucyApIHtcblx0XHRcdFx0UGFyc2VyLmNhbGwoIHRoaXMsIHN0ciwgb3B0aW9ucyApO1xuXHRcdFx0fTtcblx0XHRcdENoaWxkLnByb3RvdHlwZSA9IGNyZWF0ZSggUGFyZW50LnByb3RvdHlwZSApO1xuXHRcdFx0Zm9yICgga2V5IGluIHByb3RvICkge1xuXHRcdFx0XHRpZiAoIGhhc093blByb3BlcnR5LmNhbGwoIHByb3RvLCBrZXkgKSApIHtcblx0XHRcdFx0XHRDaGlsZC5wcm90b3R5cGVbIGtleSBdID0gcHJvdG9bIGtleSBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRDaGlsZC5leHRlbmQgPSBQYXJzZXIuZXh0ZW5kO1xuXHRcdFx0cmV0dXJuIENoaWxkO1xuXHRcdH07XG5cdFx0Y2lyY3VsYXIuUGFyc2VyID0gUGFyc2VyO1xuXHRcdHJldHVybiBQYXJzZXI7XG5cdH0oIGNpcmN1bGFyLCBjcmVhdGUsIGhhc093biwgY29uZGl0aW9uYWwsIGZsYXR0ZW5FeHByZXNzaW9uICk7XG5cblx0LyogcGFyc2UvY29udmVydGVycy9tdXN0YWNoZS9kZWxpbWl0ZXJDaGFuZ2UuanMgKi9cblx0dmFyIGRlbGltaXRlckNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIGRlbGltaXRlckNoYW5nZVBhdHRlcm4gPSAvXlteXFxzPV0rLyxcblx0XHRcdHdoaXRlc3BhY2VQYXR0ZXJuID0gL15cXHMrLztcblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwgb3BlbmluZywgY2xvc2luZztcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJz0nICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZWZvcmUgbmV3IG9wZW5pbmcgZGVsaW1pdGVyXG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRvcGVuaW5nID0gcGFyc2VyLm1hdGNoUGF0dGVybiggZGVsaW1pdGVyQ2hhbmdlUGF0dGVybiApO1xuXHRcdFx0aWYgKCAhb3BlbmluZyApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdC8vIGFsbG93IHdoaXRlc3BhY2UgKGluIGZhY3QsIGl0J3MgbmVjZXNzYXJ5Li4uKVxuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoUGF0dGVybiggd2hpdGVzcGFjZVBhdHRlcm4gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRjbG9zaW5nID0gcGFyc2VyLm1hdGNoUGF0dGVybiggZGVsaW1pdGVyQ2hhbmdlUGF0dGVybiApO1xuXHRcdFx0aWYgKCAhY2xvc2luZyApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmVmb3JlIGNsb3NpbmcgJz0nXG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICc9JyApICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0b3BlbmluZyxcblx0XHRcdFx0Y2xvc2luZ1xuXHRcdFx0XTtcblx0XHR9O1xuXHR9KCk7XG5cblx0LyogcGFyc2UvY29udmVydGVycy9tdXN0YWNoZS9kZWxpbWl0ZXJUeXBlcy5qcyAqL1xuXHR2YXIgZGVsaW1pdGVyVHlwZXMgPSBbIHtcblx0XHRkZWxpbWl0ZXJzOiAnZGVsaW1pdGVycycsXG5cdFx0aXNUcmlwbGU6IGZhbHNlLFxuXHRcdGlzU3RhdGljOiBmYWxzZVxuXHR9LCB7XG5cdFx0ZGVsaW1pdGVyczogJ3RyaXBsZURlbGltaXRlcnMnLFxuXHRcdGlzVHJpcGxlOiB0cnVlLFxuXHRcdGlzU3RhdGljOiBmYWxzZVxuXHR9LCB7XG5cdFx0ZGVsaW1pdGVyczogJ3N0YXRpY0RlbGltaXRlcnMnLFxuXHRcdGlzVHJpcGxlOiBmYWxzZSxcblx0XHRpc1N0YXRpYzogdHJ1ZVxuXHR9LCB7XG5cdFx0ZGVsaW1pdGVyczogJ3N0YXRpY1RyaXBsZURlbGltaXRlcnMnLFxuXHRcdGlzVHJpcGxlOiB0cnVlLFxuXHRcdGlzU3RhdGljOiB0cnVlXG5cdH0gXTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL211c3RhY2hlL3R5cGUuanMgKi9cblx0dmFyIHR5cGUgPSBmdW5jdGlvbiggdHlwZXMgKSB7XG5cblx0XHR2YXIgbXVzdGFjaGVUeXBlcyA9IHtcblx0XHRcdCcjJzogdHlwZXMuU0VDVElPTixcblx0XHRcdCdeJzogdHlwZXMuSU5WRVJURUQsXG5cdFx0XHQnLyc6IHR5cGVzLkNMT1NJTkcsXG5cdFx0XHQnPic6IHR5cGVzLlBBUlRJQUwsXG5cdFx0XHQnISc6IHR5cGVzLkNPTU1FTlQsXG5cdFx0XHQnJic6IHR5cGVzLlRSSVBMRVxuXHRcdH07XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgdHlwZSA9IG11c3RhY2hlVHlwZXNbIHBhcnNlci5zdHIuY2hhckF0KCBwYXJzZXIucG9zICkgXTtcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLnBvcyArPSAxO1xuXHRcdFx0cmV0dXJuIHR5cGU7XG5cdFx0fTtcblx0fSggdHlwZXMgKTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL211c3RhY2hlL2hhbmRsZWJhcnNCbG9ja0NvZGVzLmpzICovXG5cdHZhciBoYW5kbGViYXJzQmxvY2tDb2RlcyA9IGZ1bmN0aW9uKCB0eXBlcyApIHtcblxuXHRcdHJldHVybiB7XG5cdFx0XHQnZWFjaCc6IHR5cGVzLlNFQ1RJT05fRUFDSCxcblx0XHRcdCdpZic6IHR5cGVzLlNFQ1RJT05fSUYsXG5cdFx0XHQnaWYtd2l0aCc6IHR5cGVzLlNFQ1RJT05fSUZfV0lUSCxcblx0XHRcdCd3aXRoJzogdHlwZXMuU0VDVElPTl9XSVRILFxuXHRcdFx0J3VubGVzcyc6IHR5cGVzLlNFQ1RJT05fVU5MRVNTXG5cdFx0fTtcblx0fSggdHlwZXMgKTtcblxuXHQvKiBlbXB0eS9sZWdhY3kuanMgKi9cblx0dmFyIGxlZ2FjeSA9IG51bGw7XG5cblx0LyogcGFyc2UvY29udmVydGVycy9tdXN0YWNoZS9jb250ZW50LmpzICovXG5cdHZhciBjb250ZW50ID0gZnVuY3Rpb24oIHR5cGVzLCBtdXN0YWNoZVR5cGUsIGhhbmRsZWJhcnNCbG9ja0NvZGVzICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBpbmRleFJlZlBhdHRlcm4gPSAvXlxccyo6XFxzKihbYS16QS1aXyRdW2EtekEtWl8kMC05XSopLyxcblx0XHRcdGFycmF5TWVtYmVyUGF0dGVybiA9IC9eWzAtOV1bMS05XSokLyxcblx0XHRcdGhhbmRsZWJhcnNCbG9ja1BhdHRlcm4gPSBuZXcgUmVnRXhwKCAnXignICsgT2JqZWN0LmtleXMoIGhhbmRsZWJhcnNCbG9ja0NvZGVzICkuam9pbiggJ3wnICkgKyAnKVxcXFxiJyApLFxuXHRcdFx0bGVnYWxSZWZlcmVuY2U7XG5cdFx0bGVnYWxSZWZlcmVuY2UgPSAvXlthLXpBLVokXzAtOV0rKD86KFxcLlthLXpBLVokXzAtOV0rKXwoXFxbW2EtekEtWiRfMC05XStcXF0pKSokLztcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uKCBwYXJzZXIsIGRlbGltaXRlclR5cGUgKSB7XG5cdFx0XHR2YXIgc3RhcnQsIHBvcywgbXVzdGFjaGUsIHR5cGUsIGJsb2NrLCBleHByZXNzaW9uLCBpLCByZW1haW5pbmcsIGluZGV4LCBkZWxpbWl0ZXJzO1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0bXVzdGFjaGUgPSB7fTtcblx0XHRcdGRlbGltaXRlcnMgPSBwYXJzZXJbIGRlbGltaXRlclR5cGUuZGVsaW1pdGVycyBdO1xuXHRcdFx0aWYgKCBkZWxpbWl0ZXJUeXBlLmlzU3RhdGljICkge1xuXHRcdFx0XHRtdXN0YWNoZS5zID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdC8vIERldGVybWluZSBtdXN0YWNoZSB0eXBlXG5cdFx0XHRpZiAoIGRlbGltaXRlclR5cGUuaXNUcmlwbGUgKSB7XG5cdFx0XHRcdG11c3RhY2hlLnQgPSB0eXBlcy5UUklQTEU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBXZSBuZWVkIHRvIHRlc3QgZm9yIGV4cHJlc3Npb25zIGJlZm9yZSB3ZSB0ZXN0IGZvciBtdXN0YWNoZSB0eXBlLCBiZWNhdXNlXG5cdFx0XHRcdC8vIGFuIGV4cHJlc3Npb24gdGhhdCBiZWdpbnMgJyEnIGxvb2tzIGEgbG90IGxpa2UgYSBjb21tZW50XG5cdFx0XHRcdGlmICggcGFyc2VyLnJlbWFpbmluZygpWyAwIF0gPT09ICchJyApIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0ZXhwcmVzc2lvbiA9IHBhcnNlci5yZWFkRXhwcmVzc2lvbigpO1xuXHRcdFx0XHRcdFx0Ly8gV2FzIGl0IGFjdHVhbGx5IGFuIGV4cHJlc3Npb24sIG9yIGEgY29tbWVudCBibG9jayBpbiBkaXNndWlzZT9cblx0XHRcdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0XHRcdGlmICggcGFyc2VyLnJlbWFpbmluZygpLmluZGV4T2YoIGRlbGltaXRlcnNbIDEgXSApICkge1xuXHRcdFx0XHRcdFx0XHRleHByZXNzaW9uID0gbnVsbDtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdG11c3RhY2hlLnQgPSB0eXBlcy5JTlRFUlBPTEFUT1I7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBjYXRjaCAoIGVyciApIHt9XG5cdFx0XHRcdFx0aWYgKCAhZXhwcmVzc2lvbiApIHtcblx0XHRcdFx0XHRcdGluZGV4ID0gcGFyc2VyLnJlbWFpbmluZygpLmluZGV4T2YoIGRlbGltaXRlcnNbIDEgXSApO1xuXHRcdFx0XHRcdFx0aWYgKCB+aW5kZXggKSB7XG5cdFx0XHRcdFx0XHRcdHBhcnNlci5wb3MgKz0gaW5kZXg7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoICdFeHBlY3RlZCBjbG9zaW5nIGRlbGltaXRlciAoXFwnJyArIGRlbGltaXRlcnNbIDEgXSArICdcXCcpJyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0dDogdHlwZXMuQ09NTUVOVFxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhZXhwcmVzc2lvbiApIHtcblx0XHRcdFx0XHR0eXBlID0gbXVzdGFjaGVUeXBlKCBwYXJzZXIgKTtcblx0XHRcdFx0XHRtdXN0YWNoZS50ID0gdHlwZSB8fCB0eXBlcy5JTlRFUlBPTEFUT1I7XG5cdFx0XHRcdFx0Ly8gZGVmYXVsdFxuXHRcdFx0XHRcdC8vIFNlZSBpZiB0aGVyZSdzIGFuIGV4cGxpY2l0IHNlY3Rpb24gdHlwZSBlLmcuIHt7I3dpdGh9fS4uLnt7L3dpdGh9fVxuXHRcdFx0XHRcdGlmICggdHlwZSA9PT0gdHlwZXMuU0VDVElPTiApIHtcblx0XHRcdFx0XHRcdGlmICggYmxvY2sgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBoYW5kbGViYXJzQmxvY2tQYXR0ZXJuICkgKSB7XG5cdFx0XHRcdFx0XHRcdG11c3RhY2hlLm4gPSBibG9jaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSB0eXBlcy5DT01NRU5UIHx8IHR5cGUgPT09IHR5cGVzLkNMT1NJTkcgKSB7XG5cdFx0XHRcdFx0XHRyZW1haW5pbmcgPSBwYXJzZXIucmVtYWluaW5nKCk7XG5cdFx0XHRcdFx0XHRpbmRleCA9IHJlbWFpbmluZy5pbmRleE9mKCBkZWxpbWl0ZXJzWyAxIF0gKTtcblx0XHRcdFx0XHRcdGlmICggaW5kZXggIT09IC0xICkge1xuXHRcdFx0XHRcdFx0XHRtdXN0YWNoZS5yID0gcmVtYWluaW5nLnN1YnN0ciggMCwgaW5kZXggKS5zcGxpdCggJyAnIClbIDAgXTtcblx0XHRcdFx0XHRcdFx0cGFyc2VyLnBvcyArPSBpbmRleDtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG11c3RhY2hlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCAhZXhwcmVzc2lvbiApIHtcblx0XHRcdFx0Ly8gYWxsb3cgd2hpdGVzcGFjZVxuXHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdC8vIGdldCBleHByZXNzaW9uXG5cdFx0XHRcdGV4cHJlc3Npb24gPSBwYXJzZXIucmVhZEV4cHJlc3Npb24oKTtcblx0XHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHBhcnRpYWwsIGl0IG1heSBoYXZlIGEgY29udGV4dCAoZS5nLiBge3s+aXRlbSBmb299fWApLiBUaGVzZVxuXHRcdFx0XHQvLyBjYXNlcyBpbnZvbHZlIGEgYml0IG9mIGEgaGFjayAtIHdlIHdhbnQgdG8gdHVybiBpdCBpbnRvIHRoZSBlcXVpdmFsZW50IG9mXG5cdFx0XHRcdC8vIGB7eyN3aXRoIGZvb319e3s+aXRlbX19e3svd2l0aH19YCwgYnV0IHRvIGdldCB0aGVyZSB3ZSB0ZW1wb3JhcmlseSBhcHBlbmRcblx0XHRcdFx0Ly8gYSAnY29udGV4dFBhcnRpYWxFeHByZXNzaW9uJyB0byB0aGUgbXVzdGFjaGUsIGFuZCBwcm9jZXNzIHRoZSBjb250ZXh0IGluc3RlYWQgb2Zcblx0XHRcdFx0Ly8gdGhlIHJlZmVyZW5jZVxuXHRcdFx0XHR2YXIgdGVtcDtcblx0XHRcdFx0aWYgKCBtdXN0YWNoZS50ID09PSB0eXBlcy5QQVJUSUFMICYmIGV4cHJlc3Npb24gJiYgKCB0ZW1wID0gcGFyc2VyLnJlYWRFeHByZXNzaW9uKCkgKSApIHtcblx0XHRcdFx0XHRtdXN0YWNoZSA9IHtcblx0XHRcdFx0XHRcdGNvbnRleHRQYXJ0aWFsRXhwcmVzc2lvbjogZXhwcmVzc2lvblxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0ZXhwcmVzc2lvbiA9IHRlbXA7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gV2l0aCBjZXJ0YWluIHZhbGlkIHJlZmVyZW5jZXMgdGhhdCBhcmVuJ3QgdmFsaWQgZXhwcmVzc2lvbnMsXG5cdFx0XHRcdC8vIGUuZy4ge3sxLmZvb319LCB3ZSBoYXZlIGEgcHJvYmxlbTogaXQgbG9va3MgbGlrZSB3ZSd2ZSBnb3QgYW5cblx0XHRcdFx0Ly8gZXhwcmVzc2lvbiwgYnV0IHRoZSBleHByZXNzaW9uIGRpZG4ndCBjb25zdW1lIHRoZSBlbnRpcmVcblx0XHRcdFx0Ly8gcmVmZXJlbmNlLiBTbyB3ZSBuZWVkIHRvIGNoZWNrIHRoYXQgdGhlIG11c3RhY2hlIGRlbGltaXRlcnNcblx0XHRcdFx0Ly8gYXBwZWFyIG5leHQsIHVubGVzcyB0aGVyZSdzIGFuIGluZGV4IHJlZmVyZW5jZSAoaS5lLiBhIGNvbG9uKVxuXHRcdFx0XHRyZW1haW5pbmcgPSBwYXJzZXIucmVtYWluaW5nKCk7XG5cdFx0XHRcdGlmICggcmVtYWluaW5nLnN1YnN0ciggMCwgZGVsaW1pdGVyc1sgMSBdLmxlbmd0aCApICE9PSBkZWxpbWl0ZXJzWyAxIF0gJiYgcmVtYWluaW5nLmNoYXJBdCggMCApICE9PSAnOicgKSB7XG5cdFx0XHRcdFx0cG9zID0gcGFyc2VyLnBvcztcblx0XHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdFx0cmVtYWluaW5nID0gcGFyc2VyLnJlbWFpbmluZygpO1xuXHRcdFx0XHRcdGluZGV4ID0gcmVtYWluaW5nLmluZGV4T2YoIGRlbGltaXRlcnNbIDEgXSApO1xuXHRcdFx0XHRcdGlmICggaW5kZXggIT09IC0xICkge1xuXHRcdFx0XHRcdFx0bXVzdGFjaGUuciA9IHJlbWFpbmluZy5zdWJzdHIoIDAsIGluZGV4ICkudHJpbSgpO1xuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgaXQncyBhIGxlZ2FsIHJlZmVyZW5jZVxuXHRcdFx0XHRcdFx0aWYgKCAhbGVnYWxSZWZlcmVuY2UudGVzdCggbXVzdGFjaGUuciApICkge1xuXHRcdFx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoICdFeHBlY3RlZCBhIGxlZ2FsIE11c3RhY2hlIHJlZmVyZW5jZScgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHBhcnNlci5wb3MgKz0gaW5kZXg7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbXVzdGFjaGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBhcnNlci5wb3MgPSBwb3M7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlZmluZUV4cHJlc3Npb24oIHBhcnNlciwgZXhwcmVzc2lvbiwgbXVzdGFjaGUgKTtcblx0XHRcdC8vIGlmIHRoZXJlIHdhcyBjb250ZXh0LCBwcm9jZXNzIHRoZSBleHByZXNzaW9uIG5vdyBhbmQgc2F2ZSBpdCBmb3IgbGF0ZXJcblx0XHRcdGlmICggbXVzdGFjaGUuY29udGV4dFBhcnRpYWxFeHByZXNzaW9uICkge1xuXHRcdFx0XHRtdXN0YWNoZS5jb250ZXh0UGFydGlhbEV4cHJlc3Npb24gPSBbIHJlZmluZUV4cHJlc3Npb24oIHBhcnNlciwgbXVzdGFjaGUuY29udGV4dFBhcnRpYWxFeHByZXNzaW9uLCB7XG5cdFx0XHRcdFx0dDogdHlwZXMuUEFSVElBTFxuXHRcdFx0XHR9ICkgXTtcblx0XHRcdH1cblx0XHRcdC8vIG9wdGlvbmFsIGluZGV4IHJlZmVyZW5jZVxuXHRcdFx0aWYgKCBpID0gcGFyc2VyLm1hdGNoUGF0dGVybiggaW5kZXhSZWZQYXR0ZXJuICkgKSB7XG5cdFx0XHRcdG11c3RhY2hlLmkgPSBpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG11c3RhY2hlO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiByZWZpbmVFeHByZXNzaW9uKCBwYXJzZXIsIGV4cHJlc3Npb24sIG11c3RhY2hlICkge1xuXHRcdFx0dmFyIHJlZmVyZW5jZUV4cHJlc3Npb247XG5cdFx0XHRpZiAoIGV4cHJlc3Npb24gKSB7XG5cdFx0XHRcdHdoaWxlICggZXhwcmVzc2lvbi50ID09PSB0eXBlcy5CUkFDS0VURUQgJiYgZXhwcmVzc2lvbi54ICkge1xuXHRcdFx0XHRcdGV4cHJlc3Npb24gPSBleHByZXNzaW9uLng7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gaW50ZWdlcnMgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYXJyYXkgbWVtYmVycyByZWZlcmVuY2VzLFxuXHRcdFx0XHQvLyByYXRoZXIgdGhhbiBhcyBleHByZXNzaW9ucyBpbiB0aGVpciBvd24gcmlnaHRcblx0XHRcdFx0aWYgKCBleHByZXNzaW9uLnQgPT09IHR5cGVzLlJFRkVSRU5DRSApIHtcblx0XHRcdFx0XHRtdXN0YWNoZS5yID0gZXhwcmVzc2lvbi5uO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICggZXhwcmVzc2lvbi50ID09PSB0eXBlcy5OVU1CRVJfTElURVJBTCAmJiBhcnJheU1lbWJlclBhdHRlcm4udGVzdCggZXhwcmVzc2lvbi52ICkgKSB7XG5cdFx0XHRcdFx0XHRtdXN0YWNoZS5yID0gZXhwcmVzc2lvbi52O1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHJlZmVyZW5jZUV4cHJlc3Npb24gPSBnZXRSZWZlcmVuY2VFeHByZXNzaW9uKCBwYXJzZXIsIGV4cHJlc3Npb24gKSApIHtcblx0XHRcdFx0XHRcdG11c3RhY2hlLnJ4ID0gcmVmZXJlbmNlRXhwcmVzc2lvbjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bXVzdGFjaGUueCA9IHBhcnNlci5mbGF0dGVuRXhwcmVzc2lvbiggZXhwcmVzc2lvbiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbXVzdGFjaGU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIFRPRE8gcmVmYWN0b3IgdGhpcyEgaXQncyBiZXdpbGRlcmluZ1xuXHRcdGZ1bmN0aW9uIGdldFJlZmVyZW5jZUV4cHJlc3Npb24oIHBhcnNlciwgZXhwcmVzc2lvbiApIHtcblx0XHRcdHZhciBtZW1iZXJzID0gW10sXG5cdFx0XHRcdHJlZmluZW1lbnQ7XG5cdFx0XHR3aGlsZSAoIGV4cHJlc3Npb24udCA9PT0gdHlwZXMuTUVNQkVSICYmIGV4cHJlc3Npb24uci50ID09PSB0eXBlcy5SRUZJTkVNRU5UICkge1xuXHRcdFx0XHRyZWZpbmVtZW50ID0gZXhwcmVzc2lvbi5yO1xuXHRcdFx0XHRpZiAoIHJlZmluZW1lbnQueCApIHtcblx0XHRcdFx0XHRpZiAoIHJlZmluZW1lbnQueC50ID09PSB0eXBlcy5SRUZFUkVOQ0UgKSB7XG5cdFx0XHRcdFx0XHRtZW1iZXJzLnVuc2hpZnQoIHJlZmluZW1lbnQueCApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRtZW1iZXJzLnVuc2hpZnQoIHBhcnNlci5mbGF0dGVuRXhwcmVzc2lvbiggcmVmaW5lbWVudC54ICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bWVtYmVycy51bnNoaWZ0KCByZWZpbmVtZW50Lm4gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRleHByZXNzaW9uID0gZXhwcmVzc2lvbi54O1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBleHByZXNzaW9uLnQgIT09IHR5cGVzLlJFRkVSRU5DRSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRyOiBleHByZXNzaW9uLm4sXG5cdFx0XHRcdG06IG1lbWJlcnNcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggdHlwZXMsIHR5cGUsIGhhbmRsZWJhcnNCbG9ja0NvZGVzLCBsZWdhY3kgKTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL211c3RhY2hlLmpzICovXG5cdHZhciBtdXN0YWNoZSA9IGZ1bmN0aW9uKCB0eXBlcywgZGVsaW1pdGVyQ2hhbmdlLCBkZWxpbWl0ZXJUeXBlcywgbXVzdGFjaGVDb250ZW50LCBoYW5kbGViYXJzQmxvY2tDb2RlcyApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgZGVsaW1pdGVyQ2hhbmdlVG9rZW4gPSB7XG5cdFx0XHR0OiB0eXBlcy5ERUxJTUNIQU5HRSxcblx0XHRcdGV4Y2x1ZGU6IHRydWVcblx0XHR9O1xuXHRcdF9fZXhwb3J0ID0gZ2V0TXVzdGFjaGU7XG5cblx0XHRmdW5jdGlvbiBnZXRNdXN0YWNoZSggcGFyc2VyICkge1xuXHRcdFx0dmFyIHR5cGVzO1xuXHRcdFx0Ly8gSWYgd2UncmUgaW5zaWRlIGEgPHNjcmlwdD4gb3IgPHN0eWxlPiB0YWcsIGFuZCB3ZSdyZSBub3Rcblx0XHRcdC8vIGludGVycG9sYXRpbmcsIGJ1ZyBvdXRcblx0XHRcdGlmICggcGFyc2VyLmludGVycG9sYXRlWyBwYXJzZXIuaW5zaWRlIF0gPT09IGZhbHNlICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHR5cGVzID0gZGVsaW1pdGVyVHlwZXMuc2xpY2UoKS5zb3J0KCBmdW5jdGlvbiBjb21wYXJlKCBhLCBiICkge1xuXHRcdFx0XHQvLyBTb3J0IGluIG9yZGVyIG9mIGRlc2NlbmRpbmcgb3BlbmluZyBkZWxpbWl0ZXIgbGVuZ3RoIChsb25nZXIgZmlyc3QpLFxuXHRcdFx0XHQvLyB0byBwcm90ZWN0IGFnYWluc3Qgb3BlbmluZyBkZWxpbWl0ZXJzIGJlaW5nIHN1YnN0cmluZ3Mgb2YgZWFjaCBvdGhlclxuXHRcdFx0XHRyZXR1cm4gcGFyc2VyWyBiLmRlbGltaXRlcnMgXVsgMCBdLmxlbmd0aCAtIHBhcnNlclsgYS5kZWxpbWl0ZXJzIF1bIDAgXS5sZW5ndGg7XG5cdFx0XHR9ICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gciggdHlwZSApIHtcblx0XHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gZ2V0TXVzdGFjaGVPZlR5cGUoIHBhcnNlciwgdHlwZSApIHx8IHIoIHR5cGVzLnNoaWZ0KCkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSggdHlwZXMuc2hpZnQoKSApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldE11c3RhY2hlT2ZUeXBlKCBwYXJzZXIsIGRlbGltaXRlclR5cGUgKSB7XG5cdFx0XHR2YXIgc3RhcnQsIG11c3RhY2hlLCBkZWxpbWl0ZXJzLCBjaGlsZHJlbiwgZXhwZWN0ZWRDbG9zZSwgZWxzZUNoaWxkcmVuLCBjdXJyZW50Q2hpbGRyZW4sIGNoaWxkO1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0ZGVsaW1pdGVycyA9IHBhcnNlclsgZGVsaW1pdGVyVHlwZS5kZWxpbWl0ZXJzIF07XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoIGRlbGltaXRlcnNbIDAgXSApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdC8vIGRlbGltaXRlciBjaGFuZ2U/XG5cdFx0XHRpZiAoIG11c3RhY2hlID0gZGVsaW1pdGVyQ2hhbmdlKCBwYXJzZXIgKSApIHtcblx0XHRcdFx0Ly8gZmluZCBjbG9zaW5nIGRlbGltaXRlciBvciBhYm9ydC4uLlxuXHRcdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoIGRlbGltaXRlcnNbIDEgXSApICkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIC4uLnRoZW4gbWFrZSB0aGUgc3dpdGNoXG5cdFx0XHRcdHBhcnNlclsgZGVsaW1pdGVyVHlwZS5kZWxpbWl0ZXJzIF0gPSBtdXN0YWNoZTtcblx0XHRcdFx0cmV0dXJuIGRlbGltaXRlckNoYW5nZVRva2VuO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0bXVzdGFjaGUgPSBtdXN0YWNoZUNvbnRlbnQoIHBhcnNlciwgZGVsaW1pdGVyVHlwZSApO1xuXHRcdFx0aWYgKCBtdXN0YWNoZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmVmb3JlIGNsb3NpbmcgZGVsaW1pdGVyXG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoIGRlbGltaXRlcnNbIDEgXSApICkge1xuXHRcdFx0XHRwYXJzZXIuZXJyb3IoICdFeHBlY3RlZCBjbG9zaW5nIGRlbGltaXRlciBcXCcnICsgZGVsaW1pdGVyc1sgMSBdICsgJ1xcJyBhZnRlciByZWZlcmVuY2UnICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG11c3RhY2hlLnQgPT09IHR5cGVzLkNPTU1FTlQgKSB7XG5cdFx0XHRcdG11c3RhY2hlLmV4Y2x1ZGUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBtdXN0YWNoZS50ID09PSB0eXBlcy5DTE9TSU5HICkge1xuXHRcdFx0XHRwYXJzZXIuc2VjdGlvbkRlcHRoIC09IDE7XG5cdFx0XHRcdGlmICggcGFyc2VyLnNlY3Rpb25EZXB0aCA8IDAgKSB7XG5cdFx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRcdHBhcnNlci5lcnJvciggJ0F0dGVtcHRlZCB0byBjbG9zZSBhIHNlY3Rpb24gdGhhdCB3YXNuXFwndCBvcGVuJyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBwYXJ0aWFscyB3aXRoIGNvbnRleHRcblx0XHRcdGlmICggbXVzdGFjaGUuY29udGV4dFBhcnRpYWxFeHByZXNzaW9uICkge1xuXHRcdFx0XHRtdXN0YWNoZS5mID0gbXVzdGFjaGUuY29udGV4dFBhcnRpYWxFeHByZXNzaW9uO1xuXHRcdFx0XHRtdXN0YWNoZS50ID0gdHlwZXMuU0VDVElPTjtcblx0XHRcdFx0bXVzdGFjaGUubiA9ICd3aXRoJztcblx0XHRcdFx0ZGVsZXRlIG11c3RhY2hlLmNvbnRleHRQYXJ0aWFsRXhwcmVzc2lvbjtcblx0XHRcdH0gZWxzZSBpZiAoIGlzU2VjdGlvbiggbXVzdGFjaGUgKSApIHtcblx0XHRcdFx0cGFyc2VyLnNlY3Rpb25EZXB0aCArPSAxO1xuXHRcdFx0XHRjaGlsZHJlbiA9IFtdO1xuXHRcdFx0XHRjdXJyZW50Q2hpbGRyZW4gPSBjaGlsZHJlbjtcblx0XHRcdFx0ZXhwZWN0ZWRDbG9zZSA9IG11c3RhY2hlLm47XG5cdFx0XHRcdHdoaWxlICggY2hpbGQgPSBwYXJzZXIucmVhZCgpICkge1xuXHRcdFx0XHRcdGlmICggY2hpbGQudCA9PT0gdHlwZXMuQ0xPU0lORyApIHtcblx0XHRcdFx0XHRcdGlmICggZXhwZWN0ZWRDbG9zZSAmJiBjaGlsZC5yICE9PSBleHBlY3RlZENsb3NlICkge1xuXHRcdFx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoICdFeHBlY3RlZCB7ey8nICsgZXhwZWN0ZWRDbG9zZSArICd9fScgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyB7e2Vsc2V9fSB0YWdzIHJlcXVpcmUgc3BlY2lhbCB0cmVhdG1lbnRcblx0XHRcdFx0XHRpZiAoIGNoaWxkLnQgPT09IHR5cGVzLklOVEVSUE9MQVRPUiAmJiBjaGlsZC5yID09PSAnZWxzZScgKSB7XG5cdFx0XHRcdFx0XHQvLyBubyB7e2Vsc2V9fSBhbGxvd2VkIGluIHt7I3VubGVzc319XG5cdFx0XHRcdFx0XHRpZiAoIG11c3RhY2hlLm4gPT09ICd1bmxlc3MnICkge1xuXHRcdFx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoICd7e2Vsc2V9fSBub3QgYWxsb3dlZCBpbiB7eyN1bmxlc3N9fScgKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGN1cnJlbnRDaGlsZHJlbiA9IGVsc2VDaGlsZHJlbiA9IFtdO1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y3VycmVudENoaWxkcmVuLnB1c2goIGNoaWxkICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBjaGlsZHJlbi5sZW5ndGggKSB7XG5cdFx0XHRcdFx0bXVzdGFjaGUuZiA9IGNoaWxkcmVuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZWxzZUNoaWxkcmVuICYmIGVsc2VDaGlsZHJlbi5sZW5ndGggKSB7XG5cdFx0XHRcdFx0bXVzdGFjaGUubCA9IGVsc2VDaGlsZHJlbjtcblx0XHRcdFx0XHRpZiAoIG11c3RhY2hlLm4gPT09ICd3aXRoJyApIHtcblx0XHRcdFx0XHRcdG11c3RhY2hlLm4gPSAnaWYtd2l0aCc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHBhcnNlci5pbmNsdWRlTGluZVBvc2l0aW9ucyApIHtcblx0XHRcdFx0bXVzdGFjaGUucCA9IHBhcnNlci5nZXRMaW5lUG9zKCBzdGFydCApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gUmVwbGFjZSBibG9jayBuYW1lIHdpdGggY29kZVxuXHRcdFx0aWYgKCBtdXN0YWNoZS5uICkge1xuXHRcdFx0XHRtdXN0YWNoZS5uID0gaGFuZGxlYmFyc0Jsb2NrQ29kZXNbIG11c3RhY2hlLm4gXTtcblx0XHRcdH0gZWxzZSBpZiAoIG11c3RhY2hlLnQgPT09IHR5cGVzLklOVkVSVEVEICkge1xuXHRcdFx0XHRtdXN0YWNoZS50ID0gdHlwZXMuU0VDVElPTjtcblx0XHRcdFx0bXVzdGFjaGUubiA9IHR5cGVzLlNFQ1RJT05fVU5MRVNTO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG11c3RhY2hlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzU2VjdGlvbiggbXVzdGFjaGUgKSB7XG5cdFx0XHRyZXR1cm4gbXVzdGFjaGUudCA9PT0gdHlwZXMuU0VDVElPTiB8fCBtdXN0YWNoZS50ID09PSB0eXBlcy5JTlZFUlRFRDtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCB0eXBlcywgZGVsaW1pdGVyQ2hhbmdlLCBkZWxpbWl0ZXJUeXBlcywgY29udGVudCwgaGFuZGxlYmFyc0Jsb2NrQ29kZXMgKTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL2NvbW1lbnQuanMgKi9cblx0dmFyIGNvbW1lbnQgPSBmdW5jdGlvbiggdHlwZXMgKSB7XG5cblx0XHR2YXIgT1BFTl9DT01NRU5UID0gJzwhLS0nLFxuXHRcdFx0Q0xPU0VfQ09NTUVOVCA9ICctLT4nO1xuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBjb250ZW50LCByZW1haW5pbmcsIGVuZEluZGV4LCBjb21tZW50O1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCBPUEVOX0NPTU1FTlQgKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRyZW1haW5pbmcgPSBwYXJzZXIucmVtYWluaW5nKCk7XG5cdFx0XHRlbmRJbmRleCA9IHJlbWFpbmluZy5pbmRleE9mKCBDTE9TRV9DT01NRU5UICk7XG5cdFx0XHRpZiAoIGVuZEluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0cGFyc2VyLmVycm9yKCAnSWxsZWdhbCBIVE1MIC0gZXhwZWN0ZWQgY2xvc2luZyBjb21tZW50IHNlcXVlbmNlIChcXCctLT5cXCcpJyApO1xuXHRcdFx0fVxuXHRcdFx0Y29udGVudCA9IHJlbWFpbmluZy5zdWJzdHIoIDAsIGVuZEluZGV4ICk7XG5cdFx0XHRwYXJzZXIucG9zICs9IGVuZEluZGV4ICsgMztcblx0XHRcdGNvbW1lbnQgPSB7XG5cdFx0XHRcdHQ6IHR5cGVzLkNPTU1FTlQsXG5cdFx0XHRcdGM6IGNvbnRlbnRcblx0XHRcdH07XG5cdFx0XHRpZiAoIHBhcnNlci5pbmNsdWRlTGluZVBvc2l0aW9ucyApIHtcblx0XHRcdFx0Y29tbWVudC5wID0gcGFyc2VyLmdldExpbmVQb3MoIHN0YXJ0ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY29tbWVudDtcblx0XHR9O1xuXHR9KCB0eXBlcyApO1xuXG5cdC8qIGNvbmZpZy92b2lkRWxlbWVudE5hbWVzLmpzICovXG5cdHZhciB2b2lkRWxlbWVudE5hbWVzID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgdm9pZEVsZW1lbnROYW1lcyA9IC9eKD86YXJlYXxiYXNlfGJyfGNvbHxjb21tYW5kfGRvY3R5cGV8ZW1iZWR8aHJ8aW1nfGlucHV0fGtleWdlbnxsaW5rfG1ldGF8cGFyYW18c291cmNlfHRyYWNrfHdicikkL2k7XG5cdFx0cmV0dXJuIHZvaWRFbGVtZW50TmFtZXM7XG5cdH0oKTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL3V0aWxzL2dldExvd2VzdEluZGV4LmpzICovXG5cdHZhciBnZXRMb3dlc3RJbmRleCA9IGZ1bmN0aW9uKCBoYXlzdGFjaywgbmVlZGxlcyApIHtcblx0XHR2YXIgaSwgaW5kZXgsIGxvd2VzdDtcblx0XHRpID0gbmVlZGxlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRpbmRleCA9IGhheXN0YWNrLmluZGV4T2YoIG5lZWRsZXNbIGkgXSApO1xuXHRcdFx0Ly8gc2hvcnQgY2lyY3VpdFxuXHRcdFx0aWYgKCAhaW5kZXggKSB7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBpbmRleCA9PT0gLTEgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhbG93ZXN0IHx8IGluZGV4IDwgbG93ZXN0ICkge1xuXHRcdFx0XHRsb3dlc3QgPSBpbmRleDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGxvd2VzdCB8fCAtMTtcblx0fTtcblxuXHQvKiBzaGFyZWQvZGVjb2RlQ2hhcmFjdGVyUmVmZXJlbmNlcy5qcyAqL1xuXHR2YXIgZGVjb2RlQ2hhcmFjdGVyUmVmZXJlbmNlcyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBodG1sRW50aXRpZXMsIGNvbnRyb2xDaGFyYWN0ZXJzLCBlbnRpdHlQYXR0ZXJuO1xuXHRcdGh0bWxFbnRpdGllcyA9IHtcblx0XHRcdHF1b3Q6IDM0LFxuXHRcdFx0YW1wOiAzOCxcblx0XHRcdGFwb3M6IDM5LFxuXHRcdFx0bHQ6IDYwLFxuXHRcdFx0Z3Q6IDYyLFxuXHRcdFx0bmJzcDogMTYwLFxuXHRcdFx0aWV4Y2w6IDE2MSxcblx0XHRcdGNlbnQ6IDE2Mixcblx0XHRcdHBvdW5kOiAxNjMsXG5cdFx0XHRjdXJyZW46IDE2NCxcblx0XHRcdHllbjogMTY1LFxuXHRcdFx0YnJ2YmFyOiAxNjYsXG5cdFx0XHRzZWN0OiAxNjcsXG5cdFx0XHR1bWw6IDE2OCxcblx0XHRcdGNvcHk6IDE2OSxcblx0XHRcdG9yZGY6IDE3MCxcblx0XHRcdGxhcXVvOiAxNzEsXG5cdFx0XHRub3Q6IDE3Mixcblx0XHRcdHNoeTogMTczLFxuXHRcdFx0cmVnOiAxNzQsXG5cdFx0XHRtYWNyOiAxNzUsXG5cdFx0XHRkZWc6IDE3Nixcblx0XHRcdHBsdXNtbjogMTc3LFxuXHRcdFx0c3VwMjogMTc4LFxuXHRcdFx0c3VwMzogMTc5LFxuXHRcdFx0YWN1dGU6IDE4MCxcblx0XHRcdG1pY3JvOiAxODEsXG5cdFx0XHRwYXJhOiAxODIsXG5cdFx0XHRtaWRkb3Q6IDE4Myxcblx0XHRcdGNlZGlsOiAxODQsXG5cdFx0XHRzdXAxOiAxODUsXG5cdFx0XHRvcmRtOiAxODYsXG5cdFx0XHRyYXF1bzogMTg3LFxuXHRcdFx0ZnJhYzE0OiAxODgsXG5cdFx0XHRmcmFjMTI6IDE4OSxcblx0XHRcdGZyYWMzNDogMTkwLFxuXHRcdFx0aXF1ZXN0OiAxOTEsXG5cdFx0XHRBZ3JhdmU6IDE5Mixcblx0XHRcdEFhY3V0ZTogMTkzLFxuXHRcdFx0QWNpcmM6IDE5NCxcblx0XHRcdEF0aWxkZTogMTk1LFxuXHRcdFx0QXVtbDogMTk2LFxuXHRcdFx0QXJpbmc6IDE5Nyxcblx0XHRcdEFFbGlnOiAxOTgsXG5cdFx0XHRDY2VkaWw6IDE5OSxcblx0XHRcdEVncmF2ZTogMjAwLFxuXHRcdFx0RWFjdXRlOiAyMDEsXG5cdFx0XHRFY2lyYzogMjAyLFxuXHRcdFx0RXVtbDogMjAzLFxuXHRcdFx0SWdyYXZlOiAyMDQsXG5cdFx0XHRJYWN1dGU6IDIwNSxcblx0XHRcdEljaXJjOiAyMDYsXG5cdFx0XHRJdW1sOiAyMDcsXG5cdFx0XHRFVEg6IDIwOCxcblx0XHRcdE50aWxkZTogMjA5LFxuXHRcdFx0T2dyYXZlOiAyMTAsXG5cdFx0XHRPYWN1dGU6IDIxMSxcblx0XHRcdE9jaXJjOiAyMTIsXG5cdFx0XHRPdGlsZGU6IDIxMyxcblx0XHRcdE91bWw6IDIxNCxcblx0XHRcdHRpbWVzOiAyMTUsXG5cdFx0XHRPc2xhc2g6IDIxNixcblx0XHRcdFVncmF2ZTogMjE3LFxuXHRcdFx0VWFjdXRlOiAyMTgsXG5cdFx0XHRVY2lyYzogMjE5LFxuXHRcdFx0VXVtbDogMjIwLFxuXHRcdFx0WWFjdXRlOiAyMjEsXG5cdFx0XHRUSE9STjogMjIyLFxuXHRcdFx0c3psaWc6IDIyMyxcblx0XHRcdGFncmF2ZTogMjI0LFxuXHRcdFx0YWFjdXRlOiAyMjUsXG5cdFx0XHRhY2lyYzogMjI2LFxuXHRcdFx0YXRpbGRlOiAyMjcsXG5cdFx0XHRhdW1sOiAyMjgsXG5cdFx0XHRhcmluZzogMjI5LFxuXHRcdFx0YWVsaWc6IDIzMCxcblx0XHRcdGNjZWRpbDogMjMxLFxuXHRcdFx0ZWdyYXZlOiAyMzIsXG5cdFx0XHRlYWN1dGU6IDIzMyxcblx0XHRcdGVjaXJjOiAyMzQsXG5cdFx0XHRldW1sOiAyMzUsXG5cdFx0XHRpZ3JhdmU6IDIzNixcblx0XHRcdGlhY3V0ZTogMjM3LFxuXHRcdFx0aWNpcmM6IDIzOCxcblx0XHRcdGl1bWw6IDIzOSxcblx0XHRcdGV0aDogMjQwLFxuXHRcdFx0bnRpbGRlOiAyNDEsXG5cdFx0XHRvZ3JhdmU6IDI0Mixcblx0XHRcdG9hY3V0ZTogMjQzLFxuXHRcdFx0b2NpcmM6IDI0NCxcblx0XHRcdG90aWxkZTogMjQ1LFxuXHRcdFx0b3VtbDogMjQ2LFxuXHRcdFx0ZGl2aWRlOiAyNDcsXG5cdFx0XHRvc2xhc2g6IDI0OCxcblx0XHRcdHVncmF2ZTogMjQ5LFxuXHRcdFx0dWFjdXRlOiAyNTAsXG5cdFx0XHR1Y2lyYzogMjUxLFxuXHRcdFx0dXVtbDogMjUyLFxuXHRcdFx0eWFjdXRlOiAyNTMsXG5cdFx0XHR0aG9ybjogMjU0LFxuXHRcdFx0eXVtbDogMjU1LFxuXHRcdFx0T0VsaWc6IDMzOCxcblx0XHRcdG9lbGlnOiAzMzksXG5cdFx0XHRTY2Fyb246IDM1Mixcblx0XHRcdHNjYXJvbjogMzUzLFxuXHRcdFx0WXVtbDogMzc2LFxuXHRcdFx0Zm5vZjogNDAyLFxuXHRcdFx0Y2lyYzogNzEwLFxuXHRcdFx0dGlsZGU6IDczMixcblx0XHRcdEFscGhhOiA5MTMsXG5cdFx0XHRCZXRhOiA5MTQsXG5cdFx0XHRHYW1tYTogOTE1LFxuXHRcdFx0RGVsdGE6IDkxNixcblx0XHRcdEVwc2lsb246IDkxNyxcblx0XHRcdFpldGE6IDkxOCxcblx0XHRcdEV0YTogOTE5LFxuXHRcdFx0VGhldGE6IDkyMCxcblx0XHRcdElvdGE6IDkyMSxcblx0XHRcdEthcHBhOiA5MjIsXG5cdFx0XHRMYW1iZGE6IDkyMyxcblx0XHRcdE11OiA5MjQsXG5cdFx0XHROdTogOTI1LFxuXHRcdFx0WGk6IDkyNixcblx0XHRcdE9taWNyb246IDkyNyxcblx0XHRcdFBpOiA5MjgsXG5cdFx0XHRSaG86IDkyOSxcblx0XHRcdFNpZ21hOiA5MzEsXG5cdFx0XHRUYXU6IDkzMixcblx0XHRcdFVwc2lsb246IDkzMyxcblx0XHRcdFBoaTogOTM0LFxuXHRcdFx0Q2hpOiA5MzUsXG5cdFx0XHRQc2k6IDkzNixcblx0XHRcdE9tZWdhOiA5MzcsXG5cdFx0XHRhbHBoYTogOTQ1LFxuXHRcdFx0YmV0YTogOTQ2LFxuXHRcdFx0Z2FtbWE6IDk0Nyxcblx0XHRcdGRlbHRhOiA5NDgsXG5cdFx0XHRlcHNpbG9uOiA5NDksXG5cdFx0XHR6ZXRhOiA5NTAsXG5cdFx0XHRldGE6IDk1MSxcblx0XHRcdHRoZXRhOiA5NTIsXG5cdFx0XHRpb3RhOiA5NTMsXG5cdFx0XHRrYXBwYTogOTU0LFxuXHRcdFx0bGFtYmRhOiA5NTUsXG5cdFx0XHRtdTogOTU2LFxuXHRcdFx0bnU6IDk1Nyxcblx0XHRcdHhpOiA5NTgsXG5cdFx0XHRvbWljcm9uOiA5NTksXG5cdFx0XHRwaTogOTYwLFxuXHRcdFx0cmhvOiA5NjEsXG5cdFx0XHRzaWdtYWY6IDk2Mixcblx0XHRcdHNpZ21hOiA5NjMsXG5cdFx0XHR0YXU6IDk2NCxcblx0XHRcdHVwc2lsb246IDk2NSxcblx0XHRcdHBoaTogOTY2LFxuXHRcdFx0Y2hpOiA5NjcsXG5cdFx0XHRwc2k6IDk2OCxcblx0XHRcdG9tZWdhOiA5NjksXG5cdFx0XHR0aGV0YXN5bTogOTc3LFxuXHRcdFx0dXBzaWg6IDk3OCxcblx0XHRcdHBpdjogOTgyLFxuXHRcdFx0ZW5zcDogODE5NCxcblx0XHRcdGVtc3A6IDgxOTUsXG5cdFx0XHR0aGluc3A6IDgyMDEsXG5cdFx0XHR6d25qOiA4MjA0LFxuXHRcdFx0endqOiA4MjA1LFxuXHRcdFx0bHJtOiA4MjA2LFxuXHRcdFx0cmxtOiA4MjA3LFxuXHRcdFx0bmRhc2g6IDgyMTEsXG5cdFx0XHRtZGFzaDogODIxMixcblx0XHRcdGxzcXVvOiA4MjE2LFxuXHRcdFx0cnNxdW86IDgyMTcsXG5cdFx0XHRzYnF1bzogODIxOCxcblx0XHRcdGxkcXVvOiA4MjIwLFxuXHRcdFx0cmRxdW86IDgyMjEsXG5cdFx0XHRiZHF1bzogODIyMixcblx0XHRcdGRhZ2dlcjogODIyNCxcblx0XHRcdERhZ2dlcjogODIyNSxcblx0XHRcdGJ1bGw6IDgyMjYsXG5cdFx0XHRoZWxsaXA6IDgyMzAsXG5cdFx0XHRwZXJtaWw6IDgyNDAsXG5cdFx0XHRwcmltZTogODI0Mixcblx0XHRcdFByaW1lOiA4MjQzLFxuXHRcdFx0bHNhcXVvOiA4MjQ5LFxuXHRcdFx0cnNhcXVvOiA4MjUwLFxuXHRcdFx0b2xpbmU6IDgyNTQsXG5cdFx0XHRmcmFzbDogODI2MCxcblx0XHRcdGV1cm86IDgzNjQsXG5cdFx0XHRpbWFnZTogODQ2NSxcblx0XHRcdHdlaWVycDogODQ3Mixcblx0XHRcdHJlYWw6IDg0NzYsXG5cdFx0XHR0cmFkZTogODQ4Mixcblx0XHRcdGFsZWZzeW06IDg1MDEsXG5cdFx0XHRsYXJyOiA4NTkyLFxuXHRcdFx0dWFycjogODU5Myxcblx0XHRcdHJhcnI6IDg1OTQsXG5cdFx0XHRkYXJyOiA4NTk1LFxuXHRcdFx0aGFycjogODU5Nixcblx0XHRcdGNyYXJyOiA4NjI5LFxuXHRcdFx0bEFycjogODY1Nixcblx0XHRcdHVBcnI6IDg2NTcsXG5cdFx0XHRyQXJyOiA4NjU4LFxuXHRcdFx0ZEFycjogODY1OSxcblx0XHRcdGhBcnI6IDg2NjAsXG5cdFx0XHRmb3JhbGw6IDg3MDQsXG5cdFx0XHRwYXJ0OiA4NzA2LFxuXHRcdFx0ZXhpc3Q6IDg3MDcsXG5cdFx0XHRlbXB0eTogODcwOSxcblx0XHRcdG5hYmxhOiA4NzExLFxuXHRcdFx0aXNpbjogODcxMixcblx0XHRcdG5vdGluOiA4NzEzLFxuXHRcdFx0bmk6IDg3MTUsXG5cdFx0XHRwcm9kOiA4NzE5LFxuXHRcdFx0c3VtOiA4NzIxLFxuXHRcdFx0bWludXM6IDg3MjIsXG5cdFx0XHRsb3dhc3Q6IDg3MjcsXG5cdFx0XHRyYWRpYzogODczMCxcblx0XHRcdHByb3A6IDg3MzMsXG5cdFx0XHRpbmZpbjogODczNCxcblx0XHRcdGFuZzogODczNixcblx0XHRcdGFuZDogODc0Myxcblx0XHRcdG9yOiA4NzQ0LFxuXHRcdFx0Y2FwOiA4NzQ1LFxuXHRcdFx0Y3VwOiA4NzQ2LFxuXHRcdFx0J2ludCc6IDg3NDcsXG5cdFx0XHR0aGVyZTQ6IDg3NTYsXG5cdFx0XHRzaW06IDg3NjQsXG5cdFx0XHRjb25nOiA4NzczLFxuXHRcdFx0YXN5bXA6IDg3NzYsXG5cdFx0XHRuZTogODgwMCxcblx0XHRcdGVxdWl2OiA4ODAxLFxuXHRcdFx0bGU6IDg4MDQsXG5cdFx0XHRnZTogODgwNSxcblx0XHRcdHN1YjogODgzNCxcblx0XHRcdHN1cDogODgzNSxcblx0XHRcdG5zdWI6IDg4MzYsXG5cdFx0XHRzdWJlOiA4ODM4LFxuXHRcdFx0c3VwZTogODgzOSxcblx0XHRcdG9wbHVzOiA4ODUzLFxuXHRcdFx0b3RpbWVzOiA4ODU1LFxuXHRcdFx0cGVycDogODg2OSxcblx0XHRcdHNkb3Q6IDg5MDEsXG5cdFx0XHRsY2VpbDogODk2OCxcblx0XHRcdHJjZWlsOiA4OTY5LFxuXHRcdFx0bGZsb29yOiA4OTcwLFxuXHRcdFx0cmZsb29yOiA4OTcxLFxuXHRcdFx0bGFuZzogOTAwMSxcblx0XHRcdHJhbmc6IDkwMDIsXG5cdFx0XHRsb3o6IDk2NzQsXG5cdFx0XHRzcGFkZXM6IDk4MjQsXG5cdFx0XHRjbHViczogOTgyNyxcblx0XHRcdGhlYXJ0czogOTgyOSxcblx0XHRcdGRpYW1zOiA5ODMwXG5cdFx0fTtcblx0XHRjb250cm9sQ2hhcmFjdGVycyA9IFtcblx0XHRcdDgzNjQsXG5cdFx0XHQxMjksXG5cdFx0XHQ4MjE4LFxuXHRcdFx0NDAyLFxuXHRcdFx0ODIyMixcblx0XHRcdDgyMzAsXG5cdFx0XHQ4MjI0LFxuXHRcdFx0ODIyNSxcblx0XHRcdDcxMCxcblx0XHRcdDgyNDAsXG5cdFx0XHQzNTIsXG5cdFx0XHQ4MjQ5LFxuXHRcdFx0MzM4LFxuXHRcdFx0MTQxLFxuXHRcdFx0MzgxLFxuXHRcdFx0MTQzLFxuXHRcdFx0MTQ0LFxuXHRcdFx0ODIxNixcblx0XHRcdDgyMTcsXG5cdFx0XHQ4MjIwLFxuXHRcdFx0ODIyMSxcblx0XHRcdDgyMjYsXG5cdFx0XHQ4MjExLFxuXHRcdFx0ODIxMixcblx0XHRcdDczMixcblx0XHRcdDg0ODIsXG5cdFx0XHQzNTMsXG5cdFx0XHQ4MjUwLFxuXHRcdFx0MzM5LFxuXHRcdFx0MTU3LFxuXHRcdFx0MzgyLFxuXHRcdFx0Mzc2XG5cdFx0XTtcblx0XHRlbnRpdHlQYXR0ZXJuID0gbmV3IFJlZ0V4cCggJyYoIz8oPzp4W1xcXFx3XFxcXGRdK3xcXFxcZCt8JyArIE9iamVjdC5rZXlzKCBodG1sRW50aXRpZXMgKS5qb2luKCAnfCcgKSArICcpKTs/JywgJ2cnICk7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzKCBodG1sICkge1xuXHRcdFx0cmV0dXJuIGh0bWwucmVwbGFjZSggZW50aXR5UGF0dGVybiwgZnVuY3Rpb24oIG1hdGNoLCBlbnRpdHkgKSB7XG5cdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHQvLyBIYW5kbGUgbmFtZWQgZW50aXRpZXNcblx0XHRcdFx0aWYgKCBlbnRpdHlbIDAgXSAhPT0gJyMnICkge1xuXHRcdFx0XHRcdGNvZGUgPSBodG1sRW50aXRpZXNbIGVudGl0eSBdO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBlbnRpdHlbIDEgXSA9PT0gJ3gnICkge1xuXHRcdFx0XHRcdGNvZGUgPSBwYXJzZUludCggZW50aXR5LnN1YnN0cmluZyggMiApLCAxNiApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvZGUgPSBwYXJzZUludCggZW50aXR5LnN1YnN0cmluZyggMSApLCAxMCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIWNvZGUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKCB2YWxpZGF0ZUNvZGUoIGNvZGUgKSApO1xuXHRcdFx0fSApO1xuXHRcdH07XG5cdFx0Ly8gc29tZSBjb2RlIHBvaW50cyBhcmUgdmVyYm90ZW4uIElmIHdlIHdlcmUgaW5zZXJ0aW5nIEhUTUwsIHRoZSBicm93c2VyIHdvdWxkIHJlcGxhY2UgdGhlIGlsbGVnYWxcblx0XHQvLyBjb2RlIHBvaW50cyB3aXRoIGFsdGVybmF0aXZlcyBpbiBzb21lIGNhc2VzIC0gc2luY2Ugd2UncmUgYnlwYXNzaW5nIHRoYXQgbWVjaGFuaXNtLCB3ZSBuZWVkXG5cdFx0Ly8gdG8gcmVwbGFjZSB0aGVtIG91cnNlbHZlc1xuXHRcdC8vXG5cdFx0Ly8gU291cmNlOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NoYXJhY3Rlcl9lbmNvZGluZ3NfaW5fSFRNTCNJbGxlZ2FsX2NoYXJhY3RlcnNcblx0XHRmdW5jdGlvbiB2YWxpZGF0ZUNvZGUoIGNvZGUgKSB7XG5cdFx0XHRpZiAoICFjb2RlICkge1xuXHRcdFx0XHRyZXR1cm4gNjU1MzM7XG5cdFx0XHR9XG5cdFx0XHQvLyBsaW5lIGZlZWQgYmVjb21lcyBnZW5lcmljIHdoaXRlc3BhY2Vcblx0XHRcdGlmICggY29kZSA9PT0gMTAgKSB7XG5cdFx0XHRcdHJldHVybiAzMjtcblx0XHRcdH1cblx0XHRcdC8vIEFTQ0lJIHJhbmdlLiAoV2h5IHNvbWVvbmUgd291bGQgdXNlIEhUTUwgZW50aXRpZXMgZm9yIEFTQ0lJIGNoYXJhY3RlcnMgSSBkb24ndCBrbm93LCBidXQuLi4pXG5cdFx0XHRpZiAoIGNvZGUgPCAxMjggKSB7XG5cdFx0XHRcdHJldHVybiBjb2RlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gY29kZSBwb2ludHMgMTI4LTE1OSBhcmUgZGVhbHQgd2l0aCBsZW5pZW50bHkgYnkgYnJvd3NlcnMsIGJ1dCB0aGV5J3JlIGluY29ycmVjdC4gV2UgbmVlZFxuXHRcdFx0Ly8gdG8gY29ycmVjdCB0aGUgbWlzdGFrZSBvciB3ZSdsbCBlbmQgdXAgd2l0aCBtaXNzaW5nIOKCrCBzaWducyBhbmQgc28gb25cblx0XHRcdGlmICggY29kZSA8PSAxNTkgKSB7XG5cdFx0XHRcdHJldHVybiBjb250cm9sQ2hhcmFjdGVyc1sgY29kZSAtIDEyOCBdO1xuXHRcdFx0fVxuXHRcdFx0Ly8gYmFzaWMgbXVsdGlsaW5ndWFsIHBsYW5lXG5cdFx0XHRpZiAoIGNvZGUgPCA1NTI5NiApIHtcblx0XHRcdFx0cmV0dXJuIGNvZGU7XG5cdFx0XHR9XG5cdFx0XHQvLyBVVEYtMTYgc3Vycm9nYXRlIGhhbHZlc1xuXHRcdFx0aWYgKCBjb2RlIDw9IDU3MzQzICkge1xuXHRcdFx0XHRyZXR1cm4gNjU1MzM7XG5cdFx0XHR9XG5cdFx0XHQvLyByZXN0IG9mIHRoZSBiYXNpYyBtdWx0aWxpbmd1YWwgcGxhbmVcblx0XHRcdGlmICggY29kZSA8PSA2NTUzNSApIHtcblx0XHRcdFx0cmV0dXJuIGNvZGU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gNjU1MzM7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggbGVnYWN5ICk7XG5cblx0LyogcGFyc2UvY29udmVydGVycy90ZXh0LmpzICovXG5cdHZhciB0ZXh0ID0gZnVuY3Rpb24oIGdldExvd2VzdEluZGV4LCBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgaW5kZXgsIHJlbWFpbmluZywgZGlzYWxsb3dlZCwgYmFycmllcjtcblx0XHRcdHJlbWFpbmluZyA9IHBhcnNlci5yZW1haW5pbmcoKTtcblx0XHRcdGJhcnJpZXIgPSBwYXJzZXIuaW5zaWRlID8gJzwvJyArIHBhcnNlci5pbnNpZGUgOiAnPCc7XG5cdFx0XHRpZiAoIHBhcnNlci5pbnNpZGUgJiYgIXBhcnNlci5pbnRlcnBvbGF0ZVsgcGFyc2VyLmluc2lkZSBdICkge1xuXHRcdFx0XHRpbmRleCA9IHJlbWFpbmluZy5pbmRleE9mKCBiYXJyaWVyICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkaXNhbGxvd2VkID0gW1xuXHRcdFx0XHRcdHBhcnNlci5kZWxpbWl0ZXJzWyAwIF0sXG5cdFx0XHRcdFx0cGFyc2VyLnRyaXBsZURlbGltaXRlcnNbIDAgXSxcblx0XHRcdFx0XHRwYXJzZXIuc3RhdGljRGVsaW1pdGVyc1sgMCBdLFxuXHRcdFx0XHRcdHBhcnNlci5zdGF0aWNUcmlwbGVEZWxpbWl0ZXJzWyAwIF1cblx0XHRcdFx0XTtcblx0XHRcdFx0Ly8gaHR0cDovL2RldmVsb3BlcnMud2hhdHdnLm9yZy9zeW50YXguaHRtbCNzeW50YXgtYXR0cmlidXRlc1xuXHRcdFx0XHRpZiAoIHBhcnNlci5pbkF0dHJpYnV0ZSA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHQvLyB3ZSdyZSBpbnNpZGUgYW4gdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlXG5cdFx0XHRcdFx0ZGlzYWxsb3dlZC5wdXNoKCAnXCInLCAnXFwnJywgJz0nLCAnPCcsICc+JywgJ2AnICk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIHBhcnNlci5pbkF0dHJpYnV0ZSApIHtcblx0XHRcdFx0XHQvLyBxdW90ZWQgYXR0cmlidXRlIHZhbHVlXG5cdFx0XHRcdFx0ZGlzYWxsb3dlZC5wdXNoKCBwYXJzZXIuaW5BdHRyaWJ1dGUgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkaXNhbGxvd2VkLnB1c2goIGJhcnJpZXIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpbmRleCA9IGdldExvd2VzdEluZGV4KCByZW1haW5pbmcsIGRpc2FsbG93ZWQgKTtcblx0XHRcdH1cblx0XHRcdGlmICggIWluZGV4ICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGlmICggaW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRpbmRleCA9IHJlbWFpbmluZy5sZW5ndGg7XG5cdFx0XHR9XG5cdFx0XHRwYXJzZXIucG9zICs9IGluZGV4O1xuXHRcdFx0cmV0dXJuIHBhcnNlci5pbnNpZGUgPyByZW1haW5pbmcuc3Vic3RyKCAwLCBpbmRleCApIDogZGVjb2RlQ2hhcmFjdGVyUmVmZXJlbmNlcyggcmVtYWluaW5nLnN1YnN0ciggMCwgaW5kZXggKSApO1xuXHRcdH07XG5cdH0oIGdldExvd2VzdEluZGV4LCBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzICk7XG5cblx0LyogcGFyc2UvY29udmVydGVycy9lbGVtZW50L2Nsb3NpbmdUYWcuanMgKi9cblx0dmFyIGNsb3NpbmdUYWcgPSBmdW5jdGlvbiggdHlwZXMgKSB7XG5cblx0XHR2YXIgY2xvc2luZ1RhZ1BhdHRlcm4gPSAvXihbYS16QS1aXXsxLH06P1thLXpBLVowLTlcXC1dKilcXHMqXFw+Lztcblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciB0YWc7XG5cdFx0XHQvLyBhcmUgd2UgbG9va2luZyBhdCBhIGNsb3NpbmcgdGFnP1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnPC8nICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0YWcgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBjbG9zaW5nVGFnUGF0dGVybiApICkge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHQ6IHR5cGVzLkNMT1NJTkdfVEFHLFxuXHRcdFx0XHRcdGU6IHRhZ1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0Ly8gV2UgaGF2ZSBhbiBpbGxlZ2FsIGNsb3NpbmcgdGFnLCByZXBvcnQgaXRcblx0XHRcdHBhcnNlci5wb3MgLT0gMjtcblx0XHRcdHBhcnNlci5lcnJvciggJ0lsbGVnYWwgY2xvc2luZyB0YWcnICk7XG5cdFx0fTtcblx0fSggdHlwZXMgKTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL2VsZW1lbnQvYXR0cmlidXRlLmpzICovXG5cdHZhciBhdHRyaWJ1dGUgPSBmdW5jdGlvbiggZ2V0TG93ZXN0SW5kZXgsIGdldE11c3RhY2hlLCBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBhdHRyaWJ1dGVOYW1lUGF0dGVybiA9IC9eW15cXHNcIic+XFwvPV0rLyxcblx0XHRcdHVucXVvdGVkQXR0cmlidXRlVmFsdWVUZXh0UGF0dGVybiA9IC9eW15cXHNcIic9PD5gXSsvO1xuXHRcdF9fZXhwb3J0ID0gZ2V0QXR0cmlidXRlO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0QXR0cmlidXRlKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgYXR0ciwgbmFtZSwgdmFsdWU7XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRuYW1lID0gcGFyc2VyLm1hdGNoUGF0dGVybiggYXR0cmlidXRlTmFtZVBhdHRlcm4gKTtcblx0XHRcdGlmICggIW5hbWUgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0YXR0ciA9IHtcblx0XHRcdFx0bmFtZTogbmFtZVxuXHRcdFx0fTtcblx0XHRcdHZhbHVlID0gZ2V0QXR0cmlidXRlVmFsdWUoIHBhcnNlciApO1xuXHRcdFx0aWYgKCB2YWx1ZSApIHtcblx0XHRcdFx0YXR0ci52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGF0dHI7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0QXR0cmlidXRlVmFsdWUoIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwgdmFsdWVTdGFydCwgc3RhcnREZXB0aCwgdmFsdWU7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICc9JyApICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0dmFsdWVTdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRzdGFydERlcHRoID0gcGFyc2VyLnNlY3Rpb25EZXB0aDtcblx0XHRcdHZhbHVlID0gZ2V0UXVvdGVkQXR0cmlidXRlVmFsdWUoIHBhcnNlciwgJ1xcJycgKSB8fCBnZXRRdW90ZWRBdHRyaWJ1dGVWYWx1ZSggcGFyc2VyLCAnXCInICkgfHwgZ2V0VW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZSggcGFyc2VyICk7XG5cdFx0XHRpZiAoIHBhcnNlci5zZWN0aW9uRGVwdGggIT09IHN0YXJ0RGVwdGggKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSB2YWx1ZVN0YXJ0O1xuXHRcdFx0XHRwYXJzZXIuZXJyb3IoICdBbiBhdHRyaWJ1dGUgdmFsdWUgbXVzdCBjb250YWluIGFzIG1hbnkgb3BlbmluZyBzZWN0aW9uIHRhZ3MgYXMgY2xvc2luZyBzZWN0aW9uIHRhZ3MnICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhdmFsdWUubGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGlmICggdmFsdWUubGVuZ3RoID09PSAxICYmIHR5cGVvZiB2YWx1ZVsgMCBdID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0cmV0dXJuIGRlY29kZUNoYXJhY3RlclJlZmVyZW5jZXMoIHZhbHVlWyAwIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlVG9rZW4oIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwgdGV4dCwgaGF5c3RhY2ssIG5lZWRsZXMsIGluZGV4O1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0dGV4dCA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIHVucXVvdGVkQXR0cmlidXRlVmFsdWVUZXh0UGF0dGVybiApO1xuXHRcdFx0aWYgKCAhdGV4dCApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRoYXlzdGFjayA9IHRleHQ7XG5cdFx0XHRuZWVkbGVzID0gW1xuXHRcdFx0XHRwYXJzZXIuZGVsaW1pdGVyc1sgMCBdLFxuXHRcdFx0XHRwYXJzZXIudHJpcGxlRGVsaW1pdGVyc1sgMCBdLFxuXHRcdFx0XHRwYXJzZXIuc3RhdGljRGVsaW1pdGVyc1sgMCBdLFxuXHRcdFx0XHRwYXJzZXIuc3RhdGljVHJpcGxlRGVsaW1pdGVyc1sgMCBdXG5cdFx0XHRdO1xuXHRcdFx0aWYgKCAoIGluZGV4ID0gZ2V0TG93ZXN0SW5kZXgoIGhheXN0YWNrLCBuZWVkbGVzICkgKSAhPT0gLTEgKSB7XG5cdFx0XHRcdHRleHQgPSB0ZXh0LnN1YnN0ciggMCwgaW5kZXggKTtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0ICsgdGV4dC5sZW5ndGg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgdG9rZW5zLCB0b2tlbjtcblx0XHRcdHBhcnNlci5pbkF0dHJpYnV0ZSA9IHRydWU7XG5cdFx0XHR0b2tlbnMgPSBbXTtcblx0XHRcdHRva2VuID0gZ2V0TXVzdGFjaGUoIHBhcnNlciApIHx8IGdldFVucXVvdGVkQXR0cmlidXRlVmFsdWVUb2tlbiggcGFyc2VyICk7XG5cdFx0XHR3aGlsZSAoIHRva2VuICE9PSBudWxsICkge1xuXHRcdFx0XHR0b2tlbnMucHVzaCggdG9rZW4gKTtcblx0XHRcdFx0dG9rZW4gPSBnZXRNdXN0YWNoZSggcGFyc2VyICkgfHwgZ2V0VW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZVRva2VuKCBwYXJzZXIgKTtcblx0XHRcdH1cblx0XHRcdGlmICggIXRva2Vucy5sZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLmluQXR0cmlidXRlID0gZmFsc2U7XG5cdFx0XHRyZXR1cm4gdG9rZW5zO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFF1b3RlZEF0dHJpYnV0ZVZhbHVlKCBwYXJzZXIsIHF1b3RlTWFyayApIHtcblx0XHRcdHZhciBzdGFydCwgdG9rZW5zLCB0b2tlbjtcblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggcXVvdGVNYXJrICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLmluQXR0cmlidXRlID0gcXVvdGVNYXJrO1xuXHRcdFx0dG9rZW5zID0gW107XG5cdFx0XHR0b2tlbiA9IGdldE11c3RhY2hlKCBwYXJzZXIgKSB8fCBnZXRRdW90ZWRTdHJpbmdUb2tlbiggcGFyc2VyLCBxdW90ZU1hcmsgKTtcblx0XHRcdHdoaWxlICggdG9rZW4gIT09IG51bGwgKSB7XG5cdFx0XHRcdHRva2Vucy5wdXNoKCB0b2tlbiApO1xuXHRcdFx0XHR0b2tlbiA9IGdldE11c3RhY2hlKCBwYXJzZXIgKSB8fCBnZXRRdW90ZWRTdHJpbmdUb2tlbiggcGFyc2VyLCBxdW90ZU1hcmsgKTtcblx0XHRcdH1cblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggcXVvdGVNYXJrICkgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRwYXJzZXIuaW5BdHRyaWJ1dGUgPSBmYWxzZTtcblx0XHRcdHJldHVybiB0b2tlbnM7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0UXVvdGVkU3RyaW5nVG9rZW4oIHBhcnNlciwgcXVvdGVNYXJrICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBpbmRleCwgaGF5c3RhY2ssIG5lZWRsZXM7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRoYXlzdGFjayA9IHBhcnNlci5yZW1haW5pbmcoKTtcblx0XHRcdG5lZWRsZXMgPSBbXG5cdFx0XHRcdHF1b3RlTWFyayxcblx0XHRcdFx0cGFyc2VyLmRlbGltaXRlcnNbIDAgXSxcblx0XHRcdFx0cGFyc2VyLnRyaXBsZURlbGltaXRlcnNbIDAgXSxcblx0XHRcdFx0cGFyc2VyLnN0YXRpY0RlbGltaXRlcnNbIDAgXSxcblx0XHRcdFx0cGFyc2VyLnN0YXRpY1RyaXBsZURlbGltaXRlcnNbIDAgXVxuXHRcdFx0XTtcblx0XHRcdGluZGV4ID0gZ2V0TG93ZXN0SW5kZXgoIGhheXN0YWNrLCBuZWVkbGVzICk7XG5cdFx0XHRpZiAoIGluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0cGFyc2VyLmVycm9yKCAnUXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZSBtdXN0IGhhdmUgYSBjbG9zaW5nIHF1b3RlJyApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhaW5kZXggKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLnBvcyArPSBpbmRleDtcblx0XHRcdHJldHVybiBoYXlzdGFjay5zdWJzdHIoIDAsIGluZGV4ICk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggZ2V0TG93ZXN0SW5kZXgsIG11c3RhY2hlLCBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzICk7XG5cblx0LyogdXRpbHMvcGFyc2VKU09OLmpzICovXG5cdHZhciBwYXJzZUpTT04gPSBmdW5jdGlvbiggUGFyc2VyLCBnZXRTdHJpbmdMaXRlcmFsLCBnZXRLZXkgKSB7XG5cblx0XHR2YXIgSnNvblBhcnNlciwgc3BlY2lhbHMsIHNwZWNpYWxzUGF0dGVybiwgbnVtYmVyUGF0dGVybiwgcGxhY2Vob2xkZXJQYXR0ZXJuLCBwbGFjZWhvbGRlckF0U3RhcnRQYXR0ZXJuLCBvbmx5V2hpdGVzcGFjZTtcblx0XHRzcGVjaWFscyA9IHtcblx0XHRcdCd0cnVlJzogdHJ1ZSxcblx0XHRcdCdmYWxzZSc6IGZhbHNlLFxuXHRcdFx0J3VuZGVmaW5lZCc6IHVuZGVmaW5lZCxcblx0XHRcdCdudWxsJzogbnVsbFxuXHRcdH07XG5cdFx0c3BlY2lhbHNQYXR0ZXJuID0gbmV3IFJlZ0V4cCggJ14oPzonICsgT2JqZWN0LmtleXMoIHNwZWNpYWxzICkuam9pbiggJ3wnICkgKyAnKScgKTtcblx0XHRudW1iZXJQYXR0ZXJuID0gL14oPzpbKy1dPykoPzooPzooPzowfFsxLTldXFxkKik/XFwuXFxkKyl8KD86KD86MHxbMS05XVxcZCopXFwuKXwoPzowfFsxLTldXFxkKikpKD86W2VFXVsrLV0/XFxkKyk/Lztcblx0XHRwbGFjZWhvbGRlclBhdHRlcm4gPSAvXFwkXFx7KFteXFx9XSspXFx9L2c7XG5cdFx0cGxhY2Vob2xkZXJBdFN0YXJ0UGF0dGVybiA9IC9eXFwkXFx7KFteXFx9XSspXFx9Lztcblx0XHRvbmx5V2hpdGVzcGFjZSA9IC9eXFxzKiQvO1xuXHRcdEpzb25QYXJzZXIgPSBQYXJzZXIuZXh0ZW5kKCB7XG5cdFx0XHRpbml0OiBmdW5jdGlvbiggc3RyLCBvcHRpb25zICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlcyA9IG9wdGlvbnMudmFsdWVzO1xuXHRcdFx0XHR0aGlzLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0fSxcblx0XHRcdHBvc3RQcm9jZXNzOiBmdW5jdGlvbiggcmVzdWx0ICkge1xuXHRcdFx0XHRpZiAoIHJlc3VsdC5sZW5ndGggIT09IDEgfHwgIW9ubHlXaGl0ZXNwYWNlLnRlc3QoIHRoaXMubGVmdG92ZXIgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHZhbHVlOiByZXN1bHRbIDAgXS52XG5cdFx0XHRcdH07XG5cdFx0XHR9LFxuXHRcdFx0Y29udmVydGVyczogW1xuXG5cdFx0XHRcdGZ1bmN0aW9uIGdldFBsYWNlaG9sZGVyKCBwYXJzZXIgKSB7XG5cdFx0XHRcdFx0dmFyIHBsYWNlaG9sZGVyO1xuXHRcdFx0XHRcdGlmICggIXBhcnNlci52YWx1ZXMgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cGxhY2Vob2xkZXIgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBwbGFjZWhvbGRlckF0U3RhcnRQYXR0ZXJuICk7XG5cdFx0XHRcdFx0aWYgKCBwbGFjZWhvbGRlciAmJiBwYXJzZXIudmFsdWVzLmhhc093blByb3BlcnR5KCBwbGFjZWhvbGRlciApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0djogcGFyc2VyLnZhbHVlc1sgcGxhY2Vob2xkZXIgXVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZ1bmN0aW9uIGdldFNwZWNpYWwoIHBhcnNlciApIHtcblx0XHRcdFx0XHR2YXIgc3BlY2lhbDtcblx0XHRcdFx0XHRpZiAoIHNwZWNpYWwgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBzcGVjaWFsc1BhdHRlcm4gKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdHY6IHNwZWNpYWxzWyBzcGVjaWFsIF1cblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRmdW5jdGlvbiBnZXROdW1iZXIoIHBhcnNlciApIHtcblx0XHRcdFx0XHR2YXIgbnVtYmVyO1xuXHRcdFx0XHRcdGlmICggbnVtYmVyID0gcGFyc2VyLm1hdGNoUGF0dGVybiggbnVtYmVyUGF0dGVybiApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0djogK251bWJlclxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZ1bmN0aW9uIGdldFN0cmluZyggcGFyc2VyICkge1xuXHRcdFx0XHRcdHZhciBzdHJpbmdMaXRlcmFsID0gZ2V0U3RyaW5nTGl0ZXJhbCggcGFyc2VyICksXG5cdFx0XHRcdFx0XHR2YWx1ZXM7XG5cdFx0XHRcdFx0aWYgKCBzdHJpbmdMaXRlcmFsICYmICggdmFsdWVzID0gcGFyc2VyLnZhbHVlcyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0djogc3RyaW5nTGl0ZXJhbC52LnJlcGxhY2UoIHBsYWNlaG9sZGVyUGF0dGVybiwgZnVuY3Rpb24oIG1hdGNoLCAkMSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gJDEgaW4gdmFsdWVzID8gdmFsdWVzWyAkMSBdIDogJDE7XG5cdFx0XHRcdFx0XHRcdH0gKVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHN0cmluZ0xpdGVyYWw7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZ1bmN0aW9uIGdldE9iamVjdCggcGFyc2VyICkge1xuXHRcdFx0XHRcdHZhciByZXN1bHQsIHBhaXI7XG5cdFx0XHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAneycgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXN1bHQgPSB7fTtcblx0XHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICd9JyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0djogcmVzdWx0XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3aGlsZSAoIHBhaXIgPSBnZXRLZXlWYWx1ZVBhaXIoIHBhcnNlciApICkge1xuXHRcdFx0XHRcdFx0cmVzdWx0WyBwYWlyLmtleSBdID0gcGFpci52YWx1ZTtcblx0XHRcdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnfScgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0XHR2OiByZXN1bHRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJywnICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fSxcblx0XHRcdFx0ZnVuY3Rpb24gZ2V0QXJyYXkoIHBhcnNlciApIHtcblx0XHRcdFx0XHR2YXIgcmVzdWx0LCB2YWx1ZVRva2VuO1xuXHRcdFx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJ1snICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVzdWx0ID0gW107XG5cdFx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnXScgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdHY6IHJlc3VsdFxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCB2YWx1ZVRva2VuID0gcGFyc2VyLnJlYWQoKSApIHtcblx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKCB2YWx1ZVRva2VuLnYgKTtcblx0XHRcdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnXScgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0XHR2OiByZXN1bHRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJywnICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XVxuXHRcdH0gKTtcblxuXHRcdGZ1bmN0aW9uIGdldEtleVZhbHVlUGFpciggcGFyc2VyICkge1xuXHRcdFx0dmFyIGtleSwgdmFsdWVUb2tlbiwgcGFpcjtcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGtleSA9IGdldEtleSggcGFyc2VyICk7XG5cdFx0XHRpZiAoICFrZXkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cGFpciA9IHtcblx0XHRcdFx0a2V5OiBrZXlcblx0XHRcdH07XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICc6JyApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdHZhbHVlVG9rZW4gPSBwYXJzZXIucmVhZCgpO1xuXHRcdFx0aWYgKCAhdmFsdWVUb2tlbiApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRwYWlyLnZhbHVlID0gdmFsdWVUb2tlbi52O1xuXHRcdFx0cmV0dXJuIHBhaXI7XG5cdFx0fVxuXHRcdHJldHVybiBmdW5jdGlvbiggc3RyLCB2YWx1ZXMgKSB7XG5cdFx0XHR2YXIgcGFyc2VyID0gbmV3IEpzb25QYXJzZXIoIHN0ciwge1xuXHRcdFx0XHR2YWx1ZXM6IHZhbHVlc1xuXHRcdFx0fSApO1xuXHRcdFx0cmV0dXJuIHBhcnNlci5yZXN1bHQ7XG5cdFx0fTtcblx0fSggUGFyc2VyLCBzdHJpbmdMaXRlcmFsLCBrZXkgKTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL2VsZW1lbnQvcHJvY2Vzc0RpcmVjdGl2ZS5qcyAqL1xuXHR2YXIgcHJvY2Vzc0RpcmVjdGl2ZSA9IGZ1bmN0aW9uKCBQYXJzZXIsIGNvbmRpdGlvbmFsLCBmbGF0dGVuRXhwcmVzc2lvbiwgcGFyc2VKU09OICkge1xuXG5cdFx0dmFyIG1ldGhvZENhbGxQYXR0ZXJuID0gL14oW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qKVxcKC8sXG5cdFx0XHRFeHByZXNzaW9uUGFyc2VyO1xuXHRcdEV4cHJlc3Npb25QYXJzZXIgPSBQYXJzZXIuZXh0ZW5kKCB7XG5cdFx0XHRjb252ZXJ0ZXJzOiBbIGNvbmRpdGlvbmFsIF1cblx0XHR9ICk7XG5cdFx0Ly8gVE9ETyBjbGVhbiB0aGlzIHVwLCBpdCdzIHNob2NraW5nXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCB0b2tlbnMgKSB7XG5cdFx0XHR2YXIgcmVzdWx0LCBtYXRjaCwgcGFyc2VyLCBhcmdzLCB0b2tlbiwgY29sb25JbmRleCwgZGlyZWN0aXZlTmFtZSwgZGlyZWN0aXZlQXJncywgcGFyc2VkO1xuXHRcdFx0aWYgKCB0eXBlb2YgdG9rZW5zID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0aWYgKCBtYXRjaCA9IG1ldGhvZENhbGxQYXR0ZXJuLmV4ZWMoIHRva2VucyApICkge1xuXHRcdFx0XHRcdHJlc3VsdCA9IHtcblx0XHRcdFx0XHRcdG06IG1hdGNoWyAxIF1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGFyZ3MgPSAnWycgKyB0b2tlbnMuc2xpY2UoIHJlc3VsdC5tLmxlbmd0aCArIDEsIC0xICkgKyAnXSc7XG5cdFx0XHRcdFx0cGFyc2VyID0gbmV3IEV4cHJlc3Npb25QYXJzZXIoIGFyZ3MgKTtcblx0XHRcdFx0XHRyZXN1bHQuYSA9IGZsYXR0ZW5FeHByZXNzaW9uKCBwYXJzZXIucmVzdWx0WyAwIF0gKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggdG9rZW5zLmluZGV4T2YoICc6JyApID09PSAtMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdG9rZW5zLnRyaW0oKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0b2tlbnMgPSBbIHRva2VucyBdO1xuXHRcdFx0fVxuXHRcdFx0cmVzdWx0ID0ge307XG5cdFx0XHRkaXJlY3RpdmVOYW1lID0gW107XG5cdFx0XHRkaXJlY3RpdmVBcmdzID0gW107XG5cdFx0XHRpZiAoIHRva2VucyApIHtcblx0XHRcdFx0d2hpbGUgKCB0b2tlbnMubGVuZ3RoICkge1xuXHRcdFx0XHRcdHRva2VuID0gdG9rZW5zLnNoaWZ0KCk7XG5cdFx0XHRcdFx0aWYgKCB0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdFx0Y29sb25JbmRleCA9IHRva2VuLmluZGV4T2YoICc6JyApO1xuXHRcdFx0XHRcdFx0aWYgKCBjb2xvbkluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0XHRcdFx0ZGlyZWN0aXZlTmFtZS5wdXNoKCB0b2tlbiApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gaXMgdGhlIGNvbG9uIHRoZSBmaXJzdCBjaGFyYWN0ZXI/XG5cdFx0XHRcdFx0XHRcdGlmICggY29sb25JbmRleCApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBub1xuXHRcdFx0XHRcdFx0XHRcdGRpcmVjdGl2ZU5hbWUucHVzaCggdG9rZW4uc3Vic3RyKCAwLCBjb2xvbkluZGV4ICkgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHQvLyBpZiB0aGVyZSBpcyBhbnl0aGluZyBhZnRlciB0aGUgY29sb24gaW4gdGhpcyB0b2tlbiwgdHJlYXRcblx0XHRcdFx0XHRcdFx0Ly8gaXQgYXMgdGhlIGZpcnN0IHRva2VuIG9mIHRoZSBkaXJlY3RpdmVBcmdzIGZyYWdtZW50XG5cdFx0XHRcdFx0XHRcdGlmICggdG9rZW4ubGVuZ3RoID4gY29sb25JbmRleCArIDEgKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGlyZWN0aXZlQXJnc1sgMCBdID0gdG9rZW4uc3Vic3RyaW5nKCBjb2xvbkluZGV4ICsgMSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRkaXJlY3RpdmVOYW1lLnB1c2goIHRva2VuICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGRpcmVjdGl2ZUFyZ3MgPSBkaXJlY3RpdmVBcmdzLmNvbmNhdCggdG9rZW5zICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFkaXJlY3RpdmVOYW1lLmxlbmd0aCApIHtcblx0XHRcdFx0cmVzdWx0ID0gJyc7XG5cdFx0XHR9IGVsc2UgaWYgKCBkaXJlY3RpdmVBcmdzLmxlbmd0aCB8fCB0eXBlb2YgZGlyZWN0aXZlTmFtZSAhPT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdHJlc3VsdCA9IHtcblx0XHRcdFx0XHQvLyBUT0RPIGlzIHRoaXMgcmVhbGx5IG5lY2Vzc2FyeT8ganVzdCB1c2UgdGhlIGFycmF5XG5cdFx0XHRcdFx0bjogZGlyZWN0aXZlTmFtZS5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGRpcmVjdGl2ZU5hbWVbIDAgXSA9PT0gJ3N0cmluZycgPyBkaXJlY3RpdmVOYW1lWyAwIF0gOiBkaXJlY3RpdmVOYW1lXG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmICggZGlyZWN0aXZlQXJncy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGRpcmVjdGl2ZUFyZ3NbIDAgXSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0cGFyc2VkID0gcGFyc2VKU09OKCAnWycgKyBkaXJlY3RpdmVBcmdzWyAwIF0gKyAnXScgKTtcblx0XHRcdFx0XHRyZXN1bHQuYSA9IHBhcnNlZCA/IHBhcnNlZC52YWx1ZSA6IGRpcmVjdGl2ZUFyZ3NbIDAgXS50cmltKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzdWx0LmQgPSBkaXJlY3RpdmVBcmdzO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXN1bHQgPSBkaXJlY3RpdmVOYW1lO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXHR9KCBQYXJzZXIsIGNvbmRpdGlvbmFsLCBmbGF0dGVuRXhwcmVzc2lvbiwgcGFyc2VKU09OICk7XG5cblx0LyogcGFyc2UvY29udmVydGVycy9lbGVtZW50LmpzICovXG5cdHZhciBlbGVtZW50ID0gZnVuY3Rpb24oIHR5cGVzLCB2b2lkRWxlbWVudE5hbWVzLCBnZXRNdXN0YWNoZSwgZ2V0Q29tbWVudCwgZ2V0VGV4dCwgZ2V0Q2xvc2luZ1RhZywgZ2V0QXR0cmlidXRlLCBwcm9jZXNzRGlyZWN0aXZlICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciB0YWdOYW1lUGF0dGVybiA9IC9eW2EtekEtWl17MSx9Oj9bYS16QS1aMC05XFwtXSovLFxuXHRcdFx0dmFsaWRUYWdOYW1lRm9sbG93ZXIgPSAvXltcXHNcXG5cXC8+XS8sXG5cdFx0XHRvblBhdHRlcm4gPSAvXm9uLyxcblx0XHRcdHByb3h5RXZlbnRQYXR0ZXJuID0gL15vbi0oW2EtekEtWlxcXFwqXFxcXC4kX11bYS16QS1aXFxcXCpcXFxcLiRfMC05XFwtXSspJC8sXG5cdFx0XHRyZXNlcnZlZEV2ZW50TmFtZXMgPSAvXig/OmNoYW5nZXxyZXNldHx0ZWFyZG93bnx1cGRhdGV8Y29uc3RydWN0fGNvbmZpZ3xpbml0fHJlbmRlcnx1bnJlbmRlcnxkZXRhY2h8aW5zZXJ0KSQvLFxuXHRcdFx0ZGlyZWN0aXZlcyA9IHtcblx0XHRcdFx0J2ludHJvLW91dHJvJzogJ3QwJyxcblx0XHRcdFx0aW50cm86ICd0MScsXG5cdFx0XHRcdG91dHJvOiAndDInLFxuXHRcdFx0XHRkZWNvcmF0b3I6ICdvJ1xuXHRcdFx0fSxcblx0XHRcdGV4Y2x1ZGUgPSB7XG5cdFx0XHRcdGV4Y2x1ZGU6IHRydWVcblx0XHRcdH0sXG5cdFx0XHRjb252ZXJ0ZXJzLCBkaXNhbGxvd2VkQ29udGVudHM7XG5cdFx0Ly8gRGlmZmVyZW50IHNldCBvZiBjb252ZXJ0ZXJzLCBiZWNhdXNlIHRoaXMgdGltZSB3ZSdyZSBsb29raW5nIGZvciBjbG9zaW5nIHRhZ3Ncblx0XHRjb252ZXJ0ZXJzID0gW1xuXHRcdFx0Z2V0TXVzdGFjaGUsXG5cdFx0XHRnZXRDb21tZW50LFxuXHRcdFx0Z2V0RWxlbWVudCxcblx0XHRcdGdldFRleHQsXG5cdFx0XHRnZXRDbG9zaW5nVGFnXG5cdFx0XTtcblx0XHQvLyBiYXNlZCBvbiBodHRwOi8vZGV2ZWxvcGVycy53aGF0d2cub3JnL3N5bnRheC5odG1sI3N5bnRheC10YWctb21pc3Npb25cblx0XHRkaXNhbGxvd2VkQ29udGVudHMgPSB7XG5cdFx0XHRsaTogWyAnbGknIF0sXG5cdFx0XHRkdDogW1xuXHRcdFx0XHQnZHQnLFxuXHRcdFx0XHQnZGQnXG5cdFx0XHRdLFxuXHRcdFx0ZGQ6IFtcblx0XHRcdFx0J2R0Jyxcblx0XHRcdFx0J2RkJ1xuXHRcdFx0XSxcblx0XHRcdHA6ICdhZGRyZXNzIGFydGljbGUgYXNpZGUgYmxvY2txdW90ZSBkaXYgZGwgZmllbGRzZXQgZm9vdGVyIGZvcm0gaDEgaDIgaDMgaDQgaDUgaDYgaGVhZGVyIGhncm91cCBociBtYWluIG1lbnUgbmF2IG9sIHAgcHJlIHNlY3Rpb24gdGFibGUgdWwnLnNwbGl0KCAnICcgKSxcblx0XHRcdHJ0OiBbXG5cdFx0XHRcdCdydCcsXG5cdFx0XHRcdCdycCdcblx0XHRcdF0sXG5cdFx0XHRycDogW1xuXHRcdFx0XHQncnQnLFxuXHRcdFx0XHQncnAnXG5cdFx0XHRdLFxuXHRcdFx0b3B0Z3JvdXA6IFsgJ29wdGdyb3VwJyBdLFxuXHRcdFx0b3B0aW9uOiBbXG5cdFx0XHRcdCdvcHRpb24nLFxuXHRcdFx0XHQnb3B0Z3JvdXAnXG5cdFx0XHRdLFxuXHRcdFx0dGhlYWQ6IFtcblx0XHRcdFx0J3Rib2R5Jyxcblx0XHRcdFx0J3Rmb290J1xuXHRcdFx0XSxcblx0XHRcdHRib2R5OiBbXG5cdFx0XHRcdCd0Ym9keScsXG5cdFx0XHRcdCd0Zm9vdCdcblx0XHRcdF0sXG5cdFx0XHR0Zm9vdDogWyAndGJvZHknIF0sXG5cdFx0XHR0cjogW1xuXHRcdFx0XHQndHInLFxuXHRcdFx0XHQndGJvZHknXG5cdFx0XHRdLFxuXHRcdFx0dGQ6IFtcblx0XHRcdFx0J3RkJyxcblx0XHRcdFx0J3RoJyxcblx0XHRcdFx0J3RyJ1xuXHRcdFx0XSxcblx0XHRcdHRoOiBbXG5cdFx0XHRcdCd0ZCcsXG5cdFx0XHRcdCd0aCcsXG5cdFx0XHRcdCd0cidcblx0XHRcdF1cblx0XHR9O1xuXHRcdF9fZXhwb3J0ID0gZ2V0RWxlbWVudDtcblxuXHRcdGZ1bmN0aW9uIGdldEVsZW1lbnQoIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwgZWxlbWVudCwgbG93ZXJDYXNlTmFtZSwgZGlyZWN0aXZlTmFtZSwgbWF0Y2gsIGFkZFByb3h5RXZlbnQsIGF0dHJpYnV0ZSwgZGlyZWN0aXZlLCBzZWxmQ2xvc2luZywgY2hpbGRyZW4sIGNoaWxkO1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0aWYgKCBwYXJzZXIuaW5zaWRlIHx8IHBhcnNlci5pbkF0dHJpYnV0ZSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICc8JyApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdC8vIGlmIHRoaXMgaXMgYSBjbG9zaW5nIHRhZywgYWJvcnQgc3RyYWlnaHQgYXdheVxuXHRcdFx0aWYgKCBwYXJzZXIubmV4dENoYXIoKSA9PT0gJy8nICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGVsZW1lbnQgPSB7XG5cdFx0XHRcdHQ6IHR5cGVzLkVMRU1FTlRcblx0XHRcdH07XG5cdFx0XHRpZiAoIHBhcnNlci5pbmNsdWRlTGluZVBvc2l0aW9ucyApIHtcblx0XHRcdFx0ZWxlbWVudC5wID0gcGFyc2VyLmdldExpbmVQb3MoIHN0YXJ0ICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJyEnICkgKSB7XG5cdFx0XHRcdGVsZW1lbnQueSA9IDE7XG5cdFx0XHR9XG5cdFx0XHQvLyBlbGVtZW50IG5hbWVcblx0XHRcdGVsZW1lbnQuZSA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIHRhZ05hbWVQYXR0ZXJuICk7XG5cdFx0XHRpZiAoICFlbGVtZW50LmUgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0Ly8gbmV4dCBjaGFyYWN0ZXIgbXVzdCBiZSB3aGl0ZXNwYWNlLCBjbG9zaW5nIHNvbGlkdXMgb3IgJz4nXG5cdFx0XHRpZiAoICF2YWxpZFRhZ05hbWVGb2xsb3dlci50ZXN0KCBwYXJzZXIubmV4dENoYXIoKSApICkge1xuXHRcdFx0XHRwYXJzZXIuZXJyb3IoICdJbGxlZ2FsIHRhZyBuYW1lJyApO1xuXHRcdFx0fVxuXHRcdFx0YWRkUHJveHlFdmVudCA9IGZ1bmN0aW9uKCBuYW1lLCBkaXJlY3RpdmUgKSB7XG5cdFx0XHRcdHZhciBkaXJlY3RpdmVOYW1lID0gZGlyZWN0aXZlLm4gfHwgZGlyZWN0aXZlO1xuXHRcdFx0XHRpZiAoIHJlc2VydmVkRXZlbnROYW1lcy50ZXN0KCBkaXJlY3RpdmVOYW1lICkgKSB7XG5cdFx0XHRcdFx0cGFyc2VyLnBvcyAtPSBkaXJlY3RpdmVOYW1lLmxlbmd0aDtcblx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoICdDYW5ub3QgdXNlIHJlc2VydmVkIGV2ZW50IG5hbWVzIChjaGFuZ2UsIHJlc2V0LCB0ZWFyZG93biwgdXBkYXRlLCBjb25zdHJ1Y3QsIGNvbmZpZywgaW5pdCwgcmVuZGVyLCB1bnJlbmRlciwgZGV0YWNoLCBpbnNlcnQpJyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsZW1lbnQudlsgbmFtZSBdID0gZGlyZWN0aXZlO1xuXHRcdFx0fTtcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdC8vIGRpcmVjdGl2ZXMgYW5kIGF0dHJpYnV0ZXNcblx0XHRcdHdoaWxlICggYXR0cmlidXRlID0gZ2V0TXVzdGFjaGUoIHBhcnNlciApIHx8IGdldEF0dHJpYnV0ZSggcGFyc2VyICkgKSB7XG5cdFx0XHRcdC8vIHJlZ3VsYXIgYXR0cmlidXRlc1xuXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZS5uYW1lICkge1xuXHRcdFx0XHRcdC8vIGludHJvLCBvdXRybywgZGVjb3JhdG9yXG5cdFx0XHRcdFx0aWYgKCBkaXJlY3RpdmVOYW1lID0gZGlyZWN0aXZlc1sgYXR0cmlidXRlLm5hbWUgXSApIHtcblx0XHRcdFx0XHRcdGVsZW1lbnRbIGRpcmVjdGl2ZU5hbWUgXSA9IHByb2Nlc3NEaXJlY3RpdmUoIGF0dHJpYnV0ZS52YWx1ZSApO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoID0gcHJveHlFdmVudFBhdHRlcm4uZXhlYyggYXR0cmlidXRlLm5hbWUgKSApIHtcblx0XHRcdFx0XHRcdGlmICggIWVsZW1lbnQudiApXG5cdFx0XHRcdFx0XHRcdGVsZW1lbnQudiA9IHt9O1xuXHRcdFx0XHRcdFx0ZGlyZWN0aXZlID0gcHJvY2Vzc0RpcmVjdGl2ZSggYXR0cmlidXRlLnZhbHVlICk7XG5cdFx0XHRcdFx0XHRhZGRQcm94eUV2ZW50KCBtYXRjaFsgMSBdLCBkaXJlY3RpdmUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKCAhcGFyc2VyLnNhbml0aXplRXZlbnRBdHRyaWJ1dGVzIHx8ICFvblBhdHRlcm4udGVzdCggYXR0cmlidXRlLm5hbWUgKSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhZWxlbWVudC5hIClcblx0XHRcdFx0XHRcdFx0XHRlbGVtZW50LmEgPSB7fTtcblx0XHRcdFx0XHRcdFx0ZWxlbWVudC5hWyBhdHRyaWJ1dGUubmFtZSBdID0gYXR0cmlidXRlLnZhbHVlIHx8IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICggIWVsZW1lbnQubSApXG5cdFx0XHRcdFx0XHRlbGVtZW50Lm0gPSBbXTtcblx0XHRcdFx0XHRlbGVtZW50Lm0ucHVzaCggYXR0cmlidXRlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZWZvcmUgY2xvc2luZyBzb2xpZHVzXG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHQvLyBzZWxmLWNsb3Npbmcgc29saWR1cz9cblx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnLycgKSApIHtcblx0XHRcdFx0c2VsZkNsb3NpbmcgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gY2xvc2luZyBhbmdsZSBicmFja2V0XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICc+JyApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGxvd2VyQ2FzZU5hbWUgPSBlbGVtZW50LmUudG9Mb3dlckNhc2UoKTtcblx0XHRcdGlmICggIXNlbGZDbG9zaW5nICYmICF2b2lkRWxlbWVudE5hbWVzLnRlc3QoIGVsZW1lbnQuZSApICkge1xuXHRcdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSBpZiB3ZSBvcGVuIGEgc2NyaXB0IGVsZW1lbnQsIGZ1cnRoZXIgdGFncyBzaG91bGRcblx0XHRcdFx0Ly8gYmUgaWdub3JlZCB1bmxlc3MgdGhleSdyZSBhIGNsb3Npbmcgc2NyaXB0IGVsZW1lbnRcblx0XHRcdFx0aWYgKCBsb3dlckNhc2VOYW1lID09PSAnc2NyaXB0JyB8fCBsb3dlckNhc2VOYW1lID09PSAnc3R5bGUnICkge1xuXHRcdFx0XHRcdHBhcnNlci5pbnNpZGUgPSBsb3dlckNhc2VOYW1lO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNoaWxkcmVuID0gW107XG5cdFx0XHRcdHdoaWxlICggY2FuQ29udGFpbiggbG93ZXJDYXNlTmFtZSwgcGFyc2VyLnJlbWFpbmluZygpICkgJiYgKCBjaGlsZCA9IHBhcnNlci5yZWFkKCBjb252ZXJ0ZXJzICkgKSApIHtcblx0XHRcdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSBjbG9zaW5nIHNlY3Rpb24gdGFnXG5cdFx0XHRcdFx0aWYgKCBjaGlsZC50ID09PSB0eXBlcy5DTE9TSU5HICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggY2hpbGQudCA9PT0gdHlwZXMuQ0xPU0lOR19UQUcgKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2hpbGRyZW4ucHVzaCggY2hpbGQgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGNoaWxkcmVuLmxlbmd0aCApIHtcblx0XHRcdFx0XHRlbGVtZW50LmYgPSBjaGlsZHJlbjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLmluc2lkZSA9IG51bGw7XG5cdFx0XHRpZiAoIHBhcnNlci5zYW5pdGl6ZUVsZW1lbnRzICYmIHBhcnNlci5zYW5pdGl6ZUVsZW1lbnRzLmluZGV4T2YoIGxvd2VyQ2FzZU5hbWUgKSAhPT0gLTEgKSB7XG5cdFx0XHRcdHJldHVybiBleGNsdWRlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGVsZW1lbnQ7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2FuQ29udGFpbiggbmFtZSwgcmVtYWluaW5nICkge1xuXHRcdFx0dmFyIG1hdGNoLCBkaXNhbGxvd2VkO1xuXHRcdFx0bWF0Y2ggPSAvXjwoW2EtekEtWl1bYS16QS1aMC05XSopLy5leGVjKCByZW1haW5pbmcgKTtcblx0XHRcdGRpc2FsbG93ZWQgPSBkaXNhbGxvd2VkQ29udGVudHNbIG5hbWUgXTtcblx0XHRcdGlmICggIW1hdGNoIHx8ICFkaXNhbGxvd2VkICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAhfmRpc2FsbG93ZWQuaW5kZXhPZiggbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpICk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggdHlwZXMsIHZvaWRFbGVtZW50TmFtZXMsIG11c3RhY2hlLCBjb21tZW50LCB0ZXh0LCBjbG9zaW5nVGFnLCBhdHRyaWJ1dGUsIHByb2Nlc3NEaXJlY3RpdmUgKTtcblxuXHQvKiBwYXJzZS91dGlscy90cmltV2hpdGVzcGFjZS5qcyAqL1xuXHR2YXIgdHJpbVdoaXRlc3BhY2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBsZWFkaW5nV2hpdGVzcGFjZSA9IC9eWyBcXHRcXGZcXHJcXG5dKy8sXG5cdFx0XHR0cmFpbGluZ1doaXRlc3BhY2UgPSAvWyBcXHRcXGZcXHJcXG5dKyQvO1xuXHRcdHJldHVybiBmdW5jdGlvbiggaXRlbXMsIGxlYWRpbmcsIHRyYWlsaW5nICkge1xuXHRcdFx0dmFyIGl0ZW07XG5cdFx0XHRpZiAoIGxlYWRpbmcgKSB7XG5cdFx0XHRcdGl0ZW0gPSBpdGVtc1sgMCBdO1xuXHRcdFx0XHRpZiAoIHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRpdGVtID0gaXRlbS5yZXBsYWNlKCBsZWFkaW5nV2hpdGVzcGFjZSwgJycgKTtcblx0XHRcdFx0XHRpZiAoICFpdGVtICkge1xuXHRcdFx0XHRcdFx0aXRlbXMuc2hpZnQoKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aXRlbXNbIDAgXSA9IGl0ZW07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRyYWlsaW5nICkge1xuXHRcdFx0XHRpdGVtID0gaXRlbXNbIGl0ZW1zLmxlbmd0aCAtIDEgXTtcblx0XHRcdFx0aWYgKCB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0aXRlbSA9IGl0ZW0ucmVwbGFjZSggdHJhaWxpbmdXaGl0ZXNwYWNlLCAnJyApO1xuXHRcdFx0XHRcdGlmICggIWl0ZW0gKSB7XG5cdFx0XHRcdFx0XHRpdGVtcy5wb3AoKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aXRlbXNbIGl0ZW1zLmxlbmd0aCAtIDEgXSA9IGl0ZW07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSgpO1xuXG5cdC8qIHBhcnNlL3V0aWxzL3N0cmlwU3RhbmRhbG9uZXMuanMgKi9cblx0dmFyIHN0cmlwU3RhbmRhbG9uZXMgPSBmdW5jdGlvbiggdHlwZXMgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIGxlYWRpbmdMaW5lYnJlYWsgPSAvXlxccypcXHI/XFxuLyxcblx0XHRcdHRyYWlsaW5nTGluZWJyZWFrID0gL1xccj9cXG5cXHMqJC87XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiggaXRlbXMgKSB7XG5cdFx0XHR2YXIgaSwgY3VycmVudCwgYmFja09uZSwgYmFja1R3bywgbGFzdFNlY3Rpb25JdGVtO1xuXHRcdFx0Zm9yICggaSA9IDE7IGkgPCBpdGVtcy5sZW5ndGg7IGkgKz0gMSApIHtcblx0XHRcdFx0Y3VycmVudCA9IGl0ZW1zWyBpIF07XG5cdFx0XHRcdGJhY2tPbmUgPSBpdGVtc1sgaSAtIDEgXTtcblx0XHRcdFx0YmFja1R3byA9IGl0ZW1zWyBpIC0gMiBdO1xuXHRcdFx0XHQvLyBpZiB3ZSdyZSBhdCB0aGUgZW5kIG9mIGEgW3RleHRdW2NvbW1lbnRdW3RleHRdIHNlcXVlbmNlLi4uXG5cdFx0XHRcdGlmICggaXNTdHJpbmcoIGN1cnJlbnQgKSAmJiBpc0NvbW1lbnQoIGJhY2tPbmUgKSAmJiBpc1N0cmluZyggYmFja1R3byApICkge1xuXHRcdFx0XHRcdC8vIC4uLiBhbmQgdGhlIGNvbW1lbnQgaXMgYSBzdGFuZGFsb25lIChpLmUuIGxpbmUgYnJlYWtzIGVpdGhlciBzaWRlKS4uLlxuXHRcdFx0XHRcdGlmICggdHJhaWxpbmdMaW5lYnJlYWsudGVzdCggYmFja1R3byApICYmIGxlYWRpbmdMaW5lYnJlYWsudGVzdCggY3VycmVudCApICkge1xuXHRcdFx0XHRcdFx0Ly8gLi4uIHRoZW4gd2Ugd2FudCB0byByZW1vdmUgdGhlIHdoaXRlc3BhY2UgYWZ0ZXIgdGhlIGZpcnN0IGxpbmUgYnJlYWtcblx0XHRcdFx0XHRcdGl0ZW1zWyBpIC0gMiBdID0gYmFja1R3by5yZXBsYWNlKCB0cmFpbGluZ0xpbmVicmVhaywgJ1xcbicgKTtcblx0XHRcdFx0XHRcdC8vIGFuZCB0aGUgbGVhZGluZyBsaW5lIGJyZWFrIG9mIHRoZSBzZWNvbmQgdGV4dCB0b2tlblxuXHRcdFx0XHRcdFx0aXRlbXNbIGkgXSA9IGN1cnJlbnQucmVwbGFjZSggbGVhZGluZ0xpbmVicmVhaywgJycgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gaWYgdGhlIGN1cnJlbnQgaXRlbSBpcyBhIHNlY3Rpb24sIGFuZCBpdCBpcyBwcmVjZWRlZCBieSBhIGxpbmVicmVhaywgYW5kXG5cdFx0XHRcdC8vIGl0cyBmaXJzdCBpdGVtIGlzIGEgbGluZWJyZWFrLi4uXG5cdFx0XHRcdGlmICggaXNTZWN0aW9uKCBjdXJyZW50ICkgJiYgaXNTdHJpbmcoIGJhY2tPbmUgKSApIHtcblx0XHRcdFx0XHRpZiAoIHRyYWlsaW5nTGluZWJyZWFrLnRlc3QoIGJhY2tPbmUgKSAmJiBpc1N0cmluZyggY3VycmVudC5mWyAwIF0gKSAmJiBsZWFkaW5nTGluZWJyZWFrLnRlc3QoIGN1cnJlbnQuZlsgMCBdICkgKSB7XG5cdFx0XHRcdFx0XHRpdGVtc1sgaSAtIDEgXSA9IGJhY2tPbmUucmVwbGFjZSggdHJhaWxpbmdMaW5lYnJlYWssICdcXG4nICk7XG5cdFx0XHRcdFx0XHRjdXJyZW50LmZbIDAgXSA9IGN1cnJlbnQuZlsgMCBdLnJlcGxhY2UoIGxlYWRpbmdMaW5lYnJlYWssICcnICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGlmIHRoZSBsYXN0IGl0ZW0gd2FzIGEgc2VjdGlvbiwgYW5kIGl0IGlzIGZvbGxvd2VkIGJ5IGEgbGluZWJyZWFrLCBhbmRcblx0XHRcdFx0Ly8gaXRzIGxhc3QgaXRlbSBpcyBhIGxpbmVicmVhay4uLlxuXHRcdFx0XHRpZiAoIGlzU3RyaW5nKCBjdXJyZW50ICkgJiYgaXNTZWN0aW9uKCBiYWNrT25lICkgKSB7XG5cdFx0XHRcdFx0bGFzdFNlY3Rpb25JdGVtID0gYmFja09uZS5mWyBiYWNrT25lLmYubGVuZ3RoIC0gMSBdO1xuXHRcdFx0XHRcdGlmICggaXNTdHJpbmcoIGxhc3RTZWN0aW9uSXRlbSApICYmIHRyYWlsaW5nTGluZWJyZWFrLnRlc3QoIGxhc3RTZWN0aW9uSXRlbSApICYmIGxlYWRpbmdMaW5lYnJlYWsudGVzdCggY3VycmVudCApICkge1xuXHRcdFx0XHRcdFx0YmFja09uZS5mWyBiYWNrT25lLmYubGVuZ3RoIC0gMSBdID0gbGFzdFNlY3Rpb25JdGVtLnJlcGxhY2UoIHRyYWlsaW5nTGluZWJyZWFrLCAnXFxuJyApO1xuXHRcdFx0XHRcdFx0aXRlbXNbIGkgXSA9IGN1cnJlbnQucmVwbGFjZSggbGVhZGluZ0xpbmVicmVhaywgJycgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBpdGVtcztcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gaXNTdHJpbmcoIGl0ZW0gKSB7XG5cdFx0XHRyZXR1cm4gdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzQ29tbWVudCggaXRlbSApIHtcblx0XHRcdHJldHVybiBpdGVtLnQgPT09IHR5cGVzLkNPTU1FTlQgfHwgaXRlbS50ID09PSB0eXBlcy5ERUxJTUNIQU5HRTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc1NlY3Rpb24oIGl0ZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBpdGVtLnQgPT09IHR5cGVzLlNFQ1RJT04gfHwgaXRlbS50ID09PSB0eXBlcy5JTlZFUlRFRCApICYmIGl0ZW0uZjtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCB0eXBlcyApO1xuXG5cdC8qIHV0aWxzL2VzY2FwZVJlZ0V4cC5qcyAqL1xuXHR2YXIgZXNjYXBlUmVnRXhwID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgcGF0dGVybiA9IC9bLS9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nO1xuXHRcdHJldHVybiBmdW5jdGlvbiBlc2NhcGVSZWdFeHAoIHN0ciApIHtcblx0XHRcdHJldHVybiBzdHIucmVwbGFjZSggcGF0dGVybiwgJ1xcXFwkJicgKTtcblx0XHR9O1xuXHR9KCk7XG5cblx0LyogcGFyc2UvX3BhcnNlLmpzICovXG5cdHZhciBwYXJzZSA9IGZ1bmN0aW9uKCB0eXBlcywgUGFyc2VyLCBtdXN0YWNoZSwgY29tbWVudCwgZWxlbWVudCwgdGV4dCwgdHJpbVdoaXRlc3BhY2UsIHN0cmlwU3RhbmRhbG9uZXMsIGVzY2FwZVJlZ0V4cCApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgU3RhbmRhcmRQYXJzZXIsIHBhcnNlLCBjb250aWd1b3VzV2hpdGVzcGFjZSA9IC9bIFxcdFxcZlxcclxcbl0rL2csXG5cdFx0XHRwcmVzZXJ2ZVdoaXRlc3BhY2VFbGVtZW50cyA9IC9eKD86cHJlfHNjcmlwdHxzdHlsZXx0ZXh0YXJlYSkkL2ksXG5cdFx0XHRsZWFkaW5nV2hpdGVzcGFjZSA9IC9eXFxzKy8sXG5cdFx0XHR0cmFpbGluZ1doaXRlc3BhY2UgPSAvXFxzKyQvO1xuXHRcdFN0YW5kYXJkUGFyc2VyID0gUGFyc2VyLmV4dGVuZCgge1xuXHRcdFx0aW5pdDogZnVuY3Rpb24oIHN0ciwgb3B0aW9ucyApIHtcblx0XHRcdFx0Ly8gY29uZmlnXG5cdFx0XHRcdHNldERlbGltaXRlcnMoIG9wdGlvbnMsIHRoaXMgKTtcblx0XHRcdFx0dGhpcy5zZWN0aW9uRGVwdGggPSAwO1xuXHRcdFx0XHR0aGlzLmludGVycG9sYXRlID0ge1xuXHRcdFx0XHRcdHNjcmlwdDogIW9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgb3B0aW9ucy5pbnRlcnBvbGF0ZS5zY3JpcHQgIT09IGZhbHNlLFxuXHRcdFx0XHRcdHN0eWxlOiAhb3B0aW9ucy5pbnRlcnBvbGF0ZSB8fCBvcHRpb25zLmludGVycG9sYXRlLnN0eWxlICE9PSBmYWxzZVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAoIG9wdGlvbnMuc2FuaXRpemUgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0b3B0aW9ucy5zYW5pdGl6ZSA9IHtcblx0XHRcdFx0XHRcdC8vIGJsYWNrbGlzdCBmcm9tIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvZ29vZ2xlLWNhamEvc291cmNlL2Jyb3dzZS90cnVuay9zcmMvY29tL2dvb2dsZS9jYWphL2xhbmcvaHRtbC9odG1sNC1lbGVtZW50cy13aGl0ZWxpc3QuanNvblxuXHRcdFx0XHRcdFx0ZWxlbWVudHM6ICdhcHBsZXQgYmFzZSBiYXNlZm9udCBib2R5IGZyYW1lIGZyYW1lc2V0IGhlYWQgaHRtbCBpc2luZGV4IGxpbmsgbWV0YSBub2ZyYW1lcyBub3NjcmlwdCBvYmplY3QgcGFyYW0gc2NyaXB0IHN0eWxlIHRpdGxlJy5zcGxpdCggJyAnICksXG5cdFx0XHRcdFx0XHRldmVudEF0dHJpYnV0ZXM6IHRydWVcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuc2FuaXRpemVFbGVtZW50cyA9IG9wdGlvbnMuc2FuaXRpemUgJiYgb3B0aW9ucy5zYW5pdGl6ZS5lbGVtZW50cztcblx0XHRcdFx0dGhpcy5zYW5pdGl6ZUV2ZW50QXR0cmlidXRlcyA9IG9wdGlvbnMuc2FuaXRpemUgJiYgb3B0aW9ucy5zYW5pdGl6ZS5ldmVudEF0dHJpYnV0ZXM7XG5cdFx0XHRcdHRoaXMuaW5jbHVkZUxpbmVQb3NpdGlvbnMgPSBvcHRpb25zLmluY2x1ZGVMaW5lUG9zaXRpb25zO1xuXHRcdFx0fSxcblx0XHRcdHBvc3RQcm9jZXNzOiBmdW5jdGlvbiggaXRlbXMsIG9wdGlvbnMgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5zZWN0aW9uRGVwdGggPiAwICkge1xuXHRcdFx0XHRcdHRoaXMuZXJyb3IoICdBIHNlY3Rpb24gd2FzIGxlZnQgb3BlbicgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjbGVhbnVwKCBpdGVtcywgb3B0aW9ucy5zdHJpcENvbW1lbnRzICE9PSBmYWxzZSwgb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UsICFvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSwgIW9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlLCBvcHRpb25zLnJld3JpdGVFbHNlICE9PSBmYWxzZSApO1xuXHRcdFx0XHRyZXR1cm4gaXRlbXM7XG5cdFx0XHR9LFxuXHRcdFx0Y29udmVydGVyczogW1xuXHRcdFx0XHRtdXN0YWNoZSxcblx0XHRcdFx0Y29tbWVudCxcblx0XHRcdFx0ZWxlbWVudCxcblx0XHRcdFx0dGV4dFxuXHRcdFx0XVxuXHRcdH0gKTtcblx0XHRwYXJzZSA9IGZ1bmN0aW9uKCB0ZW1wbGF0ZSApIHtcblx0XHRcdHZhciBvcHRpb25zID0gYXJndW1lbnRzWyAxIF07XG5cdFx0XHRpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApXG5cdFx0XHRcdG9wdGlvbnMgPSB7fTtcblx0XHRcdHZhciByZXN1bHQsIHJlbWFpbmluZywgcGFydGlhbHMsIG5hbWUsIHN0YXJ0TWF0Y2gsIGVuZE1hdGNoLCBpbmxpbmVQYXJ0aWFsU3RhcnQsIGlubGluZVBhcnRpYWxFbmQ7XG5cdFx0XHRzZXREZWxpbWl0ZXJzKCBvcHRpb25zICk7XG5cdFx0XHRpbmxpbmVQYXJ0aWFsU3RhcnQgPSBuZXcgUmVnRXhwKCAnPCEtLVxcXFxzKicgKyBlc2NhcGVSZWdFeHAoIG9wdGlvbnMuZGVsaW1pdGVyc1sgMCBdICkgKyAnXFxcXHMqPlxcXFxzKihbYS16QS1aXyRdW2EtekEtWl8kMC05XSopXFxcXHMqJyArIGVzY2FwZVJlZ0V4cCggb3B0aW9ucy5kZWxpbWl0ZXJzWyAxIF0gKSArICdcXFxccyotLT4nICk7XG5cdFx0XHRpbmxpbmVQYXJ0aWFsRW5kID0gbmV3IFJlZ0V4cCggJzwhLS1cXFxccyonICsgZXNjYXBlUmVnRXhwKCBvcHRpb25zLmRlbGltaXRlcnNbIDAgXSApICsgJ1xcXFxzKlxcXFwvXFxcXHMqKFthLXpBLVpfJF1bYS16QS1aXyQwLTldKilcXFxccyonICsgZXNjYXBlUmVnRXhwKCBvcHRpb25zLmRlbGltaXRlcnNbIDEgXSApICsgJ1xcXFxzKi0tPicgKTtcblx0XHRcdHJlc3VsdCA9IHtcblx0XHRcdFx0djogMVxuXHRcdFx0fTtcblx0XHRcdGlmICggaW5saW5lUGFydGlhbFN0YXJ0LnRlc3QoIHRlbXBsYXRlICkgKSB7XG5cdFx0XHRcdHJlbWFpbmluZyA9IHRlbXBsYXRlO1xuXHRcdFx0XHR0ZW1wbGF0ZSA9ICcnO1xuXHRcdFx0XHR3aGlsZSAoIHN0YXJ0TWF0Y2ggPSBpbmxpbmVQYXJ0aWFsU3RhcnQuZXhlYyggcmVtYWluaW5nICkgKSB7XG5cdFx0XHRcdFx0bmFtZSA9IHN0YXJ0TWF0Y2hbIDEgXTtcblx0XHRcdFx0XHR0ZW1wbGF0ZSArPSByZW1haW5pbmcuc3Vic3RyKCAwLCBzdGFydE1hdGNoLmluZGV4ICk7XG5cdFx0XHRcdFx0cmVtYWluaW5nID0gcmVtYWluaW5nLnN1YnN0cmluZyggc3RhcnRNYXRjaC5pbmRleCArIHN0YXJ0TWF0Y2hbIDAgXS5sZW5ndGggKTtcblx0XHRcdFx0XHRlbmRNYXRjaCA9IGlubGluZVBhcnRpYWxFbmQuZXhlYyggcmVtYWluaW5nICk7XG5cdFx0XHRcdFx0aWYgKCAhZW5kTWF0Y2ggfHwgZW5kTWF0Y2hbIDEgXSAhPT0gbmFtZSApIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0lubGluZSBwYXJ0aWFscyBtdXN0IGhhdmUgYSBjbG9zaW5nIGRlbGltaXRlciwgYW5kIGNhbm5vdCBiZSBuZXN0ZWQuIEV4cGVjdGVkIGNsb3NpbmcgZm9yIFwiJyArIG5hbWUgKyAnXCIsIGJ1dCAnICsgKCBlbmRNYXRjaCA/ICdpbnN0ZWFkIGZvdW5kIFwiJyArIGVuZE1hdGNoWyAxIF0gKyAnXCInIDogJyBubyBjbG9zaW5nIGZvdW5kJyApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCggcGFydGlhbHMgfHwgKCBwYXJ0aWFscyA9IHt9ICkgKVsgbmFtZSBdID0gbmV3IFN0YW5kYXJkUGFyc2VyKCByZW1haW5pbmcuc3Vic3RyKCAwLCBlbmRNYXRjaC5pbmRleCApLCBvcHRpb25zICkucmVzdWx0O1xuXHRcdFx0XHRcdHJlbWFpbmluZyA9IHJlbWFpbmluZy5zdWJzdHJpbmcoIGVuZE1hdGNoLmluZGV4ICsgZW5kTWF0Y2hbIDAgXS5sZW5ndGggKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0ZW1wbGF0ZSArPSByZW1haW5pbmc7XG5cdFx0XHRcdHJlc3VsdC5wID0gcGFydGlhbHM7XG5cdFx0XHR9XG5cdFx0XHRyZXN1bHQudCA9IG5ldyBTdGFuZGFyZFBhcnNlciggdGVtcGxhdGUsIG9wdGlvbnMgKS5yZXN1bHQ7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cdFx0X19leHBvcnQgPSBwYXJzZTtcblxuXHRcdGZ1bmN0aW9uIGNsZWFudXAoIGl0ZW1zLCBzdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlLCByZW1vdmVUcmFpbGluZ1doaXRlc3BhY2UsIHJld3JpdGVFbHNlICkge1xuXHRcdFx0dmFyIGksIGl0ZW0sIHByZXZpb3VzSXRlbSwgbmV4dEl0ZW0sIHByZXNlcnZlV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZW1vdmVMZWFkaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZW1vdmVUcmFpbGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgdW5sZXNzQmxvY2ssIGtleTtcblx0XHRcdC8vIEZpcnN0IHBhc3MgLSByZW1vdmUgc3RhbmRhbG9uZXMgYW5kIGNvbW1lbnRzIGV0Y1xuXHRcdFx0c3RyaXBTdGFuZGFsb25lcyggaXRlbXMgKTtcblx0XHRcdGkgPSBpdGVtcy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aXRlbSA9IGl0ZW1zWyBpIF07XG5cdFx0XHRcdC8vIFJlbW92ZSBkZWxpbWl0ZXIgY2hhbmdlcywgdW5zYWZlIGVsZW1lbnRzIGV0Y1xuXHRcdFx0XHRpZiAoIGl0ZW0uZXhjbHVkZSApIHtcblx0XHRcdFx0XHRpdGVtcy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0fSBlbHNlIGlmICggc3RyaXBDb21tZW50cyAmJiBpdGVtLnQgPT09IHR5cGVzLkNPTU1FTlQgKSB7XG5cdFx0XHRcdFx0aXRlbXMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIElmIG5lY2Vzc2FyeSwgcmVtb3ZlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2Vcblx0XHRcdHRyaW1XaGl0ZXNwYWNlKCBpdGVtcywgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2UsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZSApO1xuXHRcdFx0aSA9IGl0ZW1zLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpdGVtID0gaXRlbXNbIGkgXTtcblx0XHRcdFx0Ly8gUmVjdXJzZVxuXHRcdFx0XHRpZiAoIGl0ZW0uZiApIHtcblx0XHRcdFx0XHRwcmVzZXJ2ZVdoaXRlc3BhY2VJbnNpZGVGcmFnbWVudCA9IHByZXNlcnZlV2hpdGVzcGFjZSB8fCBpdGVtLnQgPT09IHR5cGVzLkVMRU1FTlQgJiYgcHJlc2VydmVXaGl0ZXNwYWNlRWxlbWVudHMudGVzdCggaXRlbS5lICk7XG5cdFx0XHRcdFx0aWYgKCAhcHJlc2VydmVXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQgKSB7XG5cdFx0XHRcdFx0XHRwcmV2aW91c0l0ZW0gPSBpdGVtc1sgaSAtIDEgXTtcblx0XHRcdFx0XHRcdG5leHRJdGVtID0gaXRlbXNbIGkgKyAxIF07XG5cdFx0XHRcdFx0XHQvLyBpZiB0aGUgcHJldmlvdXMgaXRlbSB3YXMgYSB0ZXh0IGl0ZW0gd2l0aCB0cmFpbGluZyB3aGl0ZXNwYWNlLFxuXHRcdFx0XHRcdFx0Ly8gcmVtb3ZlIGxlYWRpbmcgd2hpdGVzcGFjZSBpbnNpZGUgdGhlIGZyYWdtZW50XG5cdFx0XHRcdFx0XHRpZiAoICFwcmV2aW91c0l0ZW0gfHwgdHlwZW9mIHByZXZpb3VzSXRlbSA9PT0gJ3N0cmluZycgJiYgdHJhaWxpbmdXaGl0ZXNwYWNlLnRlc3QoIHByZXZpb3VzSXRlbSApICkge1xuXHRcdFx0XHRcdFx0XHRyZW1vdmVMZWFkaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIGFuZCB2aWNlIHZlcnNhXG5cdFx0XHRcdFx0XHRpZiAoICFuZXh0SXRlbSB8fCB0eXBlb2YgbmV4dEl0ZW0gPT09ICdzdHJpbmcnICYmIGxlYWRpbmdXaGl0ZXNwYWNlLnRlc3QoIG5leHRJdGVtICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2xlYW51cCggaXRlbS5mLCBzdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJld3JpdGVFbHNlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gU3BsaXQgaWYtZWxzZSBibG9ja3MgaW50byB0d28gKGFuIGlmLCBhbmQgYW4gdW5sZXNzKVxuXHRcdFx0XHRpZiAoIGl0ZW0ubCApIHtcblx0XHRcdFx0XHRjbGVhbnVwKCBpdGVtLmwsIHN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZSwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJld3JpdGVFbHNlICk7XG5cdFx0XHRcdFx0aWYgKCByZXdyaXRlRWxzZSApIHtcblx0XHRcdFx0XHRcdHVubGVzc0Jsb2NrID0ge1xuXHRcdFx0XHRcdFx0XHR0OiA0LFxuXHRcdFx0XHRcdFx0XHRuOiB0eXBlcy5TRUNUSU9OX1VOTEVTUyxcblx0XHRcdFx0XHRcdFx0ZjogaXRlbS5sXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0Ly8gY29weSB0aGUgY29uZGl0aW9uYWwgYmFzZWQgb24gaXRzIHR5cGVcblx0XHRcdFx0XHRcdGlmICggaXRlbS5yICkge1xuXHRcdFx0XHRcdFx0XHR1bmxlc3NCbG9jay5yID0gaXRlbS5yO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBpdGVtLnggKSB7XG5cdFx0XHRcdFx0XHRcdHVubGVzc0Jsb2NrLnggPSBpdGVtLng7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIGl0ZW0ucnggKSB7XG5cdFx0XHRcdFx0XHRcdHVubGVzc0Jsb2NrLnJ4ID0gaXRlbS5yeDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGl0ZW1zLnNwbGljZSggaSArIDEsIDAsIHVubGVzc0Jsb2NrICk7XG5cdFx0XHRcdFx0XHRkZWxldGUgaXRlbS5sO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBDbGVhbiB1cCBlbGVtZW50IGF0dHJpYnV0ZXNcblx0XHRcdFx0aWYgKCBpdGVtLmEgKSB7XG5cdFx0XHRcdFx0Zm9yICgga2V5IGluIGl0ZW0uYSApIHtcblx0XHRcdFx0XHRcdGlmICggaXRlbS5hLmhhc093blByb3BlcnR5KCBrZXkgKSAmJiB0eXBlb2YgaXRlbS5hWyBrZXkgXSAhPT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0XHRcdGNsZWFudXAoIGl0ZW0uYVsga2V5IF0sIHN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZSwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJld3JpdGVFbHNlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBmaW5hbCBwYXNzIC0gZnVzZSB0ZXh0IG5vZGVzIHRvZ2V0aGVyXG5cdFx0XHRpID0gaXRlbXMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggdHlwZW9mIGl0ZW1zWyBpIF0gPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdGlmICggdHlwZW9mIGl0ZW1zWyBpICsgMSBdID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRcdGl0ZW1zWyBpIF0gPSBpdGVtc1sgaSBdICsgaXRlbXNbIGkgKyAxIF07XG5cdFx0XHRcdFx0XHRpdGVtcy5zcGxpY2UoIGkgKyAxLCAxICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggIXByZXNlcnZlV2hpdGVzcGFjZSApIHtcblx0XHRcdFx0XHRcdGl0ZW1zWyBpIF0gPSBpdGVtc1sgaSBdLnJlcGxhY2UoIGNvbnRpZ3VvdXNXaGl0ZXNwYWNlLCAnICcgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBpdGVtc1sgaSBdID09PSAnJyApIHtcblx0XHRcdFx0XHRcdGl0ZW1zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNldERlbGltaXRlcnMoIHNvdXJjZSApIHtcblx0XHRcdHZhciB0YXJnZXQgPSBhcmd1bWVudHNbIDEgXTtcblx0XHRcdGlmICggdGFyZ2V0ID09PSB2b2lkIDAgKVxuXHRcdFx0XHR0YXJnZXQgPSBzb3VyY2U7XG5cdFx0XHR0YXJnZXQuZGVsaW1pdGVycyA9IHNvdXJjZS5kZWxpbWl0ZXJzIHx8IFtcblx0XHRcdFx0J3t7Jyxcblx0XHRcdFx0J319J1xuXHRcdFx0XTtcblx0XHRcdHRhcmdldC50cmlwbGVEZWxpbWl0ZXJzID0gc291cmNlLnRyaXBsZURlbGltaXRlcnMgfHwgW1xuXHRcdFx0XHQne3t7Jyxcblx0XHRcdFx0J319fSdcblx0XHRcdF07XG5cdFx0XHR0YXJnZXQuc3RhdGljRGVsaW1pdGVycyA9IHNvdXJjZS5zdGF0aWNEZWxpbWl0ZXJzIHx8IFtcblx0XHRcdFx0J1tbJyxcblx0XHRcdFx0J11dJ1xuXHRcdFx0XTtcblx0XHRcdHRhcmdldC5zdGF0aWNUcmlwbGVEZWxpbWl0ZXJzID0gc291cmNlLnN0YXRpY1RyaXBsZURlbGltaXRlcnMgfHwgW1xuXHRcdFx0XHQnW1tbJyxcblx0XHRcdFx0J11dXSdcblx0XHRcdF07XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggdHlwZXMsIFBhcnNlciwgbXVzdGFjaGUsIGNvbW1lbnQsIGVsZW1lbnQsIHRleHQsIHRyaW1XaGl0ZXNwYWNlLCBzdHJpcFN0YW5kYWxvbmVzLCBlc2NhcGVSZWdFeHAgKTtcblxuXHQvKiBjb25maWcvb3B0aW9ucy9ncm91cHMvb3B0aW9uR3JvdXAuanMgKi9cblx0dmFyIG9wdGlvbkdyb3VwID0gZnVuY3Rpb24oKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gY3JlYXRlT3B0aW9uR3JvdXAoIGtleXMsIGNvbmZpZyApIHtcblx0XHRcdHZhciBncm91cCA9IGtleXMubWFwKCBjb25maWcgKTtcblx0XHRcdGtleXMuZm9yRWFjaCggZnVuY3Rpb24oIGtleSwgaSApIHtcblx0XHRcdFx0Z3JvdXBbIGtleSBdID0gZ3JvdXBbIGkgXTtcblx0XHRcdH0gKTtcblx0XHRcdHJldHVybiBncm91cDtcblx0XHR9O1xuXHR9KCBsZWdhY3kgKTtcblxuXHQvKiBjb25maWcvb3B0aW9ucy9ncm91cHMvcGFyc2VPcHRpb25zLmpzICovXG5cdHZhciBwYXJzZU9wdGlvbnMgPSBmdW5jdGlvbiggb3B0aW9uR3JvdXAgKSB7XG5cblx0XHR2YXIga2V5cywgcGFyc2VPcHRpb25zO1xuXHRcdGtleXMgPSBbXG5cdFx0XHQncHJlc2VydmVXaGl0ZXNwYWNlJyxcblx0XHRcdCdzYW5pdGl6ZScsXG5cdFx0XHQnc3RyaXBDb21tZW50cycsXG5cdFx0XHQnZGVsaW1pdGVycycsXG5cdFx0XHQndHJpcGxlRGVsaW1pdGVycycsXG5cdFx0XHQnaW50ZXJwb2xhdGUnXG5cdFx0XTtcblx0XHRwYXJzZU9wdGlvbnMgPSBvcHRpb25Hcm91cCgga2V5cywgZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdHJldHVybiBrZXk7XG5cdFx0fSApO1xuXHRcdHJldHVybiBwYXJzZU9wdGlvbnM7XG5cdH0oIG9wdGlvbkdyb3VwICk7XG5cblx0LyogY29uZmlnL29wdGlvbnMvdGVtcGxhdGUvcGFyc2VyLmpzICovXG5cdHZhciBwYXJzZXIgPSBmdW5jdGlvbiggZXJyb3JzLCBpc0NsaWVudCwgcGFyc2UsIGNyZWF0ZSwgcGFyc2VPcHRpb25zICkge1xuXG5cdFx0dmFyIHBhcnNlciA9IHtcblx0XHRcdHBhcnNlOiBkb1BhcnNlLFxuXHRcdFx0ZnJvbUlkOiBmcm9tSWQsXG5cdFx0XHRpc0hhc2hlZElkOiBpc0hhc2hlZElkLFxuXHRcdFx0aXNQYXJzZWQ6IGlzUGFyc2VkLFxuXHRcdFx0Z2V0UGFyc2VPcHRpb25zOiBnZXRQYXJzZU9wdGlvbnMsXG5cdFx0XHRjcmVhdGVIZWxwZXI6IGNyZWF0ZUhlbHBlclxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBjcmVhdGVIZWxwZXIoIHBhcnNlT3B0aW9ucyApIHtcblx0XHRcdHZhciBoZWxwZXIgPSBjcmVhdGUoIHBhcnNlciApO1xuXHRcdFx0aGVscGVyLnBhcnNlID0gZnVuY3Rpb24oIHRlbXBsYXRlLCBvcHRpb25zICkge1xuXHRcdFx0XHRyZXR1cm4gZG9QYXJzZSggdGVtcGxhdGUsIG9wdGlvbnMgfHwgcGFyc2VPcHRpb25zICk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIGhlbHBlcjtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBkb1BhcnNlKCB0ZW1wbGF0ZSwgcGFyc2VPcHRpb25zICkge1xuXHRcdFx0aWYgKCAhcGFyc2UgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggZXJyb3JzLm1pc3NpbmdQYXJzZXIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwYXJzZSggdGVtcGxhdGUsIHBhcnNlT3B0aW9ucyB8fCB0aGlzLm9wdGlvbnMgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBmcm9tSWQoIGlkLCBvcHRpb25zICkge1xuXHRcdFx0dmFyIHRlbXBsYXRlO1xuXHRcdFx0aWYgKCAhaXNDbGllbnQgKSB7XG5cdFx0XHRcdGlmICggb3B0aW9ucyAmJiBvcHRpb25zLm5vVGhyb3cgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0Nhbm5vdCByZXRyaWV2ZSB0ZW1wbGF0ZSAjJyArIGlkICsgJyBhcyBSYWN0aXZlIGlzIG5vdCBydW5uaW5nIGluIGEgYnJvd3Nlci4nICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGlzSGFzaGVkSWQoIGlkICkgKSB7XG5cdFx0XHRcdGlkID0gaWQuc3Vic3RyaW5nKCAxICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICEoIHRlbXBsYXRlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIGlkICkgKSApIHtcblx0XHRcdFx0aWYgKCBvcHRpb25zICYmIG9wdGlvbnMubm9UaHJvdyApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQ291bGQgbm90IGZpbmQgdGVtcGxhdGUgZWxlbWVudCB3aXRoIGlkICMnICsgaWQgKTtcblx0XHRcdH1cblx0XHRcdGlmICggdGVtcGxhdGUudGFnTmFtZS50b1VwcGVyQ2FzZSgpICE9PSAnU0NSSVBUJyApIHtcblx0XHRcdFx0aWYgKCBvcHRpb25zICYmIG9wdGlvbnMubm9UaHJvdyApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVGVtcGxhdGUgZWxlbWVudCB3aXRoIGlkICMnICsgaWQgKyAnLCBtdXN0IGJlIGEgPHNjcmlwdD4gZWxlbWVudCcgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0ZW1wbGF0ZS5pbm5lckhUTUw7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNIYXNoZWRJZCggaWQgKSB7XG5cdFx0XHRyZXR1cm4gaWQgJiYgaWQuY2hhckF0KCAwICkgPT09ICcjJztcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc1BhcnNlZCggdGVtcGxhdGUgKSB7XG5cdFx0XHRyZXR1cm4gISggdHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJyApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFBhcnNlT3B0aW9ucyggcmFjdGl2ZSApIHtcblx0XHRcdC8vIENvdWxkIGJlIFJhY3RpdmUgb3IgYSBDb21wb25lbnRcblx0XHRcdGlmICggcmFjdGl2ZS5kZWZhdWx0cyApIHtcblx0XHRcdFx0cmFjdGl2ZSA9IHJhY3RpdmUuZGVmYXVsdHM7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcGFyc2VPcHRpb25zLnJlZHVjZSggZnVuY3Rpb24oIHZhbCwga2V5ICkge1xuXHRcdFx0XHR2YWxbIGtleSBdID0gcmFjdGl2ZVsga2V5IF07XG5cdFx0XHRcdHJldHVybiB2YWw7XG5cdFx0XHR9LCB7fSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcGFyc2VyO1xuXHR9KCBlcnJvcnMsIGlzQ2xpZW50LCBwYXJzZSwgY3JlYXRlLCBwYXJzZU9wdGlvbnMgKTtcblxuXHQvKiBjb25maWcvb3B0aW9ucy90ZW1wbGF0ZS90ZW1wbGF0ZS5qcyAqL1xuXHR2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbiggcGFyc2VyLCBwYXJzZSApIHtcblxuXHRcdHZhciB0ZW1wbGF0ZUNvbmZpZyA9IHtcblx0XHRcdG5hbWU6ICd0ZW1wbGF0ZScsXG5cdFx0XHRleHRlbmQ6IGZ1bmN0aW9uIGV4dGVuZCggUGFyZW50LCBwcm90bywgb3B0aW9ucyApIHtcblx0XHRcdFx0dmFyIHRlbXBsYXRlO1xuXHRcdFx0XHQvLyBvbmx5IGFzc2lnbiBpZiBleGlzdHNcblx0XHRcdFx0aWYgKCAndGVtcGxhdGUnIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdFx0dGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuXHRcdFx0XHRcdGlmICggdHlwZW9mIHRlbXBsYXRlID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdFx0cHJvdG8udGVtcGxhdGUgPSB0ZW1wbGF0ZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cHJvdG8udGVtcGxhdGUgPSBwYXJzZUlmU3RyaW5nKCB0ZW1wbGF0ZSwgcHJvdG8gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRpbml0OiBmdW5jdGlvbiBpbml0KCBQYXJlbnQsIHJhY3RpdmUsIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHZhciB0ZW1wbGF0ZSwgZm47XG5cdFx0XHRcdC8vIFRPRE8gYmVjYXVzZSBvZiBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB3ZSBtaWdodCBqdXN0IGJlIGFibGUgdG8gdXNlXG5cdFx0XHRcdC8vIHJhY3RpdmUudGVtcGxhdGUsIGFuZCBub3QgYm90aGVyIHBhc3NpbmcgdGhyb3VnaCB0aGUgUGFyZW50IG9iamVjdC5cblx0XHRcdFx0Ly8gQXQgcHJlc2VudCB0aGF0IGJyZWFrcyB0aGUgdGVzdCBtb2NrcycgZXhwZWN0YXRpb25zXG5cdFx0XHRcdHRlbXBsYXRlID0gJ3RlbXBsYXRlJyBpbiBvcHRpb25zID8gb3B0aW9ucy50ZW1wbGF0ZSA6IFBhcmVudC5wcm90b3R5cGUudGVtcGxhdGU7XG5cdFx0XHRcdGlmICggdHlwZW9mIHRlbXBsYXRlID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdGZuID0gdGVtcGxhdGU7XG5cdFx0XHRcdFx0dGVtcGxhdGUgPSBnZXREeW5hbWljVGVtcGxhdGUoIHJhY3RpdmUsIGZuICk7XG5cdFx0XHRcdFx0cmFjdGl2ZS5fY29uZmlnLnRlbXBsYXRlID0ge1xuXHRcdFx0XHRcdFx0Zm46IGZuLFxuXHRcdFx0XHRcdFx0cmVzdWx0OiB0ZW1wbGF0ZVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0dGVtcGxhdGUgPSBwYXJzZUlmU3RyaW5nKCB0ZW1wbGF0ZSwgcmFjdGl2ZSApO1xuXHRcdFx0XHQvLyBUT0RPIHRoZSBuYW1pbmcgb2YgdGhpcyBpcyBjb25mdXNpbmcgLSByYWN0aXZlLnRlbXBsYXRlIHJlZmVycyB0byBbLi4uXSxcblx0XHRcdFx0Ly8gYnV0IENvbXBvbmVudC5wcm90b3R5cGUudGVtcGxhdGUgcmVmZXJzIHRvIHt2OjEsdDpbXSxwOltdfS4uLlxuXHRcdFx0XHQvLyBpdCdzIHVubmVjZXNzYXJ5LCBiZWNhdXNlIHRoZSBkZXZlbG9wZXIgbmV2ZXIgbmVlZHMgdG8gYWNjZXNzXG5cdFx0XHRcdC8vIHJhY3RpdmUudGVtcGxhdGVcblx0XHRcdFx0cmFjdGl2ZS50ZW1wbGF0ZSA9IHRlbXBsYXRlLnQ7XG5cdFx0XHRcdGlmICggdGVtcGxhdGUucCApIHtcblx0XHRcdFx0XHRleHRlbmRQYXJ0aWFscyggcmFjdGl2ZS5wYXJ0aWFscywgdGVtcGxhdGUucCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cmVzZXQ6IGZ1bmN0aW9uKCByYWN0aXZlICkge1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gcmVzZXRWYWx1ZSggcmFjdGl2ZSApLFxuXHRcdFx0XHRcdHBhcnNlZDtcblx0XHRcdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRcdFx0cGFyc2VkID0gcGFyc2VJZlN0cmluZyggcmVzdWx0LCByYWN0aXZlICk7XG5cdFx0XHRcdFx0cmFjdGl2ZS50ZW1wbGF0ZSA9IHBhcnNlZC50O1xuXHRcdFx0XHRcdGV4dGVuZFBhcnRpYWxzKCByYWN0aXZlLnBhcnRpYWxzLCBwYXJzZWQucCwgdHJ1ZSApO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHJlc2V0VmFsdWUoIHJhY3RpdmUgKSB7XG5cdFx0XHR2YXIgaW5pdGlhbCA9IHJhY3RpdmUuX2NvbmZpZy50ZW1wbGF0ZSxcblx0XHRcdFx0cmVzdWx0O1xuXHRcdFx0Ly8gSWYgdGhpcyBpc24ndCBhIGR5bmFtaWMgdGVtcGxhdGUsIHRoZXJlJ3Mgbm90aGluZyB0byBkb1xuXHRcdFx0aWYgKCAhaW5pdGlhbCB8fCAhaW5pdGlhbC5mbiApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0cmVzdWx0ID0gZ2V0RHluYW1pY1RlbXBsYXRlKCByYWN0aXZlLCBpbml0aWFsLmZuICk7XG5cdFx0XHQvLyBUT0RPIGRlZXAgZXF1YWxpdHkgY2hlY2sgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSByZS1yZW5kZXJpbmdcblx0XHRcdC8vIGluIHRoZSBjYXNlIG9mIGFscmVhZHktcGFyc2VkIHRlbXBsYXRlc1xuXHRcdFx0aWYgKCByZXN1bHQgIT09IGluaXRpYWwucmVzdWx0ICkge1xuXHRcdFx0XHRpbml0aWFsLnJlc3VsdCA9IHJlc3VsdDtcblx0XHRcdFx0cmVzdWx0ID0gcGFyc2VJZlN0cmluZyggcmVzdWx0LCByYWN0aXZlICk7XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0RHluYW1pY1RlbXBsYXRlKCByYWN0aXZlLCBmbiApIHtcblx0XHRcdHZhciBoZWxwZXIgPSBwYXJzZXIuY3JlYXRlSGVscGVyKCBwYXJzZXIuZ2V0UGFyc2VPcHRpb25zKCByYWN0aXZlICkgKTtcblx0XHRcdHJldHVybiBmbi5jYWxsKCByYWN0aXZlLCByYWN0aXZlLmRhdGEsIGhlbHBlciApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlSWZTdHJpbmcoIHRlbXBsYXRlLCByYWN0aXZlICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHQvLyBJRCBvZiBhbiBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIHRlbXBsYXRlP1xuXHRcdFx0XHRpZiAoIHRlbXBsYXRlWyAwIF0gPT09ICcjJyApIHtcblx0XHRcdFx0XHR0ZW1wbGF0ZSA9IHBhcnNlci5mcm9tSWQoIHRlbXBsYXRlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGVtcGxhdGUgPSBwYXJzZSggdGVtcGxhdGUsIHBhcnNlci5nZXRQYXJzZU9wdGlvbnMoIHJhY3RpdmUgKSApO1xuXHRcdFx0fSBlbHNlIGlmICggdGVtcGxhdGUudiAhPT0gMSApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnTWlzbWF0Y2hlZCB0ZW1wbGF0ZSB2ZXJzaW9uISBQbGVhc2UgZW5zdXJlIHlvdSBhcmUgdXNpbmcgdGhlIGxhdGVzdCB2ZXJzaW9uIG9mIFJhY3RpdmUuanMgaW4geW91ciBidWlsZCBwcm9jZXNzIGFzIHdlbGwgYXMgaW4geW91ciBhcHAnICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGVtcGxhdGU7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZXh0ZW5kUGFydGlhbHMoIGV4aXN0aW5nUGFydGlhbHMsIG5ld1BhcnRpYWxzLCBvdmVyd3JpdGUgKSB7XG5cdFx0XHRpZiAoICFuZXdQYXJ0aWFscyApXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdC8vIFRPRE8gdGhlcmUncyBhbiBhbWJpZ3VpdHkgaGVyZSAtIHdlIG5lZWQgdG8gb3ZlcndyaXRlIGluIHRoZSBgcmVzZXQoKWBcblx0XHRcdC8vIGNhc2UsIGJ1dCBub3QgaW5pdGlhbGx5Li4uXG5cdFx0XHRmb3IgKCB2YXIga2V5IGluIG5ld1BhcnRpYWxzICkge1xuXHRcdFx0XHRpZiAoIG92ZXJ3cml0ZSB8fCAhZXhpc3RpbmdQYXJ0aWFscy5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgKSB7XG5cdFx0XHRcdFx0ZXhpc3RpbmdQYXJ0aWFsc1sga2V5IF0gPSBuZXdQYXJ0aWFsc1sga2V5IF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRlbXBsYXRlQ29uZmlnO1xuXHR9KCBwYXJzZXIsIHBhcnNlICk7XG5cblx0LyogY29uZmlnL29wdGlvbnMvUmVnaXN0cnkuanMgKi9cblx0dmFyIFJlZ2lzdHJ5ID0gZnVuY3Rpb24oIGNyZWF0ZSApIHtcblxuXHRcdGZ1bmN0aW9uIFJlZ2lzdHJ5KCBuYW1lLCB1c2VEZWZhdWx0cyApIHtcblx0XHRcdHRoaXMubmFtZSA9IG5hbWU7XG5cdFx0XHR0aGlzLnVzZURlZmF1bHRzID0gdXNlRGVmYXVsdHM7XG5cdFx0fVxuXHRcdFJlZ2lzdHJ5LnByb3RvdHlwZSA9IHtcblx0XHRcdGNvbnN0cnVjdG9yOiBSZWdpc3RyeSxcblx0XHRcdGV4dGVuZDogZnVuY3Rpb24oIFBhcmVudCwgcHJvdG8sIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHRoaXMuY29uZmlndXJlKCB0aGlzLnVzZURlZmF1bHRzID8gUGFyZW50LmRlZmF1bHRzIDogUGFyZW50LCB0aGlzLnVzZURlZmF1bHRzID8gcHJvdG8gOiBwcm90by5jb25zdHJ1Y3Rvciwgb3B0aW9ucyApO1xuXHRcdFx0fSxcblx0XHRcdGluaXQ6IGZ1bmN0aW9uKCBQYXJlbnQsIHJhY3RpdmUsIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHRoaXMuY29uZmlndXJlKCB0aGlzLnVzZURlZmF1bHRzID8gUGFyZW50LmRlZmF1bHRzIDogUGFyZW50LCByYWN0aXZlLCBvcHRpb25zICk7XG5cdFx0XHR9LFxuXHRcdFx0Y29uZmlndXJlOiBmdW5jdGlvbiggUGFyZW50LCB0YXJnZXQsIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHZhciBuYW1lID0gdGhpcy5uYW1lLFxuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIG5hbWUgXSxcblx0XHRcdFx0XHRyZWdpc3RyeTtcblx0XHRcdFx0cmVnaXN0cnkgPSBjcmVhdGUoIFBhcmVudFsgbmFtZSBdICk7XG5cdFx0XHRcdGZvciAoIHZhciBrZXkgaW4gb3B0aW9uICkge1xuXHRcdFx0XHRcdHJlZ2lzdHJ5WyBrZXkgXSA9IG9wdGlvblsga2V5IF07XG5cdFx0XHRcdH1cblx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSByZWdpc3RyeTtcblx0XHRcdH0sXG5cdFx0XHRyZXNldDogZnVuY3Rpb24oIHJhY3RpdmUgKSB7XG5cdFx0XHRcdHZhciByZWdpc3RyeSA9IHJhY3RpdmVbIHRoaXMubmFtZSBdO1xuXHRcdFx0XHR2YXIgY2hhbmdlZCA9IGZhbHNlO1xuXHRcdFx0XHRPYmplY3Qua2V5cyggcmVnaXN0cnkgKS5mb3JFYWNoKCBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRcdHZhciBpdGVtID0gcmVnaXN0cnlbIGtleSBdO1xuXHRcdFx0XHRcdGlmICggaXRlbS5fZm4gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGl0ZW0uX2ZuLmlzT3duZXIgKSB7XG5cdFx0XHRcdFx0XHRcdHJlZ2lzdHJ5WyBrZXkgXSA9IGl0ZW0uX2ZuO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIHJlZ2lzdHJ5WyBrZXkgXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRyZXR1cm4gY2hhbmdlZDtcblx0XHRcdH0sXG5cdFx0XHRmaW5kT3duZXI6IGZ1bmN0aW9uKCByYWN0aXZlLCBrZXkgKSB7XG5cdFx0XHRcdHJldHVybiByYWN0aXZlWyB0aGlzLm5hbWUgXS5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgPyByYWN0aXZlIDogdGhpcy5maW5kQ29uc3RydWN0b3IoIHJhY3RpdmUuY29uc3RydWN0b3IsIGtleSApO1xuXHRcdFx0fSxcblx0XHRcdGZpbmRDb25zdHJ1Y3RvcjogZnVuY3Rpb24oIGNvbnN0cnVjdG9yLCBrZXkgKSB7XG5cdFx0XHRcdGlmICggIWNvbnN0cnVjdG9yICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gY29uc3RydWN0b3JbIHRoaXMubmFtZSBdLmhhc093blByb3BlcnR5KCBrZXkgKSA/IGNvbnN0cnVjdG9yIDogdGhpcy5maW5kQ29uc3RydWN0b3IoIGNvbnN0cnVjdG9yLl9wYXJlbnQsIGtleSApO1xuXHRcdFx0fSxcblx0XHRcdGZpbmQ6IGZ1bmN0aW9uKCByYWN0aXZlLCBrZXkgKSB7XG5cdFx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0XHRyZXR1cm4gcmVjdXJzZUZpbmQoIHJhY3RpdmUsIGZ1bmN0aW9uKCByICkge1xuXHRcdFx0XHRcdHJldHVybiByWyB0aGlzJDAubmFtZSBdWyBrZXkgXTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fSxcblx0XHRcdGZpbmRJbnN0YW5jZTogZnVuY3Rpb24oIHJhY3RpdmUsIGtleSApIHtcblx0XHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHRcdHJldHVybiByZWN1cnNlRmluZCggcmFjdGl2ZSwgZnVuY3Rpb24oIHIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJbIHRoaXMkMC5uYW1lIF1bIGtleSBdID8gciA6IHZvaWQgMDtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiByZWN1cnNlRmluZCggcmFjdGl2ZSwgZm4gKSB7XG5cdFx0XHR2YXIgZmluZCwgcGFyZW50O1xuXHRcdFx0aWYgKCBmaW5kID0gZm4oIHJhY3RpdmUgKSApIHtcblx0XHRcdFx0cmV0dXJuIGZpbmQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFyYWN0aXZlLmlzb2xhdGVkICYmICggcGFyZW50ID0gcmFjdGl2ZS5fcGFyZW50ICkgKSB7XG5cdFx0XHRcdHJldHVybiByZWN1cnNlRmluZCggcGFyZW50LCBmbiApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gUmVnaXN0cnk7XG5cdH0oIGNyZWF0ZSwgbGVnYWN5ICk7XG5cblx0LyogY29uZmlnL29wdGlvbnMvZ3JvdXBzL3JlZ2lzdHJpZXMuanMgKi9cblx0dmFyIHJlZ2lzdHJpZXMgPSBmdW5jdGlvbiggb3B0aW9uR3JvdXAsIFJlZ2lzdHJ5ICkge1xuXG5cdFx0dmFyIGtleXMgPSBbXG5cdFx0XHRcdCdhZGFwdG9ycycsXG5cdFx0XHRcdCdjb21wb25lbnRzJyxcblx0XHRcdFx0J2NvbXB1dGVkJyxcblx0XHRcdFx0J2RlY29yYXRvcnMnLFxuXHRcdFx0XHQnZWFzaW5nJyxcblx0XHRcdFx0J2V2ZW50cycsXG5cdFx0XHRcdCdpbnRlcnBvbGF0b3JzJyxcblx0XHRcdFx0J3BhcnRpYWxzJyxcblx0XHRcdFx0J3RyYW5zaXRpb25zJ1xuXHRcdFx0XSxcblx0XHRcdHJlZ2lzdHJpZXMgPSBvcHRpb25Hcm91cCgga2V5cywgZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBSZWdpc3RyeSgga2V5LCBrZXkgPT09ICdjb21wdXRlZCcgKTtcblx0XHRcdH0gKTtcblx0XHRyZXR1cm4gcmVnaXN0cmllcztcblx0fSggb3B0aW9uR3JvdXAsIFJlZ2lzdHJ5ICk7XG5cblx0LyogdXRpbHMvbm9vcC5qcyAqL1xuXHR2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG5cblx0LyogdXRpbHMvd3JhcFByb3RvdHlwZU1ldGhvZC5qcyAqL1xuXHR2YXIgd3JhcFByb3RvdHlwZU1ldGhvZCA9IGZ1bmN0aW9uKCBub29wICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gd3JhcCggcGFyZW50LCBuYW1lLCBtZXRob2QgKSB7XG5cdFx0XHRpZiAoICEvX3N1cGVyLy50ZXN0KCBtZXRob2QgKSApIHtcblx0XHRcdFx0cmV0dXJuIG1ldGhvZDtcblx0XHRcdH1cblx0XHRcdHZhciB3cmFwcGVyID0gZnVuY3Rpb24gd3JhcFN1cGVyKCkge1xuXHRcdFx0XHR2YXIgc3VwZXJNZXRob2QgPSBnZXRTdXBlck1ldGhvZCggd3JhcHBlci5fcGFyZW50LCBuYW1lICksXG5cdFx0XHRcdFx0aGFzU3VwZXIgPSAnX3N1cGVyJyBpbiB0aGlzLFxuXHRcdFx0XHRcdG9sZFN1cGVyID0gdGhpcy5fc3VwZXIsXG5cdFx0XHRcdFx0cmVzdWx0O1xuXHRcdFx0XHR0aGlzLl9zdXBlciA9IHN1cGVyTWV0aG9kO1xuXHRcdFx0XHRyZXN1bHQgPSBtZXRob2QuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRpZiAoIGhhc1N1cGVyICkge1xuXHRcdFx0XHRcdHRoaXMuX3N1cGVyID0gb2xkU3VwZXI7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVsZXRlIHRoaXMuX3N1cGVyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9O1xuXHRcdFx0d3JhcHBlci5fcGFyZW50ID0gcGFyZW50O1xuXHRcdFx0d3JhcHBlci5fbWV0aG9kID0gbWV0aG9kO1xuXHRcdFx0cmV0dXJuIHdyYXBwZXI7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGdldFN1cGVyTWV0aG9kKCBwYXJlbnQsIG5hbWUgKSB7XG5cdFx0XHR2YXIgbWV0aG9kO1xuXHRcdFx0aWYgKCBuYW1lIGluIHBhcmVudCApIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gcGFyZW50WyBuYW1lIF07XG5cdFx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdG1ldGhvZCA9IHZhbHVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG1ldGhvZCA9IGZ1bmN0aW9uIHJldHVyblZhbHVlKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1ldGhvZCA9IG5vb3A7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWV0aG9kO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIG5vb3AgKTtcblxuXHQvKiBjb25maWcvZGVwcmVjYXRlLmpzICovXG5cdHZhciBkZXByZWNhdGUgPSBmdW5jdGlvbiggd2FybiwgaXNBcnJheSApIHtcblxuXHRcdGZ1bmN0aW9uIGRlcHJlY2F0ZSggb3B0aW9ucywgZGVwcmVjYXRlZCwgY29ycmVjdCApIHtcblx0XHRcdGlmICggZGVwcmVjYXRlZCBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRpZiAoICEoIGNvcnJlY3QgaW4gb3B0aW9ucyApICkge1xuXHRcdFx0XHRcdHdhcm4oIGdldE1lc3NhZ2UoIGRlcHJlY2F0ZWQsIGNvcnJlY3QgKSApO1xuXHRcdFx0XHRcdG9wdGlvbnNbIGNvcnJlY3QgXSA9IG9wdGlvbnNbIGRlcHJlY2F0ZWQgXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGdldE1lc3NhZ2UoIGRlcHJlY2F0ZWQsIGNvcnJlY3QsIHRydWUgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0TWVzc2FnZSggZGVwcmVjYXRlZCwgY29ycmVjdCwgaXNFcnJvciApIHtcblx0XHRcdHJldHVybiAnb3B0aW9ucy4nICsgZGVwcmVjYXRlZCArICcgaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiBmYXZvdXIgb2Ygb3B0aW9ucy4nICsgY29ycmVjdCArICcuJyArICggaXNFcnJvciA/ICcgWW91IGNhbm5vdCBzcGVjaWZ5IGJvdGggb3B0aW9ucywgcGxlYXNlIHVzZSBvcHRpb25zLicgKyBjb3JyZWN0ICsgJy4nIDogJycgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBkZXByZWNhdGVFdmVudERlZmluaXRpb25zKCBvcHRpb25zICkge1xuXHRcdFx0ZGVwcmVjYXRlKCBvcHRpb25zLCAnZXZlbnREZWZpbml0aW9ucycsICdldmVudHMnICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZGVwcmVjYXRlQWRhcHRvcnMoIG9wdGlvbnMgKSB7XG5cdFx0XHQvLyBVc2luZyBleHRlbmQgd2l0aCBDb21wb25lbnQgaW5zdGVhZCBvZiBvcHRpb25zLFxuXHRcdFx0Ly8gbGlrZSBIdW1hbi5leHRlbmQoIFNwaWRlciApIG1lYW5zIGFkYXB0b3JzIGFzIGEgcmVnaXN0cnlcblx0XHRcdC8vIGdldHMgY29waWVkIHRvIG9wdGlvbnMuIFNvIHdlIGhhdmUgdG8gY2hlY2sgaWYgYWN0dWFsbHkgYW4gYXJyYXlcblx0XHRcdGlmICggaXNBcnJheSggb3B0aW9ucy5hZGFwdG9ycyApICkge1xuXHRcdFx0XHRkZXByZWNhdGUoIG9wdGlvbnMsICdhZGFwdG9ycycsICdhZGFwdCcgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGRlcHJlY2F0ZU9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cdFx0XHRkZXByZWNhdGUoIG9wdGlvbnMsICdiZWZvcmVJbml0JywgJ29uY29uc3RydWN0JyApO1xuXHRcdFx0ZGVwcmVjYXRlKCBvcHRpb25zLCAnaW5pdCcsICdvbnJlbmRlcicgKTtcblx0XHRcdGRlcHJlY2F0ZSggb3B0aW9ucywgJ2NvbXBsZXRlJywgJ29uY29tcGxldGUnICk7XG5cdFx0XHRkZXByZWNhdGVFdmVudERlZmluaXRpb25zKCBvcHRpb25zICk7XG5cdFx0XHRkZXByZWNhdGVBZGFwdG9ycyggb3B0aW9ucyApO1xuXHRcdH07XG5cdH0oIHdhcm4sIGlzQXJyYXkgKTtcblxuXHQvKiBjb25maWcvY29uZmlnLmpzICovXG5cdHZhciBjb25maWcgPSBmdW5jdGlvbiggY3NzLCBkYXRhLCBkZWZhdWx0cywgdGVtcGxhdGUsIHBhcnNlT3B0aW9ucywgcmVnaXN0cmllcywgd3JhcFByb3RvdHlwZSwgZGVwcmVjYXRlICkge1xuXG5cdFx0dmFyIGN1c3RvbSwgb3B0aW9ucywgY29uZmlnLCBibGFja2xpc3RlZDtcblx0XHQvLyB3b3VsZCBiZSBuaWNlIHRvIG5vdCBoYXZlIHRoZXNlIGhlcmUsXG5cdFx0Ly8gdGhleSBnZXQgYWRkZWQgZHVyaW5nIGluaXRpYWxpc2UsIHNvIGZvciBub3cgd2UgaGF2ZVxuXHRcdC8vIHRvIG1ha2Ugc3VyZSBub3QgdG8gdHJ5IGFuZCBleHRlbmQgdGhlbS5cblx0XHQvLyBQb3NzaWJseSwgd2UgY291bGQgcmUtb3JkZXIgYW5kIG5vdCBhZGQgdGlsbCBsYXRlclxuXHRcdC8vIGluIHByb2Nlc3MuXG5cdFx0YmxhY2tsaXN0ZWQgPSB7XG5cdFx0XHQnX3BhcmVudCc6IHRydWUsXG5cdFx0XHQnX2NvbXBvbmVudCc6IHRydWVcblx0XHR9O1xuXHRcdGN1c3RvbSA9IHtcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUsXG5cdFx0XHRjc3M6IGNzc1xuXHRcdH07XG5cdFx0b3B0aW9ucyA9IE9iamVjdC5rZXlzKCBkZWZhdWx0cyApLmZpbHRlciggZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdHJldHVybiAhcmVnaXN0cmllc1sga2V5IF0gJiYgIWN1c3RvbVsga2V5IF0gJiYgIXBhcnNlT3B0aW9uc1sga2V5IF07XG5cdFx0fSApO1xuXHRcdC8vIHRoaXMgZGVmaW5lcyB0aGUgb3JkZXI6XG5cdFx0Y29uZmlnID0gW10uY29uY2F0KCBjdXN0b20uZGF0YSwgcGFyc2VPcHRpb25zLCBvcHRpb25zLCByZWdpc3RyaWVzLCBjdXN0b20udGVtcGxhdGUsIGN1c3RvbS5jc3MgKTtcblx0XHRmb3IgKCB2YXIga2V5IGluIGN1c3RvbSApIHtcblx0XHRcdGNvbmZpZ1sga2V5IF0gPSBjdXN0b21bIGtleSBdO1xuXHRcdH1cblx0XHQvLyBmb3IgaXRlcmF0aW9uXG5cdFx0Y29uZmlnLmtleXMgPSBPYmplY3Qua2V5cyggZGVmYXVsdHMgKS5jb25jYXQoIHJlZ2lzdHJpZXMubWFwKCBmdW5jdGlvbiggciApIHtcblx0XHRcdHJldHVybiByLm5hbWU7XG5cdFx0fSApICkuY29uY2F0KCBbICdjc3MnIF0gKTtcblx0XHQvLyBhZGQgdGhlc2UgdG8gYmxhY2tsaXN0ZWQga2V5J3MgdGhhdCB3ZSBkb24ndCBkb3VibGUgZXh0ZW5kXG5cdFx0Y29uZmlnLmtleXMuZm9yRWFjaCggZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdHJldHVybiBibGFja2xpc3RlZFsga2V5IF0gPSB0cnVlO1xuXHRcdH0gKTtcblx0XHRjb25maWcucGFyc2VPcHRpb25zID0gcGFyc2VPcHRpb25zO1xuXHRcdGNvbmZpZy5yZWdpc3RyaWVzID0gcmVnaXN0cmllcztcblxuXHRcdGZ1bmN0aW9uIGN1c3RvbUNvbmZpZyggbWV0aG9kLCBrZXksIFBhcmVudCwgaW5zdGFuY2UsIG9wdGlvbnMgKSB7XG5cdFx0XHRjdXN0b21bIGtleSBdWyBtZXRob2QgXSggUGFyZW50LCBpbnN0YW5jZSwgb3B0aW9ucyApO1xuXHRcdH1cblx0XHRjb25maWcuZXh0ZW5kID0gZnVuY3Rpb24oIFBhcmVudCwgcHJvdG8sIG9wdGlvbnMgKSB7XG5cdFx0XHRjb25maWd1cmUoICdleHRlbmQnLCBQYXJlbnQsIHByb3RvLCBvcHRpb25zICk7XG5cdFx0fTtcblx0XHRjb25maWcuaW5pdCA9IGZ1bmN0aW9uKCBQYXJlbnQsIHJhY3RpdmUsIG9wdGlvbnMgKSB7XG5cdFx0XHRjb25maWd1cmUoICdpbml0JywgUGFyZW50LCByYWN0aXZlLCBvcHRpb25zICk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGlzU3RhbmRhcmREZWZhdWx0S2V5KCBrZXkgKSB7XG5cdFx0XHRyZXR1cm4ga2V5IGluIGRlZmF1bHRzICYmICEoIGtleSBpbiBjb25maWcucGFyc2VPcHRpb25zICkgJiYgISgga2V5IGluIGN1c3RvbSApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNvbmZpZ3VyZSggbWV0aG9kLCBQYXJlbnQsIGluc3RhbmNlLCBvcHRpb25zICkge1xuXHRcdFx0ZGVwcmVjYXRlKCBvcHRpb25zICk7XG5cdFx0XHRjdXN0b21Db25maWcoIG1ldGhvZCwgJ2RhdGEnLCBQYXJlbnQsIGluc3RhbmNlLCBvcHRpb25zICk7XG5cdFx0XHRjb25maWcucGFyc2VPcHRpb25zLmZvckVhY2goIGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdGlmICgga2V5IGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdFx0aW5zdGFuY2VbIGtleSBdID0gb3B0aW9uc1sga2V5IF07XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHRcdGZvciAoIHZhciBrZXkgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0aWYgKCBpc1N0YW5kYXJkRGVmYXVsdEtleSgga2V5ICkgKSB7XG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gb3B0aW9uc1sga2V5IF07XG5cdFx0XHRcdFx0aW5zdGFuY2VbIGtleSBdID0gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gd3JhcFByb3RvdHlwZSggUGFyZW50LnByb3RvdHlwZSwga2V5LCB2YWx1ZSApIDogdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNvbmZpZy5yZWdpc3RyaWVzLmZvckVhY2goIGZ1bmN0aW9uKCByZWdpc3RyeSApIHtcblx0XHRcdFx0cmVnaXN0cnlbIG1ldGhvZCBdKCBQYXJlbnQsIGluc3RhbmNlLCBvcHRpb25zICk7XG5cdFx0XHR9ICk7XG5cdFx0XHRjdXN0b21Db25maWcoIG1ldGhvZCwgJ3RlbXBsYXRlJywgUGFyZW50LCBpbnN0YW5jZSwgb3B0aW9ucyApO1xuXHRcdFx0Y3VzdG9tQ29uZmlnKCBtZXRob2QsICdjc3MnLCBQYXJlbnQsIGluc3RhbmNlLCBvcHRpb25zICk7XG5cdFx0XHRleHRlbmRPdGhlck1ldGhvZHMoIFBhcmVudC5wcm90b3R5cGUsIGluc3RhbmNlLCBvcHRpb25zICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZXh0ZW5kT3RoZXJNZXRob2RzKCBwYXJlbnQsIGluc3RhbmNlLCBvcHRpb25zICkge1xuXHRcdFx0Zm9yICggdmFyIGtleSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRpZiAoICEoIGtleSBpbiBibGFja2xpc3RlZCApICYmIG9wdGlvbnMuaGFzT3duUHJvcGVydHkoIGtleSApICkge1xuXHRcdFx0XHRcdHZhciBtZW1iZXIgPSBvcHRpb25zWyBrZXkgXTtcblx0XHRcdFx0XHQvLyBpZiB0aGlzIGlzIGEgbWV0aG9kIHRoYXQgb3ZlcndyaXRlcyBhIG1ldGhvZCwgd3JhcCBpdDpcblx0XHRcdFx0XHRpZiAoIHR5cGVvZiBtZW1iZXIgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdFx0XHRtZW1iZXIgPSB3cmFwUHJvdG90eXBlKCBwYXJlbnQsIGtleSwgbWVtYmVyICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGluc3RhbmNlWyBrZXkgXSA9IG1lbWJlcjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRjb25maWcucmVzZXQgPSBmdW5jdGlvbiggcmFjdGl2ZSApIHtcblx0XHRcdHJldHVybiBjb25maWcuZmlsdGVyKCBmdW5jdGlvbiggYyApIHtcblx0XHRcdFx0cmV0dXJuIGMucmVzZXQgJiYgYy5yZXNldCggcmFjdGl2ZSApO1xuXHRcdFx0fSApLm1hcCggZnVuY3Rpb24oIGMgKSB7XG5cdFx0XHRcdHJldHVybiBjLm5hbWU7XG5cdFx0XHR9ICk7XG5cdFx0fTtcblx0XHRjb25maWcuZ2V0Q29uc3RydWN0VGFyZ2V0ID0gZnVuY3Rpb24oIHJhY3RpdmUsIG9wdGlvbnMgKSB7XG5cdFx0XHRpZiAoIG9wdGlvbnMub25jb25zdHJ1Y3QgKSB7XG5cdFx0XHRcdC8vIHByZXRlbmQgdGhpcyBvYmplY3QgbGl0ZXJhbCBpcyB0aGUgcmFjdGl2ZSBpbnN0YW5jZVxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdG9uY29uc3RydWN0OiB3cmFwUHJvdG90eXBlKCByYWN0aXZlLCAnb25jb25zdHJ1Y3QnLCBvcHRpb25zLm9uY29uc3RydWN0ICkuYmluZCggcmFjdGl2ZSApLFxuXHRcdFx0XHRcdGZpcmU6IHJhY3RpdmUuZmlyZS5iaW5kKCByYWN0aXZlIClcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiByYWN0aXZlO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIGNvbmZpZztcblx0fSggY3NzLCBkYXRhLCBvcHRpb25zLCB0ZW1wbGF0ZSwgcGFyc2VPcHRpb25zLCByZWdpc3RyaWVzLCB3cmFwUHJvdG90eXBlTWV0aG9kLCBkZXByZWNhdGUgKTtcblxuXHQvKiBzaGFyZWQvaW50ZXJwb2xhdGUuanMgKi9cblx0dmFyIGludGVycG9sYXRlID0gZnVuY3Rpb24oIGNpcmN1bGFyLCB3YXJuLCBpbnRlcnBvbGF0b3JzLCBjb25maWcgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIGludGVycG9sYXRlID0gZnVuY3Rpb24oIGZyb20sIHRvLCByYWN0aXZlLCB0eXBlICkge1xuXHRcdFx0aWYgKCBmcm9tID09PSB0byApIHtcblx0XHRcdFx0cmV0dXJuIHNuYXAoIHRvICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHR5cGUgKSB7XG5cdFx0XHRcdHZhciBpbnRlcnBvbCA9IGNvbmZpZy5yZWdpc3RyaWVzLmludGVycG9sYXRvcnMuZmluZCggcmFjdGl2ZSwgdHlwZSApO1xuXHRcdFx0XHRpZiAoIGludGVycG9sICkge1xuXHRcdFx0XHRcdHJldHVybiBpbnRlcnBvbCggZnJvbSwgdG8gKSB8fCBzbmFwKCB0byApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHdhcm4oICdNaXNzaW5nIFwiJyArIHR5cGUgKyAnXCIgaW50ZXJwb2xhdG9yLiBZb3UgbWF5IG5lZWQgdG8gZG93bmxvYWQgYSBwbHVnaW4gZnJvbSBbVE9ET10nICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaW50ZXJwb2xhdG9ycy5udW1iZXIoIGZyb20sIHRvICkgfHwgaW50ZXJwb2xhdG9ycy5hcnJheSggZnJvbSwgdG8gKSB8fCBpbnRlcnBvbGF0b3JzLm9iamVjdCggZnJvbSwgdG8gKSB8fCBzbmFwKCB0byApO1xuXHRcdH07XG5cdFx0Y2lyY3VsYXIuaW50ZXJwb2xhdGUgPSBpbnRlcnBvbGF0ZTtcblx0XHRfX2V4cG9ydCA9IGludGVycG9sYXRlO1xuXG5cdFx0ZnVuY3Rpb24gc25hcCggdG8gKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0bztcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggY2lyY3VsYXIsIHdhcm4sIGludGVycG9sYXRvcnMsIGNvbmZpZyApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL2FuaW1hdGUvQW5pbWF0aW9uLmpzICovXG5cdHZhciBSYWN0aXZlJGFuaW1hdGVfQW5pbWF0aW9uID0gZnVuY3Rpb24oIHdhcm4sIHJ1bmxvb3AsIGludGVycG9sYXRlICkge1xuXG5cdFx0dmFyIEFuaW1hdGlvbiA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0dmFyIGtleTtcblx0XHRcdHRoaXMuc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblx0XHRcdC8vIGZyb20gYW5kIHRvXG5cdFx0XHRmb3IgKCBrZXkgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0aWYgKCBvcHRpb25zLmhhc093blByb3BlcnR5KCBrZXkgKSApIHtcblx0XHRcdFx0XHR0aGlzWyBrZXkgXSA9IG9wdGlvbnNbIGtleSBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmludGVycG9sYXRvciA9IGludGVycG9sYXRlKCB0aGlzLmZyb20sIHRoaXMudG8sIHRoaXMucm9vdCwgdGhpcy5pbnRlcnBvbGF0b3IgKTtcblx0XHRcdHRoaXMucnVubmluZyA9IHRydWU7XG5cdFx0XHR0aGlzLnRpY2soKTtcblx0XHR9O1xuXHRcdEFuaW1hdGlvbi5wcm90b3R5cGUgPSB7XG5cdFx0XHR0aWNrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsYXBzZWQsIHQsIHZhbHVlLCB0aW1lTm93LCBpbmRleCwga2V5cGF0aDtcblx0XHRcdFx0a2V5cGF0aCA9IHRoaXMua2V5cGF0aDtcblx0XHRcdFx0aWYgKCB0aGlzLnJ1bm5pbmcgKSB7XG5cdFx0XHRcdFx0dGltZU5vdyA9IERhdGUubm93KCk7XG5cdFx0XHRcdFx0ZWxhcHNlZCA9IHRpbWVOb3cgLSB0aGlzLnN0YXJ0VGltZTtcblx0XHRcdFx0XHRpZiAoIGVsYXBzZWQgPj0gdGhpcy5kdXJhdGlvbiApIHtcblx0XHRcdFx0XHRcdGlmICgga2V5cGF0aCAhPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdFx0cnVubG9vcC5zdGFydCggdGhpcy5yb290ICk7XG5cdFx0XHRcdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KCBrZXlwYXRoLCB0aGlzLnRvICk7XG5cdFx0XHRcdFx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIHRoaXMuc3RlcCApIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5zdGVwKCAxLCB0aGlzLnRvICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLmNvbXBsZXRlKCB0aGlzLnRvICk7XG5cdFx0XHRcdFx0XHRpbmRleCA9IHRoaXMucm9vdC5fYW5pbWF0aW9ucy5pbmRleE9mKCB0aGlzICk7XG5cdFx0XHRcdFx0XHQvLyBUT0RPIGludmVzdGlnYXRlIHdoeSB0aGlzIGhhcHBlbnNcblx0XHRcdFx0XHRcdGlmICggaW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRcdFx0XHR3YXJuKCAnQW5pbWF0aW9uIHdhcyBub3QgZm91bmQnICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLnJvb3QuX2FuaW1hdGlvbnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHRcdFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHQgPSB0aGlzLmVhc2luZyA/IHRoaXMuZWFzaW5nKCBlbGFwc2VkIC8gdGhpcy5kdXJhdGlvbiApIDogZWxhcHNlZCAvIHRoaXMuZHVyYXRpb247XG5cdFx0XHRcdFx0aWYgKCBrZXlwYXRoICE9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSB0aGlzLmludGVycG9sYXRvciggdCApO1xuXHRcdFx0XHRcdFx0cnVubG9vcC5zdGFydCggdGhpcy5yb290ICk7XG5cdFx0XHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCgga2V5cGF0aCwgdmFsdWUgKTtcblx0XHRcdFx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggdGhpcy5zdGVwICkge1xuXHRcdFx0XHRcdFx0dGhpcy5zdGVwKCB0LCB2YWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBpbmRleDtcblx0XHRcdFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cdFx0XHRcdGluZGV4ID0gdGhpcy5yb290Ll9hbmltYXRpb25zLmluZGV4T2YoIHRoaXMgKTtcblx0XHRcdFx0Ly8gVE9ETyBpbnZlc3RpZ2F0ZSB3aHkgdGhpcyBoYXBwZW5zXG5cdFx0XHRcdGlmICggaW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRcdHdhcm4oICdBbmltYXRpb24gd2FzIG5vdCBmb3VuZCcgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnJvb3QuX2FuaW1hdGlvbnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIEFuaW1hdGlvbjtcblx0fSggd2FybiwgcnVubG9vcCwgaW50ZXJwb2xhdGUgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9hbmltYXRlLmpzICovXG5cdHZhciBSYWN0aXZlJGFuaW1hdGUgPSBmdW5jdGlvbiggaXNFcXVhbCwgUHJvbWlzZSwgbm9ybWFsaXNlS2V5cGF0aCwgYW5pbWF0aW9ucywgQW5pbWF0aW9uICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBub29wID0gZnVuY3Rpb24oKSB7fSxcblx0XHRcdG5vQW5pbWF0aW9uID0ge1xuXHRcdFx0XHRzdG9wOiBub29wXG5cdFx0XHR9O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gUmFjdGl2ZSRhbmltYXRlKCBrZXlwYXRoLCB0bywgb3B0aW9ucyApIHtcblx0XHRcdHZhciBwcm9taXNlLCBmdWxmaWxQcm9taXNlLCBrLCBhbmltYXRpb24sIGFuaW1hdGlvbnMsIGVhc2luZywgZHVyYXRpb24sIHN0ZXAsIGNvbXBsZXRlLCBtYWtlVmFsdWVDb2xsZWN0b3IsIGN1cnJlbnRWYWx1ZXMsIGNvbGxlY3RWYWx1ZSwgZHVtbXksIGR1bW15T3B0aW9ucztcblx0XHRcdHByb21pc2UgPSBuZXcgUHJvbWlzZSggZnVuY3Rpb24oIGZ1bGZpbCApIHtcblx0XHRcdFx0ZnVsZmlsUHJvbWlzZSA9IGZ1bGZpbDtcblx0XHRcdH0gKTtcblx0XHRcdC8vIGFuaW1hdGUgbXVsdGlwbGUga2V5cGF0aHNcblx0XHRcdGlmICggdHlwZW9mIGtleXBhdGggPT09ICdvYmplY3QnICkge1xuXHRcdFx0XHRvcHRpb25zID0gdG8gfHwge307XG5cdFx0XHRcdGVhc2luZyA9IG9wdGlvbnMuZWFzaW5nO1xuXHRcdFx0XHRkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb247XG5cdFx0XHRcdGFuaW1hdGlvbnMgPSBbXTtcblx0XHRcdFx0Ly8gd2UgZG9uJ3Qgd2FudCB0byBwYXNzIHRoZSBgc3RlcGAgYW5kIGBjb21wbGV0ZWAgaGFuZGxlcnMsIGFzIHRoZXkgd2lsbFxuXHRcdFx0XHQvLyBydW4gZm9yIGVhY2ggYW5pbWF0aW9uISBTbyBpbnN0ZWFkIHdlJ2xsIHN0b3JlIHRoZSBoYW5kbGVycyBhbmQgY3JlYXRlXG5cdFx0XHRcdC8vIG91ciBvd24uLi5cblx0XHRcdFx0c3RlcCA9IG9wdGlvbnMuc3RlcDtcblx0XHRcdFx0Y29tcGxldGUgPSBvcHRpb25zLmNvbXBsZXRlO1xuXHRcdFx0XHRpZiAoIHN0ZXAgfHwgY29tcGxldGUgKSB7XG5cdFx0XHRcdFx0Y3VycmVudFZhbHVlcyA9IHt9O1xuXHRcdFx0XHRcdG9wdGlvbnMuc3RlcCA9IG51bGw7XG5cdFx0XHRcdFx0b3B0aW9ucy5jb21wbGV0ZSA9IG51bGw7XG5cdFx0XHRcdFx0bWFrZVZhbHVlQ29sbGVjdG9yID0gZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHQsIHZhbHVlICkge1xuXHRcdFx0XHRcdFx0XHRjdXJyZW50VmFsdWVzWyBrZXlwYXRoIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKCBrIGluIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0aWYgKCBrZXlwYXRoLmhhc093blByb3BlcnR5KCBrICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIHN0ZXAgfHwgY29tcGxldGUgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbGxlY3RWYWx1ZSA9IG1ha2VWYWx1ZUNvbGxlY3RvciggayApO1xuXHRcdFx0XHRcdFx0XHRvcHRpb25zID0ge1xuXHRcdFx0XHRcdFx0XHRcdGVhc2luZzogZWFzaW5nLFxuXHRcdFx0XHRcdFx0XHRcdGR1cmF0aW9uOiBkdXJhdGlvblxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRpZiAoIHN0ZXAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5zdGVwID0gY29sbGVjdFZhbHVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRvcHRpb25zLmNvbXBsZXRlID0gY29tcGxldGUgPyBjb2xsZWN0VmFsdWUgOiBub29wO1xuXHRcdFx0XHRcdFx0YW5pbWF0aW9ucy5wdXNoKCBhbmltYXRlKCB0aGlzLCBrLCBrZXlwYXRoWyBrIF0sIG9wdGlvbnMgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBDcmVhdGUgYSBkdW1teSBhbmltYXRpb24sIHRvIGZhY2lsaXRhdGUgc3RlcC9jb21wbGV0ZVxuXHRcdFx0XHQvLyBjYWxsYmFja3MsIGFuZCBQcm9taXNlIGZ1bGZpbG1lbnRcblx0XHRcdFx0ZHVtbXlPcHRpb25zID0ge1xuXHRcdFx0XHRcdGVhc2luZzogZWFzaW5nLFxuXHRcdFx0XHRcdGR1cmF0aW9uOiBkdXJhdGlvblxuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAoIHN0ZXAgKSB7XG5cdFx0XHRcdFx0ZHVtbXlPcHRpb25zLnN0ZXAgPSBmdW5jdGlvbiggdCApIHtcblx0XHRcdFx0XHRcdHN0ZXAoIHQsIGN1cnJlbnRWYWx1ZXMgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggY29tcGxldGUgKSB7XG5cdFx0XHRcdFx0cHJvbWlzZS50aGVuKCBmdW5jdGlvbiggdCApIHtcblx0XHRcdFx0XHRcdGNvbXBsZXRlKCB0LCBjdXJyZW50VmFsdWVzICk7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGR1bW15T3B0aW9ucy5jb21wbGV0ZSA9IGZ1bGZpbFByb21pc2U7XG5cdFx0XHRcdGR1bW15ID0gYW5pbWF0ZSggdGhpcywgbnVsbCwgbnVsbCwgZHVtbXlPcHRpb25zICk7XG5cdFx0XHRcdGFuaW1hdGlvbnMucHVzaCggZHVtbXkgKTtcblx0XHRcdFx0cHJvbWlzZS5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIGFuaW1hdGlvbjtcblx0XHRcdFx0XHR3aGlsZSAoIGFuaW1hdGlvbiA9IGFuaW1hdGlvbnMucG9wKCkgKSB7XG5cdFx0XHRcdFx0XHRhbmltYXRpb24uc3RvcCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIGR1bW15ICkge1xuXHRcdFx0XHRcdFx0ZHVtbXkuc3RvcCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0XHR9XG5cdFx0XHQvLyBhbmltYXRlIGEgc2luZ2xlIGtleXBhdGhcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdFx0aWYgKCBvcHRpb25zLmNvbXBsZXRlICkge1xuXHRcdFx0XHRwcm9taXNlLnRoZW4oIG9wdGlvbnMuY29tcGxldGUgKTtcblx0XHRcdH1cblx0XHRcdG9wdGlvbnMuY29tcGxldGUgPSBmdWxmaWxQcm9taXNlO1xuXHRcdFx0YW5pbWF0aW9uID0gYW5pbWF0ZSggdGhpcywga2V5cGF0aCwgdG8sIG9wdGlvbnMgKTtcblx0XHRcdHByb21pc2Uuc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRhbmltYXRpb24uc3RvcCgpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBhbmltYXRlKCByb290LCBrZXlwYXRoLCB0bywgb3B0aW9ucyApIHtcblx0XHRcdHZhciBlYXNpbmcsIGR1cmF0aW9uLCBhbmltYXRpb24sIGZyb207XG5cdFx0XHRpZiAoIGtleXBhdGggKSB7XG5cdFx0XHRcdGtleXBhdGggPSBub3JtYWxpc2VLZXlwYXRoKCBrZXlwYXRoICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGtleXBhdGggIT09IG51bGwgKSB7XG5cdFx0XHRcdGZyb20gPSByb290LnZpZXdtb2RlbC5nZXQoIGtleXBhdGggKTtcblx0XHRcdH1cblx0XHRcdC8vIGNhbmNlbCBhbnkgZXhpc3RpbmcgYW5pbWF0aW9uXG5cdFx0XHQvLyBUT0RPIHdoYXQgYWJvdXQgdXBzdHJlYW0vZG93bnN0cmVhbSBrZXlwYXRocz9cblx0XHRcdGFuaW1hdGlvbnMuYWJvcnQoIGtleXBhdGgsIHJvb3QgKTtcblx0XHRcdC8vIGRvbid0IGJvdGhlciBhbmltYXRpbmcgdmFsdWVzIHRoYXQgc3RheSB0aGUgc2FtZVxuXHRcdFx0aWYgKCBpc0VxdWFsKCBmcm9tLCB0byApICkge1xuXHRcdFx0XHRpZiAoIG9wdGlvbnMuY29tcGxldGUgKSB7XG5cdFx0XHRcdFx0b3B0aW9ucy5jb21wbGV0ZSggb3B0aW9ucy50byApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBub0FuaW1hdGlvbjtcblx0XHRcdH1cblx0XHRcdC8vIGVhc2luZyBmdW5jdGlvblxuXHRcdFx0aWYgKCBvcHRpb25zLmVhc2luZyApIHtcblx0XHRcdFx0aWYgKCB0eXBlb2Ygb3B0aW9ucy5lYXNpbmcgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdFx0ZWFzaW5nID0gb3B0aW9ucy5lYXNpbmc7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWFzaW5nID0gcm9vdC5lYXNpbmdbIG9wdGlvbnMuZWFzaW5nIF07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB0eXBlb2YgZWFzaW5nICE9PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdGVhc2luZyA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIGR1cmF0aW9uXG5cdFx0XHRkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gPT09IHVuZGVmaW5lZCA/IDQwMCA6IG9wdGlvbnMuZHVyYXRpb247XG5cdFx0XHQvLyBUT0RPIHN0b3JlIGtleXMsIHVzZSBhbiBpbnRlcm5hbCBzZXQgbWV0aG9kXG5cdFx0XHRhbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKCB7XG5cdFx0XHRcdGtleXBhdGg6IGtleXBhdGgsXG5cdFx0XHRcdGZyb206IGZyb20sXG5cdFx0XHRcdHRvOiB0byxcblx0XHRcdFx0cm9vdDogcm9vdCxcblx0XHRcdFx0ZHVyYXRpb246IGR1cmF0aW9uLFxuXHRcdFx0XHRlYXNpbmc6IGVhc2luZyxcblx0XHRcdFx0aW50ZXJwb2xhdG9yOiBvcHRpb25zLmludGVycG9sYXRvcixcblx0XHRcdFx0Ly8gVE9ETyB3cmFwIGNhbGxiYWNrcyBpZiBuZWNlc3NhcnksIHRvIHVzZSBpbnN0YW5jZSBhcyBjb250ZXh0XG5cdFx0XHRcdHN0ZXA6IG9wdGlvbnMuc3RlcCxcblx0XHRcdFx0Y29tcGxldGU6IG9wdGlvbnMuY29tcGxldGVcblx0XHRcdH0gKTtcblx0XHRcdGFuaW1hdGlvbnMuYWRkKCBhbmltYXRpb24gKTtcblx0XHRcdHJvb3QuX2FuaW1hdGlvbnMucHVzaCggYW5pbWF0aW9uICk7XG5cdFx0XHRyZXR1cm4gYW5pbWF0aW9uO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIGlzRXF1YWwsIFByb21pc2UsIG5vcm1hbGlzZUtleXBhdGgsIGFuaW1hdGlvbnMsIFJhY3RpdmUkYW5pbWF0ZV9BbmltYXRpb24gKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9kZXRhY2guanMgKi9cblx0dmFyIFJhY3RpdmUkZGV0YWNoID0gZnVuY3Rpb24oIEhvb2ssIHJlbW92ZUZyb21BcnJheSApIHtcblxuXHRcdHZhciBkZXRhY2hIb29rID0gbmV3IEhvb2soICdkZXRhY2gnICk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkZGV0YWNoKCkge1xuXHRcdFx0aWYgKCB0aGlzLmRldGFjaGVkICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5kZXRhY2hlZDtcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5lbCApIHtcblx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCB0aGlzLmVsLl9fcmFjdGl2ZV9pbnN0YW5jZXNfXywgdGhpcyApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5kZXRhY2hlZCA9IHRoaXMuZnJhZ21lbnQuZGV0YWNoKCk7XG5cdFx0XHRkZXRhY2hIb29rLmZpcmUoIHRoaXMgKTtcblx0XHRcdHJldHVybiB0aGlzLmRldGFjaGVkO1xuXHRcdH07XG5cdH0oIFJhY3RpdmUkc2hhcmVkX2hvb2tzX0hvb2ssIHJlbW92ZUZyb21BcnJheSApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL2ZpbmQuanMgKi9cblx0dmFyIFJhY3RpdmUkZmluZCA9IGZ1bmN0aW9uIFJhY3RpdmUkZmluZCggc2VsZWN0b3IgKSB7XG5cdFx0aWYgKCAhdGhpcy5lbCApIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kKCBzZWxlY3RvciApO1xuXHR9O1xuXG5cdC8qIHV0aWxzL21hdGNoZXMuanMgKi9cblx0dmFyIG1hdGNoZXMgPSBmdW5jdGlvbiggaXNDbGllbnQsIHZlbmRvcnMsIGNyZWF0ZUVsZW1lbnQgKSB7XG5cblx0XHR2YXIgbWF0Y2hlcywgZGl2LCBtZXRob2ROYW1lcywgdW5wcmVmaXhlZCwgcHJlZml4ZWQsIGksIGosIG1ha2VGdW5jdGlvbjtcblx0XHRpZiAoICFpc0NsaWVudCApIHtcblx0XHRcdG1hdGNoZXMgPSBudWxsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkaXYgPSBjcmVhdGVFbGVtZW50KCAnZGl2JyApO1xuXHRcdFx0bWV0aG9kTmFtZXMgPSBbXG5cdFx0XHRcdCdtYXRjaGVzJyxcblx0XHRcdFx0J21hdGNoZXNTZWxlY3Rvcidcblx0XHRcdF07XG5cdFx0XHRtYWtlRnVuY3Rpb24gPSBmdW5jdGlvbiggbWV0aG9kTmFtZSApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBub2RlLCBzZWxlY3RvciApIHtcblx0XHRcdFx0XHRyZXR1cm4gbm9kZVsgbWV0aG9kTmFtZSBdKCBzZWxlY3RvciApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdGkgPSBtZXRob2ROYW1lcy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSAmJiAhbWF0Y2hlcyApIHtcblx0XHRcdFx0dW5wcmVmaXhlZCA9IG1ldGhvZE5hbWVzWyBpIF07XG5cdFx0XHRcdGlmICggZGl2WyB1bnByZWZpeGVkIF0gKSB7XG5cdFx0XHRcdFx0bWF0Y2hlcyA9IG1ha2VGdW5jdGlvbiggdW5wcmVmaXhlZCApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGogPSB2ZW5kb3JzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHRcdHByZWZpeGVkID0gdmVuZG9yc1sgaSBdICsgdW5wcmVmaXhlZC5zdWJzdHIoIDAsIDEgKS50b1VwcGVyQ2FzZSgpICsgdW5wcmVmaXhlZC5zdWJzdHJpbmcoIDEgKTtcblx0XHRcdFx0XHRcdGlmICggZGl2WyBwcmVmaXhlZCBdICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVzID0gbWFrZUZ1bmN0aW9uKCBwcmVmaXhlZCApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIElFOC4uLlxuXHRcdFx0aWYgKCAhbWF0Y2hlcyApIHtcblx0XHRcdFx0bWF0Y2hlcyA9IGZ1bmN0aW9uKCBub2RlLCBzZWxlY3RvciApIHtcblx0XHRcdFx0XHR2YXIgbm9kZXMsIHBhcmVudE5vZGUsIGk7XG5cdFx0XHRcdFx0cGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcblx0XHRcdFx0XHRpZiAoICFwYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdFx0Ly8gZW1wdHkgZHVtbXkgPGRpdj5cblx0XHRcdFx0XHRcdGRpdi5pbm5lckhUTUwgPSAnJztcblx0XHRcdFx0XHRcdHBhcmVudE5vZGUgPSBkaXY7XG5cdFx0XHRcdFx0XHRub2RlID0gbm9kZS5jbG9uZU5vZGUoKTtcblx0XHRcdFx0XHRcdGRpdi5hcHBlbmRDaGlsZCggbm9kZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRub2RlcyA9IHBhcmVudE5vZGUucXVlcnlTZWxlY3RvckFsbCggc2VsZWN0b3IgKTtcblx0XHRcdFx0XHRpID0gbm9kZXMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCBub2Rlc1sgaSBdID09PSBub2RlICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbWF0Y2hlcztcblx0fSggaXNDbGllbnQsIHZlbmRvcnMsIGNyZWF0ZUVsZW1lbnQgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvbWFrZVF1ZXJ5L3Rlc3QuanMgKi9cblx0dmFyIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV90ZXN0ID0gZnVuY3Rpb24oIG1hdGNoZXMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIGl0ZW0sIG5vRGlydHkgKSB7XG5cdFx0XHR2YXIgaXRlbU1hdGNoZXMgPSB0aGlzLl9pc0NvbXBvbmVudFF1ZXJ5ID8gIXRoaXMuc2VsZWN0b3IgfHwgaXRlbS5uYW1lID09PSB0aGlzLnNlbGVjdG9yIDogbWF0Y2hlcyggaXRlbS5ub2RlLCB0aGlzLnNlbGVjdG9yICk7XG5cdFx0XHRpZiAoIGl0ZW1NYXRjaGVzICkge1xuXHRcdFx0XHR0aGlzLnB1c2goIGl0ZW0ubm9kZSB8fCBpdGVtLmluc3RhbmNlICk7XG5cdFx0XHRcdGlmICggIW5vRGlydHkgKSB7XG5cdFx0XHRcdFx0dGhpcy5fbWFrZURpcnR5KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggbWF0Y2hlcyApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NoYXJlZC9tYWtlUXVlcnkvY2FuY2VsLmpzICovXG5cdHZhciBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfY2FuY2VsID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxpdmVRdWVyaWVzLCBzZWxlY3RvciwgaW5kZXg7XG5cdFx0bGl2ZVF1ZXJpZXMgPSB0aGlzLl9yb290WyB0aGlzLl9pc0NvbXBvbmVudFF1ZXJ5ID8gJ2xpdmVDb21wb25lbnRRdWVyaWVzJyA6ICdsaXZlUXVlcmllcycgXTtcblx0XHRzZWxlY3RvciA9IHRoaXMuc2VsZWN0b3I7XG5cdFx0aW5kZXggPSBsaXZlUXVlcmllcy5pbmRleE9mKCBzZWxlY3RvciApO1xuXHRcdGlmICggaW5kZXggIT09IC0xICkge1xuXHRcdFx0bGl2ZVF1ZXJpZXMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0bGl2ZVF1ZXJpZXNbIHNlbGVjdG9yIF0gPSBudWxsO1xuXHRcdH1cblx0fTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvbWFrZVF1ZXJ5L3NvcnRCeUl0ZW1Qb3NpdGlvbi5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X3NvcnRCeUl0ZW1Qb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHR2YXIgYW5jZXN0cnlBLCBhbmNlc3RyeUIsIG9sZGVzdEEsIG9sZGVzdEIsIG11dHVhbEFuY2VzdG9yLCBpbmRleEEsIGluZGV4QiwgZnJhZ21lbnRzLCBmcmFnbWVudEEsIGZyYWdtZW50Qjtcblx0XHRcdGFuY2VzdHJ5QSA9IGdldEFuY2VzdHJ5KCBhLmNvbXBvbmVudCB8fCBhLl9yYWN0aXZlLnByb3h5ICk7XG5cdFx0XHRhbmNlc3RyeUIgPSBnZXRBbmNlc3RyeSggYi5jb21wb25lbnQgfHwgYi5fcmFjdGl2ZS5wcm94eSApO1xuXHRcdFx0b2xkZXN0QSA9IGFuY2VzdHJ5QVsgYW5jZXN0cnlBLmxlbmd0aCAtIDEgXTtcblx0XHRcdG9sZGVzdEIgPSBhbmNlc3RyeUJbIGFuY2VzdHJ5Qi5sZW5ndGggLSAxIF07XG5cdFx0XHQvLyByZW1vdmUgaXRlbXMgZnJvbSB0aGUgZW5kIG9mIGJvdGggYW5jZXN0cmllcyBhcyBsb25nIGFzIHRoZXkgYXJlIGlkZW50aWNhbFxuXHRcdFx0Ly8gLSB0aGUgZmluYWwgb25lIHJlbW92ZWQgaXMgdGhlIGNsb3Nlc3QgbXV0dWFsIGFuY2VzdG9yXG5cdFx0XHR3aGlsZSAoIG9sZGVzdEEgJiYgb2xkZXN0QSA9PT0gb2xkZXN0QiApIHtcblx0XHRcdFx0YW5jZXN0cnlBLnBvcCgpO1xuXHRcdFx0XHRhbmNlc3RyeUIucG9wKCk7XG5cdFx0XHRcdG11dHVhbEFuY2VzdG9yID0gb2xkZXN0QTtcblx0XHRcdFx0b2xkZXN0QSA9IGFuY2VzdHJ5QVsgYW5jZXN0cnlBLmxlbmd0aCAtIDEgXTtcblx0XHRcdFx0b2xkZXN0QiA9IGFuY2VzdHJ5QlsgYW5jZXN0cnlCLmxlbmd0aCAtIDEgXTtcblx0XHRcdH1cblx0XHRcdC8vIG5vdyB0aGF0IHdlIGhhdmUgdGhlIG11dHVhbCBhbmNlc3Rvciwgd2UgY2FuIGZpbmQgd2hpY2ggaXMgZWFybGllc3Rcblx0XHRcdG9sZGVzdEEgPSBvbGRlc3RBLmNvbXBvbmVudCB8fCBvbGRlc3RBO1xuXHRcdFx0b2xkZXN0QiA9IG9sZGVzdEIuY29tcG9uZW50IHx8IG9sZGVzdEI7XG5cdFx0XHRmcmFnbWVudEEgPSBvbGRlc3RBLnBhcmVudEZyYWdtZW50O1xuXHRcdFx0ZnJhZ21lbnRCID0gb2xkZXN0Qi5wYXJlbnRGcmFnbWVudDtcblx0XHRcdC8vIGlmIGJvdGggaXRlbXMgc2hhcmUgYSBwYXJlbnQgZnJhZ21lbnQsIG91ciBqb2IgaXMgZWFzeVxuXHRcdFx0aWYgKCBmcmFnbWVudEEgPT09IGZyYWdtZW50QiApIHtcblx0XHRcdFx0aW5kZXhBID0gZnJhZ21lbnRBLml0ZW1zLmluZGV4T2YoIG9sZGVzdEEgKTtcblx0XHRcdFx0aW5kZXhCID0gZnJhZ21lbnRCLml0ZW1zLmluZGV4T2YoIG9sZGVzdEIgKTtcblx0XHRcdFx0Ly8gaWYgaXQncyB0aGUgc2FtZSBpbmRleCwgaXQgbWVhbnMgb25lIGNvbnRhaW5zIHRoZSBvdGhlcixcblx0XHRcdFx0Ly8gc28gd2Ugc2VlIHdoaWNoIGhhcyB0aGUgbG9uZ2VzdCBhbmNlc3RyeVxuXHRcdFx0XHRyZXR1cm4gaW5kZXhBIC0gaW5kZXhCIHx8IGFuY2VzdHJ5QS5sZW5ndGggLSBhbmNlc3RyeUIubGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0Ly8gaWYgbXV0dWFsIGFuY2VzdG9yIGlzIGEgc2VjdGlvbiwgd2UgZmlyc3QgdGVzdCB0byBzZWUgd2hpY2ggc2VjdGlvblxuXHRcdFx0Ly8gZnJhZ21lbnQgY29tZXMgZmlyc3Rcblx0XHRcdGlmICggZnJhZ21lbnRzID0gbXV0dWFsQW5jZXN0b3IuZnJhZ21lbnRzICkge1xuXHRcdFx0XHRpbmRleEEgPSBmcmFnbWVudHMuaW5kZXhPZiggZnJhZ21lbnRBICk7XG5cdFx0XHRcdGluZGV4QiA9IGZyYWdtZW50cy5pbmRleE9mKCBmcmFnbWVudEIgKTtcblx0XHRcdFx0cmV0dXJuIGluZGV4QSAtIGluZGV4QiB8fCBhbmNlc3RyeUEubGVuZ3RoIC0gYW5jZXN0cnlCLmxlbmd0aDtcblx0XHRcdH1cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ0FuIHVuZXhwZWN0ZWQgY29uZGl0aW9uIHdhcyBtZXQgd2hpbGUgY29tcGFyaW5nIHRoZSBwb3NpdGlvbiBvZiB0d28gY29tcG9uZW50cy4gUGxlYXNlIGZpbGUgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL1JhY3RpdmVKUy9SYWN0aXZlL2lzc3VlcyAtIHRoYW5rcyEnICk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGdldFBhcmVudCggaXRlbSApIHtcblx0XHRcdHZhciBwYXJlbnRGcmFnbWVudDtcblx0XHRcdGlmICggcGFyZW50RnJhZ21lbnQgPSBpdGVtLnBhcmVudEZyYWdtZW50ICkge1xuXHRcdFx0XHRyZXR1cm4gcGFyZW50RnJhZ21lbnQub3duZXI7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGl0ZW0uY29tcG9uZW50ICYmICggcGFyZW50RnJhZ21lbnQgPSBpdGVtLmNvbXBvbmVudC5wYXJlbnRGcmFnbWVudCApICkge1xuXHRcdFx0XHRyZXR1cm4gcGFyZW50RnJhZ21lbnQub3duZXI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0QW5jZXN0cnkoIGl0ZW0gKSB7XG5cdFx0XHR2YXIgYW5jZXN0cnksIGFuY2VzdG9yO1xuXHRcdFx0YW5jZXN0cnkgPSBbIGl0ZW0gXTtcblx0XHRcdGFuY2VzdG9yID0gZ2V0UGFyZW50KCBpdGVtICk7XG5cdFx0XHR3aGlsZSAoIGFuY2VzdG9yICkge1xuXHRcdFx0XHRhbmNlc3RyeS5wdXNoKCBhbmNlc3RvciApO1xuXHRcdFx0XHRhbmNlc3RvciA9IGdldFBhcmVudCggYW5jZXN0b3IgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBhbmNlc3RyeTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2hhcmVkL21ha2VRdWVyeS9zb3J0QnlEb2N1bWVudFBvc2l0aW9uLmpzICovXG5cdHZhciBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfc29ydEJ5RG9jdW1lbnRQb3NpdGlvbiA9IGZ1bmN0aW9uKCBzb3J0QnlJdGVtUG9zaXRpb24gKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIG5vZGUsIG90aGVyTm9kZSApIHtcblx0XHRcdHZhciBiaXRtYXNrO1xuXHRcdFx0aWYgKCBub2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICkge1xuXHRcdFx0XHRiaXRtYXNrID0gbm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggb3RoZXJOb2RlICk7XG5cdFx0XHRcdHJldHVybiBiaXRtYXNrICYgMiA/IDEgOiAtMTtcblx0XHRcdH1cblx0XHRcdC8vIEluIG9sZCBJRSwgd2UgY2FuIHBpZ2d5IGJhY2sgb24gdGhlIG1lY2hhbmlzbSBmb3Jcblx0XHRcdC8vIGNvbXBhcmluZyBjb21wb25lbnQgcG9zaXRpb25zXG5cdFx0XHRyZXR1cm4gc29ydEJ5SXRlbVBvc2l0aW9uKCBub2RlLCBvdGhlck5vZGUgKTtcblx0XHR9O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfc29ydEJ5SXRlbVBvc2l0aW9uICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2hhcmVkL21ha2VRdWVyeS9zb3J0LmpzICovXG5cdHZhciBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfc29ydCA9IGZ1bmN0aW9uKCBzb3J0QnlEb2N1bWVudFBvc2l0aW9uLCBzb3J0QnlJdGVtUG9zaXRpb24gKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnNvcnQoIHRoaXMuX2lzQ29tcG9uZW50UXVlcnkgPyBzb3J0QnlJdGVtUG9zaXRpb24gOiBzb3J0QnlEb2N1bWVudFBvc2l0aW9uICk7XG5cdFx0XHR0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuXHRcdH07XG5cdH0oIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9zb3J0QnlEb2N1bWVudFBvc2l0aW9uLCBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfc29ydEJ5SXRlbVBvc2l0aW9uICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2hhcmVkL21ha2VRdWVyeS9kaXJ0eS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X2RpcnR5ID0gZnVuY3Rpb24oIHJ1bmxvb3AgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdGlmICggIXRoaXMuX2RpcnR5ICkge1xuXHRcdFx0XHR0aGlzLl9kaXJ0eSA9IHRydWU7XG5cdFx0XHRcdC8vIE9uY2UgdGhlIERPTSBoYXMgYmVlbiB1cGRhdGVkLCBlbnN1cmUgdGhlIHF1ZXJ5XG5cdFx0XHRcdC8vIGlzIGNvcnJlY3RseSBvcmRlcmVkXG5cdFx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR0aGlzJDAuX3NvcnQoKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIHJ1bmxvb3AgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvbWFrZVF1ZXJ5L3JlbW92ZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X3JlbW92ZSA9IGZ1bmN0aW9uKCBub2RlT3JDb21wb25lbnQgKSB7XG5cdFx0dmFyIGluZGV4ID0gdGhpcy5pbmRleE9mKCB0aGlzLl9pc0NvbXBvbmVudFF1ZXJ5ID8gbm9kZU9yQ29tcG9uZW50Lmluc3RhbmNlIDogbm9kZU9yQ29tcG9uZW50ICk7XG5cdFx0aWYgKCBpbmRleCAhPT0gLTEgKSB7XG5cdFx0XHR0aGlzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHR9XG5cdH07XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2hhcmVkL21ha2VRdWVyeS9fbWFrZVF1ZXJ5LmpzICovXG5cdHZhciBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfX21ha2VRdWVyeSA9IGZ1bmN0aW9uKCBkZWZpbmVQcm9wZXJ0aWVzLCB0ZXN0LCBjYW5jZWwsIHNvcnQsIGRpcnR5LCByZW1vdmUgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gbWFrZVF1ZXJ5KCByYWN0aXZlLCBzZWxlY3RvciwgbGl2ZSwgaXNDb21wb25lbnRRdWVyeSApIHtcblx0XHRcdHZhciBxdWVyeSA9IFtdO1xuXHRcdFx0ZGVmaW5lUHJvcGVydGllcyggcXVlcnksIHtcblx0XHRcdFx0c2VsZWN0b3I6IHtcblx0XHRcdFx0XHR2YWx1ZTogc2VsZWN0b3Jcblx0XHRcdFx0fSxcblx0XHRcdFx0bGl2ZToge1xuXHRcdFx0XHRcdHZhbHVlOiBsaXZlXG5cdFx0XHRcdH0sXG5cdFx0XHRcdF9pc0NvbXBvbmVudFF1ZXJ5OiB7XG5cdFx0XHRcdFx0dmFsdWU6IGlzQ29tcG9uZW50UXVlcnlcblx0XHRcdFx0fSxcblx0XHRcdFx0X3Rlc3Q6IHtcblx0XHRcdFx0XHR2YWx1ZTogdGVzdFxuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0XHRpZiAoICFsaXZlICkge1xuXHRcdFx0XHRyZXR1cm4gcXVlcnk7XG5cdFx0XHR9XG5cdFx0XHRkZWZpbmVQcm9wZXJ0aWVzKCBxdWVyeSwge1xuXHRcdFx0XHRjYW5jZWw6IHtcblx0XHRcdFx0XHR2YWx1ZTogY2FuY2VsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdF9yb290OiB7XG5cdFx0XHRcdFx0dmFsdWU6IHJhY3RpdmVcblx0XHRcdFx0fSxcblx0XHRcdFx0X3NvcnQ6IHtcblx0XHRcdFx0XHR2YWx1ZTogc29ydFxuXHRcdFx0XHR9LFxuXHRcdFx0XHRfbWFrZURpcnR5OiB7XG5cdFx0XHRcdFx0dmFsdWU6IGRpcnR5XG5cdFx0XHRcdH0sXG5cdFx0XHRcdF9yZW1vdmU6IHtcblx0XHRcdFx0XHR2YWx1ZTogcmVtb3ZlXG5cdFx0XHRcdH0sXG5cdFx0XHRcdF9kaXJ0eToge1xuXHRcdFx0XHRcdHZhbHVlOiBmYWxzZSxcblx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZVxuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0XHRyZXR1cm4gcXVlcnk7XG5cdFx0fTtcblx0fSggZGVmaW5lUHJvcGVydGllcywgUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X3Rlc3QsIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9jYW5jZWwsIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9zb3J0LCBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfZGlydHksIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9yZW1vdmUgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9maW5kQWxsLmpzICovXG5cdHZhciBSYWN0aXZlJGZpbmRBbGwgPSBmdW5jdGlvbiggbWFrZVF1ZXJ5ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkZmluZEFsbCggc2VsZWN0b3IsIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgbGl2ZVF1ZXJpZXMsIHF1ZXJ5O1xuXHRcdFx0aWYgKCAhdGhpcy5lbCApIHtcblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fVxuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0XHRsaXZlUXVlcmllcyA9IHRoaXMuX2xpdmVRdWVyaWVzO1xuXHRcdFx0Ly8gU2hvcnRjdXQ6IGlmIHdlJ3JlIG1haW50YWluaW5nIGEgbGl2ZSBxdWVyeSB3aXRoIHRoaXNcblx0XHRcdC8vIHNlbGVjdG9yLCB3ZSBkb24ndCBuZWVkIHRvIHRyYXZlcnNlIHRoZSBwYXJhbGxlbCBET01cblx0XHRcdGlmICggcXVlcnkgPSBsaXZlUXVlcmllc1sgc2VsZWN0b3IgXSApIHtcblx0XHRcdFx0Ly8gRWl0aGVyIHJldHVybiB0aGUgZXhhY3Qgc2FtZSBxdWVyeSwgb3IgKGlmIG5vdCBsaXZlKSBhIHNuYXBzaG90XG5cdFx0XHRcdHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMubGl2ZSA/IHF1ZXJ5IDogcXVlcnkuc2xpY2UoKTtcblx0XHRcdH1cblx0XHRcdHF1ZXJ5ID0gbWFrZVF1ZXJ5KCB0aGlzLCBzZWxlY3RvciwgISFvcHRpb25zLmxpdmUsIGZhbHNlICk7XG5cdFx0XHQvLyBBZGQgdGhpcyB0byB0aGUgbGlzdCBvZiBsaXZlIHF1ZXJpZXMgUmFjdGl2ZSBuZWVkcyB0byBtYWludGFpbixcblx0XHRcdC8vIGlmIGFwcGxpY2FibGVcblx0XHRcdGlmICggcXVlcnkubGl2ZSApIHtcblx0XHRcdFx0bGl2ZVF1ZXJpZXMucHVzaCggc2VsZWN0b3IgKTtcblx0XHRcdFx0bGl2ZVF1ZXJpZXNbICdfJyArIHNlbGVjdG9yIF0gPSBxdWVyeTtcblx0XHRcdH1cblx0XHRcdHRoaXMuZnJhZ21lbnQuZmluZEFsbCggc2VsZWN0b3IsIHF1ZXJ5ICk7XG5cdFx0XHRyZXR1cm4gcXVlcnk7XG5cdFx0fTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X19tYWtlUXVlcnkgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9maW5kQWxsQ29tcG9uZW50cy5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRmaW5kQWxsQ29tcG9uZW50cyA9IGZ1bmN0aW9uKCBtYWtlUXVlcnkgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRmaW5kQWxsQ29tcG9uZW50cyggc2VsZWN0b3IsIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgbGl2ZVF1ZXJpZXMsIHF1ZXJ5O1xuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0XHRsaXZlUXVlcmllcyA9IHRoaXMuX2xpdmVDb21wb25lbnRRdWVyaWVzO1xuXHRcdFx0Ly8gU2hvcnRjdXQ6IGlmIHdlJ3JlIG1haW50YWluaW5nIGEgbGl2ZSBxdWVyeSB3aXRoIHRoaXNcblx0XHRcdC8vIHNlbGVjdG9yLCB3ZSBkb24ndCBuZWVkIHRvIHRyYXZlcnNlIHRoZSBwYXJhbGxlbCBET01cblx0XHRcdGlmICggcXVlcnkgPSBsaXZlUXVlcmllc1sgc2VsZWN0b3IgXSApIHtcblx0XHRcdFx0Ly8gRWl0aGVyIHJldHVybiB0aGUgZXhhY3Qgc2FtZSBxdWVyeSwgb3IgKGlmIG5vdCBsaXZlKSBhIHNuYXBzaG90XG5cdFx0XHRcdHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMubGl2ZSA/IHF1ZXJ5IDogcXVlcnkuc2xpY2UoKTtcblx0XHRcdH1cblx0XHRcdHF1ZXJ5ID0gbWFrZVF1ZXJ5KCB0aGlzLCBzZWxlY3RvciwgISFvcHRpb25zLmxpdmUsIHRydWUgKTtcblx0XHRcdC8vIEFkZCB0aGlzIHRvIHRoZSBsaXN0IG9mIGxpdmUgcXVlcmllcyBSYWN0aXZlIG5lZWRzIHRvIG1haW50YWluLFxuXHRcdFx0Ly8gaWYgYXBwbGljYWJsZVxuXHRcdFx0aWYgKCBxdWVyeS5saXZlICkge1xuXHRcdFx0XHRsaXZlUXVlcmllcy5wdXNoKCBzZWxlY3RvciApO1xuXHRcdFx0XHRsaXZlUXVlcmllc1sgJ18nICsgc2VsZWN0b3IgXSA9IHF1ZXJ5O1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5mcmFnbWVudC5maW5kQWxsQ29tcG9uZW50cyggc2VsZWN0b3IsIHF1ZXJ5ICk7XG5cdFx0XHRyZXR1cm4gcXVlcnk7XG5cdFx0fTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X19tYWtlUXVlcnkgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9maW5kQ29tcG9uZW50LmpzICovXG5cdHZhciBSYWN0aXZlJGZpbmRDb21wb25lbnQgPSBmdW5jdGlvbiBSYWN0aXZlJGZpbmRDb21wb25lbnQoIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRDb21wb25lbnQoIHNlbGVjdG9yICk7XG5cdH07XG5cblx0LyogdXRpbHMvZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzLmpzICovXG5cdHZhciBnZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgc3Rhck1hcHMgPSB7fTtcblx0XHQvLyBUaGlzIGZ1bmN0aW9uIHRha2VzIGEga2V5cGF0aCBzdWNoIGFzICdmb28uYmFyLmJheicsIGFuZCByZXR1cm5zXG5cdFx0Ly8gYWxsIHRoZSB2YXJpYW50cyBvZiB0aGF0IGtleXBhdGggdGhhdCBpbmNsdWRlIGEgd2lsZGNhcmQgaW4gcGxhY2Vcblx0XHQvLyBvZiBhIGtleSwgc3VjaCBhcyAnZm9vLmJhci4qJywgJ2Zvby4qLmJheicsICdmb28uKi4qJyBhbmQgc28gb24uXG5cdFx0Ly8gVGhlc2UgYXJlIHRoZW4gY2hlY2tlZCBhZ2FpbnN0IHRoZSBkZXBlbmRhbnRzIG1hcCAocmFjdGl2ZS52aWV3bW9kZWwuZGVwc01hcClcblx0XHQvLyB0byBzZWUgaWYgYW55IHBhdHRlcm4gb2JzZXJ2ZXJzIGFyZSBkb3duc3RyZWFtIG9mIG9uZSBvciBtb3JlIG9mXG5cdFx0Ly8gdGhlc2Ugd2lsZGNhcmQga2V5cGF0aHMgKGUuZy4gJ2Zvby5iYXIuKi5zdGF0dXMnKVxuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzKCBrZXlwYXRoICkge1xuXHRcdFx0dmFyIGtleXMsIHN0YXJNYXAsIG1hcHBlciwgaSwgcmVzdWx0LCB3aWxkY2FyZEtleXBhdGg7XG5cdFx0XHRrZXlzID0ga2V5cGF0aC5zcGxpdCggJy4nICk7XG5cdFx0XHRpZiAoICEoIHN0YXJNYXAgPSBzdGFyTWFwc1sga2V5cy5sZW5ndGggXSApICkge1xuXHRcdFx0XHRzdGFyTWFwID0gZ2V0U3Rhck1hcCgga2V5cy5sZW5ndGggKTtcblx0XHRcdH1cblx0XHRcdHJlc3VsdCA9IFtdO1xuXHRcdFx0bWFwcGVyID0gZnVuY3Rpb24oIHN0YXIsIGkgKSB7XG5cdFx0XHRcdHJldHVybiBzdGFyID8gJyonIDoga2V5c1sgaSBdO1xuXHRcdFx0fTtcblx0XHRcdGkgPSBzdGFyTWFwLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHR3aWxkY2FyZEtleXBhdGggPSBzdGFyTWFwWyBpIF0ubWFwKCBtYXBwZXIgKS5qb2luKCAnLicgKTtcblx0XHRcdFx0aWYgKCAhcmVzdWx0Lmhhc093blByb3BlcnR5KCB3aWxkY2FyZEtleXBhdGggKSApIHtcblx0XHRcdFx0XHRyZXN1bHQucHVzaCggd2lsZGNhcmRLZXlwYXRoICk7XG5cdFx0XHRcdFx0cmVzdWx0WyB3aWxkY2FyZEtleXBhdGggXSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fTtcblx0XHQvLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYWxsIHRoZSBwb3NzaWJsZSB0cnVlL2ZhbHNlIGNvbWJpbmF0aW9ucyBmb3Jcblx0XHQvLyBhIGdpdmVuIG51bWJlciAtIGUuZy4gZm9yIHR3bywgdGhlIHBvc3NpYmxlIGNvbWJpbmF0aW9ucyBhcmVcblx0XHQvLyBbIHRydWUsIHRydWUgXSwgWyB0cnVlLCBmYWxzZSBdLCBbIGZhbHNlLCB0cnVlIF0sIFsgZmFsc2UsIGZhbHNlIF0uXG5cdFx0Ly8gSXQgZG9lcyBzbyBieSBnZXR0aW5nIGFsbCB0aGUgYmluYXJ5IHZhbHVlcyBiZXR3ZWVuIDAgYW5kIGUuZy4gMTFcblx0XHRmdW5jdGlvbiBnZXRTdGFyTWFwKCBudW0gKSB7XG5cdFx0XHR2YXIgb25lcyA9ICcnLFxuXHRcdFx0XHRtYXgsIGJpbmFyeSwgc3Rhck1hcCwgbWFwcGVyLCBpO1xuXHRcdFx0aWYgKCAhc3Rhck1hcHNbIG51bSBdICkge1xuXHRcdFx0XHRzdGFyTWFwID0gW107XG5cdFx0XHRcdHdoaWxlICggb25lcy5sZW5ndGggPCBudW0gKSB7XG5cdFx0XHRcdFx0b25lcyArPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG1heCA9IHBhcnNlSW50KCBvbmVzLCAyICk7XG5cdFx0XHRcdG1hcHBlciA9IGZ1bmN0aW9uKCBkaWdpdCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGlnaXQgPT09ICcxJztcblx0XHRcdFx0fTtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPD0gbWF4OyBpICs9IDEgKSB7XG5cdFx0XHRcdFx0YmluYXJ5ID0gaS50b1N0cmluZyggMiApO1xuXHRcdFx0XHRcdHdoaWxlICggYmluYXJ5Lmxlbmd0aCA8IG51bSApIHtcblx0XHRcdFx0XHRcdGJpbmFyeSA9ICcwJyArIGJpbmFyeTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c3Rhck1hcFsgaSBdID0gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKCBiaW5hcnksIG1hcHBlciApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0YXJNYXBzWyBudW0gXSA9IHN0YXJNYXA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc3Rhck1hcHNbIG51bSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvZmlyZUV2ZW50LmpzICovXG5cdHZhciBSYWN0aXZlJHNoYXJlZF9maXJlRXZlbnQgPSBmdW5jdGlvbiggZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gZmlyZUV2ZW50KCByYWN0aXZlLCBldmVudE5hbWUgKSB7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IGFyZ3VtZW50c1sgMiBdO1xuXHRcdFx0aWYgKCBvcHRpb25zID09PSB2b2lkIDAgKVxuXHRcdFx0XHRvcHRpb25zID0ge307XG5cdFx0XHRpZiAoICFldmVudE5hbWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmICggIW9wdGlvbnMuZXZlbnQgKSB7XG5cdFx0XHRcdG9wdGlvbnMuZXZlbnQgPSB7XG5cdFx0XHRcdFx0bmFtZTogZXZlbnROYW1lLFxuXHRcdFx0XHRcdGNvbnRleHQ6IHJhY3RpdmUuZGF0YSxcblx0XHRcdFx0XHRrZXlwYXRoOiAnJyxcblx0XHRcdFx0XHQvLyB1bnRpbCBldmVudCBub3QgaW5jbHVkZWQgYXMgYXJndW1lbnQgZGVmYXVsdFxuXHRcdFx0XHRcdF9ub0FyZzogdHJ1ZVxuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3B0aW9ucy5ldmVudC5uYW1lID0gZXZlbnROYW1lO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGV2ZW50TmFtZXMgPSBnZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMoIGV2ZW50TmFtZSApO1xuXHRcdFx0ZmlyZUV2ZW50QXMoIHJhY3RpdmUsIGV2ZW50TmFtZXMsIG9wdGlvbnMuZXZlbnQsIG9wdGlvbnMuYXJncywgdHJ1ZSApO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBmaXJlRXZlbnRBcyggcmFjdGl2ZSwgZXZlbnROYW1lcywgZXZlbnQsIGFyZ3MgKSB7XG5cdFx0XHR2YXIgaW5pdGlhbEZpcmUgPSBhcmd1bWVudHNbIDQgXTtcblx0XHRcdGlmICggaW5pdGlhbEZpcmUgPT09IHZvaWQgMCApXG5cdFx0XHRcdGluaXRpYWxGaXJlID0gZmFsc2U7XG5cdFx0XHR2YXIgc3Vic2NyaWJlcnMsIGksIGJ1YmJsZSA9IHRydWU7XG5cdFx0XHRpZiAoIGV2ZW50ICkge1xuXHRcdFx0XHRyYWN0aXZlLmV2ZW50ID0gZXZlbnQ7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCBpID0gZXZlbnROYW1lcy5sZW5ndGg7IGkgPj0gMDsgaS0tICkge1xuXHRcdFx0XHRzdWJzY3JpYmVycyA9IHJhY3RpdmUuX3N1YnNbIGV2ZW50TmFtZXNbIGkgXSBdO1xuXHRcdFx0XHRpZiAoIHN1YnNjcmliZXJzICkge1xuXHRcdFx0XHRcdGJ1YmJsZSA9IG5vdGlmeVN1YnNjcmliZXJzKCByYWN0aXZlLCBzdWJzY3JpYmVycywgZXZlbnQsIGFyZ3MgKSAmJiBidWJibGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggZXZlbnQgKSB7XG5cdFx0XHRcdGRlbGV0ZSByYWN0aXZlLmV2ZW50O1xuXHRcdFx0fVxuXHRcdFx0aWYgKCByYWN0aXZlLl9wYXJlbnQgJiYgYnViYmxlICkge1xuXHRcdFx0XHRpZiAoIGluaXRpYWxGaXJlICYmIHJhY3RpdmUuY29tcG9uZW50ICkge1xuXHRcdFx0XHRcdHZhciBmdWxsTmFtZSA9IHJhY3RpdmUuY29tcG9uZW50Lm5hbWUgKyAnLicgKyBldmVudE5hbWVzWyBldmVudE5hbWVzLmxlbmd0aCAtIDEgXTtcblx0XHRcdFx0XHRldmVudE5hbWVzID0gZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzKCBmdWxsTmFtZSApO1xuXHRcdFx0XHRcdGlmICggZXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRldmVudC5jb21wb25lbnQgPSByYWN0aXZlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRmaXJlRXZlbnRBcyggcmFjdGl2ZS5fcGFyZW50LCBldmVudE5hbWVzLCBldmVudCwgYXJncyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG5vdGlmeVN1YnNjcmliZXJzKCByYWN0aXZlLCBzdWJzY3JpYmVycywgZXZlbnQsIGFyZ3MgKSB7XG5cdFx0XHR2YXIgb3JpZ2luYWxFdmVudCA9IG51bGwsXG5cdFx0XHRcdHN0b3BFdmVudCA9IGZhbHNlO1xuXHRcdFx0aWYgKCBldmVudCAmJiAhZXZlbnQuX25vQXJnICkge1xuXHRcdFx0XHRhcmdzID0gWyBldmVudCBdLmNvbmNhdCggYXJncyApO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsZW4gPSBzdWJzY3JpYmVycy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0aWYgKCBzdWJzY3JpYmVyc1sgaSBdLmFwcGx5KCByYWN0aXZlLCBhcmdzICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdHN0b3BFdmVudCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggZXZlbnQgJiYgIWV2ZW50Ll9ub0FyZyAmJiBzdG9wRXZlbnQgJiYgKCBvcmlnaW5hbEV2ZW50ID0gZXZlbnQub3JpZ2luYWwgKSApIHtcblx0XHRcdFx0b3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCAmJiBvcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdG9yaWdpbmFsRXZlbnQuc3RvcFByb3BhZ2F0aW9uICYmIG9yaWdpbmFsRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gIXN0b3BFdmVudDtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBnZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9maXJlLmpzICovXG5cdHZhciBSYWN0aXZlJGZpcmUgPSBmdW5jdGlvbiggZmlyZUV2ZW50ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkZmlyZSggZXZlbnROYW1lICkge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSB7XG5cdFx0XHRcdGFyZ3M6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKVxuXHRcdFx0fTtcblx0XHRcdGZpcmVFdmVudCggdGhpcywgZXZlbnROYW1lLCBvcHRpb25zICk7XG5cdFx0fTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfZmlyZUV2ZW50ICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvZ2V0LmpzICovXG5cdHZhciBSYWN0aXZlJGdldCA9IGZ1bmN0aW9uKCBub3JtYWxpc2VLZXlwYXRoLCByZXNvbHZlUmVmICkge1xuXG5cdFx0dmFyIG9wdGlvbnMgPSB7XG5cdFx0XHRjYXB0dXJlOiB0cnVlXG5cdFx0fTtcblx0XHQvLyB0b3AtbGV2ZWwgY2FsbHMgc2hvdWxkIGJlIGludGVyY2VwdGVkXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkZ2V0KCBrZXlwYXRoICkge1xuXHRcdFx0dmFyIHZhbHVlO1xuXHRcdFx0a2V5cGF0aCA9IG5vcm1hbGlzZUtleXBhdGgoIGtleXBhdGggKTtcblx0XHRcdHZhbHVlID0gdGhpcy52aWV3bW9kZWwuZ2V0KCBrZXlwYXRoLCBvcHRpb25zICk7XG5cdFx0XHQvLyBDcmVhdGUgaW50ZXItY29tcG9uZW50IGJpbmRpbmcsIGlmIG5lY2Vzc2FyeVxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX3BhcmVudCAmJiAhdGhpcy5pc29sYXRlZCApIHtcblx0XHRcdFx0aWYgKCByZXNvbHZlUmVmKCB0aGlzLCBrZXlwYXRoLCB0aGlzLmZyYWdtZW50ICkgKSB7XG5cdFx0XHRcdFx0Ly8gY3JlYXRlcyBiaW5kaW5nIGFzIHNpZGUtZWZmZWN0LCBpZiBhcHByb3ByaWF0ZVxuXHRcdFx0XHRcdHZhbHVlID0gdGhpcy52aWV3bW9kZWwuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9O1xuXHR9KCBub3JtYWxpc2VLZXlwYXRoLCByZXNvbHZlUmVmICk7XG5cblx0LyogdXRpbHMvZ2V0RWxlbWVudC5qcyAqL1xuXHR2YXIgZ2V0RWxlbWVudCA9IGZ1bmN0aW9uIGdldEVsZW1lbnQoIGlucHV0ICkge1xuXHRcdHZhciBvdXRwdXQ7XG5cdFx0aWYgKCAhaW5wdXQgfHwgdHlwZW9mIGlucHV0ID09PSAnYm9vbGVhbicgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIWRvY3VtZW50IHx8ICFpbnB1dCApIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHQvLyBXZSBhbHJlYWR5IGhhdmUgYSBET00gbm9kZSAtIG5vIHdvcmsgdG8gZG8uIChEdWNrIHR5cGluZyBhbGVydCEpXG5cdFx0aWYgKCBpbnB1dC5ub2RlVHlwZSApIHtcblx0XHRcdHJldHVybiBpbnB1dDtcblx0XHR9XG5cdFx0Ly8gR2V0IG5vZGUgZnJvbSBzdHJpbmdcblx0XHRpZiAoIHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHQvLyB0cnkgSUQgZmlyc3Rcblx0XHRcdG91dHB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBpbnB1dCApO1xuXHRcdFx0Ly8gdGhlbiBhcyBzZWxlY3RvciwgaWYgcG9zc2libGVcblx0XHRcdGlmICggIW91dHB1dCAmJiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yICkge1xuXHRcdFx0XHRvdXRwdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCBpbnB1dCApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gZGlkIGl0IHdvcms/XG5cdFx0XHRpZiAoIG91dHB1dCAmJiBvdXRwdXQubm9kZVR5cGUgKSB7XG5cdFx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIElmIHdlJ3ZlIGJlZW4gZ2l2ZW4gYSBjb2xsZWN0aW9uIChqUXVlcnksIFplcHRvIGV0YyksIGV4dHJhY3QgdGhlIGZpcnN0IGl0ZW1cblx0XHRpZiAoIGlucHV0WyAwIF0gJiYgaW5wdXRbIDAgXS5ub2RlVHlwZSApIHtcblx0XHRcdHJldHVybiBpbnB1dFsgMCBdO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9pbnNlcnQuanMgKi9cblx0dmFyIFJhY3RpdmUkaW5zZXJ0ID0gZnVuY3Rpb24oIEhvb2ssIGdldEVsZW1lbnQgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIGluc2VydEhvb2sgPSBuZXcgSG9vayggJ2luc2VydCcgKTtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIFJhY3RpdmUkaW5zZXJ0KCB0YXJnZXQsIGFuY2hvciApIHtcblx0XHRcdGlmICggIXRoaXMuZnJhZ21lbnQucmVuZGVyZWQgKSB7XG5cdFx0XHRcdC8vIFRPRE8gY3JlYXRlLCBhbmQgbGluayB0bywgZG9jdW1lbnRhdGlvbiBleHBsYWluaW5nIHRoaXNcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVGhlIEFQSSBoYXMgY2hhbmdlZCAtIHlvdSBtdXN0IGNhbGwgYHJhY3RpdmUucmVuZGVyKHRhcmdldFssIGFuY2hvcl0pYCB0byByZW5kZXIgeW91ciBSYWN0aXZlIGluc3RhbmNlLiBPbmNlIHJlbmRlcmVkIHlvdSBjYW4gdXNlIGByYWN0aXZlLmluc2VydCgpYC4nICk7XG5cdFx0XHR9XG5cdFx0XHR0YXJnZXQgPSBnZXRFbGVtZW50KCB0YXJnZXQgKTtcblx0XHRcdGFuY2hvciA9IGdldEVsZW1lbnQoIGFuY2hvciApIHx8IG51bGw7XG5cdFx0XHRpZiAoICF0YXJnZXQgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1lvdSBtdXN0IHNwZWNpZnkgYSB2YWxpZCB0YXJnZXQgdG8gaW5zZXJ0IGludG8nICk7XG5cdFx0XHR9XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCB0aGlzLmRldGFjaCgpLCBhbmNob3IgKTtcblx0XHRcdHRoaXMuZWwgPSB0YXJnZXQ7XG5cdFx0XHQoIHRhcmdldC5fX3JhY3RpdmVfaW5zdGFuY2VzX18gfHwgKCB0YXJnZXQuX19yYWN0aXZlX2luc3RhbmNlc19fID0gW10gKSApLnB1c2goIHRoaXMgKTtcblx0XHRcdHRoaXMuZGV0YWNoZWQgPSBudWxsO1xuXHRcdFx0ZmlyZUluc2VydEhvb2soIHRoaXMgKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZmlyZUluc2VydEhvb2soIHJhY3RpdmUgKSB7XG5cdFx0XHRpbnNlcnRIb29rLmZpcmUoIHJhY3RpdmUgKTtcblx0XHRcdHJhY3RpdmUuZmluZEFsbENvbXBvbmVudHMoICcqJyApLmZvckVhY2goIGZ1bmN0aW9uKCBjaGlsZCApIHtcblx0XHRcdFx0ZmlyZUluc2VydEhvb2soIGNoaWxkLmluc3RhbmNlICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggUmFjdGl2ZSRzaGFyZWRfaG9va3NfSG9vaywgZ2V0RWxlbWVudCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL21lcmdlLmpzICovXG5cdHZhciBSYWN0aXZlJG1lcmdlID0gZnVuY3Rpb24oIHJ1bmxvb3AsIGlzQXJyYXksIG5vcm1hbGlzZUtleXBhdGggKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRtZXJnZSgga2V5cGF0aCwgYXJyYXksIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgY3VycmVudEFycmF5LCBwcm9taXNlO1xuXHRcdFx0a2V5cGF0aCA9IG5vcm1hbGlzZUtleXBhdGgoIGtleXBhdGggKTtcblx0XHRcdGN1cnJlbnRBcnJheSA9IHRoaXMudmlld21vZGVsLmdldCgga2V5cGF0aCApO1xuXHRcdFx0Ly8gSWYgZWl0aGVyIHRoZSBleGlzdGluZyB2YWx1ZSBvciB0aGUgbmV3IHZhbHVlIGlzbid0IGFuXG5cdFx0XHQvLyBhcnJheSwganVzdCBkbyBhIHJlZ3VsYXIgc2V0XG5cdFx0XHRpZiAoICFpc0FycmF5KCBjdXJyZW50QXJyYXkgKSB8fCAhaXNBcnJheSggYXJyYXkgKSApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0KCBrZXlwYXRoLCBhcnJheSwgb3B0aW9ucyAmJiBvcHRpb25zLmNvbXBsZXRlICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBNYW5hZ2UgdHJhbnNpdGlvbnNcblx0XHRcdHByb21pc2UgPSBydW5sb29wLnN0YXJ0KCB0aGlzLCB0cnVlICk7XG5cdFx0XHR0aGlzLnZpZXdtb2RlbC5tZXJnZSgga2V5cGF0aCwgY3VycmVudEFycmF5LCBhcnJheSwgb3B0aW9ucyApO1xuXHRcdFx0cnVubG9vcC5lbmQoKTtcblx0XHRcdC8vIGF0dGFjaCBjYWxsYmFjayBhcyBmdWxmaWxtZW50IGhhbmRsZXIsIGlmIHNwZWNpZmllZFxuXHRcdFx0aWYgKCBvcHRpb25zICYmIG9wdGlvbnMuY29tcGxldGUgKSB7XG5cdFx0XHRcdHByb21pc2UudGhlbiggb3B0aW9ucy5jb21wbGV0ZSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0fTtcblx0fSggcnVubG9vcCwgaXNBcnJheSwgbm9ybWFsaXNlS2V5cGF0aCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL29ic2VydmUvT2JzZXJ2ZXIuanMgKi9cblx0dmFyIFJhY3RpdmUkb2JzZXJ2ZV9PYnNlcnZlciA9IGZ1bmN0aW9uKCBydW5sb29wLCBpc0VxdWFsICkge1xuXG5cdFx0dmFyIE9ic2VydmVyID0gZnVuY3Rpb24oIHJhY3RpdmUsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zICkge1xuXHRcdFx0dGhpcy5yb290ID0gcmFjdGl2ZTtcblx0XHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG5cdFx0XHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0XHR0aGlzLmRlZmVyID0gb3B0aW9ucy5kZWZlcjtcblx0XHRcdC8vIGRlZmF1bHQgdG8gcm9vdCBhcyBjb250ZXh0LCBidXQgYWxsb3cgaXQgdG8gYmUgb3ZlcnJpZGRlblxuXHRcdFx0dGhpcy5jb250ZXh0ID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvbnRleHQgPyBvcHRpb25zLmNvbnRleHQgOiByYWN0aXZlO1xuXHRcdH07XG5cdFx0T2JzZXJ2ZXIucHJvdG90eXBlID0ge1xuXHRcdFx0aW5pdDogZnVuY3Rpb24oIGltbWVkaWF0ZSApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHRoaXMucm9vdC5nZXQoIHRoaXMua2V5cGF0aCApO1xuXHRcdFx0XHRpZiAoIGltbWVkaWF0ZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLm9sZFZhbHVlID0gdGhpcy52YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHNldFZhbHVlOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0XHRpZiAoICFpc0VxdWFsKCB2YWx1ZSwgdGhpcy52YWx1ZSApICkge1xuXHRcdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0XHRpZiAoIHRoaXMuZGVmZXIgJiYgdGhpcy5yZWFkeSApIHtcblx0XHRcdFx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMkMC51cGRhdGUoKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1cGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBQcmV2ZW50IGluZmluaXRlIGxvb3BzXG5cdFx0XHRcdGlmICggdGhpcy51cGRhdGluZyApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy51cGRhdGluZyA9IHRydWU7XG5cdFx0XHRcdHRoaXMuY2FsbGJhY2suY2FsbCggdGhpcy5jb250ZXh0LCB0aGlzLnZhbHVlLCB0aGlzLm9sZFZhbHVlLCB0aGlzLmtleXBhdGggKTtcblx0XHRcdFx0dGhpcy5vbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG5cdFx0XHRcdHRoaXMudXBkYXRpbmcgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBPYnNlcnZlcjtcblx0fSggcnVubG9vcCwgaXNFcXVhbCApO1xuXG5cdC8qIHNoYXJlZC9nZXRNYXRjaGluZ0tleXBhdGhzLmpzICovXG5cdHZhciBnZXRNYXRjaGluZ0tleXBhdGhzID0gZnVuY3Rpb24oIGlzQXJyYXkgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0TWF0Y2hpbmdLZXlwYXRocyggcmFjdGl2ZSwgcGF0dGVybiApIHtcblx0XHRcdHZhciBrZXlzLCBrZXksIG1hdGNoaW5nS2V5cGF0aHM7XG5cdFx0XHRrZXlzID0gcGF0dGVybi5zcGxpdCggJy4nICk7XG5cdFx0XHRtYXRjaGluZ0tleXBhdGhzID0gWyAnJyBdO1xuXHRcdFx0d2hpbGUgKCBrZXkgPSBrZXlzLnNoaWZ0KCkgKSB7XG5cdFx0XHRcdGlmICgga2V5ID09PSAnKicgKSB7XG5cdFx0XHRcdFx0Ly8gZXhwYW5kIHRvIGZpbmQgYWxsIHZhbGlkIGNoaWxkIGtleXBhdGhzXG5cdFx0XHRcdFx0bWF0Y2hpbmdLZXlwYXRocyA9IG1hdGNoaW5nS2V5cGF0aHMucmVkdWNlKCBleHBhbmQsIFtdICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCBtYXRjaGluZ0tleXBhdGhzWyAwIF0gPT09ICcnICkge1xuXHRcdFx0XHRcdFx0Ly8gZmlyc3Qga2V5XG5cdFx0XHRcdFx0XHRtYXRjaGluZ0tleXBhdGhzWyAwIF0gPSBrZXk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG1hdGNoaW5nS2V5cGF0aHMgPSBtYXRjaGluZ0tleXBhdGhzLm1hcCggY29uY2F0ZW5hdGUoIGtleSApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hpbmdLZXlwYXRocztcblxuXHRcdFx0ZnVuY3Rpb24gZXhwYW5kKCBtYXRjaGluZ0tleXBhdGhzLCBrZXlwYXRoICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIGtleSwgY2hpbGRLZXlwYXRoO1xuXHRcdFx0XHR2YWx1ZSA9IHJhY3RpdmUudmlld21vZGVsLndyYXBwZWRbIGtleXBhdGggXSA/IHJhY3RpdmUudmlld21vZGVsLndyYXBwZWRbIGtleXBhdGggXS5nZXQoKSA6IHJhY3RpdmUuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHRcdGZvciAoIGtleSBpbiB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoIHZhbHVlLmhhc093blByb3BlcnR5KCBrZXkgKSAmJiAoIGtleSAhPT0gJ19yYWN0aXZlJyB8fCAhaXNBcnJheSggdmFsdWUgKSApICkge1xuXHRcdFx0XHRcdFx0Ly8gZm9yIGJlbmVmaXQgb2YgSUU4XG5cdFx0XHRcdFx0XHRjaGlsZEtleXBhdGggPSBrZXlwYXRoID8ga2V5cGF0aCArICcuJyArIGtleSA6IGtleTtcblx0XHRcdFx0XHRcdG1hdGNoaW5nS2V5cGF0aHMucHVzaCggY2hpbGRLZXlwYXRoICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaGluZ0tleXBhdGhzO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBjb25jYXRlbmF0ZSgga2V5ICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGtleXBhdGggPyBrZXlwYXRoICsgJy4nICsga2V5IDoga2V5O1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIGlzQXJyYXkgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9vYnNlcnZlL2dldFBhdHRlcm4uanMgKi9cblx0dmFyIFJhY3RpdmUkb2JzZXJ2ZV9nZXRQYXR0ZXJuID0gZnVuY3Rpb24oIGdldE1hdGNoaW5nS2V5cGF0aHMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0UGF0dGVybiggcmFjdGl2ZSwgcGF0dGVybiApIHtcblx0XHRcdHZhciBtYXRjaGluZ0tleXBhdGhzLCB2YWx1ZXM7XG5cdFx0XHRtYXRjaGluZ0tleXBhdGhzID0gZ2V0TWF0Y2hpbmdLZXlwYXRocyggcmFjdGl2ZSwgcGF0dGVybiApO1xuXHRcdFx0dmFsdWVzID0ge307XG5cdFx0XHRtYXRjaGluZ0tleXBhdGhzLmZvckVhY2goIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHR2YWx1ZXNbIGtleXBhdGggXSA9IHJhY3RpdmUuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHR9ICk7XG5cdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdH07XG5cdH0oIGdldE1hdGNoaW5nS2V5cGF0aHMgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9vYnNlcnZlL1BhdHRlcm5PYnNlcnZlci5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRvYnNlcnZlX1BhdHRlcm5PYnNlcnZlciA9IGZ1bmN0aW9uKCBydW5sb29wLCBpc0VxdWFsLCBnZXRQYXR0ZXJuICkge1xuXG5cdFx0dmFyIFBhdHRlcm5PYnNlcnZlciwgd2lsZGNhcmQgPSAvXFwqLyxcblx0XHRcdHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXHRcdFBhdHRlcm5PYnNlcnZlciA9IGZ1bmN0aW9uKCByYWN0aXZlLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApIHtcblx0XHRcdHRoaXMucm9vdCA9IHJhY3RpdmU7XG5cdFx0XHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0XHR0aGlzLmRlZmVyID0gb3B0aW9ucy5kZWZlcjtcblx0XHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG5cdFx0XHR0aGlzLnJlZ2V4ID0gbmV3IFJlZ0V4cCggJ14nICsga2V5cGF0aC5yZXBsYWNlKCAvXFwuL2csICdcXFxcLicgKS5yZXBsYWNlKCAvXFwqL2csICcoW15cXFxcLl0rKScgKSArICckJyApO1xuXHRcdFx0dGhpcy52YWx1ZXMgPSB7fTtcblx0XHRcdGlmICggdGhpcy5kZWZlciApIHtcblx0XHRcdFx0dGhpcy5wcm94aWVzID0gW107XG5cdFx0XHR9XG5cdFx0XHQvLyBkZWZhdWx0IHRvIHJvb3QgYXMgY29udGV4dCwgYnV0IGFsbG93IGl0IHRvIGJlIG92ZXJyaWRkZW5cblx0XHRcdHRoaXMuY29udGV4dCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb250ZXh0ID8gb3B0aW9ucy5jb250ZXh0IDogcmFjdGl2ZTtcblx0XHR9O1xuXHRcdFBhdHRlcm5PYnNlcnZlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRpbml0OiBmdW5jdGlvbiggaW1tZWRpYXRlICkge1xuXHRcdFx0XHR2YXIgdmFsdWVzLCBrZXlwYXRoO1xuXHRcdFx0XHR2YWx1ZXMgPSBnZXRQYXR0ZXJuKCB0aGlzLnJvb3QsIHRoaXMua2V5cGF0aCApO1xuXHRcdFx0XHRpZiAoIGltbWVkaWF0ZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0Zm9yICgga2V5cGF0aCBpbiB2YWx1ZXMgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIHZhbHVlcy5oYXNPd25Qcm9wZXJ0eSgga2V5cGF0aCApICkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnVwZGF0ZSgga2V5cGF0aCApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnZhbHVlcyA9IHZhbHVlcztcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVwZGF0ZTogZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0XHR2YXIgdmFsdWVzO1xuXHRcdFx0XHRpZiAoIHdpbGRjYXJkLnRlc3QoIGtleXBhdGggKSApIHtcblx0XHRcdFx0XHR2YWx1ZXMgPSBnZXRQYXR0ZXJuKCB0aGlzLnJvb3QsIGtleXBhdGggKTtcblx0XHRcdFx0XHRmb3IgKCBrZXlwYXRoIGluIHZhbHVlcyApIHtcblx0XHRcdFx0XHRcdGlmICggdmFsdWVzLmhhc093blByb3BlcnR5KCBrZXlwYXRoICkgKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMudXBkYXRlKCBrZXlwYXRoICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBhcnJheSBtdXRhdGlvbiBzaG91bGQgbm90IHRyaWdnZXIgYGFycmF5LipgXG5cdFx0XHRcdC8vIHBhdHRlcm4gb2JzZXJ2ZXIgd2l0aCBgYXJyYXkubGVuZ3RoYFxuXHRcdFx0XHRpZiAoIHRoaXMucm9vdC52aWV3bW9kZWwuaW1wbGljaXRDaGFuZ2VzWyBrZXlwYXRoIF0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggdGhpcy5kZWZlciAmJiB0aGlzLnJlYWR5ICkge1xuXHRcdFx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzJDAuZ2V0UHJveHkoIGtleXBhdGggKS51cGRhdGUoKTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMucmVhbGx5VXBkYXRlKCBrZXlwYXRoICk7XG5cdFx0XHR9LFxuXHRcdFx0cmVhbGx5VXBkYXRlOiBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIHZhbHVlLCBrZXlzLCBhcmdzO1xuXHRcdFx0XHR2YWx1ZSA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHRcdC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcHNcblx0XHRcdFx0aWYgKCB0aGlzLnVwZGF0aW5nICkge1xuXHRcdFx0XHRcdHRoaXMudmFsdWVzWyBrZXlwYXRoIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy51cGRhdGluZyA9IHRydWU7XG5cdFx0XHRcdGlmICggIWlzRXF1YWwoIHZhbHVlLCB0aGlzLnZhbHVlc1sga2V5cGF0aCBdICkgfHwgIXRoaXMucmVhZHkgKSB7XG5cdFx0XHRcdFx0a2V5cyA9IHNsaWNlLmNhbGwoIHRoaXMucmVnZXguZXhlYygga2V5cGF0aCApLCAxICk7XG5cdFx0XHRcdFx0YXJncyA9IFtcblx0XHRcdFx0XHRcdHZhbHVlLFxuXHRcdFx0XHRcdFx0dGhpcy52YWx1ZXNbIGtleXBhdGggXSxcblx0XHRcdFx0XHRcdGtleXBhdGhcblx0XHRcdFx0XHRdLmNvbmNhdCgga2V5cyApO1xuXHRcdFx0XHRcdHRoaXMuY2FsbGJhY2suYXBwbHkoIHRoaXMuY29udGV4dCwgYXJncyApO1xuXHRcdFx0XHRcdHRoaXMudmFsdWVzWyBrZXlwYXRoIF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnVwZGF0aW5nID0gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0UHJveHk6IGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRcdGlmICggIXRoaXMucHJveGllc1sga2V5cGF0aCBdICkge1xuXHRcdFx0XHRcdHRoaXMucHJveGllc1sga2V5cGF0aCBdID0ge1xuXHRcdFx0XHRcdFx0dXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0c2VsZi5yZWFsbHlVcGRhdGUoIGtleXBhdGggKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLnByb3hpZXNbIGtleXBhdGggXTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBQYXR0ZXJuT2JzZXJ2ZXI7XG5cdH0oIHJ1bmxvb3AsIGlzRXF1YWwsIFJhY3RpdmUkb2JzZXJ2ZV9nZXRQYXR0ZXJuICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvb2JzZXJ2ZS9nZXRPYnNlcnZlckZhY2FkZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRvYnNlcnZlX2dldE9ic2VydmVyRmFjYWRlID0gZnVuY3Rpb24oIG5vcm1hbGlzZUtleXBhdGgsIE9ic2VydmVyLCBQYXR0ZXJuT2JzZXJ2ZXIgKSB7XG5cblx0XHR2YXIgd2lsZGNhcmQgPSAvXFwqLyxcblx0XHRcdGVtcHR5T2JqZWN0ID0ge307XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGdldE9ic2VydmVyRmFjYWRlKCByYWN0aXZlLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApIHtcblx0XHRcdHZhciBvYnNlcnZlciwgaXNQYXR0ZXJuT2JzZXJ2ZXIsIGNhbmNlbGxlZDtcblx0XHRcdGtleXBhdGggPSBub3JtYWxpc2VLZXlwYXRoKCBrZXlwYXRoICk7XG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCBlbXB0eU9iamVjdDtcblx0XHRcdC8vIHBhdHRlcm4gb2JzZXJ2ZXJzIGFyZSB0cmVhdGVkIGRpZmZlcmVudGx5XG5cdFx0XHRpZiAoIHdpbGRjYXJkLnRlc3QoIGtleXBhdGggKSApIHtcblx0XHRcdFx0b2JzZXJ2ZXIgPSBuZXcgUGF0dGVybk9ic2VydmVyKCByYWN0aXZlLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApO1xuXHRcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5wYXR0ZXJuT2JzZXJ2ZXJzLnB1c2goIG9ic2VydmVyICk7XG5cdFx0XHRcdGlzUGF0dGVybk9ic2VydmVyID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9ic2VydmVyID0gbmV3IE9ic2VydmVyKCByYWN0aXZlLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApO1xuXHRcdFx0fVxuXHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwucmVnaXN0ZXIoIGtleXBhdGgsIG9ic2VydmVyLCBpc1BhdHRlcm5PYnNlcnZlciA/ICdwYXR0ZXJuT2JzZXJ2ZXJzJyA6ICdvYnNlcnZlcnMnICk7XG5cdFx0XHRvYnNlcnZlci5pbml0KCBvcHRpb25zLmluaXQgKTtcblx0XHRcdC8vIFRoaXMgZmxhZyBhbGxvd3Mgb2JzZXJ2ZXJzIHRvIGluaXRpYWxpc2UgZXZlbiB3aXRoIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdG9ic2VydmVyLnJlYWR5ID0gdHJ1ZTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGNhbmNlbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdGlmICggY2FuY2VsbGVkICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIGlzUGF0dGVybk9ic2VydmVyICkge1xuXHRcdFx0XHRcdFx0aW5kZXggPSByYWN0aXZlLnZpZXdtb2RlbC5wYXR0ZXJuT2JzZXJ2ZXJzLmluZGV4T2YoIG9ic2VydmVyICk7XG5cdFx0XHRcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5wYXR0ZXJuT2JzZXJ2ZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0XHRcdHJhY3RpdmUudmlld21vZGVsLnVucmVnaXN0ZXIoIGtleXBhdGgsIG9ic2VydmVyLCAncGF0dGVybk9ic2VydmVycycgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwudW5yZWdpc3Rlcigga2V5cGF0aCwgb2JzZXJ2ZXIsICdvYnNlcnZlcnMnICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhbmNlbGxlZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fTtcblx0fSggbm9ybWFsaXNlS2V5cGF0aCwgUmFjdGl2ZSRvYnNlcnZlX09ic2VydmVyLCBSYWN0aXZlJG9ic2VydmVfUGF0dGVybk9ic2VydmVyICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvb2JzZXJ2ZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRvYnNlcnZlID0gZnVuY3Rpb24oIGlzT2JqZWN0LCBnZXRPYnNlcnZlckZhY2FkZSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJG9ic2VydmUoIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zICkge1xuXHRcdFx0dmFyIG9ic2VydmVycywgbWFwLCBrZXlwYXRocywgaTtcblx0XHRcdC8vIEFsbG93IGEgbWFwIG9mIGtleXBhdGhzIHRvIGhhbmRsZXJzXG5cdFx0XHRpZiAoIGlzT2JqZWN0KCBrZXlwYXRoICkgKSB7XG5cdFx0XHRcdG9wdGlvbnMgPSBjYWxsYmFjaztcblx0XHRcdFx0bWFwID0ga2V5cGF0aDtcblx0XHRcdFx0b2JzZXJ2ZXJzID0gW107XG5cdFx0XHRcdGZvciAoIGtleXBhdGggaW4gbWFwICkge1xuXHRcdFx0XHRcdGlmICggbWFwLmhhc093blByb3BlcnR5KCBrZXlwYXRoICkgKSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IG1hcFsga2V5cGF0aCBdO1xuXHRcdFx0XHRcdFx0b2JzZXJ2ZXJzLnB1c2goIHRoaXMub2JzZXJ2ZSgga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGNhbmNlbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIG9ic2VydmVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRcdG9ic2VydmVycy5wb3AoKS5jYW5jZWwoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHQvLyBBbGxvdyBgcmFjdGl2ZS5vYnNlcnZlKCBjYWxsYmFjayApYCAtIGkuZS4gb2JzZXJ2ZSBlbnRpcmUgbW9kZWxcblx0XHRcdGlmICggdHlwZW9mIGtleXBhdGggPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdG9wdGlvbnMgPSBjYWxsYmFjaztcblx0XHRcdFx0Y2FsbGJhY2sgPSBrZXlwYXRoO1xuXHRcdFx0XHRrZXlwYXRoID0gJyc7XG5cdFx0XHRcdHJldHVybiBnZXRPYnNlcnZlckZhY2FkZSggdGhpcywga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMgKTtcblx0XHRcdH1cblx0XHRcdGtleXBhdGhzID0ga2V5cGF0aC5zcGxpdCggJyAnICk7XG5cdFx0XHQvLyBTaW5nbGUga2V5cGF0aFxuXHRcdFx0aWYgKCBrZXlwYXRocy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRcdHJldHVybiBnZXRPYnNlcnZlckZhY2FkZSggdGhpcywga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMgKTtcblx0XHRcdH1cblx0XHRcdC8vIE11bHRpcGxlIHNwYWNlLXNlcGFyYXRlZCBrZXlwYXRoc1xuXHRcdFx0b2JzZXJ2ZXJzID0gW107XG5cdFx0XHRpID0ga2V5cGF0aHMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGtleXBhdGggPSBrZXlwYXRoc1sgaSBdO1xuXHRcdFx0XHRpZiAoIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0b2JzZXJ2ZXJzLnB1c2goIGdldE9ic2VydmVyRmFjYWRlKCB0aGlzLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGNhbmNlbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0d2hpbGUgKCBvYnNlcnZlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0b2JzZXJ2ZXJzLnBvcCgpLmNhbmNlbCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9O1xuXHR9KCBpc09iamVjdCwgUmFjdGl2ZSRvYnNlcnZlX2dldE9ic2VydmVyRmFjYWRlICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2hhcmVkL3RyaW0uanMgKi9cblx0dmFyIFJhY3RpdmUkc2hhcmVkX3RyaW0gPSBmdW5jdGlvbiggc3RyICkge1xuXHRcdHJldHVybiBzdHIudHJpbSgpO1xuXHR9O1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NoYXJlZC9ub3RFbXB0eVN0cmluZy5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzaGFyZWRfbm90RW1wdHlTdHJpbmcgPSBmdW5jdGlvbiggc3RyICkge1xuXHRcdHJldHVybiBzdHIgIT09ICcnO1xuXHR9O1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL29mZi5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRvZmYgPSBmdW5jdGlvbiggdHJpbSwgbm90RW1wdHlTdHJpbmcgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRvZmYoIGV2ZW50TmFtZSwgY2FsbGJhY2sgKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdHZhciBldmVudE5hbWVzO1xuXHRcdFx0Ly8gaWYgbm8gYXJndW1lbnRzIHNwZWNpZmllZCwgcmVtb3ZlIGFsbCBjYWxsYmFja3Ncblx0XHRcdGlmICggIWV2ZW50TmFtZSApIHtcblx0XHRcdFx0Ly8gVE9ETyB1c2UgdGhpcyBjb2RlIGluc3RlYWQsIG9uY2UgdGhlIGZvbGxvd2luZyBpc3N1ZSBoYXMgYmVlbiByZXNvbHZlZFxuXHRcdFx0XHQvLyBpbiBQaGFudG9tSlMgKHRlc3RzIGFyZSB1bnBhc3NhYmxlIG90aGVyd2lzZSEpXG5cdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hcml5YS9waGFudG9tanMvaXNzdWVzLzExODU2XG5cdFx0XHRcdC8vIGRlZmluZVByb3BlcnR5KCB0aGlzLCAnX3N1YnMnLCB7IHZhbHVlOiBjcmVhdGUoIG51bGwgKSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuXHRcdFx0XHRmb3IgKCBldmVudE5hbWUgaW4gdGhpcy5fc3VicyApIHtcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5fc3Vic1sgZXZlbnROYW1lIF07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBzcGFjZS1zZXBhcmF0ZWQgZXZlbnQgbmFtZXNcblx0XHRcdFx0ZXZlbnROYW1lcyA9IGV2ZW50TmFtZS5zcGxpdCggJyAnICkubWFwKCB0cmltICkuZmlsdGVyKCBub3RFbXB0eVN0cmluZyApO1xuXHRcdFx0XHRldmVudE5hbWVzLmZvckVhY2goIGZ1bmN0aW9uKCBldmVudE5hbWUgKSB7XG5cdFx0XHRcdFx0dmFyIHN1YnNjcmliZXJzLCBpbmRleDtcblx0XHRcdFx0XHQvLyBJZiB3ZSBoYXZlIHN1YnNjcmliZXJzIGZvciB0aGlzIGV2ZW50Li4uXG5cdFx0XHRcdFx0aWYgKCBzdWJzY3JpYmVycyA9IHRoaXMkMC5fc3Vic1sgZXZlbnROYW1lIF0gKSB7XG5cdFx0XHRcdFx0XHQvLyAuLi5pZiBhIGNhbGxiYWNrIHdhcyBzcGVjaWZpZWQsIG9ubHkgcmVtb3ZlIHRoYXRcblx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdGluZGV4ID0gc3Vic2NyaWJlcnMuaW5kZXhPZiggY2FsbGJhY2sgKTtcblx0XHRcdFx0XHRcdFx0aWYgKCBpbmRleCAhPT0gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3Vic2NyaWJlcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0aGlzJDAuX3N1YnNbIGV2ZW50TmFtZSBdID0gW107XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF90cmltLCBSYWN0aXZlJHNoYXJlZF9ub3RFbXB0eVN0cmluZyApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL29uLmpzICovXG5cdHZhciBSYWN0aXZlJG9uID0gZnVuY3Rpb24oIHRyaW0sIG5vdEVtcHR5U3RyaW5nICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkb24oIGV2ZW50TmFtZSwgY2FsbGJhY2sgKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdHZhciBzZWxmID0gdGhpcyxcblx0XHRcdFx0bGlzdGVuZXJzLCBuLCBldmVudE5hbWVzO1xuXHRcdFx0Ly8gYWxsb3cgbXV0bGlwbGUgbGlzdGVuZXJzIHRvIGJlIGJvdW5kIGluIG9uZSBnb1xuXHRcdFx0aWYgKCB0eXBlb2YgZXZlbnROYW1lID09PSAnb2JqZWN0JyApIHtcblx0XHRcdFx0bGlzdGVuZXJzID0gW107XG5cdFx0XHRcdGZvciAoIG4gaW4gZXZlbnROYW1lICkge1xuXHRcdFx0XHRcdGlmICggZXZlbnROYW1lLmhhc093blByb3BlcnR5KCBuICkgKSB7XG5cdFx0XHRcdFx0XHRsaXN0ZW5lcnMucHVzaCggdGhpcy5vbiggbiwgZXZlbnROYW1lWyBuIF0gKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGNhbmNlbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHR2YXIgbGlzdGVuZXI7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGxpc3RlbmVyID0gbGlzdGVuZXJzLnBvcCgpICkge1xuXHRcdFx0XHRcdFx0XHRsaXN0ZW5lci5jYW5jZWwoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHQvLyBIYW5kbGUgbXVsdGlwbGUgc3BhY2Utc2VwYXJhdGVkIGV2ZW50IG5hbWVzXG5cdFx0XHRldmVudE5hbWVzID0gZXZlbnROYW1lLnNwbGl0KCAnICcgKS5tYXAoIHRyaW0gKS5maWx0ZXIoIG5vdEVtcHR5U3RyaW5nICk7XG5cdFx0XHRldmVudE5hbWVzLmZvckVhY2goIGZ1bmN0aW9uKCBldmVudE5hbWUgKSB7XG5cdFx0XHRcdCggdGhpcyQwLl9zdWJzWyBldmVudE5hbWUgXSB8fCAoIHRoaXMkMC5fc3Vic1sgZXZlbnROYW1lIF0gPSBbXSApICkucHVzaCggY2FsbGJhY2sgKTtcblx0XHRcdH0gKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGNhbmNlbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0c2VsZi5vZmYoIGV2ZW50TmFtZSwgY2FsbGJhY2sgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF90cmltLCBSYWN0aXZlJHNoYXJlZF9ub3RFbXB0eVN0cmluZyApO1xuXG5cdC8qIHNoYXJlZC9nZXROZXdJbmRpY2VzLmpzICovXG5cdHZhciBnZXROZXdJbmRpY2VzID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0Ly8gVGhpcyBmdW5jdGlvbiB0YWtlcyBhbiBhcnJheSwgdGhlIG5hbWUgb2YgYSBtdXRhdG9yIG1ldGhvZCwgYW5kIHRoZVxuXHRcdC8vIGFyZ3VtZW50cyB0byBjYWxsIHRoYXQgbXV0YXRvciBtZXRob2Qgd2l0aCwgYW5kIHJldHVybnMgYW4gYXJyYXkgdGhhdFxuXHRcdC8vIG1hcHMgdGhlIG9sZCBpbmRpY2VzIHRvIHRoZWlyIG5ldyBpbmRpY2VzLlxuXHRcdC8vIFNvIGlmIHlvdSBoYWQgc29tZXRoaW5nIGxpa2UgdGhpcy4uLlxuXHRcdC8vXG5cdFx0Ly8gICAgIGFycmF5ID0gWyAnYScsICdiJywgJ2MnLCAnZCcgXTtcblx0XHQvLyAgICAgYXJyYXkucHVzaCggJ2UnICk7XG5cdFx0Ly9cblx0XHQvLyAuLi55b3UnZCBnZXQgYFsgMCwgMSwgMiwgMyBdYCAtIGluIG90aGVyIHdvcmRzLCBub25lIG9mIHRoZSBvbGQgaW5kaWNlc1xuXHRcdC8vIGhhdmUgY2hhbmdlZC4gSWYgeW91IHRoZW4gZGlkIHRoaXMuLi5cblx0XHQvL1xuXHRcdC8vICAgICBhcnJheS51bnNoaWZ0KCAneicgKTtcblx0XHQvL1xuXHRcdC8vIC4uLnRoZSBpbmRpY2VzIHdvdWxkIGJlIGBbIDEsIDIsIDMsIDQsIDUgXWAgLSBldmVyeSBpdGVtIGhhcyBiZWVuIG1vdmVkXG5cdFx0Ly8gb25lIGhpZ2hlciB0byBtYWtlIHJvb20gZm9yIHRoZSAneicuIElmIHlvdSByZW1vdmVkIGFuIGl0ZW0sIHRoZSBuZXcgaW5kZXhcblx0XHQvLyB3b3VsZCBiZSAtMS4uLlxuXHRcdC8vXG5cdFx0Ly8gICAgIGFycmF5LnNwbGljZSggMiwgMiApO1xuXHRcdC8vXG5cdFx0Ly8gLi4udGhpcyB3b3VsZCByZXN1bHQgaW4gWyAwLCAxLCAtMSwgLTEsIDIsIDMgXS5cblx0XHQvL1xuXHRcdC8vIFRoaXMgaW5mb3JtYXRpb24gaXMgdXNlZCB0byBlbmFibGUgZmFzdCwgbm9uLWRlc3RydWN0aXZlIHNodWZmbGluZyBvZiBsaXN0XG5cdFx0Ly8gc2VjdGlvbnMgd2hlbiB5b3UgZG8gZS5nLiBgcmFjdGl2ZS5zcGxpY2UoICdpdGVtcycsIDIsIDIgKTtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIGdldE5ld0luZGljZXMoIGFycmF5LCBtZXRob2ROYW1lLCBhcmdzICkge1xuXHRcdFx0dmFyIHNwbGljZUFyZ3VtZW50cywgbGVuLCBuZXdJbmRpY2VzID0gW10sXG5cdFx0XHRcdHJlbW92ZVN0YXJ0LCByZW1vdmVFbmQsIGJhbGFuY2UsIGk7XG5cdFx0XHRzcGxpY2VBcmd1bWVudHMgPSBnZXRTcGxpY2VFcXVpdmFsZW50KCBhcnJheSwgbWV0aG9kTmFtZSwgYXJncyApO1xuXHRcdFx0aWYgKCAhc3BsaWNlQXJndW1lbnRzICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGxlbiA9IGFycmF5Lmxlbmd0aDtcblx0XHRcdGJhbGFuY2UgPSBzcGxpY2VBcmd1bWVudHMubGVuZ3RoIC0gMiAtIHNwbGljZUFyZ3VtZW50c1sgMSBdO1xuXHRcdFx0cmVtb3ZlU3RhcnQgPSBNYXRoLm1pbiggbGVuLCBzcGxpY2VBcmd1bWVudHNbIDAgXSApO1xuXHRcdFx0cmVtb3ZlRW5kID0gcmVtb3ZlU3RhcnQgKyBzcGxpY2VBcmd1bWVudHNbIDEgXTtcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgcmVtb3ZlU3RhcnQ7IGkgKz0gMSApIHtcblx0XHRcdFx0bmV3SW5kaWNlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCA7IGkgPCByZW1vdmVFbmQ7IGkgKz0gMSApIHtcblx0XHRcdFx0bmV3SW5kaWNlcy5wdXNoKCAtMSApO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRcdG5ld0luZGljZXMucHVzaCggaSArIGJhbGFuY2UgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBuZXdJbmRpY2VzO1xuXHRcdH07XG5cdFx0Ly8gVGhlIHBvcCwgcHVzaCwgc2hpZnQgYW4gdW5zaGlmdCBtZXRob2RzIGNhbiBhbGwgYmUgcmVwcmVzZW50ZWRcblx0XHQvLyBhcyBhbiBlcXVpdmFsZW50IHNwbGljZVxuXHRcdGZ1bmN0aW9uIGdldFNwbGljZUVxdWl2YWxlbnQoIGFycmF5LCBtZXRob2ROYW1lLCBhcmdzICkge1xuXHRcdFx0c3dpdGNoICggbWV0aG9kTmFtZSApIHtcblx0XHRcdFx0Y2FzZSAnc3BsaWNlJzpcblx0XHRcdFx0XHRpZiAoIGFyZ3NbIDAgXSAhPT0gdW5kZWZpbmVkICYmIGFyZ3NbIDAgXSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRhcmdzWyAwIF0gPSBhcnJheS5sZW5ndGggKyBNYXRoLm1heCggYXJnc1sgMCBdLCAtYXJyYXkubGVuZ3RoICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdoaWxlICggYXJncy5sZW5ndGggPCAyICkge1xuXHRcdFx0XHRcdFx0YXJncy5wdXNoKCAwICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIGVuc3VyZSB3ZSBvbmx5IHJlbW92ZSBlbGVtZW50cyB0aGF0IGV4aXN0XG5cdFx0XHRcdFx0YXJnc1sgMSBdID0gTWF0aC5taW4oIGFyZ3NbIDEgXSwgYXJyYXkubGVuZ3RoIC0gYXJnc1sgMCBdICk7XG5cdFx0XHRcdFx0cmV0dXJuIGFyZ3M7XG5cdFx0XHRcdGNhc2UgJ3NvcnQnOlxuXHRcdFx0XHRjYXNlICdyZXZlcnNlJzpcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0Y2FzZSAncG9wJzpcblx0XHRcdFx0XHRpZiAoIGFycmF5Lmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0XHRcdGFycmF5Lmxlbmd0aCAtIDEsXG5cdFx0XHRcdFx0XHRcdDFcblx0XHRcdFx0XHRcdF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRjYXNlICdwdXNoJzpcblx0XHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdFx0YXJyYXkubGVuZ3RoLFxuXHRcdFx0XHRcdFx0MFxuXHRcdFx0XHRcdF0uY29uY2F0KCBhcmdzICk7XG5cdFx0XHRcdGNhc2UgJ3NoaWZ0Jzpcblx0XHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdDFcblx0XHRcdFx0XHRdO1xuXHRcdFx0XHRjYXNlICd1bnNoaWZ0Jzpcblx0XHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdDBcblx0XHRcdFx0XHRdLmNvbmNhdCggYXJncyApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvbWFrZUFycmF5TWV0aG9kLmpzICovXG5cdHZhciBSYWN0aXZlJHNoYXJlZF9tYWtlQXJyYXlNZXRob2QgPSBmdW5jdGlvbiggaXNBcnJheSwgcnVubG9vcCwgZ2V0TmV3SW5kaWNlcyApIHtcblxuXHRcdHZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXHRcdHJldHVybiBmdW5jdGlvbiggbWV0aG9kTmFtZSApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIFNMSUNFJDAgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cdFx0XHRcdHZhciBhcmdzID0gU0xJQ0UkMC5jYWxsKCBhcmd1bWVudHMsIDEgKTtcblx0XHRcdFx0dmFyIGFycmF5LCBuZXdJbmRpY2VzID0gW10sXG5cdFx0XHRcdFx0bGVuLCBwcm9taXNlLCByZXN1bHQ7XG5cdFx0XHRcdGFycmF5ID0gdGhpcy5nZXQoIGtleXBhdGggKTtcblx0XHRcdFx0bGVuID0gYXJyYXkubGVuZ3RoO1xuXHRcdFx0XHRpZiAoICFpc0FycmF5KCBhcnJheSApICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0NhbGxlZCByYWN0aXZlLicgKyBtZXRob2ROYW1lICsgJyhcXCcnICsga2V5cGF0aCArICdcXCcpLCBidXQgXFwnJyArIGtleXBhdGggKyAnXFwnIGRvZXMgbm90IHJlZmVyIHRvIGFuIGFycmF5JyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5ld0luZGljZXMgPSBnZXROZXdJbmRpY2VzKCBhcnJheSwgbWV0aG9kTmFtZSwgYXJncyApO1xuXHRcdFx0XHRyZXN1bHQgPSBhcnJheVByb3RvWyBtZXRob2ROYW1lIF0uYXBwbHkoIGFycmF5LCBhcmdzICk7XG5cdFx0XHRcdHByb21pc2UgPSBydW5sb29wLnN0YXJ0KCB0aGlzLCB0cnVlICkudGhlbiggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRpZiAoICEhbmV3SW5kaWNlcyApIHtcblx0XHRcdFx0XHR0aGlzLnZpZXdtb2RlbC5zbWFydFVwZGF0ZSgga2V5cGF0aCwgYXJyYXksIG5ld0luZGljZXMgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnZpZXdtb2RlbC5tYXJrKCBrZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cnVubG9vcC5lbmQoKTtcblx0XHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0oIGlzQXJyYXksIHJ1bmxvb3AsIGdldE5ld0luZGljZXMgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9wb3AuanMgKi9cblx0dmFyIFJhY3RpdmUkcG9wID0gZnVuY3Rpb24oIG1ha2VBcnJheU1ldGhvZCApIHtcblxuXHRcdHJldHVybiBtYWtlQXJyYXlNZXRob2QoICdwb3AnICk7XG5cdH0oIFJhY3RpdmUkc2hhcmVkX21ha2VBcnJheU1ldGhvZCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3B1c2guanMgKi9cblx0dmFyIFJhY3RpdmUkcHVzaCA9IGZ1bmN0aW9uKCBtYWtlQXJyYXlNZXRob2QgKSB7XG5cblx0XHRyZXR1cm4gbWFrZUFycmF5TWV0aG9kKCAncHVzaCcgKTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfbWFrZUFycmF5TWV0aG9kICk7XG5cblx0LyogZ2xvYmFsL2Nzcy5qcyAqL1xuXHR2YXIgZ2xvYmFsX2NzcyA9IGZ1bmN0aW9uKCBjaXJjdWxhciwgaXNDbGllbnQsIHJlbW92ZUZyb21BcnJheSApIHtcblxuXHRcdHZhciBjc3MsIHVwZGF0ZSwgcnVubG9vcCwgc3R5bGVFbGVtZW50LCBoZWFkLCBzdHlsZVNoZWV0LCBpbkRvbSwgcHJlZml4ID0gJy8qIFJhY3RpdmUuanMgY29tcG9uZW50IHN0eWxlcyAqL1xcbicsXG5cdFx0XHRjb21wb25lbnRzSW5QYWdlID0ge30sXG5cdFx0XHRzdHlsZXMgPSBbXTtcblx0XHRpZiAoICFpc0NsaWVudCApIHtcblx0XHRcdGNzcyA9IG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRydW5sb29wID0gY2lyY3VsYXIucnVubG9vcDtcblx0XHRcdH0gKTtcblx0XHRcdHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdzdHlsZScgKTtcblx0XHRcdHN0eWxlRWxlbWVudC50eXBlID0gJ3RleHQvY3NzJztcblx0XHRcdGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSggJ2hlYWQnIClbIDAgXTtcblx0XHRcdGluRG9tID0gZmFsc2U7XG5cdFx0XHQvLyBJbnRlcm5ldCBFeHBsb2RlciB3b24ndCBsZXQgeW91IHVzZSBzdHlsZVNoZWV0LmlubmVySFRNTCAtIHdlIGhhdmUgdG9cblx0XHRcdC8vIHVzZSBzdHlsZVNoZWV0LmNzc1RleHQgaW5zdGVhZFxuXHRcdFx0c3R5bGVTaGVldCA9IHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0O1xuXHRcdFx0dXBkYXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBjc3M7XG5cdFx0XHRcdGlmICggc3R5bGVzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRjc3MgPSBwcmVmaXggKyBzdHlsZXMuam9pbiggJyAnICk7XG5cdFx0XHRcdFx0aWYgKCBzdHlsZVNoZWV0ICkge1xuXHRcdFx0XHRcdFx0c3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzdHlsZUVsZW1lbnQuaW5uZXJIVE1MID0gY3NzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoICFpbkRvbSApIHtcblx0XHRcdFx0XHRcdGhlYWQuYXBwZW5kQ2hpbGQoIHN0eWxlRWxlbWVudCApO1xuXHRcdFx0XHRcdFx0aW5Eb20gPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICggaW5Eb20gKSB7XG5cdFx0XHRcdFx0aGVhZC5yZW1vdmVDaGlsZCggc3R5bGVFbGVtZW50ICk7XG5cdFx0XHRcdFx0aW5Eb20gPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGNzcyA9IHtcblx0XHRcdFx0YWRkOiBmdW5jdGlvbiggQ29tcG9uZW50ICkge1xuXHRcdFx0XHRcdGlmICggIUNvbXBvbmVudC5jc3MgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggIWNvbXBvbmVudHNJblBhZ2VbIENvbXBvbmVudC5fZ3VpZCBdICkge1xuXHRcdFx0XHRcdFx0Ly8gd2UgY3JlYXRlIHRoaXMgY291bnRlciBzbyB0aGF0IHdlIGNhbiBpbi9kZWNyZW1lbnQgaXQgYXNcblx0XHRcdFx0XHRcdC8vIGluc3RhbmNlcyBhcmUgYWRkZWQgYW5kIHJlbW92ZWQuIFdoZW4gYWxsIGNvbXBvbmVudHMgYXJlXG5cdFx0XHRcdFx0XHQvLyByZW1vdmVkLCB0aGUgc3R5bGUgaXMgdG9vXG5cdFx0XHRcdFx0XHRjb21wb25lbnRzSW5QYWdlWyBDb21wb25lbnQuX2d1aWQgXSA9IDA7XG5cdFx0XHRcdFx0XHRzdHlsZXMucHVzaCggQ29tcG9uZW50LmNzcyApO1xuXHRcdFx0XHRcdFx0dXBkYXRlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvbXBvbmVudHNJblBhZ2VbIENvbXBvbmVudC5fZ3VpZCBdICs9IDE7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHJlbW92ZTogZnVuY3Rpb24oIENvbXBvbmVudCApIHtcblx0XHRcdFx0XHRpZiAoICFDb21wb25lbnQuY3NzICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb21wb25lbnRzSW5QYWdlWyBDb21wb25lbnQuX2d1aWQgXSAtPSAxO1xuXHRcdFx0XHRcdGlmICggIWNvbXBvbmVudHNJblBhZ2VbIENvbXBvbmVudC5fZ3VpZCBdICkge1xuXHRcdFx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCBzdHlsZXMsIENvbXBvbmVudC5jc3MgKTtcblx0XHRcdFx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCB1cGRhdGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBjc3M7XG5cdH0oIGNpcmN1bGFyLCBpc0NsaWVudCwgcmVtb3ZlRnJvbUFycmF5ICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvcmVuZGVyLmpzICovXG5cdHZhciBSYWN0aXZlJHJlbmRlciA9IGZ1bmN0aW9uKCBjc3MsIEhvb2ssIGdldEVsZW1lbnQsIHJ1bmxvb3AgKSB7XG5cblx0XHR2YXIgcmVuZGVySG9vayA9IG5ldyBIb29rKCAncmVuZGVyJyApLFxuXHRcdFx0Y29tcGxldGVIb29rID0gbmV3IEhvb2soICdjb21wbGV0ZScgKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRyZW5kZXIoIHRhcmdldCwgYW5jaG9yICkge1xuXHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHR2YXIgcHJvbWlzZSwgaW5zdGFuY2VzLCB0cmFuc2l0aW9uc0VuYWJsZWQ7XG5cdFx0XHQvLyBpZiBgbm9JbnRyb2AgaXMgYHRydWVgLCB0ZW1wb3JhcmlseSBkaXNhYmxlIHRyYW5zaXRpb25zXG5cdFx0XHR0cmFuc2l0aW9uc0VuYWJsZWQgPSB0aGlzLnRyYW5zaXRpb25zRW5hYmxlZDtcblx0XHRcdGlmICggdGhpcy5ub0ludHJvICkge1xuXHRcdFx0XHR0aGlzLnRyYW5zaXRpb25zRW5hYmxlZCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0cHJvbWlzZSA9IHJ1bmxvb3Auc3RhcnQoIHRoaXMsIHRydWUgKTtcblx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHJlbmRlckhvb2suZmlyZSggdGhpcyQwICk7XG5cdFx0XHR9LCB0cnVlICk7XG5cdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQucmVuZGVyZWQgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1lvdSBjYW5ub3QgY2FsbCByYWN0aXZlLnJlbmRlcigpIG9uIGFuIGFscmVhZHkgcmVuZGVyZWQgaW5zdGFuY2UhIENhbGwgcmFjdGl2ZS51bnJlbmRlcigpIGZpcnN0JyApO1xuXHRcdFx0fVxuXHRcdFx0dGFyZ2V0ID0gZ2V0RWxlbWVudCggdGFyZ2V0ICkgfHwgdGhpcy5lbDtcblx0XHRcdGFuY2hvciA9IGdldEVsZW1lbnQoIGFuY2hvciApIHx8IHRoaXMuYW5jaG9yO1xuXHRcdFx0dGhpcy5lbCA9IHRhcmdldDtcblx0XHRcdHRoaXMuYW5jaG9yID0gYW5jaG9yO1xuXHRcdFx0Ly8gQWRkIENTUywgaWYgYXBwbGljYWJsZVxuXHRcdFx0aWYgKCB0aGlzLmNvbnN0cnVjdG9yLmNzcyApIHtcblx0XHRcdFx0Y3NzLmFkZCggdGhpcy5jb25zdHJ1Y3RvciApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0YXJnZXQgKSB7XG5cdFx0XHRcdGlmICggISggaW5zdGFuY2VzID0gdGFyZ2V0Ll9fcmFjdGl2ZV9pbnN0YW5jZXNfXyApICkge1xuXHRcdFx0XHRcdHRhcmdldC5fX3JhY3RpdmVfaW5zdGFuY2VzX18gPSBbIHRoaXMgXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpbnN0YW5jZXMucHVzaCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggYW5jaG9yICkge1xuXHRcdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIHRoaXMuZnJhZ21lbnQucmVuZGVyKCksIGFuY2hvciApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZCggdGhpcy5mcmFnbWVudC5yZW5kZXIoKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRydW5sb29wLmVuZCgpO1xuXHRcdFx0dGhpcy50cmFuc2l0aW9uc0VuYWJsZWQgPSB0cmFuc2l0aW9uc0VuYWJsZWQ7XG5cdFx0XHQvLyBJdCBpcyBub3cgbW9yZSBwcm9ibGVtYXRpYyB0byBrbm93IGlmIHRoZSBjb21wbGV0ZSBob29rXG5cdFx0XHQvLyB3b3VsZCBmaXJlLiBNZXRob2QgY2hlY2tpbmcgaXMgc3RyYWlnaHQtZm9yd2FyZCwgYnV0IHdvdWxkXG5cdFx0XHQvLyBhbHNvIHJlcXVpcmUgcHJlZmxpZ2h0aW5nIGV2ZW50IHN1YnNjcmlwdGlvbnMuIFdoaWNoIHNlZW1zXG5cdFx0XHQvLyBsaWtlIG1vcmUgd29yayB0aGVuIGp1c3QgbGV0dGluZyB0aGUgcHJvbWlzZSBoYXBwZW4uXG5cdFx0XHQvLyBCdXQgcGVyaGFwcyBJJ20gd3JvbmcgYWJvdXQgdGhhdC4uLlxuXHRcdFx0cHJvbWlzZS50aGVuKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGNvbXBsZXRlSG9vay5maXJlKCB0aGlzJDAgKTtcblx0XHRcdH0gKTtcblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdH07XG5cdH0oIGdsb2JhbF9jc3MsIFJhY3RpdmUkc2hhcmVkX2hvb2tzX0hvb2ssIGdldEVsZW1lbnQsIHJ1bmxvb3AgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS9idWJibGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkYnViYmxlID0gZnVuY3Rpb24gRnJhZ21lbnQkYnViYmxlKCkge1xuXHRcdHRoaXMuZGlydHlWYWx1ZSA9IHRoaXMuZGlydHlBcmdzID0gdHJ1ZTtcblx0XHRpZiAoIHRoaXMuYm91bmQgJiYgdHlwZW9mIHRoaXMub3duZXIuYnViYmxlID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0dGhpcy5vd25lci5idWJibGUoKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvZGV0YWNoLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JGRldGFjaCA9IGZ1bmN0aW9uIEZyYWdtZW50JGRldGFjaCgpIHtcblx0XHR2YXIgZG9jRnJhZztcblx0XHRpZiAoIHRoaXMuaXRlbXMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaXRlbXNbIDAgXS5kZXRhY2goKTtcblx0XHR9XG5cdFx0ZG9jRnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHR0aGlzLml0ZW1zLmZvckVhY2goIGZ1bmN0aW9uKCBpdGVtICkge1xuXHRcdFx0dmFyIG5vZGUgPSBpdGVtLmRldGFjaCgpO1xuXHRcdFx0Ly8gVE9ETyBUaGUgaWYgey4uLn0gd2Fzbid0IHByZXZpb3VzbHkgcmVxdWlyZWQgLSBpdCBpcyBub3csIGJlY2F1c2Ugd2UncmVcblx0XHRcdC8vIGZvcmNpYmx5IGRldGFjaGluZyBldmVyeXRoaW5nIHRvIHJlb3JkZXIgc2VjdGlvbnMgYWZ0ZXIgYW4gdXBkYXRlLiBUaGF0J3Ncblx0XHRcdC8vIGEgbm9uLWlkZWFsIGJydXRlIGZvcmNlIGFwcHJvYWNoLCBpbXBsZW1lbnRlZCB0byBnZXQgYWxsIHRoZSB0ZXN0cyB0byBwYXNzXG5cdFx0XHQvLyAtIGFzIHNvb24gYXMgaXQncyByZXBsYWNlZCB3aXRoIHNvbWV0aGluZyBtb3JlIGVsZWdhbnQsIHRoaXMgc2hvdWxkXG5cdFx0XHQvLyByZXZlcnQgdG8gYGRvY0ZyYWcuYXBwZW5kQ2hpbGQoIGl0ZW0uZGV0YWNoKCkgKWBcblx0XHRcdGlmICggbm9kZSApIHtcblx0XHRcdFx0ZG9jRnJhZy5hcHBlbmRDaGlsZCggbm9kZSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gZG9jRnJhZztcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS9maW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JGZpbmQgPSBmdW5jdGlvbiBGcmFnbWVudCRmaW5kKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSwgbGVuLCBpdGVtLCBxdWVyeVJlc3VsdDtcblx0XHRpZiAoIHRoaXMuaXRlbXMgKSB7XG5cdFx0XHRsZW4gPSB0aGlzLml0ZW1zLmxlbmd0aDtcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRcdGl0ZW0gPSB0aGlzLml0ZW1zWyBpIF07XG5cdFx0XHRcdGlmICggaXRlbS5maW5kICYmICggcXVlcnlSZXN1bHQgPSBpdGVtLmZpbmQoIHNlbGVjdG9yICkgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcXVlcnlSZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS9maW5kQWxsLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JGZpbmRBbGwgPSBmdW5jdGlvbiBGcmFnbWVudCRmaW5kQWxsKCBzZWxlY3RvciwgcXVlcnkgKSB7XG5cdFx0dmFyIGksIGxlbiwgaXRlbTtcblx0XHRpZiAoIHRoaXMuaXRlbXMgKSB7XG5cdFx0XHRsZW4gPSB0aGlzLml0ZW1zLmxlbmd0aDtcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRcdGl0ZW0gPSB0aGlzLml0ZW1zWyBpIF07XG5cdFx0XHRcdGlmICggaXRlbS5maW5kQWxsICkge1xuXHRcdFx0XHRcdGl0ZW0uZmluZEFsbCggc2VsZWN0b3IsIHF1ZXJ5ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHF1ZXJ5O1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL2ZpbmRBbGxDb21wb25lbnRzLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JGZpbmRBbGxDb21wb25lbnRzID0gZnVuY3Rpb24gRnJhZ21lbnQkZmluZEFsbENvbXBvbmVudHMoIHNlbGVjdG9yLCBxdWVyeSApIHtcblx0XHR2YXIgaSwgbGVuLCBpdGVtO1xuXHRcdGlmICggdGhpcy5pdGVtcyApIHtcblx0XHRcdGxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0aXRlbSA9IHRoaXMuaXRlbXNbIGkgXTtcblx0XHRcdFx0aWYgKCBpdGVtLmZpbmRBbGxDb21wb25lbnRzICkge1xuXHRcdFx0XHRcdGl0ZW0uZmluZEFsbENvbXBvbmVudHMoIHNlbGVjdG9yLCBxdWVyeSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBxdWVyeTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS9maW5kQ29tcG9uZW50LmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JGZpbmRDb21wb25lbnQgPSBmdW5jdGlvbiBGcmFnbWVudCRmaW5kQ29tcG9uZW50KCBzZWxlY3RvciApIHtcblx0XHR2YXIgbGVuLCBpLCBpdGVtLCBxdWVyeVJlc3VsdDtcblx0XHRpZiAoIHRoaXMuaXRlbXMgKSB7XG5cdFx0XHRsZW4gPSB0aGlzLml0ZW1zLmxlbmd0aDtcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRcdGl0ZW0gPSB0aGlzLml0ZW1zWyBpIF07XG5cdFx0XHRcdGlmICggaXRlbS5maW5kQ29tcG9uZW50ICYmICggcXVlcnlSZXN1bHQgPSBpdGVtLmZpbmRDb21wb25lbnQoIHNlbGVjdG9yICkgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcXVlcnlSZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS9maW5kTmV4dE5vZGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkZmluZE5leHROb2RlID0gZnVuY3Rpb24gRnJhZ21lbnQkZmluZE5leHROb2RlKCBpdGVtICkge1xuXHRcdHZhciBpbmRleCA9IGl0ZW0uaW5kZXgsXG5cdFx0XHRub2RlO1xuXHRcdGlmICggdGhpcy5pdGVtc1sgaW5kZXggKyAxIF0gKSB7XG5cdFx0XHRub2RlID0gdGhpcy5pdGVtc1sgaW5kZXggKyAxIF0uZmlyc3ROb2RlKCk7XG5cdFx0fSBlbHNlIGlmICggdGhpcy5vd25lciA9PT0gdGhpcy5yb290ICkge1xuXHRcdFx0aWYgKCAhdGhpcy5vd25lci5jb21wb25lbnQgKSB7XG5cdFx0XHRcdC8vIFRPRE8gYnV0IHNvbWV0aGluZyBlbHNlIGNvdWxkIGhhdmUgYmVlbiBhcHBlbmRlZCB0b1xuXHRcdFx0XHQvLyB0aGlzLnJvb3QuZWwsIG5vP1xuXHRcdFx0XHRub2RlID0gbnVsbDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5vZGUgPSB0aGlzLm93bmVyLmNvbXBvbmVudC5maW5kTmV4dE5vZGUoKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0bm9kZSA9IHRoaXMub3duZXIuZmluZE5leHROb2RlKCB0aGlzICk7XG5cdFx0fVxuXHRcdHJldHVybiBub2RlO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL2ZpcnN0Tm9kZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCRmaXJzdE5vZGUgPSBmdW5jdGlvbiBGcmFnbWVudCRmaXJzdE5vZGUoKSB7XG5cdFx0aWYgKCB0aGlzLml0ZW1zICYmIHRoaXMuaXRlbXNbIDAgXSApIHtcblx0XHRcdHJldHVybiB0aGlzLml0ZW1zWyAwIF0uZmlyc3ROb2RlKCk7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL2dldE5vZGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkZ2V0Tm9kZSA9IGZ1bmN0aW9uIEZyYWdtZW50JGdldE5vZGUoKSB7XG5cdFx0dmFyIGZyYWdtZW50ID0gdGhpcztcblx0XHRkbyB7XG5cdFx0XHRpZiAoIGZyYWdtZW50LnBFbGVtZW50ICkge1xuXHRcdFx0XHRyZXR1cm4gZnJhZ21lbnQucEVsZW1lbnQubm9kZTtcblx0XHRcdH1cblx0XHR9IHdoaWxlICggZnJhZ21lbnQgPSBmcmFnbWVudC5wYXJlbnQgKTtcblx0XHRyZXR1cm4gdGhpcy5yb290LmRldGFjaGVkIHx8IHRoaXMucm9vdC5lbDtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS9nZXRWYWx1ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCRnZXRWYWx1ZSA9IGZ1bmN0aW9uKCBwYXJzZUpTT04gKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIGVtcHR5ID0ge307XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBGcmFnbWVudCRnZXRWYWx1ZSgpIHtcblx0XHRcdHZhciBvcHRpb25zID0gYXJndW1lbnRzWyAwIF07XG5cdFx0XHRpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApXG5cdFx0XHRcdG9wdGlvbnMgPSBlbXB0eTtcblx0XHRcdHZhciBhc0FyZ3MsIHZhbHVlcywgc291cmNlLCBwYXJzZWQsIGNhY2hlZFJlc3VsdCwgZGlydHlGbGFnLCByZXN1bHQ7XG5cdFx0XHRhc0FyZ3MgPSBvcHRpb25zLmFyZ3M7XG5cdFx0XHRjYWNoZWRSZXN1bHQgPSBhc0FyZ3MgPyAnYXJnc0xpc3QnIDogJ3ZhbHVlJztcblx0XHRcdGRpcnR5RmxhZyA9IGFzQXJncyA/ICdkaXJ0eUFyZ3MnIDogJ2RpcnR5VmFsdWUnO1xuXHRcdFx0aWYgKCB0aGlzWyBkaXJ0eUZsYWcgXSApIHtcblx0XHRcdFx0c291cmNlID0gcHJvY2Vzc0l0ZW1zKCB0aGlzLml0ZW1zLCB2YWx1ZXMgPSB7fSwgdGhpcy5yb290Ll9ndWlkICk7XG5cdFx0XHRcdHBhcnNlZCA9IHBhcnNlSlNPTiggYXNBcmdzID8gJ1snICsgc291cmNlICsgJ10nIDogc291cmNlLCB2YWx1ZXMgKTtcblx0XHRcdFx0aWYgKCAhcGFyc2VkICkge1xuXHRcdFx0XHRcdHJlc3VsdCA9IGFzQXJncyA/IFsgdGhpcy50b1N0cmluZygpIF0gOiB0aGlzLnRvU3RyaW5nKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzdWx0ID0gcGFyc2VkLnZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXNbIGNhY2hlZFJlc3VsdCBdID0gcmVzdWx0O1xuXHRcdFx0XHR0aGlzWyBkaXJ0eUZsYWcgXSA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXNbIGNhY2hlZFJlc3VsdCBdO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBwcm9jZXNzSXRlbXMoIGl0ZW1zLCB2YWx1ZXMsIGd1aWQsIGNvdW50ZXIgKSB7XG5cdFx0XHRjb3VudGVyID0gY291bnRlciB8fCAwO1xuXHRcdFx0cmV0dXJuIGl0ZW1zLm1hcCggZnVuY3Rpb24oIGl0ZW0gKSB7XG5cdFx0XHRcdHZhciBwbGFjZWhvbGRlcklkLCB3cmFwcGVkLCB2YWx1ZTtcblx0XHRcdFx0aWYgKCBpdGVtLnRleHQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGl0ZW0udGV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGl0ZW0uZnJhZ21lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBpdGVtLmZyYWdtZW50cy5tYXAoIGZ1bmN0aW9uKCBmcmFnbWVudCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBwcm9jZXNzSXRlbXMoIGZyYWdtZW50Lml0ZW1zLCB2YWx1ZXMsIGd1aWQsIGNvdW50ZXIgKTtcblx0XHRcdFx0XHR9ICkuam9pbiggJycgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwbGFjZWhvbGRlcklkID0gZ3VpZCArICctJyArIGNvdW50ZXIrKztcblx0XHRcdFx0aWYgKCB3cmFwcGVkID0gaXRlbS5yb290LnZpZXdtb2RlbC53cmFwcGVkWyBpdGVtLmtleXBhdGggXSApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHdyYXBwZWQudmFsdWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBpdGVtLmdldFZhbHVlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFsdWVzWyBwbGFjZWhvbGRlcklkIF0gPSB2YWx1ZTtcblx0XHRcdFx0cmV0dXJuICckeycgKyBwbGFjZWhvbGRlcklkICsgJ30nO1xuXHRcdFx0fSApLmpvaW4oICcnICk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggcGFyc2VKU09OICk7XG5cblx0LyogdXRpbHMvZXNjYXBlSHRtbC5qcyAqL1xuXHR2YXIgZXNjYXBlSHRtbCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIGxlc3NUaGFuID0gLzwvZztcblx0XHR2YXIgZ3JlYXRlclRoYW4gPSAvPi9nO1xuXHRcdHZhciBhbXAgPSAvJi9nO1xuXHRcdHJldHVybiBmdW5jdGlvbiBlc2NhcGVIdG1sKCBzdHIgKSB7XG5cdFx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoIGFtcCwgJyZhbXA7JyApLnJlcGxhY2UoIGxlc3NUaGFuLCAnJmx0OycgKS5yZXBsYWNlKCBncmVhdGVyVGhhbiwgJyZndDsnICk7XG5cdFx0fTtcblx0fSgpO1xuXG5cdC8qIHV0aWxzL2RldGFjaE5vZGUuanMgKi9cblx0dmFyIGRldGFjaE5vZGUgPSBmdW5jdGlvbiBkZXRhY2hOb2RlKCBub2RlICkge1xuXHRcdGlmICggbm9kZSAmJiBub2RlLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIG5vZGUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvZGV0YWNoLmpzICovXG5cdHZhciBkZXRhY2ggPSBmdW5jdGlvbiggZGV0YWNoTm9kZSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBkZXRhY2hOb2RlKCB0aGlzLm5vZGUgKTtcblx0XHR9O1xuXHR9KCBkZXRhY2hOb2RlICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9UZXh0LmpzICovXG5cdHZhciBUZXh0ID0gZnVuY3Rpb24oIHR5cGVzLCBlc2NhcGVIdG1sLCBkZXRhY2ggKSB7XG5cblx0XHR2YXIgVGV4dCA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0dGhpcy50eXBlID0gdHlwZXMuVEVYVDtcblx0XHRcdHRoaXMudGV4dCA9IG9wdGlvbnMudGVtcGxhdGU7XG5cdFx0fTtcblx0XHRUZXh0LnByb3RvdHlwZSA9IHtcblx0XHRcdGRldGFjaDogZGV0YWNoLFxuXHRcdFx0Zmlyc3ROb2RlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMubm9kZTtcblx0XHRcdH0sXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICF0aGlzLm5vZGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5ub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoIHRoaXMudGV4dCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLm5vZGU7XG5cdFx0XHR9LFxuXHRcdFx0dG9TdHJpbmc6IGZ1bmN0aW9uKCBlc2NhcGUgKSB7XG5cdFx0XHRcdHJldHVybiBlc2NhcGUgPyBlc2NhcGVIdG1sKCB0aGlzLnRleHQgKSA6IHRoaXMudGV4dDtcblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oIHNob3VsZERlc3Ryb3kgKSB7XG5cdFx0XHRcdGlmICggc2hvdWxkRGVzdHJveSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5kZXRhY2goKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIFRleHQ7XG5cdH0oIHR5cGVzLCBlc2NhcGVIdG1sLCBkZXRhY2ggKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC91bmJpbmQuanMgKi9cblx0dmFyIHVuYmluZCA9IGZ1bmN0aW9uIHVuYmluZCgpIHtcblx0XHRpZiAoIHRoaXMucmVnaXN0ZXJlZCApIHtcblx0XHRcdC8vIHRoaXMgd2FzIHJlZ2lzdGVyZWQgYXMgYSBkZXBlbmRhbnRcblx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwudW5yZWdpc3RlciggdGhpcy5rZXlwYXRoLCB0aGlzICk7XG5cdFx0fVxuXHRcdGlmICggdGhpcy5yZXNvbHZlciApIHtcblx0XHRcdHRoaXMucmVzb2x2ZXIudW5iaW5kKCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL011c3RhY2hlL2dldFZhbHVlLmpzICovXG5cdHZhciBnZXRWYWx1ZSA9IGZ1bmN0aW9uIE11c3RhY2hlJGdldFZhbHVlKCkge1xuXHRcdHJldHVybiB0aGlzLnZhbHVlO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL3V0aWxzL3N0YXJ0c1dpdGhLZXlwYXRoLmpzICovXG5cdHZhciBzdGFydHNXaXRoS2V5cGF0aCA9IGZ1bmN0aW9uIHN0YXJ0c1dpdGhLZXlwYXRoKCB0YXJnZXQsIGtleXBhdGggKSB7XG5cdFx0cmV0dXJuIHRhcmdldCAmJiBrZXlwYXRoICYmIHRhcmdldC5zdWJzdHIoIDAsIGtleXBhdGgubGVuZ3RoICsgMSApID09PSBrZXlwYXRoICsgJy4nO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL3V0aWxzL2dldE5ld0tleXBhdGguanMgKi9cblx0dmFyIGdldE5ld0tleXBhdGggPSBmdW5jdGlvbiggc3RhcnRzV2l0aEtleXBhdGggKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0TmV3S2V5cGF0aCggdGFyZ2V0S2V5cGF0aCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdC8vIGV4YWN0IG1hdGNoXG5cdFx0XHRpZiAoIHRhcmdldEtleXBhdGggPT09IG9sZEtleXBhdGggKSB7XG5cdFx0XHRcdHJldHVybiBuZXdLZXlwYXRoICE9PSB1bmRlZmluZWQgPyBuZXdLZXlwYXRoIDogbnVsbDtcblx0XHRcdH1cblx0XHRcdC8vIHBhcnRpYWwgbWF0Y2ggYmFzZWQgb24gbGVhZGluZyBrZXlwYXRoIHNlZ21lbnRzXG5cdFx0XHRpZiAoIHN0YXJ0c1dpdGhLZXlwYXRoKCB0YXJnZXRLZXlwYXRoLCBvbGRLZXlwYXRoICkgKSB7XG5cdFx0XHRcdHJldHVybiBuZXdLZXlwYXRoID09PSBudWxsID8gbmV3S2V5cGF0aCA6IHRhcmdldEtleXBhdGgucmVwbGFjZSggb2xkS2V5cGF0aCArICcuJywgbmV3S2V5cGF0aCArICcuJyApO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIHN0YXJ0c1dpdGhLZXlwYXRoICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvUmVzb2x2ZXJzL1JlZmVyZW5jZVJlc29sdmVyLmpzICovXG5cdHZhciBSZWZlcmVuY2VSZXNvbHZlciA9IGZ1bmN0aW9uKCBydW5sb29wLCByZXNvbHZlUmVmLCBnZXROZXdLZXlwYXRoICkge1xuXG5cdFx0dmFyIFJlZmVyZW5jZVJlc29sdmVyID0gZnVuY3Rpb24oIG93bmVyLCByZWYsIGNhbGxiYWNrICkge1xuXHRcdFx0dmFyIGtleXBhdGg7XG5cdFx0XHR0aGlzLnJlZiA9IHJlZjtcblx0XHRcdHRoaXMucmVzb2x2ZWQgPSBmYWxzZTtcblx0XHRcdHRoaXMucm9vdCA9IG93bmVyLnJvb3Q7XG5cdFx0XHR0aGlzLnBhcmVudEZyYWdtZW50ID0gb3duZXIucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0XHRrZXlwYXRoID0gcmVzb2x2ZVJlZiggb3duZXIucm9vdCwgcmVmLCBvd25lci5wYXJlbnRGcmFnbWVudCApO1xuXHRcdFx0aWYgKCBrZXlwYXRoICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMucmVzb2x2ZSgga2V5cGF0aCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cnVubG9vcC5hZGRVbnJlc29sdmVkKCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRSZWZlcmVuY2VSZXNvbHZlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRyZXNvbHZlOiBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0dGhpcy5yZXNvbHZlZCA9IHRydWU7XG5cdFx0XHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG5cdFx0XHRcdHRoaXMuY2FsbGJhY2soIGtleXBhdGggKTtcblx0XHRcdH0sXG5cdFx0XHRmb3JjZVJlc29sdXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnJlc29sdmUoIHRoaXMucmVmICk7XG5cdFx0XHR9LFxuXHRcdFx0cmViaW5kOiBmdW5jdGlvbiggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdFx0XHR2YXIga2V5cGF0aDtcblx0XHRcdFx0aWYgKCB0aGlzLmtleXBhdGggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRrZXlwYXRoID0gZ2V0TmV3S2V5cGF0aCggdGhpcy5rZXlwYXRoLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHRcdFx0Ly8gd2FzIGEgbmV3IGtleXBhdGggY3JlYXRlZD9cblx0XHRcdFx0XHRpZiAoIGtleXBhdGggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdC8vIHJlc29sdmUgaXRcblx0XHRcdFx0XHRcdHRoaXMucmVzb2x2ZSgga2V5cGF0aCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVuYmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIXRoaXMucmVzb2x2ZWQgKSB7XG5cdFx0XHRcdFx0cnVubG9vcC5yZW1vdmVVbnJlc29sdmVkKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBSZWZlcmVuY2VSZXNvbHZlcjtcblx0fSggcnVubG9vcCwgcmVzb2x2ZVJlZiwgZ2V0TmV3S2V5cGF0aCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL1Jlc29sdmVycy9TcGVjaWFsUmVzb2x2ZXIuanMgKi9cblx0dmFyIFNwZWNpYWxSZXNvbHZlciA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIFNwZWNpYWxSZXNvbHZlciA9IGZ1bmN0aW9uKCBvd25lciwgcmVmLCBjYWxsYmFjayApIHtcblx0XHRcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBvd25lci5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHRoaXMucmVmID0gcmVmO1xuXHRcdFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXHRcdFx0dGhpcy5yZWJpbmQoKTtcblx0XHR9O1xuXHRcdFNwZWNpYWxSZXNvbHZlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRyZWJpbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcmVmID0gdGhpcy5yZWYsXG5cdFx0XHRcdFx0ZnJhZ21lbnQgPSB0aGlzLnBhcmVudEZyYWdtZW50O1xuXHRcdFx0XHRpZiAoIHJlZiA9PT0gJ0BrZXlwYXRoJyApIHtcblx0XHRcdFx0XHR3aGlsZSAoIGZyYWdtZW50ICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhIWZyYWdtZW50LmNvbnRleHQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmNhbGxiYWNrKCAnQCcgKyBmcmFnbWVudC5jb250ZXh0ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRmcmFnbWVudCA9IGZyYWdtZW50LnBhcmVudDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCByZWYgPT09ICdAaW5kZXgnIHx8IHJlZiA9PT0gJ0BrZXknICkge1xuXHRcdFx0XHRcdHdoaWxlICggZnJhZ21lbnQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGZyYWdtZW50LmluZGV4ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmNhbGxiYWNrKCAnQCcgKyBmcmFnbWVudC5pbmRleCApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZnJhZ21lbnQgPSBmcmFnbWVudC5wYXJlbnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1Vua25vd24gc3BlY2lhbCByZWZlcmVuY2UgXCInICsgcmVmICsgJ1wiIC0gdmFsaWQgcmVmZXJlbmNlcyBhcmUgQGluZGV4LCBAa2V5IGFuZCBAa2V5cGF0aCcgKTtcblx0XHRcdH0sXG5cdFx0XHR1bmJpbmQ6IGZ1bmN0aW9uKCkge31cblx0XHR9O1xuXHRcdHJldHVybiBTcGVjaWFsUmVzb2x2ZXI7XG5cdH0oKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC9SZXNvbHZlcnMvSW5kZXhSZXNvbHZlci5qcyAqL1xuXHR2YXIgSW5kZXhSZXNvbHZlciA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIEluZGV4UmVzb2x2ZXIgPSBmdW5jdGlvbiggb3duZXIsIHJlZiwgY2FsbGJhY2sgKSB7XG5cdFx0XHR0aGlzLnBhcmVudEZyYWdtZW50ID0gb3duZXIucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHR0aGlzLnJlZiA9IHJlZjtcblx0XHRcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRcdHRoaXMucmViaW5kKCk7XG5cdFx0fTtcblx0XHRJbmRleFJlc29sdmVyLnByb3RvdHlwZSA9IHtcblx0XHRcdHJlYmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciByZWYgPSB0aGlzLnJlZixcblx0XHRcdFx0XHRpbmRleFJlZnMgPSB0aGlzLnBhcmVudEZyYWdtZW50LmluZGV4UmVmcyxcblx0XHRcdFx0XHRpbmRleCA9IGluZGV4UmVmc1sgcmVmIF07XG5cdFx0XHRcdGlmICggaW5kZXggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0aGlzLmNhbGxiYWNrKCAnQCcgKyBpbmRleCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dW5iaW5kOiBmdW5jdGlvbigpIHt9XG5cdFx0fTtcblx0XHRyZXR1cm4gSW5kZXhSZXNvbHZlcjtcblx0fSgpO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL1Jlc29sdmVycy9jcmVhdGVSZWZlcmVuY2VSZXNvbHZlci5qcyAqL1xuXHR2YXIgY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIgPSBmdW5jdGlvbiggUmVmZXJlbmNlUmVzb2x2ZXIsIFNwZWNpYWxSZXNvbHZlciwgSW5kZXhSZXNvbHZlciApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBjcmVhdGVSZWZlcmVuY2VSZXNvbHZlciggb3duZXIsIHJlZiwgY2FsbGJhY2sgKSB7XG5cdFx0XHR2YXIgaW5kZXhSZWZzLCBpbmRleDtcblx0XHRcdGlmICggcmVmLmNoYXJBdCggMCApID09PSAnQCcgKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgU3BlY2lhbFJlc29sdmVyKCBvd25lciwgcmVmLCBjYWxsYmFjayApO1xuXHRcdFx0fVxuXHRcdFx0aW5kZXhSZWZzID0gb3duZXIucGFyZW50RnJhZ21lbnQuaW5kZXhSZWZzO1xuXHRcdFx0aWYgKCBpbmRleFJlZnMgJiYgKCBpbmRleCA9IGluZGV4UmVmc1sgcmVmIF0gKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IEluZGV4UmVzb2x2ZXIoIG93bmVyLCByZWYsIGNhbGxiYWNrICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbmV3IFJlZmVyZW5jZVJlc29sdmVyKCBvd25lciwgcmVmLCBjYWxsYmFjayApO1xuXHRcdH07XG5cdH0oIFJlZmVyZW5jZVJlc29sdmVyLCBTcGVjaWFsUmVzb2x2ZXIsIEluZGV4UmVzb2x2ZXIgKTtcblxuXHQvKiBzaGFyZWQvZ2V0RnVuY3Rpb25Gcm9tU3RyaW5nLmpzICovXG5cdHZhciBnZXRGdW5jdGlvbkZyb21TdHJpbmcgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBjYWNoZSA9IHt9O1xuXHRcdHJldHVybiBmdW5jdGlvbiBnZXRGdW5jdGlvbkZyb21TdHJpbmcoIHN0ciwgaSApIHtcblx0XHRcdHZhciBmbiwgYXJncztcblx0XHRcdGlmICggY2FjaGVbIHN0ciBdICkge1xuXHRcdFx0XHRyZXR1cm4gY2FjaGVbIHN0ciBdO1xuXHRcdFx0fVxuXHRcdFx0YXJncyA9IFtdO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGFyZ3NbIGkgXSA9ICdfJyArIGk7XG5cdFx0XHR9XG5cdFx0XHRmbiA9IG5ldyBGdW5jdGlvbiggYXJncy5qb2luKCAnLCcgKSwgJ3JldHVybignICsgc3RyICsgJyknICk7XG5cdFx0XHRjYWNoZVsgc3RyIF0gPSBmbjtcblx0XHRcdHJldHVybiBmbjtcblx0XHR9O1xuXHR9KCk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvUmVzb2x2ZXJzL0V4cHJlc3Npb25SZXNvbHZlci5qcyAqL1xuXHR2YXIgRXhwcmVzc2lvblJlc29sdmVyID0gZnVuY3Rpb24oIGRlZmluZVByb3BlcnR5LCBpc051bWVyaWMsIGNyZWF0ZVJlZmVyZW5jZVJlc29sdmVyLCBnZXRGdW5jdGlvbkZyb21TdHJpbmcgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIEV4cHJlc3Npb25SZXNvbHZlciwgYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kO1xuXHRcdEV4cHJlc3Npb25SZXNvbHZlciA9IGZ1bmN0aW9uKCBvd25lciwgcGFyZW50RnJhZ21lbnQsIGV4cHJlc3Npb24sIGNhbGxiYWNrICkge1xuXHRcdFx0dmFyIHJlc29sdmVyID0gdGhpcyxcblx0XHRcdFx0cmFjdGl2ZSwgaW5kZXhSZWZzO1xuXHRcdFx0cmFjdGl2ZSA9IG93bmVyLnJvb3Q7XG5cdFx0XHRyZXNvbHZlci5yb290ID0gcmFjdGl2ZTtcblx0XHRcdHJlc29sdmVyLnBhcmVudEZyYWdtZW50ID0gcGFyZW50RnJhZ21lbnQ7XG5cdFx0XHRyZXNvbHZlci5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXHRcdFx0cmVzb2x2ZXIub3duZXIgPSBvd25lcjtcblx0XHRcdHJlc29sdmVyLnN0ciA9IGV4cHJlc3Npb24ucztcblx0XHRcdHJlc29sdmVyLmtleXBhdGhzID0gW107XG5cdFx0XHRpbmRleFJlZnMgPSBwYXJlbnRGcmFnbWVudC5pbmRleFJlZnM7XG5cdFx0XHQvLyBDcmVhdGUgcmVzb2x2ZXJzIGZvciBlYWNoIHJlZmVyZW5jZVxuXHRcdFx0cmVzb2x2ZXIucGVuZGluZyA9IGV4cHJlc3Npb24uci5sZW5ndGg7XG5cdFx0XHRyZXNvbHZlci5yZWZSZXNvbHZlcnMgPSBleHByZXNzaW9uLnIubWFwKCBmdW5jdGlvbiggcmVmLCBpICkge1xuXHRcdFx0XHRyZXR1cm4gY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIoIHJlc29sdmVyLCByZWYsIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdHJlc29sdmVyLnJlc29sdmUoIGksIGtleXBhdGggKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fSApO1xuXHRcdFx0cmVzb2x2ZXIucmVhZHkgPSB0cnVlO1xuXHRcdFx0cmVzb2x2ZXIuYnViYmxlKCk7XG5cdFx0fTtcblx0XHRFeHByZXNzaW9uUmVzb2x2ZXIucHJvdG90eXBlID0ge1xuXHRcdFx0YnViYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhdGhpcy5yZWFkeSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy51bmlxdWVTdHJpbmcgPSBnZXRVbmlxdWVTdHJpbmcoIHRoaXMuc3RyLCB0aGlzLmtleXBhdGhzICk7XG5cdFx0XHRcdHRoaXMua2V5cGF0aCA9IGdldEtleXBhdGgoIHRoaXMudW5pcXVlU3RyaW5nICk7XG5cdFx0XHRcdHRoaXMuY3JlYXRlRXZhbHVhdG9yKCk7XG5cdFx0XHRcdHRoaXMuY2FsbGJhY2soIHRoaXMua2V5cGF0aCApO1xuXHRcdFx0fSxcblx0XHRcdHVuYmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciByZXNvbHZlcjtcblx0XHRcdFx0d2hpbGUgKCByZXNvbHZlciA9IHRoaXMucmVmUmVzb2x2ZXJzLnBvcCgpICkge1xuXHRcdFx0XHRcdHJlc29sdmVyLnVuYmluZCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cmVzb2x2ZTogZnVuY3Rpb24oIGluZGV4LCBrZXlwYXRoICkge1xuXHRcdFx0XHR0aGlzLmtleXBhdGhzWyBpbmRleCBdID0ga2V5cGF0aDtcblx0XHRcdFx0dGhpcy5idWJibGUoKTtcblx0XHRcdH0sXG5cdFx0XHRjcmVhdGVFdmFsdWF0b3I6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0XHRcdGNvbXB1dGF0aW9uLCB2YWx1ZUdldHRlcnMsIHNpZ25hdHVyZSwga2V5cGF0aCwgZm47XG5cdFx0XHRcdGNvbXB1dGF0aW9uID0gdGhpcy5yb290LnZpZXdtb2RlbC5jb21wdXRhdGlvbnNbIHRoaXMua2V5cGF0aCBdO1xuXHRcdFx0XHQvLyBvbmx5IGlmIGl0IGRvZXNuJ3QgZXhpc3QgeWV0IVxuXHRcdFx0XHRpZiAoICFjb21wdXRhdGlvbiApIHtcblx0XHRcdFx0XHRmbiA9IGdldEZ1bmN0aW9uRnJvbVN0cmluZyggdGhpcy5zdHIsIHRoaXMucmVmUmVzb2x2ZXJzLmxlbmd0aCApO1xuXHRcdFx0XHRcdHZhbHVlR2V0dGVycyA9IHRoaXMua2V5cGF0aHMubWFwKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRcdHZhciB2YWx1ZTtcblx0XHRcdFx0XHRcdGlmICgga2V5cGF0aCA9PT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gJ3NwZWNpYWwnIGtleXBhdGhzIGVuY29kZSBhIHZhbHVlXG5cdFx0XHRcdFx0XHRpZiAoIGtleXBhdGhbIDAgXSA9PT0gJ0AnICkge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGtleXBhdGguc2xpY2UoIDEgKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGlzTnVtZXJpYyggdmFsdWUgKSA/IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiArdmFsdWU7XG5cdFx0XHRcdFx0XHRcdH0gOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB2YWx1ZSA9IHRoaXMkMC5yb290LnZpZXdtb2RlbC5nZXQoIGtleXBhdGggKTtcblx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFsdWUgPSB3cmFwRnVuY3Rpb24oIHZhbHVlLCBzZWxmLnJvb3QgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRzaWduYXR1cmUgPSB7XG5cdFx0XHRcdFx0XHRkZXBzOiB0aGlzLmtleXBhdGhzLmZpbHRlciggaXNWYWxpZERlcGVuZGVuY3kgKSxcblx0XHRcdFx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBhcmdzID0gdmFsdWVHZXR0ZXJzLm1hcCggY2FsbCApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZm4uYXBwbHkoIG51bGwsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGNvbXB1dGF0aW9uID0gdGhpcy5yb290LnZpZXdtb2RlbC5jb21wdXRlKCB0aGlzLmtleXBhdGgsIHNpZ25hdHVyZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwubWFyayggdGhpcy5rZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRyZWJpbmQ6IGZ1bmN0aW9uKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHRcdC8vIFRPRE8gb25seSBidWJibGUgb25jZSwgbm8gbWF0dGVyIGhvdyBtYW55IHJlZmVyZW5jZXMgYXJlIGFmZmVjdGVkIGJ5IHRoZSByZWJpbmRcblx0XHRcdFx0dGhpcy5yZWZSZXNvbHZlcnMuZm9yRWFjaCggZnVuY3Rpb24oIHIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHIucmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0X19leHBvcnQgPSBFeHByZXNzaW9uUmVzb2x2ZXI7XG5cblx0XHRmdW5jdGlvbiBjYWxsKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZS5jYWxsKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0VW5pcXVlU3RyaW5nKCBzdHIsIGtleXBhdGhzICkge1xuXHRcdFx0Ly8gZ2V0IHN0cmluZyB0aGF0IGlzIHVuaXF1ZSB0byB0aGlzIGV4cHJlc3Npb25cblx0XHRcdHJldHVybiBzdHIucmVwbGFjZSggL18oWzAtOV0rKS9nLCBmdW5jdGlvbiggbWF0Y2gsICQxICkge1xuXHRcdFx0XHR2YXIga2V5cGF0aCwgdmFsdWU7XG5cdFx0XHRcdGtleXBhdGggPSBrZXlwYXRoc1sgJDEgXTtcblx0XHRcdFx0aWYgKCBrZXlwYXRoID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuICd1bmRlZmluZWQnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICgga2V5cGF0aFsgMCBdID09PSAnQCcgKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBrZXlwYXRoLnNsaWNlKCAxICk7XG5cdFx0XHRcdFx0cmV0dXJuIGlzTnVtZXJpYyggdmFsdWUgKSA/IHZhbHVlIDogJ1wiJyArIHZhbHVlICsgJ1wiJztcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ga2V5cGF0aDtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRLZXlwYXRoKCB1bmlxdWVTdHJpbmcgKSB7XG5cdFx0XHQvLyBTYW5pdGl6ZSBieSByZW1vdmluZyBhbnkgcGVyaW9kcyBvciBzcXVhcmUgYnJhY2tldHMuIE90aGVyd2lzZVxuXHRcdFx0Ly8gd2UgY2FuJ3Qgc3BsaXQgdGhlIGtleXBhdGggaW50byBrZXlzIVxuXHRcdFx0cmV0dXJuICckeycgKyB1bmlxdWVTdHJpbmcucmVwbGFjZSggL1tcXC5cXFtcXF1dL2csICctJyApICsgJ30nO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzVmFsaWREZXBlbmRlbmN5KCBrZXlwYXRoICkge1xuXHRcdFx0cmV0dXJuIGtleXBhdGggIT09IHVuZGVmaW5lZCAmJiBrZXlwYXRoWyAwIF0gIT09ICdAJztcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB3cmFwRnVuY3Rpb24oIGZuLCByYWN0aXZlICkge1xuXHRcdFx0dmFyIHdyYXBwZWQsIHByb3AsIGtleTtcblx0XHRcdGlmICggZm4uX25vV3JhcCApIHtcblx0XHRcdFx0cmV0dXJuIGZuO1xuXHRcdFx0fVxuXHRcdFx0cHJvcCA9ICdfX3JhY3RpdmVfJyArIHJhY3RpdmUuX2d1aWQ7XG5cdFx0XHR3cmFwcGVkID0gZm5bIHByb3AgXTtcblx0XHRcdGlmICggd3JhcHBlZCApIHtcblx0XHRcdFx0cmV0dXJuIHdyYXBwZWQ7XG5cdFx0XHR9IGVsc2UgaWYgKCAvdGhpcy8udGVzdCggZm4udG9TdHJpbmcoKSApICkge1xuXHRcdFx0XHRkZWZpbmVQcm9wZXJ0eSggZm4sIHByb3AsIHtcblx0XHRcdFx0XHR2YWx1ZTogYmluZC5jYWxsKCBmbiwgcmFjdGl2ZSApXG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0Ly8gQWRkIHByb3BlcnRpZXMvbWV0aG9kcyB0byB3cmFwcGVkIGZ1bmN0aW9uXG5cdFx0XHRcdGZvciAoIGtleSBpbiBmbiApIHtcblx0XHRcdFx0XHRpZiAoIGZuLmhhc093blByb3BlcnR5KCBrZXkgKSApIHtcblx0XHRcdFx0XHRcdGZuWyBwcm9wIF1bIGtleSBdID0gZm5bIGtleSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZm5bIHByb3AgXTtcblx0XHRcdH1cblx0XHRcdGRlZmluZVByb3BlcnR5KCBmbiwgJ19fcmFjdGl2ZV9ub3dyYXAnLCB7XG5cdFx0XHRcdHZhbHVlOiBmblxuXHRcdFx0fSApO1xuXHRcdFx0cmV0dXJuIGZuLl9fcmFjdGl2ZV9ub3dyYXA7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggZGVmaW5lUHJvcGVydHksIGlzTnVtZXJpYywgY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIsIGdldEZ1bmN0aW9uRnJvbVN0cmluZywgbGVnYWN5ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvUmVzb2x2ZXJzL1JlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlci9NZW1iZXJSZXNvbHZlci5qcyAqL1xuXHR2YXIgTWVtYmVyUmVzb2x2ZXIgPSBmdW5jdGlvbiggdHlwZXMsIGNyZWF0ZVJlZmVyZW5jZVJlc29sdmVyLCBFeHByZXNzaW9uUmVzb2x2ZXIgKSB7XG5cblx0XHR2YXIgTWVtYmVyUmVzb2x2ZXIgPSBmdW5jdGlvbiggdGVtcGxhdGUsIHJlc29sdmVyLCBwYXJlbnRGcmFnbWVudCApIHtcblx0XHRcdHZhciBtZW1iZXIgPSB0aGlzLFxuXHRcdFx0XHRrZXlwYXRoO1xuXHRcdFx0bWVtYmVyLnJlc29sdmVyID0gcmVzb2x2ZXI7XG5cdFx0XHRtZW1iZXIucm9vdCA9IHJlc29sdmVyLnJvb3Q7XG5cdFx0XHRtZW1iZXIucGFyZW50RnJhZ21lbnQgPSBwYXJlbnRGcmFnbWVudDtcblx0XHRcdG1lbWJlci52aWV3bW9kZWwgPSByZXNvbHZlci5yb290LnZpZXdtb2RlbDtcblx0XHRcdGlmICggdHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0bWVtYmVyLnZhbHVlID0gdGVtcGxhdGU7XG5cdFx0XHR9IGVsc2UgaWYgKCB0ZW1wbGF0ZS50ID09PSB0eXBlcy5SRUZFUkVOQ0UgKSB7XG5cdFx0XHRcdG1lbWJlci5yZWZSZXNvbHZlciA9IGNyZWF0ZVJlZmVyZW5jZVJlc29sdmVyKCB0aGlzLCB0ZW1wbGF0ZS5uLCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRtZW1iZXIucmVzb2x2ZSgga2V5cGF0aCApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRuZXcgRXhwcmVzc2lvblJlc29sdmVyKCByZXNvbHZlciwgcGFyZW50RnJhZ21lbnQsIHRlbXBsYXRlLCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRtZW1iZXIucmVzb2x2ZSgga2V5cGF0aCApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRNZW1iZXJSZXNvbHZlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRyZXNvbHZlOiBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0aWYgKCB0aGlzLmtleXBhdGggKSB7XG5cdFx0XHRcdFx0dGhpcy52aWV3bW9kZWwudW5yZWdpc3RlciggdGhpcy5rZXlwYXRoLCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHRoaXMudmlld21vZGVsLmdldCgga2V5cGF0aCApO1xuXHRcdFx0XHR0aGlzLmJpbmQoKTtcblx0XHRcdFx0dGhpcy5yZXNvbHZlci5idWJibGUoKTtcblx0XHRcdH0sXG5cdFx0XHRiaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy52aWV3bW9kZWwucmVnaXN0ZXIoIHRoaXMua2V5cGF0aCwgdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdHJlYmluZDogZnVuY3Rpb24oIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdFx0aWYgKCB0aGlzLnJlZlJlc29sdmVyICkge1xuXHRcdFx0XHRcdHRoaXMucmVmUmVzb2x2ZXIucmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHNldFZhbHVlOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0dGhpcy5yZXNvbHZlci5idWJibGUoKTtcblx0XHRcdH0sXG5cdFx0XHR1bmJpbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMua2V5cGF0aCApIHtcblx0XHRcdFx0XHR0aGlzLnZpZXdtb2RlbC51bnJlZ2lzdGVyKCB0aGlzLmtleXBhdGgsIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHRoaXMudW5yZXNvbHZlZCApIHtcblx0XHRcdFx0XHR0aGlzLnVucmVzb2x2ZWQudW5iaW5kKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRmb3JjZVJlc29sdXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMucmVmUmVzb2x2ZXIgKSB7XG5cdFx0XHRcdFx0dGhpcy5yZWZSZXNvbHZlci5mb3JjZVJlc29sdXRpb24oKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIE1lbWJlclJlc29sdmVyO1xuXHR9KCB0eXBlcywgY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIsIEV4cHJlc3Npb25SZXNvbHZlciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL1Jlc29sdmVycy9SZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIvUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyLmpzICovXG5cdHZhciBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIgPSBmdW5jdGlvbiggcmVzb2x2ZVJlZiwgUmVmZXJlbmNlUmVzb2x2ZXIsIE1lbWJlclJlc29sdmVyICkge1xuXG5cdFx0dmFyIFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlciA9IGZ1bmN0aW9uKCBtdXN0YWNoZSwgdGVtcGxhdGUsIGNhbGxiYWNrICkge1xuXHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHR2YXIgcmVzb2x2ZXIgPSB0aGlzLFxuXHRcdFx0XHRyYWN0aXZlLCByZWYsIGtleXBhdGgsIHBhcmVudEZyYWdtZW50O1xuXHRcdFx0cmVzb2x2ZXIucGFyZW50RnJhZ21lbnQgPSBwYXJlbnRGcmFnbWVudCA9IG11c3RhY2hlLnBhcmVudEZyYWdtZW50O1xuXHRcdFx0cmVzb2x2ZXIucm9vdCA9IHJhY3RpdmUgPSBtdXN0YWNoZS5yb290O1xuXHRcdFx0cmVzb2x2ZXIubXVzdGFjaGUgPSBtdXN0YWNoZTtcblx0XHRcdHJlc29sdmVyLnJlZiA9IHJlZiA9IHRlbXBsYXRlLnI7XG5cdFx0XHRyZXNvbHZlci5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXHRcdFx0cmVzb2x2ZXIudW5yZXNvbHZlZCA9IFtdO1xuXHRcdFx0Ly8gRmluZCBiYXNlIGtleXBhdGhcblx0XHRcdGlmICgga2V5cGF0aCA9IHJlc29sdmVSZWYoIHJhY3RpdmUsIHJlZiwgcGFyZW50RnJhZ21lbnQgKSApIHtcblx0XHRcdFx0cmVzb2x2ZXIuYmFzZSA9IGtleXBhdGg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXNvbHZlci5iYXNlUmVzb2x2ZXIgPSBuZXcgUmVmZXJlbmNlUmVzb2x2ZXIoIHRoaXMsIHJlZiwgZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZXIuYmFzZSA9IGtleXBhdGg7XG5cdFx0XHRcdFx0cmVzb2x2ZXIuYmFzZVJlc29sdmVyID0gbnVsbDtcblx0XHRcdFx0XHRyZXNvbHZlci5idWJibGUoKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gRmluZCB2YWx1ZXMgZm9yIG1lbWJlcnMsIG9yIG1hcmsgdGhlbSBhcyB1bnJlc29sdmVkXG5cdFx0XHRyZXNvbHZlci5tZW1iZXJzID0gdGVtcGxhdGUubS5tYXAoIGZ1bmN0aW9uKCB0ZW1wbGF0ZSApIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBNZW1iZXJSZXNvbHZlciggdGVtcGxhdGUsIHRoaXMkMCwgcGFyZW50RnJhZ21lbnQgKTtcblx0XHRcdH0gKTtcblx0XHRcdHJlc29sdmVyLnJlYWR5ID0gdHJ1ZTtcblx0XHRcdHJlc29sdmVyLmJ1YmJsZSgpO1xuXHRcdH07XG5cdFx0UmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyLnByb3RvdHlwZSA9IHtcblx0XHRcdGdldEtleXBhdGg6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgdmFsdWVzID0gdGhpcy5tZW1iZXJzLm1hcCggZ2V0VmFsdWUgKTtcblx0XHRcdFx0aWYgKCAhdmFsdWVzLmV2ZXJ5KCBpc0RlZmluZWQgKSB8fCB0aGlzLmJhc2VSZXNvbHZlciApIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5iYXNlICsgJy4nICsgdmFsdWVzLmpvaW4oICcuJyApO1xuXHRcdFx0fSxcblx0XHRcdGJ1YmJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIXRoaXMucmVhZHkgfHwgdGhpcy5iYXNlUmVzb2x2ZXIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuY2FsbGJhY2soIHRoaXMuZ2V0S2V5cGF0aCgpICk7XG5cdFx0XHR9LFxuXHRcdFx0dW5iaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5tZW1iZXJzLmZvckVhY2goIHVuYmluZCApO1xuXHRcdFx0fSxcblx0XHRcdHJlYmluZDogZnVuY3Rpb24oIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIGNoYW5nZWQ7XG5cdFx0XHRcdHRoaXMubWVtYmVycy5mb3JFYWNoKCBmdW5jdGlvbiggbWVtYmVycyApIHtcblx0XHRcdFx0XHRpZiAoIG1lbWJlcnMucmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSApIHtcblx0XHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRpZiAoIGNoYW5nZWQgKSB7XG5cdFx0XHRcdFx0dGhpcy5idWJibGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGZvcmNlUmVzb2x1dGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy5iYXNlUmVzb2x2ZXIgKSB7XG5cdFx0XHRcdFx0dGhpcy5iYXNlID0gdGhpcy5yZWY7XG5cdFx0XHRcdFx0dGhpcy5iYXNlUmVzb2x2ZXIudW5iaW5kKCk7XG5cdFx0XHRcdFx0dGhpcy5iYXNlUmVzb2x2ZXIgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMubWVtYmVycy5mb3JFYWNoKCBmdW5jdGlvbiggbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbS5mb3JjZVJlc29sdXRpb24oKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0XHR0aGlzLmJ1YmJsZSgpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBnZXRWYWx1ZSggbWVtYmVyICkge1xuXHRcdFx0cmV0dXJuIG1lbWJlci52YWx1ZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc0RlZmluZWQoIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlICE9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1bmJpbmQoIG1lbWJlciApIHtcblx0XHRcdG1lbWJlci51bmJpbmQoKTtcblx0XHR9XG5cdFx0cmV0dXJuIFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlcjtcblx0fSggcmVzb2x2ZVJlZiwgUmVmZXJlbmNlUmVzb2x2ZXIsIE1lbWJlclJlc29sdmVyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvTXVzdGFjaGUvaW5pdGlhbGlzZS5qcyAqL1xuXHR2YXIgaW5pdGlhbGlzZSA9IGZ1bmN0aW9uKCB0eXBlcywgY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIsIFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlciwgRXhwcmVzc2lvblJlc29sdmVyICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIE11c3RhY2hlJGluaXQoIG11c3RhY2hlLCBvcHRpb25zICkge1xuXHRcdFx0dmFyIHJlZiwgcGFyZW50RnJhZ21lbnQsIHRlbXBsYXRlO1xuXHRcdFx0cGFyZW50RnJhZ21lbnQgPSBvcHRpb25zLnBhcmVudEZyYWdtZW50O1xuXHRcdFx0dGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuXHRcdFx0bXVzdGFjaGUucm9vdCA9IHBhcmVudEZyYWdtZW50LnJvb3Q7XG5cdFx0XHRtdXN0YWNoZS5wYXJlbnRGcmFnbWVudCA9IHBhcmVudEZyYWdtZW50O1xuXHRcdFx0bXVzdGFjaGUucEVsZW1lbnQgPSBwYXJlbnRGcmFnbWVudC5wRWxlbWVudDtcblx0XHRcdG11c3RhY2hlLnRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcblx0XHRcdG11c3RhY2hlLmluZGV4ID0gb3B0aW9ucy5pbmRleCB8fCAwO1xuXHRcdFx0bXVzdGFjaGUuaXNTdGF0aWMgPSBvcHRpb25zLnRlbXBsYXRlLnM7XG5cdFx0XHRtdXN0YWNoZS50eXBlID0gb3B0aW9ucy50ZW1wbGF0ZS50O1xuXHRcdFx0bXVzdGFjaGUucmVnaXN0ZXJlZCA9IGZhbHNlO1xuXHRcdFx0Ly8gaWYgdGhpcyBpcyBhIHNpbXBsZSBtdXN0YWNoZSwgd2l0aCBhIHJlZmVyZW5jZSwgd2UganVzdCBuZWVkIHRvIHJlc29sdmVcblx0XHRcdC8vIHRoZSByZWZlcmVuY2UgdG8gYSBrZXlwYXRoXG5cdFx0XHRpZiAoIHJlZiA9IHRlbXBsYXRlLnIgKSB7XG5cdFx0XHRcdG11c3RhY2hlLnJlc29sdmVyID0gbmV3IGNyZWF0ZVJlZmVyZW5jZVJlc29sdmVyKCBtdXN0YWNoZSwgcmVmLCByZXNvbHZlICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBpZiBpdCdzIGFuIGV4cHJlc3Npb24sIHdlIGhhdmUgYSBiaXQgbW9yZSB3b3JrIHRvIGRvXG5cdFx0XHRpZiAoIG9wdGlvbnMudGVtcGxhdGUueCApIHtcblx0XHRcdFx0bXVzdGFjaGUucmVzb2x2ZXIgPSBuZXcgRXhwcmVzc2lvblJlc29sdmVyKCBtdXN0YWNoZSwgcGFyZW50RnJhZ21lbnQsIG9wdGlvbnMudGVtcGxhdGUueCwgcmVzb2x2ZUFuZFJlYmluZENoaWxkcmVuICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG9wdGlvbnMudGVtcGxhdGUucnggKSB7XG5cdFx0XHRcdG11c3RhY2hlLnJlc29sdmVyID0gbmV3IFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlciggbXVzdGFjaGUsIG9wdGlvbnMudGVtcGxhdGUucngsIHJlc29sdmVBbmRSZWJpbmRDaGlsZHJlbiApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gaW52ZXJ0ZWQgc2VjdGlvbnNcblx0XHRcdGlmICggbXVzdGFjaGUudGVtcGxhdGUubiA9PT0gdHlwZXMuU0VDVElPTl9VTkxFU1MgJiYgIW11c3RhY2hlLmhhc093blByb3BlcnR5KCAndmFsdWUnICkgKSB7XG5cdFx0XHRcdG11c3RhY2hlLnNldFZhbHVlKCB1bmRlZmluZWQgKTtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gcmVzb2x2ZSgga2V5cGF0aCApIHtcblx0XHRcdFx0bXVzdGFjaGUucmVzb2x2ZSgga2V5cGF0aCApO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiByZXNvbHZlQW5kUmViaW5kQ2hpbGRyZW4oIG5ld0tleXBhdGggKSB7XG5cdFx0XHRcdHZhciBvbGRLZXlwYXRoID0gbXVzdGFjaGUua2V5cGF0aDtcblx0XHRcdFx0aWYgKCBuZXdLZXlwYXRoICE9PSBvbGRLZXlwYXRoICkge1xuXHRcdFx0XHRcdG11c3RhY2hlLnJlc29sdmUoIG5ld0tleXBhdGggKTtcblx0XHRcdFx0XHRpZiAoIG9sZEtleXBhdGggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdG11c3RhY2hlLmZyYWdtZW50cyAmJiBtdXN0YWNoZS5mcmFnbWVudHMuZm9yRWFjaCggZnVuY3Rpb24oIGYgKSB7XG5cdFx0XHRcdFx0XHRcdGYucmViaW5kKCBudWxsLCBudWxsLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggdHlwZXMsIGNyZWF0ZVJlZmVyZW5jZVJlc29sdmVyLCBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIsIEV4cHJlc3Npb25SZXNvbHZlciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL011c3RhY2hlL3Jlc29sdmUuanMgKi9cblx0dmFyIHJlc29sdmUgPSBmdW5jdGlvbiggaXNOdW1lcmljICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIE11c3RhY2hlJHJlc29sdmUoIGtleXBhdGggKSB7XG5cdFx0XHR2YXIgd2FzUmVzb2x2ZWQsIHZhbHVlLCB0d293YXlCaW5kaW5nO1xuXHRcdFx0Ly8gJ1NwZWNpYWwnIGtleXBhdGhzLCBlLmcuIEBmb28gb3IgQDcsIGVuY29kZSBhIHZhbHVlXG5cdFx0XHRpZiAoIGtleXBhdGggJiYga2V5cGF0aFsgMCBdID09PSAnQCcgKSB7XG5cdFx0XHRcdHZhbHVlID0ga2V5cGF0aC5zbGljZSggMSApO1xuXHRcdFx0XHRpZiAoIGlzTnVtZXJpYyggdmFsdWUgKSApIHtcblx0XHRcdFx0XHR2YWx1ZSA9ICt2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuXHRcdFx0XHR0aGlzLnNldFZhbHVlKCB2YWx1ZSApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvLyBJZiB3ZSByZXNvbHZlZCBwcmV2aW91c2x5LCB3ZSBuZWVkIHRvIHVucmVnaXN0ZXJcblx0XHRcdGlmICggdGhpcy5yZWdpc3RlcmVkICkge1xuXHRcdFx0XHQvLyB1bmRlZmluZWQgb3IgbnVsbFxuXHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnVucmVnaXN0ZXIoIHRoaXMua2V5cGF0aCwgdGhpcyApO1xuXHRcdFx0XHR0aGlzLnJlZ2lzdGVyZWQgPSBmYWxzZTtcblx0XHRcdFx0d2FzUmVzb2x2ZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcblx0XHRcdC8vIElmIHRoZSBuZXcga2V5cGF0aCBleGlzdHMsIHdlIG5lZWQgdG8gcmVnaXN0ZXJcblx0XHRcdC8vIHdpdGggdGhlIHZpZXdtb2RlbFxuXHRcdFx0aWYgKCBrZXlwYXRoICE9IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0Ly8gdW5kZWZpbmVkIG9yIG51bGxcblx0XHRcdFx0dmFsdWUgPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldCgga2V5cGF0aCApO1xuXHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnJlZ2lzdGVyKCBrZXlwYXRoLCB0aGlzICk7XG5cdFx0XHRcdHRoaXMucmVnaXN0ZXJlZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHQvLyBFaXRoZXIgd2F5IHdlIG5lZWQgdG8gcXVldWUgdXAgYSByZW5kZXIgKGB2YWx1ZWBcblx0XHRcdC8vIHdpbGwgYmUgYHVuZGVmaW5lZGAgaWYgdGhlcmUncyBubyBrZXlwYXRoKVxuXHRcdFx0dGhpcy5zZXRWYWx1ZSggdmFsdWUgKTtcblx0XHRcdC8vIFR3by13YXkgYmluZGluZ3MgbmVlZCB0byBwb2ludCB0byB0aGVpciBuZXcgdGFyZ2V0IGtleXBhdGhcblx0XHRcdGlmICggd2FzUmVzb2x2ZWQgJiYgKCB0d293YXlCaW5kaW5nID0gdGhpcy50d293YXlCaW5kaW5nICkgKSB7XG5cdFx0XHRcdHR3b3dheUJpbmRpbmcucmVib3VuZCgpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIGlzTnVtZXJpYyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL011c3RhY2hlL3JlYmluZC5qcyAqL1xuXHR2YXIgcmViaW5kID0gZnVuY3Rpb24gTXVzdGFjaGUkcmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0Ly8gQ2hpbGRyZW4gZmlyc3Rcblx0XHRpZiAoIHRoaXMuZnJhZ21lbnRzICkge1xuXHRcdFx0dGhpcy5mcmFnbWVudHMuZm9yRWFjaCggZnVuY3Rpb24oIGYgKSB7XG5cdFx0XHRcdHJldHVybiBmLnJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdC8vIEV4cHJlc3Npb24gbXVzdGFjaGU/XG5cdFx0aWYgKCB0aGlzLnJlc29sdmVyICkge1xuXHRcdFx0dGhpcy5yZXNvbHZlci5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC9NdXN0YWNoZS9fTXVzdGFjaGUuanMgKi9cblx0dmFyIE11c3RhY2hlID0gZnVuY3Rpb24oIGdldFZhbHVlLCBpbml0LCByZXNvbHZlLCByZWJpbmQgKSB7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0Z2V0VmFsdWU6IGdldFZhbHVlLFxuXHRcdFx0aW5pdDogaW5pdCxcblx0XHRcdHJlc29sdmU6IHJlc29sdmUsXG5cdFx0XHRyZWJpbmQ6IHJlYmluZFxuXHRcdH07XG5cdH0oIGdldFZhbHVlLCBpbml0aWFsaXNlLCByZXNvbHZlLCByZWJpbmQgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0ludGVycG9sYXRvci5qcyAqL1xuXHR2YXIgSW50ZXJwb2xhdG9yID0gZnVuY3Rpb24oIHR5cGVzLCBydW5sb29wLCBlc2NhcGVIdG1sLCBkZXRhY2hOb2RlLCBpc0VxdWFsLCB1bmJpbmQsIE11c3RhY2hlLCBkZXRhY2ggKSB7XG5cblx0XHR2YXIgSW50ZXJwb2xhdG9yID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLnR5cGUgPSB0eXBlcy5JTlRFUlBPTEFUT1I7XG5cdFx0XHRNdXN0YWNoZS5pbml0KCB0aGlzLCBvcHRpb25zICk7XG5cdFx0fTtcblx0XHRJbnRlcnBvbGF0b3IucHJvdG90eXBlID0ge1xuXHRcdFx0dXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5ub2RlLmRhdGEgPSB0aGlzLnZhbHVlID09IHVuZGVmaW5lZCA/ICcnIDogdGhpcy52YWx1ZTtcblx0XHRcdH0sXG5cdFx0XHRyZXNvbHZlOiBNdXN0YWNoZS5yZXNvbHZlLFxuXHRcdFx0cmViaW5kOiBNdXN0YWNoZS5yZWJpbmQsXG5cdFx0XHRkZXRhY2g6IGRldGFjaCxcblx0XHRcdHVuYmluZDogdW5iaW5kLFxuXHRcdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhdGhpcy5ub2RlICkge1xuXHRcdFx0XHRcdHRoaXMubm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCB0aGlzLnZhbHVlICE9IHVuZGVmaW5lZCA/IHRoaXMudmFsdWUgOiAnJyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLm5vZGU7XG5cdFx0XHR9LFxuXHRcdFx0dW5yZW5kZXI6IGZ1bmN0aW9uKCBzaG91bGREZXN0cm95ICkge1xuXHRcdFx0XHRpZiAoIHNob3VsZERlc3Ryb3kgKSB7XG5cdFx0XHRcdFx0ZGV0YWNoTm9kZSggdGhpcy5ub2RlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRnZXRWYWx1ZTogTXVzdGFjaGUuZ2V0VmFsdWUsXG5cdFx0XHQvLyBURU1QXG5cdFx0XHRzZXRWYWx1ZTogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgd3JhcHBlcjtcblx0XHRcdFx0Ly8gVE9ETyBpcyB0aGVyZSBhIGJldHRlciB3YXkgdG8gYXBwcm9hY2ggdGhpcz9cblx0XHRcdFx0aWYgKCB3cmFwcGVyID0gdGhpcy5yb290LnZpZXdtb2RlbC53cmFwcGVkWyB0aGlzLmtleXBhdGggXSApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHdyYXBwZXIuZ2V0KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhaXNFcXVhbCggdmFsdWUsIHRoaXMudmFsdWUgKSApIHtcblx0XHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudC5idWJibGUoKTtcblx0XHRcdFx0XHRpZiAoIHRoaXMubm9kZSApIHtcblx0XHRcdFx0XHRcdHJ1bmxvb3AuYWRkVmlldyggdGhpcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGZpcnN0Tm9kZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLm5vZGU7XG5cdFx0XHR9LFxuXHRcdFx0dG9TdHJpbmc6IGZ1bmN0aW9uKCBlc2NhcGUgKSB7XG5cdFx0XHRcdHZhciBzdHJpbmcgPSB0aGlzLnZhbHVlICE9IHVuZGVmaW5lZCA/ICcnICsgdGhpcy52YWx1ZSA6ICcnO1xuXHRcdFx0XHRyZXR1cm4gZXNjYXBlID8gZXNjYXBlSHRtbCggc3RyaW5nICkgOiBzdHJpbmc7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gSW50ZXJwb2xhdG9yO1xuXHR9KCB0eXBlcywgcnVubG9vcCwgZXNjYXBlSHRtbCwgZGV0YWNoTm9kZSwgaXNFcXVhbCwgdW5iaW5kLCBNdXN0YWNoZSwgZGV0YWNoICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9idWJibGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRidWJibGUgPSBmdW5jdGlvbiBTZWN0aW9uJGJ1YmJsZSgpIHtcblx0XHR0aGlzLnBhcmVudEZyYWdtZW50LmJ1YmJsZSgpO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9wcm90b3R5cGUvZGV0YWNoLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZGV0YWNoID0gZnVuY3Rpb24gU2VjdGlvbiRkZXRhY2goKSB7XG5cdFx0dmFyIGRvY0ZyYWc7XG5cdFx0aWYgKCB0aGlzLmZyYWdtZW50cy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudHNbIDAgXS5kZXRhY2goKTtcblx0XHR9XG5cdFx0ZG9jRnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHR0aGlzLmZyYWdtZW50cy5mb3JFYWNoKCBmdW5jdGlvbiggaXRlbSApIHtcblx0XHRcdGRvY0ZyYWcuYXBwZW5kQ2hpbGQoIGl0ZW0uZGV0YWNoKCkgKTtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIGRvY0ZyYWc7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9maW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZmluZCA9IGZ1bmN0aW9uIFNlY3Rpb24kZmluZCggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksIGxlbiwgcXVlcnlSZXN1bHQ7XG5cdFx0bGVuID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoO1xuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRpZiAoIHF1ZXJ5UmVzdWx0ID0gdGhpcy5mcmFnbWVudHNbIGkgXS5maW5kKCBzZWxlY3RvciApICkge1xuXHRcdFx0XHRyZXR1cm4gcXVlcnlSZXN1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9wcm90b3R5cGUvZmluZEFsbC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGZpbmRBbGwgPSBmdW5jdGlvbiBTZWN0aW9uJGZpbmRBbGwoIHNlbGVjdG9yLCBxdWVyeSApIHtcblx0XHR2YXIgaSwgbGVuO1xuXHRcdGxlbiA9IHRoaXMuZnJhZ21lbnRzLmxlbmd0aDtcblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0dGhpcy5mcmFnbWVudHNbIGkgXS5maW5kQWxsKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9maW5kQWxsQ29tcG9uZW50cy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGZpbmRBbGxDb21wb25lbnRzID0gZnVuY3Rpb24gU2VjdGlvbiRmaW5kQWxsQ29tcG9uZW50cyggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuXHRcdHZhciBpLCBsZW47XG5cdFx0bGVuID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoO1xuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHR0aGlzLmZyYWdtZW50c1sgaSBdLmZpbmRBbGxDb21wb25lbnRzKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9maW5kQ29tcG9uZW50LmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZmluZENvbXBvbmVudCA9IGZ1bmN0aW9uIFNlY3Rpb24kZmluZENvbXBvbmVudCggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksIGxlbiwgcXVlcnlSZXN1bHQ7XG5cdFx0bGVuID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoO1xuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRpZiAoIHF1ZXJ5UmVzdWx0ID0gdGhpcy5mcmFnbWVudHNbIGkgXS5maW5kQ29tcG9uZW50KCBzZWxlY3RvciApICkge1xuXHRcdFx0XHRyZXR1cm4gcXVlcnlSZXN1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9wcm90b3R5cGUvZmluZE5leHROb2RlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZmluZE5leHROb2RlID0gZnVuY3Rpb24gU2VjdGlvbiRmaW5kTmV4dE5vZGUoIGZyYWdtZW50ICkge1xuXHRcdGlmICggdGhpcy5mcmFnbWVudHNbIGZyYWdtZW50LmluZGV4ICsgMSBdICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnRzWyBmcmFnbWVudC5pbmRleCArIDEgXS5maXJzdE5vZGUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKCB0aGlzICk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9maXJzdE5vZGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRmaXJzdE5vZGUgPSBmdW5jdGlvbiBTZWN0aW9uJGZpcnN0Tm9kZSgpIHtcblx0XHR2YXIgbGVuLCBpLCBub2RlO1xuXHRcdGlmICggbGVuID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoICkge1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0aWYgKCBub2RlID0gdGhpcy5mcmFnbWVudHNbIGkgXS5maXJzdE5vZGUoKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbm9kZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUoIHRoaXMgKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vcHJvdG90eXBlL3NodWZmbGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRzaHVmZmxlID0gZnVuY3Rpb24oIHR5cGVzLCBydW5sb29wLCBjaXJjdWxhciApIHtcblxuXHRcdHZhciBGcmFnbWVudDtcblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdEZyYWdtZW50ID0gY2lyY3VsYXIuRnJhZ21lbnQ7XG5cdFx0fSApO1xuXHRcdHJldHVybiBmdW5jdGlvbiBTZWN0aW9uJHNodWZmbGUoIG5ld0luZGljZXMgKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdHZhciBzZWN0aW9uID0gdGhpcyxcblx0XHRcdFx0cGFyZW50RnJhZ21lbnQsIGZpcnN0Q2hhbmdlLCBpLCBuZXdMZW5ndGgsIHJlYm91bmRGcmFnbWVudHMsIGZyYWdtZW50T3B0aW9ucywgZnJhZ21lbnQ7XG5cdFx0XHQvLyBzaG9ydCBjaXJjdWl0IGFueSBkb3VibGUtdXBkYXRlcywgYW5kIGVuc3VyZSB0aGF0IHRoaXMgaXNuJ3QgYXBwbGllZCB0b1xuXHRcdFx0Ly8gbm9uLWxpc3Qgc2VjdGlvbnNcblx0XHRcdGlmICggdGhpcy5zaHVmZmxpbmcgfHwgdGhpcy51bmJvdW5kIHx8IHRoaXMuc3VidHlwZSAmJiB0aGlzLnN1YnR5cGUgIT09IHR5cGVzLlNFQ1RJT05fRUFDSCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5zaHVmZmxpbmcgPSB0cnVlO1xuXHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcyQwLnNodWZmbGluZyA9IGZhbHNlO1xuXHRcdFx0fSApO1xuXHRcdFx0cGFyZW50RnJhZ21lbnQgPSB0aGlzLnBhcmVudEZyYWdtZW50O1xuXHRcdFx0cmVib3VuZEZyYWdtZW50cyA9IFtdO1xuXHRcdFx0Ly8gZmlyc3QsIHJlYmluZCBleGlzdGluZyBmcmFnbWVudHNcblx0XHRcdG5ld0luZGljZXMuZm9yRWFjaCggZnVuY3Rpb24gcmViaW5kSWZOZWNlc3NhcnkoIG5ld0luZGV4LCBvbGRJbmRleCApIHtcblx0XHRcdFx0dmFyIGZyYWdtZW50LCBieSwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aDtcblx0XHRcdFx0aWYgKCBuZXdJbmRleCA9PT0gb2xkSW5kZXggKSB7XG5cdFx0XHRcdFx0cmVib3VuZEZyYWdtZW50c1sgbmV3SW5kZXggXSA9IHNlY3Rpb24uZnJhZ21lbnRzWyBvbGRJbmRleCBdO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRmcmFnbWVudCA9IHNlY3Rpb24uZnJhZ21lbnRzWyBvbGRJbmRleCBdO1xuXHRcdFx0XHRpZiAoIGZpcnN0Q2hhbmdlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0Zmlyc3RDaGFuZ2UgPSBvbGRJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBkb2VzIHRoaXMgZnJhZ21lbnQgbmVlZCB0byBiZSB0b3JuIGRvd24/XG5cdFx0XHRcdGlmICggbmV3SW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlci5wdXNoKCBmcmFnbWVudCApO1xuXHRcdFx0XHRcdGZyYWdtZW50LnVuYmluZCgpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIGl0IG5lZWRzIHRvIGJlIHJlYm91bmQgdG8gYSBuZXcgaW5kZXhcblx0XHRcdFx0YnkgPSBuZXdJbmRleCAtIG9sZEluZGV4O1xuXHRcdFx0XHRvbGRLZXlwYXRoID0gc2VjdGlvbi5rZXlwYXRoICsgJy4nICsgb2xkSW5kZXg7XG5cdFx0XHRcdG5ld0tleXBhdGggPSBzZWN0aW9uLmtleXBhdGggKyAnLicgKyBuZXdJbmRleDtcblx0XHRcdFx0ZnJhZ21lbnQucmViaW5kKCBzZWN0aW9uLnRlbXBsYXRlLmksIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHRcdGZyYWdtZW50LmluZGV4ID0gbmV3SW5kZXg7XG5cdFx0XHRcdHJlYm91bmRGcmFnbWVudHNbIG5ld0luZGV4IF0gPSBmcmFnbWVudDtcblx0XHRcdH0gKTtcblx0XHRcdG5ld0xlbmd0aCA9IHRoaXMucm9vdC5nZXQoIHRoaXMua2V5cGF0aCApLmxlbmd0aDtcblx0XHRcdC8vIElmIG5vdGhpbmcgY2hhbmdlZCB3aXRoIHRoZSBleGlzdGluZyBmcmFnbWVudHMsIHRoZW4gd2Ugc3RhcnQgYWRkaW5nXG5cdFx0XHQvLyBuZXcgZnJhZ21lbnRzIGF0IHRoZSBlbmQuLi5cblx0XHRcdGlmICggZmlyc3RDaGFuZ2UgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0Ly8gLi4udW5sZXNzIHRoZXJlIGFyZSBubyBuZXcgZnJhZ21lbnRzIHRvIGFkZFxuXHRcdFx0XHRpZiAoIHRoaXMubGVuZ3RoID09PSBuZXdMZW5ndGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZpcnN0Q2hhbmdlID0gdGhpcy5sZW5ndGg7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmxlbmd0aCA9IHRoaXMuZnJhZ21lbnRzLmxlbmd0aCA9IG5ld0xlbmd0aDtcblx0XHRcdGlmICggdGhpcy5yZW5kZXJlZCApIHtcblx0XHRcdFx0cnVubG9vcC5hZGRWaWV3KCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBQcmVwYXJlIG5ldyBmcmFnbWVudCBvcHRpb25zXG5cdFx0XHRmcmFnbWVudE9wdGlvbnMgPSB7XG5cdFx0XHRcdHRlbXBsYXRlOiB0aGlzLnRlbXBsYXRlLmYsXG5cdFx0XHRcdHJvb3Q6IHRoaXMucm9vdCxcblx0XHRcdFx0b3duZXI6IHRoaXNcblx0XHRcdH07XG5cdFx0XHRpZiAoIHRoaXMudGVtcGxhdGUuaSApIHtcblx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zLmluZGV4UmVmID0gdGhpcy50ZW1wbGF0ZS5pO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQWRkIGFzIG1hbnkgbmV3IGZyYWdtZW50cyBhcyB3ZSBuZWVkIHRvLCBvciBhZGQgYmFjayBleGlzdGluZ1xuXHRcdFx0Ly8gKGRldGFjaGVkKSBmcmFnbWVudHNcblx0XHRcdGZvciAoIGkgPSBmaXJzdENoYW5nZTsgaSA8IG5ld0xlbmd0aDsgaSArPSAxICkge1xuXHRcdFx0XHRmcmFnbWVudCA9IHJlYm91bmRGcmFnbWVudHNbIGkgXTtcblx0XHRcdFx0aWYgKCAhZnJhZ21lbnQgKSB7XG5cdFx0XHRcdFx0dGhpcy5mcmFnbWVudHNUb0NyZWF0ZS5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5mcmFnbWVudHNbIGkgXSA9IGZyYWdtZW50O1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIHR5cGVzLCBydW5sb29wLCBjaXJjdWxhciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9wcm90b3R5cGUvcmVuZGVyLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kcmVuZGVyID0gZnVuY3Rpb24gU2VjdGlvbiRyZW5kZXIoKSB7XG5cdFx0dmFyIGRvY0ZyYWc7XG5cdFx0ZG9jRnJhZyA9IHRoaXMuZG9jRnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuXHRcdHJldHVybiBkb2NGcmFnO1xuXHR9O1xuXG5cdC8qIHV0aWxzL2lzQXJyYXlMaWtlLmpzICovXG5cdHZhciBpc0FycmF5TGlrZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHBhdHRlcm4gPSAvXlxcW29iamVjdCAoPzpBcnJheXxGaWxlTGlzdClcXF0kLyxcblx0XHRcdHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblx0XHRyZXR1cm4gZnVuY3Rpb24gaXNBcnJheUxpa2UoIG9iaiApIHtcblx0XHRcdHJldHVybiBwYXR0ZXJuLnRlc3QoIHRvU3RyaW5nLmNhbGwoIG9iaiApICk7XG5cdFx0fTtcblx0fSgpO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9wcm90b3R5cGUvc2V0VmFsdWUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRzZXRWYWx1ZSA9IGZ1bmN0aW9uKCB0eXBlcywgaXNBcnJheUxpa2UsIGlzT2JqZWN0LCBydW5sb29wLCBjaXJjdWxhciApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgRnJhZ21lbnQ7XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRGcmFnbWVudCA9IGNpcmN1bGFyLkZyYWdtZW50O1xuXHRcdH0gKTtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIFNlY3Rpb24kc2V0VmFsdWUoIHZhbHVlICkge1xuXHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHR2YXIgd3JhcHBlciwgZnJhZ21lbnRPcHRpb25zO1xuXHRcdFx0aWYgKCB0aGlzLnVwZGF0aW5nICkge1xuXHRcdFx0XHQvLyBJZiBhIGNoaWxkIG9mIHRoaXMgc2VjdGlvbiBjYXVzZXMgYSByZS1ldmFsdWF0aW9uIC0gZm9yIGV4YW1wbGUsIGFuXG5cdFx0XHRcdC8vIGV4cHJlc3Npb24gcmVmZXJzIHRvIGEgZnVuY3Rpb24gdGhhdCBtdXRhdGVzIHRoZSBhcnJheSB0aGF0IHRoaXNcblx0XHRcdFx0Ly8gc2VjdGlvbiBkZXBlbmRzIG9uIC0gd2UnbGwgZW5kIHVwIHdpdGggYSBkb3VibGUgcmVuZGVyaW5nIGJ1ZyAoc2VlXG5cdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yYWN0aXZlanMvcmFjdGl2ZS9pc3N1ZXMvNzQ4KS4gVGhpcyBwcmV2ZW50cyBpdC5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy51cGRhdGluZyA9IHRydWU7XG5cdFx0XHQvLyB3aXRoIHNlY3Rpb25zLCB3ZSBuZWVkIHRvIGdldCB0aGUgZmFrZSB2YWx1ZSBpZiB3ZSBoYXZlIGEgd3JhcHBlZCBvYmplY3Rcblx0XHRcdGlmICggd3JhcHBlciA9IHRoaXMucm9vdC52aWV3bW9kZWwud3JhcHBlZFsgdGhpcy5rZXlwYXRoIF0gKSB7XG5cdFx0XHRcdHZhbHVlID0gd3JhcHBlci5nZXQoKTtcblx0XHRcdH1cblx0XHRcdC8vIElmIGFueSBmcmFnbWVudHMgYXJlIGF3YWl0aW5nIGNyZWF0aW9uIGFmdGVyIGEgc3BsaWNlLFxuXHRcdFx0Ly8gdGhpcyBpcyB0aGUgcGxhY2UgdG8gZG8gaXRcblx0XHRcdGlmICggdGhpcy5mcmFnbWVudHNUb0NyZWF0ZS5sZW5ndGggKSB7XG5cdFx0XHRcdGZyYWdtZW50T3B0aW9ucyA9IHtcblx0XHRcdFx0XHR0ZW1wbGF0ZTogdGhpcy50ZW1wbGF0ZS5mLFxuXHRcdFx0XHRcdHJvb3Q6IHRoaXMucm9vdCxcblx0XHRcdFx0XHRwRWxlbWVudDogdGhpcy5wRWxlbWVudCxcblx0XHRcdFx0XHRvd25lcjogdGhpcyxcblx0XHRcdFx0XHRpbmRleFJlZjogdGhpcy50ZW1wbGF0ZS5pXG5cdFx0XHRcdH07XG5cdFx0XHRcdHRoaXMuZnJhZ21lbnRzVG9DcmVhdGUuZm9yRWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0XHRcdHZhciBmcmFnbWVudDtcblx0XHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuY29udGV4dCA9IHRoaXMkMC5rZXlwYXRoICsgJy4nICsgaW5kZXg7XG5cdFx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zLmluZGV4ID0gaW5kZXg7XG5cdFx0XHRcdFx0ZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIGZyYWdtZW50T3B0aW9ucyApO1xuXHRcdFx0XHRcdHRoaXMkMC5mcmFnbWVudHNUb1JlbmRlci5wdXNoKCB0aGlzJDAuZnJhZ21lbnRzWyBpbmRleCBdID0gZnJhZ21lbnQgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0XHR0aGlzLmZyYWdtZW50c1RvQ3JlYXRlLmxlbmd0aCA9IDA7XG5cdFx0XHR9IGVsc2UgaWYgKCByZWV2YWx1YXRlU2VjdGlvbiggdGhpcywgdmFsdWUgKSApIHtcblx0XHRcdFx0dGhpcy5idWJibGUoKTtcblx0XHRcdFx0aWYgKCB0aGlzLnJlbmRlcmVkICkge1xuXHRcdFx0XHRcdHJ1bmxvb3AuYWRkVmlldyggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdFx0XHR0aGlzLnVwZGF0aW5nID0gZmFsc2U7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHJlZXZhbHVhdGVTZWN0aW9uKCBzZWN0aW9uLCB2YWx1ZSApIHtcblx0XHRcdHZhciBmcmFnbWVudE9wdGlvbnMgPSB7XG5cdFx0XHRcdHRlbXBsYXRlOiBzZWN0aW9uLnRlbXBsYXRlLmYsXG5cdFx0XHRcdHJvb3Q6IHNlY3Rpb24ucm9vdCxcblx0XHRcdFx0cEVsZW1lbnQ6IHNlY3Rpb24ucGFyZW50RnJhZ21lbnQucEVsZW1lbnQsXG5cdFx0XHRcdG93bmVyOiBzZWN0aW9uXG5cdFx0XHR9O1xuXHRcdFx0Ly8gSWYgd2UgYWxyZWFkeSBrbm93IHRoZSBzZWN0aW9uIHR5cGUsIGdyZWF0XG5cdFx0XHQvLyBUT0RPIGNhbiB0aGlzIGJlIG9wdGltaXNlZD8gaS5lLiBwaWNrIGFuIHJlZXZhbHVhdGVTZWN0aW9uIGZ1bmN0aW9uIGR1cmluZyBpbml0XG5cdFx0XHQvLyBhbmQgYXZvaWQgZG9pbmcgdGhpcyBlYWNoIHRpbWU/XG5cdFx0XHRpZiAoIHNlY3Rpb24uc3VidHlwZSApIHtcblx0XHRcdFx0c3dpdGNoICggc2VjdGlvbi5zdWJ0eXBlICkge1xuXHRcdFx0XHRcdGNhc2UgdHlwZXMuU0VDVElPTl9JRjpcblx0XHRcdFx0XHRcdHJldHVybiByZWV2YWx1YXRlQ29uZGl0aW9uYWxTZWN0aW9uKCBzZWN0aW9uLCB2YWx1ZSwgZmFsc2UsIGZyYWdtZW50T3B0aW9ucyApO1xuXHRcdFx0XHRcdGNhc2UgdHlwZXMuU0VDVElPTl9VTkxFU1M6XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUNvbmRpdGlvbmFsU2VjdGlvbiggc2VjdGlvbiwgdmFsdWUsIHRydWUsIGZyYWdtZW50T3B0aW9ucyApO1xuXHRcdFx0XHRcdGNhc2UgdHlwZXMuU0VDVElPTl9XSVRIOlxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlZXZhbHVhdGVDb250ZXh0U2VjdGlvbiggc2VjdGlvbiwgZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHRcdFx0Y2FzZSB0eXBlcy5TRUNUSU9OX0lGX1dJVEg6XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUNvbmRpdGlvbmFsQ29udGV4dFNlY3Rpb24oIHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHRcdFx0XHRjYXNlIHR5cGVzLlNFQ1RJT05fRUFDSDpcblx0XHRcdFx0XHRcdGlmICggaXNPYmplY3QoIHZhbHVlICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZWV2YWx1YXRlTGlzdE9iamVjdFNlY3Rpb24oIHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgdG8gd29yayBvdXQgd2hhdCBzb3J0IG9mIHNlY3Rpb24gd2UncmUgZGVhbGluZyB3aXRoXG5cdFx0XHRzZWN0aW9uLm9yZGVyZWQgPSAhIWlzQXJyYXlMaWtlKCB2YWx1ZSApO1xuXHRcdFx0Ly8gT3JkZXJlZCBsaXN0IHNlY3Rpb25cblx0XHRcdGlmICggc2VjdGlvbi5vcmRlcmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUxpc3RTZWN0aW9uKCBzZWN0aW9uLCB2YWx1ZSwgZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBVbm9yZGVyZWQgbGlzdCwgb3IgY29udGV4dFxuXHRcdFx0aWYgKCBpc09iamVjdCggdmFsdWUgKSB8fCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdC8vIEluZGV4IHJlZmVyZW5jZSBpbmRpY2F0ZXMgc2VjdGlvbiBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIGxpc3Rcblx0XHRcdFx0aWYgKCBzZWN0aW9uLnRlbXBsYXRlLmkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlZXZhbHVhdGVMaXN0T2JqZWN0U2VjdGlvbiggc2VjdGlvbiwgdmFsdWUsIGZyYWdtZW50T3B0aW9ucyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgb2JqZWN0IHByb3ZpZGVzIGNvbnRleHQgZm9yIGNvbnRlbnRzXG5cdFx0XHRcdHJldHVybiByZWV2YWx1YXRlQ29udGV4dFNlY3Rpb24oIHNlY3Rpb24sIGZyYWdtZW50T3B0aW9ucyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQ29uZGl0aW9uYWwgc2VjdGlvblxuXHRcdFx0cmV0dXJuIHJlZXZhbHVhdGVDb25kaXRpb25hbFNlY3Rpb24oIHNlY3Rpb24sIHZhbHVlLCBmYWxzZSwgZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVldmFsdWF0ZUxpc3RTZWN0aW9uKCBzZWN0aW9uLCB2YWx1ZSwgZnJhZ21lbnRPcHRpb25zICkge1xuXHRcdFx0dmFyIGksIGxlbmd0aCwgZnJhZ21lbnQ7XG5cdFx0XHRsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cdFx0XHRpZiAoIGxlbmd0aCA9PT0gc2VjdGlvbi5sZW5ndGggKSB7XG5cdFx0XHRcdC8vIE5vdGhpbmcgdG8gZG9cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gaWYgdGhlIGFycmF5IGlzIHNob3J0ZXIgdGhhbiBpdCB3YXMgcHJldmlvdXNseSwgcmVtb3ZlIGl0ZW1zXG5cdFx0XHRpZiAoIGxlbmd0aCA8IHNlY3Rpb24ubGVuZ3RoICkge1xuXHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIgPSBzZWN0aW9uLmZyYWdtZW50cy5zcGxpY2UoIGxlbmd0aCwgc2VjdGlvbi5sZW5ndGggLSBsZW5ndGggKTtcblx0XHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyLmZvckVhY2goIHVuYmluZCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCBsZW5ndGggPiBzZWN0aW9uLmxlbmd0aCApIHtcblx0XHRcdFx0XHQvLyBhZGQgYW55IG5ldyBvbmVzXG5cdFx0XHRcdFx0Zm9yICggaSA9IHNlY3Rpb24ubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEgKSB7XG5cdFx0XHRcdFx0XHQvLyBhcHBlbmQgbGlzdCBpdGVtIHRvIGNvbnRleHQgc3RhY2tcblx0XHRcdFx0XHRcdGZyYWdtZW50T3B0aW9ucy5jb250ZXh0ID0gc2VjdGlvbi5rZXlwYXRoICsgJy4nICsgaTtcblx0XHRcdFx0XHRcdGZyYWdtZW50T3B0aW9ucy5pbmRleCA9IGk7XG5cdFx0XHRcdFx0XHRpZiAoIHNlY3Rpb24udGVtcGxhdGUuaSApIHtcblx0XHRcdFx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zLmluZGV4UmVmID0gc2VjdGlvbi50ZW1wbGF0ZS5pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIGZyYWdtZW50T3B0aW9ucyApO1xuXHRcdFx0XHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1JlbmRlci5wdXNoKCBzZWN0aW9uLmZyYWdtZW50c1sgaSBdID0gZnJhZ21lbnQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHNlY3Rpb24ubGVuZ3RoID0gbGVuZ3RoO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVldmFsdWF0ZUxpc3RPYmplY3RTZWN0aW9uKCBzZWN0aW9uLCB2YWx1ZSwgZnJhZ21lbnRPcHRpb25zICkge1xuXHRcdFx0dmFyIGlkLCBpLCBoYXNLZXksIGZyYWdtZW50LCBjaGFuZ2VkO1xuXHRcdFx0aGFzS2V5ID0gc2VjdGlvbi5oYXNLZXkgfHwgKCBzZWN0aW9uLmhhc0tleSA9IHt9ICk7XG5cdFx0XHQvLyByZW1vdmUgYW55IGZyYWdtZW50cyB0aGF0IHNob3VsZCBubyBsb25nZXIgZXhpc3Rcblx0XHRcdGkgPSBzZWN0aW9uLmZyYWdtZW50cy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0ZnJhZ21lbnQgPSBzZWN0aW9uLmZyYWdtZW50c1sgaSBdO1xuXHRcdFx0XHRpZiAoICEoIGZyYWdtZW50LmluZGV4IGluIHZhbHVlICkgKSB7XG5cdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0ZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0XHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyLnB1c2goIGZyYWdtZW50ICk7XG5cdFx0XHRcdFx0c2VjdGlvbi5mcmFnbWVudHMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0aGFzS2V5WyBmcmFnbWVudC5pbmRleCBdID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIGFkZCBhbnkgdGhhdCBoYXZlbid0IGJlZW4gY3JlYXRlZCB5ZXRcblx0XHRcdGZvciAoIGlkIGluIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICFoYXNLZXlbIGlkIF0gKSB7XG5cdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zLmNvbnRleHQgPSBzZWN0aW9uLmtleXBhdGggKyAnLicgKyBpZDtcblx0XHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXggPSBpZDtcblx0XHRcdFx0XHRpZiAoIHNlY3Rpb24udGVtcGxhdGUuaSApIHtcblx0XHRcdFx0XHRcdGZyYWdtZW50T3B0aW9ucy5pbmRleFJlZiA9IHNlY3Rpb24udGVtcGxhdGUuaTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIGZyYWdtZW50T3B0aW9ucyApO1xuXHRcdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9SZW5kZXIucHVzaCggZnJhZ21lbnQgKTtcblx0XHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50cy5wdXNoKCBmcmFnbWVudCApO1xuXHRcdFx0XHRcdGhhc0tleVsgaWQgXSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHNlY3Rpb24ubGVuZ3RoID0gc2VjdGlvbi5mcmFnbWVudHMubGVuZ3RoO1xuXHRcdFx0cmV0dXJuIGNoYW5nZWQ7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVldmFsdWF0ZUNvbmRpdGlvbmFsQ29udGV4dFNlY3Rpb24oIHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMgKSB7XG5cdFx0XHRpZiAoIHZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUNvbnRleHRTZWN0aW9uKCBzZWN0aW9uLCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiByZW1vdmVTZWN0aW9uRnJhZ21lbnRzKCBzZWN0aW9uICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVldmFsdWF0ZUNvbnRleHRTZWN0aW9uKCBzZWN0aW9uLCBmcmFnbWVudE9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgZnJhZ21lbnQ7XG5cdFx0XHQvLyAuLi50aGVuIGlmIGl0IGlzbid0IHJlbmRlcmVkLCByZW5kZXIgaXQsIGFkZGluZyBzZWN0aW9uLmtleXBhdGggdG8gdGhlIGNvbnRleHQgc3RhY2tcblx0XHRcdC8vIChpZiBpdCBpcyBhbHJlYWR5IHJlbmRlcmVkLCB0aGVuIGFueSBjaGlsZHJlbiBkZXBlbmRlbnQgb24gdGhlIGNvbnRleHQgc3RhY2tcblx0XHRcdC8vIHdpbGwgdXBkYXRlIHRoZW1zZWx2ZXMgd2l0aG91dCBhbnkgcHJvbXB0aW5nKVxuXHRcdFx0aWYgKCAhc2VjdGlvbi5sZW5ndGggKSB7XG5cdFx0XHRcdC8vIGFwcGVuZCB0aGlzIHNlY3Rpb24gdG8gdGhlIGNvbnRleHQgc3RhY2tcblx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zLmNvbnRleHQgPSBzZWN0aW9uLmtleXBhdGg7XG5cdFx0XHRcdGZyYWdtZW50T3B0aW9ucy5pbmRleCA9IDA7XG5cdFx0XHRcdGZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1JlbmRlci5wdXNoKCBzZWN0aW9uLmZyYWdtZW50c1sgMCBdID0gZnJhZ21lbnQgKTtcblx0XHRcdFx0c2VjdGlvbi5sZW5ndGggPSAxO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWV2YWx1YXRlQ29uZGl0aW9uYWxTZWN0aW9uKCBzZWN0aW9uLCB2YWx1ZSwgaW52ZXJ0ZWQsIGZyYWdtZW50T3B0aW9ucyApIHtcblx0XHRcdHZhciBkb1JlbmRlciwgZW1wdHlBcnJheSwgZW1wdHlPYmplY3QsIGZyYWdtZW50LCBuYW1lO1xuXHRcdFx0ZW1wdHlBcnJheSA9IGlzQXJyYXlMaWtlKCB2YWx1ZSApICYmIHZhbHVlLmxlbmd0aCA9PT0gMDtcblx0XHRcdGVtcHR5T2JqZWN0ID0gZmFsc2U7XG5cdFx0XHRpZiAoICFpc0FycmF5TGlrZSggdmFsdWUgKSAmJiBpc09iamVjdCggdmFsdWUgKSApIHtcblx0XHRcdFx0ZW1wdHlPYmplY3QgPSB0cnVlO1xuXHRcdFx0XHRmb3IgKCBuYW1lIGluIHZhbHVlICkge1xuXHRcdFx0XHRcdGVtcHR5T2JqZWN0ID0gZmFsc2U7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggaW52ZXJ0ZWQgKSB7XG5cdFx0XHRcdGRvUmVuZGVyID0gZW1wdHlBcnJheSB8fCBlbXB0eU9iamVjdCB8fCAhdmFsdWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkb1JlbmRlciA9IHZhbHVlICYmICFlbXB0eUFycmF5ICYmICFlbXB0eU9iamVjdDtcblx0XHRcdH1cblx0XHRcdGlmICggZG9SZW5kZXIgKSB7XG5cdFx0XHRcdGlmICggIXNlY3Rpb24ubGVuZ3RoICkge1xuXHRcdFx0XHRcdC8vIG5vIGNoYW5nZSB0byBjb250ZXh0IHN0YWNrXG5cdFx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zLmluZGV4ID0gMDtcblx0XHRcdFx0XHRmcmFnbWVudCA9IG5ldyBGcmFnbWVudCggZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1JlbmRlci5wdXNoKCBzZWN0aW9uLmZyYWdtZW50c1sgMCBdID0gZnJhZ21lbnQgKTtcblx0XHRcdFx0XHRzZWN0aW9uLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBzZWN0aW9uLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyID0gc2VjdGlvbi5mcmFnbWVudHMuc3BsaWNlKCAxICk7XG5cdFx0XHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyLmZvckVhY2goIHVuYmluZCApO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gcmVtb3ZlU2VjdGlvbkZyYWdtZW50cyggc2VjdGlvbiApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlbW92ZVNlY3Rpb25GcmFnbWVudHMoIHNlY3Rpb24gKSB7XG5cdFx0XHRpZiAoIHNlY3Rpb24ubGVuZ3RoICkge1xuXHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIgPSBzZWN0aW9uLmZyYWdtZW50cy5zcGxpY2UoIDAsIHNlY3Rpb24uZnJhZ21lbnRzLmxlbmd0aCApLmZpbHRlciggaXNSZW5kZXJlZCApO1xuXHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIuZm9yRWFjaCggdW5iaW5kICk7XG5cdFx0XHRcdHNlY3Rpb24ubGVuZ3RoID0gc2VjdGlvbi5mcmFnbWVudHNUb1JlbmRlci5sZW5ndGggPSAwO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1bmJpbmQoIGZyYWdtZW50ICkge1xuXHRcdFx0ZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNSZW5kZXJlZCggZnJhZ21lbnQgKSB7XG5cdFx0XHRyZXR1cm4gZnJhZ21lbnQucmVuZGVyZWQ7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggdHlwZXMsIGlzQXJyYXlMaWtlLCBpc09iamVjdCwgcnVubG9vcCwgY2lyY3VsYXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vcHJvdG90eXBlL3RvU3RyaW5nLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kdG9TdHJpbmcgPSBmdW5jdGlvbiBTZWN0aW9uJHRvU3RyaW5nKCBlc2NhcGUgKSB7XG5cdFx0dmFyIHN0ciwgaSwgbGVuO1xuXHRcdHN0ciA9ICcnO1xuXHRcdGkgPSAwO1xuXHRcdGxlbiA9IHRoaXMubGVuZ3RoO1xuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRzdHIgKz0gdGhpcy5mcmFnbWVudHNbIGkgXS50b1N0cmluZyggZXNjYXBlICk7XG5cdFx0fVxuXHRcdHJldHVybiBzdHI7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS91bmJpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiR1bmJpbmQgPSBmdW5jdGlvbiggdW5iaW5kICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gU2VjdGlvbiR1bmJpbmQoKSB7XG5cdFx0XHR0aGlzLmZyYWdtZW50cy5mb3JFYWNoKCB1bmJpbmRGcmFnbWVudCApO1xuXHRcdFx0dW5iaW5kLmNhbGwoIHRoaXMgKTtcblx0XHRcdHRoaXMubGVuZ3RoID0gMDtcblx0XHRcdHRoaXMudW5ib3VuZCA9IHRydWU7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHVuYmluZEZyYWdtZW50KCBmcmFnbWVudCApIHtcblx0XHRcdGZyYWdtZW50LnVuYmluZCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIHVuYmluZCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9wcm90b3R5cGUvdW5yZW5kZXIuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiR1bnJlbmRlciA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gU2VjdGlvbiR1bnJlbmRlciggc2hvdWxkRGVzdHJveSApIHtcblx0XHRcdHRoaXMuZnJhZ21lbnRzLmZvckVhY2goIHNob3VsZERlc3Ryb3kgPyB1bnJlbmRlckFuZERlc3Ryb3kgOiB1bnJlbmRlciApO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiB1bnJlbmRlckFuZERlc3Ryb3koIGZyYWdtZW50ICkge1xuXHRcdFx0ZnJhZ21lbnQudW5yZW5kZXIoIHRydWUgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1bnJlbmRlciggZnJhZ21lbnQgKSB7XG5cdFx0XHRmcmFnbWVudC51bnJlbmRlciggZmFsc2UgKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS91cGRhdGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiR1cGRhdGUgPSBmdW5jdGlvbiBTZWN0aW9uJHVwZGF0ZSgpIHtcblx0XHR2YXIgZnJhZ21lbnQsIHJlbmRlckluZGV4LCByZW5kZXJlZEZyYWdtZW50cywgYW5jaG9yLCB0YXJnZXQsIGksIGxlbjtcblx0XHQvLyBgdGhpcy5yZW5kZXJlZEZyYWdtZW50c2AgaXMgaW4gdGhlIG9yZGVyIG9mIHRoZSBwcmV2aW91cyByZW5kZXIuXG5cdFx0Ly8gSWYgZnJhZ21lbnRzIGhhdmUgc2h1ZmZsZWQgYWJvdXQsIHRoaXMgYWxsb3dzIHVzIHRvIHF1aWNrbHlcblx0XHQvLyByZWluc2VydCB0aGVtIGluIHRoZSBjb3JyZWN0IHBsYWNlXG5cdFx0cmVuZGVyZWRGcmFnbWVudHMgPSB0aGlzLnJlbmRlcmVkRnJhZ21lbnRzO1xuXHRcdC8vIFJlbW92ZSBmcmFnbWVudHMgdGhhdCBoYXZlIGJlZW4gbWFya2VkIGZvciBkZXN0cnVjdGlvblxuXHRcdHdoaWxlICggZnJhZ21lbnQgPSB0aGlzLmZyYWdtZW50c1RvVW5yZW5kZXIucG9wKCkgKSB7XG5cdFx0XHRmcmFnbWVudC51bnJlbmRlciggdHJ1ZSApO1xuXHRcdFx0cmVuZGVyZWRGcmFnbWVudHMuc3BsaWNlKCByZW5kZXJlZEZyYWdtZW50cy5pbmRleE9mKCBmcmFnbWVudCApLCAxICk7XG5cdFx0fVxuXHRcdC8vIFJlbmRlciBuZXcgZnJhZ21lbnRzIChidXQgZG9uJ3QgaW5zZXJ0IHRoZW0geWV0KVxuXHRcdHdoaWxlICggZnJhZ21lbnQgPSB0aGlzLmZyYWdtZW50c1RvUmVuZGVyLnNoaWZ0KCkgKSB7XG5cdFx0XHRmcmFnbWVudC5yZW5kZXIoKTtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLnJlbmRlcmVkICkge1xuXHRcdFx0dGFyZ2V0ID0gdGhpcy5wYXJlbnRGcmFnbWVudC5nZXROb2RlKCk7XG5cdFx0fVxuXHRcdGxlbiA9IHRoaXMuZnJhZ21lbnRzLmxlbmd0aDtcblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0ZnJhZ21lbnQgPSB0aGlzLmZyYWdtZW50c1sgaSBdO1xuXHRcdFx0cmVuZGVySW5kZXggPSByZW5kZXJlZEZyYWdtZW50cy5pbmRleE9mKCBmcmFnbWVudCwgaSApO1xuXHRcdFx0Ly8gc2VhcmNoIGZyb20gY3VycmVudCBpbmRleCAtIGl0J3MgZ3VhcmFudGVlZCB0byBiZSB0aGUgc2FtZSBvciBoaWdoZXJcblx0XHRcdGlmICggcmVuZGVySW5kZXggPT09IGkgKSB7XG5cdFx0XHRcdC8vIGFscmVhZHkgaW4gdGhlIHJpZ2h0IHBsYWNlLiBpbnNlcnQgYWNjdW11bGF0ZWQgbm9kZXMgKGlmIGFueSkgYW5kIGNhcnJ5IG9uXG5cdFx0XHRcdGlmICggdGhpcy5kb2NGcmFnLmNoaWxkTm9kZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdGFuY2hvciA9IGZyYWdtZW50LmZpcnN0Tm9kZSgpO1xuXHRcdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIHRoaXMuZG9jRnJhZywgYW5jaG9yICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmRvY0ZyYWcuYXBwZW5kQ2hpbGQoIGZyYWdtZW50LmRldGFjaCgpICk7XG5cdFx0XHQvLyB1cGRhdGUgcmVuZGVyZWRGcmFnbWVudHNcblx0XHRcdGlmICggcmVuZGVySW5kZXggIT09IC0xICkge1xuXHRcdFx0XHRyZW5kZXJlZEZyYWdtZW50cy5zcGxpY2UoIHJlbmRlckluZGV4LCAxICk7XG5cdFx0XHR9XG5cdFx0XHRyZW5kZXJlZEZyYWdtZW50cy5zcGxpY2UoIGksIDAsIGZyYWdtZW50ICk7XG5cdFx0fVxuXHRcdGlmICggdGhpcy5yZW5kZXJlZCAmJiB0aGlzLmRvY0ZyYWcuY2hpbGROb2Rlcy5sZW5ndGggKSB7XG5cdFx0XHRhbmNob3IgPSB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSggdGhpcyApO1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggdGhpcy5kb2NGcmFnLCBhbmNob3IgKTtcblx0XHR9XG5cdFx0Ly8gU2F2ZSB0aGUgcmVuZGVyaW5nIG9yZGVyIGZvciBuZXh0IHRpbWVcblx0XHR0aGlzLnJlbmRlcmVkRnJhZ21lbnRzID0gdGhpcy5mcmFnbWVudHMuc2xpY2UoKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vX1NlY3Rpb24uanMgKi9cblx0dmFyIFNlY3Rpb24gPSBmdW5jdGlvbiggdHlwZXMsIE11c3RhY2hlLCBidWJibGUsIGRldGFjaCwgZmluZCwgZmluZEFsbCwgZmluZEFsbENvbXBvbmVudHMsIGZpbmRDb21wb25lbnQsIGZpbmROZXh0Tm9kZSwgZmlyc3ROb2RlLCBzaHVmZmxlLCByZW5kZXIsIHNldFZhbHVlLCB0b1N0cmluZywgdW5iaW5kLCB1bnJlbmRlciwgdXBkYXRlICkge1xuXG5cdFx0dmFyIFNlY3Rpb24gPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdHRoaXMudHlwZSA9IHR5cGVzLlNFQ1RJT047XG5cdFx0XHR0aGlzLnN1YnR5cGUgPSBvcHRpb25zLnRlbXBsYXRlLm47XG5cdFx0XHR0aGlzLmludmVydGVkID0gdGhpcy5zdWJ0eXBlID09PSB0eXBlcy5TRUNUSU9OX1VOTEVTUztcblx0XHRcdHRoaXMucEVsZW1lbnQgPSBvcHRpb25zLnBFbGVtZW50O1xuXHRcdFx0dGhpcy5mcmFnbWVudHMgPSBbXTtcblx0XHRcdHRoaXMuZnJhZ21lbnRzVG9DcmVhdGUgPSBbXTtcblx0XHRcdHRoaXMuZnJhZ21lbnRzVG9SZW5kZXIgPSBbXTtcblx0XHRcdHRoaXMuZnJhZ21lbnRzVG9VbnJlbmRlciA9IFtdO1xuXHRcdFx0dGhpcy5yZW5kZXJlZEZyYWdtZW50cyA9IFtdO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAwO1xuXHRcdFx0Ly8gbnVtYmVyIG9mIHRpbWVzIHRoaXMgc2VjdGlvbiBpcyByZW5kZXJlZFxuXHRcdFx0TXVzdGFjaGUuaW5pdCggdGhpcywgb3B0aW9ucyApO1xuXHRcdH07XG5cdFx0U2VjdGlvbi5wcm90b3R5cGUgPSB7XG5cdFx0XHRidWJibGU6IGJ1YmJsZSxcblx0XHRcdGRldGFjaDogZGV0YWNoLFxuXHRcdFx0ZmluZDogZmluZCxcblx0XHRcdGZpbmRBbGw6IGZpbmRBbGwsXG5cdFx0XHRmaW5kQWxsQ29tcG9uZW50czogZmluZEFsbENvbXBvbmVudHMsXG5cdFx0XHRmaW5kQ29tcG9uZW50OiBmaW5kQ29tcG9uZW50LFxuXHRcdFx0ZmluZE5leHROb2RlOiBmaW5kTmV4dE5vZGUsXG5cdFx0XHRmaXJzdE5vZGU6IGZpcnN0Tm9kZSxcblx0XHRcdGdldFZhbHVlOiBNdXN0YWNoZS5nZXRWYWx1ZSxcblx0XHRcdHNodWZmbGU6IHNodWZmbGUsXG5cdFx0XHRyZWJpbmQ6IE11c3RhY2hlLnJlYmluZCxcblx0XHRcdHJlbmRlcjogcmVuZGVyLFxuXHRcdFx0cmVzb2x2ZTogTXVzdGFjaGUucmVzb2x2ZSxcblx0XHRcdHNldFZhbHVlOiBzZXRWYWx1ZSxcblx0XHRcdHRvU3RyaW5nOiB0b1N0cmluZyxcblx0XHRcdHVuYmluZDogdW5iaW5kLFxuXHRcdFx0dW5yZW5kZXI6IHVucmVuZGVyLFxuXHRcdFx0dXBkYXRlOiB1cGRhdGVcblx0XHR9O1xuXHRcdHJldHVybiBTZWN0aW9uO1xuXHR9KCB0eXBlcywgTXVzdGFjaGUsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRidWJibGUsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRkZXRhY2gsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRmaW5kLCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZmluZEFsbCwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGZpbmRBbGxDb21wb25lbnRzLCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZmluZENvbXBvbmVudCwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGZpbmROZXh0Tm9kZSwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGZpcnN0Tm9kZSwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHNodWZmbGUsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRyZW5kZXIsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRzZXRWYWx1ZSwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHRvU3RyaW5nLCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kdW5iaW5kLCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kdW5yZW5kZXIsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiR1cGRhdGUgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1RyaXBsZS9wcm90b3R5cGUvZGV0YWNoLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSRkZXRhY2ggPSBmdW5jdGlvbiBUcmlwbGUkZGV0YWNoKCkge1xuXHRcdHZhciBsZW4sIGk7XG5cdFx0aWYgKCB0aGlzLmRvY0ZyYWcgKSB7XG5cdFx0XHRsZW4gPSB0aGlzLm5vZGVzLmxlbmd0aDtcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRcdHRoaXMuZG9jRnJhZy5hcHBlbmRDaGlsZCggdGhpcy5ub2Rlc1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5kb2NGcmFnO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1RyaXBsZS9wcm90b3R5cGUvZmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkZmluZCA9IGZ1bmN0aW9uKCBtYXRjaGVzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFRyaXBsZSRmaW5kKCBzZWxlY3RvciApIHtcblx0XHRcdHZhciBpLCBsZW4sIG5vZGUsIHF1ZXJ5UmVzdWx0O1xuXHRcdFx0bGVuID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRub2RlID0gdGhpcy5ub2Rlc1sgaSBdO1xuXHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBtYXRjaGVzKCBub2RlLCBzZWxlY3RvciApICkge1xuXHRcdFx0XHRcdHJldHVybiBub2RlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggcXVlcnlSZXN1bHQgPSBub2RlLnF1ZXJ5U2VsZWN0b3IoIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHF1ZXJ5UmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHR9KCBtYXRjaGVzICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9UcmlwbGUvcHJvdG90eXBlL2ZpbmRBbGwuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJGZpbmRBbGwgPSBmdW5jdGlvbiggbWF0Y2hlcyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBUcmlwbGUkZmluZEFsbCggc2VsZWN0b3IsIHF1ZXJ5UmVzdWx0ICkge1xuXHRcdFx0dmFyIGksIGxlbiwgbm9kZSwgcXVlcnlBbGxSZXN1bHQsIG51bU5vZGVzLCBqO1xuXHRcdFx0bGVuID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRub2RlID0gdGhpcy5ub2Rlc1sgaSBdO1xuXHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBtYXRjaGVzKCBub2RlLCBzZWxlY3RvciApICkge1xuXHRcdFx0XHRcdHF1ZXJ5UmVzdWx0LnB1c2goIG5vZGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHF1ZXJ5QWxsUmVzdWx0ID0gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKCBzZWxlY3RvciApICkge1xuXHRcdFx0XHRcdG51bU5vZGVzID0gcXVlcnlBbGxSZXN1bHQubGVuZ3RoO1xuXHRcdFx0XHRcdGZvciAoIGogPSAwOyBqIDwgbnVtTm9kZXM7IGogKz0gMSApIHtcblx0XHRcdFx0XHRcdHF1ZXJ5UmVzdWx0LnB1c2goIHF1ZXJ5QWxsUmVzdWx0WyBqIF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9KCBtYXRjaGVzICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9UcmlwbGUvcHJvdG90eXBlL2ZpcnN0Tm9kZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkZmlyc3ROb2RlID0gZnVuY3Rpb24gVHJpcGxlJGZpcnN0Tm9kZSgpIHtcblx0XHRpZiAoIHRoaXMucmVuZGVyZWQgJiYgdGhpcy5ub2Rlc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuIHRoaXMubm9kZXNbIDAgXTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKCB0aGlzICk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9UcmlwbGUvaGVscGVycy9pbnNlcnRIdG1sLmpzICovXG5cdHZhciBpbnNlcnRIdG1sID0gZnVuY3Rpb24oIG5hbWVzcGFjZXMsIGNyZWF0ZUVsZW1lbnQgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIGVsZW1lbnRDYWNoZSA9IHt9LFxuXHRcdFx0aWVCdWcsIGllQmxhY2tsaXN0O1xuXHRcdHRyeSB7XG5cdFx0XHRjcmVhdGVFbGVtZW50KCAndGFibGUnICkuaW5uZXJIVE1MID0gJ2Zvbyc7XG5cdFx0fSBjYXRjaCAoIGVyciApIHtcblx0XHRcdGllQnVnID0gdHJ1ZTtcblx0XHRcdGllQmxhY2tsaXN0ID0ge1xuXHRcdFx0XHRUQUJMRTogW1xuXHRcdFx0XHRcdCc8dGFibGUgY2xhc3M9XCJ4XCI+Jyxcblx0XHRcdFx0XHQnPC90YWJsZT4nXG5cdFx0XHRcdF0sXG5cdFx0XHRcdFRIRUFEOiBbXG5cdFx0XHRcdFx0Jzx0YWJsZT48dGhlYWQgY2xhc3M9XCJ4XCI+Jyxcblx0XHRcdFx0XHQnPC90aGVhZD48L3RhYmxlPidcblx0XHRcdFx0XSxcblx0XHRcdFx0VEJPRFk6IFtcblx0XHRcdFx0XHQnPHRhYmxlPjx0Ym9keSBjbGFzcz1cInhcIj4nLFxuXHRcdFx0XHRcdCc8L3Rib2R5PjwvdGFibGU+J1xuXHRcdFx0XHRdLFxuXHRcdFx0XHRUUjogW1xuXHRcdFx0XHRcdCc8dGFibGU+PHRyIGNsYXNzPVwieFwiPicsXG5cdFx0XHRcdFx0JzwvdHI+PC90YWJsZT4nXG5cdFx0XHRcdF0sXG5cdFx0XHRcdFNFTEVDVDogW1xuXHRcdFx0XHRcdCc8c2VsZWN0IGNsYXNzPVwieFwiPicsXG5cdFx0XHRcdFx0Jzwvc2VsZWN0Pidcblx0XHRcdFx0XVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiggaHRtbCwgbm9kZSwgZG9jRnJhZyApIHtcblx0XHRcdHZhciBjb250YWluZXIsIG5vZGVzID0gW10sXG5cdFx0XHRcdHdyYXBwZXIsIHNlbGVjdGVkT3B0aW9uLCBjaGlsZCwgaTtcblx0XHRcdC8vIHJlbmRlciAwIGFuZCBmYWxzZVxuXHRcdFx0aWYgKCBodG1sICE9IG51bGwgJiYgaHRtbCAhPT0gJycgKSB7XG5cdFx0XHRcdGlmICggaWVCdWcgJiYgKCB3cmFwcGVyID0gaWVCbGFja2xpc3RbIG5vZGUudGFnTmFtZSBdICkgKSB7XG5cdFx0XHRcdFx0Y29udGFpbmVyID0gZWxlbWVudCggJ0RJVicgKTtcblx0XHRcdFx0XHRjb250YWluZXIuaW5uZXJIVE1MID0gd3JhcHBlclsgMCBdICsgaHRtbCArIHdyYXBwZXJbIDEgXTtcblx0XHRcdFx0XHRjb250YWluZXIgPSBjb250YWluZXIucXVlcnlTZWxlY3RvciggJy54JyApO1xuXHRcdFx0XHRcdGlmICggY29udGFpbmVyLnRhZ05hbWUgPT09ICdTRUxFQ1QnICkge1xuXHRcdFx0XHRcdFx0c2VsZWN0ZWRPcHRpb24gPSBjb250YWluZXIub3B0aW9uc1sgY29udGFpbmVyLnNlbGVjdGVkSW5kZXggXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoIG5vZGUubmFtZXNwYWNlVVJJID09PSBuYW1lc3BhY2VzLnN2ZyApIHtcblx0XHRcdFx0XHRjb250YWluZXIgPSBlbGVtZW50KCAnRElWJyApO1xuXHRcdFx0XHRcdGNvbnRhaW5lci5pbm5lckhUTUwgPSAnPHN2ZyBjbGFzcz1cInhcIj4nICsgaHRtbCArICc8L3N2Zz4nO1xuXHRcdFx0XHRcdGNvbnRhaW5lciA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCAnLngnICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGFpbmVyID0gZWxlbWVudCggbm9kZS50YWdOYW1lICk7XG5cdFx0XHRcdFx0Y29udGFpbmVyLmlubmVySFRNTCA9IGh0bWw7XG5cdFx0XHRcdFx0aWYgKCBjb250YWluZXIudGFnTmFtZSA9PT0gJ1NFTEVDVCcgKSB7XG5cdFx0XHRcdFx0XHRzZWxlY3RlZE9wdGlvbiA9IGNvbnRhaW5lci5vcHRpb25zWyBjb250YWluZXIuc2VsZWN0ZWRJbmRleCBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR3aGlsZSAoIGNoaWxkID0gY29udGFpbmVyLmZpcnN0Q2hpbGQgKSB7XG5cdFx0XHRcdFx0bm9kZXMucHVzaCggY2hpbGQgKTtcblx0XHRcdFx0XHRkb2NGcmFnLmFwcGVuZENoaWxkKCBjaGlsZCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIFRoaXMgaXMgcmVhbGx5IGFubm95aW5nLiBFeHRyYWN0aW5nIDxvcHRpb24+IG5vZGVzIGZyb20gdGhlXG5cdFx0XHRcdC8vIHRlbXBvcmFyeSBjb250YWluZXIgPHNlbGVjdD4gY2F1c2VzIHRoZSByZW1haW5pbmcgb25lcyB0b1xuXHRcdFx0XHQvLyBiZWNvbWUgc2VsZWN0ZWQuIFNvIG5vdyB3ZSBoYXZlIHRvIGRlc2VsZWN0IHRoZW0uIElFOCwgeW91XG5cdFx0XHRcdC8vIGFtYXplIG1lLiBZb3UgcmVhbGx5IGRvXG5cdFx0XHRcdC8vIC4uLmFuZCBub3cgQ2hyb21lIHRvb1xuXHRcdFx0XHRpZiAoIG5vZGUudGFnTmFtZSA9PT0gJ1NFTEVDVCcgKSB7XG5cdFx0XHRcdFx0aSA9IG5vZGVzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggbm9kZXNbIGkgXSAhPT0gc2VsZWN0ZWRPcHRpb24gKSB7XG5cdFx0XHRcdFx0XHRcdG5vZGVzWyBpIF0uc2VsZWN0ZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBub2Rlcztcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZWxlbWVudCggdGFnTmFtZSApIHtcblx0XHRcdHJldHVybiBlbGVtZW50Q2FjaGVbIHRhZ05hbWUgXSB8fCAoIGVsZW1lbnRDYWNoZVsgdGFnTmFtZSBdID0gY3JlYXRlRWxlbWVudCggdGFnTmFtZSApICk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggbmFtZXNwYWNlcywgY3JlYXRlRWxlbWVudCApO1xuXG5cdC8qIHV0aWxzL3RvQXJyYXkuanMgKi9cblx0dmFyIHRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5KCBhcnJheUxpa2UgKSB7XG5cdFx0dmFyIGFycmF5ID0gW10sXG5cdFx0XHRpID0gYXJyYXlMaWtlLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGFycmF5WyBpIF0gPSBhcnJheUxpa2VbIGkgXTtcblx0XHR9XG5cdFx0cmV0dXJuIGFycmF5O1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvVHJpcGxlL2hlbHBlcnMvdXBkYXRlU2VsZWN0LmpzICovXG5cdHZhciB1cGRhdGVTZWxlY3QgPSBmdW5jdGlvbiggdG9BcnJheSApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIHVwZGF0ZVNlbGVjdCggcGFyZW50RWxlbWVudCApIHtcblx0XHRcdHZhciBzZWxlY3RlZE9wdGlvbnMsIG9wdGlvbiwgdmFsdWU7XG5cdFx0XHRpZiAoICFwYXJlbnRFbGVtZW50IHx8IHBhcmVudEVsZW1lbnQubmFtZSAhPT0gJ3NlbGVjdCcgfHwgIXBhcmVudEVsZW1lbnQuYmluZGluZyApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0c2VsZWN0ZWRPcHRpb25zID0gdG9BcnJheSggcGFyZW50RWxlbWVudC5ub2RlLm9wdGlvbnMgKS5maWx0ZXIoIGlzU2VsZWN0ZWQgKTtcblx0XHRcdC8vIElmIG9uZSBvZiB0aGVtIGhhZCBhIGBzZWxlY3RlZGAgYXR0cmlidXRlLCB3ZSBuZWVkIHRvIHN5bmNcblx0XHRcdC8vIHRoZSBtb2RlbCB0byB0aGUgdmlld1xuXHRcdFx0aWYgKCBwYXJlbnRFbGVtZW50LmdldEF0dHJpYnV0ZSggJ211bHRpcGxlJyApICkge1xuXHRcdFx0XHR2YWx1ZSA9IHNlbGVjdGVkT3B0aW9ucy5tYXAoIGZ1bmN0aW9uKCBvICkge1xuXHRcdFx0XHRcdHJldHVybiBvLnZhbHVlO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9IGVsc2UgaWYgKCBvcHRpb24gPSBzZWxlY3RlZE9wdGlvbnNbIDAgXSApIHtcblx0XHRcdFx0dmFsdWUgPSBvcHRpb24udmFsdWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHBhcmVudEVsZW1lbnQuYmluZGluZy5zZXRWYWx1ZSggdmFsdWUgKTtcblx0XHRcdH1cblx0XHRcdHBhcmVudEVsZW1lbnQuYnViYmxlKCk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGlzU2VsZWN0ZWQoIG9wdGlvbiApIHtcblx0XHRcdHJldHVybiBvcHRpb24uc2VsZWN0ZWQ7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggdG9BcnJheSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvVHJpcGxlL3Byb3RvdHlwZS9yZW5kZXIuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJHJlbmRlciA9IGZ1bmN0aW9uKCBpbnNlcnRIdG1sLCB1cGRhdGVTZWxlY3QgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gVHJpcGxlJHJlbmRlcigpIHtcblx0XHRcdGlmICggdGhpcy5yZW5kZXJlZCApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQXR0ZW1wdGVkIHRvIHJlbmRlciBhbiBpdGVtIHRoYXQgd2FzIGFscmVhZHkgcmVuZGVyZWQnICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmRvY0ZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdFx0XHR0aGlzLm5vZGVzID0gaW5zZXJ0SHRtbCggdGhpcy52YWx1ZSwgdGhpcy5wYXJlbnRGcmFnbWVudC5nZXROb2RlKCksIHRoaXMuZG9jRnJhZyApO1xuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gd2UncmUgaW5zZXJ0aW5nIHRoZSBjb250ZW50cyBvZiBhIDxzZWxlY3Q+XG5cdFx0XHR1cGRhdGVTZWxlY3QoIHRoaXMucEVsZW1lbnQgKTtcblx0XHRcdHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIHRoaXMuZG9jRnJhZztcblx0XHR9O1xuXHR9KCBpbnNlcnRIdG1sLCB1cGRhdGVTZWxlY3QgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1RyaXBsZS9wcm90b3R5cGUvc2V0VmFsdWUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJHNldFZhbHVlID0gZnVuY3Rpb24oIHJ1bmxvb3AgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gVHJpcGxlJHNldFZhbHVlKCB2YWx1ZSApIHtcblx0XHRcdHZhciB3cmFwcGVyO1xuXHRcdFx0Ly8gVE9ETyBpcyB0aGVyZSBhIGJldHRlciB3YXkgdG8gYXBwcm9hY2ggdGhpcz9cblx0XHRcdGlmICggd3JhcHBlciA9IHRoaXMucm9vdC52aWV3bW9kZWwud3JhcHBlZFsgdGhpcy5rZXlwYXRoIF0gKSB7XG5cdFx0XHRcdHZhbHVlID0gd3JhcHBlci5nZXQoKTtcblx0XHRcdH1cblx0XHRcdGlmICggdmFsdWUgIT09IHRoaXMudmFsdWUgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudC5idWJibGUoKTtcblx0XHRcdFx0aWYgKCB0aGlzLnJlbmRlcmVkICkge1xuXHRcdFx0XHRcdHJ1bmxvb3AuYWRkVmlldyggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggcnVubG9vcCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvVHJpcGxlL3Byb3RvdHlwZS90b1N0cmluZy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkdG9TdHJpbmcgPSBmdW5jdGlvbiggZGVjb2RlQ2hhcmFjdGVyUmVmZXJlbmNlcyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBUcmlwbGUkdG9TdHJpbmcoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy52YWx1ZSAhPSB1bmRlZmluZWQgPyBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzKCAnJyArIHRoaXMudmFsdWUgKSA6ICcnO1xuXHRcdH07XG5cdH0oIGRlY29kZUNoYXJhY3RlclJlZmVyZW5jZXMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1RyaXBsZS9wcm90b3R5cGUvdW5yZW5kZXIuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJHVucmVuZGVyID0gZnVuY3Rpb24oIGRldGFjaE5vZGUgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gVHJpcGxlJHVucmVuZGVyKCBzaG91bGREZXN0cm95ICkge1xuXHRcdFx0aWYgKCB0aGlzLnJlbmRlcmVkICYmIHNob3VsZERlc3Ryb3kgKSB7XG5cdFx0XHRcdHRoaXMubm9kZXMuZm9yRWFjaCggZGV0YWNoTm9kZSApO1xuXHRcdFx0XHR0aGlzLnJlbmRlcmVkID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggZGV0YWNoTm9kZSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvVHJpcGxlL3Byb3RvdHlwZS91cGRhdGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJHVwZGF0ZSA9IGZ1bmN0aW9uKCBpbnNlcnRIdG1sLCB1cGRhdGVTZWxlY3QgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gVHJpcGxlJHVwZGF0ZSgpIHtcblx0XHRcdHZhciBub2RlLCBwYXJlbnROb2RlO1xuXHRcdFx0aWYgKCAhdGhpcy5yZW5kZXJlZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Ly8gUmVtb3ZlIGV4aXN0aW5nIG5vZGVzXG5cdFx0XHR3aGlsZSAoIHRoaXMubm9kZXMgJiYgdGhpcy5ub2Rlcy5sZW5ndGggKSB7XG5cdFx0XHRcdG5vZGUgPSB0aGlzLm5vZGVzLnBvcCgpO1xuXHRcdFx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIG5vZGUgKTtcblx0XHRcdH1cblx0XHRcdC8vIEluc2VydCBuZXcgbm9kZXNcblx0XHRcdHBhcmVudE5vZGUgPSB0aGlzLnBhcmVudEZyYWdtZW50LmdldE5vZGUoKTtcblx0XHRcdHRoaXMubm9kZXMgPSBpbnNlcnRIdG1sKCB0aGlzLnZhbHVlLCBwYXJlbnROb2RlLCB0aGlzLmRvY0ZyYWcgKTtcblx0XHRcdHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCB0aGlzLmRvY0ZyYWcsIHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKCB0aGlzICkgKTtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIHdlJ3JlIGluc2VydGluZyB0aGUgY29udGVudHMgb2YgYSA8c2VsZWN0PlxuXHRcdFx0dXBkYXRlU2VsZWN0KCB0aGlzLnBFbGVtZW50ICk7XG5cdFx0fTtcblx0fSggaW5zZXJ0SHRtbCwgdXBkYXRlU2VsZWN0ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9UcmlwbGUvX1RyaXBsZS5qcyAqL1xuXHR2YXIgVHJpcGxlID0gZnVuY3Rpb24oIHR5cGVzLCBNdXN0YWNoZSwgZGV0YWNoLCBmaW5kLCBmaW5kQWxsLCBmaXJzdE5vZGUsIHJlbmRlciwgc2V0VmFsdWUsIHRvU3RyaW5nLCB1bnJlbmRlciwgdXBkYXRlLCB1bmJpbmQgKSB7XG5cblx0XHR2YXIgVHJpcGxlID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLnR5cGUgPSB0eXBlcy5UUklQTEU7XG5cdFx0XHRNdXN0YWNoZS5pbml0KCB0aGlzLCBvcHRpb25zICk7XG5cdFx0fTtcblx0XHRUcmlwbGUucHJvdG90eXBlID0ge1xuXHRcdFx0ZGV0YWNoOiBkZXRhY2gsXG5cdFx0XHRmaW5kOiBmaW5kLFxuXHRcdFx0ZmluZEFsbDogZmluZEFsbCxcblx0XHRcdGZpcnN0Tm9kZTogZmlyc3ROb2RlLFxuXHRcdFx0Z2V0VmFsdWU6IE11c3RhY2hlLmdldFZhbHVlLFxuXHRcdFx0cmViaW5kOiBNdXN0YWNoZS5yZWJpbmQsXG5cdFx0XHRyZW5kZXI6IHJlbmRlcixcblx0XHRcdHJlc29sdmU6IE11c3RhY2hlLnJlc29sdmUsXG5cdFx0XHRzZXRWYWx1ZTogc2V0VmFsdWUsXG5cdFx0XHR0b1N0cmluZzogdG9TdHJpbmcsXG5cdFx0XHR1bmJpbmQ6IHVuYmluZCxcblx0XHRcdHVucmVuZGVyOiB1bnJlbmRlcixcblx0XHRcdHVwZGF0ZTogdXBkYXRlXG5cdFx0fTtcblx0XHRyZXR1cm4gVHJpcGxlO1xuXHR9KCB0eXBlcywgTXVzdGFjaGUsIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJGRldGFjaCwgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkZmluZCwgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkZmluZEFsbCwgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkZmlyc3ROb2RlLCB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSRyZW5kZXIsIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJHNldFZhbHVlLCB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSR0b1N0cmluZywgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkdW5yZW5kZXIsIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJHVwZGF0ZSwgdW5iaW5kICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9idWJibGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRidWJibGUgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnBhcmVudEZyYWdtZW50LmJ1YmJsZSgpO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvZGV0YWNoLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZGV0YWNoID0gZnVuY3Rpb24gRWxlbWVudCRkZXRhY2goKSB7XG5cdFx0dmFyIG5vZGUgPSB0aGlzLm5vZGUsXG5cdFx0XHRwYXJlbnROb2RlO1xuXHRcdGlmICggbm9kZSApIHtcblx0XHRcdC8vIG5lZWQgdG8gY2hlY2sgZm9yIHBhcmVudCBub2RlIC0gRE9NIG1heSBoYXZlIGJlZW4gYWx0ZXJlZFxuXHRcdFx0Ly8gYnkgc29tZXRoaW5nIG90aGVyIHRoYW4gUmFjdGl2ZSEgZS5nLiBqUXVlcnkgVUkuLi5cblx0XHRcdGlmICggcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0cGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvZmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGZpbmQgPSBmdW5jdGlvbiggbWF0Y2hlcyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRpZiAoIG1hdGNoZXMoIHRoaXMubm9kZSwgc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMubm9kZTtcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5mcmFnbWVudCAmJiB0aGlzLmZyYWdtZW50LmZpbmQgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggbWF0Y2hlcyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvZmluZEFsbC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGZpbmRBbGwgPSBmdW5jdGlvbiggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuXHRcdC8vIEFkZCB0aGlzIG5vZGUgdG8gdGhlIHF1ZXJ5LCBpZiBhcHBsaWNhYmxlLCBhbmQgcmVnaXN0ZXIgdGhlXG5cdFx0Ly8gcXVlcnkgb24gdGhpcyBlbGVtZW50XG5cdFx0aWYgKCBxdWVyeS5fdGVzdCggdGhpcywgdHJ1ZSApICYmIHF1ZXJ5LmxpdmUgKSB7XG5cdFx0XHQoIHRoaXMubGl2ZVF1ZXJpZXMgfHwgKCB0aGlzLmxpdmVRdWVyaWVzID0gW10gKSApLnB1c2goIHF1ZXJ5ICk7XG5cdFx0fVxuXHRcdGlmICggdGhpcy5mcmFnbWVudCApIHtcblx0XHRcdHRoaXMuZnJhZ21lbnQuZmluZEFsbCggc2VsZWN0b3IsIHF1ZXJ5ICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvZmluZEFsbENvbXBvbmVudHMuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRmaW5kQWxsQ29tcG9uZW50cyA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcXVlcnkgKSB7XG5cdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuXHRcdFx0dGhpcy5mcmFnbWVudC5maW5kQWxsQ29tcG9uZW50cyggc2VsZWN0b3IsIHF1ZXJ5ICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvZmluZENvbXBvbmVudC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGZpbmRDb21wb25lbnQgPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZENvbXBvbmVudCggc2VsZWN0b3IgKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9maW5kTmV4dE5vZGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRmaW5kTmV4dE5vZGUgPSBmdW5jdGlvbiBFbGVtZW50JGZpbmROZXh0Tm9kZSgpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL2ZpcnN0Tm9kZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGZpcnN0Tm9kZSA9IGZ1bmN0aW9uIEVsZW1lbnQkZmlyc3ROb2RlKCkge1xuXHRcdHJldHVybiB0aGlzLm5vZGU7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9nZXRBdHRyaWJ1dGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRnZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiBFbGVtZW50JGdldEF0dHJpYnV0ZSggbmFtZSApIHtcblx0XHRpZiAoICF0aGlzLmF0dHJpYnV0ZXMgfHwgIXRoaXMuYXR0cmlidXRlc1sgbmFtZSBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF0udmFsdWU7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3NoYXJlZC9lbmZvcmNlQ2FzZS5qcyAqL1xuXHR2YXIgZW5mb3JjZUNhc2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBzdmdDYW1lbENhc2VFbGVtZW50cywgc3ZnQ2FtZWxDYXNlQXR0cmlidXRlcywgY3JlYXRlTWFwLCBtYXA7XG5cdFx0c3ZnQ2FtZWxDYXNlRWxlbWVudHMgPSAnYWx0R2x5cGggYWx0R2x5cGhEZWYgYWx0R2x5cGhJdGVtIGFuaW1hdGVDb2xvciBhbmltYXRlTW90aW9uIGFuaW1hdGVUcmFuc2Zvcm0gY2xpcFBhdGggZmVCbGVuZCBmZUNvbG9yTWF0cml4IGZlQ29tcG9uZW50VHJhbnNmZXIgZmVDb21wb3NpdGUgZmVDb252b2x2ZU1hdHJpeCBmZURpZmZ1c2VMaWdodGluZyBmZURpc3BsYWNlbWVudE1hcCBmZURpc3RhbnRMaWdodCBmZUZsb29kIGZlRnVuY0EgZmVGdW5jQiBmZUZ1bmNHIGZlRnVuY1IgZmVHYXVzc2lhbkJsdXIgZmVJbWFnZSBmZU1lcmdlIGZlTWVyZ2VOb2RlIGZlTW9ycGhvbG9neSBmZU9mZnNldCBmZVBvaW50TGlnaHQgZmVTcGVjdWxhckxpZ2h0aW5nIGZlU3BvdExpZ2h0IGZlVGlsZSBmZVR1cmJ1bGVuY2UgZm9yZWlnbk9iamVjdCBnbHlwaFJlZiBsaW5lYXJHcmFkaWVudCByYWRpYWxHcmFkaWVudCB0ZXh0UGF0aCB2a2Vybicuc3BsaXQoICcgJyApO1xuXHRcdHN2Z0NhbWVsQ2FzZUF0dHJpYnV0ZXMgPSAnYXR0cmlidXRlTmFtZSBhdHRyaWJ1dGVUeXBlIGJhc2VGcmVxdWVuY3kgYmFzZVByb2ZpbGUgY2FsY01vZGUgY2xpcFBhdGhVbml0cyBjb250ZW50U2NyaXB0VHlwZSBjb250ZW50U3R5bGVUeXBlIGRpZmZ1c2VDb25zdGFudCBlZGdlTW9kZSBleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkIGZpbHRlclJlcyBmaWx0ZXJVbml0cyBnbHlwaFJlZiBncmFkaWVudFRyYW5zZm9ybSBncmFkaWVudFVuaXRzIGtlcm5lbE1hdHJpeCBrZXJuZWxVbml0TGVuZ3RoIGtleVBvaW50cyBrZXlTcGxpbmVzIGtleVRpbWVzIGxlbmd0aEFkanVzdCBsaW1pdGluZ0NvbmVBbmdsZSBtYXJrZXJIZWlnaHQgbWFya2VyVW5pdHMgbWFya2VyV2lkdGggbWFza0NvbnRlbnRVbml0cyBtYXNrVW5pdHMgbnVtT2N0YXZlcyBwYXRoTGVuZ3RoIHBhdHRlcm5Db250ZW50VW5pdHMgcGF0dGVyblRyYW5zZm9ybSBwYXR0ZXJuVW5pdHMgcG9pbnRzQXRYIHBvaW50c0F0WSBwb2ludHNBdFogcHJlc2VydmVBbHBoYSBwcmVzZXJ2ZUFzcGVjdFJhdGlvIHByaW1pdGl2ZVVuaXRzIHJlZlggcmVmWSByZXBlYXRDb3VudCByZXBlYXREdXIgcmVxdWlyZWRFeHRlbnNpb25zIHJlcXVpcmVkRmVhdHVyZXMgc3BlY3VsYXJDb25zdGFudCBzcGVjdWxhckV4cG9uZW50IHNwcmVhZE1ldGhvZCBzdGFydE9mZnNldCBzdGREZXZpYXRpb24gc3RpdGNoVGlsZXMgc3VyZmFjZVNjYWxlIHN5c3RlbUxhbmd1YWdlIHRhYmxlVmFsdWVzIHRhcmdldFggdGFyZ2V0WSB0ZXh0TGVuZ3RoIHZpZXdCb3ggdmlld1RhcmdldCB4Q2hhbm5lbFNlbGVjdG9yIHlDaGFubmVsU2VsZWN0b3Igem9vbUFuZFBhbicuc3BsaXQoICcgJyApO1xuXHRcdGNyZWF0ZU1hcCA9IGZ1bmN0aW9uKCBpdGVtcyApIHtcblx0XHRcdHZhciBtYXAgPSB7fSxcblx0XHRcdFx0aSA9IGl0ZW1zLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRtYXBbIGl0ZW1zWyBpIF0udG9Mb3dlckNhc2UoKSBdID0gaXRlbXNbIGkgXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXA7XG5cdFx0fTtcblx0XHRtYXAgPSBjcmVhdGVNYXAoIHN2Z0NhbWVsQ2FzZUVsZW1lbnRzLmNvbmNhdCggc3ZnQ2FtZWxDYXNlQXR0cmlidXRlcyApICk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtZW50TmFtZSApIHtcblx0XHRcdHZhciBsb3dlckNhc2VFbGVtZW50TmFtZSA9IGVsZW1lbnROYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbWFwWyBsb3dlckNhc2VFbGVtZW50TmFtZSBdIHx8IGxvd2VyQ2FzZUVsZW1lbnROYW1lO1xuXHRcdH07XG5cdH0oKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS9idWJibGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkYnViYmxlID0gZnVuY3Rpb24oIHJ1bmxvb3AsIGlzRXF1YWwgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gQXR0cmlidXRlJGJ1YmJsZSgpIHtcblx0XHRcdHZhciB2YWx1ZSA9IHRoaXMuZnJhZ21lbnQuZ2V0VmFsdWUoKTtcblx0XHRcdC8vIFRPRE8gdGhpcyBjYW4gcmVnaXN0ZXIgdGhlIGF0dHJpYnV0ZSBtdWx0aXBsZSB0aW1lcyAoc2VlIHJlbmRlciB0ZXN0XG5cdFx0XHQvLyAnQXR0cmlidXRlIHdpdGggbmVzdGVkIG11c3RhY2hlcycpXG5cdFx0XHRpZiAoICFpc0VxdWFsKCB2YWx1ZSwgdGhpcy52YWx1ZSApICkge1xuXHRcdFx0XHQvLyBOZWVkIHRvIGNsZWFyIG9sZCBpZCBmcm9tIHJhY3RpdmUubm9kZXNcblx0XHRcdFx0aWYgKCB0aGlzLm5hbWUgPT09ICdpZCcgJiYgdGhpcy52YWx1ZSApIHtcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5yb290Lm5vZGVzWyB0aGlzLnZhbHVlIF07XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ3ZhbHVlJyAmJiB0aGlzLm5vZGUgKSB7XG5cdFx0XHRcdFx0Ly8gV2UgbmVlZCB0byBzdG9yZSB0aGUgdmFsdWUgb24gdGhlIERPTSBsaWtlIHRoaXMgc28gd2Vcblx0XHRcdFx0XHQvLyBjYW4gcmV0cmlldmUgaXQgbGF0ZXIgd2l0aG91dCBpdCBiZWluZyBjb2VyY2VkIHRvIGEgc3RyaW5nXG5cdFx0XHRcdFx0dGhpcy5ub2RlLl9yYWN0aXZlLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB0aGlzLnJlbmRlcmVkICkge1xuXHRcdFx0XHRcdHJ1bmxvb3AuYWRkVmlldyggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggcnVubG9vcCwgaXNFcXVhbCApO1xuXG5cdC8qIGNvbmZpZy9ib29sZWFuQXR0cmlidXRlcy5qcyAqL1xuXHR2YXIgYm9vbGVhbkF0dHJpYnV0ZXMgPSBmdW5jdGlvbigpIHtcblxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9rYW5nYXgvaHRtbC1taW5pZmllci9pc3N1ZXMvNjMjaXNzdWVjb21tZW50LTM3NzYzMzE2XG5cdFx0dmFyIGJvb2xlYW5BdHRyaWJ1dGVzID0gL14oYWxsb3dGdWxsc2NyZWVufGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjaGVja2VkfGNvbXBhY3R8Y29udHJvbHN8ZGVjbGFyZXxkZWZhdWx0fGRlZmF1bHRDaGVja2VkfGRlZmF1bHRNdXRlZHxkZWZhdWx0U2VsZWN0ZWR8ZGVmZXJ8ZGlzYWJsZWR8ZHJhZ2dhYmxlfGVuYWJsZWR8Zm9ybU5vVmFsaWRhdGV8aGlkZGVufGluZGV0ZXJtaW5hdGV8aW5lcnR8aXNNYXB8aXRlbVNjb3BlfGxvb3B8bXVsdGlwbGV8bXV0ZWR8bm9IcmVmfG5vUmVzaXplfG5vU2hhZGV8bm9WYWxpZGF0ZXxub1dyYXB8b3BlbnxwYXVzZU9uRXhpdHxyZWFkT25seXxyZXF1aXJlZHxyZXZlcnNlZHxzY29wZWR8c2VhbWxlc3N8c2VsZWN0ZWR8c29ydGFibGV8dHJhbnNsYXRlfHRydWVTcGVlZHx0eXBlTXVzdE1hdGNofHZpc2libGUpJC9pO1xuXHRcdHJldHVybiBib29sZWFuQXR0cmlidXRlcztcblx0fSgpO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvaGVscGVycy9kZXRlcm1pbmVOYW1lQW5kTmFtZXNwYWNlLmpzICovXG5cdHZhciBkZXRlcm1pbmVOYW1lQW5kTmFtZXNwYWNlID0gZnVuY3Rpb24oIG5hbWVzcGFjZXMsIGVuZm9yY2VDYXNlICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBhdHRyaWJ1dGUsIG5hbWUgKSB7XG5cdFx0XHR2YXIgY29sb25JbmRleCwgbmFtZXNwYWNlUHJlZml4O1xuXHRcdFx0Ly8gYXJlIHdlIGRlYWxpbmcgd2l0aCBhIG5hbWVzcGFjZWQgYXR0cmlidXRlLCBlLmcuIHhsaW5rOmhyZWY/XG5cdFx0XHRjb2xvbkluZGV4ID0gbmFtZS5pbmRleE9mKCAnOicgKTtcblx0XHRcdGlmICggY29sb25JbmRleCAhPT0gLTEgKSB7XG5cdFx0XHRcdC8vIGxvb2tzIGxpa2Ugd2UgYXJlLCB5ZXMuLi5cblx0XHRcdFx0bmFtZXNwYWNlUHJlZml4ID0gbmFtZS5zdWJzdHIoIDAsIGNvbG9uSW5kZXggKTtcblx0XHRcdFx0Ly8gLi4udW5sZXNzIGl0J3MgYSBuYW1lc3BhY2UgKmRlY2xhcmF0aW9uKiwgd2hpY2ggd2UgaWdub3JlIChvbiB0aGUgYXNzdW1wdGlvblxuXHRcdFx0XHQvLyB0aGF0IG9ubHkgdmFsaWQgbmFtZXNwYWNlcyB3aWxsIGJlIHVzZWQpXG5cdFx0XHRcdGlmICggbmFtZXNwYWNlUHJlZml4ICE9PSAneG1sbnMnICkge1xuXHRcdFx0XHRcdG5hbWUgPSBuYW1lLnN1YnN0cmluZyggY29sb25JbmRleCArIDEgKTtcblx0XHRcdFx0XHRhdHRyaWJ1dGUubmFtZSA9IGVuZm9yY2VDYXNlKCBuYW1lICk7XG5cdFx0XHRcdFx0YXR0cmlidXRlLm5hbWVzcGFjZSA9IG5hbWVzcGFjZXNbIG5hbWVzcGFjZVByZWZpeC50b0xvd2VyQ2FzZSgpIF07XG5cdFx0XHRcdFx0YXR0cmlidXRlLm5hbWVzcGFjZVByZWZpeCA9IG5hbWVzcGFjZVByZWZpeDtcblx0XHRcdFx0XHRpZiAoICFhdHRyaWJ1dGUubmFtZXNwYWNlICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgJ1Vua25vd24gbmFtZXNwYWNlIChcIicgKyBuYW1lc3BhY2VQcmVmaXggKyAnXCIpJztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBTVkcgYXR0cmlidXRlIG5hbWVzIGFyZSBjYXNlIHNlbnNpdGl2ZVxuXHRcdFx0YXR0cmlidXRlLm5hbWUgPSBhdHRyaWJ1dGUuZWxlbWVudC5uYW1lc3BhY2UgIT09IG5hbWVzcGFjZXMuaHRtbCA/IGVuZm9yY2VDYXNlKCBuYW1lICkgOiBuYW1lO1xuXHRcdH07XG5cdH0oIG5hbWVzcGFjZXMsIGVuZm9yY2VDYXNlICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9oZWxwZXJzL2dldEludGVycG9sYXRvci5qcyAqL1xuXHR2YXIgZ2V0SW50ZXJwb2xhdG9yID0gZnVuY3Rpb24oIHR5cGVzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGdldEludGVycG9sYXRvciggYXR0cmlidXRlICkge1xuXHRcdFx0dmFyIGl0ZW1zID0gYXR0cmlidXRlLmZyYWdtZW50Lml0ZW1zO1xuXHRcdFx0aWYgKCBpdGVtcy5sZW5ndGggIT09IDEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmICggaXRlbXNbIDAgXS50eXBlID09PSB0eXBlcy5JTlRFUlBPTEFUT1IgKSB7XG5cdFx0XHRcdHJldHVybiBpdGVtc1sgMCBdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIHR5cGVzICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9oZWxwZXJzL2RldGVybWluZVByb3BlcnR5TmFtZS5qcyAqL1xuXHR2YXIgZGV0ZXJtaW5lUHJvcGVydHlOYW1lID0gZnVuY3Rpb24oIG5hbWVzcGFjZXMsIGJvb2xlYW5BdHRyaWJ1dGVzICkge1xuXG5cdFx0dmFyIHByb3BlcnR5TmFtZXMgPSB7XG5cdFx0XHQnYWNjZXB0LWNoYXJzZXQnOiAnYWNjZXB0Q2hhcnNldCcsXG5cdFx0XHRhY2Nlc3NrZXk6ICdhY2Nlc3NLZXknLFxuXHRcdFx0Ymdjb2xvcjogJ2JnQ29sb3InLFxuXHRcdFx0J2NsYXNzJzogJ2NsYXNzTmFtZScsXG5cdFx0XHRjb2RlYmFzZTogJ2NvZGVCYXNlJyxcblx0XHRcdGNvbHNwYW46ICdjb2xTcGFuJyxcblx0XHRcdGNvbnRlbnRlZGl0YWJsZTogJ2NvbnRlbnRFZGl0YWJsZScsXG5cdFx0XHRkYXRldGltZTogJ2RhdGVUaW1lJyxcblx0XHRcdGRpcm5hbWU6ICdkaXJOYW1lJyxcblx0XHRcdCdmb3InOiAnaHRtbEZvcicsXG5cdFx0XHQnaHR0cC1lcXVpdic6ICdodHRwRXF1aXYnLFxuXHRcdFx0aXNtYXA6ICdpc01hcCcsXG5cdFx0XHRtYXhsZW5ndGg6ICdtYXhMZW5ndGgnLFxuXHRcdFx0bm92YWxpZGF0ZTogJ25vVmFsaWRhdGUnLFxuXHRcdFx0cHViZGF0ZTogJ3B1YkRhdGUnLFxuXHRcdFx0cmVhZG9ubHk6ICdyZWFkT25seScsXG5cdFx0XHRyb3dzcGFuOiAncm93U3BhbicsXG5cdFx0XHR0YWJpbmRleDogJ3RhYkluZGV4Jyxcblx0XHRcdHVzZW1hcDogJ3VzZU1hcCdcblx0XHR9O1xuXHRcdHJldHVybiBmdW5jdGlvbiggYXR0cmlidXRlLCBvcHRpb25zICkge1xuXHRcdFx0dmFyIHByb3BlcnR5TmFtZTtcblx0XHRcdGlmICggYXR0cmlidXRlLnBOb2RlICYmICFhdHRyaWJ1dGUubmFtZXNwYWNlICYmICggIW9wdGlvbnMucE5vZGUubmFtZXNwYWNlVVJJIHx8IG9wdGlvbnMucE5vZGUubmFtZXNwYWNlVVJJID09PSBuYW1lc3BhY2VzLmh0bWwgKSApIHtcblx0XHRcdFx0cHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lc1sgYXR0cmlidXRlLm5hbWUgXSB8fCBhdHRyaWJ1dGUubmFtZTtcblx0XHRcdFx0aWYgKCBvcHRpb25zLnBOb2RlWyBwcm9wZXJ0eU5hbWUgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGF0dHJpYnV0ZS5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gaXMgYXR0cmlidXRlIGEgYm9vbGVhbiBhdHRyaWJ1dGUgb3IgJ3ZhbHVlJz8gSWYgc28gd2UncmUgYmV0dGVyIG9mZiBkb2luZyBlLmcuXG5cdFx0XHRcdC8vIG5vZGUuc2VsZWN0ZWQgPSB0cnVlIHJhdGhlciB0aGFuIG5vZGUuc2V0QXR0cmlidXRlKCAnc2VsZWN0ZWQnLCAnJyApXG5cdFx0XHRcdGlmICggYm9vbGVhbkF0dHJpYnV0ZXMudGVzdCggcHJvcGVydHlOYW1lICkgfHwgcHJvcGVydHlOYW1lID09PSAndmFsdWUnICkge1xuXHRcdFx0XHRcdGF0dHJpYnV0ZS51c2VQcm9wZXJ0eSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9KCBuYW1lc3BhY2VzLCBib29sZWFuQXR0cmlidXRlcyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL2luaXQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkaW5pdCA9IGZ1bmN0aW9uKCB0eXBlcywgYm9vbGVhbkF0dHJpYnV0ZXMsIGRldGVybWluZU5hbWVBbmROYW1lc3BhY2UsIGdldEludGVycG9sYXRvciwgZGV0ZXJtaW5lUHJvcGVydHlOYW1lLCBjaXJjdWxhciApIHtcblxuXHRcdHZhciBGcmFnbWVudDtcblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdEZyYWdtZW50ID0gY2lyY3VsYXIuRnJhZ21lbnQ7XG5cdFx0fSApO1xuXHRcdHJldHVybiBmdW5jdGlvbiBBdHRyaWJ1dGUkaW5pdCggb3B0aW9ucyApIHtcblx0XHRcdHRoaXMudHlwZSA9IHR5cGVzLkFUVFJJQlVURTtcblx0XHRcdHRoaXMuZWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudDtcblx0XHRcdHRoaXMucm9vdCA9IG9wdGlvbnMucm9vdDtcblx0XHRcdGRldGVybWluZU5hbWVBbmROYW1lc3BhY2UoIHRoaXMsIG9wdGlvbnMubmFtZSApO1xuXHRcdFx0Ly8gaWYgaXQncyBhbiBlbXB0eSBhdHRyaWJ1dGUsIG9yIGp1c3QgYSBzdHJhaWdodCBrZXktdmFsdWUgcGFpciwgd2l0aCBub1xuXHRcdFx0Ly8gbXVzdGFjaGUgc2hlbmFuaWdhbnMsIHNldCB0aGUgYXR0cmlidXRlIGFjY29yZGluZ2x5IGFuZCBnbyBob21lXG5cdFx0XHRpZiAoICFvcHRpb25zLnZhbHVlIHx8IHR5cGVvZiBvcHRpb25zLnZhbHVlID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IGJvb2xlYW5BdHRyaWJ1dGVzLnRlc3QoIHRoaXMubmFtZSApID8gdHJ1ZSA6IG9wdGlvbnMudmFsdWUgfHwgJyc7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8vIG90aGVyd2lzZSB3ZSBuZWVkIHRvIGRvIHNvbWUgd29ya1xuXHRcdFx0Ly8gc2hhcmUgcGFyZW50RnJhZ21lbnQgd2l0aCBwYXJlbnQgZWxlbWVudFxuXHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IHRoaXMuZWxlbWVudC5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHRoaXMuZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIHtcblx0XHRcdFx0dGVtcGxhdGU6IG9wdGlvbnMudmFsdWUsXG5cdFx0XHRcdHJvb3Q6IHRoaXMucm9vdCxcblx0XHRcdFx0b3duZXI6IHRoaXNcblx0XHRcdH0gKTtcblx0XHRcdHRoaXMudmFsdWUgPSB0aGlzLmZyYWdtZW50LmdldFZhbHVlKCk7XG5cdFx0XHQvLyBTdG9yZSBhIHJlZmVyZW5jZSB0byB0aGlzIGF0dHJpYnV0ZSdzIGludGVycG9sYXRvciwgaWYgaXRzIGZyYWdtZW50XG5cdFx0XHQvLyB0YWtlcyB0aGUgZm9ybSBge3tmb299fWAuIFRoaXMgaXMgbmVjZXNzYXJ5IGZvciB0d28td2F5IGJpbmRpbmcgYW5kXG5cdFx0XHQvLyBmb3IgY29ycmVjdGx5IHJlbmRlcmluZyBIVE1MIGxhdGVyXG5cdFx0XHR0aGlzLmludGVycG9sYXRvciA9IGdldEludGVycG9sYXRvciggdGhpcyApO1xuXHRcdFx0dGhpcy5pc0JpbmRhYmxlID0gISF0aGlzLmludGVycG9sYXRvciAmJiAhdGhpcy5pbnRlcnBvbGF0b3IuaXNTdGF0aWM7XG5cdFx0XHQvLyBjYW4gd2UgZXN0YWJsaXNoIHRoaXMgYXR0cmlidXRlJ3MgcHJvcGVydHkgbmFtZSBlcXVpdmFsZW50P1xuXHRcdFx0ZGV0ZXJtaW5lUHJvcGVydHlOYW1lKCB0aGlzLCBvcHRpb25zICk7XG5cdFx0XHQvLyBtYXJrIGFzIHJlYWR5XG5cdFx0XHR0aGlzLnJlYWR5ID0gdHJ1ZTtcblx0XHR9O1xuXHR9KCB0eXBlcywgYm9vbGVhbkF0dHJpYnV0ZXMsIGRldGVybWluZU5hbWVBbmROYW1lc3BhY2UsIGdldEludGVycG9sYXRvciwgZGV0ZXJtaW5lUHJvcGVydHlOYW1lLCBjaXJjdWxhciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3JlYmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSRyZWJpbmQgPSBmdW5jdGlvbiBBdHRyaWJ1dGUkcmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuXHRcdFx0dGhpcy5mcmFnbWVudC5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS9yZW5kZXIuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkcmVuZGVyID0gZnVuY3Rpb24oIG5hbWVzcGFjZXMsIGJvb2xlYW5BdHRyaWJ1dGVzICkge1xuXG5cdFx0dmFyIHByb3BlcnR5TmFtZXMgPSB7XG5cdFx0XHQnYWNjZXB0LWNoYXJzZXQnOiAnYWNjZXB0Q2hhcnNldCcsXG5cdFx0XHQnYWNjZXNza2V5JzogJ2FjY2Vzc0tleScsXG5cdFx0XHQnYmdjb2xvcic6ICdiZ0NvbG9yJyxcblx0XHRcdCdjbGFzcyc6ICdjbGFzc05hbWUnLFxuXHRcdFx0J2NvZGViYXNlJzogJ2NvZGVCYXNlJyxcblx0XHRcdCdjb2xzcGFuJzogJ2NvbFNwYW4nLFxuXHRcdFx0J2NvbnRlbnRlZGl0YWJsZSc6ICdjb250ZW50RWRpdGFibGUnLFxuXHRcdFx0J2RhdGV0aW1lJzogJ2RhdGVUaW1lJyxcblx0XHRcdCdkaXJuYW1lJzogJ2Rpck5hbWUnLFxuXHRcdFx0J2Zvcic6ICdodG1sRm9yJyxcblx0XHRcdCdodHRwLWVxdWl2JzogJ2h0dHBFcXVpdicsXG5cdFx0XHQnaXNtYXAnOiAnaXNNYXAnLFxuXHRcdFx0J21heGxlbmd0aCc6ICdtYXhMZW5ndGgnLFxuXHRcdFx0J25vdmFsaWRhdGUnOiAnbm9WYWxpZGF0ZScsXG5cdFx0XHQncHViZGF0ZSc6ICdwdWJEYXRlJyxcblx0XHRcdCdyZWFkb25seSc6ICdyZWFkT25seScsXG5cdFx0XHQncm93c3Bhbic6ICdyb3dTcGFuJyxcblx0XHRcdCd0YWJpbmRleCc6ICd0YWJJbmRleCcsXG5cdFx0XHQndXNlbWFwJzogJ3VzZU1hcCdcblx0XHR9O1xuXHRcdHJldHVybiBmdW5jdGlvbiBBdHRyaWJ1dGUkcmVuZGVyKCBub2RlICkge1xuXHRcdFx0dmFyIHByb3BlcnR5TmFtZTtcblx0XHRcdHRoaXMubm9kZSA9IG5vZGU7XG5cdFx0XHQvLyBzaG91bGQgd2UgdXNlIGRpcmVjdCBwcm9wZXJ0eSBhY2Nlc3MsIG9yIHNldEF0dHJpYnV0ZT9cblx0XHRcdGlmICggIW5vZGUubmFtZXNwYWNlVVJJIHx8IG5vZGUubmFtZXNwYWNlVVJJID09PSBuYW1lc3BhY2VzLmh0bWwgKSB7XG5cdFx0XHRcdHByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZXNbIHRoaXMubmFtZSBdIHx8IHRoaXMubmFtZTtcblx0XHRcdFx0aWYgKCBub2RlWyBwcm9wZXJ0eU5hbWUgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRoaXMucHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGlzIGF0dHJpYnV0ZSBhIGJvb2xlYW4gYXR0cmlidXRlIG9yICd2YWx1ZSc/IElmIHNvIHdlJ3JlIGJldHRlciBvZmYgZG9pbmcgZS5nLlxuXHRcdFx0XHQvLyBub2RlLnNlbGVjdGVkID0gdHJ1ZSByYXRoZXIgdGhhbiBub2RlLnNldEF0dHJpYnV0ZSggJ3NlbGVjdGVkJywgJycgKVxuXHRcdFx0XHRpZiAoIGJvb2xlYW5BdHRyaWJ1dGVzLnRlc3QoIHByb3BlcnR5TmFtZSApIHx8IHByb3BlcnR5TmFtZSA9PT0gJ3ZhbHVlJyApIHtcblx0XHRcdFx0XHR0aGlzLnVzZVByb3BlcnR5ID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHByb3BlcnR5TmFtZSA9PT0gJ3ZhbHVlJyApIHtcblx0XHRcdFx0XHR0aGlzLnVzZVByb3BlcnR5ID0gdHJ1ZTtcblx0XHRcdFx0XHRub2RlLl9yYWN0aXZlLnZhbHVlID0gdGhpcy52YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdH07XG5cdH0oIG5hbWVzcGFjZXMsIGJvb2xlYW5BdHRyaWJ1dGVzICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvdG9TdHJpbmcuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdG9TdHJpbmcgPSBmdW5jdGlvbiggYm9vbGVhbkF0dHJpYnV0ZXMgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBBdHRyaWJ1dGUkdG9TdHJpbmcoKSB7XG5cdFx0XHR2YXIgbmFtZSA9ICggZnJhZ21lbnQgPSB0aGlzICkubmFtZSxcblx0XHRcdFx0bmFtZXNwYWNlUHJlZml4ID0gZnJhZ21lbnQubmFtZXNwYWNlUHJlZml4LFxuXHRcdFx0XHR2YWx1ZSA9IGZyYWdtZW50LnZhbHVlLFxuXHRcdFx0XHRpbnRlcnBvbGF0b3IgPSBmcmFnbWVudC5pbnRlcnBvbGF0b3IsXG5cdFx0XHRcdGZyYWdtZW50ID0gZnJhZ21lbnQuZnJhZ21lbnQ7XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSBzZWxlY3QgYW5kIHRleHRhcmVhIHZhbHVlcyAoc2hvdWxkIG5vdCBiZSBzdHJpbmdpZmllZClcblx0XHRcdGlmICggbmFtZSA9PT0gJ3ZhbHVlJyAmJiAoIHRoaXMuZWxlbWVudC5uYW1lID09PSAnc2VsZWN0JyB8fCB0aGlzLmVsZW1lbnQubmFtZSA9PT0gJ3RleHRhcmVhJyApICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSBjb250ZW50IGVkaXRhYmxlXG5cdFx0XHRpZiAoIG5hbWUgPT09ICd2YWx1ZScgJiYgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ2NvbnRlbnRlZGl0YWJsZScgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSByYWRpbyBuYW1lc1xuXHRcdFx0aWYgKCBuYW1lID09PSAnbmFtZScgJiYgdGhpcy5lbGVtZW50Lm5hbWUgPT09ICdpbnB1dCcgJiYgaW50ZXJwb2xhdG9yICkge1xuXHRcdFx0XHRyZXR1cm4gJ25hbWU9e3snICsgKCBpbnRlcnBvbGF0b3Iua2V5cGF0aCB8fCBpbnRlcnBvbGF0b3IucmVmICkgKyAnfX0nO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzXG5cdFx0XHRpZiAoIGJvb2xlYW5BdHRyaWJ1dGVzLnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlID8gbmFtZSA6ICcnO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBmcmFnbWVudCApIHtcblx0XHRcdFx0dmFsdWUgPSBmcmFnbWVudC50b1N0cmluZygpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBuYW1lc3BhY2VQcmVmaXggKSB7XG5cdFx0XHRcdG5hbWUgPSBuYW1lc3BhY2VQcmVmaXggKyAnOicgKyBuYW1lO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbHVlID8gbmFtZSArICc9XCInICsgZXNjYXBlKCB2YWx1ZSApICsgJ1wiJyA6IG5hbWU7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGVzY2FwZSggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUucmVwbGFjZSggLyYvZywgJyZhbXA7JyApLnJlcGxhY2UoIC9cIi9nLCAnJnF1b3Q7JyApLnJlcGxhY2UoIC8nL2csICcmIzM5OycgKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBib29sZWFuQXR0cmlidXRlcyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VuYmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1bmJpbmQgPSBmdW5jdGlvbiBBdHRyaWJ1dGUkdW5iaW5kKCkge1xuXHRcdC8vIGlnbm9yZSBub24tZHluYW1pYyBhdHRyaWJ1dGVzXG5cdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuXHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLm5hbWUgPT09ICdpZCcgKSB7XG5cdFx0XHRkZWxldGUgdGhpcy5yb290Lm5vZGVzWyB0aGlzLnZhbHVlIF07XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS91cGRhdGVTZWxlY3RWYWx1ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlU2VsZWN0VmFsdWUgPSBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlU2VsZWN0KCkge1xuXHRcdHZhciB2YWx1ZSA9IHRoaXMudmFsdWUsXG5cdFx0XHRvcHRpb25zLCBvcHRpb24sIG9wdGlvblZhbHVlLCBpO1xuXHRcdGlmICggIXRoaXMubG9ja2VkICkge1xuXHRcdFx0dGhpcy5ub2RlLl9yYWN0aXZlLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRvcHRpb25zID0gdGhpcy5ub2RlLm9wdGlvbnM7XG5cdFx0XHRpID0gb3B0aW9ucy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXHRcdFx0XHRvcHRpb25WYWx1ZSA9IG9wdGlvbi5fcmFjdGl2ZSA/IG9wdGlvbi5fcmFjdGl2ZS52YWx1ZSA6IG9wdGlvbi52YWx1ZTtcblx0XHRcdFx0Ly8gb3B0aW9ucyBpbnNlcnRlZCB2aWEgYSB0cmlwbGUgZG9uJ3QgaGF2ZSBfcmFjdGl2ZVxuXHRcdFx0XHRpZiAoIG9wdGlvblZhbHVlID09IHZhbHVlICkge1xuXHRcdFx0XHRcdC8vIGRvdWJsZSBlcXVhbHMgYXMgd2UgbWF5IGJlIGNvbXBhcmluZyBudW1iZXJzIHdpdGggc3RyaW5nc1xuXHRcdFx0XHRcdG9wdGlvbi5zZWxlY3RlZCA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyogdXRpbHMvYXJyYXlDb250YWlucy5qcyAqL1xuXHR2YXIgYXJyYXlDb250YWlucyA9IGZ1bmN0aW9uIGFycmF5Q29udGFpbnMoIGFycmF5LCB2YWx1ZSApIHtcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGMgPSBhcnJheS5sZW5ndGg7IGkgPCBjOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFycmF5WyBpIF0gPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvdXBkYXRlL3VwZGF0ZU11bHRpcGxlU2VsZWN0VmFsdWUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZU11bHRpcGxlU2VsZWN0VmFsdWUgPSBmdW5jdGlvbiggYXJyYXlDb250YWlucywgaXNBcnJheSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlTXVsdGlwbGVTZWxlY3QoKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSB0aGlzLnZhbHVlLFxuXHRcdFx0XHRvcHRpb25zLCBpLCBvcHRpb24sIG9wdGlvblZhbHVlO1xuXHRcdFx0aWYgKCAhaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0dmFsdWUgPSBbIHZhbHVlIF07XG5cdFx0XHR9XG5cdFx0XHRvcHRpb25zID0gdGhpcy5ub2RlLm9wdGlvbnM7XG5cdFx0XHRpID0gb3B0aW9ucy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXHRcdFx0XHRvcHRpb25WYWx1ZSA9IG9wdGlvbi5fcmFjdGl2ZSA/IG9wdGlvbi5fcmFjdGl2ZS52YWx1ZSA6IG9wdGlvbi52YWx1ZTtcblx0XHRcdFx0Ly8gb3B0aW9ucyBpbnNlcnRlZCB2aWEgYSB0cmlwbGUgZG9uJ3QgaGF2ZSBfcmFjdGl2ZVxuXHRcdFx0XHRvcHRpb24uc2VsZWN0ZWQgPSBhcnJheUNvbnRhaW5zKCB2YWx1ZSwgb3B0aW9uVmFsdWUgKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBhcnJheUNvbnRhaW5zLCBpc0FycmF5ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvdXBkYXRlL3VwZGF0ZVJhZGlvTmFtZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlUmFkaW9OYW1lID0gZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZVJhZGlvTmFtZSgpIHtcblx0XHR2YXIgbm9kZSA9ICggdmFsdWUgPSB0aGlzICkubm9kZSxcblx0XHRcdHZhbHVlID0gdmFsdWUudmFsdWU7XG5cdFx0bm9kZS5jaGVja2VkID0gdmFsdWUgPT0gbm9kZS5fcmFjdGl2ZS52YWx1ZTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS91cGRhdGUvdXBkYXRlUmFkaW9WYWx1ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlUmFkaW9WYWx1ZSA9IGZ1bmN0aW9uKCBydW5sb29wICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVSYWRpb1ZhbHVlKCkge1xuXHRcdFx0dmFyIHdhc0NoZWNrZWQsIG5vZGUgPSB0aGlzLm5vZGUsXG5cdFx0XHRcdGJpbmRpbmcsIGJpbmRpbmdzLCBpO1xuXHRcdFx0d2FzQ2hlY2tlZCA9IG5vZGUuY2hlY2tlZDtcblx0XHRcdG5vZGUudmFsdWUgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHRub2RlLmNoZWNrZWQgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndmFsdWUnICkgPT09IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoICduYW1lJyApO1xuXHRcdFx0Ly8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSAtIGlmIHRoZSBpbnB1dCB3YXMgY2hlY2tlZCwgYW5kIHRoZSB2YWx1ZVxuXHRcdFx0Ly8gY2hhbmdlZCBzbyB0aGF0IGl0J3Mgbm8gbG9uZ2VyIGNoZWNrZWQsIHRoZSB0d293YXkgYmluZGluZyBpc1xuXHRcdFx0Ly8gbW9zdCBsaWtlbHkgb3V0IG9mIGRhdGUuIFRvIGZpeCBpdCB3ZSBoYXZlIHRvIGp1bXAgdGhyb3VnaCBzb21lXG5cdFx0XHQvLyBob29wcy4uLiB0aGlzIGlzIGEgbGl0dGxlIGtsdWRneSBidXQgaXQgd29ya3Ncblx0XHRcdGlmICggd2FzQ2hlY2tlZCAmJiAhbm9kZS5jaGVja2VkICYmIHRoaXMuZWxlbWVudC5iaW5kaW5nICkge1xuXHRcdFx0XHRiaW5kaW5ncyA9IHRoaXMuZWxlbWVudC5iaW5kaW5nLnNpYmxpbmdzO1xuXHRcdFx0XHRpZiAoIGkgPSBiaW5kaW5ncy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRiaW5kaW5nID0gYmluZGluZ3NbIGkgXTtcblx0XHRcdFx0XHRcdGlmICggIWJpbmRpbmcuZWxlbWVudC5ub2RlICkge1xuXHRcdFx0XHRcdFx0XHQvLyB0aGlzIGlzIHRoZSBpbml0aWFsIHJlbmRlciwgc2libGluZ3MgYXJlIHN0aWxsIHJlbmRlcmluZyFcblx0XHRcdFx0XHRcdFx0Ly8gd2UnbGwgY29tZSBiYWNrIGxhdGVyLi4uXG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggYmluZGluZy5lbGVtZW50Lm5vZGUuY2hlY2tlZCApIHtcblx0XHRcdFx0XHRcdFx0cnVubG9vcC5hZGRWaWV3bW9kZWwoIGJpbmRpbmcucm9vdC52aWV3bW9kZWwgKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGJpbmRpbmcuaGFuZGxlQ2hhbmdlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJ1bmxvb3AuYWRkVmlld21vZGVsKCBiaW5kaW5nLnJvb3Qudmlld21vZGVsICk7XG5cdFx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQoIGJpbmRpbmcua2V5cGF0aCwgdW5kZWZpbmVkICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9KCBydW5sb29wICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvdXBkYXRlL3VwZGF0ZUNoZWNrYm94TmFtZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlQ2hlY2tib3hOYW1lID0gZnVuY3Rpb24oIGlzQXJyYXkgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZUNoZWNrYm94TmFtZSgpIHtcblx0XHRcdHZhciBlbGVtZW50ID0gKCB2YWx1ZSA9IHRoaXMgKS5lbGVtZW50LFxuXHRcdFx0XHRub2RlID0gdmFsdWUubm9kZSxcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZS52YWx1ZSxcblx0XHRcdFx0dmFsdWVBdHRyaWJ1dGUsIGk7XG5cdFx0XHR2YWx1ZUF0dHJpYnV0ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHRpZiAoICFpc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0XHRub2RlLmNoZWNrZWQgPSB2YWx1ZSA9PSB2YWx1ZUF0dHJpYnV0ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGkgPSB2YWx1ZS5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGlmICggdmFsdWVBdHRyaWJ1dGUgPT0gdmFsdWVbIGkgXSApIHtcblx0XHRcdFx0XHRcdG5vZGUuY2hlY2tlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdG5vZGUuY2hlY2tlZCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIGlzQXJyYXkgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS91cGRhdGUvdXBkYXRlQ2xhc3NOYW1lLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVDbGFzc05hbWUgPSBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlQ2xhc3NOYW1lKCkge1xuXHRcdHZhciBub2RlLCB2YWx1ZTtcblx0XHRub2RlID0gdGhpcy5ub2RlO1xuXHRcdHZhbHVlID0gdGhpcy52YWx1ZTtcblx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWx1ZSA9ICcnO1xuXHRcdH1cblx0XHRub2RlLmNsYXNzTmFtZSA9IHZhbHVlO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS91cGRhdGVJZEF0dHJpYnV0ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlSWRBdHRyaWJ1dGUgPSBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlSWRBdHRyaWJ1dGUoKSB7XG5cdFx0dmFyIG5vZGUgPSAoIHZhbHVlID0gdGhpcyApLm5vZGUsXG5cdFx0XHR2YWx1ZSA9IHZhbHVlLnZhbHVlO1xuXHRcdHRoaXMucm9vdC5ub2Rlc1sgdmFsdWUgXSA9IG5vZGU7XG5cdFx0bm9kZS5pZCA9IHZhbHVlO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS91cGRhdGVJRVN0eWxlQXR0cmlidXRlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVJRVN0eWxlQXR0cmlidXRlID0gZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZUlFU3R5bGVBdHRyaWJ1dGUoKSB7XG5cdFx0dmFyIG5vZGUsIHZhbHVlO1xuXHRcdG5vZGUgPSB0aGlzLm5vZGU7XG5cdFx0dmFsdWUgPSB0aGlzLnZhbHVlO1xuXHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbHVlID0gJyc7XG5cdFx0fVxuXHRcdG5vZGUuc3R5bGUuc2V0QXR0cmlidXRlKCAnY3NzVGV4dCcsIHZhbHVlICk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvdXBkYXRlL3VwZGF0ZUNvbnRlbnRFZGl0YWJsZVZhbHVlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVDb250ZW50RWRpdGFibGVWYWx1ZSA9IGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVDb250ZW50RWRpdGFibGVWYWx1ZSgpIHtcblx0XHR2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuXHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbHVlID0gJyc7XG5cdFx0fVxuXHRcdGlmICggIXRoaXMubG9ja2VkICkge1xuXHRcdFx0dGhpcy5ub2RlLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS91cGRhdGUvdXBkYXRlVmFsdWUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZVZhbHVlID0gZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZVZhbHVlKCkge1xuXHRcdHZhciBub2RlID0gKCB2YWx1ZSA9IHRoaXMgKS5ub2RlLFxuXHRcdFx0dmFsdWUgPSB2YWx1ZS52YWx1ZTtcblx0XHQvLyBzdG9yZSBhY3R1YWwgdmFsdWUsIHNvIGl0IGRvZXNuJ3QgZ2V0IGNvZXJjZWQgdG8gYSBzdHJpbmdcblx0XHRub2RlLl9yYWN0aXZlLnZhbHVlID0gdmFsdWU7XG5cdFx0Ly8gd2l0aCB0d28td2F5IGJpbmRpbmcsIG9ubHkgdXBkYXRlIGlmIHRoZSBjaGFuZ2Ugd2Fzbid0IGluaXRpYXRlZCBieSB0aGUgdXNlclxuXHRcdC8vIG90aGVyd2lzZSB0aGUgY3Vyc29yIHdpbGwgb2Z0ZW4gYmUgc2VudCB0byB0aGUgd3JvbmcgcGxhY2Vcblx0XHRpZiAoICF0aGlzLmxvY2tlZCApIHtcblx0XHRcdG5vZGUudmFsdWUgPSB2YWx1ZSA9PSB1bmRlZmluZWQgPyAnJyA6IHZhbHVlO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS91cGRhdGUvdXBkYXRlQm9vbGVhbi5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlQm9vbGVhbiA9IGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVCb29sZWFuQXR0cmlidXRlKCkge1xuXHRcdC8vIHdpdGggdHdvLXdheSBiaW5kaW5nLCBvbmx5IHVwZGF0ZSBpZiB0aGUgY2hhbmdlIHdhc24ndCBpbml0aWF0ZWQgYnkgdGhlIHVzZXJcblx0XHQvLyBvdGhlcndpc2UgdGhlIGN1cnNvciB3aWxsIG9mdGVuIGJlIHNlbnQgdG8gdGhlIHdyb25nIHBsYWNlXG5cdFx0aWYgKCAhdGhpcy5sb2NrZWQgKSB7XG5cdFx0XHR0aGlzLm5vZGVbIHRoaXMucHJvcGVydHlOYW1lIF0gPSB0aGlzLnZhbHVlO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS91cGRhdGUvdXBkYXRlRXZlcnl0aGluZ0Vsc2UuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZUV2ZXJ5dGhpbmdFbHNlID0gZnVuY3Rpb24oIGJvb2xlYW5BdHRyaWJ1dGVzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVFdmVyeXRoaW5nRWxzZSgpIHtcblx0XHRcdHZhciBub2RlID0gKCBmcmFnbWVudCA9IHRoaXMgKS5ub2RlLFxuXHRcdFx0XHRuYW1lc3BhY2UgPSBmcmFnbWVudC5uYW1lc3BhY2UsXG5cdFx0XHRcdG5hbWUgPSBmcmFnbWVudC5uYW1lLFxuXHRcdFx0XHR2YWx1ZSA9IGZyYWdtZW50LnZhbHVlLFxuXHRcdFx0XHRmcmFnbWVudCA9IGZyYWdtZW50LmZyYWdtZW50O1xuXHRcdFx0aWYgKCBuYW1lc3BhY2UgKSB7XG5cdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlTlMoIG5hbWVzcGFjZSwgbmFtZSwgKCBmcmFnbWVudCB8fCB2YWx1ZSApLnRvU3RyaW5nKCkgKTtcblx0XHRcdH0gZWxzZSBpZiAoICFib29sZWFuQXR0cmlidXRlcy50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKCBuYW1lLCAoIGZyYWdtZW50IHx8IHZhbHVlICkudG9TdHJpbmcoKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRub2RlLnNldEF0dHJpYnV0ZSggbmFtZSwgJycgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRub2RlLnJlbW92ZUF0dHJpYnV0ZSggbmFtZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggYm9vbGVhbkF0dHJpYnV0ZXMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS91cGRhdGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlID0gZnVuY3Rpb24oIG5hbWVzcGFjZXMsIG5vb3AsIHVwZGF0ZVNlbGVjdFZhbHVlLCB1cGRhdGVNdWx0aXBsZVNlbGVjdFZhbHVlLCB1cGRhdGVSYWRpb05hbWUsIHVwZGF0ZVJhZGlvVmFsdWUsIHVwZGF0ZUNoZWNrYm94TmFtZSwgdXBkYXRlQ2xhc3NOYW1lLCB1cGRhdGVJZEF0dHJpYnV0ZSwgdXBkYXRlSUVTdHlsZUF0dHJpYnV0ZSwgdXBkYXRlQ29udGVudEVkaXRhYmxlVmFsdWUsIHVwZGF0ZVZhbHVlLCB1cGRhdGVCb29sZWFuLCB1cGRhdGVFdmVyeXRoaW5nRWxzZSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlKCkge1xuXHRcdFx0dmFyIG5hbWUgPSAoIG5vZGUgPSB0aGlzICkubmFtZSxcblx0XHRcdFx0ZWxlbWVudCA9IG5vZGUuZWxlbWVudCxcblx0XHRcdFx0bm9kZSA9IG5vZGUubm9kZSxcblx0XHRcdFx0dHlwZSwgdXBkYXRlTWV0aG9kO1xuXHRcdFx0aWYgKCBuYW1lID09PSAnaWQnICkge1xuXHRcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVJZEF0dHJpYnV0ZTtcblx0XHRcdH0gZWxzZSBpZiAoIG5hbWUgPT09ICd2YWx1ZScgKSB7XG5cdFx0XHRcdC8vIHNwZWNpYWwgY2FzZSAtIHNlbGVjdHNcblx0XHRcdFx0aWYgKCBlbGVtZW50Lm5hbWUgPT09ICdzZWxlY3QnICYmIG5hbWUgPT09ICd2YWx1ZScgKSB7XG5cdFx0XHRcdFx0dXBkYXRlTWV0aG9kID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdtdWx0aXBsZScgKSA/IHVwZGF0ZU11bHRpcGxlU2VsZWN0VmFsdWUgOiB1cGRhdGVTZWxlY3RWYWx1ZTtcblx0XHRcdFx0fSBlbHNlIGlmICggZWxlbWVudC5uYW1lID09PSAndGV4dGFyZWEnICkge1xuXHRcdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZVZhbHVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ2NvbnRlbnRlZGl0YWJsZScgKSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZUNvbnRlbnRFZGl0YWJsZVZhbHVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBlbGVtZW50Lm5hbWUgPT09ICdpbnB1dCcgKSB7XG5cdFx0XHRcdFx0dHlwZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndHlwZScgKTtcblx0XHRcdFx0XHQvLyB0eXBlPSdmaWxlJyB2YWx1ZT0ne3tmaWxlTGlzdH19Jz5cblx0XHRcdFx0XHRpZiAoIHR5cGUgPT09ICdmaWxlJyApIHtcblx0XHRcdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IG5vb3A7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gJ3JhZGlvJyAmJiBlbGVtZW50LmJpbmRpbmcgJiYgZWxlbWVudC5iaW5kaW5nLm5hbWUgPT09ICduYW1lJyApIHtcblx0XHRcdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZVJhZGlvVmFsdWU7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZVZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICggdGhpcy50d293YXkgJiYgbmFtZSA9PT0gJ25hbWUnICkge1xuXHRcdFx0XHRpZiAoIG5vZGUudHlwZSA9PT0gJ3JhZGlvJyApIHtcblx0XHRcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVSYWRpb05hbWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIG5vZGUudHlwZSA9PT0gJ2NoZWNrYm94JyApIHtcblx0XHRcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVDaGVja2JveE5hbWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoIG5hbWUgPT09ICdzdHlsZScgJiYgbm9kZS5zdHlsZS5zZXRBdHRyaWJ1dGUgKSB7XG5cdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZUlFU3R5bGVBdHRyaWJ1dGU7XG5cdFx0XHR9IGVsc2UgaWYgKCBuYW1lID09PSAnY2xhc3MnICYmICggIW5vZGUubmFtZXNwYWNlVVJJIHx8IG5vZGUubmFtZXNwYWNlVVJJID09PSBuYW1lc3BhY2VzLmh0bWwgKSApIHtcblx0XHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlQ2xhc3NOYW1lO1xuXHRcdFx0fSBlbHNlIGlmICggdGhpcy51c2VQcm9wZXJ0eSApIHtcblx0XHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlQm9vbGVhbjtcblx0XHRcdH1cblx0XHRcdGlmICggIXVwZGF0ZU1ldGhvZCApIHtcblx0XHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlRXZlcnl0aGluZ0Vsc2U7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnVwZGF0ZSA9IHVwZGF0ZU1ldGhvZDtcblx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0fTtcblx0fSggbmFtZXNwYWNlcywgbm9vcCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlU2VsZWN0VmFsdWUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZU11bHRpcGxlU2VsZWN0VmFsdWUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZVJhZGlvTmFtZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlUmFkaW9WYWx1ZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlQ2hlY2tib3hOYW1lLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVDbGFzc05hbWUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZUlkQXR0cmlidXRlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVJRVN0eWxlQXR0cmlidXRlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVDb250ZW50RWRpdGFibGVWYWx1ZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlVmFsdWUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZUJvb2xlYW4sIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZUV2ZXJ5dGhpbmdFbHNlICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9fQXR0cmlidXRlLmpzICovXG5cdHZhciBBdHRyaWJ1dGUgPSBmdW5jdGlvbiggYnViYmxlLCBpbml0LCByZWJpbmQsIHJlbmRlciwgdG9TdHJpbmcsIHVuYmluZCwgdXBkYXRlICkge1xuXG5cdFx0dmFyIEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0dGhpcy5pbml0KCBvcHRpb25zICk7XG5cdFx0fTtcblx0XHRBdHRyaWJ1dGUucHJvdG90eXBlID0ge1xuXHRcdFx0YnViYmxlOiBidWJibGUsXG5cdFx0XHRpbml0OiBpbml0LFxuXHRcdFx0cmViaW5kOiByZWJpbmQsXG5cdFx0XHRyZW5kZXI6IHJlbmRlcixcblx0XHRcdHRvU3RyaW5nOiB0b1N0cmluZyxcblx0XHRcdHVuYmluZDogdW5iaW5kLFxuXHRcdFx0dXBkYXRlOiB1cGRhdGVcblx0XHR9O1xuXHRcdHJldHVybiBBdHRyaWJ1dGU7XG5cdH0oIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkYnViYmxlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJGluaXQsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkcmViaW5kLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHJlbmRlciwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR0b1N0cmluZywgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1bmJpbmQsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9pbml0L2NyZWF0ZUF0dHJpYnV0ZXMuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRpbml0X2NyZWF0ZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiggQXR0cmlidXRlICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtZW50LCBhdHRyaWJ1dGVzICkge1xuXHRcdFx0dmFyIG5hbWUsIGF0dHJpYnV0ZSwgcmVzdWx0ID0gW107XG5cdFx0XHRmb3IgKCBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XG5cdFx0XHRcdGlmICggYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eSggbmFtZSApICkge1xuXHRcdFx0XHRcdGF0dHJpYnV0ZSA9IG5ldyBBdHRyaWJ1dGUoIHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6IGVsZW1lbnQsXG5cdFx0XHRcdFx0XHRuYW1lOiBuYW1lLFxuXHRcdFx0XHRcdFx0dmFsdWU6IGF0dHJpYnV0ZXNbIG5hbWUgXSxcblx0XHRcdFx0XHRcdHJvb3Q6IGVsZW1lbnQucm9vdFxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRyZXN1bHQucHVzaCggcmVzdWx0WyBuYW1lIF0gPSBhdHRyaWJ1dGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXHR9KCBBdHRyaWJ1dGUgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQ29uZGl0aW9uYWxBdHRyaWJ1dGUvX0NvbmRpdGlvbmFsQXR0cmlidXRlLmpzICovXG5cdHZhciBDb25kaXRpb25hbEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKCBjaXJjdWxhciwgbmFtZXNwYWNlcywgY3JlYXRlRWxlbWVudCwgdG9BcnJheSApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgRnJhZ21lbnQsIGRpdjtcblx0XHRpZiAoIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRkaXYgPSBjcmVhdGVFbGVtZW50KCAnZGl2JyApO1xuXHRcdH1cblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdEZyYWdtZW50ID0gY2lyY3VsYXIuRnJhZ21lbnQ7XG5cdFx0fSApO1xuXHRcdHZhciBDb25kaXRpb25hbEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKCBlbGVtZW50LCB0ZW1wbGF0ZSApIHtcblx0XHRcdHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG5cdFx0XHR0aGlzLnJvb3QgPSBlbGVtZW50LnJvb3Q7XG5cdFx0XHR0aGlzLnBhcmVudEZyYWdtZW50ID0gZWxlbWVudC5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHRoaXMuYXR0cmlidXRlcyA9IFtdO1xuXHRcdFx0dGhpcy5mcmFnbWVudCA9IG5ldyBGcmFnbWVudCgge1xuXHRcdFx0XHRyb290OiBlbGVtZW50LnJvb3QsXG5cdFx0XHRcdG93bmVyOiB0aGlzLFxuXHRcdFx0XHR0ZW1wbGF0ZTogWyB0ZW1wbGF0ZSBdXG5cdFx0XHR9ICk7XG5cdFx0fTtcblx0XHRDb25kaXRpb25hbEF0dHJpYnV0ZS5wcm90b3R5cGUgPSB7XG5cdFx0XHRidWJibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMubm9kZSApIHtcblx0XHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5idWJibGUoKTtcblx0XHRcdH0sXG5cdFx0XHRyZWJpbmQ6IGZ1bmN0aW9uKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHRcdHRoaXMuZnJhZ21lbnQucmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdH0sXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCBub2RlICkge1xuXHRcdFx0XHR0aGlzLm5vZGUgPSBub2RlO1xuXHRcdFx0XHR0aGlzLmlzU3ZnID0gbm9kZS5uYW1lc3BhY2VVUkkgPT09IG5hbWVzcGFjZXMuc3ZnO1xuXHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdFx0fSxcblx0XHRcdHVuYmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0XHR9LFxuXHRcdFx0dXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHRcdHZhciBzdHIsIGF0dHJzO1xuXHRcdFx0XHRzdHIgPSB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCk7XG5cdFx0XHRcdGF0dHJzID0gcGFyc2VBdHRyaWJ1dGVzKCBzdHIsIHRoaXMuaXNTdmcgKTtcblx0XHRcdFx0Ly8gYW55IGF0dHJpYnV0ZXMgdGhhdCBwcmV2aW91c2x5IGV4aXN0ZWQgYnV0IG5vIGxvbmdlciBkb1xuXHRcdFx0XHQvLyBtdXN0IGJlIHJlbW92ZWRcblx0XHRcdFx0dGhpcy5hdHRyaWJ1dGVzLmZpbHRlciggZnVuY3Rpb24oIGEgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5vdEluKCBhdHRycywgYSApO1xuXHRcdFx0XHR9ICkuZm9yRWFjaCggZnVuY3Rpb24oIGEgKSB7XG5cdFx0XHRcdFx0dGhpcyQwLm5vZGUucmVtb3ZlQXR0cmlidXRlKCBhLm5hbWUgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRhdHRycy5mb3JFYWNoKCBmdW5jdGlvbiggYSApIHtcblx0XHRcdFx0XHR0aGlzJDAubm9kZS5zZXRBdHRyaWJ1dGUoIGEubmFtZSwgYS52YWx1ZSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHRoaXMuYXR0cmlidXRlcyA9IGF0dHJzO1xuXHRcdFx0fSxcblx0XHRcdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdF9fZXhwb3J0ID0gQ29uZGl0aW9uYWxBdHRyaWJ1dGU7XG5cblx0XHRmdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZXMoIHN0ciwgaXNTdmcgKSB7XG5cdFx0XHR2YXIgdGFnID0gaXNTdmcgPyAnc3ZnJyA6ICdkaXYnO1xuXHRcdFx0ZGl2LmlubmVySFRNTCA9ICc8JyArIHRhZyArICcgJyArIHN0ciArICc+PC8nICsgdGFnICsgJz4nO1xuXHRcdFx0cmV0dXJuIHRvQXJyYXkoIGRpdi5jaGlsZE5vZGVzWyAwIF0uYXR0cmlidXRlcyApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG5vdEluKCBoYXlzdGFjaywgbmVlZGxlICkge1xuXHRcdFx0dmFyIGkgPSBoYXlzdGFjay5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBoYXlzdGFja1sgaSBdLm5hbWUgPT09IG5lZWRsZS5uYW1lICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggY2lyY3VsYXIsIG5hbWVzcGFjZXMsIGNyZWF0ZUVsZW1lbnQsIHRvQXJyYXkgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL2luaXQvY3JlYXRlQ29uZGl0aW9uYWxBdHRyaWJ1dGVzLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkaW5pdF9jcmVhdGVDb25kaXRpb25hbEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiggQ29uZGl0aW9uYWxBdHRyaWJ1dGUgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW1lbnQsIGF0dHJpYnV0ZXMgKSB7XG5cdFx0XHRpZiAoICFhdHRyaWJ1dGVzICkge1xuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYXR0cmlidXRlcy5tYXAoIGZ1bmN0aW9uKCBhICkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IENvbmRpdGlvbmFsQXR0cmlidXRlKCBlbGVtZW50LCBhICk7XG5cdFx0XHR9ICk7XG5cdFx0fTtcblx0fSggQ29uZGl0aW9uYWxBdHRyaWJ1dGUgKTtcblxuXHQvKiB1dGlscy9leHRlbmQuanMgKi9cblx0dmFyIGV4dGVuZCA9IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIFNMSUNFJDAgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cdFx0dmFyIHNvdXJjZXMgPSBTTElDRSQwLmNhbGwoIGFyZ3VtZW50cywgMSApO1xuXHRcdHZhciBwcm9wLCBzb3VyY2U7XG5cdFx0d2hpbGUgKCBzb3VyY2UgPSBzb3VyY2VzLnNoaWZ0KCkgKSB7XG5cdFx0XHRmb3IgKCBwcm9wIGluIHNvdXJjZSApIHtcblx0XHRcdFx0aWYgKCBzb3VyY2UuaGFzT3duUHJvcGVydHkoIHByb3AgKSApIHtcblx0XHRcdFx0XHR0YXJnZXRbIHByb3AgXSA9IHNvdXJjZVsgcHJvcCBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0JpbmRpbmcvQmluZGluZy5qcyAqL1xuXHR2YXIgQmluZGluZyA9IGZ1bmN0aW9uKCBydW5sb29wLCB3YXJuLCBjcmVhdGUsIGV4dGVuZCwgcmVtb3ZlRnJvbUFycmF5ICkge1xuXG5cdFx0dmFyIEJpbmRpbmcgPSBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHRcdHZhciBpbnRlcnBvbGF0b3IsIGtleXBhdGgsIHZhbHVlO1xuXHRcdFx0dGhpcy5lbGVtZW50ID0gZWxlbWVudDtcblx0XHRcdHRoaXMucm9vdCA9IGVsZW1lbnQucm9vdDtcblx0XHRcdHRoaXMuYXR0cmlidXRlID0gZWxlbWVudC5hdHRyaWJ1dGVzWyB0aGlzLm5hbWUgfHwgJ3ZhbHVlJyBdO1xuXHRcdFx0aW50ZXJwb2xhdG9yID0gdGhpcy5hdHRyaWJ1dGUuaW50ZXJwb2xhdG9yO1xuXHRcdFx0aW50ZXJwb2xhdG9yLnR3b3dheUJpbmRpbmcgPSB0aGlzO1xuXHRcdFx0aWYgKCBpbnRlcnBvbGF0b3Iua2V5cGF0aCAmJiBpbnRlcnBvbGF0b3Iua2V5cGF0aC5zdWJzdHIoIDAsIDIgKSA9PT0gJyR7JyApIHtcblx0XHRcdFx0d2FybiggJ1R3by13YXkgYmluZGluZyBkb2VzIG5vdCB3b3JrIHdpdGggZXhwcmVzc2lvbnMgKGAnICsgaW50ZXJwb2xhdG9yLmtleXBhdGguc2xpY2UoIDIsIC0xICkgKyAnYCknICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdC8vIEEgbXVzdGFjaGUgbWF5IGJlICphbWJpZ3VvdXMqLiBMZXQncyBzYXkgd2Ugd2VyZSBnaXZlblxuXHRcdFx0Ly8gYHZhbHVlPVwie3tiYXJ9fVwiYC4gSWYgdGhlIGNvbnRleHQgd2FzIGBmb29gLCBhbmQgYGZvby5iYXJgXG5cdFx0XHQvLyAqd2Fzbid0KiBgdW5kZWZpbmVkYCwgdGhlIGtleXBhdGggd291bGQgYmUgYGZvby5iYXJgLlxuXHRcdFx0Ly8gVGhlbiwgYW55IHVzZXIgaW5wdXQgd291bGQgcmVzdWx0IGluIGBmb28uYmFyYCBiZWluZyB1cGRhdGVkLlxuXHRcdFx0Ly9cblx0XHRcdC8vIElmLCBob3dldmVyLCBgZm9vLmJhcmAgKndhcyogdW5kZWZpbmVkLCBhbmQgc28gd2FzIGBiYXJgLCB3ZSB3b3VsZCBiZVxuXHRcdFx0Ly8gbGVmdCB3aXRoIGFuIHVucmVzb2x2ZWQgcGFydGlhbCBrZXlwYXRoIC0gc28gd2UgYXJlIGZvcmNlZCB0byBtYWtlIGFuXG5cdFx0XHQvLyBhc3N1bXB0aW9uLiBUaGF0IGFzc3VtcHRpb24gaXMgdGhhdCB0aGUgaW5wdXQgaW4gcXVlc3Rpb24gc2hvdWxkXG5cdFx0XHQvLyBiZSBmb3JjZWQgdG8gcmVzb2x2ZSB0byBgYmFyYCwgYW5kIGFueSB1c2VyIGlucHV0IHdvdWxkIGFmZmVjdCBgYmFyYFxuXHRcdFx0Ly8gYW5kIG5vdCBgZm9vLmJhcmAuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gRGlkIHRoYXQgbWFrZSBhbnkgc2Vuc2U/IE5vPyBPaC4gU29ycnkuIFdlbGwgdGhlIG1vcmFsIG9mIHRoZSBzdG9yeSBpc1xuXHRcdFx0Ly8gYmUgZXhwbGljaXQgd2hlbiB1c2luZyB0d28td2F5IGRhdGEtYmluZGluZyBhYm91dCB3aGF0IGtleXBhdGggeW91J3JlXG5cdFx0XHQvLyB1cGRhdGluZy4gVXNpbmcgaXQgaW4gbGlzdHMgaXMgcHJvYmFibHkgYSByZWNpcGUgZm9yIGNvbmZ1c2lvbi4uLlxuXHRcdFx0aWYgKCAhaW50ZXJwb2xhdG9yLmtleXBhdGggKSB7XG5cdFx0XHRcdGludGVycG9sYXRvci5yZXNvbHZlci5mb3JjZVJlc29sdXRpb24oKTtcblx0XHRcdH1cblx0XHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGggPSBpbnRlcnBvbGF0b3Iua2V5cGF0aDtcblx0XHRcdC8vIGluaXRpYWxpc2UgdmFsdWUsIGlmIGl0J3MgdW5kZWZpbmVkXG5cdFx0XHRpZiAoIHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KCBrZXlwYXRoICkgPT09IHVuZGVmaW5lZCAmJiB0aGlzLmdldEluaXRpYWxWYWx1ZSApIHtcblx0XHRcdFx0dmFsdWUgPSB0aGlzLmdldEluaXRpYWxWYWx1ZSgpO1xuXHRcdFx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQoIGtleXBhdGgsIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdEJpbmRpbmcucHJvdG90eXBlID0ge1xuXHRcdFx0aGFuZGxlQ2hhbmdlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHRcdHJ1bmxvb3Auc3RhcnQoIHRoaXMucm9vdCApO1xuXHRcdFx0XHR0aGlzLmF0dHJpYnV0ZS5sb2NrZWQgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCggdGhpcy5rZXlwYXRoLCB0aGlzLmdldFZhbHVlKCkgKTtcblx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzJDAuYXR0cmlidXRlLmxvY2tlZCA9IGZhbHNlO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHR9LFxuXHRcdFx0cmVib3VuZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBiaW5kaW5ncywgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aDtcblx0XHRcdFx0b2xkS2V5cGF0aCA9IHRoaXMua2V5cGF0aDtcblx0XHRcdFx0bmV3S2V5cGF0aCA9IHRoaXMuYXR0cmlidXRlLmludGVycG9sYXRvci5rZXlwYXRoO1xuXHRcdFx0XHQvLyBUaGUgYXR0cmlidXRlIHRoaXMgYmluZGluZyBpcyBsaW5rZWQgdG8gaGFzIGFscmVhZHkgZG9uZSB0aGUgd29ya1xuXHRcdFx0XHRpZiAoIG9sZEtleXBhdGggPT09IG5ld0tleXBhdGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJlbW92ZUZyb21BcnJheSggdGhpcy5yb290Ll90d293YXlCaW5kaW5nc1sgb2xkS2V5cGF0aCBdLCB0aGlzICk7XG5cdFx0XHRcdHRoaXMua2V5cGF0aCA9IG5ld0tleXBhdGg7XG5cdFx0XHRcdGJpbmRpbmdzID0gdGhpcy5yb290Ll90d293YXlCaW5kaW5nc1sgbmV3S2V5cGF0aCBdIHx8ICggdGhpcy5yb290Ll90d293YXlCaW5kaW5nc1sgbmV3S2V5cGF0aCBdID0gW10gKTtcblx0XHRcdFx0YmluZGluZ3MucHVzaCggdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdHVuYmluZDogZnVuY3Rpb24oKSB7fVxuXHRcdH07XG5cdFx0QmluZGluZy5leHRlbmQgPSBmdW5jdGlvbiggcHJvcGVydGllcyApIHtcblx0XHRcdHZhciBQYXJlbnQgPSB0aGlzLFxuXHRcdFx0XHRTcGVjaWFsaXNlZEJpbmRpbmc7XG5cdFx0XHRTcGVjaWFsaXNlZEJpbmRpbmcgPSBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHRcdFx0QmluZGluZy5jYWxsKCB0aGlzLCBlbGVtZW50ICk7XG5cdFx0XHRcdGlmICggdGhpcy5pbml0ICkge1xuXHRcdFx0XHRcdHRoaXMuaW5pdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0U3BlY2lhbGlzZWRCaW5kaW5nLnByb3RvdHlwZSA9IGNyZWF0ZSggUGFyZW50LnByb3RvdHlwZSApO1xuXHRcdFx0ZXh0ZW5kKCBTcGVjaWFsaXNlZEJpbmRpbmcucHJvdG90eXBlLCBwcm9wZXJ0aWVzICk7XG5cdFx0XHRTcGVjaWFsaXNlZEJpbmRpbmcuZXh0ZW5kID0gQmluZGluZy5leHRlbmQ7XG5cdFx0XHRyZXR1cm4gU3BlY2lhbGlzZWRCaW5kaW5nO1xuXHRcdH07XG5cdFx0cmV0dXJuIEJpbmRpbmc7XG5cdH0oIHJ1bmxvb3AsIHdhcm4sIGNyZWF0ZSwgZXh0ZW5kLCByZW1vdmVGcm9tQXJyYXkgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9zaGFyZWQvaGFuZGxlRG9tRXZlbnQuanMgKi9cblx0dmFyIGhhbmRsZURvbUV2ZW50ID0gZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKCkge1xuXHRcdHRoaXMuX3JhY3RpdmUuYmluZGluZy5oYW5kbGVDaGFuZ2UoKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9Db250ZW50RWRpdGFibGVCaW5kaW5nLmpzICovXG5cdHZhciBDb250ZW50RWRpdGFibGVCaW5kaW5nID0gZnVuY3Rpb24oIEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50ICkge1xuXG5cdFx0dmFyIENvbnRlbnRFZGl0YWJsZUJpbmRpbmcgPSBCaW5kaW5nLmV4dGVuZCgge1xuXHRcdFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5mcmFnbWVudCA/IHRoaXMuZWxlbWVudC5mcmFnbWVudC50b1N0cmluZygpIDogJyc7XG5cdFx0XHR9LFxuXHRcdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdGlmICggIXRoaXMucm9vdC5sYXp5ICkge1xuXHRcdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2lucHV0JywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdFx0aWYgKCBub2RlLmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAna2V5dXAnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdpbnB1dCcsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdrZXl1cCcsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0fSxcblx0XHRcdGdldFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5ub2RlLmlubmVySFRNTDtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIENvbnRlbnRFZGl0YWJsZUJpbmRpbmc7XG5cdH0oIEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0JpbmRpbmcvc2hhcmVkL2dldFNpYmxpbmdzLmpzICovXG5cdHZhciBnZXRTaWJsaW5ncyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHNldHMgPSB7fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0U2libGluZ3MoIGlkLCBncm91cCwga2V5cGF0aCApIHtcblx0XHRcdHZhciBoYXNoID0gaWQgKyBncm91cCArIGtleXBhdGg7XG5cdFx0XHRyZXR1cm4gc2V0c1sgaGFzaCBdIHx8ICggc2V0c1sgaGFzaCBdID0gW10gKTtcblx0XHR9O1xuXHR9KCk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0JpbmRpbmcvUmFkaW9CaW5kaW5nLmpzICovXG5cdHZhciBSYWRpb0JpbmRpbmcgPSBmdW5jdGlvbiggcnVubG9vcCwgcmVtb3ZlRnJvbUFycmF5LCBCaW5kaW5nLCBnZXRTaWJsaW5ncywgaGFuZGxlRG9tRXZlbnQgKSB7XG5cblx0XHR2YXIgUmFkaW9CaW5kaW5nID0gQmluZGluZy5leHRlbmQoIHtcblx0XHRcdG5hbWU6ICdjaGVja2VkJyxcblx0XHRcdGluaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnNpYmxpbmdzID0gZ2V0U2libGluZ3MoIHRoaXMucm9vdC5fZ3VpZCwgJ3JhZGlvJywgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ25hbWUnICkgKTtcblx0XHRcdFx0dGhpcy5zaWJsaW5ncy5wdXNoKCB0aGlzICk7XG5cdFx0XHR9LFxuXHRcdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdGlmICggbm9kZS5hdHRhY2hFdmVudCApIHtcblx0XHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjbGljaycsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dW5yZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2xpY2snLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdH0sXG5cdFx0XHRoYW5kbGVDaGFuZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRydW5sb29wLnN0YXJ0KCB0aGlzLnJvb3QgKTtcblx0XHRcdFx0dGhpcy5zaWJsaW5ncy5mb3JFYWNoKCBmdW5jdGlvbiggYmluZGluZyApIHtcblx0XHRcdFx0XHRiaW5kaW5nLnJvb3Qudmlld21vZGVsLnNldCggYmluZGluZy5rZXlwYXRoLCBiaW5kaW5nLmdldFZhbHVlKCkgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRydW5sb29wLmVuZCgpO1xuXHRcdFx0fSxcblx0XHRcdGdldFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5ub2RlLmNoZWNrZWQ7XG5cdFx0XHR9LFxuXHRcdFx0dW5iaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCB0aGlzLnNpYmxpbmdzLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBSYWRpb0JpbmRpbmc7XG5cdH0oIHJ1bmxvb3AsIHJlbW92ZUZyb21BcnJheSwgQmluZGluZywgZ2V0U2libGluZ3MsIGhhbmRsZURvbUV2ZW50ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0JpbmRpbmcvUmFkaW9OYW1lQmluZGluZy5qcyAqL1xuXHR2YXIgUmFkaW9OYW1lQmluZGluZyA9IGZ1bmN0aW9uKCByZW1vdmVGcm9tQXJyYXksIEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50LCBnZXRTaWJsaW5ncyApIHtcblxuXHRcdHZhciBSYWRpb05hbWVCaW5kaW5nID0gQmluZGluZy5leHRlbmQoIHtcblx0XHRcdG5hbWU6ICduYW1lJyxcblx0XHRcdGluaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnNpYmxpbmdzID0gZ2V0U2libGluZ3MoIHRoaXMucm9vdC5fZ3VpZCwgJ3JhZGlvbmFtZScsIHRoaXMua2V5cGF0aCApO1xuXHRcdFx0XHR0aGlzLnNpYmxpbmdzLnB1c2goIHRoaXMgKTtcblx0XHRcdFx0dGhpcy5yYWRpb05hbWUgPSB0cnVlO1xuXHRcdFx0XHQvLyBzbyB0aGF0IHJhY3RpdmUudXBkYXRlTW9kZWwoKSBrbm93cyB3aGF0IHRvIGRvIHdpdGggdGhpc1xuXHRcdFx0XHR0aGlzLmF0dHJpYnV0ZS50d293YXkgPSB0cnVlO1xuXHRcdFx0fSxcblx0XHRcdGdldEluaXRpYWxWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ2NoZWNrZWQnICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cdFx0XHRcdG5vZGUubmFtZSA9ICd7eycgKyB0aGlzLmtleXBhdGggKyAnfX0nO1xuXHRcdFx0XHRub2RlLmNoZWNrZWQgPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldCggdGhpcy5rZXlwYXRoICkgPT0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0aWYgKCBub2RlLmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2NsaWNrJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjbGljaycsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0fSxcblx0XHRcdGdldFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblx0XHRcdFx0cmV0dXJuIG5vZGUuX3JhY3RpdmUgPyBub2RlLl9yYWN0aXZlLnZhbHVlIDogbm9kZS52YWx1ZTtcblx0XHRcdH0sXG5cdFx0XHRoYW5kbGVDaGFuZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBJZiB0aGlzIDxpbnB1dD4gaXMgdGhlIG9uZSB0aGF0J3MgY2hlY2tlZCwgdGhlbiB0aGUgdmFsdWUgb2YgaXRzXG5cdFx0XHRcdC8vIGBuYW1lYCBrZXlwYXRoIGdldHMgc2V0IHRvIGl0cyB2YWx1ZVxuXHRcdFx0XHRpZiAoIHRoaXMuZWxlbWVudC5ub2RlLmNoZWNrZWQgKSB7XG5cdFx0XHRcdFx0QmluZGluZy5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHJlYm91bmQ6IGZ1bmN0aW9uKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHRcdHZhciBub2RlO1xuXHRcdFx0XHRCaW5kaW5nLnByb3RvdHlwZS5yZWJvdW5kLmNhbGwoIHRoaXMsIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0XHRpZiAoIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZSApIHtcblx0XHRcdFx0XHRub2RlLm5hbWUgPSAne3snICsgdGhpcy5rZXlwYXRoICsgJ319Jztcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVuYmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJlbW92ZUZyb21BcnJheSggdGhpcy5zaWJsaW5ncywgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gUmFkaW9OYW1lQmluZGluZztcblx0fSggcmVtb3ZlRnJvbUFycmF5LCBCaW5kaW5nLCBoYW5kbGVEb21FdmVudCwgZ2V0U2libGluZ3MgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9DaGVja2JveE5hbWVCaW5kaW5nLmpzICovXG5cdHZhciBDaGVja2JveE5hbWVCaW5kaW5nID0gZnVuY3Rpb24oIGlzQXJyYXksIGFycmF5Q29udGFpbnMsIHJlbW92ZUZyb21BcnJheSwgQmluZGluZywgZ2V0U2libGluZ3MsIGhhbmRsZURvbUV2ZW50ICkge1xuXG5cdFx0dmFyIENoZWNrYm94TmFtZUJpbmRpbmcgPSBCaW5kaW5nLmV4dGVuZCgge1xuXHRcdFx0bmFtZTogJ25hbWUnLFxuXHRcdFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gVGhpcyBvbmx5IGdldHMgY2FsbGVkIG9uY2UgcGVyIGdyb3VwIChvZiBpbnB1dHMgdGhhdFxuXHRcdFx0XHQvLyBzaGFyZSBhIG5hbWUpLCBiZWNhdXNlIGl0IG9ubHkgZ2V0cyBjYWxsZWQgaWYgdGhlcmVcblx0XHRcdFx0Ly8gaXNuJ3QgYW4gaW5pdGlhbCB2YWx1ZS4gQnkgdGhlIHNhbWUgdG9rZW4sIHdlIGNhbiBtYWtlXG5cdFx0XHRcdC8vIGEgbm90ZSBvZiB0aGF0IGZhY3QgdGhhdCB0aGVyZSB3YXMgbm8gaW5pdGlhbCB2YWx1ZSxcblx0XHRcdFx0Ly8gYW5kIHBvcHVsYXRlIGl0IHVzaW5nIGFueSBgY2hlY2tlZGAgYXR0cmlidXRlcyB0aGF0XG5cdFx0XHRcdC8vIGV4aXN0ICh3aGljaCB1c2VycyBzaG91bGQgYXZvaWQsIGJ1dCB3aGljaCB3ZSBzaG91bGRcblx0XHRcdFx0Ly8gc3VwcG9ydCBhbnl3YXkgdG8gYXZvaWQgYnJlYWtpbmcgZXhwZWN0YXRpb25zKVxuXHRcdFx0XHR0aGlzLm5vSW5pdGlhbFZhbHVlID0gdHJ1ZTtcblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fSxcblx0XHRcdGluaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZXhpc3RpbmdWYWx1ZSwgYmluZGluZ1ZhbHVlO1xuXHRcdFx0XHR0aGlzLmNoZWNrYm94TmFtZSA9IHRydWU7XG5cdFx0XHRcdC8vIHNvIHRoYXQgcmFjdGl2ZS51cGRhdGVNb2RlbCgpIGtub3dzIHdoYXQgdG8gZG8gd2l0aCB0aGlzXG5cdFx0XHRcdHRoaXMuYXR0cmlidXRlLnR3b3dheSA9IHRydWU7XG5cdFx0XHRcdC8vIHdlIHNldCB0aGlzIHByb3BlcnR5IHNvIHRoYXQgdGhlIGF0dHJpYnV0ZSBnZXRzIHRoZSBjb3JyZWN0IHVwZGF0ZSBtZXRob2Rcblx0XHRcdFx0Ly8gRWFjaCBpbnB1dCBoYXMgYSByZWZlcmVuY2UgdG8gYW4gYXJyYXkgY29udGFpbmluZyBpdCBhbmQgaXRzXG5cdFx0XHRcdC8vIHNpYmxpbmdzLCBhcyB0d28td2F5IGJpbmRpbmcgZGVwZW5kcyBvbiBiZWluZyBhYmxlIHRvIGFzY2VydGFpblxuXHRcdFx0XHQvLyB0aGUgc3RhdHVzIG9mIGFsbCBpbnB1dHMgd2l0aGluIHRoZSBncm91cFxuXHRcdFx0XHR0aGlzLnNpYmxpbmdzID0gZ2V0U2libGluZ3MoIHRoaXMucm9vdC5fZ3VpZCwgJ2NoZWNrYm94ZXMnLCB0aGlzLmtleXBhdGggKTtcblx0XHRcdFx0dGhpcy5zaWJsaW5ncy5wdXNoKCB0aGlzICk7XG5cdFx0XHRcdGlmICggdGhpcy5ub0luaXRpYWxWYWx1ZSApIHtcblx0XHRcdFx0XHR0aGlzLnNpYmxpbmdzLm5vSW5pdGlhbFZhbHVlID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBJZiBubyBpbml0aWFsIHZhbHVlIHdhcyBzZXQsIGFuZCB0aGlzIGlucHV0IGlzIGNoZWNrZWQsIHdlXG5cdFx0XHRcdC8vIHVwZGF0ZSB0aGUgbW9kZWxcblx0XHRcdFx0aWYgKCB0aGlzLnNpYmxpbmdzLm5vSW5pdGlhbFZhbHVlICYmIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdjaGVja2VkJyApICkge1xuXHRcdFx0XHRcdGV4aXN0aW5nVmFsdWUgPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldCggdGhpcy5rZXlwYXRoICk7XG5cdFx0XHRcdFx0YmluZGluZ1ZhbHVlID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdFx0XHRcdGV4aXN0aW5nVmFsdWUucHVzaCggYmluZGluZ1ZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1bmJpbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZW1vdmVGcm9tQXJyYXkoIHRoaXMuc2libGluZ3MsIHRoaXMgKTtcblx0XHRcdH0sXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlLFxuXHRcdFx0XHRcdGV4aXN0aW5nVmFsdWUsIGJpbmRpbmdWYWx1ZTtcblx0XHRcdFx0ZXhpc3RpbmdWYWx1ZSA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KCB0aGlzLmtleXBhdGggKTtcblx0XHRcdFx0YmluZGluZ1ZhbHVlID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdFx0XHRpZiAoIGlzQXJyYXkoIGV4aXN0aW5nVmFsdWUgKSApIHtcblx0XHRcdFx0XHR0aGlzLmlzQ2hlY2tlZCA9IGFycmF5Q29udGFpbnMoIGV4aXN0aW5nVmFsdWUsIGJpbmRpbmdWYWx1ZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuaXNDaGVja2VkID0gZXhpc3RpbmdWYWx1ZSA9PSBiaW5kaW5nVmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0bm9kZS5uYW1lID0gJ3t7JyArIHRoaXMua2V5cGF0aCArICd9fSc7XG5cdFx0XHRcdG5vZGUuY2hlY2tlZCA9IHRoaXMuaXNDaGVja2VkO1xuXHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0Ly8gaW4gY2FzZSBvZiBJRSBlbWVyZ2VuY3ksIGJpbmQgdG8gY2xpY2sgZXZlbnQgYXMgd2VsbFxuXHRcdFx0XHRpZiAoIG5vZGUuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnY2xpY2snLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVucmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NsaWNrJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHR9LFxuXHRcdFx0Y2hhbmdlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB3YXNDaGVja2VkID0gISF0aGlzLmlzQ2hlY2tlZDtcblx0XHRcdFx0dGhpcy5pc0NoZWNrZWQgPSB0aGlzLmVsZW1lbnQubm9kZS5jaGVja2VkO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5pc0NoZWNrZWQgPT09IHdhc0NoZWNrZWQ7XG5cdFx0XHR9LFxuXHRcdFx0aGFuZGxlQ2hhbmdlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5pc0NoZWNrZWQgPSB0aGlzLmVsZW1lbnQubm9kZS5jaGVja2VkO1xuXHRcdFx0XHRCaW5kaW5nLnByb3RvdHlwZS5oYW5kbGVDaGFuZ2UuY2FsbCggdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdGdldFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2libGluZ3MuZmlsdGVyKCBpc0NoZWNrZWQgKS5tYXAoIGdldFZhbHVlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdFx0ZnVuY3Rpb24gaXNDaGVja2VkKCBiaW5kaW5nICkge1xuXHRcdFx0cmV0dXJuIGJpbmRpbmcuaXNDaGVja2VkO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFZhbHVlKCBiaW5kaW5nICkge1xuXHRcdFx0cmV0dXJuIGJpbmRpbmcuZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcblx0XHR9XG5cdFx0cmV0dXJuIENoZWNrYm94TmFtZUJpbmRpbmc7XG5cdH0oIGlzQXJyYXksIGFycmF5Q29udGFpbnMsIHJlbW92ZUZyb21BcnJheSwgQmluZGluZywgZ2V0U2libGluZ3MsIGhhbmRsZURvbUV2ZW50ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0JpbmRpbmcvQ2hlY2tib3hCaW5kaW5nLmpzICovXG5cdHZhciBDaGVja2JveEJpbmRpbmcgPSBmdW5jdGlvbiggQmluZGluZywgaGFuZGxlRG9tRXZlbnQgKSB7XG5cblx0XHR2YXIgQ2hlY2tib3hCaW5kaW5nID0gQmluZGluZy5leHRlbmQoIHtcblx0XHRcdG5hbWU6ICdjaGVja2VkJyxcblx0XHRcdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRpZiAoIG5vZGUuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnY2xpY2snLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVucmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NsaWNrJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50Lm5vZGUuY2hlY2tlZDtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIENoZWNrYm94QmluZGluZztcblx0fSggQmluZGluZywgaGFuZGxlRG9tRXZlbnQgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9TZWxlY3RCaW5kaW5nLmpzICovXG5cdHZhciBTZWxlY3RCaW5kaW5nID0gZnVuY3Rpb24oIHJ1bmxvb3AsIEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50ICkge1xuXG5cdFx0dmFyIFNlbGVjdEJpbmRpbmcgPSBCaW5kaW5nLmV4dGVuZCgge1xuXHRcdFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLmVsZW1lbnQub3B0aW9ucyxcblx0XHRcdFx0XHRsZW4sIGksIHZhbHVlLCBvcHRpb25XYXNTZWxlY3RlZDtcblx0XHRcdFx0aWYgKCB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndmFsdWUnICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aSA9IGxlbiA9IG9wdGlvbnMubGVuZ3RoO1xuXHRcdFx0XHRpZiAoICFsZW4gKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHRha2UgdGhlIGZpbmFsIHNlbGVjdGVkIG9wdGlvbi4uLlxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIG9wdGlvbnNbIGkgXS5nZXRBdHRyaWJ1dGUoICdzZWxlY3RlZCcgKSApIHtcblx0XHRcdFx0XHRcdHZhbHVlID0gb3B0aW9uc1sgaSBdLmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdFx0XHRcdFx0b3B0aW9uV2FzU2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIG9yIHRoZSBmaXJzdCBub24tZGlzYWJsZWQgb3B0aW9uLCBpZiBub25lIGFyZSBzZWxlY3RlZFxuXHRcdFx0XHRpZiAoICFvcHRpb25XYXNTZWxlY3RlZCApIHtcblx0XHRcdFx0XHR3aGlsZSAoICsraSA8IGxlbiApIHtcblx0XHRcdFx0XHRcdGlmICggIW9wdGlvbnNbIGkgXS5nZXRBdHRyaWJ1dGUoICdkaXNhYmxlZCcgKSApIHtcblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBvcHRpb25zWyBpIF0uZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBUaGlzIGlzIGFuIG9wdGltaXNhdGlvbiAoYWthIGhhY2spIHRoYXQgYWxsb3dzIHVzIHRvIGZvcmdvIHNvbWVcblx0XHRcdFx0Ly8gb3RoZXIgbW9yZSBleHBlbnNpdmUgd29ya1xuXHRcdFx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGhpcy5lbGVtZW50LmF0dHJpYnV0ZXMudmFsdWUudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHR9LFxuXHRcdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50Lm5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0fSxcblx0XHRcdHVucmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50Lm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0fSxcblx0XHRcdC8vIFRPRE8gdGhpcyBtZXRob2QgaXMgYW4gYW5vbWFseS4uLiBpcyBpdCBuZWNlc3Nhcnk/XG5cdFx0XHRzZXRWYWx1ZTogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRydW5sb29wLmFkZFZpZXdtb2RlbCggdGhpcy5yb290LnZpZXdtb2RlbCApO1xuXHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCggdGhpcy5rZXlwYXRoLCB2YWx1ZSApO1xuXHRcdFx0fSxcblx0XHRcdGdldFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG9wdGlvbnMsIGksIGxlbiwgb3B0aW9uLCBvcHRpb25WYWx1ZTtcblx0XHRcdFx0b3B0aW9ucyA9IHRoaXMuZWxlbWVudC5ub2RlLm9wdGlvbnM7XG5cdFx0XHRcdGxlbiA9IG9wdGlvbnMubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblx0XHRcdFx0XHRpZiAoIG9wdGlvbnNbIGkgXS5zZWxlY3RlZCApIHtcblx0XHRcdFx0XHRcdG9wdGlvblZhbHVlID0gb3B0aW9uLl9yYWN0aXZlID8gb3B0aW9uLl9yYWN0aXZlLnZhbHVlIDogb3B0aW9uLnZhbHVlO1xuXHRcdFx0XHRcdFx0cmV0dXJuIG9wdGlvblZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGZvcmNlVXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblx0XHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRoaXMuYXR0cmlidXRlLmxvY2tlZCA9IHRydWU7XG5cdFx0XHRcdFx0cnVubG9vcC5hZGRWaWV3bW9kZWwoIHRoaXMucm9vdC52aWV3bW9kZWwgKTtcblx0XHRcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcyQwLmF0dHJpYnV0ZS5sb2NrZWQgPSBmYWxzZTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQoIHRoaXMua2V5cGF0aCwgdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gU2VsZWN0QmluZGluZztcblx0fSggcnVubG9vcCwgQmluZGluZywgaGFuZGxlRG9tRXZlbnQgKTtcblxuXHQvKiB1dGlscy9hcnJheUNvbnRlbnRzTWF0Y2guanMgKi9cblx0dmFyIGFycmF5Q29udGVudHNNYXRjaCA9IGZ1bmN0aW9uKCBpc0FycmF5ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0dmFyIGk7XG5cdFx0XHRpZiAoICFpc0FycmF5KCBhICkgfHwgIWlzQXJyYXkoIGIgKSApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBhLmxlbmd0aCAhPT0gYi5sZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGkgPSBhLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIGFbIGkgXSAhPT0gYlsgaSBdICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblx0fSggaXNBcnJheSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9CaW5kaW5nL011bHRpcGxlU2VsZWN0QmluZGluZy5qcyAqL1xuXHR2YXIgTXVsdGlwbGVTZWxlY3RCaW5kaW5nID0gZnVuY3Rpb24oIHJ1bmxvb3AsIGFycmF5Q29udGVudHNNYXRjaCwgU2VsZWN0QmluZGluZywgaGFuZGxlRG9tRXZlbnQgKSB7XG5cblx0XHR2YXIgTXVsdGlwbGVTZWxlY3RCaW5kaW5nID0gU2VsZWN0QmluZGluZy5leHRlbmQoIHtcblx0XHRcdGdldEluaXRpYWxWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmVsZW1lbnQub3B0aW9ucy5maWx0ZXIoIGZ1bmN0aW9uKCBvcHRpb24gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wdGlvbi5nZXRBdHRyaWJ1dGUoICdzZWxlY3RlZCcgKTtcblx0XHRcdFx0fSApLm1hcCggZnVuY3Rpb24oIG9wdGlvbiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb3B0aW9uLmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9LFxuXHRcdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHZhbHVlRnJvbU1vZGVsO1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQubm9kZS5hZGRFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdHZhbHVlRnJvbU1vZGVsID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQoIHRoaXMua2V5cGF0aCApO1xuXHRcdFx0XHRpZiAoIHZhbHVlRnJvbU1vZGVsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0Ly8gZ2V0IHZhbHVlIGZyb20gRE9NLCBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdHRoaXMuaGFuZGxlQ2hhbmdlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdH0sXG5cdFx0XHRzZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RPRE8gbm90IGltcGxlbWVudGVkIHlldCcgKTtcblx0XHRcdH0sXG5cdFx0XHRnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBzZWxlY3RlZFZhbHVlcywgb3B0aW9ucywgaSwgbGVuLCBvcHRpb24sIG9wdGlvblZhbHVlO1xuXHRcdFx0XHRzZWxlY3RlZFZhbHVlcyA9IFtdO1xuXHRcdFx0XHRvcHRpb25zID0gdGhpcy5lbGVtZW50Lm5vZGUub3B0aW9ucztcblx0XHRcdFx0bGVuID0gb3B0aW9ucy5sZW5ndGg7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXHRcdFx0XHRcdGlmICggb3B0aW9uLnNlbGVjdGVkICkge1xuXHRcdFx0XHRcdFx0b3B0aW9uVmFsdWUgPSBvcHRpb24uX3JhY3RpdmUgPyBvcHRpb24uX3JhY3RpdmUudmFsdWUgOiBvcHRpb24udmFsdWU7XG5cdFx0XHRcdFx0XHRzZWxlY3RlZFZhbHVlcy5wdXNoKCBvcHRpb25WYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2VsZWN0ZWRWYWx1ZXM7XG5cdFx0XHR9LFxuXHRcdFx0aGFuZGxlQ2hhbmdlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGF0dHJpYnV0ZSwgcHJldmlvdXNWYWx1ZSwgdmFsdWU7XG5cdFx0XHRcdGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlO1xuXHRcdFx0XHRwcmV2aW91c1ZhbHVlID0gYXR0cmlidXRlLnZhbHVlO1xuXHRcdFx0XHR2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblx0XHRcdFx0aWYgKCBwcmV2aW91c1ZhbHVlID09PSB1bmRlZmluZWQgfHwgIWFycmF5Q29udGVudHNNYXRjaCggdmFsdWUsIHByZXZpb3VzVmFsdWUgKSApIHtcblx0XHRcdFx0XHRTZWxlY3RCaW5kaW5nLnByb3RvdHlwZS5oYW5kbGVDaGFuZ2UuY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGZvcmNlVXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblx0XHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRoaXMuYXR0cmlidXRlLmxvY2tlZCA9IHRydWU7XG5cdFx0XHRcdFx0cnVubG9vcC5hZGRWaWV3bW9kZWwoIHRoaXMucm9vdC52aWV3bW9kZWwgKTtcblx0XHRcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcyQwLmF0dHJpYnV0ZS5sb2NrZWQgPSBmYWxzZTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQoIHRoaXMua2V5cGF0aCwgdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVwZGF0ZU1vZGVsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLmF0dHJpYnV0ZS52YWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICF0aGlzLmF0dHJpYnV0ZS52YWx1ZS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQoIHRoaXMua2V5cGF0aCwgdGhpcy5pbml0aWFsVmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gTXVsdGlwbGVTZWxlY3RCaW5kaW5nO1xuXHR9KCBydW5sb29wLCBhcnJheUNvbnRlbnRzTWF0Y2gsIFNlbGVjdEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0JpbmRpbmcvRmlsZUxpc3RCaW5kaW5nLmpzICovXG5cdHZhciBGaWxlTGlzdEJpbmRpbmcgPSBmdW5jdGlvbiggQmluZGluZywgaGFuZGxlRG9tRXZlbnQgKSB7XG5cblx0XHR2YXIgRmlsZUxpc3RCaW5kaW5nID0gQmluZGluZy5leHRlbmQoIHtcblx0XHRcdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdH0sXG5cdFx0XHRnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmVsZW1lbnQubm9kZS5maWxlcztcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIEZpbGVMaXN0QmluZGluZztcblx0fSggQmluZGluZywgaGFuZGxlRG9tRXZlbnQgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9HZW5lcmljQmluZGluZy5qcyAqL1xuXHR2YXIgR2VuZXJpY0JpbmRpbmcgPSBmdW5jdGlvbiggQmluZGluZywgaGFuZGxlRG9tRXZlbnQgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIEdlbmVyaWNCaW5kaW5nLCBnZXRPcHRpb25zO1xuXHRcdGdldE9wdGlvbnMgPSB7XG5cdFx0XHRldmFsdWF0ZVdyYXBwZWQ6IHRydWVcblx0XHR9O1xuXHRcdEdlbmVyaWNCaW5kaW5nID0gQmluZGluZy5leHRlbmQoIHtcblx0XHRcdGdldEluaXRpYWxWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAnJztcblx0XHRcdH0sXG5cdFx0XHRnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmVsZW1lbnQubm9kZS52YWx1ZTtcblx0XHRcdH0sXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0aWYgKCAhdGhpcy5yb290LmxhenkgKSB7XG5cdFx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnaW5wdXQnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0XHRpZiAoIG5vZGUuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdrZXl1cCcsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdibHVyJywgaGFuZGxlQmx1ciwgZmFsc2UgKTtcblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdpbnB1dCcsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdrZXl1cCcsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdibHVyJywgaGFuZGxlQmx1ciwgZmFsc2UgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0X19leHBvcnQgPSBHZW5lcmljQmluZGluZztcblxuXHRcdGZ1bmN0aW9uIGhhbmRsZUJsdXIoKSB7XG5cdFx0XHR2YXIgdmFsdWU7XG5cdFx0XHRoYW5kbGVEb21FdmVudC5jYWxsKCB0aGlzICk7XG5cdFx0XHR2YWx1ZSA9IHRoaXMuX3JhY3RpdmUucm9vdC52aWV3bW9kZWwuZ2V0KCB0aGlzLl9yYWN0aXZlLmJpbmRpbmcua2V5cGF0aCwgZ2V0T3B0aW9ucyApO1xuXHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlID09IHVuZGVmaW5lZCA/ICcnIDogdmFsdWU7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggQmluZGluZywgaGFuZGxlRG9tRXZlbnQgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9OdW1lcmljQmluZGluZy5qcyAqL1xuXHR2YXIgTnVtZXJpY0JpbmRpbmcgPSBmdW5jdGlvbiggR2VuZXJpY0JpbmRpbmcgKSB7XG5cblx0XHRyZXR1cm4gR2VuZXJpY0JpbmRpbmcuZXh0ZW5kKCB7XG5cdFx0XHRnZXRJbml0aWFsVmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0fSxcblx0XHRcdGdldFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gcGFyc2VGbG9hdCggdGhpcy5lbGVtZW50Lm5vZGUudmFsdWUgKTtcblx0XHRcdFx0cmV0dXJuIGlzTmFOKCB2YWx1ZSApID8gdW5kZWZpbmVkIDogdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9KCBHZW5lcmljQmluZGluZyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvaW5pdC9jcmVhdGVUd293YXlCaW5kaW5nLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkaW5pdF9jcmVhdGVUd293YXlCaW5kaW5nID0gZnVuY3Rpb24oIGxvZywgQ29udGVudEVkaXRhYmxlQmluZGluZywgUmFkaW9CaW5kaW5nLCBSYWRpb05hbWVCaW5kaW5nLCBDaGVja2JveE5hbWVCaW5kaW5nLCBDaGVja2JveEJpbmRpbmcsIFNlbGVjdEJpbmRpbmcsIE11bHRpcGxlU2VsZWN0QmluZGluZywgRmlsZUxpc3RCaW5kaW5nLCBOdW1lcmljQmluZGluZywgR2VuZXJpY0JpbmRpbmcgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBjcmVhdGVUd293YXlCaW5kaW5nKCBlbGVtZW50ICkge1xuXHRcdFx0dmFyIGF0dHJpYnV0ZXMgPSBlbGVtZW50LmF0dHJpYnV0ZXMsXG5cdFx0XHRcdHR5cGUsIEJpbmRpbmcsIGJpbmROYW1lLCBiaW5kQ2hlY2tlZDtcblx0XHRcdC8vIGlmIHRoaXMgaXMgYSBsYXRlIGJpbmRpbmcsIGFuZCB0aGVyZSdzIGFscmVhZHkgb25lLCBpdFxuXHRcdFx0Ly8gbmVlZHMgdG8gYmUgdG9ybiBkb3duXG5cdFx0XHRpZiAoIGVsZW1lbnQuYmluZGluZyApIHtcblx0XHRcdFx0ZWxlbWVudC5iaW5kaW5nLnRlYXJkb3duKCk7XG5cdFx0XHRcdGVsZW1lbnQuYmluZGluZyA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHQvLyBjb250ZW50ZWRpdGFibGVcblx0XHRcdGlmICggLy8gaWYgdGhlIGNvbnRlbnRlZGl0YWJsZSBhdHRyaWJ1dGUgaXMgdHJ1ZSBvciBpcyBiaW5kYWJsZSBhbmQgbWF5IHRodXMgYmVjb21lIHRydWVcblx0XHRcdFx0KCBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ2NvbnRlbnRlZGl0YWJsZScgKSB8fCAhIWF0dHJpYnV0ZXMuY29udGVudGVkaXRhYmxlICYmIGlzQmluZGFibGUoIGF0dHJpYnV0ZXMuY29udGVudGVkaXRhYmxlICkgKSAmJiBpc0JpbmRhYmxlKCBhdHRyaWJ1dGVzLnZhbHVlICkgKSB7XG5cdFx0XHRcdEJpbmRpbmcgPSBDb250ZW50RWRpdGFibGVCaW5kaW5nO1xuXHRcdFx0fSBlbHNlIGlmICggZWxlbWVudC5uYW1lID09PSAnaW5wdXQnICkge1xuXHRcdFx0XHR0eXBlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd0eXBlJyApO1xuXHRcdFx0XHRpZiAoIHR5cGUgPT09ICdyYWRpbycgfHwgdHlwZSA9PT0gJ2NoZWNrYm94JyApIHtcblx0XHRcdFx0XHRiaW5kTmFtZSA9IGlzQmluZGFibGUoIGF0dHJpYnV0ZXMubmFtZSApO1xuXHRcdFx0XHRcdGJpbmRDaGVja2VkID0gaXNCaW5kYWJsZSggYXR0cmlidXRlcy5jaGVja2VkICk7XG5cdFx0XHRcdFx0Ly8gd2UgY2FuIGVpdGhlciBiaW5kIHRoZSBuYW1lIGF0dHJpYnV0ZSwgb3IgdGhlIGNoZWNrZWQgYXR0cmlidXRlIC0gbm90IGJvdGhcblx0XHRcdFx0XHRpZiAoIGJpbmROYW1lICYmIGJpbmRDaGVja2VkICkge1xuXHRcdFx0XHRcdFx0bG9nLmVycm9yKCB7XG5cdFx0XHRcdFx0XHRcdG1lc3NhZ2U6ICdiYWRSYWRpb0lucHV0QmluZGluZydcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBiaW5kTmFtZSApIHtcblx0XHRcdFx0XHRcdEJpbmRpbmcgPSB0eXBlID09PSAncmFkaW8nID8gUmFkaW9OYW1lQmluZGluZyA6IENoZWNrYm94TmFtZUJpbmRpbmc7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggYmluZENoZWNrZWQgKSB7XG5cdFx0XHRcdFx0XHRCaW5kaW5nID0gdHlwZSA9PT0gJ3JhZGlvJyA/IFJhZGlvQmluZGluZyA6IENoZWNrYm94QmluZGluZztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09ICdmaWxlJyAmJiBpc0JpbmRhYmxlKCBhdHRyaWJ1dGVzLnZhbHVlICkgKSB7XG5cdFx0XHRcdFx0QmluZGluZyA9IEZpbGVMaXN0QmluZGluZztcblx0XHRcdFx0fSBlbHNlIGlmICggaXNCaW5kYWJsZSggYXR0cmlidXRlcy52YWx1ZSApICkge1xuXHRcdFx0XHRcdEJpbmRpbmcgPSB0eXBlID09PSAnbnVtYmVyJyB8fCB0eXBlID09PSAncmFuZ2UnID8gTnVtZXJpY0JpbmRpbmcgOiBHZW5lcmljQmluZGluZztcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICggZWxlbWVudC5uYW1lID09PSAnc2VsZWN0JyAmJiBpc0JpbmRhYmxlKCBhdHRyaWJ1dGVzLnZhbHVlICkgKSB7XG5cdFx0XHRcdEJpbmRpbmcgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ211bHRpcGxlJyApID8gTXVsdGlwbGVTZWxlY3RCaW5kaW5nIDogU2VsZWN0QmluZGluZztcblx0XHRcdH0gZWxzZSBpZiAoIGVsZW1lbnQubmFtZSA9PT0gJ3RleHRhcmVhJyAmJiBpc0JpbmRhYmxlKCBhdHRyaWJ1dGVzLnZhbHVlICkgKSB7XG5cdFx0XHRcdEJpbmRpbmcgPSBHZW5lcmljQmluZGluZztcblx0XHRcdH1cblx0XHRcdGlmICggQmluZGluZyApIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBCaW5kaW5nKCBlbGVtZW50ICk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGlzQmluZGFibGUoIGF0dHJpYnV0ZSApIHtcblx0XHRcdHJldHVybiBhdHRyaWJ1dGUgJiYgYXR0cmlidXRlLmlzQmluZGFibGU7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggbG9nLCBDb250ZW50RWRpdGFibGVCaW5kaW5nLCBSYWRpb0JpbmRpbmcsIFJhZGlvTmFtZUJpbmRpbmcsIENoZWNrYm94TmFtZUJpbmRpbmcsIENoZWNrYm94QmluZGluZywgU2VsZWN0QmluZGluZywgTXVsdGlwbGVTZWxlY3RCaW5kaW5nLCBGaWxlTGlzdEJpbmRpbmcsIE51bWVyaWNCaW5kaW5nLCBHZW5lcmljQmluZGluZyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9FdmVudEhhbmRsZXIvcHJvdG90eXBlL2J1YmJsZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciRidWJibGUgPSBmdW5jdGlvbiBFdmVudEhhbmRsZXIkYnViYmxlKCkge1xuXHRcdHZhciBoYXNBY3Rpb24gPSB0aGlzLmdldEFjdGlvbigpO1xuXHRcdGlmICggaGFzQWN0aW9uICYmICF0aGlzLmhhc0xpc3RlbmVyICkge1xuXHRcdFx0dGhpcy5saXN0ZW4oKTtcblx0XHR9IGVsc2UgaWYgKCAhaGFzQWN0aW9uICYmIHRoaXMuaGFzTGlzdGVuZXIgKSB7XG5cdFx0XHR0aGlzLnVucmVuZGVyKCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9FdmVudEhhbmRsZXIvcHJvdG90eXBlL2ZpcmUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkZmlyZSA9IGZ1bmN0aW9uKCBmaXJlRXZlbnQgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gRXZlbnRIYW5kbGVyJGZpcmUoIGV2ZW50ICkge1xuXHRcdFx0ZmlyZUV2ZW50KCB0aGlzLnJvb3QsIHRoaXMuZ2V0QWN0aW9uKCksIHtcblx0XHRcdFx0ZXZlbnQ6IGV2ZW50XG5cdFx0XHR9ICk7XG5cdFx0fTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfZmlyZUV2ZW50ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0V2ZW50SGFuZGxlci9wcm90b3R5cGUvZ2V0QWN0aW9uLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJGdldEFjdGlvbiA9IGZ1bmN0aW9uIEV2ZW50SGFuZGxlciRnZXRBY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWN0aW9uLnRvU3RyaW5nKCkudHJpbSgpO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9FdmVudEhhbmRsZXIvcHJvdG90eXBlL2luaXQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkaW5pdCA9IGZ1bmN0aW9uKCBnZXRGdW5jdGlvbkZyb21TdHJpbmcsIGNyZWF0ZVJlZmVyZW5jZVJlc29sdmVyLCBjaXJjdWxhciwgZmlyZUV2ZW50LCBsb2cgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIEZyYWdtZW50LCBnZXRWYWx1ZU9wdGlvbnMgPSB7XG5cdFx0XHRcdGFyZ3M6IHRydWVcblx0XHRcdH0sXG5cdFx0XHRldmVudFBhdHRlcm4gPSAvXmV2ZW50KD86XFwuKC4rKSk/Lztcblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdEZyYWdtZW50ID0gY2lyY3VsYXIuRnJhZ21lbnQ7XG5cdFx0fSApO1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gRXZlbnRIYW5kbGVyJGluaXQoIGVsZW1lbnQsIG5hbWUsIHRlbXBsYXRlICkge1xuXHRcdFx0dmFyIGhhbmRsZXIgPSB0aGlzLFxuXHRcdFx0XHRhY3Rpb24sIHJlZnMsIHJhY3RpdmU7XG5cdFx0XHRoYW5kbGVyLmVsZW1lbnQgPSBlbGVtZW50O1xuXHRcdFx0aGFuZGxlci5yb290ID0gZWxlbWVudC5yb290O1xuXHRcdFx0aGFuZGxlci5uYW1lID0gbmFtZTtcblx0XHRcdGlmICggbmFtZS5pbmRleE9mKCAnKicgKSAhPT0gLTEgKSB7XG5cdFx0XHRcdGxvZy5lcnJvcigge1xuXHRcdFx0XHRcdGRlYnVnOiB0aGlzLnJvb3QuZGVidWcsXG5cdFx0XHRcdFx0bWVzc2FnZTogJ25vRWxlbWVudFByb3h5RXZlbnRXaWxkY2FyZHMnLFxuXHRcdFx0XHRcdGFyZ3M6IHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6IGVsZW1lbnQudGFnTmFtZSxcblx0XHRcdFx0XHRcdGV2ZW50OiBuYW1lXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHRoaXMuaW52YWxpZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRlbXBsYXRlLm0gKSB7XG5cdFx0XHRcdHJlZnMgPSB0ZW1wbGF0ZS5hLnI7XG5cdFx0XHRcdC8vIFRoaXMgaXMgYSBtZXRob2QgY2FsbFxuXHRcdFx0XHRoYW5kbGVyLm1ldGhvZCA9IHRlbXBsYXRlLm07XG5cdFx0XHRcdGhhbmRsZXIua2V5cGF0aHMgPSBbXTtcblx0XHRcdFx0aGFuZGxlci5mbiA9IGdldEZ1bmN0aW9uRnJvbVN0cmluZyggdGVtcGxhdGUuYS5zLCByZWZzLmxlbmd0aCApO1xuXHRcdFx0XHRoYW5kbGVyLnBhcmVudEZyYWdtZW50ID0gZWxlbWVudC5wYXJlbnRGcmFnbWVudDtcblx0XHRcdFx0cmFjdGl2ZSA9IGhhbmRsZXIucm9vdDtcblx0XHRcdFx0Ly8gQ3JlYXRlIHJlc29sdmVycyBmb3IgZWFjaCByZWZlcmVuY2Vcblx0XHRcdFx0aGFuZGxlci5yZWZSZXNvbHZlcnMgPSByZWZzLm1hcCggZnVuY3Rpb24oIHJlZiwgaSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gdGhlIGBldmVudGAgb2JqZWN0XG5cdFx0XHRcdFx0aWYgKCBtYXRjaCA9IGV2ZW50UGF0dGVybi5leGVjKCByZWYgKSApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXIua2V5cGF0aHNbIGkgXSA9IHtcblx0XHRcdFx0XHRcdFx0ZXZlbnRPYmplY3Q6IHRydWUsXG5cdFx0XHRcdFx0XHRcdHJlZmluZW1lbnRzOiBtYXRjaFsgMSBdID8gbWF0Y2hbIDEgXS5zcGxpdCggJy4nICkgOiBbXVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIoIGhhbmRsZXIsIHJlZiwgZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVyLnJlc29sdmUoIGksIGtleXBhdGggKTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0dGhpcy5maXJlID0gZmlyZU1ldGhvZENhbGw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBHZXQgYWN0aW9uICgnZm9vJyBpbiAnb24tY2xpY2s9J2ZvbycpXG5cdFx0XHRcdGFjdGlvbiA9IHRlbXBsYXRlLm4gfHwgdGVtcGxhdGU7XG5cdFx0XHRcdGlmICggdHlwZW9mIGFjdGlvbiAhPT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0YWN0aW9uID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdFx0XHR0ZW1wbGF0ZTogYWN0aW9uLFxuXHRcdFx0XHRcdFx0cm9vdDogdGhpcy5yb290LFxuXHRcdFx0XHRcdFx0b3duZXI6IHRoaXNcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5hY3Rpb24gPSBhY3Rpb247XG5cdFx0XHRcdC8vIEdldCBwYXJhbWV0ZXJzXG5cdFx0XHRcdGlmICggdGVtcGxhdGUuZCApIHtcblx0XHRcdFx0XHR0aGlzLmR5bmFtaWNQYXJhbXMgPSBuZXcgRnJhZ21lbnQoIHtcblx0XHRcdFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZS5kLFxuXHRcdFx0XHRcdFx0cm9vdDogdGhpcy5yb290LFxuXHRcdFx0XHRcdFx0b3duZXI6IHRoaXMuZWxlbWVudFxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR0aGlzLmZpcmUgPSBmaXJlRXZlbnRXaXRoRHluYW1pY1BhcmFtcztcblx0XHRcdFx0fSBlbHNlIGlmICggdGVtcGxhdGUuYSApIHtcblx0XHRcdFx0XHR0aGlzLnBhcmFtcyA9IHRlbXBsYXRlLmE7XG5cdFx0XHRcdFx0dGhpcy5maXJlID0gZmlyZUV2ZW50V2l0aFBhcmFtcztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBmaXJlTWV0aG9kQ2FsbCggZXZlbnQgKSB7XG5cdFx0XHR2YXIgcmFjdGl2ZSwgdmFsdWVzLCBhcmdzO1xuXHRcdFx0cmFjdGl2ZSA9IHRoaXMucm9vdDtcblx0XHRcdGlmICggdHlwZW9mIHJhY3RpdmVbIHRoaXMubWV0aG9kIF0gIT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0F0dGVtcHRlZCB0byBjYWxsIGEgbm9uLWV4aXN0ZW50IG1ldGhvZCAoXCInICsgdGhpcy5tZXRob2QgKyAnXCIpJyApO1xuXHRcdFx0fVxuXHRcdFx0dmFsdWVzID0gdGhpcy5rZXlwYXRocy5tYXAoIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIGxlbiwgaTtcblx0XHRcdFx0aWYgKCBrZXlwYXRoID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0Ly8gbm90IHlldCByZXNvbHZlZFxuXHRcdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gVE9ETyB0aGUgcmVmaW5lbWVudHMgc3R1ZmYgd291bGQgYmUgYmV0dGVyIGhhbmRsZWQgYXQgcGFyc2UgdGltZVxuXHRcdFx0XHRpZiAoIGtleXBhdGguZXZlbnRPYmplY3QgKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBldmVudDtcblx0XHRcdFx0XHRpZiAoIGxlbiA9IGtleXBhdGgucmVmaW5lbWVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZVsga2V5cGF0aC5yZWZpbmVtZW50c1sgaSBdIF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhbHVlID0gcmFjdGl2ZS52aWV3bW9kZWwuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fSApO1xuXHRcdFx0cmFjdGl2ZS5ldmVudCA9IGV2ZW50O1xuXHRcdFx0YXJncyA9IHRoaXMuZm4uYXBwbHkoIG51bGwsIHZhbHVlcyApO1xuXHRcdFx0cmFjdGl2ZVsgdGhpcy5tZXRob2QgXS5hcHBseSggcmFjdGl2ZSwgYXJncyApO1xuXHRcdFx0ZGVsZXRlIHJhY3RpdmUuZXZlbnQ7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZmlyZUV2ZW50V2l0aFBhcmFtcyggZXZlbnQgKSB7XG5cdFx0XHRmaXJlRXZlbnQoIHRoaXMucm9vdCwgdGhpcy5nZXRBY3Rpb24oKSwge1xuXHRcdFx0XHRldmVudDogZXZlbnQsXG5cdFx0XHRcdGFyZ3M6IHRoaXMucGFyYW1zXG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZmlyZUV2ZW50V2l0aER5bmFtaWNQYXJhbXMoIGV2ZW50ICkge1xuXHRcdFx0dmFyIGFyZ3MgPSB0aGlzLmR5bmFtaWNQYXJhbXMuZ2V0VmFsdWUoIGdldFZhbHVlT3B0aW9ucyApO1xuXHRcdFx0Ly8gbmVlZCB0byBzdHJpcCBbXSBmcm9tIGVuZHMgaWYgYSBzdHJpbmchXG5cdFx0XHRpZiAoIHR5cGVvZiBhcmdzID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0YXJncyA9IGFyZ3Muc3Vic3RyKCAxLCBhcmdzLmxlbmd0aCAtIDIgKTtcblx0XHRcdH1cblx0XHRcdGZpcmVFdmVudCggdGhpcy5yb290LCB0aGlzLmdldEFjdGlvbigpLCB7XG5cdFx0XHRcdGV2ZW50OiBldmVudCxcblx0XHRcdFx0YXJnczogYXJnc1xuXHRcdFx0fSApO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIGdldEZ1bmN0aW9uRnJvbVN0cmluZywgY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIsIGNpcmN1bGFyLCBSYWN0aXZlJHNoYXJlZF9maXJlRXZlbnQsIGxvZyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9FdmVudEhhbmRsZXIvc2hhcmVkL2dlbmVyaWNIYW5kbGVyLmpzICovXG5cdHZhciBnZW5lcmljSGFuZGxlciA9IGZ1bmN0aW9uIGdlbmVyaWNIYW5kbGVyKCBldmVudCApIHtcblx0XHR2YXIgc3RvcmFnZSwgaGFuZGxlcjtcblx0XHRzdG9yYWdlID0gdGhpcy5fcmFjdGl2ZTtcblx0XHRoYW5kbGVyID0gc3RvcmFnZS5ldmVudHNbIGV2ZW50LnR5cGUgXTtcblx0XHRoYW5kbGVyLmZpcmUoIHtcblx0XHRcdG5vZGU6IHRoaXMsXG5cdFx0XHRvcmlnaW5hbDogZXZlbnQsXG5cdFx0XHRpbmRleDogc3RvcmFnZS5pbmRleCxcblx0XHRcdGtleXBhdGg6IHN0b3JhZ2Uua2V5cGF0aCxcblx0XHRcdGNvbnRleHQ6IHN0b3JhZ2Uucm9vdC5nZXQoIHN0b3JhZ2Uua2V5cGF0aCApXG5cdFx0fSApO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9FdmVudEhhbmRsZXIvcHJvdG90eXBlL2xpc3Rlbi5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciRsaXN0ZW4gPSBmdW5jdGlvbiggY29uZmlnLCBnZW5lcmljSGFuZGxlciwgbG9nICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBjdXN0b21IYW5kbGVycyA9IHt9LFxuXHRcdFx0dG91Y2hFdmVudHMgPSB7XG5cdFx0XHRcdHRvdWNoc3RhcnQ6IHRydWUsXG5cdFx0XHRcdHRvdWNobW92ZTogdHJ1ZSxcblx0XHRcdFx0dG91Y2hlbmQ6IHRydWUsXG5cdFx0XHRcdHRvdWNoY2FuY2VsOiB0cnVlLFxuXHRcdFx0XHQvL25vdCB3M2MsIGJ1dCBzdXBwb3J0ZWQgaW4gc29tZSBicm93c2Vyc1xuXHRcdFx0XHR0b3VjaGxlYXZlOiB0cnVlXG5cdFx0XHR9O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gRXZlbnRIYW5kbGVyJGxpc3RlbigpIHtcblx0XHRcdHZhciBkZWZpbml0aW9uLCBuYW1lID0gdGhpcy5uYW1lO1xuXHRcdFx0aWYgKCB0aGlzLmludmFsaWQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmICggZGVmaW5pdGlvbiA9IGNvbmZpZy5yZWdpc3RyaWVzLmV2ZW50cy5maW5kKCB0aGlzLnJvb3QsIG5hbWUgKSApIHtcblx0XHRcdFx0dGhpcy5jdXN0b20gPSBkZWZpbml0aW9uKCB0aGlzLm5vZGUsIGdldEN1c3RvbUhhbmRsZXIoIG5hbWUgKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gTG9va3MgbGlrZSB3ZSdyZSBkZWFsaW5nIHdpdGggYSBzdGFuZGFyZCBET00gZXZlbnQuLi4gYnV0IGxldCdzIGNoZWNrXG5cdFx0XHRcdGlmICggISggJ29uJyArIG5hbWUgaW4gdGhpcy5ub2RlICkgJiYgISggd2luZG93ICYmICdvbicgKyBuYW1lIGluIHdpbmRvdyApICkge1xuXHRcdFx0XHRcdC8vIG9rYXkgdG8gdXNlIHRvdWNoIGV2ZW50cyBpZiB0aGlzIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRoZW1cblx0XHRcdFx0XHRpZiAoICF0b3VjaEV2ZW50c1sgbmFtZSBdICkge1xuXHRcdFx0XHRcdFx0bG9nLmVycm9yKCB7XG5cdFx0XHRcdFx0XHRcdGRlYnVnOiB0aGlzLnJvb3QuZGVidWcsXG5cdFx0XHRcdFx0XHRcdG1lc3NhZ2U6ICdtaXNzaW5nUGx1Z2luJyxcblx0XHRcdFx0XHRcdFx0YXJnczoge1xuXHRcdFx0XHRcdFx0XHRcdHBsdWdpbjogJ2V2ZW50Jyxcblx0XHRcdFx0XHRcdFx0XHRuYW1lOiBuYW1lXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKCBuYW1lLCBnZW5lcmljSGFuZGxlciwgZmFsc2UgKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuaGFzTGlzdGVuZXIgPSB0cnVlO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBnZXRDdXN0b21IYW5kbGVyKCBuYW1lICkge1xuXHRcdFx0aWYgKCAhY3VzdG9tSGFuZGxlcnNbIG5hbWUgXSApIHtcblx0XHRcdFx0Y3VzdG9tSGFuZGxlcnNbIG5hbWUgXSA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0XHR2YXIgc3RvcmFnZSA9IGV2ZW50Lm5vZGUuX3JhY3RpdmU7XG5cdFx0XHRcdFx0ZXZlbnQuaW5kZXggPSBzdG9yYWdlLmluZGV4O1xuXHRcdFx0XHRcdGV2ZW50LmtleXBhdGggPSBzdG9yYWdlLmtleXBhdGg7XG5cdFx0XHRcdFx0ZXZlbnQuY29udGV4dCA9IHN0b3JhZ2Uucm9vdC5nZXQoIHN0b3JhZ2Uua2V5cGF0aCApO1xuXHRcdFx0XHRcdHN0b3JhZ2UuZXZlbnRzWyBuYW1lIF0uZmlyZSggZXZlbnQgKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBjdXN0b21IYW5kbGVyc1sgbmFtZSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIGNvbmZpZywgZ2VuZXJpY0hhbmRsZXIsIGxvZyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9FdmVudEhhbmRsZXIvcHJvdG90eXBlL3JlYmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciRyZWJpbmQgPSBmdW5jdGlvbiBFdmVudEhhbmRsZXIkcmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0dmFyIGZyYWdtZW50O1xuXHRcdGlmICggdGhpcy5tZXRob2QgKSB7XG5cdFx0XHRmcmFnbWVudCA9IHRoaXMuZWxlbWVudC5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHRoaXMucmVmUmVzb2x2ZXJzLmZvckVhY2goIHJlYmluZCApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB0aGlzLmFjdGlvbiAhPT0gJ3N0cmluZycgKSB7XG5cdFx0XHRyZWJpbmQoIHRoaXMuYWN0aW9uICk7XG5cdFx0fVxuXHRcdGlmICggdGhpcy5keW5hbWljUGFyYW1zICkge1xuXHRcdFx0cmViaW5kKCB0aGlzLmR5bmFtaWNQYXJhbXMgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWJpbmQoIHRoaW5nICkge1xuXHRcdFx0dGhpbmcgJiYgdGhpbmcucmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0V2ZW50SGFuZGxlci9wcm90b3R5cGUvcmVuZGVyLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJHJlbmRlciA9IGZ1bmN0aW9uIEV2ZW50SGFuZGxlciRyZW5kZXIoKSB7XG5cdFx0dGhpcy5ub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cdFx0Ly8gc3RvcmUgdGhpcyBvbiB0aGUgbm9kZSBpdHNlbGYsIHNvIGl0IGNhbiBiZSByZXRyaWV2ZWQgYnkgYVxuXHRcdC8vIHVuaXZlcnNhbCBoYW5kbGVyXG5cdFx0dGhpcy5ub2RlLl9yYWN0aXZlLmV2ZW50c1sgdGhpcy5uYW1lIF0gPSB0aGlzO1xuXHRcdGlmICggdGhpcy5tZXRob2QgfHwgdGhpcy5nZXRBY3Rpb24oKSApIHtcblx0XHRcdHRoaXMubGlzdGVuKCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9FdmVudEhhbmRsZXIvcHJvdG90eXBlL3Jlc29sdmUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkcmVzb2x2ZSA9IGZ1bmN0aW9uIEV2ZW50SGFuZGxlciRyZXNvbHZlKCBpbmRleCwga2V5cGF0aCApIHtcblx0XHR0aGlzLmtleXBhdGhzWyBpbmRleCBdID0ga2V5cGF0aDtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvRXZlbnRIYW5kbGVyL3Byb3RvdHlwZS91bmJpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkdW5iaW5kID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBFdmVudEhhbmRsZXIkdW5iaW5kKCkge1xuXHRcdFx0aWYgKCB0aGlzLm1ldGhvZCApIHtcblx0XHRcdFx0dGhpcy5yZWZSZXNvbHZlcnMuZm9yRWFjaCggdW5iaW5kICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8vIFRlYXIgZG93biBkeW5hbWljIG5hbWVcblx0XHRcdGlmICggdHlwZW9mIHRoaXMuYWN0aW9uICE9PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0dGhpcy5hY3Rpb24udW5iaW5kKCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBUZWFyIGRvd24gZHluYW1pYyBwYXJhbWV0ZXJzXG5cdFx0XHRpZiAoIHRoaXMuZHluYW1pY1BhcmFtcyApIHtcblx0XHRcdFx0dGhpcy5keW5hbWljUGFyYW1zLnVuYmluZCgpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiB1bmJpbmQoIHggKSB7XG5cdFx0XHR4LnVuYmluZCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvRXZlbnRIYW5kbGVyL3Byb3RvdHlwZS91bnJlbmRlci5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciR1bnJlbmRlciA9IGZ1bmN0aW9uKCBnZW5lcmljSGFuZGxlciApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBFdmVudEhhbmRsZXIkdW5yZW5kZXIoKSB7XG5cdFx0XHRpZiAoIHRoaXMuY3VzdG9tICkge1xuXHRcdFx0XHR0aGlzLmN1c3RvbS50ZWFyZG93bigpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHRoaXMubmFtZSwgZ2VuZXJpY0hhbmRsZXIsIGZhbHNlICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmhhc0xpc3RlbmVyID0gZmFsc2U7XG5cdFx0fTtcblx0fSggZ2VuZXJpY0hhbmRsZXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvRXZlbnRIYW5kbGVyL19FdmVudEhhbmRsZXIuanMgKi9cblx0dmFyIEV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uKCBidWJibGUsIGZpcmUsIGdldEFjdGlvbiwgaW5pdCwgbGlzdGVuLCByZWJpbmQsIHJlbmRlciwgcmVzb2x2ZSwgdW5iaW5kLCB1bnJlbmRlciApIHtcblxuXHRcdHZhciBFdmVudEhhbmRsZXIgPSBmdW5jdGlvbiggZWxlbWVudCwgbmFtZSwgdGVtcGxhdGUgKSB7XG5cdFx0XHR0aGlzLmluaXQoIGVsZW1lbnQsIG5hbWUsIHRlbXBsYXRlICk7XG5cdFx0fTtcblx0XHRFdmVudEhhbmRsZXIucHJvdG90eXBlID0ge1xuXHRcdFx0YnViYmxlOiBidWJibGUsXG5cdFx0XHRmaXJlOiBmaXJlLFxuXHRcdFx0Z2V0QWN0aW9uOiBnZXRBY3Rpb24sXG5cdFx0XHRpbml0OiBpbml0LFxuXHRcdFx0bGlzdGVuOiBsaXN0ZW4sXG5cdFx0XHRyZWJpbmQ6IHJlYmluZCxcblx0XHRcdHJlbmRlcjogcmVuZGVyLFxuXHRcdFx0cmVzb2x2ZTogcmVzb2x2ZSxcblx0XHRcdHVuYmluZDogdW5iaW5kLFxuXHRcdFx0dW5yZW5kZXI6IHVucmVuZGVyXG5cdFx0fTtcblx0XHRyZXR1cm4gRXZlbnRIYW5kbGVyO1xuXHR9KCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJGJ1YmJsZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciRmaXJlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJGdldEFjdGlvbiwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciRpbml0LCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJGxpc3RlbiwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciRyZWJpbmQsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkcmVuZGVyLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJHJlc29sdmUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkdW5iaW5kLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJHVucmVuZGVyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9pbml0L2NyZWF0ZUV2ZW50SGFuZGxlcnMuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRpbml0X2NyZWF0ZUV2ZW50SGFuZGxlcnMgPSBmdW5jdGlvbiggRXZlbnRIYW5kbGVyICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtZW50LCB0ZW1wbGF0ZSApIHtcblx0XHRcdHZhciBpLCBuYW1lLCBuYW1lcywgaGFuZGxlciwgcmVzdWx0ID0gW107XG5cdFx0XHRmb3IgKCBuYW1lIGluIHRlbXBsYXRlICkge1xuXHRcdFx0XHRpZiAoIHRlbXBsYXRlLmhhc093blByb3BlcnR5KCBuYW1lICkgKSB7XG5cdFx0XHRcdFx0bmFtZXMgPSBuYW1lLnNwbGl0KCAnLScgKTtcblx0XHRcdFx0XHRpID0gbmFtZXMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlciA9IG5ldyBFdmVudEhhbmRsZXIoIGVsZW1lbnQsIG5hbWVzWyBpIF0sIHRlbXBsYXRlWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKCBoYW5kbGVyICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cdH0oIEV2ZW50SGFuZGxlciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9EZWNvcmF0b3IvX0RlY29yYXRvci5qcyAqL1xuXHR2YXIgRGVjb3JhdG9yID0gZnVuY3Rpb24oIGxvZywgY2lyY3VsYXIsIGNvbmZpZyApIHtcblxuXHRcdHZhciBGcmFnbWVudCwgZ2V0VmFsdWVPcHRpb25zLCBEZWNvcmF0b3I7XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRGcmFnbWVudCA9IGNpcmN1bGFyLkZyYWdtZW50O1xuXHRcdH0gKTtcblx0XHRnZXRWYWx1ZU9wdGlvbnMgPSB7XG5cdFx0XHRhcmdzOiB0cnVlXG5cdFx0fTtcblx0XHREZWNvcmF0b3IgPSBmdW5jdGlvbiggZWxlbWVudCwgdGVtcGxhdGUgKSB7XG5cdFx0XHR2YXIgZGVjb3JhdG9yID0gdGhpcyxcblx0XHRcdFx0cmFjdGl2ZSwgbmFtZSwgZnJhZ21lbnQ7XG5cdFx0XHRkZWNvcmF0b3IuZWxlbWVudCA9IGVsZW1lbnQ7XG5cdFx0XHRkZWNvcmF0b3Iucm9vdCA9IHJhY3RpdmUgPSBlbGVtZW50LnJvb3Q7XG5cdFx0XHRuYW1lID0gdGVtcGxhdGUubiB8fCB0ZW1wbGF0ZTtcblx0XHRcdGlmICggdHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRmcmFnbWVudCA9IG5ldyBGcmFnbWVudCgge1xuXHRcdFx0XHRcdHRlbXBsYXRlOiBuYW1lLFxuXHRcdFx0XHRcdHJvb3Q6IHJhY3RpdmUsXG5cdFx0XHRcdFx0b3duZXI6IGVsZW1lbnRcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRuYW1lID0gZnJhZ21lbnQudG9TdHJpbmcoKTtcblx0XHRcdFx0ZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRlbXBsYXRlLmEgKSB7XG5cdFx0XHRcdGRlY29yYXRvci5wYXJhbXMgPSB0ZW1wbGF0ZS5hO1xuXHRcdFx0fSBlbHNlIGlmICggdGVtcGxhdGUuZCApIHtcblx0XHRcdFx0ZGVjb3JhdG9yLmZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLmQsXG5cdFx0XHRcdFx0cm9vdDogcmFjdGl2ZSxcblx0XHRcdFx0XHRvd25lcjogZWxlbWVudFxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdGRlY29yYXRvci5wYXJhbXMgPSBkZWNvcmF0b3IuZnJhZ21lbnQuZ2V0VmFsdWUoIGdldFZhbHVlT3B0aW9ucyApO1xuXHRcdFx0XHRkZWNvcmF0b3IuZnJhZ21lbnQuYnViYmxlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dGhpcy5kaXJ0eUFyZ3MgPSB0aGlzLmRpcnR5VmFsdWUgPSB0cnVlO1xuXHRcdFx0XHRcdGRlY29yYXRvci5wYXJhbXMgPSB0aGlzLmdldFZhbHVlKCBnZXRWYWx1ZU9wdGlvbnMgKTtcblx0XHRcdFx0XHRpZiAoIGRlY29yYXRvci5yZWFkeSApIHtcblx0XHRcdFx0XHRcdGRlY29yYXRvci51cGRhdGUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRkZWNvcmF0b3IuZm4gPSBjb25maWcucmVnaXN0cmllcy5kZWNvcmF0b3JzLmZpbmQoIHJhY3RpdmUsIG5hbWUgKTtcblx0XHRcdGlmICggIWRlY29yYXRvci5mbiApIHtcblx0XHRcdFx0bG9nLmVycm9yKCB7XG5cdFx0XHRcdFx0ZGVidWc6IHJhY3RpdmUuZGVidWcsXG5cdFx0XHRcdFx0bWVzc2FnZTogJ21pc3NpbmdQbHVnaW4nLFxuXHRcdFx0XHRcdGFyZ3M6IHtcblx0XHRcdFx0XHRcdHBsdWdpbjogJ2RlY29yYXRvcicsXG5cdFx0XHRcdFx0XHRuYW1lOiBuYW1lXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHREZWNvcmF0b3IucHJvdG90eXBlID0ge1xuXHRcdFx0aW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkZWNvcmF0b3IgPSB0aGlzLFxuXHRcdFx0XHRcdG5vZGUsIHJlc3VsdCwgYXJncztcblx0XHRcdFx0bm9kZSA9IGRlY29yYXRvci5lbGVtZW50Lm5vZGU7XG5cdFx0XHRcdGlmICggZGVjb3JhdG9yLnBhcmFtcyApIHtcblx0XHRcdFx0XHRhcmdzID0gWyBub2RlIF0uY29uY2F0KCBkZWNvcmF0b3IucGFyYW1zICk7XG5cdFx0XHRcdFx0cmVzdWx0ID0gZGVjb3JhdG9yLmZuLmFwcGx5KCBkZWNvcmF0b3Iucm9vdCwgYXJncyApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlc3VsdCA9IGRlY29yYXRvci5mbi5jYWxsKCBkZWNvcmF0b3Iucm9vdCwgbm9kZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIXJlc3VsdCB8fCAhcmVzdWx0LnRlYXJkb3duICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0RlY29yYXRvciBkZWZpbml0aW9uIG11c3QgcmV0dXJuIGFuIG9iamVjdCB3aXRoIGEgdGVhcmRvd24gbWV0aG9kJyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIFRPRE8gZG9lcyB0aGlzIG1ha2Ugc2Vuc2U/XG5cdFx0XHRcdGRlY29yYXRvci5hY3R1YWwgPSByZXN1bHQ7XG5cdFx0XHRcdGRlY29yYXRvci5yZWFkeSA9IHRydWU7XG5cdFx0XHR9LFxuXHRcdFx0dXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLmFjdHVhbC51cGRhdGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5hY3R1YWwudXBkYXRlLmFwcGx5KCB0aGlzLnJvb3QsIHRoaXMucGFyYW1zICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5hY3R1YWwudGVhcmRvd24oIHRydWUgKTtcblx0XHRcdFx0XHR0aGlzLmluaXQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHJlYmluZDogZnVuY3Rpb24oIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuXHRcdFx0XHRcdHRoaXMuZnJhZ21lbnQucmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbiggdXBkYXRpbmcgKSB7XG5cdFx0XHRcdHRoaXMuYWN0dWFsLnRlYXJkb3duKCk7XG5cdFx0XHRcdGlmICggIXVwZGF0aW5nICYmIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIERlY29yYXRvcjtcblx0fSggbG9nLCBjaXJjdWxhciwgY29uZmlnICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3NwZWNpYWwvc2VsZWN0L3N5bmMuanMgKi9cblx0dmFyIHN5bmMgPSBmdW5jdGlvbiggdG9BcnJheSApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIHN5bmNTZWxlY3QoIHNlbGVjdEVsZW1lbnQgKSB7XG5cdFx0XHR2YXIgc2VsZWN0Tm9kZSwgc2VsZWN0VmFsdWUsIGlzTXVsdGlwbGUsIG9wdGlvbnMsIG9wdGlvbldhc1NlbGVjdGVkO1xuXHRcdFx0c2VsZWN0Tm9kZSA9IHNlbGVjdEVsZW1lbnQubm9kZTtcblx0XHRcdGlmICggIXNlbGVjdE5vZGUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdG9wdGlvbnMgPSB0b0FycmF5KCBzZWxlY3ROb2RlLm9wdGlvbnMgKTtcblx0XHRcdHNlbGVjdFZhbHVlID0gc2VsZWN0RWxlbWVudC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcblx0XHRcdGlzTXVsdGlwbGUgPSBzZWxlY3RFbGVtZW50LmdldEF0dHJpYnV0ZSggJ211bHRpcGxlJyApO1xuXHRcdFx0Ly8gSWYgdGhlIDxzZWxlY3Q+IGhhcyBhIHNwZWNpZmllZCB2YWx1ZSwgdGhhdCBzaG91bGQgb3ZlcnJpZGVcblx0XHRcdC8vIHRoZXNlIG9wdGlvbnNcblx0XHRcdGlmICggc2VsZWN0VmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0b3B0aW9ucy5mb3JFYWNoKCBmdW5jdGlvbiggbyApIHtcblx0XHRcdFx0XHR2YXIgb3B0aW9uVmFsdWUsIHNob3VsZFNlbGVjdDtcblx0XHRcdFx0XHRvcHRpb25WYWx1ZSA9IG8uX3JhY3RpdmUgPyBvLl9yYWN0aXZlLnZhbHVlIDogby52YWx1ZTtcblx0XHRcdFx0XHRzaG91bGRTZWxlY3QgPSBpc011bHRpcGxlID8gdmFsdWVDb250YWlucyggc2VsZWN0VmFsdWUsIG9wdGlvblZhbHVlICkgOiBzZWxlY3RWYWx1ZSA9PSBvcHRpb25WYWx1ZTtcblx0XHRcdFx0XHRpZiAoIHNob3VsZFNlbGVjdCApIHtcblx0XHRcdFx0XHRcdG9wdGlvbldhc1NlbGVjdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0by5zZWxlY3RlZCA9IHNob3VsZFNlbGVjdDtcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRpZiAoICFvcHRpb25XYXNTZWxlY3RlZCApIHtcblx0XHRcdFx0XHRpZiAoIG9wdGlvbnNbIDAgXSApIHtcblx0XHRcdFx0XHRcdG9wdGlvbnNbIDAgXS5zZWxlY3RlZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc2VsZWN0RWxlbWVudC5iaW5kaW5nICkge1xuXHRcdFx0XHRcdFx0c2VsZWN0RWxlbWVudC5iaW5kaW5nLmZvcmNlVXBkYXRlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCBzZWxlY3RFbGVtZW50LmJpbmRpbmcgKSB7XG5cdFx0XHRcdHNlbGVjdEVsZW1lbnQuYmluZGluZy5mb3JjZVVwZGF0ZSgpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiB2YWx1ZUNvbnRhaW5zKCBzZWxlY3RWYWx1ZSwgb3B0aW9uVmFsdWUgKSB7XG5cdFx0XHR2YXIgaSA9IHNlbGVjdFZhbHVlLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIHNlbGVjdFZhbHVlWyBpIF0gPT0gb3B0aW9uVmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCB0b0FycmF5ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3NwZWNpYWwvc2VsZWN0L2J1YmJsZS5qcyAqL1xuXHR2YXIgYnViYmxlID0gZnVuY3Rpb24oIHJ1bmxvb3AsIHN5bmNTZWxlY3QgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gYnViYmxlU2VsZWN0KCkge1xuXHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHRpZiAoICF0aGlzLmRpcnR5ICkge1xuXHRcdFx0XHR0aGlzLmRpcnR5ID0gdHJ1ZTtcblx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHN5bmNTZWxlY3QoIHRoaXMkMCApO1xuXHRcdFx0XHRcdHRoaXMkMC5kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnBhcmVudEZyYWdtZW50LmJ1YmJsZSgpO1xuXHRcdH07XG5cdH0oIHJ1bmxvb3AsIHN5bmMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvc3BlY2lhbC9vcHRpb24vZmluZFBhcmVudFNlbGVjdC5qcyAqL1xuXHR2YXIgZmluZFBhcmVudFNlbGVjdCA9IGZ1bmN0aW9uIGZpbmRQYXJlbnRTZWxlY3QoIGVsZW1lbnQgKSB7XG5cdFx0ZG8ge1xuXHRcdFx0aWYgKCBlbGVtZW50Lm5hbWUgPT09ICdzZWxlY3QnICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbWVudDtcblx0XHRcdH1cblx0XHR9IHdoaWxlICggZWxlbWVudCA9IGVsZW1lbnQucGFyZW50ICk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3NwZWNpYWwvb3B0aW9uL2luaXQuanMgKi9cblx0dmFyIGluaXQgPSBmdW5jdGlvbiggZmluZFBhcmVudFNlbGVjdCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBpbml0T3B0aW9uKCBvcHRpb24sIHRlbXBsYXRlICkge1xuXHRcdFx0b3B0aW9uLnNlbGVjdCA9IGZpbmRQYXJlbnRTZWxlY3QoIG9wdGlvbi5wYXJlbnQgKTtcblx0XHRcdC8vIHdlIG1pZ2h0IGJlIGluc2lkZSBhIDxkYXRhbGlzdD4gZWxlbWVudFxuXHRcdFx0aWYgKCAhb3B0aW9uLnNlbGVjdCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0b3B0aW9uLnNlbGVjdC5vcHRpb25zLnB1c2goIG9wdGlvbiApO1xuXHRcdFx0Ly8gSWYgdGhlIHZhbHVlIGF0dHJpYnV0ZSBpcyBtaXNzaW5nLCB1c2UgdGhlIGVsZW1lbnQncyBjb250ZW50XG5cdFx0XHRpZiAoICF0ZW1wbGF0ZS5hICkge1xuXHRcdFx0XHR0ZW1wbGF0ZS5hID0ge307XG5cdFx0XHR9XG5cdFx0XHQvLyAuLi5hcyBsb25nIGFzIGl0IGlzbid0IGRpc2FibGVkXG5cdFx0XHRpZiAoIHRlbXBsYXRlLmEudmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhdGVtcGxhdGUuYS5oYXNPd25Qcm9wZXJ0eSggJ2Rpc2FibGVkJyApICkge1xuXHRcdFx0XHR0ZW1wbGF0ZS5hLnZhbHVlID0gdGVtcGxhdGUuZjtcblx0XHRcdH1cblx0XHRcdC8vIElmIHRoZXJlIGlzIGEgYHNlbGVjdGVkYCBhdHRyaWJ1dGUsIGJ1dCB0aGUgPHNlbGVjdD5cblx0XHRcdC8vIGFscmVhZHkgaGFzIGEgdmFsdWUsIGRlbGV0ZSBpdFxuXHRcdFx0aWYgKCAnc2VsZWN0ZWQnIGluIHRlbXBsYXRlLmEgJiYgb3B0aW9uLnNlbGVjdC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRkZWxldGUgdGVtcGxhdGUuYS5zZWxlY3RlZDtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBmaW5kUGFyZW50U2VsZWN0ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9pbml0LmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkaW5pdCA9IGZ1bmN0aW9uKCB0eXBlcywgZW5mb3JjZUNhc2UsIGNyZWF0ZUF0dHJpYnV0ZXMsIGNyZWF0ZUNvbmRpdGlvbmFsQXR0cmlidXRlcywgY3JlYXRlVHdvd2F5QmluZGluZywgY3JlYXRlRXZlbnRIYW5kbGVycywgRGVjb3JhdG9yLCBidWJibGVTZWxlY3QsIGluaXRPcHRpb24sIGNpcmN1bGFyICkge1xuXG5cdFx0dmFyIEZyYWdtZW50O1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0RnJhZ21lbnQgPSBjaXJjdWxhci5GcmFnbWVudDtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEVsZW1lbnQkaW5pdCggb3B0aW9ucyApIHtcblx0XHRcdHZhciBwYXJlbnRGcmFnbWVudCwgdGVtcGxhdGUsIHJhY3RpdmUsIGJpbmRpbmcsIGJpbmRpbmdzO1xuXHRcdFx0dGhpcy50eXBlID0gdHlwZXMuRUxFTUVOVDtcblx0XHRcdC8vIHN0dWZmIHdlJ2xsIG5lZWQgbGF0ZXJcblx0XHRcdHBhcmVudEZyYWdtZW50ID0gdGhpcy5wYXJlbnRGcmFnbWVudCA9IG9wdGlvbnMucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHR0ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuXHRcdFx0dGhpcy5wYXJlbnQgPSBvcHRpb25zLnBFbGVtZW50IHx8IHBhcmVudEZyYWdtZW50LnBFbGVtZW50O1xuXHRcdFx0dGhpcy5yb290ID0gcmFjdGl2ZSA9IHBhcmVudEZyYWdtZW50LnJvb3Q7XG5cdFx0XHR0aGlzLmluZGV4ID0gb3B0aW9ucy5pbmRleDtcblx0XHRcdHRoaXMubmFtZSA9IGVuZm9yY2VDYXNlKCB0ZW1wbGF0ZS5lICk7XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSA8b3B0aW9uPiBlbGVtZW50c1xuXHRcdFx0aWYgKCB0aGlzLm5hbWUgPT09ICdvcHRpb24nICkge1xuXHRcdFx0XHRpbml0T3B0aW9uKCB0aGlzLCB0ZW1wbGF0ZSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gPHNlbGVjdD4gZWxlbWVudHNcblx0XHRcdGlmICggdGhpcy5uYW1lID09PSAnc2VsZWN0JyApIHtcblx0XHRcdFx0dGhpcy5vcHRpb25zID0gW107XG5cdFx0XHRcdHRoaXMuYnViYmxlID0gYnViYmxlU2VsZWN0O1xuXHRcdFx0fVxuXHRcdFx0Ly8gY3JlYXRlIGF0dHJpYnV0ZXNcblx0XHRcdHRoaXMuYXR0cmlidXRlcyA9IGNyZWF0ZUF0dHJpYnV0ZXMoIHRoaXMsIHRlbXBsYXRlLmEgKTtcblx0XHRcdHRoaXMuY29uZGl0aW9uYWxBdHRyaWJ1dGVzID0gY3JlYXRlQ29uZGl0aW9uYWxBdHRyaWJ1dGVzKCB0aGlzLCB0ZW1wbGF0ZS5tICk7XG5cdFx0XHQvLyBhcHBlbmQgY2hpbGRyZW4sIGlmIHRoZXJlIGFyZSBhbnlcblx0XHRcdGlmICggdGVtcGxhdGUuZiApIHtcblx0XHRcdFx0dGhpcy5mcmFnbWVudCA9IG5ldyBGcmFnbWVudCgge1xuXHRcdFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZS5mLFxuXHRcdFx0XHRcdHJvb3Q6IHJhY3RpdmUsXG5cdFx0XHRcdFx0b3duZXI6IHRoaXMsXG5cdFx0XHRcdFx0cEVsZW1lbnQ6IHRoaXNcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gY3JlYXRlIHR3b3dheSBiaW5kaW5nXG5cdFx0XHRpZiAoIHJhY3RpdmUudHdvd2F5ICYmICggYmluZGluZyA9IGNyZWF0ZVR3b3dheUJpbmRpbmcoIHRoaXMsIHRlbXBsYXRlLmEgKSApICkge1xuXHRcdFx0XHR0aGlzLmJpbmRpbmcgPSBiaW5kaW5nO1xuXHRcdFx0XHQvLyByZWdpc3RlciB0aGlzIHdpdGggdGhlIHJvb3QsIHNvIHRoYXQgd2UgY2FuIGRvIHJhY3RpdmUudXBkYXRlTW9kZWwoKVxuXHRcdFx0XHRiaW5kaW5ncyA9IHRoaXMucm9vdC5fdHdvd2F5QmluZGluZ3NbIGJpbmRpbmcua2V5cGF0aCBdIHx8ICggdGhpcy5yb290Ll90d293YXlCaW5kaW5nc1sgYmluZGluZy5rZXlwYXRoIF0gPSBbXSApO1xuXHRcdFx0XHRiaW5kaW5ncy5wdXNoKCBiaW5kaW5nICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBjcmVhdGUgZXZlbnQgcHJveGllc1xuXHRcdFx0aWYgKCB0ZW1wbGF0ZS52ICkge1xuXHRcdFx0XHR0aGlzLmV2ZW50SGFuZGxlcnMgPSBjcmVhdGVFdmVudEhhbmRsZXJzKCB0aGlzLCB0ZW1wbGF0ZS52ICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBjcmVhdGUgZGVjb3JhdG9yXG5cdFx0XHRpZiAoIHRlbXBsYXRlLm8gKSB7XG5cdFx0XHRcdHRoaXMuZGVjb3JhdG9yID0gbmV3IERlY29yYXRvciggdGhpcywgdGVtcGxhdGUubyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gY3JlYXRlIHRyYW5zaXRpb25zXG5cdFx0XHR0aGlzLmludHJvID0gdGVtcGxhdGUudDAgfHwgdGVtcGxhdGUudDE7XG5cdFx0XHR0aGlzLm91dHJvID0gdGVtcGxhdGUudDAgfHwgdGVtcGxhdGUudDI7XG5cdFx0fTtcblx0fSggdHlwZXMsIGVuZm9yY2VDYXNlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkaW5pdF9jcmVhdGVBdHRyaWJ1dGVzLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkaW5pdF9jcmVhdGVDb25kaXRpb25hbEF0dHJpYnV0ZXMsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRpbml0X2NyZWF0ZVR3b3dheUJpbmRpbmcsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRpbml0X2NyZWF0ZUV2ZW50SGFuZGxlcnMsIERlY29yYXRvciwgYnViYmxlLCBpbml0LCBjaXJjdWxhciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL3V0aWxzL3N0YXJ0c1dpdGguanMgKi9cblx0dmFyIHN0YXJ0c1dpdGggPSBmdW5jdGlvbiggc3RhcnRzV2l0aEtleXBhdGggKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gc3RhcnRzV2l0aCggdGFyZ2V0LCBrZXlwYXRoICkge1xuXHRcdFx0cmV0dXJuIHRhcmdldCA9PT0ga2V5cGF0aCB8fCBzdGFydHNXaXRoS2V5cGF0aCggdGFyZ2V0LCBrZXlwYXRoICk7XG5cdFx0fTtcblx0fSggc3RhcnRzV2l0aEtleXBhdGggKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC91dGlscy9hc3NpZ25OZXdLZXlwYXRoLmpzICovXG5cdHZhciBhc3NpZ25OZXdLZXlwYXRoID0gZnVuY3Rpb24oIHN0YXJ0c1dpdGgsIGdldE5ld0tleXBhdGggKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gYXNzaWduTmV3S2V5cGF0aCggdGFyZ2V0LCBwcm9wZXJ0eSwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdHZhciBleGlzdGluZ0tleXBhdGggPSB0YXJnZXRbIHByb3BlcnR5IF07XG5cdFx0XHRpZiAoICFleGlzdGluZ0tleXBhdGggfHwgc3RhcnRzV2l0aCggZXhpc3RpbmdLZXlwYXRoLCBuZXdLZXlwYXRoICkgfHwgIXN0YXJ0c1dpdGgoIGV4aXN0aW5nS2V5cGF0aCwgb2xkS2V5cGF0aCApICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR0YXJnZXRbIHByb3BlcnR5IF0gPSBnZXROZXdLZXlwYXRoKCBleGlzdGluZ0tleXBhdGgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHR9O1xuXHR9KCBzdGFydHNXaXRoLCBnZXROZXdLZXlwYXRoICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9yZWJpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRyZWJpbmQgPSBmdW5jdGlvbiggYXNzaWduTmV3S2V5cGF0aCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBFbGVtZW50JHJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdFx0dmFyIGksIHN0b3JhZ2UsIGxpdmVRdWVyaWVzLCByYWN0aXZlO1xuXHRcdFx0aWYgKCB0aGlzLmF0dHJpYnV0ZXMgKSB7XG5cdFx0XHRcdHRoaXMuYXR0cmlidXRlcy5mb3JFYWNoKCByZWJpbmQgKTtcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5jb25kaXRpb25hbEF0dHJpYnV0ZXMgKSB7XG5cdFx0XHRcdHRoaXMuY29uZGl0aW9uYWxBdHRyaWJ1dGVzLmZvckVhY2goIHJlYmluZCApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLmV2ZW50SGFuZGxlcnMgKSB7XG5cdFx0XHRcdHRoaXMuZXZlbnRIYW5kbGVycy5mb3JFYWNoKCByZWJpbmQgKTtcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5kZWNvcmF0b3IgKSB7XG5cdFx0XHRcdHJlYmluZCggdGhpcy5kZWNvcmF0b3IgKTtcblx0XHRcdH1cblx0XHRcdC8vIHJlYmluZCBjaGlsZHJlblxuXHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuXHRcdFx0XHRyZWJpbmQoIHRoaXMuZnJhZ21lbnQgKTtcblx0XHRcdH1cblx0XHRcdC8vIFVwZGF0ZSBsaXZlIHF1ZXJpZXMsIGlmIG5lY2Vzc2FyeVxuXHRcdFx0aWYgKCBsaXZlUXVlcmllcyA9IHRoaXMubGl2ZVF1ZXJpZXMgKSB7XG5cdFx0XHRcdHJhY3RpdmUgPSB0aGlzLnJvb3Q7XG5cdFx0XHRcdGkgPSBsaXZlUXVlcmllcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGxpdmVRdWVyaWVzWyBpIF0uX21ha2VEaXJ0eSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMubm9kZSAmJiAoIHN0b3JhZ2UgPSB0aGlzLm5vZGUuX3JhY3RpdmUgKSApIHtcblx0XHRcdFx0Ly8gYWRqdXN0IGtleXBhdGggaWYgbmVlZGVkXG5cdFx0XHRcdGFzc2lnbk5ld0tleXBhdGgoIHN0b3JhZ2UsICdrZXlwYXRoJywgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0XHRpZiAoIGluZGV4UmVmICE9IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRzdG9yYWdlLmluZGV4WyBpbmRleFJlZiBdID0gbmV3SW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gcmViaW5kKCB0aGluZyApIHtcblx0XHRcdFx0dGhpbmcucmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBhc3NpZ25OZXdLZXlwYXRoICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3NwZWNpYWwvaW1nL3JlbmRlci5qcyAqL1xuXHR2YXIgcmVuZGVyID0gZnVuY3Rpb24gcmVuZGVySW1hZ2UoIGltZyApIHtcblx0XHR2YXIgbG9hZEhhbmRsZXI7XG5cdFx0Ly8gaWYgdGhpcyBpcyBhbiA8aW1nPiwgYW5kIHdlJ3JlIGluIGEgY3JhcCBicm93c2VyLCB3ZSBtYXkgbmVlZCB0byBwcmV2ZW50IGl0XG5cdFx0Ly8gZnJvbSBvdmVycmlkaW5nIHdpZHRoIGFuZCBoZWlnaHQgd2hlbiBpdCBsb2FkcyB0aGUgc3JjXG5cdFx0aWYgKCBpbWcuYXR0cmlidXRlcy53aWR0aCB8fCBpbWcuYXR0cmlidXRlcy5oZWlnaHQgKSB7XG5cdFx0XHRpbWcubm9kZS5hZGRFdmVudExpc3RlbmVyKCAnbG9hZCcsIGxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB3aWR0aCA9IGltZy5nZXRBdHRyaWJ1dGUoICd3aWR0aCcgKSxcblx0XHRcdFx0XHRoZWlnaHQgPSBpbWcuZ2V0QXR0cmlidXRlKCAnaGVpZ2h0JyApO1xuXHRcdFx0XHRpZiAoIHdpZHRoICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aW1nLm5vZGUuc2V0QXR0cmlidXRlKCAnd2lkdGgnLCB3aWR0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggaGVpZ2h0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aW1nLm5vZGUuc2V0QXR0cmlidXRlKCAnaGVpZ2h0JywgaGVpZ2h0ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW1nLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCBsb2FkSGFuZGxlciwgZmFsc2UgKTtcblx0XHRcdH0sIGZhbHNlICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9UcmFuc2l0aW9uL3Byb3RvdHlwZS9pbml0LmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRpbml0ID0gZnVuY3Rpb24oIGxvZywgY29uZmlnLCBjaXJjdWxhciApIHtcblxuXHRcdHZhciBGcmFnbWVudCwgZ2V0VmFsdWVPcHRpb25zID0ge307XG5cdFx0Ly8gVE9ETyB3aGF0IGFyZSB0aGUgb3B0aW9ucz9cblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdEZyYWdtZW50ID0gY2lyY3VsYXIuRnJhZ21lbnQ7XG5cdFx0fSApO1xuXHRcdHJldHVybiBmdW5jdGlvbiBUcmFuc2l0aW9uJGluaXQoIGVsZW1lbnQsIHRlbXBsYXRlLCBpc0ludHJvICkge1xuXHRcdFx0dmFyIHQgPSB0aGlzLFxuXHRcdFx0XHRyYWN0aXZlLCBuYW1lLCBmcmFnbWVudDtcblx0XHRcdHQuZWxlbWVudCA9IGVsZW1lbnQ7XG5cdFx0XHR0LnJvb3QgPSByYWN0aXZlID0gZWxlbWVudC5yb290O1xuXHRcdFx0dC5pc0ludHJvID0gaXNJbnRybztcblx0XHRcdG5hbWUgPSB0ZW1wbGF0ZS5uIHx8IHRlbXBsYXRlO1xuXHRcdFx0aWYgKCB0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdGZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdFx0dGVtcGxhdGU6IG5hbWUsXG5cdFx0XHRcdFx0cm9vdDogcmFjdGl2ZSxcblx0XHRcdFx0XHRvd25lcjogZWxlbWVudFxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdG5hbWUgPSBmcmFnbWVudC50b1N0cmluZygpO1xuXHRcdFx0XHRmcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdH1cblx0XHRcdHQubmFtZSA9IG5hbWU7XG5cdFx0XHRpZiAoIHRlbXBsYXRlLmEgKSB7XG5cdFx0XHRcdHQucGFyYW1zID0gdGVtcGxhdGUuYTtcblx0XHRcdH0gZWxzZSBpZiAoIHRlbXBsYXRlLmQgKSB7XG5cdFx0XHRcdC8vIFRPRE8gaXMgdGhlcmUgYSB3YXkgdG8gaW50ZXJwcmV0IGR5bmFtaWMgYXJndW1lbnRzIHdpdGhvdXQgYWxsIHRoZVxuXHRcdFx0XHQvLyAnZGVwZW5kZW5jeSB0aHJhc2hpbmcnP1xuXHRcdFx0XHRmcmFnbWVudCA9IG5ldyBGcmFnbWVudCgge1xuXHRcdFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZS5kLFxuXHRcdFx0XHRcdHJvb3Q6IHJhY3RpdmUsXG5cdFx0XHRcdFx0b3duZXI6IGVsZW1lbnRcblx0XHRcdFx0fSApO1xuXHRcdFx0XHR0LnBhcmFtcyA9IGZyYWdtZW50LmdldFZhbHVlKCBnZXRWYWx1ZU9wdGlvbnMgKTtcblx0XHRcdFx0ZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0XHR9XG5cdFx0XHR0Ll9mbiA9IGNvbmZpZy5yZWdpc3RyaWVzLnRyYW5zaXRpb25zLmZpbmQoIHJhY3RpdmUsIG5hbWUgKTtcblx0XHRcdGlmICggIXQuX2ZuICkge1xuXHRcdFx0XHRsb2cuZXJyb3IoIHtcblx0XHRcdFx0XHRkZWJ1ZzogcmFjdGl2ZS5kZWJ1Zyxcblx0XHRcdFx0XHRtZXNzYWdlOiAnbWlzc2luZ1BsdWdpbicsXG5cdFx0XHRcdFx0YXJnczoge1xuXHRcdFx0XHRcdFx0cGx1Z2luOiAndHJhbnNpdGlvbicsXG5cdFx0XHRcdFx0XHRuYW1lOiBuYW1lXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBsb2csIGNvbmZpZywgY2lyY3VsYXIgKTtcblxuXHQvKiB1dGlscy9jYW1lbENhc2UuanMgKi9cblx0dmFyIGNhbWVsQ2FzZSA9IGZ1bmN0aW9uKCBoeXBoZW5hdGVkU3RyICkge1xuXHRcdHJldHVybiBoeXBoZW5hdGVkU3RyLnJlcGxhY2UoIC8tKFthLXpBLVpdKS9nLCBmdW5jdGlvbiggbWF0Y2gsICQxICkge1xuXHRcdFx0cmV0dXJuICQxLnRvVXBwZXJDYXNlKCk7XG5cdFx0fSApO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9UcmFuc2l0aW9uL2hlbHBlcnMvcHJlZml4LmpzICovXG5cdHZhciBwcmVmaXggPSBmdW5jdGlvbiggaXNDbGllbnQsIHZlbmRvcnMsIGNyZWF0ZUVsZW1lbnQsIGNhbWVsQ2FzZSApIHtcblxuXHRcdHZhciBwcmVmaXgsIHByZWZpeENhY2hlLCB0ZXN0U3R5bGU7XG5cdFx0aWYgKCAhaXNDbGllbnQgKSB7XG5cdFx0XHRwcmVmaXggPSBudWxsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcmVmaXhDYWNoZSA9IHt9O1xuXHRcdFx0dGVzdFN0eWxlID0gY3JlYXRlRWxlbWVudCggJ2RpdicgKS5zdHlsZTtcblx0XHRcdHByZWZpeCA9IGZ1bmN0aW9uKCBwcm9wICkge1xuXHRcdFx0XHR2YXIgaSwgdmVuZG9yLCBjYXBwZWQ7XG5cdFx0XHRcdHByb3AgPSBjYW1lbENhc2UoIHByb3AgKTtcblx0XHRcdFx0aWYgKCAhcHJlZml4Q2FjaGVbIHByb3AgXSApIHtcblx0XHRcdFx0XHRpZiAoIHRlc3RTdHlsZVsgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRwcmVmaXhDYWNoZVsgcHJvcCBdID0gcHJvcDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gdGVzdCB2ZW5kb3JzLi4uXG5cdFx0XHRcdFx0XHRjYXBwZWQgPSBwcm9wLmNoYXJBdCggMCApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnN1YnN0cmluZyggMSApO1xuXHRcdFx0XHRcdFx0aSA9IHZlbmRvcnMubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdHZlbmRvciA9IHZlbmRvcnNbIGkgXTtcblx0XHRcdFx0XHRcdFx0aWYgKCB0ZXN0U3R5bGVbIHZlbmRvciArIGNhcHBlZCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJlZml4Q2FjaGVbIHByb3AgXSA9IHZlbmRvciArIGNhcHBlZDtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcHJlZml4Q2FjaGVbIHByb3AgXTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBwcmVmaXg7XG5cdH0oIGlzQ2xpZW50LCB2ZW5kb3JzLCBjcmVhdGVFbGVtZW50LCBjYW1lbENhc2UgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvVHJhbnNpdGlvbi9wcm90b3R5cGUvZ2V0U3R5bGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJGdldFN0eWxlID0gZnVuY3Rpb24oIGxlZ2FjeSwgaXNDbGllbnQsIGlzQXJyYXksIHByZWZpeCApIHtcblxuXHRcdHZhciBnZXRTdHlsZSwgZ2V0Q29tcHV0ZWRTdHlsZTtcblx0XHRpZiAoICFpc0NsaWVudCApIHtcblx0XHRcdGdldFN0eWxlID0gbnVsbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Z2V0Q29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlIHx8IGxlZ2FjeS5nZXRDb21wdXRlZFN0eWxlO1xuXHRcdFx0Z2V0U3R5bGUgPSBmdW5jdGlvbiggcHJvcHMgKSB7XG5cdFx0XHRcdHZhciBjb21wdXRlZFN0eWxlLCBzdHlsZXMsIGksIHByb3AsIHZhbHVlO1xuXHRcdFx0XHRjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSggdGhpcy5ub2RlICk7XG5cdFx0XHRcdGlmICggdHlwZW9mIHByb3BzID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGNvbXB1dGVkU3R5bGVbIHByZWZpeCggcHJvcHMgKSBdO1xuXHRcdFx0XHRcdGlmICggdmFsdWUgPT09ICcwcHgnICkge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhaXNBcnJheSggcHJvcHMgKSApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUcmFuc2l0aW9uJGdldFN0eWxlIG11c3QgYmUgcGFzc2VkIGEgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBzdHJpbmdzIHJlcHJlc2VudGluZyBDU1MgcHJvcGVydGllcycgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzdHlsZXMgPSB7fTtcblx0XHRcdFx0aSA9IHByb3BzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0cHJvcCA9IHByb3BzWyBpIF07XG5cdFx0XHRcdFx0dmFsdWUgPSBjb21wdXRlZFN0eWxlWyBwcmVmaXgoIHByb3AgKSBdO1xuXHRcdFx0XHRcdGlmICggdmFsdWUgPT09ICcwcHgnICkge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzdHlsZXNbIHByb3AgXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzdHlsZXM7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gZ2V0U3R5bGU7XG5cdH0oIGxlZ2FjeSwgaXNDbGllbnQsIGlzQXJyYXksIHByZWZpeCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9UcmFuc2l0aW9uL3Byb3RvdHlwZS9zZXRTdHlsZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kc2V0U3R5bGUgPSBmdW5jdGlvbiggcHJlZml4ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBzdHlsZSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgcHJvcDtcblx0XHRcdGlmICggdHlwZW9mIHN0eWxlID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0dGhpcy5ub2RlLnN0eWxlWyBwcmVmaXgoIHN0eWxlICkgXSA9IHZhbHVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggcHJvcCBpbiBzdHlsZSApIHtcblx0XHRcdFx0XHRpZiAoIHN0eWxlLmhhc093blByb3BlcnR5KCBwcm9wICkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLm5vZGUuc3R5bGVbIHByZWZpeCggcHJvcCApIF0gPSBzdHlsZVsgcHJvcCBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSggcHJlZml4ICk7XG5cblx0Lyogc2hhcmVkL1RpY2tlci5qcyAqL1xuXHR2YXIgVGlja2VyID0gZnVuY3Rpb24oIHdhcm4sIGdldFRpbWUsIGFuaW1hdGlvbnMgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIFRpY2tlciA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0dmFyIGVhc2luZztcblx0XHRcdHRoaXMuZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uO1xuXHRcdFx0dGhpcy5zdGVwID0gb3B0aW9ucy5zdGVwO1xuXHRcdFx0dGhpcy5jb21wbGV0ZSA9IG9wdGlvbnMuY29tcGxldGU7XG5cdFx0XHQvLyBlYXNpbmdcblx0XHRcdGlmICggdHlwZW9mIG9wdGlvbnMuZWFzaW5nID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0ZWFzaW5nID0gb3B0aW9ucy5yb290LmVhc2luZ1sgb3B0aW9ucy5lYXNpbmcgXTtcblx0XHRcdFx0aWYgKCAhZWFzaW5nICkge1xuXHRcdFx0XHRcdHdhcm4oICdNaXNzaW5nIGVhc2luZyBmdW5jdGlvbiAoXCInICsgb3B0aW9ucy5lYXNpbmcgKyAnXCIpLiBZb3UgbWF5IG5lZWQgdG8gZG93bmxvYWQgYSBwbHVnaW4gZnJvbSBbVE9ET10nICk7XG5cdFx0XHRcdFx0ZWFzaW5nID0gbGluZWFyO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2Ygb3B0aW9ucy5lYXNpbmcgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdGVhc2luZyA9IG9wdGlvbnMuZWFzaW5nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWFzaW5nID0gbGluZWFyO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5lYXNpbmcgPSBlYXNpbmc7XG5cdFx0XHR0aGlzLnN0YXJ0ID0gZ2V0VGltZSgpO1xuXHRcdFx0dGhpcy5lbmQgPSB0aGlzLnN0YXJ0ICsgdGhpcy5kdXJhdGlvbjtcblx0XHRcdHRoaXMucnVubmluZyA9IHRydWU7XG5cdFx0XHRhbmltYXRpb25zLmFkZCggdGhpcyApO1xuXHRcdH07XG5cdFx0VGlja2VyLnByb3RvdHlwZSA9IHtcblx0XHRcdHRpY2s6IGZ1bmN0aW9uKCBub3cgKSB7XG5cdFx0XHRcdHZhciBlbGFwc2VkLCBlYXNlZDtcblx0XHRcdFx0aWYgKCAhdGhpcy5ydW5uaW5nICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG5vdyA+IHRoaXMuZW5kICkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5zdGVwICkge1xuXHRcdFx0XHRcdFx0dGhpcy5zdGVwKCAxICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggdGhpcy5jb21wbGV0ZSApIHtcblx0XHRcdFx0XHRcdHRoaXMuY29tcGxldGUoIDEgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsYXBzZWQgPSBub3cgLSB0aGlzLnN0YXJ0O1xuXHRcdFx0XHRlYXNlZCA9IHRoaXMuZWFzaW5nKCBlbGFwc2VkIC8gdGhpcy5kdXJhdGlvbiApO1xuXHRcdFx0XHRpZiAoIHRoaXMuc3RlcCApIHtcblx0XHRcdFx0XHR0aGlzLnN0ZXAoIGVhc2VkICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy5hYm9ydCApIHtcblx0XHRcdFx0XHR0aGlzLmFib3J0KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRfX2V4cG9ydCA9IFRpY2tlcjtcblxuXHRcdGZ1bmN0aW9uIGxpbmVhciggdCApIHtcblx0XHRcdHJldHVybiB0O1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIHdhcm4sIGdldFRpbWUsIGFuaW1hdGlvbnMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvVHJhbnNpdGlvbi9oZWxwZXJzL3VucHJlZml4LmpzICovXG5cdHZhciB1bnByZWZpeCA9IGZ1bmN0aW9uKCB2ZW5kb3JzICkge1xuXG5cdFx0dmFyIHVucHJlZml4UGF0dGVybiA9IG5ldyBSZWdFeHAoICdeLSg/OicgKyB2ZW5kb3JzLmpvaW4oICd8JyApICsgJyktJyApO1xuXHRcdHJldHVybiBmdW5jdGlvbiggcHJvcCApIHtcblx0XHRcdHJldHVybiBwcm9wLnJlcGxhY2UoIHVucHJlZml4UGF0dGVybiwgJycgKTtcblx0XHR9O1xuXHR9KCB2ZW5kb3JzICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L1RyYW5zaXRpb24vaGVscGVycy9oeXBoZW5hdGUuanMgKi9cblx0dmFyIGh5cGhlbmF0ZSA9IGZ1bmN0aW9uKCB2ZW5kb3JzICkge1xuXG5cdFx0dmFyIHZlbmRvclBhdHRlcm4gPSBuZXcgUmVnRXhwKCAnXig/OicgKyB2ZW5kb3JzLmpvaW4oICd8JyApICsgJykoW0EtWl0pJyApO1xuXHRcdHJldHVybiBmdW5jdGlvbiggc3RyICkge1xuXHRcdFx0dmFyIGh5cGhlbmF0ZWQ7XG5cdFx0XHRpZiAoICFzdHIgKSB7XG5cdFx0XHRcdHJldHVybiAnJztcblx0XHRcdH1cblx0XHRcdGlmICggdmVuZG9yUGF0dGVybi50ZXN0KCBzdHIgKSApIHtcblx0XHRcdFx0c3RyID0gJy0nICsgc3RyO1xuXHRcdFx0fVxuXHRcdFx0aHlwaGVuYXRlZCA9IHN0ci5yZXBsYWNlKCAvW0EtWl0vZywgZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0XHRyZXR1cm4gJy0nICsgbWF0Y2gudG9Mb3dlckNhc2UoKTtcblx0XHRcdH0gKTtcblx0XHRcdHJldHVybiBoeXBoZW5hdGVkO1xuXHRcdH07XG5cdH0oIHZlbmRvcnMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvVHJhbnNpdGlvbi9wcm90b3R5cGUvYW5pbWF0ZVN0eWxlL2NyZWF0ZVRyYW5zaXRpb25zLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRhbmltYXRlU3R5bGVfY3JlYXRlVHJhbnNpdGlvbnMgPSBmdW5jdGlvbiggaXNDbGllbnQsIHdhcm4sIGNyZWF0ZUVsZW1lbnQsIGNhbWVsQ2FzZSwgaW50ZXJwb2xhdGUsIFRpY2tlciwgcHJlZml4LCB1bnByZWZpeCwgaHlwaGVuYXRlICkge1xuXG5cdFx0dmFyIGNyZWF0ZVRyYW5zaXRpb25zLCB0ZXN0U3R5bGUsIFRSQU5TSVRJT04sIFRSQU5TSVRJT05FTkQsIENTU19UUkFOU0lUSU9OU19FTkFCTEVELCBUUkFOU0lUSU9OX0RVUkFUSU9OLCBUUkFOU0lUSU9OX1BST1BFUlRZLCBUUkFOU0lUSU9OX1RJTUlOR19GVU5DVElPTiwgY2FuVXNlQ3NzVHJhbnNpdGlvbnMgPSB7fSxcblx0XHRcdGNhbm5vdFVzZUNzc1RyYW5zaXRpb25zID0ge307XG5cdFx0aWYgKCAhaXNDbGllbnQgKSB7XG5cdFx0XHRjcmVhdGVUcmFuc2l0aW9ucyA9IG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRlc3RTdHlsZSA9IGNyZWF0ZUVsZW1lbnQoICdkaXYnICkuc3R5bGU7XG5cdFx0XHQvLyBkZXRlcm1pbmUgc29tZSBmYWN0cyBhYm91dCBvdXIgZW52aXJvbm1lbnRcblx0XHRcdCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGVzdFN0eWxlLnRyYW5zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRUUkFOU0lUSU9OID0gJ3RyYW5zaXRpb24nO1xuXHRcdFx0XHRcdFRSQU5TSVRJT05FTkQgPSAndHJhbnNpdGlvbmVuZCc7XG5cdFx0XHRcdFx0Q1NTX1RSQU5TSVRJT05TX0VOQUJMRUQgPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCB0ZXN0U3R5bGUud2Via2l0VHJhbnNpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFRSQU5TSVRJT04gPSAnd2Via2l0VHJhbnNpdGlvbic7XG5cdFx0XHRcdFx0VFJBTlNJVElPTkVORCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcblx0XHRcdFx0XHRDU1NfVFJBTlNJVElPTlNfRU5BQkxFRCA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Q1NTX1RSQU5TSVRJT05TX0VOQUJMRUQgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSgpICk7XG5cdFx0XHRpZiAoIFRSQU5TSVRJT04gKSB7XG5cdFx0XHRcdFRSQU5TSVRJT05fRFVSQVRJT04gPSBUUkFOU0lUSU9OICsgJ0R1cmF0aW9uJztcblx0XHRcdFx0VFJBTlNJVElPTl9QUk9QRVJUWSA9IFRSQU5TSVRJT04gKyAnUHJvcGVydHknO1xuXHRcdFx0XHRUUkFOU0lUSU9OX1RJTUlOR19GVU5DVElPTiA9IFRSQU5TSVRJT04gKyAnVGltaW5nRnVuY3Rpb24nO1xuXHRcdFx0fVxuXHRcdFx0Y3JlYXRlVHJhbnNpdGlvbnMgPSBmdW5jdGlvbiggdCwgdG8sIG9wdGlvbnMsIGNoYW5nZWRQcm9wZXJ0aWVzLCByZXNvbHZlICkge1xuXHRcdFx0XHQvLyBXYWl0IGEgYmVhdCAob3RoZXJ3aXNlIHRoZSB0YXJnZXQgc3R5bGVzIHdpbGwgYmUgYXBwbGllZCBpbW1lZGlhdGVseSlcblx0XHRcdFx0Ly8gVE9ETyB1c2UgYSBmYXN0ZG9tLXN0eWxlIG1lY2hhbmlzbT9cblx0XHRcdFx0c2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIGhhc2hQcmVmaXgsIGpzVHJhbnNpdGlvbnNDb21wbGV0ZSwgY3NzVHJhbnNpdGlvbnNDb21wbGV0ZSwgY2hlY2tDb21wbGV0ZSwgdHJhbnNpdGlvbkVuZEhhbmRsZXI7XG5cdFx0XHRcdFx0Y2hlY2tDb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCBqc1RyYW5zaXRpb25zQ29tcGxldGUgJiYgY3NzVHJhbnNpdGlvbnNDb21wbGV0ZSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gd2lsbCBjaGFuZ2VzIHRvIGV2ZW50cyBhbmQgZmlyZSBoYXZlIGFuIHVuZXhwZWN0ZWQgY29uc2VxdWVuY2UgaGVyZT9cblx0XHRcdFx0XHRcdFx0dC5yb290LmZpcmUoIHQubmFtZSArICc6ZW5kJywgdC5ub2RlLCB0LmlzSW50cm8gKTtcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0Ly8gdGhpcyBpcyB1c2VkIHRvIGtlZXAgdHJhY2sgb2Ygd2hpY2ggZWxlbWVudHMgY2FuIHVzZSBDU1MgdG8gYW5pbWF0ZVxuXHRcdFx0XHRcdC8vIHdoaWNoIHByb3BlcnRpZXNcblx0XHRcdFx0XHRoYXNoUHJlZml4ID0gKCB0Lm5vZGUubmFtZXNwYWNlVVJJIHx8ICcnICkgKyB0Lm5vZGUudGFnTmFtZTtcblx0XHRcdFx0XHR0Lm5vZGUuc3R5bGVbIFRSQU5TSVRJT05fUFJPUEVSVFkgXSA9IGNoYW5nZWRQcm9wZXJ0aWVzLm1hcCggcHJlZml4ICkubWFwKCBoeXBoZW5hdGUgKS5qb2luKCAnLCcgKTtcblx0XHRcdFx0XHR0Lm5vZGUuc3R5bGVbIFRSQU5TSVRJT05fVElNSU5HX0ZVTkNUSU9OIF0gPSBoeXBoZW5hdGUoIG9wdGlvbnMuZWFzaW5nIHx8ICdsaW5lYXInICk7XG5cdFx0XHRcdFx0dC5ub2RlLnN0eWxlWyBUUkFOU0lUSU9OX0RVUkFUSU9OIF0gPSBvcHRpb25zLmR1cmF0aW9uIC8gMTAwMCArICdzJztcblx0XHRcdFx0XHR0cmFuc2l0aW9uRW5kSGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0XHRcdHZhciBpbmRleDtcblx0XHRcdFx0XHRcdGluZGV4ID0gY2hhbmdlZFByb3BlcnRpZXMuaW5kZXhPZiggY2FtZWxDYXNlKCB1bnByZWZpeCggZXZlbnQucHJvcGVydHlOYW1lICkgKSApO1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCAhPT0gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdGNoYW5nZWRQcm9wZXJ0aWVzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggY2hhbmdlZFByb3BlcnRpZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0XHQvLyBzdGlsbCB0cmFuc2l0aW9uaW5nLi4uXG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHQubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCBUUkFOU0lUSU9ORU5ELCB0cmFuc2l0aW9uRW5kSGFuZGxlciwgZmFsc2UgKTtcblx0XHRcdFx0XHRcdGNzc1RyYW5zaXRpb25zQ29tcGxldGUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0Y2hlY2tDb21wbGV0ZSgpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0dC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoIFRSQU5TSVRJT05FTkQsIHRyYW5zaXRpb25FbmRIYW5kbGVyLCBmYWxzZSApO1xuXHRcdFx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0dmFyIGkgPSBjaGFuZ2VkUHJvcGVydGllcy5sZW5ndGgsXG5cdFx0XHRcdFx0XHRcdGhhc2gsIG9yaWdpbmFsVmFsdWUsIGluZGV4LCBwcm9wZXJ0aWVzVG9UcmFuc2l0aW9uSW5KcyA9IFtdLFxuXHRcdFx0XHRcdFx0XHRwcm9wLCBzdWZmaXg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0cHJvcCA9IGNoYW5nZWRQcm9wZXJ0aWVzWyBpIF07XG5cdFx0XHRcdFx0XHRcdGhhc2ggPSBoYXNoUHJlZml4ICsgcHJvcDtcblx0XHRcdFx0XHRcdFx0aWYgKCBDU1NfVFJBTlNJVElPTlNfRU5BQkxFRCAmJiAhY2Fubm90VXNlQ3NzVHJhbnNpdGlvbnNbIGhhc2ggXSApIHtcblx0XHRcdFx0XHRcdFx0XHR0Lm5vZGUuc3R5bGVbIHByZWZpeCggcHJvcCApIF0gPSB0b1sgcHJvcCBdO1xuXHRcdFx0XHRcdFx0XHRcdC8vIElmIHdlJ3JlIG5vdCBzdXJlIGlmIENTUyB0cmFuc2l0aW9ucyBhcmUgc3VwcG9ydGVkIGZvclxuXHRcdFx0XHRcdFx0XHRcdC8vIHRoaXMgdGFnL3Byb3BlcnR5IGNvbWJvLCBmaW5kIG91dCBub3dcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFjYW5Vc2VDc3NUcmFuc2l0aW9uc1sgaGFzaCBdICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0b3JpZ2luYWxWYWx1ZSA9IHQuZ2V0U3R5bGUoIHByb3AgKTtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGlmIHRoaXMgcHJvcGVydHkgaXMgdHJhbnNpdGlvbmFibGUgaW4gdGhpcyBicm93c2VyLFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gdGhlIGN1cnJlbnQgc3R5bGUgd2lsbCBiZSBkaWZmZXJlbnQgZnJvbSB0aGUgdGFyZ2V0IHN0eWxlXG5cdFx0XHRcdFx0XHRcdFx0XHRjYW5Vc2VDc3NUcmFuc2l0aW9uc1sgaGFzaCBdID0gdC5nZXRTdHlsZSggcHJvcCApICE9IHRvWyBwcm9wIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRjYW5ub3RVc2VDc3NUcmFuc2l0aW9uc1sgaGFzaCBdID0gIWNhblVzZUNzc1RyYW5zaXRpb25zWyBoYXNoIF07XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBSZXNldCwgaWYgd2UncmUgZ29pbmcgdG8gdXNlIHRpbWVycyBhZnRlciBhbGxcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggY2Fubm90VXNlQ3NzVHJhbnNpdGlvbnNbIGhhc2ggXSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dC5ub2RlLnN0eWxlWyBwcmVmaXgoIHByb3AgKSBdID0gb3JpZ2luYWxWYWx1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKCAhQ1NTX1RSQU5TSVRJT05TX0VOQUJMRUQgfHwgY2Fubm90VXNlQ3NzVHJhbnNpdGlvbnNbIGhhc2ggXSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyB3ZSBuZWVkIHRvIGZhbGwgYmFjayB0byB0aW1lci1iYXNlZCBzdHVmZlxuXHRcdFx0XHRcdFx0XHRcdGlmICggb3JpZ2luYWxWYWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0b3JpZ2luYWxWYWx1ZSA9IHQuZ2V0U3R5bGUoIHByb3AgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0Ly8gbmVlZCB0byByZW1vdmUgdGhpcyBmcm9tIGNoYW5nZWRQcm9wZXJ0aWVzLCBvdGhlcndpc2UgdHJhbnNpdGlvbkVuZEhhbmRsZXJcblx0XHRcdFx0XHRcdFx0XHQvLyB3aWxsIGdldCBjb25mdXNlZFxuXHRcdFx0XHRcdFx0XHRcdGluZGV4ID0gY2hhbmdlZFByb3BlcnRpZXMuaW5kZXhPZiggcHJvcCApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggaW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0d2FybiggJ1NvbWV0aGluZyB2ZXJ5IHN0cmFuZ2UgaGFwcGVuZWQgd2l0aCB0cmFuc2l0aW9ucy4gSWYgeW91IHNlZSB0aGlzIG1lc3NhZ2UsIHBsZWFzZSBsZXQgQFJhY3RpdmVKUyBrbm93LiBUaGFua3MhJyApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjaGFuZ2VkUHJvcGVydGllcy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdC8vIFRPRE8gRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBwcm9wZXJ0eSBpcyBhbmltYXRhYmxlIGF0IGFsbFxuXHRcdFx0XHRcdFx0XHRcdHN1ZmZpeCA9IC9bXlxcZF0qJC8uZXhlYyggdG9bIHByb3AgXSApWyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0Ly8gLi4udGhlbiBraWNrIG9mZiBhIHRpbWVyLWJhc2VkIHRyYW5zaXRpb25cblx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0aWVzVG9UcmFuc2l0aW9uSW5Kcy5wdXNoKCB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuYW1lOiBwcmVmaXgoIHByb3AgKSxcblx0XHRcdFx0XHRcdFx0XHRcdGludGVycG9sYXRvcjogaW50ZXJwb2xhdGUoIHBhcnNlRmxvYXQoIG9yaWdpbmFsVmFsdWUgKSwgcGFyc2VGbG9hdCggdG9bIHByb3AgXSApICksXG5cdFx0XHRcdFx0XHRcdFx0XHRzdWZmaXg6IHN1ZmZpeFxuXHRcdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gamF2YXNjcmlwdCB0cmFuc2l0aW9uc1xuXHRcdFx0XHRcdFx0aWYgKCBwcm9wZXJ0aWVzVG9UcmFuc2l0aW9uSW5Kcy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRcdG5ldyBUaWNrZXIoIHtcblx0XHRcdFx0XHRcdFx0XHRyb290OiB0LnJvb3QsXG5cdFx0XHRcdFx0XHRcdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG5cdFx0XHRcdFx0XHRcdFx0ZWFzaW5nOiBjYW1lbENhc2UoIG9wdGlvbnMuZWFzaW5nIHx8ICcnICksXG5cdFx0XHRcdFx0XHRcdFx0c3RlcDogZnVuY3Rpb24oIHBvcyApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBwcm9wLCBpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aSA9IHByb3BlcnRpZXNUb1RyYW5zaXRpb25JbkpzLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9wID0gcHJvcGVydGllc1RvVHJhbnNpdGlvbkluSnNbIGkgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dC5ub2RlLnN0eWxlWyBwcm9wLm5hbWUgXSA9IHByb3AuaW50ZXJwb2xhdG9yKCBwb3MgKSArIHByb3Auc3VmZml4O1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0anNUcmFuc2l0aW9uc0NvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdGNoZWNrQ29tcGxldGUoKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGpzVHJhbnNpdGlvbnNDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoICFjaGFuZ2VkUHJvcGVydGllcy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFdlIG5lZWQgdG8gY2FuY2VsIHRoZSB0cmFuc2l0aW9uRW5kSGFuZGxlciwgYW5kIGRlYWwgd2l0aFxuXHRcdFx0XHRcdFx0XHQvLyB0aGUgZmFjdCB0aGF0IGl0IHdpbGwgbmV2ZXIgZmlyZVxuXHRcdFx0XHRcdFx0XHR0Lm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggVFJBTlNJVElPTkVORCwgdHJhbnNpdGlvbkVuZEhhbmRsZXIsIGZhbHNlICk7XG5cdFx0XHRcdFx0XHRcdGNzc1RyYW5zaXRpb25zQ29tcGxldGUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRjaGVja0NvbXBsZXRlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgMCApO1xuXHRcdFx0XHR9LCBvcHRpb25zLmRlbGF5IHx8IDAgKTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBjcmVhdGVUcmFuc2l0aW9ucztcblx0fSggaXNDbGllbnQsIHdhcm4sIGNyZWF0ZUVsZW1lbnQsIGNhbWVsQ2FzZSwgaW50ZXJwb2xhdGUsIFRpY2tlciwgcHJlZml4LCB1bnByZWZpeCwgaHlwaGVuYXRlICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L1RyYW5zaXRpb24vcHJvdG90eXBlL2FuaW1hdGVTdHlsZS92aXNpYmlsaXR5LmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRhbmltYXRlU3R5bGVfdmlzaWJpbGl0eSA9IGZ1bmN0aW9uKCB2ZW5kb3JzICkge1xuXG5cdFx0dmFyIGhpZGRlbiwgdmVuZG9yLCBwcmVmaXgsIGksIHZpc2liaWxpdHk7XG5cdFx0aWYgKCB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0aGlkZGVuID0gJ2hpZGRlbic7XG5cdFx0XHR2aXNpYmlsaXR5ID0ge307XG5cdFx0XHRpZiAoIGhpZGRlbiBpbiBkb2N1bWVudCApIHtcblx0XHRcdFx0cHJlZml4ID0gJyc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpID0gdmVuZG9ycy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdHZlbmRvciA9IHZlbmRvcnNbIGkgXTtcblx0XHRcdFx0XHRoaWRkZW4gPSB2ZW5kb3IgKyAnSGlkZGVuJztcblx0XHRcdFx0XHRpZiAoIGhpZGRlbiBpbiBkb2N1bWVudCApIHtcblx0XHRcdFx0XHRcdHByZWZpeCA9IHZlbmRvcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggcHJlZml4ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIHByZWZpeCArICd2aXNpYmlsaXR5Y2hhbmdlJywgb25DaGFuZ2UgKTtcblx0XHRcdFx0Ly8gaW5pdGlhbGlzZVxuXHRcdFx0XHRvbkNoYW5nZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gZ2FoLCB3ZSdyZSBpbiBhbiBvbGQgYnJvd3NlclxuXHRcdFx0XHRpZiAoICdvbmZvY3Vzb3V0JyBpbiBkb2N1bWVudCApIHtcblx0XHRcdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCAnZm9jdXNvdXQnLCBvbkhpZGUgKTtcblx0XHRcdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCAnZm9jdXNpbicsIG9uU2hvdyApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAncGFnZWhpZGUnLCBvbkhpZGUgKTtcblx0XHRcdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ2JsdXInLCBvbkhpZGUgKTtcblx0XHRcdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ3BhZ2VzaG93Jywgb25TaG93ICk7XG5cdFx0XHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdmb2N1cycsIG9uU2hvdyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZpc2liaWxpdHkuaGlkZGVuID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25DaGFuZ2UoKSB7XG5cdFx0XHR2aXNpYmlsaXR5LmhpZGRlbiA9IGRvY3VtZW50WyBoaWRkZW4gXTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvbkhpZGUoKSB7XG5cdFx0XHR2aXNpYmlsaXR5LmhpZGRlbiA9IHRydWU7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25TaG93KCkge1xuXHRcdFx0dmlzaWJpbGl0eS5oaWRkZW4gPSBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHZpc2liaWxpdHk7XG5cdH0oIHZlbmRvcnMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvVHJhbnNpdGlvbi9wcm90b3R5cGUvYW5pbWF0ZVN0eWxlL19hbmltYXRlU3R5bGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJGFuaW1hdGVTdHlsZV9fYW5pbWF0ZVN0eWxlID0gZnVuY3Rpb24oIGxlZ2FjeSwgaXNDbGllbnQsIHdhcm4sIFByb21pc2UsIHByZWZpeCwgY3JlYXRlVHJhbnNpdGlvbnMsIHZpc2liaWxpdHkgKSB7XG5cblx0XHR2YXIgYW5pbWF0ZVN0eWxlLCBnZXRDb21wdXRlZFN0eWxlLCByZXNvbHZlZDtcblx0XHRpZiAoICFpc0NsaWVudCApIHtcblx0XHRcdGFuaW1hdGVTdHlsZSA9IG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGdldENvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSB8fCBsZWdhY3kuZ2V0Q29tcHV0ZWRTdHlsZTtcblx0XHRcdGFuaW1hdGVTdHlsZSA9IGZ1bmN0aW9uKCBzdHlsZSwgdmFsdWUsIG9wdGlvbnMsIGNvbXBsZXRlICkge1xuXHRcdFx0XHR2YXIgdCA9IHRoaXMsXG5cdFx0XHRcdFx0dG87XG5cdFx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIHBhZ2UgaXNuJ3QgdmlzaWJsZS4gRG9uJ3QgYW5pbWF0ZSBhbnl0aGluZywgYmVjYXVzZVxuXHRcdFx0XHQvLyB0aGF0IHdheSB5b3UnbGwgbmV2ZXIgZ2V0IENTUyB0cmFuc2l0aW9uZW5kIGV2ZW50c1xuXHRcdFx0XHRpZiAoIHZpc2liaWxpdHkuaGlkZGVuICkge1xuXHRcdFx0XHRcdHRoaXMuc2V0U3R5bGUoIHN0eWxlLCB2YWx1ZSApO1xuXHRcdFx0XHRcdHJldHVybiByZXNvbHZlZCB8fCAoIHJlc29sdmVkID0gUHJvbWlzZS5yZXNvbHZlKCkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHR5cGVvZiBzdHlsZSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0dG8gPSB7fTtcblx0XHRcdFx0XHR0b1sgc3R5bGUgXSA9IHZhbHVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRvID0gc3R5bGU7XG5cdFx0XHRcdFx0Ly8gc2h1ZmZsZSBhcmd1bWVudHNcblx0XHRcdFx0XHRjb21wbGV0ZSA9IG9wdGlvbnM7XG5cdFx0XHRcdFx0b3B0aW9ucyA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIEFzIG9mIDAuMy45LCB0cmFuc2l0aW9uIGF1dGhvcnMgc2hvdWxkIHN1cHBseSBhbiBgb3B0aW9uYCBvYmplY3Qgd2l0aFxuXHRcdFx0XHQvLyBgZHVyYXRpb25gIGFuZCBgZWFzaW5nYCBwcm9wZXJ0aWVzIChhbmQgb3B0aW9uYWwgYGRlbGF5YCksIHBsdXMgYVxuXHRcdFx0XHQvLyBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGFmdGVyIHRoZSBhbmltYXRpb24gY29tcGxldGVzXG5cdFx0XHRcdC8vIFRPRE8gcmVtb3ZlIHRoaXMgY2hlY2sgaW4gYSBmdXR1cmUgdmVyc2lvblxuXHRcdFx0XHRpZiAoICFvcHRpb25zICkge1xuXHRcdFx0XHRcdHdhcm4oICdUaGUgXCInICsgdC5uYW1lICsgJ1wiIHRyYW5zaXRpb24gZG9lcyBub3Qgc3VwcGx5IGFuIG9wdGlvbnMgb2JqZWN0IHRvIGB0LmFuaW1hdGVTdHlsZSgpYC4gVGhpcyB3aWxsIGJyZWFrIGluIGEgZnV0dXJlIHZlcnNpb24gb2YgUmFjdGl2ZS4gRm9yIG1vcmUgaW5mbyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL1JhY3RpdmVKUy9SYWN0aXZlL2lzc3Vlcy8zNDAnICk7XG5cdFx0XHRcdFx0b3B0aW9ucyA9IHQ7XG5cdFx0XHRcdFx0Y29tcGxldGUgPSB0LmNvbXBsZXRlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoIGZ1bmN0aW9uKCByZXNvbHZlICkge1xuXHRcdFx0XHRcdHZhciBwcm9wZXJ0eU5hbWVzLCBjaGFuZ2VkUHJvcGVydGllcywgY29tcHV0ZWRTdHlsZSwgY3VycmVudCwgZnJvbSwgaSwgcHJvcDtcblx0XHRcdFx0XHQvLyBFZGdlIGNhc2UgLSBpZiBkdXJhdGlvbiBpcyB6ZXJvLCBzZXQgc3R5bGUgc3luY2hyb25vdXNseSBhbmQgY29tcGxldGVcblx0XHRcdFx0XHRpZiAoICFvcHRpb25zLmR1cmF0aW9uICkge1xuXHRcdFx0XHRcdFx0dC5zZXRTdHlsZSggdG8gKTtcblx0XHRcdFx0XHRcdHJlc29sdmUoKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gR2V0IGEgbGlzdCBvZiB0aGUgcHJvcGVydGllcyB3ZSdyZSBhbmltYXRpbmdcblx0XHRcdFx0XHRwcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmtleXMoIHRvICk7XG5cdFx0XHRcdFx0Y2hhbmdlZFByb3BlcnRpZXMgPSBbXTtcblx0XHRcdFx0XHQvLyBTdG9yZSB0aGUgY3VycmVudCBzdHlsZXNcblx0XHRcdFx0XHRjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSggdC5ub2RlICk7XG5cdFx0XHRcdFx0ZnJvbSA9IHt9O1xuXHRcdFx0XHRcdGkgPSBwcm9wZXJ0eU5hbWVzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdHByb3AgPSBwcm9wZXJ0eU5hbWVzWyBpIF07XG5cdFx0XHRcdFx0XHRjdXJyZW50ID0gY29tcHV0ZWRTdHlsZVsgcHJlZml4KCBwcm9wICkgXTtcblx0XHRcdFx0XHRcdGlmICggY3VycmVudCA9PT0gJzBweCcgKSB7XG5cdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gd2UgbmVlZCB0byBrbm93IGlmIHdlJ3JlIGFjdHVhbGx5IGNoYW5naW5nIGFueXRoaW5nXG5cdFx0XHRcdFx0XHRpZiAoIGN1cnJlbnQgIT0gdG9bIHByb3AgXSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gdXNlICE9IGluc3RlYWQgb2YgIT09LCBzbyB3ZSBjYW4gY29tcGFyZSBzdHJpbmdzIHdpdGggbnVtYmVyc1xuXHRcdFx0XHRcdFx0XHRjaGFuZ2VkUHJvcGVydGllcy5wdXNoKCBwcm9wICk7XG5cdFx0XHRcdFx0XHRcdC8vIG1ha2UgdGhlIGNvbXB1dGVkIHN0eWxlIGV4cGxpY2l0LCBzbyB3ZSBjYW4gYW5pbWF0ZSB3aGVyZVxuXHRcdFx0XHRcdFx0XHQvLyBlLmcuIGhlaWdodD0nYXV0bydcblx0XHRcdFx0XHRcdFx0dC5ub2RlLnN0eWxlWyBwcmVmaXgoIHByb3AgKSBdID0gY3VycmVudDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gSWYgd2UncmUgbm90IGFjdHVhbGx5IGNoYW5naW5nIGFueXRoaW5nLCB0aGUgdHJhbnNpdGlvbmVuZCBldmVudFxuXHRcdFx0XHRcdC8vIHdpbGwgbmV2ZXIgZmlyZSEgU28gd2UgY29tcGxldGUgZWFybHlcblx0XHRcdFx0XHRpZiAoICFjaGFuZ2VkUHJvcGVydGllcy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNyZWF0ZVRyYW5zaXRpb25zKCB0LCB0bywgb3B0aW9ucywgY2hhbmdlZFByb3BlcnRpZXMsIHJlc29sdmUgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0XHQvLyBJZiBhIGNhbGxiYWNrIHdhcyBzdXBwbGllZCwgZG8gdGhlIGhvbm91cnNcblx0XHRcdFx0Ly8gVE9ETyByZW1vdmUgdGhpcyBjaGVjayBpbiBmdXR1cmVcblx0XHRcdFx0aWYgKCBjb21wbGV0ZSApIHtcblx0XHRcdFx0XHR3YXJuKCAndC5hbmltYXRlU3R5bGUgcmV0dXJucyBhIFByb21pc2UgYXMgb2YgMC40LjAuIFRyYW5zaXRpb24gYXV0aG9ycyBzaG91bGQgZG8gdC5hbmltYXRlU3R5bGUoLi4uKS50aGVuKGNhbGxiYWNrKScgKTtcblx0XHRcdFx0XHRwcm9taXNlLnRoZW4oIGNvbXBsZXRlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gYW5pbWF0ZVN0eWxlO1xuXHR9KCBsZWdhY3ksIGlzQ2xpZW50LCB3YXJuLCBQcm9taXNlLCBwcmVmaXgsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJGFuaW1hdGVTdHlsZV9jcmVhdGVUcmFuc2l0aW9ucywgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kYW5pbWF0ZVN0eWxlX3Zpc2liaWxpdHkgKTtcblxuXHQvKiB1dGlscy9maWxsR2Fwcy5qcyAqL1xuXHR2YXIgZmlsbEdhcHMgPSBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciBTTElDRSQwID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXHRcdHZhciBzb3VyY2VzID0gU0xJQ0UkMC5jYWxsKCBhcmd1bWVudHMsIDEgKTtcblx0XHRzb3VyY2VzLmZvckVhY2goIGZ1bmN0aW9uKCBzICkge1xuXHRcdFx0Zm9yICggdmFyIGtleSBpbiBzICkge1xuXHRcdFx0XHRpZiAoIHMuaGFzT3duUHJvcGVydHkoIGtleSApICYmICEoIGtleSBpbiB0YXJnZXQgKSApIHtcblx0XHRcdFx0XHR0YXJnZXRbIGtleSBdID0gc1sga2V5IF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvVHJhbnNpdGlvbi9wcm90b3R5cGUvcHJvY2Vzc1BhcmFtcy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kcHJvY2Vzc1BhcmFtcyA9IGZ1bmN0aW9uKCBmaWxsR2FwcyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyYW1zLCBkZWZhdWx0cyApIHtcblx0XHRcdGlmICggdHlwZW9mIHBhcmFtcyA9PT0gJ251bWJlcicgKSB7XG5cdFx0XHRcdHBhcmFtcyA9IHtcblx0XHRcdFx0XHRkdXJhdGlvbjogcGFyYW1zXG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgcGFyYW1zID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0aWYgKCBwYXJhbXMgPT09ICdzbG93JyApIHtcblx0XHRcdFx0XHRwYXJhbXMgPSB7XG5cdFx0XHRcdFx0XHRkdXJhdGlvbjogNjAwXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSBlbHNlIGlmICggcGFyYW1zID09PSAnZmFzdCcgKSB7XG5cdFx0XHRcdFx0cGFyYW1zID0ge1xuXHRcdFx0XHRcdFx0ZHVyYXRpb246IDIwMFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cGFyYW1zID0ge1xuXHRcdFx0XHRcdFx0ZHVyYXRpb246IDQwMFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoICFwYXJhbXMgKSB7XG5cdFx0XHRcdHBhcmFtcyA9IHt9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZpbGxHYXBzKCB7fSwgcGFyYW1zLCBkZWZhdWx0cyApO1xuXHRcdH07XG5cdH0oIGZpbGxHYXBzICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L1RyYW5zaXRpb24vcHJvdG90eXBlL3N0YXJ0LmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRzdGFydCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gVHJhbnNpdGlvbiRzdGFydCgpIHtcblx0XHRcdHZhciB0ID0gdGhpcyxcblx0XHRcdFx0bm9kZSwgb3JpZ2luYWxTdHlsZSwgY29tcGxldGVkO1xuXHRcdFx0bm9kZSA9IHQubm9kZSA9IHQuZWxlbWVudC5ub2RlO1xuXHRcdFx0b3JpZ2luYWxTdHlsZSA9IG5vZGUuZ2V0QXR0cmlidXRlKCAnc3R5bGUnICk7XG5cdFx0XHQvLyBjcmVhdGUgdC5jb21wbGV0ZSgpIC0gd2UgZG9uJ3Qgd2FudCB0aGlzIG9uIHRoZSBwcm90b3R5cGUsXG5cdFx0XHQvLyBiZWNhdXNlIHdlIGRvbid0IHdhbnQgYHRoaXNgIHNpbGxpbmVzcyB3aGVuIHBhc3NpbmcgaXQgYXNcblx0XHRcdC8vIGFuIGFyZ3VtZW50XG5cdFx0XHR0LmNvbXBsZXRlID0gZnVuY3Rpb24oIG5vUmVzZXQgKSB7XG5cdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFub1Jlc2V0ICYmIHQuaXNJbnRybyApIHtcblx0XHRcdFx0XHRyZXNldFN0eWxlKCBub2RlLCBvcmlnaW5hbFN0eWxlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bm9kZS5fcmFjdGl2ZS50cmFuc2l0aW9uID0gbnVsbDtcblx0XHRcdFx0dC5fbWFuYWdlci5yZW1vdmUoIHQgKTtcblx0XHRcdFx0Y29tcGxldGVkID0gdHJ1ZTtcblx0XHRcdH07XG5cdFx0XHQvLyBJZiB0aGUgdHJhbnNpdGlvbiBmdW5jdGlvbiBkb2Vzbid0IGV4aXN0LCBhYm9ydFxuXHRcdFx0aWYgKCAhdC5fZm4gKSB7XG5cdFx0XHRcdHQuY29tcGxldGUoKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dC5fZm4uYXBwbHkoIHQucm9vdCwgWyB0IF0uY29uY2F0KCB0LnBhcmFtcyApICk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHJlc2V0U3R5bGUoIG5vZGUsIHN0eWxlICkge1xuXHRcdFx0aWYgKCBzdHlsZSApIHtcblx0XHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGUoICdzdHlsZScsIHN0eWxlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBOZXh0IGxpbmUgaXMgbmVjZXNzYXJ5LCB0byByZW1vdmUgZW1wdHkgc3R5bGUgYXR0cmlidXRlIVxuXHRcdFx0XHQvLyBTZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNzE2NzU1M1xuXHRcdFx0XHRub2RlLmdldEF0dHJpYnV0ZSggJ3N0eWxlJyApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUF0dHJpYnV0ZSggJ3N0eWxlJyApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvVHJhbnNpdGlvbi9fVHJhbnNpdGlvbi5qcyAqL1xuXHR2YXIgVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKCBpbml0LCBnZXRTdHlsZSwgc2V0U3R5bGUsIGFuaW1hdGVTdHlsZSwgcHJvY2Vzc1BhcmFtcywgc3RhcnQsIGNpcmN1bGFyICkge1xuXG5cdFx0dmFyIEZyYWdtZW50LCBUcmFuc2l0aW9uO1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0RnJhZ21lbnQgPSBjaXJjdWxhci5GcmFnbWVudDtcblx0XHR9ICk7XG5cdFx0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uKCBvd25lciwgdGVtcGxhdGUsIGlzSW50cm8gKSB7XG5cdFx0XHR0aGlzLmluaXQoIG93bmVyLCB0ZW1wbGF0ZSwgaXNJbnRybyApO1xuXHRcdH07XG5cdFx0VHJhbnNpdGlvbi5wcm90b3R5cGUgPSB7XG5cdFx0XHRpbml0OiBpbml0LFxuXHRcdFx0c3RhcnQ6IHN0YXJ0LFxuXHRcdFx0Z2V0U3R5bGU6IGdldFN0eWxlLFxuXHRcdFx0c2V0U3R5bGU6IHNldFN0eWxlLFxuXHRcdFx0YW5pbWF0ZVN0eWxlOiBhbmltYXRlU3R5bGUsXG5cdFx0XHRwcm9jZXNzUGFyYW1zOiBwcm9jZXNzUGFyYW1zXG5cdFx0fTtcblx0XHRyZXR1cm4gVHJhbnNpdGlvbjtcblx0fSggdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kaW5pdCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kZ2V0U3R5bGUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJHNldFN0eWxlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRhbmltYXRlU3R5bGVfX2FuaW1hdGVTdHlsZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kcHJvY2Vzc1BhcmFtcywgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kc3RhcnQsIGNpcmN1bGFyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9yZW5kZXIuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRyZW5kZXIgPSBmdW5jdGlvbiggbmFtZXNwYWNlcywgaXNBcnJheSwgd2FybiwgY3JlYXRlLCBjcmVhdGVFbGVtZW50LCBkZWZpbmVQcm9wZXJ0eSwgbm9vcCwgcnVubG9vcCwgZ2V0SW5uZXJDb250ZXh0LCByZW5kZXJJbWFnZSwgVHJhbnNpdGlvbiApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgdXBkYXRlQ3NzLCB1cGRhdGVTY3JpcHQ7XG5cdFx0dXBkYXRlQ3NzID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbm9kZSA9IHRoaXMubm9kZSxcblx0XHRcdFx0Y29udGVudCA9IHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoIGZhbHNlICk7XG5cdFx0XHQvLyBJRTggaGFzIG5vIHN0eWxlU2hlZXQgdW5sZXNzIHRoZXJlJ3MgYSB0eXBlIHRleHQvY3NzXG5cdFx0XHRpZiAoIHdpbmRvdyAmJiB3aW5kb3cuYXBwZWFyc1RvQmVJRUxlc3NFcXVhbDggKSB7XG5cdFx0XHRcdG5vZGUudHlwZSA9ICd0ZXh0L2Nzcyc7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG5vZGUuc3R5bGVTaGVldCApIHtcblx0XHRcdFx0bm9kZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjb250ZW50O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKCBub2RlLmhhc0NoaWxkTm9kZXMoKSApIHtcblx0XHRcdFx0XHRub2RlLnJlbW92ZUNoaWxkKCBub2RlLmZpcnN0Q2hpbGQgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRub2RlLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSggY29udGVudCApICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHR1cGRhdGVTY3JpcHQgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXRoaXMubm9kZS50eXBlIHx8IHRoaXMubm9kZS50eXBlID09PSAndGV4dC9qYXZhc2NyaXB0JyApIHtcblx0XHRcdFx0d2FybiggJ1NjcmlwdCB0YWcgd2FzIHVwZGF0ZWQuIFRoaXMgZG9lcyBub3QgY2F1c2UgdGhlIGNvZGUgdG8gYmUgcmUtZXZhbHVhdGVkIScgKTtcblx0XHRcdH1cblx0XHRcdHRoaXMubm9kZS50ZXh0ID0gdGhpcy5mcmFnbWVudC50b1N0cmluZyggZmFsc2UgKTtcblx0XHR9O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gRWxlbWVudCRyZW5kZXIoKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdHZhciByb290ID0gdGhpcy5yb290LFxuXHRcdFx0XHRuYW1lc3BhY2UsIG5vZGU7XG5cdFx0XHRuYW1lc3BhY2UgPSBnZXROYW1lc3BhY2UoIHRoaXMgKTtcblx0XHRcdG5vZGUgPSB0aGlzLm5vZGUgPSBjcmVhdGVFbGVtZW50KCB0aGlzLm5hbWUsIG5hbWVzcGFjZSApO1xuXHRcdFx0Ly8gSXMgdGhpcyBhIHRvcC1sZXZlbCBub2RlIG9mIGEgY29tcG9uZW50PyBJZiBzbywgd2UgbWF5IG5lZWQgdG8gYWRkXG5cdFx0XHQvLyBhIGRhdGEtcnZjZ3VpZCBhdHRyaWJ1dGUsIGZvciBDU1MgZW5jYXBzdWxhdGlvblxuXHRcdFx0Ly8gTk9URTogY3NzIG5vIGxvbmdlciBjb3BpZWQgdG8gaW5zdGFuY2UsIHNvIHdlIGNoZWNrIGNvbnN0cnVjdG9yLmNzcyAtXG5cdFx0XHQvLyB3ZSBjYW4gZW5oYW5jZSB0byBoYW5kbGUgaW5zdGFuY2UsIGJ1dCB0aGlzIGlzIG1vcmUgXCJjb3JyZWN0XCIgd2l0aCBjdXJyZW50XG5cdFx0XHQvLyBmdW5jdGlvbmFsaXR5XG5cdFx0XHRpZiAoIHJvb3QuY29uc3RydWN0b3IuY3NzICYmIHRoaXMucGFyZW50RnJhZ21lbnQuZ2V0Tm9kZSgpID09PSByb290LmVsICkge1xuXHRcdFx0XHR0aGlzLm5vZGUuc2V0QXR0cmlidXRlKCAnZGF0YS1ydmNndWlkJywgcm9vdC5jb25zdHJ1Y3Rvci5fZ3VpZCApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQWRkIF9yYWN0aXZlIHByb3BlcnR5IHRvIHRoZSBub2RlIC0gd2UgdXNlIHRoaXMgb2JqZWN0IHRvIHN0b3JlIHN0dWZmXG5cdFx0XHQvLyByZWxhdGVkIHRvIHByb3h5IGV2ZW50cywgdHdvLXdheSBiaW5kaW5ncyBldGNcblx0XHRcdGRlZmluZVByb3BlcnR5KCB0aGlzLm5vZGUsICdfcmFjdGl2ZScsIHtcblx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRwcm94eTogdGhpcyxcblx0XHRcdFx0XHRrZXlwYXRoOiBnZXRJbm5lckNvbnRleHQoIHRoaXMucGFyZW50RnJhZ21lbnQgKSxcblx0XHRcdFx0XHRpbmRleDogdGhpcy5wYXJlbnRGcmFnbWVudC5pbmRleFJlZnMsXG5cdFx0XHRcdFx0ZXZlbnRzOiBjcmVhdGUoIG51bGwgKSxcblx0XHRcdFx0XHRyb290OiByb290XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHRcdC8vIFJlbmRlciBhdHRyaWJ1dGVzXG5cdFx0XHR0aGlzLmF0dHJpYnV0ZXMuZm9yRWFjaCggZnVuY3Rpb24oIGEgKSB7XG5cdFx0XHRcdHJldHVybiBhLnJlbmRlciggbm9kZSApO1xuXHRcdFx0fSApO1xuXHRcdFx0dGhpcy5jb25kaXRpb25hbEF0dHJpYnV0ZXMuZm9yRWFjaCggZnVuY3Rpb24oIGEgKSB7XG5cdFx0XHRcdHJldHVybiBhLnJlbmRlciggbm9kZSApO1xuXHRcdFx0fSApO1xuXHRcdFx0Ly8gUmVuZGVyIGNoaWxkcmVuXG5cdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIDxzY3JpcHQ+IGVsZW1lbnRcblx0XHRcdFx0aWYgKCB0aGlzLm5hbWUgPT09ICdzY3JpcHQnICkge1xuXHRcdFx0XHRcdHRoaXMuYnViYmxlID0gdXBkYXRlU2NyaXB0O1xuXHRcdFx0XHRcdHRoaXMubm9kZS50ZXh0ID0gdGhpcy5mcmFnbWVudC50b1N0cmluZyggZmFsc2UgKTtcblx0XHRcdFx0XHQvLyBieXBhc3Mgd2FybmluZyBpbml0aWFsbHlcblx0XHRcdFx0XHR0aGlzLmZyYWdtZW50LnVucmVuZGVyID0gbm9vcDtcblx0XHRcdFx0fSBlbHNlIGlmICggdGhpcy5uYW1lID09PSAnc3R5bGUnICkge1xuXHRcdFx0XHRcdHRoaXMuYnViYmxlID0gdXBkYXRlQ3NzO1xuXHRcdFx0XHRcdHRoaXMuYnViYmxlKCk7XG5cdFx0XHRcdFx0dGhpcy5mcmFnbWVudC51bnJlbmRlciA9IG5vb3A7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIHRoaXMuYmluZGluZyAmJiB0aGlzLmdldEF0dHJpYnV0ZSggJ2NvbnRlbnRlZGl0YWJsZScgKSApIHtcblx0XHRcdFx0XHR0aGlzLmZyYWdtZW50LnVucmVuZGVyID0gbm9vcDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoIHRoaXMuZnJhZ21lbnQucmVuZGVyKCkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gQWRkIHByb3h5IGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRpZiAoIHRoaXMuZXZlbnRIYW5kbGVycyApIHtcblx0XHRcdFx0dGhpcy5ldmVudEhhbmRsZXJzLmZvckVhY2goIGZ1bmN0aW9uKCBoICkge1xuXHRcdFx0XHRcdHJldHVybiBoLnJlbmRlcigpO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBkZWFsIHdpdGggdHdvLXdheSBiaW5kaW5nc1xuXHRcdFx0aWYgKCB0aGlzLmJpbmRpbmcgKSB7XG5cdFx0XHRcdHRoaXMuYmluZGluZy5yZW5kZXIoKTtcblx0XHRcdFx0dGhpcy5ub2RlLl9yYWN0aXZlLmJpbmRpbmcgPSB0aGlzLmJpbmRpbmc7XG5cdFx0XHR9XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2U6IGlmIHRoaXMgaXMgYW4gPGltZz4sIGFuZCB3ZSdyZSBpbiBhIGNyYXAgYnJvd3Nlciwgd2UgbWF5XG5cdFx0XHQvLyBuZWVkIHRvIHByZXZlbnQgaXQgZnJvbSBvdmVycmlkaW5nIHdpZHRoIGFuZCBoZWlnaHQgd2hlbiBpdCBsb2FkcyB0aGUgc3JjXG5cdFx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ2ltZycgKSB7XG5cdFx0XHRcdHJlbmRlckltYWdlKCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBhcHBseSBkZWNvcmF0b3Iocylcblx0XHRcdGlmICggdGhpcy5kZWNvcmF0b3IgJiYgdGhpcy5kZWNvcmF0b3IuZm4gKSB7XG5cdFx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcyQwLmRlY29yYXRvci5pbml0KCk7XG5cdFx0XHRcdH0sIHRydWUgKTtcblx0XHRcdH1cblx0XHRcdC8vIHRyaWdnZXIgaW50cm8gdHJhbnNpdGlvblxuXHRcdFx0aWYgKCByb290LnRyYW5zaXRpb25zRW5hYmxlZCAmJiB0aGlzLmludHJvICkge1xuXHRcdFx0XHR2YXIgdHJhbnNpdGlvbiA9IG5ldyBUcmFuc2l0aW9uKCB0aGlzLCB0aGlzLmludHJvLCB0cnVlICk7XG5cdFx0XHRcdHJ1bmxvb3AucmVnaXN0ZXJUcmFuc2l0aW9uKCB0cmFuc2l0aW9uICk7XG5cdFx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJhbnNpdGlvbi5zdGFydCgpO1xuXHRcdFx0XHR9LCB0cnVlICk7XG5cdFx0XHRcdHRoaXMudHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ29wdGlvbicgKSB7XG5cdFx0XHRcdHByb2Nlc3NPcHRpb24oIHRoaXMgKTtcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5ub2RlLmF1dG9mb2N1cyApIHtcblx0XHRcdFx0Ly8gU3BlY2lhbCBjYXNlLiBTb21lIGJyb3dzZXJzICgqY291Z2gqIEZpcmVmaXggKmNvdWdoKikgaGF2ZSBhIHByb2JsZW1cblx0XHRcdFx0Ly8gd2l0aCBkeW5hbWljYWxseS1nZW5lcmF0ZWQgZWxlbWVudHMgaGF2aW5nIGF1dG9mb2N1cywgYW5kIHRoZXkgd29uJ3Rcblx0XHRcdFx0Ly8gYWxsb3cgeW91IHRvIHByb2dyYW1tYXRpY2FsbHkgZm9jdXMgdGhlIGVsZW1lbnQgdW50aWwgaXQncyBpbiB0aGUgRE9NXG5cdFx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcyQwLm5vZGUuZm9jdXMoKTtcblx0XHRcdFx0fSwgdHJ1ZSApO1xuXHRcdFx0fVxuXHRcdFx0dXBkYXRlTGl2ZVF1ZXJpZXMoIHRoaXMgKTtcblx0XHRcdHJldHVybiB0aGlzLm5vZGU7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGdldE5hbWVzcGFjZSggZWxlbWVudCApIHtcblx0XHRcdHZhciBuYW1lc3BhY2UsIHhtbG5zLCBwYXJlbnQ7XG5cdFx0XHQvLyBVc2Ugc3BlY2lmaWVkIG5hbWVzcGFjZS4uLlxuXHRcdFx0aWYgKCB4bWxucyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAneG1sbnMnICkgKSB7XG5cdFx0XHRcdG5hbWVzcGFjZSA9IHhtbG5zO1xuXHRcdFx0fSBlbHNlIGlmICggZWxlbWVudC5uYW1lID09PSAnc3ZnJyApIHtcblx0XHRcdFx0bmFtZXNwYWNlID0gbmFtZXNwYWNlcy5zdmc7XG5cdFx0XHR9IGVsc2UgaWYgKCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudCApIHtcblx0XHRcdFx0Ly8gLi4ub3IgSFRNTCwgaWYgdGhlIHBhcmVudCBpcyBhIDxmb3JlaWduT2JqZWN0PlxuXHRcdFx0XHRpZiAoIHBhcmVudC5uYW1lID09PSAnZm9yZWlnbk9iamVjdCcgKSB7XG5cdFx0XHRcdFx0bmFtZXNwYWNlID0gbmFtZXNwYWNlcy5odG1sO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5hbWVzcGFjZSA9IHBhcmVudC5ub2RlLm5hbWVzcGFjZVVSSTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bmFtZXNwYWNlID0gZWxlbWVudC5yb290LmVsLm5hbWVzcGFjZVVSSTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBuYW1lc3BhY2U7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcHJvY2Vzc09wdGlvbiggb3B0aW9uICkge1xuXHRcdFx0dmFyIG9wdGlvblZhbHVlLCBzZWxlY3RWYWx1ZSwgaTtcblx0XHRcdGlmICggIW9wdGlvbi5zZWxlY3QgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHNlbGVjdFZhbHVlID0gb3B0aW9uLnNlbGVjdC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcblx0XHRcdGlmICggc2VsZWN0VmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0b3B0aW9uVmFsdWUgPSBvcHRpb24uZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3Qubm9kZS5tdWx0aXBsZSAmJiBpc0FycmF5KCBzZWxlY3RWYWx1ZSApICkge1xuXHRcdFx0XHRpID0gc2VsZWN0VmFsdWUubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIG9wdGlvblZhbHVlID09IHNlbGVjdFZhbHVlWyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRvcHRpb24ubm9kZS5zZWxlY3RlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9wdGlvbi5ub2RlLnNlbGVjdGVkID0gb3B0aW9uVmFsdWUgPT0gc2VsZWN0VmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdXBkYXRlTGl2ZVF1ZXJpZXMoIGVsZW1lbnQgKSB7XG5cdFx0XHR2YXIgaW5zdGFuY2UsIGxpdmVRdWVyaWVzLCBpLCBzZWxlY3RvciwgcXVlcnk7XG5cdFx0XHQvLyBEb2VzIHRoaXMgbmVlZCB0byBiZSBhZGRlZCB0byBhbnkgbGl2ZSBxdWVyaWVzP1xuXHRcdFx0aW5zdGFuY2UgPSBlbGVtZW50LnJvb3Q7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGxpdmVRdWVyaWVzID0gaW5zdGFuY2UuX2xpdmVRdWVyaWVzO1xuXHRcdFx0XHRpID0gbGl2ZVF1ZXJpZXMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRzZWxlY3RvciA9IGxpdmVRdWVyaWVzWyBpIF07XG5cdFx0XHRcdFx0cXVlcnkgPSBsaXZlUXVlcmllc1sgJ18nICsgc2VsZWN0b3IgXTtcblx0XHRcdFx0XHRpZiAoIHF1ZXJ5Ll90ZXN0KCBlbGVtZW50ICkgKSB7XG5cdFx0XHRcdFx0XHQvLyBrZWVwIHJlZ2lzdGVyIG9mIGFwcGxpY2FibGUgc2VsZWN0b3JzLCBmb3Igd2hlbiB3ZSB0ZWFyZG93blxuXHRcdFx0XHRcdFx0KCBlbGVtZW50LmxpdmVRdWVyaWVzIHx8ICggZWxlbWVudC5saXZlUXVlcmllcyA9IFtdICkgKS5wdXNoKCBxdWVyeSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSB3aGlsZSAoIGluc3RhbmNlID0gaW5zdGFuY2UuX3BhcmVudCApO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIG5hbWVzcGFjZXMsIGlzQXJyYXksIHdhcm4sIGNyZWF0ZSwgY3JlYXRlRWxlbWVudCwgZGVmaW5lUHJvcGVydHksIG5vb3AsIHJ1bmxvb3AsIGdldElubmVyQ29udGV4dCwgcmVuZGVyLCBUcmFuc2l0aW9uICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS90b1N0cmluZy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JHRvU3RyaW5nID0gZnVuY3Rpb24oIHZvaWRFbGVtZW50TmFtZXMsIGlzQXJyYXksIGVzY2FwZUh0bWwgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzdHIsIGVzY2FwZTtcblx0XHRcdHN0ciA9ICc8JyArICggdGhpcy50ZW1wbGF0ZS55ID8gJyFET0NUWVBFJyA6IHRoaXMudGVtcGxhdGUuZSApO1xuXHRcdFx0c3RyICs9IHRoaXMuYXR0cmlidXRlcy5tYXAoIHN0cmluZ2lmeUF0dHJpYnV0ZSApLmpvaW4oICcnICkgKyB0aGlzLmNvbmRpdGlvbmFsQXR0cmlidXRlcy5tYXAoIHN0cmluZ2lmeUF0dHJpYnV0ZSApLmpvaW4oICcnICk7XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSBzZWxlY3RlZCBvcHRpb25zXG5cdFx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ29wdGlvbicgJiYgb3B0aW9uSXNTZWxlY3RlZCggdGhpcyApICkge1xuXHRcdFx0XHRzdHIgKz0gJyBzZWxlY3RlZCc7XG5cdFx0XHR9XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSB0d28td2F5IHJhZGlvIG5hbWUgYmluZGluZ3Ncblx0XHRcdGlmICggdGhpcy5uYW1lID09PSAnaW5wdXQnICYmIGlucHV0SXNDaGVja2VkUmFkaW8oIHRoaXMgKSApIHtcblx0XHRcdFx0c3RyICs9ICcgY2hlY2tlZCc7XG5cdFx0XHR9XG5cdFx0XHRzdHIgKz0gJz4nO1xuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gdGV4dGFyZWFcblx0XHRcdGlmICggdGhpcy5uYW1lID09PSAndGV4dGFyZWEnICYmIHRoaXMuZ2V0QXR0cmlidXRlKCAndmFsdWUnICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0c3RyICs9IGVzY2FwZUh0bWwoIHRoaXMuZ2V0QXR0cmlidXRlKCAndmFsdWUnICkgKTtcblx0XHRcdH0gZWxzZSBpZiAoIHRoaXMuZ2V0QXR0cmlidXRlKCAnY29udGVudGVkaXRhYmxlJyApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHN0ciArPSB0aGlzLmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuXHRcdFx0XHRlc2NhcGUgPSB0aGlzLm5hbWUgIT09ICdzY3JpcHQnICYmIHRoaXMubmFtZSAhPT0gJ3N0eWxlJztcblx0XHRcdFx0c3RyICs9IHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoIGVzY2FwZSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gYWRkIGEgY2xvc2luZyB0YWcgaWYgdGhpcyBpc24ndCBhIHZvaWQgZWxlbWVudFxuXHRcdFx0aWYgKCAhdm9pZEVsZW1lbnROYW1lcy50ZXN0KCB0aGlzLnRlbXBsYXRlLmUgKSApIHtcblx0XHRcdFx0c3RyICs9ICc8LycgKyB0aGlzLnRlbXBsYXRlLmUgKyAnPic7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc3RyO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBvcHRpb25Jc1NlbGVjdGVkKCBlbGVtZW50ICkge1xuXHRcdFx0dmFyIG9wdGlvblZhbHVlLCBzZWxlY3RWYWx1ZSwgaTtcblx0XHRcdG9wdGlvblZhbHVlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcblx0XHRcdGlmICggb3B0aW9uVmFsdWUgPT09IHVuZGVmaW5lZCB8fCAhZWxlbWVudC5zZWxlY3QgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHNlbGVjdFZhbHVlID0gZWxlbWVudC5zZWxlY3QuZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHRpZiAoIHNlbGVjdFZhbHVlID09IG9wdGlvblZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmICggZWxlbWVudC5zZWxlY3QuZ2V0QXR0cmlidXRlKCAnbXVsdGlwbGUnICkgJiYgaXNBcnJheSggc2VsZWN0VmFsdWUgKSApIHtcblx0XHRcdFx0aSA9IHNlbGVjdFZhbHVlLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCBzZWxlY3RWYWx1ZVsgaSBdID09IG9wdGlvblZhbHVlICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaW5wdXRJc0NoZWNrZWRSYWRpbyggZWxlbWVudCApIHtcblx0XHRcdHZhciBhdHRyaWJ1dGVzLCB0eXBlQXR0cmlidXRlLCB2YWx1ZUF0dHJpYnV0ZSwgbmFtZUF0dHJpYnV0ZTtcblx0XHRcdGF0dHJpYnV0ZXMgPSBlbGVtZW50LmF0dHJpYnV0ZXM7XG5cdFx0XHR0eXBlQXR0cmlidXRlID0gYXR0cmlidXRlcy50eXBlO1xuXHRcdFx0dmFsdWVBdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLnZhbHVlO1xuXHRcdFx0bmFtZUF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMubmFtZTtcblx0XHRcdGlmICggIXR5cGVBdHRyaWJ1dGUgfHwgdHlwZUF0dHJpYnV0ZS52YWx1ZSAhPT0gJ3JhZGlvJyB8fCAhdmFsdWVBdHRyaWJ1dGUgfHwgIW5hbWVBdHRyaWJ1dGUuaW50ZXJwb2xhdG9yICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHZhbHVlQXR0cmlidXRlLnZhbHVlID09PSBuYW1lQXR0cmlidXRlLmludGVycG9sYXRvci52YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc3RyaW5naWZ5QXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XG5cdFx0XHR2YXIgc3RyID0gYXR0cmlidXRlLnRvU3RyaW5nKCk7XG5cdFx0XHRyZXR1cm4gc3RyID8gJyAnICsgc3RyIDogJyc7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggdm9pZEVsZW1lbnROYW1lcywgaXNBcnJheSwgZXNjYXBlSHRtbCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9zcGVjaWFsL29wdGlvbi91bmJpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9zcGVjaWFsX29wdGlvbl91bmJpbmQgPSBmdW5jdGlvbiggcmVtb3ZlRnJvbUFycmF5ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHVuYmluZE9wdGlvbiggb3B0aW9uICkge1xuXHRcdFx0aWYgKCBvcHRpb24uc2VsZWN0ICkge1xuXHRcdFx0XHRyZW1vdmVGcm9tQXJyYXkoIG9wdGlvbi5zZWxlY3Qub3B0aW9ucywgb3B0aW9uICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggcmVtb3ZlRnJvbUFycmF5ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS91bmJpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCR1bmJpbmQgPSBmdW5jdGlvbiggdW5iaW5kT3B0aW9uICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gRWxlbWVudCR1bmJpbmQoKSB7XG5cdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMuYmluZGluZyApIHtcblx0XHRcdFx0dGhpcy5iaW5kaW5nLnVuYmluZCgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLmV2ZW50SGFuZGxlcnMgKSB7XG5cdFx0XHRcdHRoaXMuZXZlbnRIYW5kbGVycy5mb3JFYWNoKCB1bmJpbmQgKTtcblx0XHRcdH1cblx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIDxvcHRpb24+XG5cdFx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ29wdGlvbicgKSB7XG5cdFx0XHRcdHVuYmluZE9wdGlvbiggdGhpcyApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5hdHRyaWJ1dGVzLmZvckVhY2goIHVuYmluZCApO1xuXHRcdFx0dGhpcy5jb25kaXRpb25hbEF0dHJpYnV0ZXMuZm9yRWFjaCggdW5iaW5kICk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHVuYmluZCggeCApIHtcblx0XHRcdHgudW5iaW5kKCk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X3NwZWNpYWxfb3B0aW9uX3VuYmluZCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvdW5yZW5kZXIuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCR1bnJlbmRlciA9IGZ1bmN0aW9uKCBydW5sb29wLCBUcmFuc2l0aW9uICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gRWxlbWVudCR1bnJlbmRlciggc2hvdWxkRGVzdHJveSApIHtcblx0XHRcdHZhciBiaW5kaW5nLCBiaW5kaW5ncztcblx0XHRcdGlmICggdGhpcy50cmFuc2l0aW9uICkge1xuXHRcdFx0XHR0aGlzLnRyYW5zaXRpb24uY29tcGxldGUoKTtcblx0XHRcdH1cblx0XHRcdC8vIERldGFjaCBhcyBzb29uIGFzIHdlIGNhblxuXHRcdFx0aWYgKCB0aGlzLm5hbWUgPT09ICdvcHRpb24nICkge1xuXHRcdFx0XHQvLyA8b3B0aW9uPiBlbGVtZW50cyBkZXRhY2ggaW1tZWRpYXRlbHksIHNvIHRoYXRcblx0XHRcdFx0Ly8gdGhlaXIgcGFyZW50IDxzZWxlY3Q+IGVsZW1lbnQgc3luY3MgY29ycmVjdGx5LCBhbmRcblx0XHRcdFx0Ly8gc2luY2Ugb3B0aW9uIGVsZW1lbnRzIGNhbid0IGhhdmUgdHJhbnNpdGlvbnMgYW55d2F5XG5cdFx0XHRcdHRoaXMuZGV0YWNoKCk7XG5cdFx0XHR9IGVsc2UgaWYgKCBzaG91bGREZXN0cm95ICkge1xuXHRcdFx0XHRydW5sb29wLmRldGFjaFdoZW5SZWFkeSggdGhpcyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQ2hpbGRyZW4gZmlyc3QuIHRoYXQgd2F5LCBhbnkgdHJhbnNpdGlvbnMgb24gY2hpbGQgZWxlbWVudHMgd2lsbCBiZVxuXHRcdFx0Ly8gaGFuZGxlZCBieSB0aGUgY3VycmVudCB0cmFuc2l0aW9uTWFuYWdlclxuXHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuXHRcdFx0XHR0aGlzLmZyYWdtZW50LnVucmVuZGVyKCBmYWxzZSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBiaW5kaW5nID0gdGhpcy5iaW5kaW5nICkge1xuXHRcdFx0XHR0aGlzLmJpbmRpbmcudW5yZW5kZXIoKTtcblx0XHRcdFx0dGhpcy5ub2RlLl9yYWN0aXZlLmJpbmRpbmcgPSBudWxsO1xuXHRcdFx0XHRiaW5kaW5ncyA9IHRoaXMucm9vdC5fdHdvd2F5QmluZGluZ3NbIGJpbmRpbmcua2V5cGF0aCBdO1xuXHRcdFx0XHRiaW5kaW5ncy5zcGxpY2UoIGJpbmRpbmdzLmluZGV4T2YoIGJpbmRpbmcgKSwgMSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gUmVtb3ZlIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRpZiAoIHRoaXMuZXZlbnRIYW5kbGVycyApIHtcblx0XHRcdFx0dGhpcy5ldmVudEhhbmRsZXJzLmZvckVhY2goIGZ1bmN0aW9uKCBoICkge1xuXHRcdFx0XHRcdHJldHVybiBoLnVucmVuZGVyKCk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5kZWNvcmF0b3IgKSB7XG5cdFx0XHRcdHRoaXMuZGVjb3JhdG9yLnRlYXJkb3duKCk7XG5cdFx0XHR9XG5cdFx0XHQvLyB0cmlnZ2VyIG91dHJvIHRyYW5zaXRpb24gaWYgbmVjZXNzYXJ5XG5cdFx0XHRpZiAoIHRoaXMucm9vdC50cmFuc2l0aW9uc0VuYWJsZWQgJiYgdGhpcy5vdXRybyApIHtcblx0XHRcdFx0dmFyIHRyYW5zaXRpb24gPSBuZXcgVHJhbnNpdGlvbiggdGhpcywgdGhpcy5vdXRybywgZmFsc2UgKTtcblx0XHRcdFx0cnVubG9vcC5yZWdpc3RlclRyYW5zaXRpb24oIHRyYW5zaXRpb24gKTtcblx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiB0cmFuc2l0aW9uLnN0YXJ0KCk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdC8vIFJlbW92ZSB0aGlzIG5vZGUgZnJvbSBhbnkgbGl2ZSBxdWVyaWVzXG5cdFx0XHRpZiAoIHRoaXMubGl2ZVF1ZXJpZXMgKSB7XG5cdFx0XHRcdHJlbW92ZUZyb21MaXZlUXVlcmllcyggdGhpcyApO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiByZW1vdmVGcm9tTGl2ZVF1ZXJpZXMoIGVsZW1lbnQgKSB7XG5cdFx0XHR2YXIgcXVlcnksIHNlbGVjdG9yLCBpO1xuXHRcdFx0aSA9IGVsZW1lbnQubGl2ZVF1ZXJpZXMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdHF1ZXJ5ID0gZWxlbWVudC5saXZlUXVlcmllc1sgaSBdO1xuXHRcdFx0XHRzZWxlY3RvciA9IHF1ZXJ5LnNlbGVjdG9yO1xuXHRcdFx0XHRxdWVyeS5fcmVtb3ZlKCBlbGVtZW50Lm5vZGUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBydW5sb29wLCBUcmFuc2l0aW9uICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L19FbGVtZW50LmpzICovXG5cdHZhciBFbGVtZW50ID0gZnVuY3Rpb24oIGJ1YmJsZSwgZGV0YWNoLCBmaW5kLCBmaW5kQWxsLCBmaW5kQWxsQ29tcG9uZW50cywgZmluZENvbXBvbmVudCwgZmluZE5leHROb2RlLCBmaXJzdE5vZGUsIGdldEF0dHJpYnV0ZSwgaW5pdCwgcmViaW5kLCByZW5kZXIsIHRvU3RyaW5nLCB1bmJpbmQsIHVucmVuZGVyICkge1xuXG5cdFx0dmFyIEVsZW1lbnQgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdHRoaXMuaW5pdCggb3B0aW9ucyApO1xuXHRcdH07XG5cdFx0RWxlbWVudC5wcm90b3R5cGUgPSB7XG5cdFx0XHRidWJibGU6IGJ1YmJsZSxcblx0XHRcdGRldGFjaDogZGV0YWNoLFxuXHRcdFx0ZmluZDogZmluZCxcblx0XHRcdGZpbmRBbGw6IGZpbmRBbGwsXG5cdFx0XHRmaW5kQWxsQ29tcG9uZW50czogZmluZEFsbENvbXBvbmVudHMsXG5cdFx0XHRmaW5kQ29tcG9uZW50OiBmaW5kQ29tcG9uZW50LFxuXHRcdFx0ZmluZE5leHROb2RlOiBmaW5kTmV4dE5vZGUsXG5cdFx0XHRmaXJzdE5vZGU6IGZpcnN0Tm9kZSxcblx0XHRcdGdldEF0dHJpYnV0ZTogZ2V0QXR0cmlidXRlLFxuXHRcdFx0aW5pdDogaW5pdCxcblx0XHRcdHJlYmluZDogcmViaW5kLFxuXHRcdFx0cmVuZGVyOiByZW5kZXIsXG5cdFx0XHR0b1N0cmluZzogdG9TdHJpbmcsXG5cdFx0XHR1bmJpbmQ6IHVuYmluZCxcblx0XHRcdHVucmVuZGVyOiB1bnJlbmRlclxuXHRcdH07XG5cdFx0cmV0dXJuIEVsZW1lbnQ7XG5cdH0oIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRidWJibGUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRkZXRhY2gsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRmaW5kLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZmluZEFsbCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGZpbmRBbGxDb21wb25lbnRzLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZmluZENvbXBvbmVudCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGZpbmROZXh0Tm9kZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGZpcnN0Tm9kZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGdldEF0dHJpYnV0ZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGluaXQsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRyZWJpbmQsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRyZW5kZXIsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCR0b1N0cmluZywgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JHVuYmluZCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JHVucmVuZGVyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9QYXJ0aWFsL2RlSW5kZW50LmpzICovXG5cdHZhciBkZUluZGVudCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBlbXB0eSA9IC9eXFxzKiQvLFxuXHRcdFx0bGVhZGluZ1doaXRlc3BhY2UgPSAvXlxccyovO1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24oIHN0ciApIHtcblx0XHRcdHZhciBsaW5lcywgZmlyc3RMaW5lLCBsYXN0TGluZSwgbWluSW5kZW50O1xuXHRcdFx0bGluZXMgPSBzdHIuc3BsaXQoICdcXG4nICk7XG5cdFx0XHQvLyByZW1vdmUgZmlyc3QgYW5kIGxhc3QgbGluZSwgaWYgdGhleSBvbmx5IGNvbnRhaW4gd2hpdGVzcGFjZVxuXHRcdFx0Zmlyc3RMaW5lID0gbGluZXNbIDAgXTtcblx0XHRcdGlmICggZmlyc3RMaW5lICE9PSB1bmRlZmluZWQgJiYgZW1wdHkudGVzdCggZmlyc3RMaW5lICkgKSB7XG5cdFx0XHRcdGxpbmVzLnNoaWZ0KCk7XG5cdFx0XHR9XG5cdFx0XHRsYXN0TGluZSA9IGxpbmVzWyBsaW5lcy5sZW5ndGggLSAxIF07XG5cdFx0XHRpZiAoIGxhc3RMaW5lICE9PSB1bmRlZmluZWQgJiYgZW1wdHkudGVzdCggbGFzdExpbmUgKSApIHtcblx0XHRcdFx0bGluZXMucG9wKCk7XG5cdFx0XHR9XG5cdFx0XHRtaW5JbmRlbnQgPSBsaW5lcy5yZWR1Y2UoIHJlZHVjZXIsIG51bGwgKTtcblx0XHRcdGlmICggbWluSW5kZW50ICkge1xuXHRcdFx0XHRzdHIgPSBsaW5lcy5tYXAoIGZ1bmN0aW9uKCBsaW5lICkge1xuXHRcdFx0XHRcdHJldHVybiBsaW5lLnJlcGxhY2UoIG1pbkluZGVudCwgJycgKTtcblx0XHRcdFx0fSApLmpvaW4oICdcXG4nICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc3RyO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiByZWR1Y2VyKCBwcmV2aW91cywgbGluZSApIHtcblx0XHRcdHZhciBsaW5lSW5kZW50ID0gbGVhZGluZ1doaXRlc3BhY2UuZXhlYyggbGluZSApWyAwIF07XG5cdFx0XHRpZiAoIHByZXZpb3VzID09PSBudWxsIHx8IGxpbmVJbmRlbnQubGVuZ3RoIDwgcHJldmlvdXMubGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gbGluZUluZGVudDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwcmV2aW91cztcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9QYXJ0aWFsL2dldFBhcnRpYWxUZW1wbGF0ZS5qcyAqL1xuXHR2YXIgZ2V0UGFydGlhbFRlbXBsYXRlID0gZnVuY3Rpb24oIGxvZywgY29uZmlnLCBwYXJzZXIsIGRlSW5kZW50ICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gZ2V0UGFydGlhbFRlbXBsYXRlKCByYWN0aXZlLCBuYW1lICkge1xuXHRcdFx0dmFyIHBhcnRpYWw7XG5cdFx0XHQvLyBJZiB0aGUgcGFydGlhbCBpbiBpbnN0YW5jZSBvciB2aWV3IGhlaXJhcmNoeSBpbnN0YW5jZXMsIGdyZWF0XG5cdFx0XHRpZiAoIHBhcnRpYWwgPSBnZXRQYXJ0aWFsRnJvbVJlZ2lzdHJ5KCByYWN0aXZlLCBuYW1lICkgKSB7XG5cdFx0XHRcdHJldHVybiBwYXJ0aWFsO1xuXHRcdFx0fVxuXHRcdFx0Ly8gRG9lcyBpdCBleGlzdCBvbiB0aGUgcGFnZSBhcyBhIHNjcmlwdCB0YWc/XG5cdFx0XHRwYXJ0aWFsID0gcGFyc2VyLmZyb21JZCggbmFtZSwge1xuXHRcdFx0XHRub1Rocm93OiB0cnVlXG5cdFx0XHR9ICk7XG5cdFx0XHRpZiAoIHBhcnRpYWwgKSB7XG5cdFx0XHRcdC8vIGlzIHRoaXMgbmVjZXNzYXJ5P1xuXHRcdFx0XHRwYXJ0aWFsID0gZGVJbmRlbnQoIHBhcnRpYWwgKTtcblx0XHRcdFx0Ly8gcGFyc2UgYW5kIHJlZ2lzdGVyIHRvIHRoaXMgcmFjdGl2ZSBpbnN0YW5jZVxuXHRcdFx0XHR2YXIgcGFyc2VkID0gcGFyc2VyLnBhcnNlKCBwYXJ0aWFsLCBwYXJzZXIuZ2V0UGFyc2VPcHRpb25zKCByYWN0aXZlICkgKTtcblx0XHRcdFx0Ly8gcmVnaXN0ZXIgKGFuZCByZXR1cm4gbWFpbiBwYXJ0aWFsIGlmIHRoZXJlIGFyZSBvdGhlcnMgaW4gdGhlIHRlbXBsYXRlKVxuXHRcdFx0XHRyZXR1cm4gcmFjdGl2ZS5wYXJ0aWFsc1sgbmFtZSBdID0gcGFyc2VkLnQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGdldFBhcnRpYWxGcm9tUmVnaXN0cnkoIHJhY3RpdmUsIG5hbWUgKSB7XG5cdFx0XHR2YXIgcGFydGlhbHMgPSBjb25maWcucmVnaXN0cmllcy5wYXJ0aWFscztcblx0XHRcdC8vIGZpbmQgZmlyc3QgaW5zdGFuY2UgaW4gdGhlIHJhY3RpdmUgb3IgdmlldyBoaWVyYXJjaHkgdGhhdCBoYXMgdGhpcyBwYXJ0aWFsXG5cdFx0XHR2YXIgaW5zdGFuY2UgPSBwYXJ0aWFscy5maW5kSW5zdGFuY2UoIHJhY3RpdmUsIG5hbWUgKTtcblx0XHRcdGlmICggIWluc3RhbmNlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgcGFydGlhbCA9IGluc3RhbmNlLnBhcnRpYWxzWyBuYW1lIF0sXG5cdFx0XHRcdGZuO1xuXHRcdFx0Ly8gcGFydGlhbCBpcyBhIGZ1bmN0aW9uP1xuXHRcdFx0aWYgKCB0eXBlb2YgcGFydGlhbCA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0Zm4gPSBwYXJ0aWFsLmJpbmQoIGluc3RhbmNlICk7XG5cdFx0XHRcdGZuLmlzT3duZXIgPSBpbnN0YW5jZS5wYXJ0aWFscy5oYXNPd25Qcm9wZXJ0eSggbmFtZSApO1xuXHRcdFx0XHRwYXJ0aWFsID0gZm4oIGluc3RhbmNlLmRhdGEsIHBhcnNlciApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhcGFydGlhbCApIHtcblx0XHRcdFx0bG9nLndhcm4oIHtcblx0XHRcdFx0XHRkZWJ1ZzogcmFjdGl2ZS5kZWJ1Zyxcblx0XHRcdFx0XHRtZXNzYWdlOiAnbm9SZWdpc3RyeUZ1bmN0aW9uUmV0dXJuJyxcblx0XHRcdFx0XHRhcmdzOiB7XG5cdFx0XHRcdFx0XHRyZWdpc3RyeTogJ3BhcnRpYWwnLFxuXHRcdFx0XHRcdFx0bmFtZTogbmFtZVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvLyBJZiB0aGlzIHdhcyBhZGRlZCBtYW51YWxseSB0byB0aGUgcmVnaXN0cnksXG5cdFx0XHQvLyBidXQgaGFzbid0IGJlZW4gcGFyc2VkLCBwYXJzZSBpdCBub3dcblx0XHRcdGlmICggIXBhcnNlci5pc1BhcnNlZCggcGFydGlhbCApICkge1xuXHRcdFx0XHQvLyB1c2UgdGhlIHBhcnNlT3B0aW9ucyBvZiB0aGUgcmFjdGl2ZSBpbnN0YW5jZSBvbiB3aGljaCBpdCB3YXMgZm91bmRcblx0XHRcdFx0dmFyIHBhcnNlZCA9IHBhcnNlci5wYXJzZSggcGFydGlhbCwgcGFyc2VyLmdldFBhcnNlT3B0aW9ucyggaW5zdGFuY2UgKSApO1xuXHRcdFx0XHQvLyBQYXJ0aWFscyBjYW5ub3QgY29udGFpbiBuZXN0ZWQgcGFydGlhbHMhXG5cdFx0XHRcdC8vIFRPRE8gYWRkIGEgdGVzdCBmb3IgdGhpc1xuXHRcdFx0XHRpZiAoIHBhcnNlZC5wICkge1xuXHRcdFx0XHRcdGxvZy53YXJuKCB7XG5cdFx0XHRcdFx0XHRkZWJ1ZzogcmFjdGl2ZS5kZWJ1Zyxcblx0XHRcdFx0XHRcdG1lc3NhZ2U6ICdub05lc3RlZFBhcnRpYWxzJyxcblx0XHRcdFx0XHRcdGFyZ3M6IHtcblx0XHRcdFx0XHRcdFx0cm5hbWU6IG5hbWVcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gaWYgZm4sIHVzZSBpbnN0YW5jZSB0byBzdG9yZSByZXN1bHQsIG90aGVyd2lzZSBuZWVkcyB0byBnb1xuXHRcdFx0XHQvLyBpbiB0aGUgY29ycmVjdCBwb2ludCBpbiBwcm90b3R5cGUgY2hhaW4gb24gaW5zdGFuY2Ugb3IgY29uc3RydWN0b3Jcblx0XHRcdFx0dmFyIHRhcmdldCA9IGZuID8gaW5zdGFuY2UgOiBwYXJ0aWFscy5maW5kT3duZXIoIGluc3RhbmNlLCBuYW1lICk7XG5cdFx0XHRcdC8vIG1heSBiZSBhIHRlbXBsYXRlIHdpdGggcGFydGlhbHMsIHdoaWNoIG5lZWQgdG8gYmUgcmVnaXN0ZXJlZCBhbmQgbWFpbiB0ZW1wbGF0ZSBleHRyYWN0ZWRcblx0XHRcdFx0dGFyZ2V0LnBhcnRpYWxzWyBuYW1lIF0gPSBwYXJ0aWFsID0gcGFyc2VkLnQ7XG5cdFx0XHR9XG5cdFx0XHQvLyBzdG9yZSBmb3IgcmVzZXRcblx0XHRcdGlmICggZm4gKSB7XG5cdFx0XHRcdHBhcnRpYWwuX2ZuID0gZm47XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcGFydGlhbC52ID8gcGFydGlhbC50IDogcGFydGlhbDtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBsb2csIGNvbmZpZywgcGFyc2VyLCBkZUluZGVudCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvUGFydGlhbC9hcHBseUluZGVudC5qcyAqL1xuXHR2YXIgYXBwbHlJbmRlbnQgPSBmdW5jdGlvbiggc3RyaW5nLCBpbmRlbnQgKSB7XG5cdFx0dmFyIGluZGVudGVkO1xuXHRcdGlmICggIWluZGVudCApIHtcblx0XHRcdHJldHVybiBzdHJpbmc7XG5cdFx0fVxuXHRcdGluZGVudGVkID0gc3RyaW5nLnNwbGl0KCAnXFxuJyApLm1hcCggZnVuY3Rpb24oIGxpbmUsIG5vdEZpcnN0TGluZSApIHtcblx0XHRcdHJldHVybiBub3RGaXJzdExpbmUgPyBpbmRlbnQgKyBsaW5lIDogbGluZTtcblx0XHR9ICkuam9pbiggJ1xcbicgKTtcblx0XHRyZXR1cm4gaW5kZW50ZWQ7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9QYXJ0aWFsL19QYXJ0aWFsLmpzICovXG5cdHZhciBQYXJ0aWFsID0gZnVuY3Rpb24oIGxvZywgdHlwZXMsIGdldFBhcnRpYWxUZW1wbGF0ZSwgYXBwbHlJbmRlbnQsIGNpcmN1bGFyLCBydW5sb29wLCBNdXN0YWNoZSwgcmViaW5kLCB1bmJpbmQgKSB7XG5cblx0XHR2YXIgUGFydGlhbCwgRnJhZ21lbnQ7XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRGcmFnbWVudCA9IGNpcmN1bGFyLkZyYWdtZW50O1xuXHRcdH0gKTtcblx0XHRQYXJ0aWFsID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgcGFyZW50RnJhZ21lbnQsIHRlbXBsYXRlO1xuXHRcdFx0cGFyZW50RnJhZ21lbnQgPSB0aGlzLnBhcmVudEZyYWdtZW50ID0gb3B0aW9ucy5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHRoaXMucm9vdCA9IHBhcmVudEZyYWdtZW50LnJvb3Q7XG5cdFx0XHR0aGlzLnR5cGUgPSB0eXBlcy5QQVJUSUFMO1xuXHRcdFx0dGhpcy5pbmRleCA9IG9wdGlvbnMuaW5kZXg7XG5cdFx0XHR0aGlzLm5hbWUgPSBvcHRpb25zLnRlbXBsYXRlLnI7XG5cdFx0XHR0aGlzLmZyYWdtZW50ID0gdGhpcy5mcmFnbWVudFRvUmVuZGVyID0gdGhpcy5mcmFnbWVudFRvVW5yZW5kZXIgPSBudWxsO1xuXHRcdFx0TXVzdGFjaGUuaW5pdCggdGhpcywgb3B0aW9ucyApO1xuXHRcdFx0Ly8gSWYgdGhpcyBkaWRuJ3QgcmVzb2x2ZSwgaXQgbW9zdCBsaWtlbHkgbWVhbnMgd2UgaGF2ZSBhIG5hbWVkIHBhcnRpYWxcblx0XHRcdC8vIChpLmUuIGB7ez5mb299fWAgbWVhbnMgJ3VzZSB0aGUgZm9vIHBhcnRpYWwnLCBub3QgJ3VzZSB0aGUgcGFydGlhbFxuXHRcdFx0Ly8gd2hvc2UgbmFtZSBpcyB0aGUgdmFsdWUgb2YgYGZvb2AnKVxuXHRcdFx0aWYgKCAhdGhpcy5rZXlwYXRoICYmICggdGVtcGxhdGUgPSBnZXRQYXJ0aWFsVGVtcGxhdGUoIHRoaXMucm9vdCwgdGhpcy5uYW1lICkgKSApIHtcblx0XHRcdFx0dW5iaW5kLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0Ly8gcHJldmVudCBhbnkgZnVydGhlciBjaGFuZ2VzXG5cdFx0XHRcdHRoaXMuaXNOYW1lZCA9IHRydWU7XG5cdFx0XHRcdHRoaXMuc2V0VGVtcGxhdGUoIHRlbXBsYXRlICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRQYXJ0aWFsLnByb3RvdHlwZSA9IHtcblx0XHRcdGJ1YmJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50RnJhZ21lbnQuYnViYmxlKCk7XG5cdFx0XHR9LFxuXHRcdFx0ZGV0YWNoOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZGV0YWNoKCk7XG5cdFx0XHR9LFxuXHRcdFx0ZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0fSxcblx0XHRcdGZpbmRBbGw6IGZ1bmN0aW9uKCBzZWxlY3RvciwgcXVlcnkgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRBbGwoIHNlbGVjdG9yLCBxdWVyeSApO1xuXHRcdFx0fSxcblx0XHRcdGZpbmRDb21wb25lbnQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZENvbXBvbmVudCggc2VsZWN0b3IgKTtcblx0XHRcdH0sXG5cdFx0XHRmaW5kQWxsQ29tcG9uZW50czogZnVuY3Rpb24oIHNlbGVjdG9yLCBxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZEFsbENvbXBvbmVudHMoIHNlbGVjdG9yLCBxdWVyeSApO1xuXHRcdFx0fSxcblx0XHRcdGZpcnN0Tm9kZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpcnN0Tm9kZSgpO1xuXHRcdFx0fSxcblx0XHRcdGZpbmROZXh0Tm9kZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSggdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdGdldFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZ2V0VmFsdWUoKTtcblx0XHRcdH0sXG5cdFx0XHRyZWJpbmQ6IGZ1bmN0aW9uKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHRcdHJlYmluZC5jYWxsKCB0aGlzLCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdFx0dGhpcy5mcmFnbWVudC5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0fSxcblx0XHRcdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuZG9jRnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHRcdFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG5cdFx0XHRcdHJldHVybiB0aGlzLmRvY0ZyYWc7XG5cdFx0XHR9LFxuXHRcdFx0cmVzb2x2ZTogTXVzdGFjaGUucmVzb2x2ZSxcblx0XHRcdHNldFZhbHVlOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdHZhciB0ZW1wbGF0ZTtcblx0XHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlID09PSB0aGlzLnZhbHVlICkge1xuXHRcdFx0XHRcdC8vIG5vdGhpbmcgaGFzIGNoYW5nZWQsIHNvIG5vIHdvcmsgdG8gYmUgZG9uZVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0ZW1wbGF0ZSA9IGdldFBhcnRpYWxUZW1wbGF0ZSggdGhpcy5yb290LCAnJyArIHZhbHVlICk7XG5cdFx0XHRcdC8vIHdlIG1heSBiZSBoZXJlIGlmIHdlIGhhdmUgYSBwYXJ0aWFsIGxpa2UgYHt7PmZvb319YCBhbmQgYGZvb2AgaXMgdGhlXG5cdFx0XHRcdC8vIG5hbWUgb2YgYm90aCBhIGRhdGEgcHJvcGVydHkgKHdob3NlIHZhbHVlIElTTidUIHRoZSBuYW1lIG9mIGEgcGFydGlhbClcblx0XHRcdFx0Ly8gYW5kIGEgcGFydGlhbC4gSW4gdGhvc2UgY2FzZXMsIHRoaXMgYmVjb21lcyBhIG5hbWVkIHBhcnRpYWxcblx0XHRcdFx0aWYgKCAhdGVtcGxhdGUgJiYgdGhpcy5uYW1lICYmICggdGVtcGxhdGUgPSBnZXRQYXJ0aWFsVGVtcGxhdGUoIHRoaXMucm9vdCwgdGhpcy5uYW1lICkgKSApIHtcblx0XHRcdFx0XHR1bmJpbmQuY2FsbCggdGhpcyApO1xuXHRcdFx0XHRcdHRoaXMuaXNOYW1lZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhdGVtcGxhdGUgKSB7XG5cdFx0XHRcdFx0bG9nLmVycm9yKCB7XG5cdFx0XHRcdFx0XHRkZWJ1ZzogdGhpcy5yb290LmRlYnVnLFxuXHRcdFx0XHRcdFx0bWVzc2FnZTogJ25vVGVtcGxhdGVGb3JQYXJ0aWFsJyxcblx0XHRcdFx0XHRcdGFyZ3M6IHtcblx0XHRcdFx0XHRcdFx0bmFtZTogdGhpcy5uYW1lXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuc2V0VGVtcGxhdGUoIHRlbXBsYXRlIHx8IFtdICk7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0dGhpcy5idWJibGUoKTtcblx0XHRcdFx0aWYgKCB0aGlzLnJlbmRlcmVkICkge1xuXHRcdFx0XHRcdHJ1bmxvb3AuYWRkVmlldyggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0c2V0VGVtcGxhdGU6IGZ1bmN0aW9uKCB0ZW1wbGF0ZSApIHtcblx0XHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuXHRcdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0XHRcdFx0dGhpcy5mcmFnbWVudFRvVW5yZW5kZXIgPSB0aGlzLmZyYWdtZW50O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIHtcblx0XHRcdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUsXG5cdFx0XHRcdFx0cm9vdDogdGhpcy5yb290LFxuXHRcdFx0XHRcdG93bmVyOiB0aGlzLFxuXHRcdFx0XHRcdHBFbGVtZW50OiB0aGlzLnBhcmVudEZyYWdtZW50LnBFbGVtZW50XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0dGhpcy5mcmFnbWVudFRvUmVuZGVyID0gdGhpcy5mcmFnbWVudDtcblx0XHRcdH0sXG5cdFx0XHR0b1N0cmluZzogZnVuY3Rpb24oIHRvU3RyaW5nICkge1xuXHRcdFx0XHR2YXIgc3RyaW5nLCBwcmV2aW91c0l0ZW0sIGxhc3RMaW5lLCBtYXRjaDtcblx0XHRcdFx0c3RyaW5nID0gdGhpcy5mcmFnbWVudC50b1N0cmluZyggdG9TdHJpbmcgKTtcblx0XHRcdFx0cHJldmlvdXNJdGVtID0gdGhpcy5wYXJlbnRGcmFnbWVudC5pdGVtc1sgdGhpcy5pbmRleCAtIDEgXTtcblx0XHRcdFx0aWYgKCAhcHJldmlvdXNJdGVtIHx8IHByZXZpb3VzSXRlbS50eXBlICE9PSB0eXBlcy5URVhUICkge1xuXHRcdFx0XHRcdHJldHVybiBzdHJpbmc7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGFzdExpbmUgPSBwcmV2aW91c0l0ZW0udGV4dC5zcGxpdCggJ1xcbicgKS5wb3AoKTtcblx0XHRcdFx0aWYgKCBtYXRjaCA9IC9eXFxzKyQvLmV4ZWMoIGxhc3RMaW5lICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGFwcGx5SW5kZW50KCBzdHJpbmcsIG1hdGNoWyAwIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc3RyaW5nO1xuXHRcdFx0fSxcblx0XHRcdHVuYmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIXRoaXMuaXNOYW1lZCApIHtcblx0XHRcdFx0XHQvLyBkeW5hbWljIHBhcnRpYWwgLSBuZWVkIHRvIHVuYmluZCBzZWxmXG5cdFx0XHRcdFx0dW5iaW5kLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVucmVuZGVyOiBmdW5jdGlvbiggc2hvdWxkRGVzdHJveSApIHtcblx0XHRcdFx0aWYgKCB0aGlzLnJlbmRlcmVkICkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5mcmFnbWVudCApIHtcblx0XHRcdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5yZW5kZXIoIHNob3VsZERlc3Ryb3kgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5yZW5kZXJlZCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHRhcmdldCwgYW5jaG9yO1xuXHRcdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnRUb1VucmVuZGVyICkge1xuXHRcdFx0XHRcdHRoaXMuZnJhZ21lbnRUb1VucmVuZGVyLnVucmVuZGVyKCB0cnVlICk7XG5cdFx0XHRcdFx0dGhpcy5mcmFnbWVudFRvVW5yZW5kZXIgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggdGhpcy5mcmFnbWVudFRvUmVuZGVyICkge1xuXHRcdFx0XHRcdHRoaXMuZG9jRnJhZy5hcHBlbmRDaGlsZCggdGhpcy5mcmFnbWVudFRvUmVuZGVyLnJlbmRlcigpICk7XG5cdFx0XHRcdFx0dGhpcy5mcmFnbWVudFRvUmVuZGVyID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHRoaXMucmVuZGVyZWQgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0ID0gdGhpcy5wYXJlbnRGcmFnbWVudC5nZXROb2RlKCk7XG5cdFx0XHRcdFx0YW5jaG9yID0gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUoIHRoaXMgKTtcblx0XHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCB0aGlzLmRvY0ZyYWcsIGFuY2hvciApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gUGFydGlhbDtcblx0fSggbG9nLCB0eXBlcywgZ2V0UGFydGlhbFRlbXBsYXRlLCBhcHBseUluZGVudCwgY2lyY3VsYXIsIHJ1bmxvb3AsIE11c3RhY2hlLCByZWJpbmQsIHVuYmluZCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L2dldENvbXBvbmVudC5qcyAqL1xuXHR2YXIgZ2V0Q29tcG9uZW50ID0gZnVuY3Rpb24oIGNvbmZpZywgbG9nLCBjaXJjdWxhciApIHtcblxuXHRcdHZhciBSYWN0aXZlO1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0UmFjdGl2ZSA9IGNpcmN1bGFyLlJhY3RpdmU7XG5cdFx0fSApO1xuXHRcdC8vIGZpbmRzIHRoZSBjb21wb25lbnQgY29uc3RydWN0b3IgaW4gdGhlIHJlZ2lzdHJ5IG9yIHZpZXcgaGllcmFyY2h5IHJlZ2lzdHJpZXNcblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0Q29tcG9uZW50KCByYWN0aXZlLCBuYW1lICkge1xuXHRcdFx0dmFyIGNvbXBvbmVudCwgaW5zdGFuY2UgPSBjb25maWcucmVnaXN0cmllcy5jb21wb25lbnRzLmZpbmRJbnN0YW5jZSggcmFjdGl2ZSwgbmFtZSApO1xuXHRcdFx0aWYgKCBpbnN0YW5jZSApIHtcblx0XHRcdFx0Y29tcG9uZW50ID0gaW5zdGFuY2UuY29tcG9uZW50c1sgbmFtZSBdO1xuXHRcdFx0XHQvLyBiZXN0IHRlc3Qgd2UgaGF2ZSBmb3Igbm90IFJhY3RpdmUuZXh0ZW5kXG5cdFx0XHRcdGlmICggIWNvbXBvbmVudC5fcGFyZW50ICkge1xuXHRcdFx0XHRcdC8vIGZ1bmN0aW9uIG9wdGlvbiwgZXhlY3V0ZSBhbmQgc3RvcmUgZm9yIHJlc2V0XG5cdFx0XHRcdFx0dmFyIGZuID0gY29tcG9uZW50LmJpbmQoIGluc3RhbmNlICk7XG5cdFx0XHRcdFx0Zm4uaXNPd25lciA9IGluc3RhbmNlLmNvbXBvbmVudHMuaGFzT3duUHJvcGVydHkoIG5hbWUgKTtcblx0XHRcdFx0XHRjb21wb25lbnQgPSBmbiggaW5zdGFuY2UuZGF0YSApO1xuXHRcdFx0XHRcdGlmICggIWNvbXBvbmVudCApIHtcblx0XHRcdFx0XHRcdGxvZy53YXJuKCB7XG5cdFx0XHRcdFx0XHRcdGRlYnVnOiByYWN0aXZlLmRlYnVnLFxuXHRcdFx0XHRcdFx0XHRtZXNzYWdlOiAnbm9SZWdpc3RyeUZ1bmN0aW9uUmV0dXJuJyxcblx0XHRcdFx0XHRcdFx0YXJnczoge1xuXHRcdFx0XHRcdFx0XHRcdHJlZ2lzdHJ5OiAnY29tcG9uZW50Jyxcblx0XHRcdFx0XHRcdFx0XHRuYW1lOiBuYW1lXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCB0eXBlb2YgY29tcG9uZW50ID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRcdC8vYWxsb3cgc3RyaW5nIGxvb2t1cFxuXHRcdFx0XHRcdFx0Y29tcG9uZW50ID0gZ2V0Q29tcG9uZW50KCByYWN0aXZlLCBjb21wb25lbnQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29tcG9uZW50Ll9mbiA9IGZuO1xuXHRcdFx0XHRcdGluc3RhbmNlLmNvbXBvbmVudHNbIG5hbWUgXSA9IGNvbXBvbmVudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNvbXBvbmVudDtcblx0XHR9O1xuXHR9KCBjb25maWcsIGxvZywgY2lyY3VsYXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9wcm90b3R5cGUvZGV0YWNoLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRkZXRhY2ggPSBmdW5jdGlvbiggSG9vayApIHtcblxuXHRcdHZhciBkZXRhY2hIb29rID0gbmV3IEhvb2soICdkZXRhY2gnICk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIENvbXBvbmVudCRkZXRhY2goKSB7XG5cdFx0XHR2YXIgZGV0YWNoZWQgPSB0aGlzLmluc3RhbmNlLmZyYWdtZW50LmRldGFjaCgpO1xuXHRcdFx0ZGV0YWNoSG9vay5maXJlKCB0aGlzLmluc3RhbmNlICk7XG5cdFx0XHRyZXR1cm4gZGV0YWNoZWQ7XG5cdFx0fTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfaG9va3NfSG9vayApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L3Byb3RvdHlwZS9maW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRmaW5kID0gZnVuY3Rpb24gQ29tcG9uZW50JGZpbmQoIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmluc3RhbmNlLmZyYWdtZW50LmZpbmQoIHNlbGVjdG9yICk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvcHJvdG90eXBlL2ZpbmRBbGwuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGZpbmRBbGwgPSBmdW5jdGlvbiBDb21wb25lbnQkZmluZEFsbCggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuXHRcdHJldHVybiB0aGlzLmluc3RhbmNlLmZyYWdtZW50LmZpbmRBbGwoIHNlbGVjdG9yLCBxdWVyeSApO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L3Byb3RvdHlwZS9maW5kQWxsQ29tcG9uZW50cy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkZmluZEFsbENvbXBvbmVudHMgPSBmdW5jdGlvbiBDb21wb25lbnQkZmluZEFsbENvbXBvbmVudHMoIHNlbGVjdG9yLCBxdWVyeSApIHtcblx0XHRxdWVyeS5fdGVzdCggdGhpcywgdHJ1ZSApO1xuXHRcdGlmICggdGhpcy5pbnN0YW5jZS5mcmFnbWVudCApIHtcblx0XHRcdHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQuZmluZEFsbENvbXBvbmVudHMoIHNlbGVjdG9yLCBxdWVyeSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9wcm90b3R5cGUvZmluZENvbXBvbmVudC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkZmluZENvbXBvbmVudCA9IGZ1bmN0aW9uIENvbXBvbmVudCRmaW5kQ29tcG9uZW50KCBzZWxlY3RvciApIHtcblx0XHRpZiAoICFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gdGhpcy5uYW1lICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaW5zdGFuY2U7XG5cdFx0fVxuXHRcdGlmICggdGhpcy5pbnN0YW5jZS5mcmFnbWVudCApIHtcblx0XHRcdHJldHVybiB0aGlzLmluc3RhbmNlLmZyYWdtZW50LmZpbmRDb21wb25lbnQoIHNlbGVjdG9yICk7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L3Byb3RvdHlwZS9maW5kTmV4dE5vZGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGZpbmROZXh0Tm9kZSA9IGZ1bmN0aW9uIENvbXBvbmVudCRmaW5kTmV4dE5vZGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKCB0aGlzICk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvcHJvdG90eXBlL2ZpcnN0Tm9kZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkZmlyc3ROb2RlID0gZnVuY3Rpb24gQ29tcG9uZW50JGZpcnN0Tm9kZSgpIHtcblx0XHRpZiAoIHRoaXMucmVuZGVyZWQgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pbnN0YW5jZS5mcmFnbWVudC5maXJzdE5vZGUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvaW5pdGlhbGlzZS9jcmVhdGVNb2RlbC9Db21wb25lbnRQYXJhbWV0ZXIuanMgKi9cblx0dmFyIENvbXBvbmVudFBhcmFtZXRlciA9IGZ1bmN0aW9uKCBydW5sb29wLCBjaXJjdWxhciApIHtcblxuXHRcdHZhciBGcmFnbWVudCwgQ29tcG9uZW50UGFyYW1ldGVyO1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0RnJhZ21lbnQgPSBjaXJjdWxhci5GcmFnbWVudDtcblx0XHR9ICk7XG5cdFx0Q29tcG9uZW50UGFyYW1ldGVyID0gZnVuY3Rpb24oIGNvbXBvbmVudCwga2V5LCB2YWx1ZSApIHtcblx0XHRcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBjb21wb25lbnQucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHR0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcblx0XHRcdHRoaXMua2V5ID0ga2V5O1xuXHRcdFx0dGhpcy5mcmFnbWVudCA9IG5ldyBGcmFnbWVudCgge1xuXHRcdFx0XHR0ZW1wbGF0ZTogdmFsdWUsXG5cdFx0XHRcdHJvb3Q6IGNvbXBvbmVudC5yb290LFxuXHRcdFx0XHRvd25lcjogdGhpc1xuXHRcdFx0fSApO1xuXHRcdFx0dGhpcy52YWx1ZSA9IHRoaXMuZnJhZ21lbnQuZ2V0VmFsdWUoKTtcblx0XHR9O1xuXHRcdENvbXBvbmVudFBhcmFtZXRlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRidWJibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICF0aGlzLmRpcnR5ICkge1xuXHRcdFx0XHRcdHRoaXMuZGlydHkgPSB0cnVlO1xuXHRcdFx0XHRcdHJ1bmxvb3AuYWRkVmlldyggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gdGhpcy5mcmFnbWVudC5nZXRWYWx1ZSgpO1xuXHRcdFx0XHR0aGlzLmNvbXBvbmVudC5pbnN0YW5jZS52aWV3bW9kZWwuc2V0KCB0aGlzLmtleSwgdmFsdWUgKTtcblx0XHRcdFx0cnVubG9vcC5hZGRWaWV3bW9kZWwoIHRoaXMuY29tcG9uZW50Lmluc3RhbmNlLnZpZXdtb2RlbCApO1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdHRoaXMuZGlydHkgPSBmYWxzZTtcblx0XHRcdH0sXG5cdFx0XHRyZWJpbmQ6IGZ1bmN0aW9uKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHRcdHRoaXMuZnJhZ21lbnQucmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdH0sXG5cdFx0XHR1bmJpbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIENvbXBvbmVudFBhcmFtZXRlcjtcblx0fSggcnVubG9vcCwgY2lyY3VsYXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9pbml0aWFsaXNlL2NyZWF0ZU1vZGVsL1JlZmVyZW5jZUV4cHJlc3Npb25QYXJhbWV0ZXIuanMgKi9cblx0dmFyIFJlZmVyZW5jZUV4cHJlc3Npb25QYXJhbWV0ZXIgPSBmdW5jdGlvbiggUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyLCBjcmVhdGVDb21wb25lbnRCaW5kaW5nICkge1xuXG5cdFx0dmFyIFJlZmVyZW5jZUV4cHJlc3Npb25QYXJhbWV0ZXIgPSBmdW5jdGlvbiggY29tcG9uZW50LCBjaGlsZEtleXBhdGgsIHRlbXBsYXRlLCB0b0JpbmQgKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdHRoaXMucm9vdCA9IGNvbXBvbmVudC5yb290O1xuXHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IGNvbXBvbmVudC5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHRoaXMucmVhZHkgPSBmYWxzZTtcblx0XHRcdHRoaXMuaGFzaCA9IG51bGw7XG5cdFx0XHR0aGlzLnJlc29sdmVyID0gbmV3IFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlciggdGhpcywgdGVtcGxhdGUsIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHQvLyBBcmUgd2UgdXBkYXRpbmcgYW4gZXhpc3RpbmcgYmluZGluZz9cblx0XHRcdFx0aWYgKCB0aGlzJDAuYmluZGluZyB8fCAoIHRoaXMkMC5iaW5kaW5nID0gY29tcG9uZW50LmJpbmRpbmdzWyB0aGlzJDAuaGFzaCBdICkgKSB7XG5cdFx0XHRcdFx0Y29tcG9uZW50LmJpbmRpbmdzWyB0aGlzJDAuaGFzaCBdID0gbnVsbDtcblx0XHRcdFx0XHR0aGlzJDAuYmluZGluZy5yZWJpbmQoIGtleXBhdGggKTtcblx0XHRcdFx0XHR0aGlzJDAuaGFzaCA9IGtleXBhdGggKyAnPScgKyBjaGlsZEtleXBhdGg7XG5cdFx0XHRcdFx0Y29tcG9uZW50LmJpbmRpbmdzWyB0aGlzJDAuaGFzaCBdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICggIXRoaXMkMC5yZWFkeSApIHtcblx0XHRcdFx0XHRcdC8vIFRoZSBjaGlsZCBpbnN0YW5jZSBpc24ndCBjcmVhdGVkIHlldCwgd2UgbmVlZCB0byBjcmVhdGUgdGhlIGJpbmRpbmcgbGF0ZXJcblx0XHRcdFx0XHRcdHRvQmluZC5wdXNoKCB7XG5cdFx0XHRcdFx0XHRcdGNoaWxkS2V5cGF0aDogY2hpbGRLZXlwYXRoLFxuXHRcdFx0XHRcdFx0XHRwYXJlbnRLZXlwYXRoOiBrZXlwYXRoXG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNyZWF0ZUNvbXBvbmVudEJpbmRpbmcoIGNvbXBvbmVudCwgY29tcG9uZW50LnJvb3QsIGtleXBhdGgsIGNoaWxkS2V5cGF0aCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzJDAudmFsdWUgPSBjb21wb25lbnQucm9vdC52aWV3bW9kZWwuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHR9ICk7XG5cdFx0fTtcblx0XHRSZWZlcmVuY2VFeHByZXNzaW9uUGFyYW1ldGVyLnByb3RvdHlwZSA9IHtcblx0XHRcdHJlYmluZDogZnVuY3Rpb24oIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdFx0dGhpcy5yZXNvbHZlci5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0fSxcblx0XHRcdHVuYmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMucmVzb2x2ZXIudW5iaW5kKCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gUmVmZXJlbmNlRXhwcmVzc2lvblBhcmFtZXRlcjtcblx0fSggUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyLCBjcmVhdGVDb21wb25lbnRCaW5kaW5nICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvaW5pdGlhbGlzZS9jcmVhdGVNb2RlbC9fY3JlYXRlTW9kZWwuanMgKi9cblx0dmFyIGNyZWF0ZU1vZGVsID0gZnVuY3Rpb24oIHR5cGVzLCBwYXJzZUpTT04sIHJlc29sdmVSZWYsIENvbXBvbmVudFBhcmFtZXRlciwgUmVmZXJlbmNlRXhwcmVzc2lvblBhcmFtZXRlciApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uKCBjb21wb25lbnQsIGRlZmF1bHREYXRhLCBhdHRyaWJ1dGVzLCB0b0JpbmQgKSB7XG5cdFx0XHR2YXIgZGF0YSA9IHt9LFxuXHRcdFx0XHRrZXksIHZhbHVlO1xuXHRcdFx0Ly8gc29tZSBwYXJhbWV0ZXJzLCBlLmcuIGZvbz1cIlRoZSB2YWx1ZSBpcyB7e2Jhcn19XCIsIGFyZSAnY29tcGxleCcgLSBpblxuXHRcdFx0Ly8gb3RoZXIgd29yZHMsIHdlIG5lZWQgdG8gY29uc3RydWN0IGEgc3RyaW5nIGZyYWdtZW50IHRvIHdhdGNoXG5cdFx0XHQvLyB3aGVuIHRoZXkgY2hhbmdlLiBXZSBzdG9yZSB0aGVzZSBzbyB0aGV5IGNhbiBiZSB0b3JuIGRvd24gbGF0ZXJcblx0XHRcdGNvbXBvbmVudC5jb21wbGV4UGFyYW1ldGVycyA9IFtdO1xuXHRcdFx0Zm9yICgga2V5IGluIGF0dHJpYnV0ZXMgKSB7XG5cdFx0XHRcdGlmICggYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBnZXRWYWx1ZSggY29tcG9uZW50LCBrZXksIGF0dHJpYnV0ZXNbIGtleSBdLCB0b0JpbmQgKTtcblx0XHRcdFx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgfHwgZGVmYXVsdERhdGFbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRkYXRhWyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGdldFZhbHVlKCBjb21wb25lbnQsIGtleSwgdGVtcGxhdGUsIHRvQmluZCApIHtcblx0XHRcdHZhciBwYXJhbWV0ZXIsIHBhcnNlZCwgcGFyZW50SW5zdGFuY2UsIHBhcmVudEZyYWdtZW50LCBrZXlwYXRoLCBpbmRleFJlZjtcblx0XHRcdHBhcmVudEluc3RhbmNlID0gY29tcG9uZW50LnJvb3Q7XG5cdFx0XHRwYXJlbnRGcmFnbWVudCA9IGNvbXBvbmVudC5wYXJlbnRGcmFnbWVudDtcblx0XHRcdC8vIElmIHRoaXMgaXMgYSBzdGF0aWMgdmFsdWUsIGdyZWF0XG5cdFx0XHRpZiAoIHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdHBhcnNlZCA9IHBhcnNlSlNPTiggdGVtcGxhdGUgKTtcblx0XHRcdFx0aWYgKCAhcGFyc2VkICkge1xuXHRcdFx0XHRcdHJldHVybiB0ZW1wbGF0ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcGFyc2VkLnZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgbnVsbCwgd2UgdHJlYXQgaXQgYXMgYSBib29sZWFuIGF0dHJpYnV0ZSAoaS5lLiB0cnVlKVxuXHRcdFx0aWYgKCB0ZW1wbGF0ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHQvLyBTaW5nbGUgaW50ZXJwb2xhdG9yP1xuXHRcdFx0aWYgKCB0ZW1wbGF0ZS5sZW5ndGggPT09IDEgJiYgdGVtcGxhdGVbIDAgXS50ID09PSB0eXBlcy5JTlRFUlBPTEFUT1IgKSB7XG5cdFx0XHRcdC8vIElmIGl0J3MgYSByZWd1bGFyIGludGVycG9sYXRvciwgd2UgYmluZCB0byBpdFxuXHRcdFx0XHRpZiAoIHRlbXBsYXRlWyAwIF0uciApIHtcblx0XHRcdFx0XHQvLyBJcyBpdCBhbiBpbmRleCByZWZlcmVuY2U/XG5cdFx0XHRcdFx0aWYgKCBwYXJlbnRGcmFnbWVudC5pbmRleFJlZnMgJiYgcGFyZW50RnJhZ21lbnQuaW5kZXhSZWZzWyBpbmRleFJlZiA9IHRlbXBsYXRlWyAwIF0uciBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRjb21wb25lbnQuaW5kZXhSZWZCaW5kaW5nc1sgaW5kZXhSZWYgXSA9IGtleTtcblx0XHRcdFx0XHRcdHJldHVybiBwYXJlbnRGcmFnbWVudC5pbmRleFJlZnNbIGluZGV4UmVmIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIFRPRE8gd2hhdCBhYm91dCByZWZlcmVuY2VzIHRoYXQgcmVzb2x2ZSBsYXRlPyBTaG91bGQgdGhlc2UgYmUgY29uc2lkZXJlZD9cblx0XHRcdFx0XHRrZXlwYXRoID0gcmVzb2x2ZVJlZiggcGFyZW50SW5zdGFuY2UsIHRlbXBsYXRlWyAwIF0uciwgcGFyZW50RnJhZ21lbnQgKSB8fCB0ZW1wbGF0ZVsgMCBdLnI7XG5cdFx0XHRcdFx0Ly8gV2UgbmVlZCB0byBzZXQgdXAgYmluZGluZ3MgYmV0d2VlbiBwYXJlbnQgYW5kIGNoaWxkLCBidXRcblx0XHRcdFx0XHQvLyB3ZSBjYW4ndCBkbyBpdCB5ZXQgYmVjYXVzZSB0aGUgY2hpbGQgaW5zdGFuY2UgZG9lc24ndCBleGlzdFxuXHRcdFx0XHRcdC8vIHlldCAtIHNvIHdlIG1ha2UgYSBub3RlIGluc3RlYWRcblx0XHRcdFx0XHR0b0JpbmQucHVzaCgge1xuXHRcdFx0XHRcdFx0Y2hpbGRLZXlwYXRoOiBrZXksXG5cdFx0XHRcdFx0XHRwYXJlbnRLZXlwYXRoOiBrZXlwYXRoXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdHJldHVybiBwYXJlbnRJbnN0YW5jZS52aWV3bW9kZWwuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gSWYgaXQncyBhIHJlZmVyZW5jZSBleHByZXNzaW9uIChlLmcuIGB7e2Zvb1tiYXJdfX1gKSwgd2UgbmVlZFxuXHRcdFx0XHQvLyB0byB3YXRjaCB0aGUga2V5cGF0aCBhbmQgY3JlYXRlL2Rlc3Ryb3kgYmluZGluZ3Ncblx0XHRcdFx0aWYgKCB0ZW1wbGF0ZVsgMCBdLnJ4ICkge1xuXHRcdFx0XHRcdHBhcmFtZXRlciA9IG5ldyBSZWZlcmVuY2VFeHByZXNzaW9uUGFyYW1ldGVyKCBjb21wb25lbnQsIGtleSwgdGVtcGxhdGVbIDAgXS5yeCwgdG9CaW5kICk7XG5cdFx0XHRcdFx0Y29tcG9uZW50LmNvbXBsZXhQYXJhbWV0ZXJzLnB1c2goIHBhcmFtZXRlciApO1xuXHRcdFx0XHRcdHBhcmFtZXRlci5yZWFkeSA9IHRydWU7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcmFtZXRlci52YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gV2UgaGF2ZSBhICdjb21wbGV4IHBhcmFtZXRlcicgLSB3ZSBuZWVkIHRvIGNyZWF0ZSBhIGZ1bGwtYmxvd24gc3RyaW5nXG5cdFx0XHQvLyBmcmFnbWVudCBpbiBvcmRlciB0byBldmFsdWF0ZSBhbmQgb2JzZXJ2ZSBpdHMgdmFsdWVcblx0XHRcdHBhcmFtZXRlciA9IG5ldyBDb21wb25lbnRQYXJhbWV0ZXIoIGNvbXBvbmVudCwga2V5LCB0ZW1wbGF0ZSApO1xuXHRcdFx0Y29tcG9uZW50LmNvbXBsZXhQYXJhbWV0ZXJzLnB1c2goIHBhcmFtZXRlciApO1xuXHRcdFx0cmV0dXJuIHBhcmFtZXRlci52YWx1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCB0eXBlcywgcGFyc2VKU09OLCByZXNvbHZlUmVmLCBDb21wb25lbnRQYXJhbWV0ZXIsIFJlZmVyZW5jZUV4cHJlc3Npb25QYXJhbWV0ZXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9pbml0aWFsaXNlL2NyZWF0ZUluc3RhbmNlLmpzICovXG5cdHZhciBjcmVhdGVJbnN0YW5jZSA9IGZ1bmN0aW9uKCBsb2cgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIGNvbXBvbmVudCwgQ29tcG9uZW50LCBkYXRhLCBjb250ZW50RGVzY3JpcHRvciApIHtcblx0XHRcdHZhciBpbnN0YW5jZSwgcGFyZW50RnJhZ21lbnQsIHBhcnRpYWxzLCByYWN0aXZlO1xuXHRcdFx0cGFyZW50RnJhZ21lbnQgPSBjb21wb25lbnQucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHRyYWN0aXZlID0gY29tcG9uZW50LnJvb3Q7XG5cdFx0XHQvLyBNYWtlIGNvbnRlbnRzIGF2YWlsYWJsZSBhcyBhIHt7PmNvbnRlbnR9fSBwYXJ0aWFsXG5cdFx0XHRwYXJ0aWFscyA9IHtcblx0XHRcdFx0Y29udGVudDogY29udGVudERlc2NyaXB0b3IgfHwgW11cblx0XHRcdH07XG5cdFx0XHRpZiAoIENvbXBvbmVudC5kZWZhdWx0cy5lbCApIHtcblx0XHRcdFx0bG9nLndhcm4oIHtcblx0XHRcdFx0XHRkZWJ1ZzogcmFjdGl2ZS5kZWJ1Zyxcblx0XHRcdFx0XHRtZXNzYWdlOiAnZGVmYXVsdEVsU3BlY2lmaWVkJyxcblx0XHRcdFx0XHRhcmdzOiB7XG5cdFx0XHRcdFx0XHRuYW1lOiBjb21wb25lbnQubmFtZVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0aW5zdGFuY2UgPSBuZXcgQ29tcG9uZW50KCB7XG5cdFx0XHRcdGVsOiBudWxsLFxuXHRcdFx0XHRhcHBlbmQ6IHRydWUsXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdHBhcnRpYWxzOiBwYXJ0aWFscyxcblx0XHRcdFx0bWFnaWM6IHJhY3RpdmUubWFnaWMgfHwgQ29tcG9uZW50LmRlZmF1bHRzLm1hZ2ljLFxuXHRcdFx0XHRtb2RpZnlBcnJheXM6IHJhY3RpdmUubW9kaWZ5QXJyYXlzLFxuXHRcdFx0XHRfcGFyZW50OiByYWN0aXZlLFxuXHRcdFx0XHRfY29tcG9uZW50OiBjb21wb25lbnQsXG5cdFx0XHRcdC8vIG5lZWQgdG8gaW5oZXJpdCBydW50aW1lIHBhcmVudCBhZGFwdG9yc1xuXHRcdFx0XHRhZGFwdDogcmFjdGl2ZS5hZGFwdCxcblx0XHRcdFx0eWllbGQ6IHtcblx0XHRcdFx0XHR0ZW1wbGF0ZTogY29udGVudERlc2NyaXB0b3IsXG5cdFx0XHRcdFx0aW5zdGFuY2U6IHJhY3RpdmVcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdFx0cmV0dXJuIGluc3RhbmNlO1xuXHRcdH07XG5cdH0oIGxvZyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L2luaXRpYWxpc2UvY3JlYXRlQmluZGluZ3MuanMgKi9cblx0dmFyIGNyZWF0ZUJpbmRpbmdzID0gZnVuY3Rpb24oIGNyZWF0ZUNvbXBvbmVudEJpbmRpbmcgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gY3JlYXRlSW5pdGlhbENvbXBvbmVudEJpbmRpbmdzKCBjb21wb25lbnQsIHRvQmluZCApIHtcblx0XHRcdHRvQmluZC5mb3JFYWNoKCBmdW5jdGlvbiBjcmVhdGVJbml0aWFsQ29tcG9uZW50QmluZGluZyggcGFpciApIHtcblx0XHRcdFx0dmFyIGNoaWxkVmFsdWUsIHBhcmVudFZhbHVlO1xuXHRcdFx0XHRjcmVhdGVDb21wb25lbnRCaW5kaW5nKCBjb21wb25lbnQsIGNvbXBvbmVudC5yb290LCBwYWlyLnBhcmVudEtleXBhdGgsIHBhaXIuY2hpbGRLZXlwYXRoICk7XG5cdFx0XHRcdGNoaWxkVmFsdWUgPSBjb21wb25lbnQuaW5zdGFuY2Uudmlld21vZGVsLmdldCggcGFpci5jaGlsZEtleXBhdGggKTtcblx0XHRcdFx0cGFyZW50VmFsdWUgPSBjb21wb25lbnQucm9vdC52aWV3bW9kZWwuZ2V0KCBwYWlyLnBhcmVudEtleXBhdGggKTtcblx0XHRcdFx0aWYgKCBjaGlsZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgcGFyZW50VmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRjb21wb25lbnQucm9vdC52aWV3bW9kZWwuc2V0KCBwYWlyLnBhcmVudEtleXBhdGgsIGNoaWxkVmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH07XG5cdH0oIGNyZWF0ZUNvbXBvbmVudEJpbmRpbmcgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9pbml0aWFsaXNlL3Byb3BhZ2F0ZUV2ZW50cy5qcyAqL1xuXHR2YXIgcHJvcGFnYXRlRXZlbnRzID0gZnVuY3Rpb24oIGNpcmN1bGFyLCBmaXJlRXZlbnQsIGxvZyApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgRnJhZ21lbnQ7XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRGcmFnbWVudCA9IGNpcmN1bGFyLkZyYWdtZW50O1xuXHRcdH0gKTtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIHByb3BhZ2F0ZUV2ZW50cyggY29tcG9uZW50LCBldmVudHNEZXNjcmlwdG9yICkge1xuXHRcdFx0dmFyIGV2ZW50TmFtZTtcblx0XHRcdGZvciAoIGV2ZW50TmFtZSBpbiBldmVudHNEZXNjcmlwdG9yICkge1xuXHRcdFx0XHRpZiAoIGV2ZW50c0Rlc2NyaXB0b3IuaGFzT3duUHJvcGVydHkoIGV2ZW50TmFtZSApICkge1xuXHRcdFx0XHRcdHByb3BhZ2F0ZUV2ZW50KCBjb21wb25lbnQuaW5zdGFuY2UsIGNvbXBvbmVudC5yb290LCBldmVudE5hbWUsIGV2ZW50c0Rlc2NyaXB0b3JbIGV2ZW50TmFtZSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcHJvcGFnYXRlRXZlbnQoIGNoaWxkSW5zdGFuY2UsIHBhcmVudEluc3RhbmNlLCBldmVudE5hbWUsIHByb3h5RXZlbnROYW1lICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgcHJveHlFdmVudE5hbWUgIT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRsb2cuZXJyb3IoIHtcblx0XHRcdFx0XHRkZWJ1ZzogcGFyZW50SW5zdGFuY2UuZGVidWcsXG5cdFx0XHRcdFx0bWVzc2FnZTogJ25vQ29tcG9uZW50RXZlbnRBcmd1bWVudHMnXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdGNoaWxkSW5zdGFuY2Uub24oIGV2ZW50TmFtZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBldmVudCwgYXJncztcblx0XHRcdFx0Ly8gc2VtaS13ZWFrIHRlc3QsIGJ1dCB3aGF0IGVsc2U/IHRhZyB0aGUgZXZlbnQgb2JqIC5faXNFdmVudCA/XG5cdFx0XHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCAmJiBhcmd1bWVudHNbIDAgXSAmJiBhcmd1bWVudHNbIDAgXS5ub2RlICkge1xuXHRcdFx0XHRcdGV2ZW50ID0gQXJyYXkucHJvdG90eXBlLnNoaWZ0LmNhbGwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdGZpcmVFdmVudCggcGFyZW50SW5zdGFuY2UsIHByb3h5RXZlbnROYW1lLCB7XG5cdFx0XHRcdFx0ZXZlbnQ6IGV2ZW50LFxuXHRcdFx0XHRcdGFyZ3M6IGFyZ3Ncblx0XHRcdFx0fSApO1xuXHRcdFx0XHQvLyBjYW5jZWwgYnViYmxpbmdcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIGNpcmN1bGFyLCBSYWN0aXZlJHNoYXJlZF9maXJlRXZlbnQsIGxvZyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L2luaXRpYWxpc2UvdXBkYXRlTGl2ZVF1ZXJpZXMuanMgKi9cblx0dmFyIHVwZGF0ZUxpdmVRdWVyaWVzID0gZnVuY3Rpb24oIGNvbXBvbmVudCApIHtcblx0XHR2YXIgYW5jZXN0b3IsIHF1ZXJ5O1xuXHRcdC8vIElmIHRoZXJlJ3MgYSBsaXZlIHF1ZXJ5IGZvciB0aGlzIGNvbXBvbmVudCB0eXBlLCBhZGQgaXRcblx0XHRhbmNlc3RvciA9IGNvbXBvbmVudC5yb290O1xuXHRcdHdoaWxlICggYW5jZXN0b3IgKSB7XG5cdFx0XHRpZiAoIHF1ZXJ5ID0gYW5jZXN0b3IuX2xpdmVDb21wb25lbnRRdWVyaWVzWyAnXycgKyBjb21wb25lbnQubmFtZSBdICkge1xuXHRcdFx0XHRxdWVyeS5wdXNoKCBjb21wb25lbnQuaW5zdGFuY2UgKTtcblx0XHRcdH1cblx0XHRcdGFuY2VzdG9yID0gYW5jZXN0b3IuX3BhcmVudDtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvcHJvdG90eXBlL2luaXQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGluaXQgPSBmdW5jdGlvbiggdHlwZXMsIHdhcm4sIGNyZWF0ZU1vZGVsLCBjcmVhdGVJbnN0YW5jZSwgY3JlYXRlQmluZGluZ3MsIHByb3BhZ2F0ZUV2ZW50cywgdXBkYXRlTGl2ZVF1ZXJpZXMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gQ29tcG9uZW50JGluaXQoIG9wdGlvbnMsIENvbXBvbmVudCApIHtcblx0XHRcdHZhciBwYXJlbnRGcmFnbWVudCwgcm9vdCwgZGF0YSwgdG9CaW5kO1xuXHRcdFx0cGFyZW50RnJhZ21lbnQgPSB0aGlzLnBhcmVudEZyYWdtZW50ID0gb3B0aW9ucy5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHJvb3QgPSBwYXJlbnRGcmFnbWVudC5yb290O1xuXHRcdFx0dGhpcy5yb290ID0gcm9vdDtcblx0XHRcdHRoaXMudHlwZSA9IHR5cGVzLkNPTVBPTkVOVDtcblx0XHRcdHRoaXMubmFtZSA9IG9wdGlvbnMudGVtcGxhdGUuZTtcblx0XHRcdHRoaXMuaW5kZXggPSBvcHRpb25zLmluZGV4O1xuXHRcdFx0dGhpcy5pbmRleFJlZkJpbmRpbmdzID0ge307XG5cdFx0XHR0aGlzLmJpbmRpbmdzID0gW107XG5cdFx0XHQvLyBldmVuIHRob3VnaCBvbmx5IG9uZSB5aWVsZGVyIGlzIGFsbG93ZWQsIHdlIG5lZWQgdG8gaGF2ZSBhbiBhcnJheSBvZiB0aGVtXG5cdFx0XHQvLyBhcyBpdCdzIHBvc3NpYmxlIHRvIGNhdXNlIGEgeWllbGRlciB0byBiZSBjcmVhdGVkIGJlZm9yZSB0aGUgbGFzdCBvbmVcblx0XHRcdC8vIHdhcyBkZXN0cm95ZWQgaW4gdGhlIHNhbWUgdHVybiBvZiB0aGUgcnVubG9vcFxuXHRcdFx0dGhpcy55aWVsZGVycyA9IFtdO1xuXHRcdFx0aWYgKCAhQ29tcG9uZW50ICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdDb21wb25lbnQgXCInICsgdGhpcy5uYW1lICsgJ1wiIG5vdCBmb3VuZCcgKTtcblx0XHRcdH1cblx0XHRcdC8vIEZpcnN0LCB3ZSBuZWVkIHRvIGNyZWF0ZSBhIG1vZGVsIGZvciB0aGUgY29tcG9uZW50IC0gZS5nLiBpZiB3ZVxuXHRcdFx0Ly8gZW5jb3VudGVyIDx3aWRnZXQgZm9vPSdiYXInLz4gdGhlbiB3ZSBuZWVkIHRvIGNyZWF0ZSBhIHdpZGdldFxuXHRcdFx0Ly8gd2l0aCBgZGF0YTogeyBmb286ICdiYXInIH1gLlxuXHRcdFx0Ly9cblx0XHRcdC8vIFRoaXMgbWF5IGludm9sdmUgc2V0dGluZyB1cCBzb21lIGJpbmRpbmdzLCBidXQgd2UgY2FuJ3QgZG8gaXRcblx0XHRcdC8vIHlldCBzbyB3ZSB0YWtlIHNvbWUgbm90ZXMgaW5zdGVhZFxuXHRcdFx0dG9CaW5kID0gW107XG5cdFx0XHRkYXRhID0gY3JlYXRlTW9kZWwoIHRoaXMsIENvbXBvbmVudC5kZWZhdWx0cy5kYXRhIHx8IHt9LCBvcHRpb25zLnRlbXBsYXRlLmEsIHRvQmluZCApO1xuXHRcdFx0Y3JlYXRlSW5zdGFuY2UoIHRoaXMsIENvbXBvbmVudCwgZGF0YSwgb3B0aW9ucy50ZW1wbGF0ZS5mICk7XG5cdFx0XHRjcmVhdGVCaW5kaW5ncyggdGhpcywgdG9CaW5kICk7XG5cdFx0XHRwcm9wYWdhdGVFdmVudHMoIHRoaXMsIG9wdGlvbnMudGVtcGxhdGUudiApO1xuXHRcdFx0Ly8gaW50cm8sIG91dHJvIGFuZCBkZWNvcmF0b3IgZGlyZWN0aXZlcyBoYXZlIG5vIGVmZmVjdFxuXHRcdFx0aWYgKCBvcHRpb25zLnRlbXBsYXRlLnQxIHx8IG9wdGlvbnMudGVtcGxhdGUudDIgfHwgb3B0aW9ucy50ZW1wbGF0ZS5vICkge1xuXHRcdFx0XHR3YXJuKCAnVGhlIFwiaW50cm9cIiwgXCJvdXRyb1wiIGFuZCBcImRlY29yYXRvclwiIGRpcmVjdGl2ZXMgaGF2ZSBubyBlZmZlY3Qgb24gY29tcG9uZW50cycgKTtcblx0XHRcdH1cblx0XHRcdHVwZGF0ZUxpdmVRdWVyaWVzKCB0aGlzICk7XG5cdFx0fTtcblx0fSggdHlwZXMsIHdhcm4sIGNyZWF0ZU1vZGVsLCBjcmVhdGVJbnN0YW5jZSwgY3JlYXRlQmluZGluZ3MsIHByb3BhZ2F0ZUV2ZW50cywgdXBkYXRlTGl2ZVF1ZXJpZXMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9wcm90b3R5cGUvcmViaW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRyZWJpbmQgPSBmdW5jdGlvbiggcnVubG9vcCwgZ2V0TmV3S2V5cGF0aCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBDb21wb25lbnQkcmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHR2YXIgY2hpbGRJbnN0YW5jZSA9IHRoaXMuaW5zdGFuY2UsXG5cdFx0XHRcdHBhcmVudEluc3RhbmNlID0gY2hpbGRJbnN0YW5jZS5fcGFyZW50LFxuXHRcdFx0XHRpbmRleFJlZkFsaWFzLCBxdWVyeTtcblx0XHRcdHRoaXMuYmluZGluZ3MuZm9yRWFjaCggZnVuY3Rpb24oIGJpbmRpbmcgKSB7XG5cdFx0XHRcdHZhciB1cGRhdGVkO1xuXHRcdFx0XHRpZiAoIGJpbmRpbmcucm9vdCAhPT0gcGFyZW50SW5zdGFuY2UgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggdXBkYXRlZCA9IGdldE5ld0tleXBhdGgoIGJpbmRpbmcua2V5cGF0aCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApICkge1xuXHRcdFx0XHRcdGJpbmRpbmcucmViaW5kKCB1cGRhdGVkICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHRcdHRoaXMuY29tcGxleFBhcmFtZXRlcnMuZm9yRWFjaCggcmViaW5kICk7XG5cdFx0XHRpZiAoIHRoaXMueWllbGRlcnNbIDAgXSApIHtcblx0XHRcdFx0cmViaW5kKCB0aGlzLnlpZWxkZXJzWyAwIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggaW5kZXhSZWZBbGlhcyA9IHRoaXMuaW5kZXhSZWZCaW5kaW5nc1sgaW5kZXhSZWYgXSApIHtcblx0XHRcdFx0cnVubG9vcC5hZGRWaWV3bW9kZWwoIGNoaWxkSW5zdGFuY2Uudmlld21vZGVsICk7XG5cdFx0XHRcdGNoaWxkSW5zdGFuY2Uudmlld21vZGVsLnNldCggaW5kZXhSZWZBbGlhcywgbmV3SW5kZXggKTtcblx0XHRcdH1cblx0XHRcdGlmICggcXVlcnkgPSB0aGlzLnJvb3QuX2xpdmVDb21wb25lbnRRdWVyaWVzWyAnXycgKyB0aGlzLm5hbWUgXSApIHtcblx0XHRcdFx0cXVlcnkuX21ha2VEaXJ0eSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiByZWJpbmQoIHggKSB7XG5cdFx0XHRcdHgucmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBydW5sb29wLCBnZXROZXdLZXlwYXRoICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvcHJvdG90eXBlL3JlbmRlci5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkcmVuZGVyID0gZnVuY3Rpb24gQ29tcG9uZW50JHJlbmRlcigpIHtcblx0XHR2YXIgaW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlO1xuXHRcdGluc3RhbmNlLnJlbmRlciggdGhpcy5wYXJlbnRGcmFnbWVudC5nZXROb2RlKCkgKTtcblx0XHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcblx0XHRyZXR1cm4gaW5zdGFuY2UuZnJhZ21lbnQuZGV0YWNoKCk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvcHJvdG90eXBlL3RvU3RyaW5nLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCR0b1N0cmluZyA9IGZ1bmN0aW9uIENvbXBvbmVudCR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5pbnN0YW5jZS5mcmFnbWVudC50b1N0cmluZygpO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L3Byb3RvdHlwZS91bmJpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JHVuYmluZCA9IGZ1bmN0aW9uKCBIb29rLCByZW1vdmVGcm9tQXJyYXkgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIHRlYXJkb3duSG9vayA9IG5ldyBIb29rKCAndGVhcmRvd24nICk7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBDb21wb25lbnQkdW5iaW5kKCkge1xuXHRcdFx0dmFyIGluc3RhbmNlID0gdGhpcy5pbnN0YW5jZTtcblx0XHRcdHRoaXMuY29tcGxleFBhcmFtZXRlcnMuZm9yRWFjaCggdW5iaW5kICk7XG5cdFx0XHR0aGlzLmJpbmRpbmdzLmZvckVhY2goIHVuYmluZCApO1xuXHRcdFx0cmVtb3ZlRnJvbUxpdmVDb21wb25lbnRRdWVyaWVzKCB0aGlzICk7XG5cdFx0XHQvLyB0ZWFyZG93biB0aGUgaW5zdGFuY2Vcblx0XHRcdGluc3RhbmNlLmZyYWdtZW50LnVuYmluZCgpO1xuXHRcdFx0aW5zdGFuY2Uudmlld21vZGVsLnRlYXJkb3duKCk7XG5cdFx0XHRpZiAoIGluc3RhbmNlLmZyYWdtZW50LnJlbmRlcmVkICYmIGluc3RhbmNlLmVsLl9fcmFjdGl2ZV9pbnN0YW5jZXNfXyApIHtcblx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCBpbnN0YW5jZS5lbC5fX3JhY3RpdmVfaW5zdGFuY2VzX18sIGluc3RhbmNlICk7XG5cdFx0XHR9XG5cdFx0XHR0ZWFyZG93bkhvb2suZmlyZSggaW5zdGFuY2UgKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdW5iaW5kKCB0aGluZyApIHtcblx0XHRcdHRoaW5nLnVuYmluZCgpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlbW92ZUZyb21MaXZlQ29tcG9uZW50UXVlcmllcyggY29tcG9uZW50ICkge1xuXHRcdFx0dmFyIGluc3RhbmNlLCBxdWVyeTtcblx0XHRcdGluc3RhbmNlID0gY29tcG9uZW50LnJvb3Q7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGlmICggcXVlcnkgPSBpbnN0YW5jZS5fbGl2ZUNvbXBvbmVudFF1ZXJpZXNbICdfJyArIGNvbXBvbmVudC5uYW1lIF0gKSB7XG5cdFx0XHRcdFx0cXVlcnkuX3JlbW92ZSggY29tcG9uZW50ICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gd2hpbGUgKCBpbnN0YW5jZSA9IGluc3RhbmNlLl9wYXJlbnQgKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9ob29rc19Ib29rLCByZW1vdmVGcm9tQXJyYXkgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9wcm90b3R5cGUvdW5yZW5kZXIuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JHVucmVuZGVyID0gZnVuY3Rpb24gQ29tcG9uZW50JHVucmVuZGVyKCBzaG91bGREZXN0cm95ICkge1xuXHRcdHRoaXMuc2hvdWxkRGVzdHJveSA9IHNob3VsZERlc3Ryb3k7XG5cdFx0dGhpcy5pbnN0YW5jZS51bnJlbmRlcigpO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L19Db21wb25lbnQuanMgKi9cblx0dmFyIENvbXBvbmVudCA9IGZ1bmN0aW9uKCBkZXRhY2gsIGZpbmQsIGZpbmRBbGwsIGZpbmRBbGxDb21wb25lbnRzLCBmaW5kQ29tcG9uZW50LCBmaW5kTmV4dE5vZGUsIGZpcnN0Tm9kZSwgaW5pdCwgcmViaW5kLCByZW5kZXIsIHRvU3RyaW5nLCB1bmJpbmQsIHVucmVuZGVyICkge1xuXG5cdFx0dmFyIENvbXBvbmVudCA9IGZ1bmN0aW9uKCBvcHRpb25zLCBDb25zdHJ1Y3RvciApIHtcblx0XHRcdHRoaXMuaW5pdCggb3B0aW9ucywgQ29uc3RydWN0b3IgKTtcblx0XHR9O1xuXHRcdENvbXBvbmVudC5wcm90b3R5cGUgPSB7XG5cdFx0XHRkZXRhY2g6IGRldGFjaCxcblx0XHRcdGZpbmQ6IGZpbmQsXG5cdFx0XHRmaW5kQWxsOiBmaW5kQWxsLFxuXHRcdFx0ZmluZEFsbENvbXBvbmVudHM6IGZpbmRBbGxDb21wb25lbnRzLFxuXHRcdFx0ZmluZENvbXBvbmVudDogZmluZENvbXBvbmVudCxcblx0XHRcdGZpbmROZXh0Tm9kZTogZmluZE5leHROb2RlLFxuXHRcdFx0Zmlyc3ROb2RlOiBmaXJzdE5vZGUsXG5cdFx0XHRpbml0OiBpbml0LFxuXHRcdFx0cmViaW5kOiByZWJpbmQsXG5cdFx0XHRyZW5kZXI6IHJlbmRlcixcblx0XHRcdHRvU3RyaW5nOiB0b1N0cmluZyxcblx0XHRcdHVuYmluZDogdW5iaW5kLFxuXHRcdFx0dW5yZW5kZXI6IHVucmVuZGVyXG5cdFx0fTtcblx0XHRyZXR1cm4gQ29tcG9uZW50O1xuXHR9KCB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRkZXRhY2gsIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGZpbmQsIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGZpbmRBbGwsIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGZpbmRBbGxDb21wb25lbnRzLCB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRmaW5kQ29tcG9uZW50LCB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRmaW5kTmV4dE5vZGUsIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGZpcnN0Tm9kZSwgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkaW5pdCwgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkcmViaW5kLCB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRyZW5kZXIsIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JHRvU3RyaW5nLCB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCR1bmJpbmQsIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JHVucmVuZGVyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21tZW50LmpzICovXG5cdHZhciBDb21tZW50ID0gZnVuY3Rpb24oIHR5cGVzLCBkZXRhY2ggKSB7XG5cblx0XHR2YXIgQ29tbWVudCA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0dGhpcy50eXBlID0gdHlwZXMuQ09NTUVOVDtcblx0XHRcdHRoaXMudmFsdWUgPSBvcHRpb25zLnRlbXBsYXRlLmM7XG5cdFx0fTtcblx0XHRDb21tZW50LnByb3RvdHlwZSA9IHtcblx0XHRcdGRldGFjaDogZGV0YWNoLFxuXHRcdFx0Zmlyc3ROb2RlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMubm9kZTtcblx0XHRcdH0sXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICF0aGlzLm5vZGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5ub2RlID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCggdGhpcy52YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLm5vZGU7XG5cdFx0XHR9LFxuXHRcdFx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gJzwhLS0nICsgdGhpcy52YWx1ZSArICctLT4nO1xuXHRcdFx0fSxcblx0XHRcdHVucmVuZGVyOiBmdW5jdGlvbiggc2hvdWxkRGVzdHJveSApIHtcblx0XHRcdFx0aWYgKCBzaG91bGREZXN0cm95ICkge1xuXHRcdFx0XHRcdHRoaXMubm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCB0aGlzLm5vZGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIENvbW1lbnQ7XG5cdH0oIHR5cGVzLCBkZXRhY2ggKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1lpZWxkZXIuanMgKi9cblx0dmFyIFlpZWxkZXIgPSBmdW5jdGlvbiggcnVubG9vcCwgcmVtb3ZlRnJvbUFycmF5LCBjaXJjdWxhciApIHtcblxuXHRcdHZhciBGcmFnbWVudDtcblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdEZyYWdtZW50ID0gY2lyY3VsYXIuRnJhZ21lbnQ7XG5cdFx0fSApO1xuXHRcdHZhciBZaWVsZGVyID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgY29tcG9uZW50SW5zdGFuY2UsIGNvbXBvbmVudDtcblx0XHRcdGNvbXBvbmVudEluc3RhbmNlID0gb3B0aW9ucy5wYXJlbnRGcmFnbWVudC5yb290O1xuXHRcdFx0dGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQgPSBjb21wb25lbnRJbnN0YW5jZS5jb21wb25lbnQ7XG5cdFx0XHR0aGlzLnN1cnJvZ2F0ZVBhcmVudCA9IG9wdGlvbnMucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHR0aGlzLnBhcmVudEZyYWdtZW50ID0gY29tcG9uZW50LnBhcmVudEZyYWdtZW50O1xuXHRcdFx0dGhpcy5mcmFnbWVudCA9IG5ldyBGcmFnbWVudCgge1xuXHRcdFx0XHRvd25lcjogdGhpcyxcblx0XHRcdFx0cm9vdDogY29tcG9uZW50SW5zdGFuY2UueWllbGQuaW5zdGFuY2UsXG5cdFx0XHRcdHRlbXBsYXRlOiBjb21wb25lbnRJbnN0YW5jZS55aWVsZC50ZW1wbGF0ZSxcblx0XHRcdFx0cEVsZW1lbnQ6IHRoaXMuc3Vycm9nYXRlUGFyZW50LnBFbGVtZW50XG5cdFx0XHR9ICk7XG5cdFx0XHRjb21wb25lbnQueWllbGRlcnMucHVzaCggdGhpcyApO1xuXHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNvbXBvbmVudC55aWVsZGVycy5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0EgY29tcG9uZW50IHRlbXBsYXRlIGNhbiBvbmx5IGhhdmUgb25lIHt7eWllbGR9fSBkZWNsYXJhdGlvbiBhdCBhIHRpbWUnICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9O1xuXHRcdFlpZWxkZXIucHJvdG90eXBlID0ge1xuXHRcdFx0ZGV0YWNoOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZGV0YWNoKCk7XG5cdFx0XHR9LFxuXHRcdFx0ZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0fSxcblx0XHRcdGZpbmRBbGw6IGZ1bmN0aW9uKCBzZWxlY3RvciwgcXVlcnkgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRBbGwoIHNlbGVjdG9yLCBxdWVyeSApO1xuXHRcdFx0fSxcblx0XHRcdGZpbmRDb21wb25lbnQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZENvbXBvbmVudCggc2VsZWN0b3IgKTtcblx0XHRcdH0sXG5cdFx0XHRmaW5kQWxsQ29tcG9uZW50czogZnVuY3Rpb24oIHNlbGVjdG9yLCBxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZEFsbENvbXBvbmVudHMoIHNlbGVjdG9yLCBxdWVyeSApO1xuXHRcdFx0fSxcblx0XHRcdGZpbmROZXh0Tm9kZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnN1cnJvZ2F0ZVBhcmVudC5maW5kTmV4dE5vZGUoIHRoaXMgKTtcblx0XHRcdH0sXG5cdFx0XHRmaXJzdE5vZGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maXJzdE5vZGUoKTtcblx0XHRcdH0sXG5cdFx0XHRnZXRWYWx1ZTogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmdldFZhbHVlKCBvcHRpb25zICk7XG5cdFx0XHR9LFxuXHRcdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQucmVuZGVyKCk7XG5cdFx0XHR9LFxuXHRcdFx0dW5iaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oIHNob3VsZERlc3Ryb3kgKSB7XG5cdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5yZW5kZXIoIHNob3VsZERlc3Ryb3kgKTtcblx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCB0aGlzLmNvbXBvbmVudC55aWVsZGVycywgdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdHJlYmluZDogZnVuY3Rpb24oIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdFx0dGhpcy5mcmFnbWVudC5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0fSxcblx0XHRcdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBZaWVsZGVyO1xuXHR9KCBydW5sb29wLCByZW1vdmVGcm9tQXJyYXksIGNpcmN1bGFyICk7XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvaW5pdC9jcmVhdGVJdGVtLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JGluaXRfY3JlYXRlSXRlbSA9IGZ1bmN0aW9uKCB0eXBlcywgVGV4dCwgSW50ZXJwb2xhdG9yLCBTZWN0aW9uLCBUcmlwbGUsIEVsZW1lbnQsIFBhcnRpYWwsIGdldENvbXBvbmVudCwgQ29tcG9uZW50LCBDb21tZW50LCBZaWVsZGVyICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUl0ZW0oIG9wdGlvbnMgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBvcHRpb25zLnRlbXBsYXRlID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBUZXh0KCBvcHRpb25zICk7XG5cdFx0XHR9XG5cdFx0XHRzd2l0Y2ggKCBvcHRpb25zLnRlbXBsYXRlLnQgKSB7XG5cdFx0XHRcdGNhc2UgdHlwZXMuSU5URVJQT0xBVE9SOlxuXHRcdFx0XHRcdGlmICggb3B0aW9ucy50ZW1wbGF0ZS5yID09PSAneWllbGQnICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBZaWVsZGVyKCBvcHRpb25zICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBuZXcgSW50ZXJwb2xhdG9yKCBvcHRpb25zICk7XG5cdFx0XHRcdGNhc2UgdHlwZXMuU0VDVElPTjpcblx0XHRcdFx0XHRyZXR1cm4gbmV3IFNlY3Rpb24oIG9wdGlvbnMgKTtcblx0XHRcdFx0Y2FzZSB0eXBlcy5UUklQTEU6XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBUcmlwbGUoIG9wdGlvbnMgKTtcblx0XHRcdFx0Y2FzZSB0eXBlcy5FTEVNRU5UOlxuXHRcdFx0XHRcdHZhciBjb25zdHJ1Y3Rvcjtcblx0XHRcdFx0XHRpZiAoIGNvbnN0cnVjdG9yID0gZ2V0Q29tcG9uZW50KCBvcHRpb25zLnBhcmVudEZyYWdtZW50LnJvb3QsIG9wdGlvbnMudGVtcGxhdGUuZSApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBDb21wb25lbnQoIG9wdGlvbnMsIGNvbnN0cnVjdG9yICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBuZXcgRWxlbWVudCggb3B0aW9ucyApO1xuXHRcdFx0XHRjYXNlIHR5cGVzLlBBUlRJQUw6XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBQYXJ0aWFsKCBvcHRpb25zICk7XG5cdFx0XHRcdGNhc2UgdHlwZXMuQ09NTUVOVDpcblx0XHRcdFx0XHRyZXR1cm4gbmV3IENvbW1lbnQoIG9wdGlvbnMgKTtcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdTb21ldGhpbmcgdmVyeSBzdHJhbmdlIGhhcHBlbmVkLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vcmFjdGl2ZWpzL3JhY3RpdmUvaXNzdWVzLiBUaGFua3MhJyApO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIHR5cGVzLCBUZXh0LCBJbnRlcnBvbGF0b3IsIFNlY3Rpb24sIFRyaXBsZSwgRWxlbWVudCwgUGFydGlhbCwgZ2V0Q29tcG9uZW50LCBDb21wb25lbnQsIENvbW1lbnQsIFlpZWxkZXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS9pbml0LmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JGluaXQgPSBmdW5jdGlvbiggdHlwZXMsIGNyZWF0ZSwgY3JlYXRlSXRlbSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBGcmFnbWVudCRpbml0KCBvcHRpb25zICkge1xuXHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHR2YXIgcGFyZW50RnJhZ21lbnQsIHBhcmVudFJlZnMsIHJlZjtcblx0XHRcdC8vIFRoZSBpdGVtIHRoYXQgb3ducyB0aGlzIGZyYWdtZW50IC0gYW4gZWxlbWVudCwgc2VjdGlvbiwgcGFydGlhbCwgb3IgYXR0cmlidXRlXG5cdFx0XHR0aGlzLm93bmVyID0gb3B0aW9ucy5vd25lcjtcblx0XHRcdHBhcmVudEZyYWdtZW50ID0gdGhpcy5wYXJlbnQgPSB0aGlzLm93bmVyLnBhcmVudEZyYWdtZW50O1xuXHRcdFx0Ly8gaW5oZXJpdGVkIHByb3BlcnRpZXNcblx0XHRcdHRoaXMucm9vdCA9IG9wdGlvbnMucm9vdDtcblx0XHRcdHRoaXMucEVsZW1lbnQgPSBvcHRpb25zLnBFbGVtZW50O1xuXHRcdFx0dGhpcy5jb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0O1xuXHRcdFx0Ly8gSWYgcGFyZW50IGl0ZW0gaXMgYSBzZWN0aW9uLCB0aGlzIG1heSBub3QgYmUgdGhlIG9ubHkgZnJhZ21lbnRcblx0XHRcdC8vIHRoYXQgYmVsb25ncyB0byBpdCAtIHdlIG5lZWQgdG8gbWFrZSBhIG5vdGUgb2YgdGhlIGluZGV4XG5cdFx0XHRpZiAoIHRoaXMub3duZXIudHlwZSA9PT0gdHlwZXMuU0VDVElPTiApIHtcblx0XHRcdFx0dGhpcy5pbmRleCA9IG9wdGlvbnMuaW5kZXg7XG5cdFx0XHR9XG5cdFx0XHQvLyBpbmRleCByZWZlcmVuY2VzICh0aGUgJ2knIGluIHt7I3NlY3Rpb246aX19Li4ue3svc2VjdGlvbn19KSBuZWVkIHRvIGNhc2NhZGVcblx0XHRcdC8vIGRvd24gdGhlIHRyZWVcblx0XHRcdGlmICggcGFyZW50RnJhZ21lbnQgKSB7XG5cdFx0XHRcdHBhcmVudFJlZnMgPSBwYXJlbnRGcmFnbWVudC5pbmRleFJlZnM7XG5cdFx0XHRcdGlmICggcGFyZW50UmVmcyApIHtcblx0XHRcdFx0XHR0aGlzLmluZGV4UmVmcyA9IGNyZWF0ZSggbnVsbCApO1xuXHRcdFx0XHRcdC8vIGF2b2lkcyBuZWVkIGZvciBoYXNPd25Qcm9wZXJ0eVxuXHRcdFx0XHRcdGZvciAoIHJlZiBpbiBwYXJlbnRSZWZzICkge1xuXHRcdFx0XHRcdFx0dGhpcy5pbmRleFJlZnNbIHJlZiBdID0gcGFyZW50UmVmc1sgcmVmIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG9wdGlvbnMuaW5kZXhSZWYgKSB7XG5cdFx0XHRcdGlmICggIXRoaXMuaW5kZXhSZWZzICkge1xuXHRcdFx0XHRcdHRoaXMuaW5kZXhSZWZzID0ge307XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5pbmRleFJlZnNbIG9wdGlvbnMuaW5kZXhSZWYgXSA9IG9wdGlvbnMuaW5kZXg7XG5cdFx0XHR9XG5cdFx0XHQvLyBUaW1lIHRvIGNyZWF0ZSB0aGlzIGZyYWdtZW50J3MgY2hpbGQgaXRlbXNcblx0XHRcdC8vIFRFTVAgc2hvdWxkIHRoaXMgYmUgaGFwcGVuaW5nP1xuXHRcdFx0aWYgKCB0eXBlb2Ygb3B0aW9ucy50ZW1wbGF0ZSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdG9wdGlvbnMudGVtcGxhdGUgPSBbIG9wdGlvbnMudGVtcGxhdGUgXTtcblx0XHRcdH0gZWxzZSBpZiAoICFvcHRpb25zLnRlbXBsYXRlICkge1xuXHRcdFx0XHRvcHRpb25zLnRlbXBsYXRlID0gW107XG5cdFx0XHR9XG5cdFx0XHR0aGlzLml0ZW1zID0gb3B0aW9ucy50ZW1wbGF0ZS5tYXAoIGZ1bmN0aW9uKCB0ZW1wbGF0ZSwgaSApIHtcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZUl0ZW0oIHtcblx0XHRcdFx0XHRwYXJlbnRGcmFnbWVudDogdGhpcyQwLFxuXHRcdFx0XHRcdHBFbGVtZW50OiBvcHRpb25zLnBFbGVtZW50LFxuXHRcdFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZSxcblx0XHRcdFx0XHRpbmRleDogaVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9ICk7XG5cdFx0XHR0aGlzLnZhbHVlID0gdGhpcy5hcmdzTGlzdCA9IG51bGw7XG5cdFx0XHR0aGlzLmRpcnR5QXJncyA9IHRoaXMuZGlydHlWYWx1ZSA9IHRydWU7XG5cdFx0XHR0aGlzLmJvdW5kID0gdHJ1ZTtcblx0XHR9O1xuXHR9KCB0eXBlcywgY3JlYXRlLCB2aXJ0dWFsZG9tX0ZyYWdtZW50JGluaXRfY3JlYXRlSXRlbSApO1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL3JlYmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCRyZWJpbmQgPSBmdW5jdGlvbiggYXNzaWduTmV3S2V5cGF0aCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBGcmFnbWVudCRyZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdHRoaXMuaW5kZXggPSBuZXdJbmRleDtcblx0XHRcdC8vIGFzc2lnbiBuZXcgY29udGV4dCBrZXlwYXRoIGlmIG5lZWRlZFxuXHRcdFx0YXNzaWduTmV3S2V5cGF0aCggdGhpcywgJ2NvbnRleHQnLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHRpZiAoIHRoaXMuaW5kZXhSZWZzICYmIHRoaXMuaW5kZXhSZWZzWyBpbmRleFJlZiBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMuaW5kZXhSZWZzWyBpbmRleFJlZiBdID0gbmV3SW5kZXg7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLml0ZW1zLmZvckVhY2goIGZ1bmN0aW9uKCBpdGVtICkge1xuXHRcdFx0XHRpZiAoIGl0ZW0ucmViaW5kICkge1xuXHRcdFx0XHRcdGl0ZW0ucmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH07XG5cdH0oIGFzc2lnbk5ld0tleXBhdGggKTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS9yZW5kZXIuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkcmVuZGVyID0gZnVuY3Rpb24gRnJhZ21lbnQkcmVuZGVyKCkge1xuXHRcdHZhciByZXN1bHQ7XG5cdFx0aWYgKCB0aGlzLml0ZW1zLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdHJlc3VsdCA9IHRoaXMuaXRlbXNbIDAgXS5yZW5kZXIoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVzdWx0ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdFx0dGhpcy5pdGVtcy5mb3JFYWNoKCBmdW5jdGlvbiggaXRlbSApIHtcblx0XHRcdFx0cmVzdWx0LmFwcGVuZENoaWxkKCBpdGVtLnJlbmRlcigpICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvdG9TdHJpbmcuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkdG9TdHJpbmcgPSBmdW5jdGlvbiBGcmFnbWVudCR0b1N0cmluZyggZXNjYXBlICkge1xuXHRcdGlmICggIXRoaXMuaXRlbXMgKSB7XG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLml0ZW1zLm1hcCggZnVuY3Rpb24oIGl0ZW0gKSB7XG5cdFx0XHRyZXR1cm4gaXRlbS50b1N0cmluZyggZXNjYXBlICk7XG5cdFx0fSApLmpvaW4oICcnICk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvdW5iaW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JHVuYmluZCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gRnJhZ21lbnQkdW5iaW5kKCkge1xuXHRcdFx0aWYgKCAhdGhpcy5ib3VuZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5pdGVtcy5mb3JFYWNoKCB1bmJpbmRJdGVtICk7XG5cdFx0XHR0aGlzLmJvdW5kID0gZmFsc2U7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHVuYmluZEl0ZW0oIGl0ZW0gKSB7XG5cdFx0XHRpZiAoIGl0ZW0udW5iaW5kICkge1xuXHRcdFx0XHRpdGVtLnVuYmluZCgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oKTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS91bnJlbmRlci5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCR1bnJlbmRlciA9IGZ1bmN0aW9uIEZyYWdtZW50JHVucmVuZGVyKCBzaG91bGREZXN0cm95ICkge1xuXHRcdGlmICggIXRoaXMucmVuZGVyZWQgKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdBdHRlbXB0ZWQgdG8gdW5yZW5kZXIgYSBmcmFnbWVudCB0aGF0IHdhcyBub3QgcmVuZGVyZWQnICk7XG5cdFx0fVxuXHRcdHRoaXMuaXRlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRyZXR1cm4gaS51bnJlbmRlciggc2hvdWxkRGVzdHJveSApO1xuXHRcdH0gKTtcblx0XHR0aGlzLnJlbmRlcmVkID0gZmFsc2U7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC5qcyAqL1xuXHR2YXIgRnJhZ21lbnQgPSBmdW5jdGlvbiggYnViYmxlLCBkZXRhY2gsIGZpbmQsIGZpbmRBbGwsIGZpbmRBbGxDb21wb25lbnRzLCBmaW5kQ29tcG9uZW50LCBmaW5kTmV4dE5vZGUsIGZpcnN0Tm9kZSwgZ2V0Tm9kZSwgZ2V0VmFsdWUsIGluaXQsIHJlYmluZCwgcmVuZGVyLCB0b1N0cmluZywgdW5iaW5kLCB1bnJlbmRlciwgY2lyY3VsYXIgKSB7XG5cblx0XHR2YXIgRnJhZ21lbnQgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdHRoaXMuaW5pdCggb3B0aW9ucyApO1xuXHRcdH07XG5cdFx0RnJhZ21lbnQucHJvdG90eXBlID0ge1xuXHRcdFx0YnViYmxlOiBidWJibGUsXG5cdFx0XHRkZXRhY2g6IGRldGFjaCxcblx0XHRcdGZpbmQ6IGZpbmQsXG5cdFx0XHRmaW5kQWxsOiBmaW5kQWxsLFxuXHRcdFx0ZmluZEFsbENvbXBvbmVudHM6IGZpbmRBbGxDb21wb25lbnRzLFxuXHRcdFx0ZmluZENvbXBvbmVudDogZmluZENvbXBvbmVudCxcblx0XHRcdGZpbmROZXh0Tm9kZTogZmluZE5leHROb2RlLFxuXHRcdFx0Zmlyc3ROb2RlOiBmaXJzdE5vZGUsXG5cdFx0XHRnZXROb2RlOiBnZXROb2RlLFxuXHRcdFx0Z2V0VmFsdWU6IGdldFZhbHVlLFxuXHRcdFx0aW5pdDogaW5pdCxcblx0XHRcdHJlYmluZDogcmViaW5kLFxuXHRcdFx0cmVuZGVyOiByZW5kZXIsXG5cdFx0XHR0b1N0cmluZzogdG9TdHJpbmcsXG5cdFx0XHR1bmJpbmQ6IHVuYmluZCxcblx0XHRcdHVucmVuZGVyOiB1bnJlbmRlclxuXHRcdH07XG5cdFx0Y2lyY3VsYXIuRnJhZ21lbnQgPSBGcmFnbWVudDtcblx0XHRyZXR1cm4gRnJhZ21lbnQ7XG5cdH0oIHZpcnR1YWxkb21fRnJhZ21lbnQkYnViYmxlLCB2aXJ0dWFsZG9tX0ZyYWdtZW50JGRldGFjaCwgdmlydHVhbGRvbV9GcmFnbWVudCRmaW5kLCB2aXJ0dWFsZG9tX0ZyYWdtZW50JGZpbmRBbGwsIHZpcnR1YWxkb21fRnJhZ21lbnQkZmluZEFsbENvbXBvbmVudHMsIHZpcnR1YWxkb21fRnJhZ21lbnQkZmluZENvbXBvbmVudCwgdmlydHVhbGRvbV9GcmFnbWVudCRmaW5kTmV4dE5vZGUsIHZpcnR1YWxkb21fRnJhZ21lbnQkZmlyc3ROb2RlLCB2aXJ0dWFsZG9tX0ZyYWdtZW50JGdldE5vZGUsIHZpcnR1YWxkb21fRnJhZ21lbnQkZ2V0VmFsdWUsIHZpcnR1YWxkb21fRnJhZ21lbnQkaW5pdCwgdmlydHVhbGRvbV9GcmFnbWVudCRyZWJpbmQsIHZpcnR1YWxkb21fRnJhZ21lbnQkcmVuZGVyLCB2aXJ0dWFsZG9tX0ZyYWdtZW50JHRvU3RyaW5nLCB2aXJ0dWFsZG9tX0ZyYWdtZW50JHVuYmluZCwgdmlydHVhbGRvbV9GcmFnbWVudCR1bnJlbmRlciwgY2lyY3VsYXIgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9yZXNldC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRyZXNldCA9IGZ1bmN0aW9uKCBIb29rLCBydW5sb29wLCBGcmFnbWVudCwgY29uZmlnICkge1xuXG5cdFx0dmFyIHNob3VsZFJlcmVuZGVyID0gW1xuXHRcdFx0XHQndGVtcGxhdGUnLFxuXHRcdFx0XHQncGFydGlhbHMnLFxuXHRcdFx0XHQnY29tcG9uZW50cycsXG5cdFx0XHRcdCdkZWNvcmF0b3JzJyxcblx0XHRcdFx0J2V2ZW50cydcblx0XHRcdF0sXG5cdFx0XHRyZXNldEhvb2sgPSBuZXcgSG9vayggJ3Jlc2V0JyApO1xuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJHJlc2V0KCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRcdHZhciBwcm9taXNlLCB3cmFwcGVyLCBjaGFuZ2VzLCBpLCByZXJlbmRlcjtcblx0XHRcdGlmICggdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicgJiYgIWNhbGxiYWNrICkge1xuXHRcdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRcdGRhdGEgPSB7fTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhIHx8IHt9O1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RoZSByZXNldCBtZXRob2QgdGFrZXMgZWl0aGVyIG5vIGFyZ3VtZW50cywgb3IgYW4gb2JqZWN0IGNvbnRhaW5pbmcgbmV3IGRhdGEnICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBJZiB0aGUgcm9vdCBvYmplY3QgaXMgd3JhcHBlZCwgdHJ5IGFuZCB1c2UgdGhlIHdyYXBwZXIncyByZXNldCB2YWx1ZVxuXHRcdFx0aWYgKCAoIHdyYXBwZXIgPSB0aGlzLnZpZXdtb2RlbC53cmFwcGVkWyAnJyBdICkgJiYgd3JhcHBlci5yZXNldCApIHtcblx0XHRcdFx0aWYgKCB3cmFwcGVyLnJlc2V0KCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdC8vIHJlc2V0IHdhcyByZWplY3RlZCwgd2UgbmVlZCB0byByZXBsYWNlIHRoZSBvYmplY3Rcblx0XHRcdFx0XHR0aGlzLmRhdGEgPSBkYXRhO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmRhdGEgPSBkYXRhO1xuXHRcdFx0fVxuXHRcdFx0Ly8gcmVzZXQgY29uZmlnIGl0ZW1zIGFuZCB0cmFjayBpZiBuZWVkIHRvIHJlcmVuZGVyXG5cdFx0XHRjaGFuZ2VzID0gY29uZmlnLnJlc2V0KCB0aGlzICk7XG5cdFx0XHRpID0gY2hhbmdlcy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzaG91bGRSZXJlbmRlci5pbmRleE9mKCBjaGFuZ2VzWyBpIF0gKSA+IC0xICkge1xuXHRcdFx0XHRcdHJlcmVuZGVyID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCByZXJlbmRlciApIHtcblx0XHRcdFx0dmFyIGNvbXBvbmVudDtcblx0XHRcdFx0dGhpcy52aWV3bW9kZWwubWFyayggJycgKTtcblx0XHRcdFx0Ly8gSXMgdGhpcyBpcyBhIGNvbXBvbmVudCwgd2UgbmVlZCB0byBzZXQgdGhlIGBzaG91bGREZXN0cm95YFxuXHRcdFx0XHQvLyBmbGFnLCBvdGhlcndpc2UgaXQgd2lsbCBhc3N1bWUgYnkgZGVmYXVsdCB0aGF0IGEgcGFyZW50IG5vZGVcblx0XHRcdFx0Ly8gd2lsbCBiZSBkZXRhY2hlZCwgYW5kIHRoZXJlZm9yZSBpdCBkb2Vzbid0IG5lZWQgdG8gYm90aGVyXG5cdFx0XHRcdC8vIGRldGFjaGluZyBpdHMgb3duIG5vZGVzXG5cdFx0XHRcdGlmICggY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQgKSB7XG5cdFx0XHRcdFx0Y29tcG9uZW50LnNob3VsZERlc3Ryb3kgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMudW5yZW5kZXIoKTtcblx0XHRcdFx0aWYgKCBjb21wb25lbnQgKSB7XG5cdFx0XHRcdFx0Y29tcG9uZW50LnNob3VsZERlc3Ryb3kgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBJZiB0aGUgdGVtcGxhdGUgY2hhbmdlZCwgd2UgbmVlZCB0byBkZXN0cm95IHRoZSBwYXJhbGxlbCBET01cblx0XHRcdFx0Ly8gVE9ETyBpZiB3ZSdyZSBoZXJlLCBwcmVzdW1hYmx5IGl0IGRpZD9cblx0XHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50LnRlbXBsYXRlICE9PSB0aGlzLnRlbXBsYXRlICkge1xuXHRcdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0XHRcdFx0dGhpcy5mcmFnbWVudCA9IG5ldyBGcmFnbWVudCgge1xuXHRcdFx0XHRcdFx0dGVtcGxhdGU6IHRoaXMudGVtcGxhdGUsXG5cdFx0XHRcdFx0XHRyb290OiB0aGlzLFxuXHRcdFx0XHRcdFx0b3duZXI6IHRoaXNcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cHJvbWlzZSA9IHRoaXMucmVuZGVyKCB0aGlzLmVsLCB0aGlzLmFuY2hvciApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHJvbWlzZSA9IHJ1bmxvb3Auc3RhcnQoIHRoaXMsIHRydWUgKTtcblx0XHRcdFx0dGhpcy52aWV3bW9kZWwubWFyayggJycgKTtcblx0XHRcdFx0cnVubG9vcC5lbmQoKTtcblx0XHRcdH1cblx0XHRcdHJlc2V0SG9vay5maXJlKCB0aGlzLCBkYXRhICk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRwcm9taXNlLnRoZW4oIGNhbGxiYWNrICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHR9O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9ob29rc19Ib29rLCBydW5sb29wLCBGcmFnbWVudCwgY29uZmlnICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvcmVzZXRUZW1wbGF0ZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRyZXNldFRlbXBsYXRlID0gZnVuY3Rpb24oIGNvbmZpZywgRnJhZ21lbnQgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRyZXNldFRlbXBsYXRlKCB0ZW1wbGF0ZSApIHtcblx0XHRcdHZhciB0cmFuc2l0aW9uc0VuYWJsZWQsIGNvbXBvbmVudDtcblx0XHRcdGNvbmZpZy50ZW1wbGF0ZS5pbml0KCBudWxsLCB0aGlzLCB7XG5cdFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZVxuXHRcdFx0fSApO1xuXHRcdFx0dHJhbnNpdGlvbnNFbmFibGVkID0gdGhpcy50cmFuc2l0aW9uc0VuYWJsZWQ7XG5cdFx0XHR0aGlzLnRyYW5zaXRpb25zRW5hYmxlZCA9IGZhbHNlO1xuXHRcdFx0Ly8gSXMgdGhpcyBpcyBhIGNvbXBvbmVudCwgd2UgbmVlZCB0byBzZXQgdGhlIGBzaG91bGREZXN0cm95YFxuXHRcdFx0Ly8gZmxhZywgb3RoZXJ3aXNlIGl0IHdpbGwgYXNzdW1lIGJ5IGRlZmF1bHQgdGhhdCBhIHBhcmVudCBub2RlXG5cdFx0XHQvLyB3aWxsIGJlIGRldGFjaGVkLCBhbmQgdGhlcmVmb3JlIGl0IGRvZXNuJ3QgbmVlZCB0byBib3RoZXJcblx0XHRcdC8vIGRldGFjaGluZyBpdHMgb3duIG5vZGVzXG5cdFx0XHRpZiAoIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50ICkge1xuXHRcdFx0XHRjb21wb25lbnQuc2hvdWxkRGVzdHJveSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnVucmVuZGVyKCk7XG5cdFx0XHRpZiAoIGNvbXBvbmVudCApIHtcblx0XHRcdFx0Y29tcG9uZW50LnNob3VsZERlc3Ryb3kgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdC8vIHJlbW92ZSBleGlzdGluZyBmcmFnbWVudCBhbmQgY3JlYXRlIG5ldyBvbmVcblx0XHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0XHR0aGlzLmZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdHRlbXBsYXRlOiB0aGlzLnRlbXBsYXRlLFxuXHRcdFx0XHRyb290OiB0aGlzLFxuXHRcdFx0XHRvd25lcjogdGhpc1xuXHRcdFx0fSApO1xuXHRcdFx0dGhpcy5yZW5kZXIoIHRoaXMuZWwsIHRoaXMuYW5jaG9yICk7XG5cdFx0XHR0aGlzLnRyYW5zaXRpb25zRW5hYmxlZCA9IHRyYW5zaXRpb25zRW5hYmxlZDtcblx0XHR9O1xuXHR9KCBjb25maWcsIEZyYWdtZW50ICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvcmV2ZXJzZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRyZXZlcnNlID0gZnVuY3Rpb24oIG1ha2VBcnJheU1ldGhvZCApIHtcblxuXHRcdHJldHVybiBtYWtlQXJyYXlNZXRob2QoICdyZXZlcnNlJyApO1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9tYWtlQXJyYXlNZXRob2QgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zZXQuanMgKi9cblx0dmFyIFJhY3RpdmUkc2V0ID0gZnVuY3Rpb24oIHJ1bmxvb3AsIGlzT2JqZWN0LCBub3JtYWxpc2VLZXlwYXRoLCBnZXRNYXRjaGluZ0tleXBhdGhzICkge1xuXG5cdFx0dmFyIHdpbGRjYXJkID0gL1xcKi87XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkc2V0KCBrZXlwYXRoLCB2YWx1ZSwgY2FsbGJhY2sgKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdHZhciBtYXAsIHByb21pc2U7XG5cdFx0XHRwcm9taXNlID0gcnVubG9vcC5zdGFydCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0Ly8gU2V0IG11bHRpcGxlIGtleXBhdGhzIGluIG9uZSBnb1xuXHRcdFx0aWYgKCBpc09iamVjdCgga2V5cGF0aCApICkge1xuXHRcdFx0XHRtYXAgPSBrZXlwYXRoO1xuXHRcdFx0XHRjYWxsYmFjayA9IHZhbHVlO1xuXHRcdFx0XHRmb3IgKCBrZXlwYXRoIGluIG1hcCApIHtcblx0XHRcdFx0XHRpZiAoIG1hcC5oYXNPd25Qcm9wZXJ0eSgga2V5cGF0aCApICkge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSBtYXBbIGtleXBhdGggXTtcblx0XHRcdFx0XHRcdGtleXBhdGggPSBub3JtYWxpc2VLZXlwYXRoKCBrZXlwYXRoICk7XG5cdFx0XHRcdFx0XHR0aGlzLnZpZXdtb2RlbC5zZXQoIGtleXBhdGgsIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRrZXlwYXRoID0gbm9ybWFsaXNlS2V5cGF0aCgga2V5cGF0aCApO1xuXHRcdFx0XHRpZiAoIHdpbGRjYXJkLnRlc3QoIGtleXBhdGggKSApIHtcblx0XHRcdFx0XHRnZXRNYXRjaGluZ0tleXBhdGhzKCB0aGlzLCBrZXlwYXRoICkuZm9yRWFjaCggZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0XHR0aGlzJDAudmlld21vZGVsLnNldCgga2V5cGF0aCwgdmFsdWUgKTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy52aWV3bW9kZWwuc2V0KCBrZXlwYXRoLCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRydW5sb29wLmVuZCgpO1xuXHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0cHJvbWlzZS50aGVuKCBjYWxsYmFjay5iaW5kKCB0aGlzICkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdH07XG5cdH0oIHJ1bmxvb3AsIGlzT2JqZWN0LCBub3JtYWxpc2VLZXlwYXRoLCBnZXRNYXRjaGluZ0tleXBhdGhzICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2hpZnQuanMgKi9cblx0dmFyIFJhY3RpdmUkc2hpZnQgPSBmdW5jdGlvbiggbWFrZUFycmF5TWV0aG9kICkge1xuXG5cdFx0cmV0dXJuIG1ha2VBcnJheU1ldGhvZCggJ3NoaWZ0JyApO1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9tYWtlQXJyYXlNZXRob2QgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zb3J0LmpzICovXG5cdHZhciBSYWN0aXZlJHNvcnQgPSBmdW5jdGlvbiggbWFrZUFycmF5TWV0aG9kICkge1xuXG5cdFx0cmV0dXJuIG1ha2VBcnJheU1ldGhvZCggJ3NvcnQnICk7XG5cdH0oIFJhY3RpdmUkc2hhcmVkX21ha2VBcnJheU1ldGhvZCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NwbGljZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzcGxpY2UgPSBmdW5jdGlvbiggbWFrZUFycmF5TWV0aG9kICkge1xuXG5cdFx0cmV0dXJuIG1ha2VBcnJheU1ldGhvZCggJ3NwbGljZScgKTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfbWFrZUFycmF5TWV0aG9kICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc3VidHJhY3QuanMgKi9cblx0dmFyIFJhY3RpdmUkc3VidHJhY3QgPSBmdW5jdGlvbiggYWRkICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkc3VidHJhY3QoIGtleXBhdGgsIGQgKSB7XG5cdFx0XHRyZXR1cm4gYWRkKCB0aGlzLCBrZXlwYXRoLCBkID09PSB1bmRlZmluZWQgPyAtMSA6IC1kICk7XG5cdFx0fTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfYWRkICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvdGVhcmRvd24uanMgKi9cblx0dmFyIFJhY3RpdmUkdGVhcmRvd24gPSBmdW5jdGlvbiggSG9vaywgUHJvbWlzZSwgcmVtb3ZlRnJvbUFycmF5ICkge1xuXG5cdFx0dmFyIHRlYXJkb3duSG9vayA9IG5ldyBIb29rKCAndGVhcmRvd24nICk7XG5cdFx0Ly8gVGVhcmRvd24uIFRoaXMgZ29lcyB0aHJvdWdoIHRoZSByb290IGZyYWdtZW50IGFuZCBhbGwgaXRzIGNoaWxkcmVuLCByZW1vdmluZyBvYnNlcnZlcnNcblx0XHQvLyBhbmQgZ2VuZXJhbGx5IGNsZWFuaW5nIHVwIGFmdGVyIGl0c2VsZlxuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJHRlYXJkb3duKCBjYWxsYmFjayApIHtcblx0XHRcdHZhciBwcm9taXNlO1xuXHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdHRoaXMudmlld21vZGVsLnRlYXJkb3duKCk7XG5cdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQucmVuZGVyZWQgJiYgdGhpcy5lbC5fX3JhY3RpdmVfaW5zdGFuY2VzX18gKSB7XG5cdFx0XHRcdHJlbW92ZUZyb21BcnJheSggdGhpcy5lbC5fX3JhY3RpdmVfaW5zdGFuY2VzX18sIHRoaXMgKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuc2hvdWxkRGVzdHJveSA9IHRydWU7XG5cdFx0XHRwcm9taXNlID0gdGhpcy5mcmFnbWVudC5yZW5kZXJlZCA/IHRoaXMudW5yZW5kZXIoKSA6IFByb21pc2UucmVzb2x2ZSgpO1xuXHRcdFx0dGVhcmRvd25Ib29rLmZpcmUoIHRoaXMgKTtcblx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdC8vIFRPRE8gZGVwcmVjYXRlIHRoaXM/XG5cdFx0XHRcdHByb21pc2UudGhlbiggY2FsbGJhY2suYmluZCggdGhpcyApICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHR9O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9ob29rc19Ib29rLCBQcm9taXNlLCByZW1vdmVGcm9tQXJyYXkgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS90b2dnbGUuanMgKi9cblx0dmFyIFJhY3RpdmUkdG9nZ2xlID0gZnVuY3Rpb24oIGxvZyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJHRvZ2dsZSgga2V5cGF0aCwgY2FsbGJhY2sgKSB7XG5cdFx0XHR2YXIgdmFsdWU7XG5cdFx0XHRpZiAoIHR5cGVvZiBrZXlwYXRoICE9PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0bG9nLmVycm9yT25seSgge1xuXHRcdFx0XHRcdGRlYnVnOiB0aGlzLmRlYnVnLFxuXHRcdFx0XHRcdG1lc3NzYWdlOiAnYmFkQXJndW1lbnRzJyxcblx0XHRcdFx0XHRhcmc6IHtcblx0XHRcdFx0XHRcdGFyZ3VtZW50czoga2V5cGF0aFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0dmFsdWUgPSB0aGlzLmdldCgga2V5cGF0aCApO1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0KCBrZXlwYXRoLCAhdmFsdWUsIGNhbGxiYWNrICk7XG5cdFx0fTtcblx0fSggbG9nICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvdG9IVE1MLmpzICovXG5cdHZhciBSYWN0aXZlJHRvSFRNTCA9IGZ1bmN0aW9uIFJhY3RpdmUkdG9IVE1MKCkge1xuXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCB0cnVlICk7XG5cdH07XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvdW5yZW5kZXIuanMgKi9cblx0dmFyIFJhY3RpdmUkdW5yZW5kZXIgPSBmdW5jdGlvbiggY3NzLCBIb29rLCBsb2csIFByb21pc2UsIHJlbW92ZUZyb21BcnJheSwgcnVubG9vcCApIHtcblxuXHRcdHZhciB1bnJlbmRlckhvb2sgPSBuZXcgSG9vayggJ3VucmVuZGVyJyApO1xuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJHVucmVuZGVyKCkge1xuXHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHR2YXIgcHJvbWlzZSwgc2hvdWxkRGVzdHJveTtcblx0XHRcdGlmICggIXRoaXMuZnJhZ21lbnQucmVuZGVyZWQgKSB7XG5cdFx0XHRcdGxvZy53YXJuKCB7XG5cdFx0XHRcdFx0ZGVidWc6IHRoaXMuZGVidWcsXG5cdFx0XHRcdFx0bWVzc2FnZTogJ3JhY3RpdmUudW5yZW5kZXIoKSB3YXMgY2FsbGVkIG9uIGEgUmFjdGl2ZSBpbnN0YW5jZSB0aGF0IHdhcyBub3QgcmVuZGVyZWQnXG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuXHRcdFx0fVxuXHRcdFx0cHJvbWlzZSA9IHJ1bmxvb3Auc3RhcnQoIHRoaXMsIHRydWUgKTtcblx0XHRcdC8vIElmIHRoaXMgaXMgYSBjb21wb25lbnQsIGFuZCB0aGUgY29tcG9uZW50IGlzbid0IG1hcmtlZCBmb3IgZGVzdHJ1Y3Rpb24sXG5cdFx0XHQvLyBkb24ndCBkZXRhY2ggbm9kZXMgZnJvbSB0aGUgRE9NIHVubmVjZXNzYXJpbHlcblx0XHRcdHNob3VsZERlc3Ryb3kgPSAhdGhpcy5jb21wb25lbnQgfHwgdGhpcy5jb21wb25lbnQuc2hvdWxkRGVzdHJveSB8fCB0aGlzLnNob3VsZERlc3Ryb3k7XG5cdFx0XHRpZiAoIHRoaXMuY29uc3RydWN0b3IuY3NzICkge1xuXHRcdFx0XHRwcm9taXNlLnRoZW4oIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGNzcy5yZW1vdmUoIHRoaXMkMC5jb25zdHJ1Y3RvciApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBDYW5jZWwgYW55IGFuaW1hdGlvbnMgaW4gcHJvZ3Jlc3Ncblx0XHRcdHdoaWxlICggdGhpcy5fYW5pbWF0aW9uc1sgMCBdICkge1xuXHRcdFx0XHR0aGlzLl9hbmltYXRpb25zWyAwIF0uc3RvcCgpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5mcmFnbWVudC51bnJlbmRlciggc2hvdWxkRGVzdHJveSApO1xuXHRcdFx0cmVtb3ZlRnJvbUFycmF5KCB0aGlzLmVsLl9fcmFjdGl2ZV9pbnN0YW5jZXNfXywgdGhpcyApO1xuXHRcdFx0dW5yZW5kZXJIb29rLmZpcmUoIHRoaXMgKTtcblx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHR9O1xuXHR9KCBnbG9iYWxfY3NzLCBSYWN0aXZlJHNoYXJlZF9ob29rc19Ib29rLCBsb2csIFByb21pc2UsIHJlbW92ZUZyb21BcnJheSwgcnVubG9vcCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3Vuc2hpZnQuanMgKi9cblx0dmFyIFJhY3RpdmUkdW5zaGlmdCA9IGZ1bmN0aW9uKCBtYWtlQXJyYXlNZXRob2QgKSB7XG5cblx0XHRyZXR1cm4gbWFrZUFycmF5TWV0aG9kKCAndW5zaGlmdCcgKTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfbWFrZUFycmF5TWV0aG9kICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvdXBkYXRlLmpzICovXG5cdHZhciBSYWN0aXZlJHVwZGF0ZSA9IGZ1bmN0aW9uKCBIb29rLCBydW5sb29wICkge1xuXG5cdFx0dmFyIHVwZGF0ZUhvb2sgPSBuZXcgSG9vayggJ3VwZGF0ZScgKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSR1cGRhdGUoIGtleXBhdGgsIGNhbGxiYWNrICkge1xuXHRcdFx0dmFyIHByb21pc2U7XG5cdFx0XHRpZiAoIHR5cGVvZiBrZXlwYXRoID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRjYWxsYmFjayA9IGtleXBhdGg7XG5cdFx0XHRcdGtleXBhdGggPSAnJztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGtleXBhdGggPSBrZXlwYXRoIHx8ICcnO1xuXHRcdFx0fVxuXHRcdFx0cHJvbWlzZSA9IHJ1bmxvb3Auc3RhcnQoIHRoaXMsIHRydWUgKTtcblx0XHRcdHRoaXMudmlld21vZGVsLm1hcmsoIGtleXBhdGggKTtcblx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHR1cGRhdGVIb29rLmZpcmUoIHRoaXMsIGtleXBhdGggKTtcblx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdHByb21pc2UudGhlbiggY2FsbGJhY2suYmluZCggdGhpcyApICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHR9O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9ob29rc19Ib29rLCBydW5sb29wICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvdXBkYXRlTW9kZWwuanMgKi9cblx0dmFyIFJhY3RpdmUkdXBkYXRlTW9kZWwgPSBmdW5jdGlvbiggYXJyYXlDb250ZW50c01hdGNoLCBpc0VxdWFsICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gUmFjdGl2ZSR1cGRhdGVNb2RlbCgga2V5cGF0aCwgY2FzY2FkZSApIHtcblx0XHRcdHZhciB2YWx1ZXM7XG5cdFx0XHRpZiAoIHR5cGVvZiBrZXlwYXRoICE9PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0a2V5cGF0aCA9ICcnO1xuXHRcdFx0XHRjYXNjYWRlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGNvbnNvbGlkYXRlQ2hhbmdlZFZhbHVlcyggdGhpcywga2V5cGF0aCwgdmFsdWVzID0ge30sIGNhc2NhZGUgKTtcblx0XHRcdHJldHVybiB0aGlzLnNldCggdmFsdWVzICk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGNvbnNvbGlkYXRlQ2hhbmdlZFZhbHVlcyggcmFjdGl2ZSwga2V5cGF0aCwgdmFsdWVzLCBjYXNjYWRlICkge1xuXHRcdFx0dmFyIGJpbmRpbmdzLCBjaGlsZERlcHMsIGksIGJpbmRpbmcsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgY2hlY2tib3hHcm91cHMgPSBbXTtcblx0XHRcdGJpbmRpbmdzID0gcmFjdGl2ZS5fdHdvd2F5QmluZGluZ3NbIGtleXBhdGggXTtcblx0XHRcdGlmICggYmluZGluZ3MgJiYgKCBpID0gYmluZGluZ3MubGVuZ3RoICkgKSB7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGJpbmRpbmcgPSBiaW5kaW5nc1sgaSBdO1xuXHRcdFx0XHRcdC8vIHNwZWNpYWwgY2FzZSAtIHJhZGlvIG5hbWUgYmluZGluZ3Ncblx0XHRcdFx0XHRpZiAoIGJpbmRpbmcucmFkaW9OYW1lICYmICFiaW5kaW5nLmVsZW1lbnQubm9kZS5jaGVja2VkICkge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIHNwZWNpYWwgY2FzZSAtIGNoZWNrYm94IG5hbWUgYmluZGluZ3MgY29tZSBpbiBncm91cHMsIHNvXG5cdFx0XHRcdFx0Ly8gd2Ugd2FudCB0byBnZXQgdGhlIHZhbHVlIG9uY2UgYXQgbW9zdFxuXHRcdFx0XHRcdGlmICggYmluZGluZy5jaGVja2JveE5hbWUgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFjaGVja2JveEdyb3Vwc1sgYmluZGluZy5rZXlwYXRoIF0gJiYgIWJpbmRpbmcuY2hhbmdlZCgpICkge1xuXHRcdFx0XHRcdFx0XHRjaGVja2JveEdyb3Vwcy5wdXNoKCBiaW5kaW5nLmtleXBhdGggKTtcblx0XHRcdFx0XHRcdFx0Y2hlY2tib3hHcm91cHNbIGJpbmRpbmcua2V5cGF0aCBdID0gYmluZGluZztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRvbGRWYWx1ZSA9IGJpbmRpbmcuYXR0cmlidXRlLnZhbHVlO1xuXHRcdFx0XHRcdG5ld1ZhbHVlID0gYmluZGluZy5nZXRWYWx1ZSgpO1xuXHRcdFx0XHRcdGlmICggYXJyYXlDb250ZW50c01hdGNoKCBvbGRWYWx1ZSwgbmV3VmFsdWUgKSApIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoICFpc0VxdWFsKCBvbGRWYWx1ZSwgbmV3VmFsdWUgKSApIHtcblx0XHRcdFx0XHRcdHZhbHVlc1sga2V5cGF0aCBdID0gbmV3VmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBIYW5kbGUgZ3JvdXBzIG9mIGA8aW5wdXQgdHlwZT0nY2hlY2tib3gnIG5hbWU9J3t7Zm9vfX0nIC4uLj5gXG5cdFx0XHRpZiAoIGNoZWNrYm94R3JvdXBzLmxlbmd0aCApIHtcblx0XHRcdFx0Y2hlY2tib3hHcm91cHMuZm9yRWFjaCggZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0dmFyIGJpbmRpbmcsIG9sZFZhbHVlLCBuZXdWYWx1ZTtcblx0XHRcdFx0XHRiaW5kaW5nID0gY2hlY2tib3hHcm91cHNbIGtleXBhdGggXTtcblx0XHRcdFx0XHQvLyBvbmUgdG8gcmVwcmVzZW50IHRoZSBlbnRpcmUgZ3JvdXBcblx0XHRcdFx0XHRvbGRWYWx1ZSA9IGJpbmRpbmcuYXR0cmlidXRlLnZhbHVlO1xuXHRcdFx0XHRcdG5ld1ZhbHVlID0gYmluZGluZy5nZXRWYWx1ZSgpO1xuXHRcdFx0XHRcdGlmICggIWFycmF5Q29udGVudHNNYXRjaCggb2xkVmFsdWUsIG5ld1ZhbHVlICkgKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZXNbIGtleXBhdGggXSA9IG5ld1ZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhY2FzY2FkZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Ly8gY2FzY2FkZVxuXHRcdFx0Y2hpbGREZXBzID0gcmFjdGl2ZS52aWV3bW9kZWwuZGVwc01hcFsgJ2RlZmF1bHQnIF1bIGtleXBhdGggXTtcblx0XHRcdGlmICggY2hpbGREZXBzICkge1xuXHRcdFx0XHRpID0gY2hpbGREZXBzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0Y29uc29saWRhdGVDaGFuZ2VkVmFsdWVzKCByYWN0aXZlLCBjaGlsZERlcHNbIGkgXSwgdmFsdWVzLCBjYXNjYWRlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBhcnJheUNvbnRlbnRzTWF0Y2gsIGlzRXF1YWwgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS5qcyAqL1xuXHR2YXIgcHJvdG90eXBlID0gZnVuY3Rpb24oIGFkZCwgYW5pbWF0ZSwgZGV0YWNoLCBmaW5kLCBmaW5kQWxsLCBmaW5kQWxsQ29tcG9uZW50cywgZmluZENvbXBvbmVudCwgZmlyZSwgZ2V0LCBpbnNlcnQsIG1lcmdlLCBvYnNlcnZlLCBvZmYsIG9uLCBwb3AsIHB1c2gsIHJlbmRlciwgcmVzZXQsIHJlc2V0VGVtcGxhdGUsIHJldmVyc2UsIHNldCwgc2hpZnQsIHNvcnQsIHNwbGljZSwgc3VidHJhY3QsIHRlYXJkb3duLCB0b2dnbGUsIHRvSFRNTCwgdW5yZW5kZXIsIHVuc2hpZnQsIHVwZGF0ZSwgdXBkYXRlTW9kZWwgKSB7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0YWRkOiBhZGQsXG5cdFx0XHRhbmltYXRlOiBhbmltYXRlLFxuXHRcdFx0ZGV0YWNoOiBkZXRhY2gsXG5cdFx0XHRmaW5kOiBmaW5kLFxuXHRcdFx0ZmluZEFsbDogZmluZEFsbCxcblx0XHRcdGZpbmRBbGxDb21wb25lbnRzOiBmaW5kQWxsQ29tcG9uZW50cyxcblx0XHRcdGZpbmRDb21wb25lbnQ6IGZpbmRDb21wb25lbnQsXG5cdFx0XHRmaXJlOiBmaXJlLFxuXHRcdFx0Z2V0OiBnZXQsXG5cdFx0XHRpbnNlcnQ6IGluc2VydCxcblx0XHRcdG1lcmdlOiBtZXJnZSxcblx0XHRcdG9ic2VydmU6IG9ic2VydmUsXG5cdFx0XHRvZmY6IG9mZixcblx0XHRcdG9uOiBvbixcblx0XHRcdHBvcDogcG9wLFxuXHRcdFx0cHVzaDogcHVzaCxcblx0XHRcdHJlbmRlcjogcmVuZGVyLFxuXHRcdFx0cmVzZXQ6IHJlc2V0LFxuXHRcdFx0cmVzZXRUZW1wbGF0ZTogcmVzZXRUZW1wbGF0ZSxcblx0XHRcdHJldmVyc2U6IHJldmVyc2UsXG5cdFx0XHRzZXQ6IHNldCxcblx0XHRcdHNoaWZ0OiBzaGlmdCxcblx0XHRcdHNvcnQ6IHNvcnQsXG5cdFx0XHRzcGxpY2U6IHNwbGljZSxcblx0XHRcdHN1YnRyYWN0OiBzdWJ0cmFjdCxcblx0XHRcdHRlYXJkb3duOiB0ZWFyZG93bixcblx0XHRcdHRvZ2dsZTogdG9nZ2xlLFxuXHRcdFx0dG9IVE1MOiB0b0hUTUwsXG5cdFx0XHR1bnJlbmRlcjogdW5yZW5kZXIsXG5cdFx0XHR1bnNoaWZ0OiB1bnNoaWZ0LFxuXHRcdFx0dXBkYXRlOiB1cGRhdGUsXG5cdFx0XHR1cGRhdGVNb2RlbDogdXBkYXRlTW9kZWxcblx0XHR9O1xuXHR9KCBSYWN0aXZlJGFkZCwgUmFjdGl2ZSRhbmltYXRlLCBSYWN0aXZlJGRldGFjaCwgUmFjdGl2ZSRmaW5kLCBSYWN0aXZlJGZpbmRBbGwsIFJhY3RpdmUkZmluZEFsbENvbXBvbmVudHMsIFJhY3RpdmUkZmluZENvbXBvbmVudCwgUmFjdGl2ZSRmaXJlLCBSYWN0aXZlJGdldCwgUmFjdGl2ZSRpbnNlcnQsIFJhY3RpdmUkbWVyZ2UsIFJhY3RpdmUkb2JzZXJ2ZSwgUmFjdGl2ZSRvZmYsIFJhY3RpdmUkb24sIFJhY3RpdmUkcG9wLCBSYWN0aXZlJHB1c2gsIFJhY3RpdmUkcmVuZGVyLCBSYWN0aXZlJHJlc2V0LCBSYWN0aXZlJHJlc2V0VGVtcGxhdGUsIFJhY3RpdmUkcmV2ZXJzZSwgUmFjdGl2ZSRzZXQsIFJhY3RpdmUkc2hpZnQsIFJhY3RpdmUkc29ydCwgUmFjdGl2ZSRzcGxpY2UsIFJhY3RpdmUkc3VidHJhY3QsIFJhY3RpdmUkdGVhcmRvd24sIFJhY3RpdmUkdG9nZ2xlLCBSYWN0aXZlJHRvSFRNTCwgUmFjdGl2ZSR1bnJlbmRlciwgUmFjdGl2ZSR1bnNoaWZ0LCBSYWN0aXZlJHVwZGF0ZSwgUmFjdGl2ZSR1cGRhdGVNb2RlbCApO1xuXG5cdC8qIHV0aWxzL2dldEd1aWQuanMgKi9cblx0dmFyIGdldEd1aWQgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSggL1t4eV0vZywgZnVuY3Rpb24oIGMgKSB7XG5cdFx0XHR2YXIgciwgdjtcblx0XHRcdHIgPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwO1xuXHRcdFx0diA9IGMgPT0gJ3gnID8gciA6IHIgJiAzIHwgODtcblx0XHRcdHJldHVybiB2LnRvU3RyaW5nKCAxNiApO1xuXHRcdH0gKTtcblx0fTtcblxuXHQvKiB1dGlscy9nZXROZXh0TnVtYmVyLmpzICovXG5cdHZhciBnZXROZXh0TnVtYmVyID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgaSA9IDA7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuICdyLScgKyBpKys7XG5cdFx0fTtcblx0fSgpO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NoYXJlZC9ob29rcy9Ib29rUXVldWUuanMgKi9cblx0dmFyIFJhY3RpdmUkc2hhcmVkX2hvb2tzX0hvb2tRdWV1ZSA9IGZ1bmN0aW9uKCBIb29rICkge1xuXG5cdFx0ZnVuY3Rpb24gSG9va1F1ZXVlKCBldmVudCApIHtcblx0XHRcdHRoaXMuaG9vayA9IG5ldyBIb29rKCBldmVudCApO1xuXHRcdFx0dGhpcy5pblByb2Nlc3MgPSB7fTtcblx0XHRcdHRoaXMucXVldWUgPSB7fTtcblx0XHR9XG5cdFx0SG9va1F1ZXVlLnByb3RvdHlwZSA9IHtcblx0XHRcdGNvbnN0cnVjdG9yOiBIb29rUXVldWUsXG5cdFx0XHRiZWdpbjogZnVuY3Rpb24oIHJhY3RpdmUgKSB7XG5cdFx0XHRcdHRoaXMuaW5Qcm9jZXNzWyByYWN0aXZlLl9ndWlkIF0gPSB0cnVlO1xuXHRcdFx0fSxcblx0XHRcdGVuZDogZnVuY3Rpb24oIHJhY3RpdmUgKSB7XG5cdFx0XHRcdHZhciBwYXJlbnQgPSByYWN0aXZlLl9wYXJlbnQ7XG5cdFx0XHRcdC8vIElmIHRoaXMgaXMgKmlzbid0KiBhIGNoaWxkIG9mIGEgY29tcG9uZW50IHRoYXQncyBpbiBwcm9jZXNzLFxuXHRcdFx0XHQvLyBpdCBzaG91bGQgY2FsbCBtZXRob2RzIG9yIGZpcmUgYXQgdGhpcyBwb2ludFxuXHRcdFx0XHRpZiAoICFwYXJlbnQgfHwgIXRoaXMuaW5Qcm9jZXNzWyBwYXJlbnQuX2d1aWQgXSApIHtcblx0XHRcdFx0XHRmaXJlKCB0aGlzLCByYWN0aXZlICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Z2V0Q2hpbGRRdWV1ZSggdGhpcy5xdWV1ZSwgcGFyZW50ICkucHVzaCggcmFjdGl2ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmluUHJvY2Vzc1sgcmFjdGl2ZS5fZ3VpZCBdO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBnZXRDaGlsZFF1ZXVlKCBxdWV1ZSwgcmFjdGl2ZSApIHtcblx0XHRcdHJldHVybiBxdWV1ZVsgcmFjdGl2ZS5fZ3VpZCBdIHx8ICggcXVldWVbIHJhY3RpdmUuX2d1aWQgXSA9IFtdICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZmlyZSggaG9va1F1ZXVlLCByYWN0aXZlICkge1xuXHRcdFx0dmFyIGNoaWxkUXVldWUgPSBnZXRDaGlsZFF1ZXVlKCBob29rUXVldWUucXVldWUsIHJhY3RpdmUgKTtcblx0XHRcdGhvb2tRdWV1ZS5ob29rLmZpcmUoIHJhY3RpdmUgKTtcblx0XHRcdC8vIHF1ZXVlIGlzIFwibGl2ZVwiIGJlY2F1c2UgY29tcG9uZW50cyBjYW4gZW5kIHVwIGJlaW5nXG5cdFx0XHQvLyBhZGRlZCB3aGlsZSBob29rcyBmaXJlIG9uIHBhcmVudHMgdGhhdCBtb2RpZnkgZGF0YSB2YWx1ZXMuXG5cdFx0XHR3aGlsZSAoIGNoaWxkUXVldWUubGVuZ3RoICkge1xuXHRcdFx0XHRmaXJlKCBob29rUXVldWUsIGNoaWxkUXVldWUuc2hpZnQoKSApO1xuXHRcdFx0fVxuXHRcdFx0ZGVsZXRlIGhvb2tRdWV1ZS5xdWV1ZVsgcmFjdGl2ZS5fZ3VpZCBdO1xuXHRcdH1cblx0XHRyZXR1cm4gSG9va1F1ZXVlO1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9ob29rc19Ib29rICk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9nZXQvYXJyYXlBZGFwdG9yL3Byb2Nlc3NXcmFwcGVyLmpzICovXG5cdHZhciB2aWV3bW9kZWwkZ2V0X2FycmF5QWRhcHRvcl9wcm9jZXNzV3JhcHBlciA9IGZ1bmN0aW9uKCB3cmFwcGVyLCBhcnJheSwgbWV0aG9kTmFtZSwgbmV3SW5kaWNlcyApIHtcblx0XHR2YXIgcm9vdCA9IHdyYXBwZXIucm9vdCxcblx0XHRcdGtleXBhdGggPSB3cmFwcGVyLmtleXBhdGg7XG5cdFx0Ly8gSWYgdGhpcyBpcyBhIHNvcnQgb3IgcmV2ZXJzZSwgd2UganVzdCBkbyByb290LnNldCgpLi4uXG5cdFx0Ly8gVE9ETyB1c2UgbWVyZ2UgbG9naWM/XG5cdFx0aWYgKCBtZXRob2ROYW1lID09PSAnc29ydCcgfHwgbWV0aG9kTmFtZSA9PT0gJ3JldmVyc2UnICkge1xuXHRcdFx0cm9vdC52aWV3bW9kZWwuc2V0KCBrZXlwYXRoLCBhcnJheSApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRyb290LnZpZXdtb2RlbC5zbWFydFVwZGF0ZSgga2V5cGF0aCwgYXJyYXksIG5ld0luZGljZXMgKTtcblx0fTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2dldC9hcnJheUFkYXB0b3IvcGF0Y2guanMgKi9cblx0dmFyIHZpZXdtb2RlbCRnZXRfYXJyYXlBZGFwdG9yX3BhdGNoID0gZnVuY3Rpb24oIHJ1bmxvb3AsIGRlZmluZVByb3BlcnR5LCBnZXROZXdJbmRpY2VzLCBwcm9jZXNzV3JhcHBlciApIHtcblxuXHRcdHZhciBwYXRjaGVkQXJyYXlQcm90byA9IFtdLFxuXHRcdFx0bXV0YXRvck1ldGhvZHMgPSBbXG5cdFx0XHRcdCdwb3AnLFxuXHRcdFx0XHQncHVzaCcsXG5cdFx0XHRcdCdyZXZlcnNlJyxcblx0XHRcdFx0J3NoaWZ0Jyxcblx0XHRcdFx0J3NvcnQnLFxuXHRcdFx0XHQnc3BsaWNlJyxcblx0XHRcdFx0J3Vuc2hpZnQnXG5cdFx0XHRdLFxuXHRcdFx0dGVzdE9iaiwgcGF0Y2hBcnJheU1ldGhvZHMsIHVucGF0Y2hBcnJheU1ldGhvZHM7XG5cdFx0bXV0YXRvck1ldGhvZHMuZm9yRWFjaCggZnVuY3Rpb24oIG1ldGhvZE5hbWUgKSB7XG5cdFx0XHR2YXIgbWV0aG9kID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBTTElDRSQwID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXHRcdFx0XHR2YXIgYXJncyA9IFNMSUNFJDAuY2FsbCggYXJndW1lbnRzLCAwICk7XG5cdFx0XHRcdHZhciBuZXdJbmRpY2VzLCByZXN1bHQsIHdyYXBwZXIsIGk7XG5cdFx0XHRcdG5ld0luZGljZXMgPSBnZXROZXdJbmRpY2VzKCB0aGlzLCBtZXRob2ROYW1lLCBhcmdzICk7XG5cdFx0XHRcdC8vIGFwcGx5IHRoZSB1bmRlcmx5aW5nIG1ldGhvZFxuXHRcdFx0XHRyZXN1bHQgPSBBcnJheS5wcm90b3R5cGVbIG1ldGhvZE5hbWUgXS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdC8vIHRyaWdnZXIgY2hhbmdlc1xuXHRcdFx0XHRydW5sb29wLnN0YXJ0KCk7XG5cdFx0XHRcdHRoaXMuX3JhY3RpdmUuc2V0dGluZyA9IHRydWU7XG5cdFx0XHRcdGkgPSB0aGlzLl9yYWN0aXZlLndyYXBwZXJzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0d3JhcHBlciA9IHRoaXMuX3JhY3RpdmUud3JhcHBlcnNbIGkgXTtcblx0XHRcdFx0XHRydW5sb29wLmFkZFZpZXdtb2RlbCggd3JhcHBlci5yb290LnZpZXdtb2RlbCApO1xuXHRcdFx0XHRcdHByb2Nlc3NXcmFwcGVyKCB3cmFwcGVyLCB0aGlzLCBtZXRob2ROYW1lLCBuZXdJbmRpY2VzICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cnVubG9vcC5lbmQoKTtcblx0XHRcdFx0dGhpcy5fcmFjdGl2ZS5zZXR0aW5nID0gZmFsc2U7XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9O1xuXHRcdFx0ZGVmaW5lUHJvcGVydHkoIHBhdGNoZWRBcnJheVByb3RvLCBtZXRob2ROYW1lLCB7XG5cdFx0XHRcdHZhbHVlOiBtZXRob2Rcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdFx0Ly8gY2FuIHdlIHVzZSBwcm90b3R5cGUgY2hhaW4gaW5qZWN0aW9uP1xuXHRcdC8vIGh0dHA6Ly9wZXJmZWN0aW9ua2lsbHMuY29tL2hvdy1lY21hc2NyaXB0LTUtc3RpbGwtZG9lcy1ub3QtYWxsb3ctdG8tc3ViY2xhc3MtYW4tYXJyYXkvI3dyYXBwZXJzX3Byb3RvdHlwZV9jaGFpbl9pbmplY3Rpb25cblx0XHR0ZXN0T2JqID0ge307XG5cdFx0aWYgKCB0ZXN0T2JqLl9fcHJvdG9fXyApIHtcblx0XHRcdC8vIHllcywgd2UgY2FuXG5cdFx0XHRwYXRjaEFycmF5TWV0aG9kcyA9IGZ1bmN0aW9uKCBhcnJheSApIHtcblx0XHRcdFx0YXJyYXkuX19wcm90b19fID0gcGF0Y2hlZEFycmF5UHJvdG87XG5cdFx0XHR9O1xuXHRcdFx0dW5wYXRjaEFycmF5TWV0aG9kcyA9IGZ1bmN0aW9uKCBhcnJheSApIHtcblx0XHRcdFx0YXJyYXkuX19wcm90b19fID0gQXJyYXkucHJvdG90eXBlO1xuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gbm8sIHdlIGNhbid0XG5cdFx0XHRwYXRjaEFycmF5TWV0aG9kcyA9IGZ1bmN0aW9uKCBhcnJheSApIHtcblx0XHRcdFx0dmFyIGksIG1ldGhvZE5hbWU7XG5cdFx0XHRcdGkgPSBtdXRhdG9yTWV0aG9kcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdG1ldGhvZE5hbWUgPSBtdXRhdG9yTWV0aG9kc1sgaSBdO1xuXHRcdFx0XHRcdGRlZmluZVByb3BlcnR5KCBhcnJheSwgbWV0aG9kTmFtZSwge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHBhdGNoZWRBcnJheVByb3RvWyBtZXRob2ROYW1lIF0sXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHR1bnBhdGNoQXJyYXlNZXRob2RzID0gZnVuY3Rpb24oIGFycmF5ICkge1xuXHRcdFx0XHR2YXIgaTtcblx0XHRcdFx0aSA9IG11dGF0b3JNZXRob2RzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIGFycmF5WyBtdXRhdG9yTWV0aG9kc1sgaSBdIF07XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdHBhdGNoQXJyYXlNZXRob2RzLnVucGF0Y2ggPSB1bnBhdGNoQXJyYXlNZXRob2RzO1xuXHRcdHJldHVybiBwYXRjaEFycmF5TWV0aG9kcztcblx0fSggcnVubG9vcCwgZGVmaW5lUHJvcGVydHksIGdldE5ld0luZGljZXMsIHZpZXdtb2RlbCRnZXRfYXJyYXlBZGFwdG9yX3Byb2Nlc3NXcmFwcGVyICk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9nZXQvYXJyYXlBZGFwdG9yLmpzICovXG5cdHZhciB2aWV3bW9kZWwkZ2V0X2FycmF5QWRhcHRvciA9IGZ1bmN0aW9uKCBkZWZpbmVQcm9wZXJ0eSwgaXNBcnJheSwgcGF0Y2ggKSB7XG5cblx0XHR2YXIgYXJyYXlBZGFwdG9yLFxuXHRcdFx0Ly8gaGVscGVyc1xuXHRcdFx0QXJyYXlXcmFwcGVyLCBlcnJvck1lc3NhZ2U7XG5cdFx0YXJyYXlBZGFwdG9yID0ge1xuXHRcdFx0ZmlsdGVyOiBmdW5jdGlvbiggb2JqZWN0ICkge1xuXHRcdFx0XHQvLyB3cmFwIHRoZSBhcnJheSBpZiBhKSBiKSBpdCdzIGFuIGFycmF5LCBhbmQgYikgZWl0aGVyIGl0IGhhc24ndCBiZWVuIHdyYXBwZWQgYWxyZWFkeSxcblx0XHRcdFx0Ly8gb3IgdGhlIGFycmF5IGRpZG4ndCB0cmlnZ2VyIHRoZSBnZXQoKSBpdHNlbGZcblx0XHRcdFx0cmV0dXJuIGlzQXJyYXkoIG9iamVjdCApICYmICggIW9iamVjdC5fcmFjdGl2ZSB8fCAhb2JqZWN0Ll9yYWN0aXZlLnNldHRpbmcgKTtcblx0XHRcdH0sXG5cdFx0XHR3cmFwOiBmdW5jdGlvbiggcmFjdGl2ZSwgYXJyYXksIGtleXBhdGggKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgQXJyYXlXcmFwcGVyKCByYWN0aXZlLCBhcnJheSwga2V5cGF0aCApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0QXJyYXlXcmFwcGVyID0gZnVuY3Rpb24oIHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoICkge1xuXHRcdFx0dGhpcy5yb290ID0gcmFjdGl2ZTtcblx0XHRcdHRoaXMudmFsdWUgPSBhcnJheTtcblx0XHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG5cdFx0XHQvLyBpZiB0aGlzIGFycmF5IGhhc24ndCBhbHJlYWR5IGJlZW4gcmFjdGlmaWVkLCByYWN0aWZ5IGl0XG5cdFx0XHRpZiAoICFhcnJheS5fcmFjdGl2ZSApIHtcblx0XHRcdFx0Ly8gZGVmaW5lIGEgbm9uLWVudW1lcmFibGUgX3JhY3RpdmUgcHJvcGVydHkgdG8gc3RvcmUgdGhlIHdyYXBwZXJzXG5cdFx0XHRcdGRlZmluZVByb3BlcnR5KCBhcnJheSwgJ19yYWN0aXZlJywge1xuXHRcdFx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdFx0XHR3cmFwcGVyczogW10sXG5cdFx0XHRcdFx0XHRpbnN0YW5jZXM6IFtdLFxuXHRcdFx0XHRcdFx0c2V0dGluZzogZmFsc2Vcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHBhdGNoKCBhcnJheSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gc3RvcmUgdGhlIHJhY3RpdmUgaW5zdGFuY2UsIHNvIHdlIGNhbiBoYW5kbGUgdHJhbnNpdGlvbnMgbGF0ZXJcblx0XHRcdGlmICggIWFycmF5Ll9yYWN0aXZlLmluc3RhbmNlc1sgcmFjdGl2ZS5fZ3VpZCBdICkge1xuXHRcdFx0XHRhcnJheS5fcmFjdGl2ZS5pbnN0YW5jZXNbIHJhY3RpdmUuX2d1aWQgXSA9IDA7XG5cdFx0XHRcdGFycmF5Ll9yYWN0aXZlLmluc3RhbmNlcy5wdXNoKCByYWN0aXZlICk7XG5cdFx0XHR9XG5cdFx0XHRhcnJheS5fcmFjdGl2ZS5pbnN0YW5jZXNbIHJhY3RpdmUuX2d1aWQgXSArPSAxO1xuXHRcdFx0YXJyYXkuX3JhY3RpdmUud3JhcHBlcnMucHVzaCggdGhpcyApO1xuXHRcdH07XG5cdFx0QXJyYXlXcmFwcGVyLnByb3RvdHlwZSA9IHtcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnZhbHVlO1xuXHRcdFx0fSxcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGFycmF5LCBzdG9yYWdlLCB3cmFwcGVycywgaW5zdGFuY2VzLCBpbmRleDtcblx0XHRcdFx0YXJyYXkgPSB0aGlzLnZhbHVlO1xuXHRcdFx0XHRzdG9yYWdlID0gYXJyYXkuX3JhY3RpdmU7XG5cdFx0XHRcdHdyYXBwZXJzID0gc3RvcmFnZS53cmFwcGVycztcblx0XHRcdFx0aW5zdGFuY2VzID0gc3RvcmFnZS5pbnN0YW5jZXM7XG5cdFx0XHRcdC8vIGlmIHRlYXJkb3duKCkgd2FzIGludm9rZWQgYmVjYXVzZSB3ZSdyZSBjbGVhcmluZyB0aGUgY2FjaGUgYXMgYSByZXN1bHQgb2Zcblx0XHRcdFx0Ly8gYSBjaGFuZ2UgdGhhdCB0aGUgYXJyYXkgaXRzZWxmIHRyaWdnZXJlZCwgd2UgY2FuIHNhdmUgb3Vyc2VsdmVzIHRoZSB0ZWFyZG93blxuXHRcdFx0XHQvLyBhbmQgaW1tZWRpYXRlIHNldHVwXG5cdFx0XHRcdGlmICggc3RvcmFnZS5zZXR0aW5nICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpbmRleCA9IHdyYXBwZXJzLmluZGV4T2YoIHRoaXMgKTtcblx0XHRcdFx0aWYgKCBpbmRleCA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBlcnJvck1lc3NhZ2UgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR3cmFwcGVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdC8vIGlmIG5vdGhpbmcgZWxzZSBkZXBlbmRzIG9uIHRoaXMgYXJyYXksIHdlIGNhbiByZXZlcnQgaXQgdG8gaXRzXG5cdFx0XHRcdC8vIG5hdHVyYWwgc3RhdGVcblx0XHRcdFx0aWYgKCAhd3JhcHBlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRcdGRlbGV0ZSBhcnJheS5fcmFjdGl2ZTtcblx0XHRcdFx0XHRwYXRjaC51bnBhdGNoKCB0aGlzLnZhbHVlICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gcmVtb3ZlIHJhY3RpdmUgaW5zdGFuY2UgaWYgcG9zc2libGVcblx0XHRcdFx0XHRpbnN0YW5jZXNbIHRoaXMucm9vdC5fZ3VpZCBdIC09IDE7XG5cdFx0XHRcdFx0aWYgKCAhaW5zdGFuY2VzWyB0aGlzLnJvb3QuX2d1aWQgXSApIHtcblx0XHRcdFx0XHRcdGluZGV4ID0gaW5zdGFuY2VzLmluZGV4T2YoIHRoaXMucm9vdCApO1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggZXJyb3JNZXNzYWdlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpbnN0YW5jZXMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0ZXJyb3JNZXNzYWdlID0gJ1NvbWV0aGluZyB3ZW50IHdyb25nIGluIGEgcmF0aGVyIGludGVyZXN0aW5nIHdheSc7XG5cdFx0cmV0dXJuIGFycmF5QWRhcHRvcjtcblx0fSggZGVmaW5lUHJvcGVydHksIGlzQXJyYXksIHZpZXdtb2RlbCRnZXRfYXJyYXlBZGFwdG9yX3BhdGNoICk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9nZXQvbWFnaWNBcnJheUFkYXB0b3IuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRnZXRfbWFnaWNBcnJheUFkYXB0b3IgPSBmdW5jdGlvbiggbWFnaWNBZGFwdG9yLCBhcnJheUFkYXB0b3IgKSB7XG5cblx0XHR2YXIgbWFnaWNBcnJheUFkYXB0b3IsIE1hZ2ljQXJyYXlXcmFwcGVyO1xuXHRcdGlmICggbWFnaWNBZGFwdG9yICkge1xuXHRcdFx0bWFnaWNBcnJheUFkYXB0b3IgPSB7XG5cdFx0XHRcdGZpbHRlcjogZnVuY3Rpb24oIG9iamVjdCwga2V5cGF0aCwgcmFjdGl2ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbWFnaWNBZGFwdG9yLmZpbHRlciggb2JqZWN0LCBrZXlwYXRoLCByYWN0aXZlICkgJiYgYXJyYXlBZGFwdG9yLmZpbHRlciggb2JqZWN0ICk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHdyYXA6IGZ1bmN0aW9uKCByYWN0aXZlLCBhcnJheSwga2V5cGF0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IE1hZ2ljQXJyYXlXcmFwcGVyKCByYWN0aXZlLCBhcnJheSwga2V5cGF0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0TWFnaWNBcnJheVdyYXBwZXIgPSBmdW5jdGlvbiggcmFjdGl2ZSwgYXJyYXksIGtleXBhdGggKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSBhcnJheTtcblx0XHRcdFx0dGhpcy5tYWdpYyA9IHRydWU7XG5cdFx0XHRcdHRoaXMubWFnaWNXcmFwcGVyID0gbWFnaWNBZGFwdG9yLndyYXAoIHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoICk7XG5cdFx0XHRcdHRoaXMuYXJyYXlXcmFwcGVyID0gYXJyYXlBZGFwdG9yLndyYXAoIHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoICk7XG5cdFx0XHR9O1xuXHRcdFx0TWFnaWNBcnJheVdyYXBwZXIucHJvdG90eXBlID0ge1xuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLnZhbHVlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dGhpcy5hcnJheVdyYXBwZXIudGVhcmRvd24oKTtcblx0XHRcdFx0XHR0aGlzLm1hZ2ljV3JhcHBlci50ZWFyZG93bigpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRyZXNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLm1hZ2ljV3JhcHBlci5yZXNldCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIG1hZ2ljQXJyYXlBZGFwdG9yO1xuXHR9KCB2aWV3bW9kZWwkZ2V0X21hZ2ljQWRhcHRvciwgdmlld21vZGVsJGdldF9hcnJheUFkYXB0b3IgKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2FkYXB0LmpzICovXG5cdHZhciB2aWV3bW9kZWwkYWRhcHQgPSBmdW5jdGlvbiggY29uZmlnLCBhcnJheUFkYXB0b3IsIGxvZywgbWFnaWNBZGFwdG9yLCBtYWdpY0FycmF5QWRhcHRvciApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgcHJlZml4ZXJzID0ge307XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBWaWV3bW9kZWwkYWRhcHQoIGtleXBhdGgsIHZhbHVlICkge1xuXHRcdFx0dmFyIHJhY3RpdmUgPSB0aGlzLnJhY3RpdmUsXG5cdFx0XHRcdGxlbiwgaSwgYWRhcHRvciwgd3JhcHBlZDtcblx0XHRcdC8vIERvIHdlIGhhdmUgYW4gYWRhcHRvciBmb3IgdGhpcyB2YWx1ZT9cblx0XHRcdGxlbiA9IHJhY3RpdmUuYWRhcHQubGVuZ3RoO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0YWRhcHRvciA9IHJhY3RpdmUuYWRhcHRbIGkgXTtcblx0XHRcdFx0Ly8gQWRhcHRvcnMgY2FuIGJlIHNwZWNpZmllZCBhcyBlLmcuIFsgJ0JhY2tib25lLk1vZGVsJywgJ0JhY2tib25lLkNvbGxlY3Rpb24nIF0gLVxuXHRcdFx0XHQvLyB3ZSBuZWVkIHRvIGdldCB0aGUgYWN0dWFsIGFkYXB0b3IgaWYgdGhhdCdzIHRoZSBjYXNlXG5cdFx0XHRcdGlmICggdHlwZW9mIGFkYXB0b3IgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdHZhciBmb3VuZCA9IGNvbmZpZy5yZWdpc3RyaWVzLmFkYXB0b3JzLmZpbmQoIHJhY3RpdmUsIGFkYXB0b3IgKTtcblx0XHRcdFx0XHRpZiAoICFmb3VuZCApIHtcblx0XHRcdFx0XHRcdC8vIHdpbGwgdGhyb3cuIFwicmV0dXJuXCIgZm9yIHNhZmV0eSwgaWYgd2UgZG93bmdyYWRlIDopXG5cdFx0XHRcdFx0XHRyZXR1cm4gbG9nLmNyaXRpY2FsKCB7XG5cdFx0XHRcdFx0XHRcdGRlYnVnOiByYWN0aXZlLmRlYnVnLFxuXHRcdFx0XHRcdFx0XHRtZXNzYWdlOiAnbWlzc2luZ1BsdWdpbicsXG5cdFx0XHRcdFx0XHRcdGFyZ3M6IHtcblx0XHRcdFx0XHRcdFx0XHRwbHVnaW46ICdhZGFwdG9yJyxcblx0XHRcdFx0XHRcdFx0XHRuYW1lOiBhZGFwdG9yXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YWRhcHRvciA9IHJhY3RpdmUuYWRhcHRbIGkgXSA9IGZvdW5kO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggYWRhcHRvci5maWx0ZXIoIHZhbHVlLCBrZXlwYXRoLCByYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0d3JhcHBlZCA9IHRoaXMud3JhcHBlZFsga2V5cGF0aCBdID0gYWRhcHRvci53cmFwKCByYWN0aXZlLCB2YWx1ZSwga2V5cGF0aCwgZ2V0UHJlZml4ZXIoIGtleXBhdGggKSApO1xuXHRcdFx0XHRcdHdyYXBwZWQudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggcmFjdGl2ZS5tYWdpYyApIHtcblx0XHRcdFx0aWYgKCBtYWdpY0FycmF5QWRhcHRvci5maWx0ZXIoIHZhbHVlLCBrZXlwYXRoLCByYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0dGhpcy53cmFwcGVkWyBrZXlwYXRoIF0gPSBtYWdpY0FycmF5QWRhcHRvci53cmFwKCByYWN0aXZlLCB2YWx1ZSwga2V5cGF0aCApO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYWdpY0FkYXB0b3IuZmlsdGVyKCB2YWx1ZSwga2V5cGF0aCwgcmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdHRoaXMud3JhcHBlZFsga2V5cGF0aCBdID0gbWFnaWNBZGFwdG9yLndyYXAoIHJhY3RpdmUsIHZhbHVlLCBrZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoIHJhY3RpdmUubW9kaWZ5QXJyYXlzICYmIGFycmF5QWRhcHRvci5maWx0ZXIoIHZhbHVlLCBrZXlwYXRoLCByYWN0aXZlICkgKSB7XG5cdFx0XHRcdHRoaXMud3JhcHBlZFsga2V5cGF0aCBdID0gYXJyYXlBZGFwdG9yLndyYXAoIHJhY3RpdmUsIHZhbHVlLCBrZXlwYXRoICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHByZWZpeEtleXBhdGgoIG9iaiwgcHJlZml4ICkge1xuXHRcdFx0dmFyIHByZWZpeGVkID0ge30sXG5cdFx0XHRcdGtleTtcblx0XHRcdGlmICggIXByZWZpeCApIHtcblx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdH1cblx0XHRcdHByZWZpeCArPSAnLic7XG5cdFx0XHRmb3IgKCBrZXkgaW4gb2JqICkge1xuXHRcdFx0XHRpZiAoIG9iai5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgKSB7XG5cdFx0XHRcdFx0cHJlZml4ZWRbIHByZWZpeCArIGtleSBdID0gb2JqWyBrZXkgXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByZWZpeGVkO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFByZWZpeGVyKCByb290S2V5cGF0aCApIHtcblx0XHRcdHZhciByb290RG90O1xuXHRcdFx0aWYgKCAhcHJlZml4ZXJzWyByb290S2V5cGF0aCBdICkge1xuXHRcdFx0XHRyb290RG90ID0gcm9vdEtleXBhdGggPyByb290S2V5cGF0aCArICcuJyA6ICcnO1xuXHRcdFx0XHRwcmVmaXhlcnNbIHJvb3RLZXlwYXRoIF0gPSBmdW5jdGlvbiggcmVsYXRpdmVLZXlwYXRoLCB2YWx1ZSApIHtcblx0XHRcdFx0XHR2YXIgb2JqO1xuXHRcdFx0XHRcdGlmICggdHlwZW9mIHJlbGF0aXZlS2V5cGF0aCA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0XHRvYmogPSB7fTtcblx0XHRcdFx0XHRcdG9ialsgcm9vdERvdCArIHJlbGF0aXZlS2V5cGF0aCBdID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRyZXR1cm4gb2JqO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHR5cGVvZiByZWxhdGl2ZUtleXBhdGggPT09ICdvYmplY3QnICkge1xuXHRcdFx0XHRcdFx0Ly8gJ3JlbGF0aXZlS2V5cGF0aCcgaXMgaW4gZmFjdCBhIGhhc2gsIG5vdCBhIGtleXBhdGhcblx0XHRcdFx0XHRcdHJldHVybiByb290RG90ID8gcHJlZml4S2V5cGF0aCggcmVsYXRpdmVLZXlwYXRoLCByb290S2V5cGF0aCApIDogcmVsYXRpdmVLZXlwYXRoO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwcmVmaXhlcnNbIHJvb3RLZXlwYXRoIF07XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggY29uZmlnLCB2aWV3bW9kZWwkZ2V0X2FycmF5QWRhcHRvciwgbG9nLCB2aWV3bW9kZWwkZ2V0X21hZ2ljQWRhcHRvciwgdmlld21vZGVsJGdldF9tYWdpY0FycmF5QWRhcHRvciApO1xuXG5cdC8qIHZpZXdtb2RlbC9oZWxwZXJzL2dldFVwc3RyZWFtQ2hhbmdlcy5qcyAqL1xuXHR2YXIgZ2V0VXBzdHJlYW1DaGFuZ2VzID0gZnVuY3Rpb24gZ2V0VXBzdHJlYW1DaGFuZ2VzKCBjaGFuZ2VzICkge1xuXHRcdHZhciB1cHN0cmVhbUNoYW5nZXMgPSBbICcnIF0sXG5cdFx0XHRpLCBrZXlwYXRoLCBrZXlzLCB1cHN0cmVhbUtleXBhdGg7XG5cdFx0aSA9IGNoYW5nZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0a2V5cGF0aCA9IGNoYW5nZXNbIGkgXTtcblx0XHRcdGtleXMgPSBrZXlwYXRoLnNwbGl0KCAnLicgKTtcblx0XHRcdHdoaWxlICgga2V5cy5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRrZXlzLnBvcCgpO1xuXHRcdFx0XHR1cHN0cmVhbUtleXBhdGggPSBrZXlzLmpvaW4oICcuJyApO1xuXHRcdFx0XHRpZiAoIHVwc3RyZWFtQ2hhbmdlcy5pbmRleE9mKCB1cHN0cmVhbUtleXBhdGggKSA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0dXBzdHJlYW1DaGFuZ2VzLnB1c2goIHVwc3RyZWFtS2V5cGF0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB1cHN0cmVhbUNoYW5nZXM7XG5cdH07XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9hcHBseUNoYW5nZXMvZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzLmpzICovXG5cdHZhciB2aWV3bW9kZWwkYXBwbHlDaGFuZ2VzX2dldFBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBzdGFyTWFwcyA9IHt9O1xuXHRcdC8vIFRoaXMgZnVuY3Rpb24gdGFrZXMgYSBrZXlwYXRoIHN1Y2ggYXMgJ2Zvby5iYXIuYmF6JywgYW5kIHJldHVybnNcblx0XHQvLyBhbGwgdGhlIHZhcmlhbnRzIG9mIHRoYXQga2V5cGF0aCB0aGF0IGluY2x1ZGUgYSB3aWxkY2FyZCBpbiBwbGFjZVxuXHRcdC8vIG9mIGEga2V5LCBzdWNoIGFzICdmb28uYmFyLionLCAnZm9vLiouYmF6JywgJ2Zvby4qLionIGFuZCBzbyBvbi5cblx0XHQvLyBUaGVzZSBhcmUgdGhlbiBjaGVja2VkIGFnYWluc3QgdGhlIGRlcGVuZGFudHMgbWFwIChyYWN0aXZlLnZpZXdtb2RlbC5kZXBzTWFwKVxuXHRcdC8vIHRvIHNlZSBpZiBhbnkgcGF0dGVybiBvYnNlcnZlcnMgYXJlIGRvd25zdHJlYW0gb2Ygb25lIG9yIG1vcmUgb2Zcblx0XHQvLyB0aGVzZSB3aWxkY2FyZCBrZXlwYXRocyAoZS5nLiAnZm9vLmJhci4qLnN0YXR1cycpXG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBnZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMoIGtleXBhdGggKSB7XG5cdFx0XHR2YXIga2V5cywgc3Rhck1hcCwgbWFwcGVyLCByZXN1bHQ7XG5cdFx0XHRrZXlzID0ga2V5cGF0aC5zcGxpdCggJy4nICk7XG5cdFx0XHRzdGFyTWFwID0gZ2V0U3Rhck1hcCgga2V5cy5sZW5ndGggKTtcblx0XHRcdG1hcHBlciA9IGZ1bmN0aW9uKCBzdGFyLCBpICkge1xuXHRcdFx0XHRyZXR1cm4gc3RhciA/ICcqJyA6IGtleXNbIGkgXTtcblx0XHRcdH07XG5cdFx0XHRyZXN1bHQgPSBzdGFyTWFwLm1hcCggZnVuY3Rpb24oIG1hc2sgKSB7XG5cdFx0XHRcdHJldHVybiBtYXNrLm1hcCggbWFwcGVyICkuam9pbiggJy4nICk7XG5cdFx0XHR9ICk7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cdFx0Ly8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGFsbCB0aGUgcG9zc2libGUgdHJ1ZS9mYWxzZSBjb21iaW5hdGlvbnMgZm9yXG5cdFx0Ly8gYSBnaXZlbiBudW1iZXIgLSBlLmcuIGZvciB0d28sIHRoZSBwb3NzaWJsZSBjb21iaW5hdGlvbnMgYXJlXG5cdFx0Ly8gWyB0cnVlLCB0cnVlIF0sIFsgdHJ1ZSwgZmFsc2UgXSwgWyBmYWxzZSwgdHJ1ZSBdLCBbIGZhbHNlLCBmYWxzZSBdLlxuXHRcdC8vIEl0IGRvZXMgc28gYnkgZ2V0dGluZyBhbGwgdGhlIGJpbmFyeSB2YWx1ZXMgYmV0d2VlbiAwIGFuZCBlLmcuIDExXG5cdFx0ZnVuY3Rpb24gZ2V0U3Rhck1hcCggbGVuZ3RoICkge1xuXHRcdFx0dmFyIG9uZXMgPSAnJyxcblx0XHRcdFx0bWF4LCBiaW5hcnksIHN0YXJNYXAsIG1hcHBlciwgaTtcblx0XHRcdGlmICggIXN0YXJNYXBzWyBsZW5ndGggXSApIHtcblx0XHRcdFx0c3Rhck1hcCA9IFtdO1xuXHRcdFx0XHR3aGlsZSAoIG9uZXMubGVuZ3RoIDwgbGVuZ3RoICkge1xuXHRcdFx0XHRcdG9uZXMgKz0gMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRtYXggPSBwYXJzZUludCggb25lcywgMiApO1xuXHRcdFx0XHRtYXBwZXIgPSBmdW5jdGlvbiggZGlnaXQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRpZ2l0ID09PSAnMSc7XG5cdFx0XHRcdH07XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDw9IG1heDsgaSArPSAxICkge1xuXHRcdFx0XHRcdGJpbmFyeSA9IGkudG9TdHJpbmcoIDIgKTtcblx0XHRcdFx0XHR3aGlsZSAoIGJpbmFyeS5sZW5ndGggPCBsZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRiaW5hcnkgPSAnMCcgKyBiaW5hcnk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHN0YXJNYXBbIGkgXSA9IEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbCggYmluYXJ5LCBtYXBwZXIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzdGFyTWFwc1sgbGVuZ3RoIF0gPSBzdGFyTWFwO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHN0YXJNYXBzWyBsZW5ndGggXTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9hcHBseUNoYW5nZXMvbm90aWZ5UGF0dGVybk9ic2VydmVycy5qcyAqL1xuXHR2YXIgdmlld21vZGVsJGFwcGx5Q2hhbmdlc19ub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzID0gZnVuY3Rpb24oIGdldFBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcyApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgbGFzdEtleSA9IC9bXlxcLl0rJC87XG5cdFx0X19leHBvcnQgPSBub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzO1xuXG5cdFx0ZnVuY3Rpb24gbm90aWZ5UGF0dGVybk9ic2VydmVycyggdmlld21vZGVsLCBrZXlwYXRoLCBvbmx5RGlyZWN0ICkge1xuXHRcdFx0dmFyIHBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcztcblx0XHRcdHVwZGF0ZU1hdGNoaW5nUGF0dGVybk9ic2VydmVycyggdmlld21vZGVsLCBrZXlwYXRoICk7XG5cdFx0XHRpZiAoIG9ubHlEaXJlY3QgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcyA9IGdldFBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcygga2V5cGF0aCApO1xuXHRcdFx0cG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzLmZvckVhY2goIGZ1bmN0aW9uKCB1cHN0cmVhbVBhdHRlcm4gKSB7XG5cdFx0XHRcdGNhc2NhZGUoIHZpZXdtb2RlbCwgdXBzdHJlYW1QYXR0ZXJuLCBrZXlwYXRoICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2FzY2FkZSggdmlld21vZGVsLCB1cHN0cmVhbVBhdHRlcm4sIGtleXBhdGggKSB7XG5cdFx0XHR2YXIgZ3JvdXAsIG1hcCwgYWN0dWFsQ2hpbGRLZXlwYXRoO1xuXHRcdFx0Z3JvdXAgPSB2aWV3bW9kZWwuZGVwc01hcC5wYXR0ZXJuT2JzZXJ2ZXJzO1xuXHRcdFx0bWFwID0gZ3JvdXBbIHVwc3RyZWFtUGF0dGVybiBdO1xuXHRcdFx0aWYgKCBtYXAgKSB7XG5cdFx0XHRcdG1hcC5mb3JFYWNoKCBmdW5jdGlvbiggY2hpbGRLZXlwYXRoICkge1xuXHRcdFx0XHRcdHZhciBrZXkgPSBsYXN0S2V5LmV4ZWMoIGNoaWxkS2V5cGF0aCApWyAwIF07XG5cdFx0XHRcdFx0Ly8gJ2Jheidcblx0XHRcdFx0XHRhY3R1YWxDaGlsZEtleXBhdGggPSBrZXlwYXRoID8ga2V5cGF0aCArICcuJyArIGtleSA6IGtleTtcblx0XHRcdFx0XHQvLyAnZm9vLmJhci5iYXonXG5cdFx0XHRcdFx0dXBkYXRlTWF0Y2hpbmdQYXR0ZXJuT2JzZXJ2ZXJzKCB2aWV3bW9kZWwsIGFjdHVhbENoaWxkS2V5cGF0aCApO1xuXHRcdFx0XHRcdGNhc2NhZGUoIHZpZXdtb2RlbCwgY2hpbGRLZXlwYXRoLCBhY3R1YWxDaGlsZEtleXBhdGggKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVwZGF0ZU1hdGNoaW5nUGF0dGVybk9ic2VydmVycyggdmlld21vZGVsLCBrZXlwYXRoICkge1xuXHRcdFx0dmlld21vZGVsLnBhdHRlcm5PYnNlcnZlcnMuZm9yRWFjaCggZnVuY3Rpb24oIG9ic2VydmVyICkge1xuXHRcdFx0XHRpZiAoIG9ic2VydmVyLnJlZ2V4LnRlc3QoIGtleXBhdGggKSApIHtcblx0XHRcdFx0XHRvYnNlcnZlci51cGRhdGUoIGtleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIHZpZXdtb2RlbCRhcHBseUNoYW5nZXNfZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzICk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9hcHBseUNoYW5nZXMuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRhcHBseUNoYW5nZXMgPSBmdW5jdGlvbiggZ2V0VXBzdHJlYW1DaGFuZ2VzLCBub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gVmlld21vZGVsJGFwcGx5Q2hhbmdlcygpIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0XHRjaGFuZ2VzLCB1cHN0cmVhbUNoYW5nZXMsIGhhc2ggPSB7fTtcblx0XHRcdGNoYW5nZXMgPSB0aGlzLmNoYW5nZXM7XG5cdFx0XHRpZiAoICFjaGFuZ2VzLmxlbmd0aCApIHtcblx0XHRcdFx0Ly8gVE9ETyB3ZSBlbmQgdXAgaGVyZSBvbiBpbml0aWFsIHJlbmRlci4gUGVyaGFwcyB3ZSBzaG91bGRuJ3Q/XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gY2FzY2FkZSgga2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIG1hcCwgZGVwZW5kYW50cywga2V5cztcblx0XHRcdFx0aWYgKCBzZWxmLm5vQ2FzY2FkZS5oYXNPd25Qcm9wZXJ0eSgga2V5cGF0aCApICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGRlcGVuZGFudHMgPSBzZWxmLmRlcHMuY29tcHV0ZWRbIGtleXBhdGggXSApIHtcblx0XHRcdFx0XHRkZXBlbmRhbnRzLmZvckVhY2goIGludmFsaWRhdGUgKTtcblx0XHRcdFx0XHRrZXlzID0gZGVwZW5kYW50cy5tYXAoIGdldEtleSApO1xuXHRcdFx0XHRcdGtleXMuZm9yRWFjaCggbWFyayApO1xuXHRcdFx0XHRcdGtleXMuZm9yRWFjaCggY2FzY2FkZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggbWFwID0gc2VsZi5kZXBzTWFwLmNvbXB1dGVkWyBrZXlwYXRoIF0gKSB7XG5cdFx0XHRcdFx0bWFwLmZvckVhY2goIGNhc2NhZGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBtYXJrKCBrZXlwYXRoICkge1xuXHRcdFx0XHRzZWxmLm1hcmsoIGtleXBhdGggKTtcblx0XHRcdH1cblx0XHRcdGNoYW5nZXMuZm9yRWFjaCggY2FzY2FkZSApO1xuXHRcdFx0dXBzdHJlYW1DaGFuZ2VzID0gZ2V0VXBzdHJlYW1DaGFuZ2VzKCBjaGFuZ2VzICk7XG5cdFx0XHR1cHN0cmVhbUNoYW5nZXMuZm9yRWFjaCggZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdHZhciBkZXBlbmRhbnRzLCBrZXlzO1xuXHRcdFx0XHRpZiAoIGRlcGVuZGFudHMgPSBzZWxmLmRlcHMuY29tcHV0ZWRbIGtleXBhdGggXSApIHtcblx0XHRcdFx0XHRkZXBlbmRhbnRzLmZvckVhY2goIGludmFsaWRhdGUgKTtcblx0XHRcdFx0XHRrZXlzID0gZGVwZW5kYW50cy5tYXAoIGdldEtleSApO1xuXHRcdFx0XHRcdGtleXMuZm9yRWFjaCggbWFyayApO1xuXHRcdFx0XHRcdGtleXMuZm9yRWFjaCggY2FzY2FkZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0XHR0aGlzLmNoYW5nZXMgPSBbXTtcblx0XHRcdC8vIFBhdHRlcm4gb2JzZXJ2ZXJzIGFyZSBhIHdlaXJkIHNwZWNpYWwgY2FzZVxuXHRcdFx0aWYgKCB0aGlzLnBhdHRlcm5PYnNlcnZlcnMubGVuZ3RoICkge1xuXHRcdFx0XHR1cHN0cmVhbUNoYW5nZXMuZm9yRWFjaCggZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5vdGlmeVBhdHRlcm5PYnNlcnZlcnMoIHRoaXMkMCwga2V5cGF0aCwgdHJ1ZSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdGNoYW5nZXMuZm9yRWFjaCggZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5vdGlmeVBhdHRlcm5PYnNlcnZlcnMoIHRoaXMkMCwga2V5cGF0aCApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMuZGVwcy5vYnNlcnZlcnMgKSB7XG5cdFx0XHRcdHVwc3RyZWFtQ2hhbmdlcy5mb3JFYWNoKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4gbm90aWZ5VXBzdHJlYW1EZXBlbmRhbnRzKCB0aGlzJDAsIG51bGwsIGtleXBhdGgsICdvYnNlcnZlcnMnICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0bm90aWZ5QWxsRGVwZW5kYW50cyggdGhpcywgY2hhbmdlcywgJ29ic2VydmVycycgKTtcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5kZXBzWyAnZGVmYXVsdCcgXSApIHtcblx0XHRcdFx0dmFyIGJpbmRpbmdzID0gW107XG5cdFx0XHRcdHVwc3RyZWFtQ2hhbmdlcy5mb3JFYWNoKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4gbm90aWZ5VXBzdHJlYW1EZXBlbmRhbnRzKCB0aGlzJDAsIGJpbmRpbmdzLCBrZXlwYXRoLCAnZGVmYXVsdCcgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRpZiAoIGJpbmRpbmdzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRub3RpZnlCaW5kaW5ncyggdGhpcywgYmluZGluZ3MsIGNoYW5nZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRub3RpZnlBbGxEZXBlbmRhbnRzKCB0aGlzLCBjaGFuZ2VzLCAnZGVmYXVsdCcgKTtcblx0XHRcdH1cblx0XHRcdC8vIFJldHVybiBhIGhhc2ggb2Yga2V5cGF0aHMgdG8gdXBkYXRlZCB2YWx1ZXNcblx0XHRcdGNoYW5nZXMuZm9yRWFjaCggZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdGhhc2hbIGtleXBhdGggXSA9IHRoaXMkMC5nZXQoIGtleXBhdGggKTtcblx0XHRcdH0gKTtcblx0XHRcdHRoaXMuaW1wbGljaXRDaGFuZ2VzID0ge307XG5cdFx0XHR0aGlzLm5vQ2FzY2FkZSA9IHt9O1xuXHRcdFx0cmV0dXJuIGhhc2g7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGludmFsaWRhdGUoIGNvbXB1dGF0aW9uICkge1xuXHRcdFx0Y29tcHV0YXRpb24uaW52YWxpZGF0ZSgpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldEtleSggY29tcHV0YXRpb24gKSB7XG5cdFx0XHRyZXR1cm4gY29tcHV0YXRpb24ua2V5O1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG5vdGlmeVVwc3RyZWFtRGVwZW5kYW50cyggdmlld21vZGVsLCBiaW5kaW5ncywga2V5cGF0aCwgZ3JvdXBOYW1lICkge1xuXHRcdFx0dmFyIGRlcGVuZGFudHMsIHZhbHVlO1xuXHRcdFx0aWYgKCBkZXBlbmRhbnRzID0gZmluZERlcGVuZGFudHMoIHZpZXdtb2RlbCwga2V5cGF0aCwgZ3JvdXBOYW1lICkgKSB7XG5cdFx0XHRcdHZhbHVlID0gdmlld21vZGVsLmdldCgga2V5cGF0aCApO1xuXHRcdFx0XHRkZXBlbmRhbnRzLmZvckVhY2goIGZ1bmN0aW9uKCBkICkge1xuXHRcdFx0XHRcdC8vIGRvbid0IFwic2V0XCIgdGhlIHBhcmVudCB2YWx1ZSwgcmVmaW5lIGl0XG5cdFx0XHRcdFx0Ly8gaS5lLiBub3QgZGF0YSA9IHZhbHVlLCBidXQgZGF0YVtmb29dID0gZm9vVmFsdWVcblx0XHRcdFx0XHRpZiAoIGJpbmRpbmdzICYmIGQucmVmaW5lVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRiaW5kaW5ncy5wdXNoKCBkICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGQuc2V0VmFsdWUoIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbm90aWZ5QmluZGluZ3MoIHZpZXdtb2RlbCwgYmluZGluZ3MsIGNoYW5nZXMgKSB7XG5cdFx0XHRiaW5kaW5ncy5mb3JFYWNoKCBmdW5jdGlvbiggYmluZGluZyApIHtcblx0XHRcdFx0dmFyIHVzZVNldCA9IGZhbHNlLFxuXHRcdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRcdGxlbmd0aCA9IGNoYW5nZXMubGVuZ3RoLFxuXHRcdFx0XHRcdHJlZmluZW1lbnRzID0gW107XG5cdFx0XHRcdHdoaWxlICggaSA8IGxlbmd0aCApIHtcblx0XHRcdFx0XHR2YXIga2V5cGF0aCA9IGNoYW5nZXNbIGkgXTtcblx0XHRcdFx0XHRpZiAoIGtleXBhdGggPT09IGJpbmRpbmcua2V5cGF0aCApIHtcblx0XHRcdFx0XHRcdHVzZVNldCA9IHRydWU7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBrZXlwYXRoLnNsaWNlKCAwLCBiaW5kaW5nLmtleXBhdGgubGVuZ3RoICkgPT09IGJpbmRpbmcua2V5cGF0aCApIHtcblx0XHRcdFx0XHRcdHJlZmluZW1lbnRzLnB1c2goIGtleXBhdGggKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggdXNlU2V0ICkge1xuXHRcdFx0XHRcdGJpbmRpbmcuc2V0VmFsdWUoIHZpZXdtb2RlbC5nZXQoIGJpbmRpbmcua2V5cGF0aCApICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCByZWZpbmVtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0YmluZGluZy5yZWZpbmVWYWx1ZSggcmVmaW5lbWVudHMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG5vdGlmeUFsbERlcGVuZGFudHMoIHZpZXdtb2RlbCwga2V5cGF0aHMsIGdyb3VwTmFtZSApIHtcblx0XHRcdHZhciBxdWV1ZSA9IFtdO1xuXHRcdFx0YWRkS2V5cGF0aHMoIGtleXBhdGhzICk7XG5cdFx0XHRxdWV1ZS5mb3JFYWNoKCBkaXNwYXRjaCApO1xuXG5cdFx0XHRmdW5jdGlvbiBhZGRLZXlwYXRocygga2V5cGF0aHMgKSB7XG5cdFx0XHRcdGtleXBhdGhzLmZvckVhY2goIGFkZEtleXBhdGggKTtcblx0XHRcdFx0a2V5cGF0aHMuZm9yRWFjaCggY2FzY2FkZSApO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBhZGRLZXlwYXRoKCBrZXlwYXRoICkge1xuXHRcdFx0XHR2YXIgZGVwcyA9IGZpbmREZXBlbmRhbnRzKCB2aWV3bW9kZWwsIGtleXBhdGgsIGdyb3VwTmFtZSApO1xuXHRcdFx0XHRpZiAoIGRlcHMgKSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCgge1xuXHRcdFx0XHRcdFx0a2V5cGF0aDoga2V5cGF0aCxcblx0XHRcdFx0XHRcdGRlcHM6IGRlcHNcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gY2FzY2FkZSgga2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIGNoaWxkRGVwcztcblx0XHRcdFx0aWYgKCBjaGlsZERlcHMgPSB2aWV3bW9kZWwuZGVwc01hcFsgZ3JvdXBOYW1lIF1bIGtleXBhdGggXSApIHtcblx0XHRcdFx0XHRhZGRLZXlwYXRocyggY2hpbGREZXBzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gZGlzcGF0Y2goIHNldCApIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gdmlld21vZGVsLmdldCggc2V0LmtleXBhdGggKTtcblx0XHRcdFx0c2V0LmRlcHMuZm9yRWFjaCggZnVuY3Rpb24oIGQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGQuc2V0VmFsdWUoIHZhbHVlICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBmaW5kRGVwZW5kYW50cyggdmlld21vZGVsLCBrZXlwYXRoLCBncm91cE5hbWUgKSB7XG5cdFx0XHR2YXIgZ3JvdXAgPSB2aWV3bW9kZWwuZGVwc1sgZ3JvdXBOYW1lIF07XG5cdFx0XHRyZXR1cm4gZ3JvdXAgPyBncm91cFsga2V5cGF0aCBdIDogbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBnZXRVcHN0cmVhbUNoYW5nZXMsIHZpZXdtb2RlbCRhcHBseUNoYW5nZXNfbm90aWZ5UGF0dGVybk9ic2VydmVycyApO1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvY2FwdHVyZS5qcyAqL1xuXHR2YXIgdmlld21vZGVsJGNhcHR1cmUgPSBmdW5jdGlvbiBWaWV3bW9kZWwkY2FwdHVyZSgpIHtcblx0XHR0aGlzLmNhcHR1cmVHcm91cHMucHVzaCggW10gKTtcblx0fTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2NsZWFyQ2FjaGUuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRjbGVhckNhY2hlID0gZnVuY3Rpb24gVmlld21vZGVsJGNsZWFyQ2FjaGUoIGtleXBhdGgsIGRvbnRUZWFyZG93bldyYXBwZXIgKSB7XG5cdFx0dmFyIGNhY2hlTWFwLCB3cmFwcGVyO1xuXHRcdGlmICggIWRvbnRUZWFyZG93bldyYXBwZXIgKSB7XG5cdFx0XHQvLyBJcyB0aGVyZSBhIHdyYXBwZWQgcHJvcGVydHkgYXQgdGhpcyBrZXlwYXRoP1xuXHRcdFx0aWYgKCB3cmFwcGVyID0gdGhpcy53cmFwcGVkWyBrZXlwYXRoIF0gKSB7XG5cdFx0XHRcdC8vIERpZCB3ZSB1bndyYXAgaXQ/XG5cdFx0XHRcdGlmICggd3JhcHBlci50ZWFyZG93bigpICE9PSBmYWxzZSApIHtcblx0XHRcdFx0XHQvLyBJcyB0aGlzIHJpZ2h0P1xuXHRcdFx0XHRcdC8vIFdoYXQncyB0aGUgbWVhbmluZyBvZiByZXR1cm5pbmcgZmFsc2UgZnJvbSB0ZWFyZG93bj9cblx0XHRcdFx0XHQvLyBDb3VsZCB0aGVyZSBiZSBhIEdDIHJhbWlmaWNhdGlvbiBpZiB0aGlzIGlzIGEgXCJyZWFsXCIgcmFjdGl2ZS50ZWFyZG93bigpP1xuXHRcdFx0XHRcdHRoaXMud3JhcHBlZFsga2V5cGF0aCBdID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLmNhY2hlWyBrZXlwYXRoIF0gPSB1bmRlZmluZWQ7XG5cdFx0aWYgKCBjYWNoZU1hcCA9IHRoaXMuY2FjaGVNYXBbIGtleXBhdGggXSApIHtcblx0XHRcdHdoaWxlICggY2FjaGVNYXAubGVuZ3RoICkge1xuXHRcdFx0XHR0aGlzLmNsZWFyQ2FjaGUoIGNhY2hlTWFwLnBvcCgpICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpZXdtb2RlbC9Db21wdXRhdGlvbi9nZXRDb21wdXRhdGlvblNpZ25hdHVyZS5qcyAqL1xuXHR2YXIgZ2V0Q29tcHV0YXRpb25TaWduYXR1cmUgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgcGF0dGVybiA9IC9cXCRcXHsoW15cXH1dKylcXH0vZztcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uKCBzaWduYXR1cmUgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBzaWduYXR1cmUgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0Z2V0OiBzaWduYXR1cmVcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGlmICggdHlwZW9mIHNpZ25hdHVyZSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0Z2V0OiBjcmVhdGVGdW5jdGlvbkZyb21TdHJpbmcoIHNpZ25hdHVyZSApXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHR5cGVvZiBzaWduYXR1cmUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBzaWduYXR1cmUuZ2V0ID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0c2lnbmF0dXJlID0ge1xuXHRcdFx0XHRcdGdldDogY3JlYXRlRnVuY3Rpb25Gcm9tU3RyaW5nKCBzaWduYXR1cmUuZ2V0ICksXG5cdFx0XHRcdFx0c2V0OiBzaWduYXR1cmUuc2V0XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc2lnbmF0dXJlO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBjcmVhdGVGdW5jdGlvbkZyb21TdHJpbmcoIHNpZ25hdHVyZSApIHtcblx0XHRcdHZhciBmdW5jdGlvbkJvZHkgPSAndmFyIF9fcmFjdGl2ZT10aGlzO3JldHVybignICsgc2lnbmF0dXJlLnJlcGxhY2UoIHBhdHRlcm4sIGZ1bmN0aW9uKCBtYXRjaCwga2V5cGF0aCApIHtcblx0XHRcdFx0cmV0dXJuICdfX3JhY3RpdmUuZ2V0KFwiJyArIGtleXBhdGggKyAnXCIpJztcblx0XHRcdH0gKSArICcpJztcblx0XHRcdHJldHVybiBuZXcgRnVuY3Rpb24oIGZ1bmN0aW9uQm9keSApO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oKTtcblxuXHQvKiB2aWV3bW9kZWwvQ29tcHV0YXRpb24vQ29tcHV0YXRpb24uanMgKi9cblx0dmFyIENvbXB1dGF0aW9uID0gZnVuY3Rpb24oIGxvZywgaXNFcXVhbCApIHtcblxuXHRcdHZhciBDb21wdXRhdGlvbiA9IGZ1bmN0aW9uKCByYWN0aXZlLCBrZXksIHNpZ25hdHVyZSApIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dGhpcy5yYWN0aXZlID0gcmFjdGl2ZTtcblx0XHRcdHRoaXMudmlld21vZGVsID0gcmFjdGl2ZS52aWV3bW9kZWw7XG5cdFx0XHR0aGlzLmtleSA9IGtleTtcblx0XHRcdHRoaXMuZ2V0dGVyID0gc2lnbmF0dXJlLmdldDtcblx0XHRcdHRoaXMuc2V0dGVyID0gc2lnbmF0dXJlLnNldDtcblx0XHRcdHRoaXMuaGFyZERlcHMgPSBzaWduYXR1cmUuZGVwcyB8fCBbXTtcblx0XHRcdHRoaXMuc29mdERlcHMgPSBbXTtcblx0XHRcdHRoaXMuZGVwVmFsdWVzID0ge307XG5cdFx0XHRpZiAoIHRoaXMuaGFyZERlcHMgKSB7XG5cdFx0XHRcdHRoaXMuaGFyZERlcHMuZm9yRWFjaCggZnVuY3Rpb24oIGQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJhY3RpdmUudmlld21vZGVsLnJlZ2lzdGVyKCBkLCB0aGlzJDAsICdjb21wdXRlZCcgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZGlydHkgPSB0aGlzLl9maXJzdFJ1biA9IHRydWU7XG5cdFx0fTtcblx0XHRDb21wdXRhdGlvbi5wcm90b3R5cGUgPSB7XG5cdFx0XHRjb25zdHJ1Y3RvcjogQ29tcHV0YXRpb24sXG5cdFx0XHRpbml0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGluaXRpYWw7XG5cdFx0XHRcdHRoaXMuYnlwYXNzID0gdHJ1ZTtcblx0XHRcdFx0aW5pdGlhbCA9IHRoaXMucmFjdGl2ZS52aWV3bW9kZWwuZ2V0KCB0aGlzLmtleSApO1xuXHRcdFx0XHR0aGlzLnJhY3RpdmUudmlld21vZGVsLmNsZWFyQ2FjaGUoIHRoaXMua2V5ICk7XG5cdFx0XHRcdHRoaXMuYnlwYXNzID0gZmFsc2U7XG5cdFx0XHRcdGlmICggdGhpcy5zZXR0ZXIgJiYgaW5pdGlhbCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRoaXMuc2V0KCBpbml0aWFsICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRpbnZhbGlkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5fZGlydHkgPSB0cnVlO1xuXHRcdFx0fSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0XHR2YXIgcmFjdGl2ZSwgbmV3RGVwcywgZGVwZW5kZW5jaWVzQ2hhbmdlZCwgZGVwZW5kZW5jeVZhbHVlc0NoYW5nZWQgPSBmYWxzZTtcblx0XHRcdFx0aWYgKCB0aGlzLmdldHRpbmcgKSB7XG5cdFx0XHRcdFx0Ly8gcHJldmVudCBkb3VibGUtY29tcHV0YXRpb24gKGUuZy4gY2F1c2VkIGJ5IGFycmF5IG11dGF0aW9uIGluc2lkZSBjb21wdXRhdGlvbilcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5nZXR0aW5nID0gdHJ1ZTtcblx0XHRcdFx0aWYgKCB0aGlzLl9kaXJ0eSApIHtcblx0XHRcdFx0XHRyYWN0aXZlID0gdGhpcy5yYWN0aXZlO1xuXHRcdFx0XHRcdC8vIGRldGVybWluZSB3aGV0aGVyIHRoZSBpbnB1dHMgaGF2ZSBjaGFuZ2VkLCBpbiBjYXNlIHRoaXMgZGVwZW5kcyBvblxuXHRcdFx0XHRcdC8vIG90aGVyIGNvbXB1dGVkIHZhbHVlc1xuXHRcdFx0XHRcdGlmICggdGhpcy5fZmlyc3RSdW4gfHwgIXRoaXMuaGFyZERlcHMubGVuZ3RoICYmICF0aGlzLnNvZnREZXBzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGRlcGVuZGVuY3lWYWx1ZXNDaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0W1xuXHRcdFx0XHRcdFx0XHR0aGlzLmhhcmREZXBzLFxuXHRcdFx0XHRcdFx0XHR0aGlzLnNvZnREZXBzXG5cdFx0XHRcdFx0XHRdLmZvckVhY2goIGZ1bmN0aW9uKCBkZXBzICkge1xuXHRcdFx0XHRcdFx0XHR2YXIga2V5cGF0aCwgdmFsdWUsIGk7XG5cdFx0XHRcdFx0XHRcdGlmICggZGVwZW5kZW5jeVZhbHVlc0NoYW5nZWQgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGkgPSBkZXBzLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0a2V5cGF0aCA9IGRlcHNbIGkgXTtcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZSA9IHJhY3RpdmUudmlld21vZGVsLmdldCgga2V5cGF0aCApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggIWlzRXF1YWwoIHZhbHVlLCB0aGlzJDAuZGVwVmFsdWVzWyBrZXlwYXRoIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMkMC5kZXBWYWx1ZXNbIGtleXBhdGggXSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGVwZW5kZW5jeVZhbHVlc0NoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIGRlcGVuZGVuY3lWYWx1ZXNDaGFuZ2VkICkge1xuXHRcdFx0XHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwuY2FwdHVyZSgpO1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0dGhpcy52YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwoIHJhY3RpdmUgKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlcnIgKSB7XG5cdFx0XHRcdFx0XHRcdGxvZy53YXJuKCB7XG5cdFx0XHRcdFx0XHRcdFx0ZGVidWc6IHJhY3RpdmUuZGVidWcsXG5cdFx0XHRcdFx0XHRcdFx0bWVzc2FnZTogJ2ZhaWxlZENvbXB1dGF0aW9uJyxcblx0XHRcdFx0XHRcdFx0XHRhcmdzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRrZXk6IHRoaXMua2V5LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZXJyOiBlcnIubWVzc2FnZSB8fCBlcnJcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdFx0dGhpcy52YWx1ZSA9IHZvaWQgMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG5ld0RlcHMgPSByYWN0aXZlLnZpZXdtb2RlbC5yZWxlYXNlKCk7XG5cdFx0XHRcdFx0XHRkZXBlbmRlbmNpZXNDaGFuZ2VkID0gdGhpcy51cGRhdGVEZXBlbmRlbmNpZXMoIG5ld0RlcHMgKTtcblx0XHRcdFx0XHRcdGlmICggZGVwZW5kZW5jaWVzQ2hhbmdlZCApIHtcblx0XHRcdFx0XHRcdFx0W1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuaGFyZERlcHMsXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5zb2Z0RGVwc1xuXHRcdFx0XHRcdFx0XHRdLmZvckVhY2goIGZ1bmN0aW9uKCBkZXBzICkge1xuXHRcdFx0XHRcdFx0XHRcdGRlcHMuZm9yRWFjaCggZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzJDAuZGVwVmFsdWVzWyBrZXlwYXRoIF0gPSByYWN0aXZlLnZpZXdtb2RlbC5nZXQoIGtleXBhdGggKTtcblx0XHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fZGlydHkgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmdldHRpbmcgPSB0aGlzLl9maXJzdFJ1biA9IGZhbHNlO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy52YWx1ZTtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCB0aGlzLnNldHRpbmcgKSB7XG5cdFx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICF0aGlzLnNldHRlciApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdDb21wdXRlZCBwcm9wZXJ0aWVzIHdpdGhvdXQgc2V0dGVycyBhcmUgcmVhZC1vbmx5LiAoVGhpcyBtYXkgY2hhbmdlIGluIGEgZnV0dXJlIHZlcnNpb24gb2YgUmFjdGl2ZSEpJyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuc2V0dGVyLmNhbGwoIHRoaXMucmFjdGl2ZSwgdmFsdWUgKTtcblx0XHRcdH0sXG5cdFx0XHR1cGRhdGVEZXBlbmRlbmNpZXM6IGZ1bmN0aW9uKCBuZXdEZXBzICkge1xuXHRcdFx0XHR2YXIgaSwgb2xkRGVwcywga2V5cGF0aCwgZGVwZW5kZW5jaWVzQ2hhbmdlZDtcblx0XHRcdFx0b2xkRGVwcyA9IHRoaXMuc29mdERlcHM7XG5cdFx0XHRcdC8vIHJlbW92ZSBkZXBlbmRlbmNpZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIHVzZWRcblx0XHRcdFx0aSA9IG9sZERlcHMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRrZXlwYXRoID0gb2xkRGVwc1sgaSBdO1xuXHRcdFx0XHRcdGlmICggbmV3RGVwcy5pbmRleE9mKCBrZXlwYXRoICkgPT09IC0xICkge1xuXHRcdFx0XHRcdFx0ZGVwZW5kZW5jaWVzQ2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHR0aGlzLnZpZXdtb2RlbC51bnJlZ2lzdGVyKCBrZXlwYXRoLCB0aGlzLCAnY29tcHV0ZWQnICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGNyZWF0ZSByZWZlcmVuY2VzIGZvciBhbnkgbmV3IGRlcGVuZGVuY2llc1xuXHRcdFx0XHRpID0gbmV3RGVwcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGtleXBhdGggPSBuZXdEZXBzWyBpIF07XG5cdFx0XHRcdFx0aWYgKCBvbGREZXBzLmluZGV4T2YoIGtleXBhdGggKSA9PT0gLTEgJiYgKCAhdGhpcy5oYXJkRGVwcyB8fCB0aGlzLmhhcmREZXBzLmluZGV4T2YoIGtleXBhdGggKSA9PT0gLTEgKSApIHtcblx0XHRcdFx0XHRcdGRlcGVuZGVuY2llc0NoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0dGhpcy52aWV3bW9kZWwucmVnaXN0ZXIoIGtleXBhdGgsIHRoaXMsICdjb21wdXRlZCcgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBkZXBlbmRlbmNpZXNDaGFuZ2VkICkge1xuXHRcdFx0XHRcdHRoaXMuc29mdERlcHMgPSBuZXdEZXBzLnNsaWNlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGRlcGVuZGVuY2llc0NoYW5nZWQ7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gQ29tcHV0YXRpb247XG5cdH0oIGxvZywgaXNFcXVhbCApO1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvY29tcHV0ZS5qcyAqL1xuXHR2YXIgdmlld21vZGVsJGNvbXB1dGUgPSBmdW5jdGlvbiggZ2V0Q29tcHV0YXRpb25TaWduYXR1cmUsIENvbXB1dGF0aW9uICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFZpZXdtb2RlbCRjb21wdXRlKCBrZXksIHNpZ25hdHVyZSApIHtcblx0XHRcdHNpZ25hdHVyZSA9IGdldENvbXB1dGF0aW9uU2lnbmF0dXJlKCBzaWduYXR1cmUgKTtcblx0XHRcdHJldHVybiB0aGlzLmNvbXB1dGF0aW9uc1sga2V5IF0gPSBuZXcgQ29tcHV0YXRpb24oIHRoaXMucmFjdGl2ZSwga2V5LCBzaWduYXR1cmUgKTtcblx0XHR9O1xuXHR9KCBnZXRDb21wdXRhdGlvblNpZ25hdHVyZSwgQ29tcHV0YXRpb24gKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2dldC9GQUlMRURfTE9PS1VQLmpzICovXG5cdHZhciB2aWV3bW9kZWwkZ2V0X0ZBSUxFRF9MT09LVVAgPSB7XG5cdFx0RkFJTEVEX0xPT0tVUDogdHJ1ZVxuXHR9O1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvZ2V0L1VucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY3kuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRnZXRfVW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeSA9IGZ1bmN0aW9uKCByZW1vdmVGcm9tQXJyYXksIHJ1bmxvb3AgKSB7XG5cblx0XHR2YXIgZW1wdHkgPSB7fTtcblx0XHR2YXIgVW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeSA9IGZ1bmN0aW9uKCB2aWV3bW9kZWwsIGtleXBhdGggKSB7XG5cdFx0XHR0aGlzLnZpZXdtb2RlbCA9IHZpZXdtb2RlbDtcblx0XHRcdHRoaXMucm9vdCA9IHZpZXdtb2RlbC5yYWN0aXZlO1xuXHRcdFx0Ly8gVE9ETyBlbGltaW5hdGUgdGhpc1xuXHRcdFx0dGhpcy5yZWYgPSBrZXlwYXRoO1xuXHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IGVtcHR5O1xuXHRcdFx0dmlld21vZGVsLnVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY2llc1sga2V5cGF0aCBdID0gdHJ1ZTtcblx0XHRcdHZpZXdtb2RlbC51bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmNpZXMucHVzaCggdGhpcyApO1xuXHRcdFx0cnVubG9vcC5hZGRVbnJlc29sdmVkKCB0aGlzICk7XG5cdFx0fTtcblx0XHRVbnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmN5LnByb3RvdHlwZSA9IHtcblx0XHRcdHJlc29sdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnZpZXdtb2RlbC5tYXJrKCB0aGlzLnJlZiApO1xuXHRcdFx0XHR0aGlzLnZpZXdtb2RlbC51bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmNpZXNbIHRoaXMucmVmIF0gPSBmYWxzZTtcblx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCB0aGlzLnZpZXdtb2RlbC51bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmNpZXMsIHRoaXMgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJ1bmxvb3AucmVtb3ZlVW5yZXNvbHZlZCggdGhpcyApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIFVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY3k7XG5cdH0oIHJlbW92ZUZyb21BcnJheSwgcnVubG9vcCApO1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvZ2V0LmpzICovXG5cdHZhciB2aWV3bW9kZWwkZ2V0ID0gZnVuY3Rpb24oIGlzTnVtZXJpYywgRkFJTEVEX0xPT0tVUCwgVW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeSApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgZW1wdHkgPSB7fTtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIFZpZXdtb2RlbCRnZXQoIGtleXBhdGggKSB7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IGFyZ3VtZW50c1sgMSBdO1xuXHRcdFx0aWYgKCBvcHRpb25zID09PSB2b2lkIDAgKVxuXHRcdFx0XHRvcHRpb25zID0gZW1wdHk7XG5cdFx0XHR2YXIgcmFjdGl2ZSA9IHRoaXMucmFjdGl2ZSxcblx0XHRcdFx0Y2FjaGUgPSB0aGlzLmNhY2hlLFxuXHRcdFx0XHR2YWx1ZSwgY29tcHV0YXRpb24sIHdyYXBwZWQsIGNhcHR1cmVHcm91cDtcblx0XHRcdGlmICgga2V5cGF0aFsgMCBdID09PSAnQCcgKSB7XG5cdFx0XHRcdHZhbHVlID0ga2V5cGF0aC5zbGljZSggMSApO1xuXHRcdFx0XHRyZXR1cm4gaXNOdW1lcmljKCB2YWx1ZSApID8gK3ZhbHVlIDogdmFsdWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGNhY2hlWyBrZXlwYXRoIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0Ly8gSXMgdGhpcyBhIGNvbXB1dGVkIHByb3BlcnR5P1xuXHRcdFx0XHRpZiAoICggY29tcHV0YXRpb24gPSB0aGlzLmNvbXB1dGF0aW9uc1sga2V5cGF0aCBdICkgJiYgIWNvbXB1dGF0aW9uLmJ5cGFzcyApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGNvbXB1dGF0aW9uLmdldCgpO1xuXHRcdFx0XHRcdHRoaXMuYWRhcHQoIGtleXBhdGgsIHZhbHVlICk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIHdyYXBwZWQgPSB0aGlzLndyYXBwZWRbIGtleXBhdGggXSApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHdyYXBwZWQudmFsdWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAoICFrZXlwYXRoICkge1xuXHRcdFx0XHRcdHRoaXMuYWRhcHQoICcnLCByYWN0aXZlLmRhdGEgKTtcblx0XHRcdFx0XHR2YWx1ZSA9IHJhY3RpdmUuZGF0YTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHJldHJpZXZlKCB0aGlzLCBrZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FjaGVbIGtleXBhdGggXSA9IHZhbHVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsdWUgPSBjYWNoZVsga2V5cGF0aCBdO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvcHRpb25zLmV2YWx1YXRlV3JhcHBlZCAmJiAoIHdyYXBwZWQgPSB0aGlzLndyYXBwZWRbIGtleXBhdGggXSApICkge1xuXHRcdFx0XHR2YWx1ZSA9IHdyYXBwZWQuZ2V0KCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBjYXB0dXJlIHRoZSBrZXlwYXRoLCBpZiB3ZSdyZSBpbnNpZGUgYSBjb21wdXRhdGlvblxuXHRcdFx0aWYgKCBvcHRpb25zLmNhcHR1cmUgJiYgKCBjYXB0dXJlR3JvdXAgPSB0aGlzLmNhcHR1cmVHcm91cHNbIHRoaXMuY2FwdHVyZUdyb3Vwcy5sZW5ndGggLSAxIF0gKSApIHtcblx0XHRcdFx0aWYgKCAhfmNhcHR1cmVHcm91cC5pbmRleE9mKCBrZXlwYXRoICkgKSB7XG5cdFx0XHRcdFx0Y2FwdHVyZUdyb3VwLnB1c2goIGtleXBhdGggKTtcblx0XHRcdFx0XHQvLyBpZiB3ZSBjb3VsZG4ndCByZXNvbHZlIHRoZSBrZXlwYXRoLCB3ZSBuZWVkIHRvIG1ha2UgaXQgYXMgYSBmYWlsZWRcblx0XHRcdFx0XHQvLyBsb29rdXAsIHNvIHRoYXQgdGhlIGNvbXB1dGF0aW9uIHVwZGF0ZXMgY29ycmVjdGx5IG9uY2Ugd2UgQ0FOXG5cdFx0XHRcdFx0Ly8gcmVzb2x2ZSB0aGUga2V5cGF0aFxuXHRcdFx0XHRcdGlmICggdmFsdWUgPT09IEZBSUxFRF9MT09LVVAgJiYgdGhpcy51bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmNpZXNbIGtleXBhdGggXSAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdG5ldyBVbnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmN5KCB0aGlzLCBrZXlwYXRoICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IEZBSUxFRF9MT09LVVAgPyB2b2lkIDAgOiB2YWx1ZTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcmV0cmlldmUoIHZpZXdtb2RlbCwga2V5cGF0aCApIHtcblx0XHRcdHZhciBrZXlzLCBrZXksIHBhcmVudEtleXBhdGgsIHBhcmVudFZhbHVlLCBjYWNoZU1hcCwgdmFsdWUsIHdyYXBwZWQ7XG5cdFx0XHRrZXlzID0ga2V5cGF0aC5zcGxpdCggJy4nICk7XG5cdFx0XHRrZXkgPSBrZXlzLnBvcCgpO1xuXHRcdFx0cGFyZW50S2V5cGF0aCA9IGtleXMuam9pbiggJy4nICk7XG5cdFx0XHRwYXJlbnRWYWx1ZSA9IHZpZXdtb2RlbC5nZXQoIHBhcmVudEtleXBhdGggKTtcblx0XHRcdGlmICggd3JhcHBlZCA9IHZpZXdtb2RlbC53cmFwcGVkWyBwYXJlbnRLZXlwYXRoIF0gKSB7XG5cdFx0XHRcdHBhcmVudFZhbHVlID0gd3JhcHBlZC5nZXQoKTtcblx0XHRcdH1cblx0XHRcdGlmICggcGFyZW50VmFsdWUgPT09IG51bGwgfHwgcGFyZW50VmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Ly8gdXBkYXRlIGNhY2hlIG1hcFxuXHRcdFx0aWYgKCAhKCBjYWNoZU1hcCA9IHZpZXdtb2RlbC5jYWNoZU1hcFsgcGFyZW50S2V5cGF0aCBdICkgKSB7XG5cdFx0XHRcdHZpZXdtb2RlbC5jYWNoZU1hcFsgcGFyZW50S2V5cGF0aCBdID0gWyBrZXlwYXRoIF07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIGNhY2hlTWFwLmluZGV4T2YoIGtleXBhdGggKSA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0Y2FjaGVNYXAucHVzaCgga2V5cGF0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBJZiB0aGlzIHByb3BlcnR5IGRvZXNuJ3QgZXhpc3QsIHdlIHJldHVybiBhIHNlbnRpbmVsIHZhbHVlXG5cdFx0XHQvLyBzbyB0aGF0IHdlIGtub3cgdG8gcXVlcnkgcGFyZW50IHNjb3BlIChpZiBzdWNoIHRoZXJlIGJlKVxuXHRcdFx0aWYgKCB0eXBlb2YgcGFyZW50VmFsdWUgPT09ICdvYmplY3QnICYmICEoIGtleSBpbiBwYXJlbnRWYWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gdmlld21vZGVsLmNhY2hlWyBrZXlwYXRoIF0gPSBGQUlMRURfTE9PS1VQO1xuXHRcdFx0fVxuXHRcdFx0dmFsdWUgPSBwYXJlbnRWYWx1ZVsga2V5IF07XG5cdFx0XHQvLyBEbyB3ZSBoYXZlIGFuIGFkYXB0b3IgZm9yIHRoaXMgdmFsdWU/XG5cdFx0XHR2aWV3bW9kZWwuYWRhcHQoIGtleXBhdGgsIHZhbHVlLCBmYWxzZSApO1xuXHRcdFx0Ly8gVXBkYXRlIGNhY2hlXG5cdFx0XHR2aWV3bW9kZWwuY2FjaGVbIGtleXBhdGggXSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIGlzTnVtZXJpYywgdmlld21vZGVsJGdldF9GQUlMRURfTE9PS1VQLCB2aWV3bW9kZWwkZ2V0X1VucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY3kgKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2luaXQuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRpbml0ID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBWaWV3bW9kZWwkaW5pdCgpIHtcblx0XHRcdHZhciBrZXksIGNvbXB1dGF0aW9uLCBjb21wdXRhdGlvbnMgPSBbXTtcblx0XHRcdGZvciAoIGtleSBpbiB0aGlzLnJhY3RpdmUuY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGNvbXB1dGF0aW9uID0gdGhpcy5jb21wdXRlKCBrZXksIHRoaXMucmFjdGl2ZS5jb21wdXRlZFsga2V5IF0gKTtcblx0XHRcdFx0Y29tcHV0YXRpb25zLnB1c2goIGNvbXB1dGF0aW9uICk7XG5cdFx0XHR9XG5cdFx0XHRjb21wdXRhdGlvbnMuZm9yRWFjaCggaW5pdCApO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBpbml0KCBjb21wdXRhdGlvbiApIHtcblx0XHRcdGNvbXB1dGF0aW9uLmluaXQoKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9tYXJrLmpzICovXG5cdHZhciB2aWV3bW9kZWwkbWFyayA9IGZ1bmN0aW9uIFZpZXdtb2RlbCRtYXJrKCBrZXlwYXRoLCBvcHRpb25zICkge1xuXHRcdHZhciBjb21wdXRhdGlvbjtcblx0XHQvLyBpbXBsaWNpdCBjaGFuZ2VzIChpLmUuIGBmb28ubGVuZ3RoYCBvbiBgcmFjdGl2ZS5wdXNoKCdmb28nLDQyKWApXG5cdFx0Ly8gc2hvdWxkIG5vdCBiZSBwaWNrZWQgdXAgYnkgcGF0dGVybiBvYnNlcnZlcnNcblx0XHRpZiAoIG9wdGlvbnMgKSB7XG5cdFx0XHRpZiAoIG9wdGlvbnMuaW1wbGljaXQgKSB7XG5cdFx0XHRcdHRoaXMuaW1wbGljaXRDaGFuZ2VzWyBrZXlwYXRoIF0gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvcHRpb25zLm5vQ2FzY2FkZSApIHtcblx0XHRcdFx0dGhpcy5ub0Nhc2NhZGVbIGtleXBhdGggXSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICggY29tcHV0YXRpb24gPSB0aGlzLmNvbXB1dGF0aW9uc1sga2V5cGF0aCBdICkge1xuXHRcdFx0Y29tcHV0YXRpb24uaW52YWxpZGF0ZSgpO1xuXHRcdH1cblx0XHRpZiAoIHRoaXMuY2hhbmdlcy5pbmRleE9mKCBrZXlwYXRoICkgPT09IC0xICkge1xuXHRcdFx0dGhpcy5jaGFuZ2VzLnB1c2goIGtleXBhdGggKTtcblx0XHR9XG5cdFx0dGhpcy5jbGVhckNhY2hlKCBrZXlwYXRoICk7XG5cdH07XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9tZXJnZS9tYXBPbGRUb05ld0luZGV4LmpzICovXG5cdHZhciB2aWV3bW9kZWwkbWVyZ2VfbWFwT2xkVG9OZXdJbmRleCA9IGZ1bmN0aW9uKCBvbGRBcnJheSwgbmV3QXJyYXkgKSB7XG5cdFx0dmFyIHVzZWRJbmRpY2VzLCBmaXJzdFVudXNlZEluZGV4LCBuZXdJbmRpY2VzLCBjaGFuZ2VkO1xuXHRcdHVzZWRJbmRpY2VzID0ge307XG5cdFx0Zmlyc3RVbnVzZWRJbmRleCA9IDA7XG5cdFx0bmV3SW5kaWNlcyA9IG9sZEFycmF5Lm1hcCggZnVuY3Rpb24oIGl0ZW0sIGkgKSB7XG5cdFx0XHR2YXIgaW5kZXgsIHN0YXJ0LCBsZW47XG5cdFx0XHRzdGFydCA9IGZpcnN0VW51c2VkSW5kZXg7XG5cdFx0XHRsZW4gPSBuZXdBcnJheS5sZW5ndGg7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGluZGV4ID0gbmV3QXJyYXkuaW5kZXhPZiggaXRlbSwgc3RhcnQgKTtcblx0XHRcdFx0aWYgKCBpbmRleCA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0YXJ0ID0gaW5kZXggKyAxO1xuXHRcdFx0fSB3aGlsZSAoIHVzZWRJbmRpY2VzWyBpbmRleCBdICYmIHN0YXJ0IDwgbGVuICk7XG5cdFx0XHQvLyBrZWVwIHRyYWNrIG9mIHRoZSBmaXJzdCB1bnVzZWQgaW5kZXgsIHNvIHdlIGRvbid0IHNlYXJjaFxuXHRcdFx0Ly8gdGhlIHdob2xlIG9mIG5ld0FycmF5IGZvciBlYWNoIGl0ZW0gaW4gb2xkQXJyYXkgdW5uZWNlc3NhcmlseVxuXHRcdFx0aWYgKCBpbmRleCA9PT0gZmlyc3RVbnVzZWRJbmRleCApIHtcblx0XHRcdFx0Zmlyc3RVbnVzZWRJbmRleCArPSAxO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBpbmRleCAhPT0gaSApIHtcblx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHR1c2VkSW5kaWNlc1sgaW5kZXggXSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gaW5kZXg7XG5cdFx0fSApO1xuXHRcdHJldHVybiBuZXdJbmRpY2VzO1xuXHR9O1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvbWVyZ2UuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRtZXJnZSA9IGZ1bmN0aW9uKCB3YXJuLCBtYXBPbGRUb05ld0luZGV4ICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBjb21wYXJhdG9ycyA9IHt9O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gVmlld21vZGVsJG1lcmdlKCBrZXlwYXRoLCBjdXJyZW50QXJyYXksIGFycmF5LCBvcHRpb25zICkge1xuXHRcdFx0dmFyIG9sZEFycmF5LCBuZXdBcnJheSwgY29tcGFyYXRvciwgbmV3SW5kaWNlcztcblx0XHRcdHRoaXMubWFyaygga2V5cGF0aCApO1xuXHRcdFx0aWYgKCBvcHRpb25zICYmIG9wdGlvbnMuY29tcGFyZSApIHtcblx0XHRcdFx0Y29tcGFyYXRvciA9IGdldENvbXBhcmF0b3JGdW5jdGlvbiggb3B0aW9ucy5jb21wYXJlICk7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0b2xkQXJyYXkgPSBjdXJyZW50QXJyYXkubWFwKCBjb21wYXJhdG9yICk7XG5cdFx0XHRcdFx0bmV3QXJyYXkgPSBhcnJheS5tYXAoIGNvbXBhcmF0b3IgKTtcblx0XHRcdFx0fSBjYXRjaCAoIGVyciApIHtcblx0XHRcdFx0XHQvLyBmYWxsYmFjayB0byBhbiBpZGVudGl0eSBjaGVjayAtIHdvcnN0IGNhc2Ugc2NlbmFyaW8gd2UgaGF2ZVxuXHRcdFx0XHRcdC8vIHRvIGRvIG1vcmUgRE9NIG1hbmlwdWxhdGlvbiB0aGFuIHdlIHRob3VnaHQuLi5cblx0XHRcdFx0XHQvLyAuLi51bmxlc3Mgd2UncmUgaW4gZGVidWcgbW9kZSBvZiBjb3Vyc2Vcblx0XHRcdFx0XHRpZiAoIHRoaXMuZGVidWcgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBlcnI7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHdhcm4oICdNZXJnZSBvcGVyYXRpb246IGNvbXBhcmlzb24gZmFpbGVkLiBGYWxsaW5nIGJhY2sgdG8gaWRlbnRpdHkgY2hlY2tpbmcnICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG9sZEFycmF5ID0gY3VycmVudEFycmF5O1xuXHRcdFx0XHRcdG5ld0FycmF5ID0gYXJyYXk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9sZEFycmF5ID0gY3VycmVudEFycmF5O1xuXHRcdFx0XHRuZXdBcnJheSA9IGFycmF5O1xuXHRcdFx0fVxuXHRcdFx0Ly8gZmluZCBuZXcgaW5kaWNlcyBmb3IgbWVtYmVycyBvZiBvbGRBcnJheVxuXHRcdFx0bmV3SW5kaWNlcyA9IG1hcE9sZFRvTmV3SW5kZXgoIG9sZEFycmF5LCBuZXdBcnJheSApO1xuXHRcdFx0dGhpcy5zbWFydFVwZGF0ZSgga2V5cGF0aCwgYXJyYXksIG5ld0luZGljZXMsIGN1cnJlbnRBcnJheS5sZW5ndGggIT09IGFycmF5Lmxlbmd0aCApO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBzdHJpbmdpZnkoIGl0ZW0gKSB7XG5cdFx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkoIGl0ZW0gKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRDb21wYXJhdG9yRnVuY3Rpb24oIGNvbXBhcmF0b3IgKSB7XG5cdFx0XHQvLyBJZiBgY29tcGFyZWAgaXMgYHRydWVgLCB3ZSB1c2UgSlNPTi5zdHJpbmdpZnkgdG8gY29tcGFyZVxuXHRcdFx0Ly8gb2JqZWN0cyB0aGF0IGFyZSB0aGUgc2FtZSBzaGFwZSwgYnV0IG5vbi1pZGVudGljYWwgLSBpLmUuXG5cdFx0XHQvLyB7IGZvbzogJ2JhcicgfSAhPT0geyBmb286ICdiYXInIH1cblx0XHRcdGlmICggY29tcGFyYXRvciA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeTtcblx0XHRcdH1cblx0XHRcdGlmICggdHlwZW9mIGNvbXBhcmF0b3IgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRpZiAoICFjb21wYXJhdG9yc1sgY29tcGFyYXRvciBdICkge1xuXHRcdFx0XHRcdGNvbXBhcmF0b3JzWyBjb21wYXJhdG9yIF0gPSBmdW5jdGlvbiggaXRlbSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBpdGVtWyBjb21wYXJhdG9yIF07XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gY29tcGFyYXRvcnNbIGNvbXBhcmF0b3IgXTtcblx0XHRcdH1cblx0XHRcdGlmICggdHlwZW9mIGNvbXBhcmF0b3IgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdHJldHVybiBjb21wYXJhdG9yO1xuXHRcdFx0fVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVGhlIGBjb21wYXJlYCBvcHRpb24gbXVzdCBiZSBhIGZ1bmN0aW9uLCBvciBhIHN0cmluZyByZXByZXNlbnRpbmcgYW4gaWRlbnRpZnlpbmcgZmllbGQgKG9yIGB0cnVlYCB0byB1c2UgSlNPTi5zdHJpbmdpZnkpJyApO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIHdhcm4sIHZpZXdtb2RlbCRtZXJnZV9tYXBPbGRUb05ld0luZGV4ICk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9yZWdpc3Rlci5qcyAqL1xuXHR2YXIgdmlld21vZGVsJHJlZ2lzdGVyID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBWaWV3bW9kZWwkcmVnaXN0ZXIoIGtleXBhdGgsIGRlcGVuZGFudCApIHtcblx0XHRcdHZhciBncm91cCA9IGFyZ3VtZW50c1sgMiBdO1xuXHRcdFx0aWYgKCBncm91cCA9PT0gdm9pZCAwIClcblx0XHRcdFx0Z3JvdXAgPSAnZGVmYXVsdCc7XG5cdFx0XHR2YXIgZGVwc0J5S2V5cGF0aCwgZGVwcztcblx0XHRcdGlmICggZGVwZW5kYW50LmlzU3RhdGljICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRkZXBzQnlLZXlwYXRoID0gdGhpcy5kZXBzWyBncm91cCBdIHx8ICggdGhpcy5kZXBzWyBncm91cCBdID0ge30gKTtcblx0XHRcdGRlcHMgPSBkZXBzQnlLZXlwYXRoWyBrZXlwYXRoIF0gfHwgKCBkZXBzQnlLZXlwYXRoWyBrZXlwYXRoIF0gPSBbXSApO1xuXHRcdFx0ZGVwcy5wdXNoKCBkZXBlbmRhbnQgKTtcblx0XHRcdGlmICggIWtleXBhdGggKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHVwZGF0ZURlcGVuZGFudHNNYXAoIHRoaXMsIGtleXBhdGgsIGdyb3VwICk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHVwZGF0ZURlcGVuZGFudHNNYXAoIHZpZXdtb2RlbCwga2V5cGF0aCwgZ3JvdXAgKSB7XG5cdFx0XHR2YXIga2V5cywgcGFyZW50S2V5cGF0aCwgbWFwLCBwYXJlbnQ7XG5cdFx0XHQvLyB1cGRhdGUgZGVwZW5kYW50cyBtYXBcblx0XHRcdGtleXMgPSBrZXlwYXRoLnNwbGl0KCAnLicgKTtcblx0XHRcdHdoaWxlICgga2V5cy5sZW5ndGggKSB7XG5cdFx0XHRcdGtleXMucG9wKCk7XG5cdFx0XHRcdHBhcmVudEtleXBhdGggPSBrZXlzLmpvaW4oICcuJyApO1xuXHRcdFx0XHRtYXAgPSB2aWV3bW9kZWwuZGVwc01hcFsgZ3JvdXAgXSB8fCAoIHZpZXdtb2RlbC5kZXBzTWFwWyBncm91cCBdID0ge30gKTtcblx0XHRcdFx0cGFyZW50ID0gbWFwWyBwYXJlbnRLZXlwYXRoIF0gfHwgKCBtYXBbIHBhcmVudEtleXBhdGggXSA9IFtdICk7XG5cdFx0XHRcdGlmICggcGFyZW50WyBrZXlwYXRoIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRwYXJlbnRbIGtleXBhdGggXSA9IDA7XG5cdFx0XHRcdFx0cGFyZW50LnB1c2goIGtleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwYXJlbnRbIGtleXBhdGggXSArPSAxO1xuXHRcdFx0XHRrZXlwYXRoID0gcGFyZW50S2V5cGF0aDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9yZWxlYXNlLmpzICovXG5cdHZhciB2aWV3bW9kZWwkcmVsZWFzZSA9IGZ1bmN0aW9uIFZpZXdtb2RlbCRyZWxlYXNlKCkge1xuXHRcdHJldHVybiB0aGlzLmNhcHR1cmVHcm91cHMucG9wKCk7XG5cdH07XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9zZXQuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRzZXQgPSBmdW5jdGlvbiggaXNFcXVhbCwgY3JlYXRlQnJhbmNoICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gVmlld21vZGVsJHNldCgga2V5cGF0aCwgdmFsdWUsIHNpbGVudCApIHtcblx0XHRcdHZhciBjb21wdXRhdGlvbiwgd3JhcHBlciwgZG9udFRlYXJkb3duV3JhcHBlcjtcblx0XHRcdGNvbXB1dGF0aW9uID0gdGhpcy5jb21wdXRhdGlvbnNbIGtleXBhdGggXTtcblx0XHRcdGlmICggY29tcHV0YXRpb24gKSB7XG5cdFx0XHRcdGlmICggY29tcHV0YXRpb24uc2V0dGluZyApIHtcblx0XHRcdFx0XHQvLyBsZXQgdGhlIG90aGVyIGNvbXB1dGF0aW9uIHNldCgpIGhhbmRsZSB0aGluZ3MuLi5cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29tcHV0YXRpb24uc2V0KCB2YWx1ZSApO1xuXHRcdFx0XHR2YWx1ZSA9IGNvbXB1dGF0aW9uLmdldCgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBpc0VxdWFsKCB0aGlzLmNhY2hlWyBrZXlwYXRoIF0sIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHdyYXBwZXIgPSB0aGlzLndyYXBwZWRbIGtleXBhdGggXTtcblx0XHRcdC8vIElmIHdlIGhhdmUgYSB3cmFwcGVyIHdpdGggYSBgcmVzZXQoKWAgbWV0aG9kLCB3ZSB0cnkgYW5kIHVzZSBpdC4gSWYgdGhlXG5cdFx0XHQvLyBgcmVzZXQoKWAgbWV0aG9kIHJldHVybnMgZmFsc2UsIHRoZSB3cmFwcGVyIHNob3VsZCBiZSB0b3JuIGRvd24sIGFuZFxuXHRcdFx0Ly8gKG1vc3QgbGlrZWx5KSBhIG5ldyBvbmUgc2hvdWxkIGJlIGNyZWF0ZWQgbGF0ZXJcblx0XHRcdGlmICggd3JhcHBlciAmJiB3cmFwcGVyLnJlc2V0ICkge1xuXHRcdFx0XHRkb250VGVhcmRvd25XcmFwcGVyID0gd3JhcHBlci5yZXNldCggdmFsdWUgKSAhPT0gZmFsc2U7XG5cdFx0XHRcdGlmICggZG9udFRlYXJkb3duV3JhcHBlciApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHdyYXBwZXIuZ2V0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggIWNvbXB1dGF0aW9uICYmICFkb250VGVhcmRvd25XcmFwcGVyICkge1xuXHRcdFx0XHRyZXNvbHZlU2V0KCB0aGlzLCBrZXlwYXRoLCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhc2lsZW50ICkge1xuXHRcdFx0XHR0aGlzLm1hcmsoIGtleXBhdGggKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFdlJ3JlIHNldHRpbmcgYSBwYXJlbnQgb2YgdGhlIG9yaWdpbmFsIHRhcmdldCBrZXlwYXRoIChpLmUuXG5cdFx0XHRcdC8vIGNyZWF0aW5nIGEgZnJlc2ggYnJhbmNoKSAtIHdlIG5lZWQgdG8gY2xlYXIgdGhlIGNhY2hlLCBidXRcblx0XHRcdFx0Ly8gbm90IG1hcmsgaXQgYXMgYSBjaGFuZ2Vcblx0XHRcdFx0dGhpcy5jbGVhckNhY2hlKCBrZXlwYXRoICk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHJlc29sdmVTZXQoIHZpZXdtb2RlbCwga2V5cGF0aCwgdmFsdWUgKSB7XG5cdFx0XHR2YXIga2V5cywgbGFzdEtleSwgcGFyZW50S2V5cGF0aCwgd3JhcHBlciwgcGFyZW50VmFsdWUsIHdyYXBwZXJTZXQsIHZhbHVlU2V0O1xuXHRcdFx0d3JhcHBlclNldCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHdyYXBwZXIuc2V0ICkge1xuXHRcdFx0XHRcdHdyYXBwZXIuc2V0KCBsYXN0S2V5LCB2YWx1ZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHBhcmVudFZhbHVlID0gd3JhcHBlci5nZXQoKTtcblx0XHRcdFx0XHR2YWx1ZVNldCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0dmFsdWVTZXQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhcGFyZW50VmFsdWUgKSB7XG5cdFx0XHRcdFx0cGFyZW50VmFsdWUgPSBjcmVhdGVCcmFuY2goIGxhc3RLZXkgKTtcblx0XHRcdFx0XHR2aWV3bW9kZWwuc2V0KCBwYXJlbnRLZXlwYXRoLCBwYXJlbnRWYWx1ZSwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBhcmVudFZhbHVlWyBsYXN0S2V5IF0gPSB2YWx1ZTtcblx0XHRcdH07XG5cdFx0XHRrZXlzID0ga2V5cGF0aC5zcGxpdCggJy4nICk7XG5cdFx0XHRsYXN0S2V5ID0ga2V5cy5wb3AoKTtcblx0XHRcdHBhcmVudEtleXBhdGggPSBrZXlzLmpvaW4oICcuJyApO1xuXHRcdFx0d3JhcHBlciA9IHZpZXdtb2RlbC53cmFwcGVkWyBwYXJlbnRLZXlwYXRoIF07XG5cdFx0XHRpZiAoIHdyYXBwZXIgKSB7XG5cdFx0XHRcdHdyYXBwZXJTZXQoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhcmVudFZhbHVlID0gdmlld21vZGVsLmdldCggcGFyZW50S2V5cGF0aCApO1xuXHRcdFx0XHQvLyBtYXkgaGF2ZSBiZWVuIHdyYXBwZWQgdmlhIHRoZSBhYm92ZSAuZ2V0KClcblx0XHRcdFx0Ly8gY2FsbCBvbiB2aWV3bW9kZWwgaWYgdGhpcyBpcyBmaXJzdCBhY2Nlc3MgdmlhIC5zZXQoKSFcblx0XHRcdFx0aWYgKCB3cmFwcGVyID0gdmlld21vZGVsLndyYXBwZWRbIHBhcmVudEtleXBhdGggXSApIHtcblx0XHRcdFx0XHR3cmFwcGVyU2V0KCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFsdWVTZXQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIGlzRXF1YWwsIGNyZWF0ZUJyYW5jaCApO1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvc21hcnRVcGRhdGUuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRzbWFydFVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBpbXBsaWNpdE9wdGlvbiA9IHtcblx0XHRcdFx0aW1wbGljaXQ6IHRydWVcblx0XHRcdH0sXG5cdFx0XHRub0Nhc2NhZGVPcHRpb24gPSB7XG5cdFx0XHRcdG5vQ2FzY2FkZTogdHJ1ZVxuXHRcdFx0fTtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIFZpZXdtb2RlbCRzbWFydFVwZGF0ZSgga2V5cGF0aCwgYXJyYXksIG5ld0luZGljZXMgKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdHZhciBkZXBlbmRhbnRzLCBvbGRMZW5ndGg7XG5cdFx0XHRvbGRMZW5ndGggPSBuZXdJbmRpY2VzLmxlbmd0aDtcblx0XHRcdC8vIEluZGljZXMgdGhhdCBhcmUgYmVpbmcgcmVtb3ZlZCBzaG91bGQgYmUgbWFya2VkIGFzIGRpcnR5XG5cdFx0XHRuZXdJbmRpY2VzLmZvckVhY2goIGZ1bmN0aW9uKCBuZXdJbmRleCwgb2xkSW5kZXggKSB7XG5cdFx0XHRcdGlmICggbmV3SW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRcdHRoaXMkMC5tYXJrKCBrZXlwYXRoICsgJy4nICsgb2xkSW5kZXgsIG5vQ2FzY2FkZU9wdGlvbiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0XHQvLyBVcGRhdGUgdGhlIG1vZGVsXG5cdFx0XHQvLyBUT0RPIGFsbG93IGV4aXN0aW5nIGFycmF5IHRvIGJlIHVwZGF0ZWQgaW4gcGxhY2UsIHJhdGhlciB0aGFuIHJlcGxhY2VkP1xuXHRcdFx0dGhpcy5zZXQoIGtleXBhdGgsIGFycmF5LCB0cnVlICk7XG5cdFx0XHRpZiAoIGRlcGVuZGFudHMgPSB0aGlzLmRlcHNbICdkZWZhdWx0JyBdWyBrZXlwYXRoIF0gKSB7XG5cdFx0XHRcdGRlcGVuZGFudHMuZmlsdGVyKCBjYW5TaHVmZmxlICkuZm9yRWFjaCggZnVuY3Rpb24oIGQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGQuc2h1ZmZsZSggbmV3SW5kaWNlcywgYXJyYXkgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvbGRMZW5ndGggIT09IGFycmF5Lmxlbmd0aCApIHtcblx0XHRcdFx0dGhpcy5tYXJrKCBrZXlwYXRoICsgJy5sZW5ndGgnLCBpbXBsaWNpdE9wdGlvbiApO1xuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IG9sZExlbmd0aDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSAxICkge1xuXHRcdFx0XHRcdHRoaXMubWFyaygga2V5cGF0aCArICcuJyArIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBkb24ndCBhbGxvdyByZW1vdmVkIGluZGV4ZXMgYmV5b25kIGVuZCBvZiBuZXcgYXJyYXkgdG8gdHJpZ2dlciByZWNvbXB1dGF0aW9uc1xuXHRcdFx0XHRmb3IgKCB2YXIgaSQwID0gYXJyYXkubGVuZ3RoOyBpJDAgPCBvbGRMZW5ndGg7IGkkMCArPSAxICkge1xuXHRcdFx0XHRcdHRoaXMubWFyaygga2V5cGF0aCArICcuJyArIGkkMCwgbm9DYXNjYWRlT3B0aW9uICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gY2FuU2h1ZmZsZSggZGVwZW5kYW50ICkge1xuXHRcdFx0cmV0dXJuIHR5cGVvZiBkZXBlbmRhbnQuc2h1ZmZsZSA9PT0gJ2Z1bmN0aW9uJztcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS90ZWFyZG93bi5qcyAqL1xuXHR2YXIgdmlld21vZGVsJHRlYXJkb3duID0gZnVuY3Rpb24gVmlld21vZGVsJHRlYXJkb3duKCkge1xuXHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdHZhciB1bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmN5O1xuXHRcdC8vIENsZWFyIGVudGlyZSBjYWNoZSAtIHRoaXMgaGFzIHRoZSBkZXNpcmVkIHNpZGUtZWZmZWN0XG5cdFx0Ly8gb2YgdW53cmFwcGluZyBhZGFwdGVkIHZhbHVlcyAoZS5nLiBhcnJheXMpXG5cdFx0T2JqZWN0LmtleXMoIHRoaXMuY2FjaGUgKS5mb3JFYWNoKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdHJldHVybiB0aGlzJDAuY2xlYXJDYWNoZSgga2V5cGF0aCApO1xuXHRcdH0gKTtcblx0XHQvLyBUZWFyZG93biBhbnkgZmFpbGVkIGxvb2t1cHMgLSB3ZSBkb24ndCBuZWVkIHRoZW0gdG8gcmVzb2x2ZSBhbnkgbW9yZVxuXHRcdHdoaWxlICggdW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeSA9IHRoaXMudW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jaWVzLnBvcCgpICkge1xuXHRcdFx0dW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeS50ZWFyZG93bigpO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL3VucmVnaXN0ZXIuanMgKi9cblx0dmFyIHZpZXdtb2RlbCR1bnJlZ2lzdGVyID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBWaWV3bW9kZWwkdW5yZWdpc3Rlcigga2V5cGF0aCwgZGVwZW5kYW50ICkge1xuXHRcdFx0dmFyIGdyb3VwID0gYXJndW1lbnRzWyAyIF07XG5cdFx0XHRpZiAoIGdyb3VwID09PSB2b2lkIDAgKVxuXHRcdFx0XHRncm91cCA9ICdkZWZhdWx0Jztcblx0XHRcdHZhciBkZXBzLCBpbmRleDtcblx0XHRcdGlmICggZGVwZW5kYW50LmlzU3RhdGljICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRkZXBzID0gdGhpcy5kZXBzWyBncm91cCBdWyBrZXlwYXRoIF07XG5cdFx0XHRpbmRleCA9IGRlcHMuaW5kZXhPZiggZGVwZW5kYW50ICk7XG5cdFx0XHRpZiAoIGluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQXR0ZW1wdGVkIHRvIHJlbW92ZSBhIGRlcGVuZGFudCB0aGF0IHdhcyBubyBsb25nZXIgcmVnaXN0ZXJlZCEgVGhpcyBzaG91bGQgbm90IGhhcHBlbi4gSWYgeW91IGFyZSBzZWVpbmcgdGhpcyBidWcgaW4gZGV2ZWxvcG1lbnQgcGxlYXNlIHJhaXNlIGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9SYWN0aXZlSlMvUmFjdGl2ZS9pc3N1ZXMgLSB0aGFua3MnICk7XG5cdFx0XHR9XG5cdFx0XHRkZXBzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdGlmICggIWtleXBhdGggKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHVwZGF0ZURlcGVuZGFudHNNYXAoIHRoaXMsIGtleXBhdGgsIGdyb3VwICk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHVwZGF0ZURlcGVuZGFudHNNYXAoIHZpZXdtb2RlbCwga2V5cGF0aCwgZ3JvdXAgKSB7XG5cdFx0XHR2YXIga2V5cywgcGFyZW50S2V5cGF0aCwgbWFwLCBwYXJlbnQ7XG5cdFx0XHQvLyB1cGRhdGUgZGVwZW5kYW50cyBtYXBcblx0XHRcdGtleXMgPSBrZXlwYXRoLnNwbGl0KCAnLicgKTtcblx0XHRcdHdoaWxlICgga2V5cy5sZW5ndGggKSB7XG5cdFx0XHRcdGtleXMucG9wKCk7XG5cdFx0XHRcdHBhcmVudEtleXBhdGggPSBrZXlzLmpvaW4oICcuJyApO1xuXHRcdFx0XHRtYXAgPSB2aWV3bW9kZWwuZGVwc01hcFsgZ3JvdXAgXTtcblx0XHRcdFx0cGFyZW50ID0gbWFwWyBwYXJlbnRLZXlwYXRoIF07XG5cdFx0XHRcdHBhcmVudFsga2V5cGF0aCBdIC09IDE7XG5cdFx0XHRcdGlmICggIXBhcmVudFsga2V5cGF0aCBdICkge1xuXHRcdFx0XHRcdC8vIHJlbW92ZSBmcm9tIHBhcmVudCBkZXBzIG1hcFxuXHRcdFx0XHRcdHBhcmVudC5zcGxpY2UoIHBhcmVudC5pbmRleE9mKCBrZXlwYXRoICksIDEgKTtcblx0XHRcdFx0XHRwYXJlbnRbIGtleXBhdGggXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRrZXlwYXRoID0gcGFyZW50S2V5cGF0aDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCk7XG5cblx0Lyogdmlld21vZGVsL2FkYXB0Q29uZmlnLmpzICovXG5cdHZhciBhZGFwdENvbmZpZyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0Ly8gc2hvdWxkIHRoaXMgYmUgY29tYmluZWQgd2l0aCBwcm90b3R5cGUvYWRhcHQuanM/XG5cdFx0dmFyIGNvbmZpZ3VyZSA9IHtcblx0XHRcdGxvb2t1cDogZnVuY3Rpb24oIHRhcmdldCwgYWRhcHRvcnMgKSB7XG5cdFx0XHRcdHZhciBpLCBhZGFwdCA9IHRhcmdldC5hZGFwdDtcblx0XHRcdFx0aWYgKCAhYWRhcHQgfHwgIWFkYXB0Lmxlbmd0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4gYWRhcHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBhZGFwdG9ycyAmJiBPYmplY3Qua2V5cyggYWRhcHRvcnMgKS5sZW5ndGggJiYgKCBpID0gYWRhcHQubGVuZ3RoICkgKSB7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHR2YXIgYWRhcHRvciA9IGFkYXB0WyBpIF07XG5cdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiBhZGFwdG9yID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRcdFx0YWRhcHRbIGkgXSA9IGFkYXB0b3JzWyBhZGFwdG9yIF0gfHwgYWRhcHRvcjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGFkYXB0O1xuXHRcdFx0fSxcblx0XHRcdGNvbWJpbmU6IGZ1bmN0aW9uKCBwYXJlbnQsIGFkYXB0ICkge1xuXHRcdFx0XHQvLyBub3JtYWxpemUgJ0ZvbycgdG8gWyAnRm9vJyBdXG5cdFx0XHRcdHBhcmVudCA9IGFycmF5SWZTdHJpbmcoIHBhcmVudCApO1xuXHRcdFx0XHRhZGFwdCA9IGFycmF5SWZTdHJpbmcoIGFkYXB0ICk7XG5cdFx0XHRcdC8vIG5vIHBhcmVudD8gcmV0dXJuIGFkYXB0XG5cdFx0XHRcdGlmICggIXBhcmVudCB8fCAhcGFyZW50Lmxlbmd0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4gYWRhcHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gbm8gYWRhcHQ/IHJldHVybiAnY29weScgb2YgcGFyZW50XG5cdFx0XHRcdGlmICggIWFkYXB0IHx8ICFhZGFwdC5sZW5ndGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcmVudC5zbGljZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGFkZCBwYXJlbnQgYWRhcHRvcnMgdG8gb3B0aW9uc1xuXHRcdFx0XHRwYXJlbnQuZm9yRWFjaCggZnVuY3Rpb24oIGEgKSB7XG5cdFx0XHRcdFx0Ly8gZG9uJ3QgcHV0IGluIGR1cGxpY2F0ZXNcblx0XHRcdFx0XHRpZiAoIGFkYXB0LmluZGV4T2YoIGEgKSA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0XHRhZGFwdC5wdXNoKCBhICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJldHVybiBhZGFwdDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gYXJyYXlJZlN0cmluZyggYWRhcHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBhZGFwdCA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdGFkYXB0ID0gWyBhZGFwdCBdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGFkYXB0O1xuXHRcdH1cblx0XHRyZXR1cm4gY29uZmlndXJlO1xuXHR9KCk7XG5cblx0Lyogdmlld21vZGVsL1ZpZXdtb2RlbC5qcyAqL1xuXHR2YXIgVmlld21vZGVsID0gZnVuY3Rpb24oIGNyZWF0ZSwgYWRhcHQsIGFwcGx5Q2hhbmdlcywgY2FwdHVyZSwgY2xlYXJDYWNoZSwgY29tcHV0ZSwgZ2V0LCBpbml0LCBtYXJrLCBtZXJnZSwgcmVnaXN0ZXIsIHJlbGVhc2UsIHNldCwgc21hcnRVcGRhdGUsIHRlYXJkb3duLCB1bnJlZ2lzdGVyLCBhZGFwdENvbmZpZyApIHtcblxuXHRcdHZhciBub01hZ2ljO1xuXHRcdHRyeSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHt9LCAndGVzdCcsIHtcblx0XHRcdFx0dmFsdWU6IDBcblx0XHRcdH0gKTtcblx0XHR9IGNhdGNoICggZXJyICkge1xuXHRcdFx0bm9NYWdpYyA9IHRydWU7XG5cdFx0fVxuXHRcdHZhciBWaWV3bW9kZWwgPSBmdW5jdGlvbiggcmFjdGl2ZSApIHtcblx0XHRcdHRoaXMucmFjdGl2ZSA9IHJhY3RpdmU7XG5cdFx0XHQvLyBUT0RPIGV2ZW50dWFsbHksIHdlIHNob3VsZG4ndCBuZWVkIHRoaXMgcmVmZXJlbmNlXG5cdFx0XHRWaWV3bW9kZWwuZXh0ZW5kKCByYWN0aXZlLmNvbnN0cnVjdG9yLCByYWN0aXZlICk7XG5cdFx0XHR0aGlzLmNhY2hlID0ge307XG5cdFx0XHQvLyB3ZSBuZWVkIHRvIGJlIGFibGUgdG8gdXNlIGhhc093blByb3BlcnR5LCBzbyBjYW4ndCBpbmhlcml0IGZyb20gbnVsbFxuXHRcdFx0dGhpcy5jYWNoZU1hcCA9IGNyZWF0ZSggbnVsbCApO1xuXHRcdFx0dGhpcy5kZXBzID0ge1xuXHRcdFx0XHRjb21wdXRlZDoge30sXG5cdFx0XHRcdCdkZWZhdWx0Jzoge31cblx0XHRcdH07XG5cdFx0XHR0aGlzLmRlcHNNYXAgPSB7XG5cdFx0XHRcdGNvbXB1dGVkOiB7fSxcblx0XHRcdFx0J2RlZmF1bHQnOiB7fVxuXHRcdFx0fTtcblx0XHRcdHRoaXMucGF0dGVybk9ic2VydmVycyA9IFtdO1xuXHRcdFx0dGhpcy53cmFwcGVkID0gY3JlYXRlKCBudWxsICk7XG5cdFx0XHR0aGlzLmNvbXB1dGF0aW9ucyA9IGNyZWF0ZSggbnVsbCApO1xuXHRcdFx0dGhpcy5jYXB0dXJlR3JvdXBzID0gW107XG5cdFx0XHR0aGlzLnVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY2llcyA9IFtdO1xuXHRcdFx0dGhpcy5jaGFuZ2VzID0gW107XG5cdFx0XHR0aGlzLmltcGxpY2l0Q2hhbmdlcyA9IHt9O1xuXHRcdFx0dGhpcy5ub0Nhc2NhZGUgPSB7fTtcblx0XHR9O1xuXHRcdFZpZXdtb2RlbC5leHRlbmQgPSBmdW5jdGlvbiggUGFyZW50LCBpbnN0YW5jZSApIHtcblx0XHRcdGlmICggaW5zdGFuY2UubWFnaWMgJiYgbm9NYWdpYyApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnR2V0dGVycyBhbmQgc2V0dGVycyAobWFnaWMgbW9kZSkgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJyApO1xuXHRcdFx0fVxuXHRcdFx0aW5zdGFuY2UuYWRhcHQgPSBhZGFwdENvbmZpZy5jb21iaW5lKCBQYXJlbnQucHJvdG90eXBlLmFkYXB0LCBpbnN0YW5jZS5hZGFwdCApIHx8IFtdO1xuXHRcdFx0aW5zdGFuY2UuYWRhcHQgPSBhZGFwdENvbmZpZy5sb29rdXAoIGluc3RhbmNlLCBpbnN0YW5jZS5hZGFwdG9ycyApO1xuXHRcdH07XG5cdFx0Vmlld21vZGVsLnByb3RvdHlwZSA9IHtcblx0XHRcdGFkYXB0OiBhZGFwdCxcblx0XHRcdGFwcGx5Q2hhbmdlczogYXBwbHlDaGFuZ2VzLFxuXHRcdFx0Y2FwdHVyZTogY2FwdHVyZSxcblx0XHRcdGNsZWFyQ2FjaGU6IGNsZWFyQ2FjaGUsXG5cdFx0XHRjb21wdXRlOiBjb21wdXRlLFxuXHRcdFx0Z2V0OiBnZXQsXG5cdFx0XHRpbml0OiBpbml0LFxuXHRcdFx0bWFyazogbWFyayxcblx0XHRcdG1lcmdlOiBtZXJnZSxcblx0XHRcdHJlZ2lzdGVyOiByZWdpc3Rlcixcblx0XHRcdHJlbGVhc2U6IHJlbGVhc2UsXG5cdFx0XHRzZXQ6IHNldCxcblx0XHRcdHNtYXJ0VXBkYXRlOiBzbWFydFVwZGF0ZSxcblx0XHRcdHRlYXJkb3duOiB0ZWFyZG93bixcblx0XHRcdHVucmVnaXN0ZXI6IHVucmVnaXN0ZXJcblx0XHR9O1xuXHRcdHJldHVybiBWaWV3bW9kZWw7XG5cdH0oIGNyZWF0ZSwgdmlld21vZGVsJGFkYXB0LCB2aWV3bW9kZWwkYXBwbHlDaGFuZ2VzLCB2aWV3bW9kZWwkY2FwdHVyZSwgdmlld21vZGVsJGNsZWFyQ2FjaGUsIHZpZXdtb2RlbCRjb21wdXRlLCB2aWV3bW9kZWwkZ2V0LCB2aWV3bW9kZWwkaW5pdCwgdmlld21vZGVsJG1hcmssIHZpZXdtb2RlbCRtZXJnZSwgdmlld21vZGVsJHJlZ2lzdGVyLCB2aWV3bW9kZWwkcmVsZWFzZSwgdmlld21vZGVsJHNldCwgdmlld21vZGVsJHNtYXJ0VXBkYXRlLCB2aWV3bW9kZWwkdGVhcmRvd24sIHZpZXdtb2RlbCR1bnJlZ2lzdGVyLCBhZGFwdENvbmZpZyApO1xuXG5cdC8qIFJhY3RpdmUvaW5pdGlhbGlzZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZV9pbml0aWFsaXNlID0gZnVuY3Rpb24oIGNvbmZpZywgY3JlYXRlLCBGcmFnbWVudCwgZ2V0RWxlbWVudCwgZ2V0TmV4dE51bWJlciwgSG9vaywgSG9va1F1ZXVlLCBWaWV3bW9kZWwgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIGNvbnN0cnVjdEhvb2sgPSBuZXcgSG9vayggJ2NvbnN0cnVjdCcgKSxcblx0XHRcdGNvbmZpZ0hvb2sgPSBuZXcgSG9vayggJ2NvbmZpZycgKSxcblx0XHRcdGluaXRIb29rID0gbmV3IEhvb2tRdWV1ZSggJ2luaXQnICk7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBpbml0aWFsaXNlUmFjdGl2ZUluc3RhbmNlKCByYWN0aXZlICkge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSBhcmd1bWVudHNbIDEgXTtcblx0XHRcdGlmICggb3B0aW9ucyA9PT0gdm9pZCAwIClcblx0XHRcdFx0b3B0aW9ucyA9IHt9O1xuXHRcdFx0dmFyIGVsO1xuXHRcdFx0aW5pdGlhbGlzZVByb3BlcnRpZXMoIHJhY3RpdmUsIG9wdGlvbnMgKTtcblx0XHRcdC8vIG1ha2UgdGhpcyBvcHRpb24gZG8gd2hhdCB3b3VsZCBiZSBleHBlY3RlZCBpZiBzb21lb25lXG5cdFx0XHQvLyBkaWQgaW5jbHVkZSBpdCBvbiBhIG5ldyBSYWN0aXZlKCkgb3IgbmV3IENvbXBvbmVudCgpIGNhbGwuXG5cdFx0XHQvLyBTaWxseSB0byBkbyBzbyAocHV0IGEgaG9vayBvbiB0aGUgdmVyeSBvcHRpb25zIGJlaW5nIHVzZWQpLFxuXHRcdFx0Ly8gYnV0IGhhbmRsZSBpdCBjb3JyZWN0bHksIGNvbnNpc3RlbnQgd2l0aCB0aGUgaW50ZW50LlxuXHRcdFx0Y29uc3RydWN0SG9vay5maXJlKCBjb25maWcuZ2V0Q29uc3RydWN0VGFyZ2V0KCByYWN0aXZlLCBvcHRpb25zICksIG9wdGlvbnMgKTtcblx0XHRcdC8vIGluaXQgY29uZmlnIGZyb20gUGFyZW50IGFuZCBvcHRpb25zXG5cdFx0XHRjb25maWcuaW5pdCggcmFjdGl2ZS5jb25zdHJ1Y3RvciwgcmFjdGl2ZSwgb3B0aW9ucyApO1xuXHRcdFx0Y29uZmlnSG9vay5maXJlKCByYWN0aXZlICk7XG5cdFx0XHQvLyBUZWFyZG93biBhbnkgZXhpc3RpbmcgaW5zdGFuY2VzICpiZWZvcmUqIHRyeWluZyB0byBzZXQgdXAgdGhlIG5ldyBvbmUgLVxuXHRcdFx0Ly8gYXZvaWRzIGNlcnRhaW4gd2VpcmQgYnVnc1xuXHRcdFx0aWYgKCBlbCA9IGdldEVsZW1lbnQoIHJhY3RpdmUuZWwgKSApIHtcblx0XHRcdFx0aWYgKCAhcmFjdGl2ZS5hcHBlbmQgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbC5fX3JhY3RpdmVfaW5zdGFuY2VzX18gKSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRlbC5fX3JhY3RpdmVfaW5zdGFuY2VzX18uc3BsaWNlKCAwLCBlbC5fX3JhY3RpdmVfaW5zdGFuY2VzX18ubGVuZ3RoICkuZm9yRWFjaCggZnVuY3Rpb24oIHIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHIudGVhcmRvd24oKTtcblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGVyciApIHt9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsLmlubmVySFRNTCA9ICcnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpbml0SG9vay5iZWdpbiggcmFjdGl2ZSApO1xuXHRcdFx0Ly8gVEVNUE9SQVJZLiBUaGlzIGlzIHNvIHdlIGNhbiBpbXBsZW1lbnQgVmlld21vZGVsIGdyYWR1YWxseVxuXHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwgPSBuZXcgVmlld21vZGVsKCByYWN0aXZlICk7XG5cdFx0XHQvLyBoYWNreSBjaXJjdWxhciBwcm9ibGVtIHVudGlsIHdlIGdldCB0aGlzIHNvcnRlZCBvdXRcblx0XHRcdC8vIGlmIHZpZXdtb2RlbCBpbW1lZGlhdGVseSBwcm9jZXNzZXMgY29tcHV0ZWQgcHJvcGVydGllcyxcblx0XHRcdC8vIHRoZXkgbWF5IGNhbGwgcmFjdGl2ZS5nZXQsIHdoaWNoIGNhbGxzIHJhY3RpdmUudmlld21vZGVsLFxuXHRcdFx0Ly8gd2hpY2ggaGFzbid0IGJlZW4gc2V0IHRpbGwgbGluZSBhYm92ZSBmaW5pc2hlcy5cblx0XHRcdHJhY3RpdmUudmlld21vZGVsLmluaXQoKTtcblx0XHRcdC8vIFJlbmRlciBvdXIgKnJvb3QgZnJhZ21lbnQqXG5cdFx0XHRpZiAoIHJhY3RpdmUudGVtcGxhdGUgKSB7XG5cdFx0XHRcdHJhY3RpdmUuZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIHtcblx0XHRcdFx0XHR0ZW1wbGF0ZTogcmFjdGl2ZS50ZW1wbGF0ZSxcblx0XHRcdFx0XHRyb290OiByYWN0aXZlLFxuXHRcdFx0XHRcdG93bmVyOiByYWN0aXZlXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdGluaXRIb29rLmVuZCggcmFjdGl2ZSApO1xuXHRcdFx0Ly8gcmVuZGVyIGF1dG9tYXRpY2FsbHkgKCBpZiBgZWxgIGlzIHNwZWNpZmllZCApXG5cdFx0XHRpZiAoIGVsICkge1xuXHRcdFx0XHRyYWN0aXZlLnJlbmRlciggZWwsIHJhY3RpdmUuYXBwZW5kICk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGluaXRpYWxpc2VQcm9wZXJ0aWVzKCByYWN0aXZlLCBvcHRpb25zICkge1xuXHRcdFx0Ly8gR2VuZXJhdGUgYSB1bmlxdWUgaWRlbnRpZmllciwgZm9yIHBsYWNlcyB3aGVyZSB5b3UnZCB1c2UgYSB3ZWFrIG1hcCBpZiBpdFxuXHRcdFx0Ly8gZXhpc3RlZFxuXHRcdFx0cmFjdGl2ZS5fZ3VpZCA9IGdldE5leHROdW1iZXIoKTtcblx0XHRcdC8vIGV2ZW50c1xuXHRcdFx0cmFjdGl2ZS5fc3VicyA9IGNyZWF0ZSggbnVsbCApO1xuXHRcdFx0Ly8gc3RvcmFnZSBmb3IgaXRlbSBjb25maWd1cmF0aW9uIGZyb20gaW5zdGFudGlhdGlvbiB0byByZXNldCxcblx0XHRcdC8vIGxpa2UgZHluYW1pYyBmdW5jdGlvbnMgb3Igb3JpZ2luYWwgdmFsdWVzXG5cdFx0XHRyYWN0aXZlLl9jb25maWcgPSB7fTtcblx0XHRcdC8vIHR3by13YXkgYmluZGluZ3Ncblx0XHRcdHJhY3RpdmUuX3R3b3dheUJpbmRpbmdzID0gY3JlYXRlKCBudWxsICk7XG5cdFx0XHQvLyBhbmltYXRpb25zIChzbyB3ZSBjYW4gc3RvcCBhbnkgaW4gcHJvZ3Jlc3MgYXQgdGVhcmRvd24pXG5cdFx0XHRyYWN0aXZlLl9hbmltYXRpb25zID0gW107XG5cdFx0XHQvLyBub2RlcyByZWdpc3RyeVxuXHRcdFx0cmFjdGl2ZS5ub2RlcyA9IHt9O1xuXHRcdFx0Ly8gbGl2ZSBxdWVyaWVzXG5cdFx0XHRyYWN0aXZlLl9saXZlUXVlcmllcyA9IFtdO1xuXHRcdFx0cmFjdGl2ZS5fbGl2ZUNvbXBvbmVudFF1ZXJpZXMgPSBbXTtcblx0XHRcdC8vIElmIHRoaXMgaXMgYSBjb21wb25lbnQsIHN0b3JlIGEgcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnRcblx0XHRcdGlmICggb3B0aW9ucy5fcGFyZW50ICYmIG9wdGlvbnMuX2NvbXBvbmVudCApIHtcblx0XHRcdFx0cmFjdGl2ZS5fcGFyZW50ID0gb3B0aW9ucy5fcGFyZW50O1xuXHRcdFx0XHRyYWN0aXZlLmNvbXBvbmVudCA9IG9wdGlvbnMuX2NvbXBvbmVudDtcblx0XHRcdFx0Ly8gQW5kIHN0b3JlIGEgcmVmZXJlbmNlIHRvIHRoZSBpbnN0YW5jZSBvbiB0aGUgY29tcG9uZW50XG5cdFx0XHRcdG9wdGlvbnMuX2NvbXBvbmVudC5pbnN0YW5jZSA9IHJhY3RpdmU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggY29uZmlnLCBjcmVhdGUsIEZyYWdtZW50LCBnZXRFbGVtZW50LCBnZXROZXh0TnVtYmVyLCBSYWN0aXZlJHNoYXJlZF9ob29rc19Ib29rLCBSYWN0aXZlJHNoYXJlZF9ob29rc19Ib29rUXVldWUsIFZpZXdtb2RlbCApO1xuXG5cdC8qIGV4dGVuZC91bndyYXBFeHRlbmRlZC5qcyAqL1xuXHR2YXIgdW53cmFwRXh0ZW5kZWQgPSBmdW5jdGlvbiggd3JhcCwgY29uZmlnLCBjaXJjdWxhciApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgUmFjdGl2ZTtcblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFJhY3RpdmUgPSBjaXJjdWxhci5SYWN0aXZlO1xuXHRcdH0gKTtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIHVud3JhcEV4dGVuZGVkKCBDaGlsZCApIHtcblx0XHRcdGlmICggISggQ2hpbGQucHJvdG90eXBlIGluc3RhbmNlb2YgUmFjdGl2ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gQ2hpbGQ7XG5cdFx0XHR9XG5cdFx0XHR2YXIgb3B0aW9ucyA9IHt9O1xuXHRcdFx0d2hpbGUgKCBDaGlsZCApIHtcblx0XHRcdFx0Y29uZmlnLnJlZ2lzdHJpZXMuZm9yRWFjaCggZnVuY3Rpb24oIHIgKSB7XG5cdFx0XHRcdFx0YWRkUmVnaXN0cnkoIHIudXNlRGVmYXVsdHMgPyBDaGlsZC5wcm90b3R5cGUgOiBDaGlsZCwgb3B0aW9ucywgci5uYW1lICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0T2JqZWN0LmtleXMoIENoaWxkLnByb3RvdHlwZSApLmZvckVhY2goIGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0aWYgKCBrZXkgPT09ICdjb21wdXRlZCcgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZhciB2YWx1ZSA9IENoaWxkLnByb3RvdHlwZVsga2V5IF07XG5cdFx0XHRcdFx0aWYgKCAhKCBrZXkgaW4gb3B0aW9ucyApICkge1xuXHRcdFx0XHRcdFx0b3B0aW9uc1sga2V5IF0gPSB2YWx1ZS5fbWV0aG9kID8gdmFsdWUuX21ldGhvZCA6IHZhbHVlO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiBvcHRpb25zWyBrZXkgXSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYgb3B0aW9uc1sga2V5IF0uX21ldGhvZCApIHtcblx0XHRcdFx0XHRcdHZhciByZXN1bHQsIG5lZWRzU3VwZXIgPSB2YWx1ZS5fbWV0aG9kO1xuXHRcdFx0XHRcdFx0aWYgKCBuZWVkc1N1cGVyICkge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlLl9tZXRob2Q7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyByZXdyYXAgYm91bmQgZGlyZWN0bHkgdG8gcGFyZW50IGZuXG5cdFx0XHRcdFx0XHRyZXN1bHQgPSB3cmFwKCBvcHRpb25zWyBrZXkgXS5fbWV0aG9kLCB2YWx1ZSApO1xuXHRcdFx0XHRcdFx0aWYgKCBuZWVkc1N1cGVyICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHQuX21ldGhvZCA9IHJlc3VsdDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG9wdGlvbnNbIGtleSBdID0gcmVzdWx0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRpZiAoIENoaWxkLl9wYXJlbnQgIT09IFJhY3RpdmUgKSB7XG5cdFx0XHRcdFx0Q2hpbGQgPSBDaGlsZC5fcGFyZW50O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdENoaWxkID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBvcHRpb25zO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBhZGRSZWdpc3RyeSggdGFyZ2V0LCBvcHRpb25zLCBuYW1lICkge1xuXHRcdFx0dmFyIHJlZ2lzdHJ5LCBrZXlzID0gT2JqZWN0LmtleXMoIHRhcmdldFsgbmFtZSBdICk7XG5cdFx0XHRpZiAoICFrZXlzLmxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhKCByZWdpc3RyeSA9IG9wdGlvbnNbIG5hbWUgXSApICkge1xuXHRcdFx0XHRyZWdpc3RyeSA9IG9wdGlvbnNbIG5hbWUgXSA9IHt9O1xuXHRcdFx0fVxuXHRcdFx0a2V5cy5maWx0ZXIoIGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdHJldHVybiAhKCBrZXkgaW4gcmVnaXN0cnkgKTtcblx0XHRcdH0gKS5mb3JFYWNoKCBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVnaXN0cnlbIGtleSBdID0gdGFyZ2V0WyBuYW1lIF1bIGtleSBdO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIHdyYXBNZXRob2QsIGNvbmZpZywgY2lyY3VsYXIgKTtcblxuXHQvKiBleHRlbmQvX2V4dGVuZC5qcyAqL1xuXHR2YXIgUmFjdGl2ZV9leHRlbmQgPSBmdW5jdGlvbiggY3JlYXRlLCBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRHdWlkLCBjb25maWcsIGluaXRpYWxpc2UsIFZpZXdtb2RlbCwgdW53cmFwICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGV4dGVuZCgpIHtcblx0XHRcdHZhciBvcHRpb25zID0gYXJndW1lbnRzWyAwIF07XG5cdFx0XHRpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApXG5cdFx0XHRcdG9wdGlvbnMgPSB7fTtcblx0XHRcdHZhciBQYXJlbnQgPSB0aGlzLFxuXHRcdFx0XHRDaGlsZCwgcHJvdG8sIHN0YXRpY1Byb3BlcnRpZXM7XG5cdFx0XHQvLyBpZiB3ZSdyZSBleHRlbmRpbmcgd2l0aCBhbm90aGVyIFJhY3RpdmUgaW5zdGFuY2UsIGluaGVyaXQgaXRzXG5cdFx0XHQvLyBwcm90b3R5cGUgbWV0aG9kcyBhbmQgZGVmYXVsdCBvcHRpb25zIGFzIHdlbGxcblx0XHRcdG9wdGlvbnMgPSB1bndyYXAoIG9wdGlvbnMgKTtcblx0XHRcdC8vIGNyZWF0ZSBDaGlsZCBjb25zdHJ1Y3RvclxuXHRcdFx0Q2hpbGQgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdFx0aW5pdGlhbGlzZSggdGhpcywgb3B0aW9ucyApO1xuXHRcdFx0fTtcblx0XHRcdHByb3RvID0gY3JlYXRlKCBQYXJlbnQucHJvdG90eXBlICk7XG5cdFx0XHRwcm90by5jb25zdHJ1Y3RvciA9IENoaWxkO1xuXHRcdFx0c3RhdGljUHJvcGVydGllcyA9IHtcblx0XHRcdFx0Ly8gZWFjaCBjb21wb25lbnQgbmVlZHMgYSBndWlkLCBmb3IgbWFuYWdpbmcgQ1NTIGV0Y1xuXHRcdFx0XHRfZ3VpZDoge1xuXHRcdFx0XHRcdHZhbHVlOiBnZXRHdWlkKClcblx0XHRcdFx0fSxcblx0XHRcdFx0Ly8gYWxpYXMgcHJvdG90eXBlIGFzIGRlZmF1bHRzXG5cdFx0XHRcdGRlZmF1bHRzOiB7XG5cdFx0XHRcdFx0dmFsdWU6IHByb3RvXG5cdFx0XHRcdH0sXG5cdFx0XHRcdC8vIGV4dGVuZGFibGVcblx0XHRcdFx0ZXh0ZW5kOiB7XG5cdFx0XHRcdFx0dmFsdWU6IGV4dGVuZCxcblx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0fSxcblx0XHRcdFx0Ly8gUGFyZW50IC0gZm9yIElFOCwgY2FuJ3QgdXNlIE9iamVjdC5nZXRQcm90b3R5cGVPZlxuXHRcdFx0XHRfcGFyZW50OiB7XG5cdFx0XHRcdFx0dmFsdWU6IFBhcmVudFxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0ZGVmaW5lUHJvcGVydGllcyggQ2hpbGQsIHN0YXRpY1Byb3BlcnRpZXMgKTtcblx0XHRcdC8vIGV4dGVuZCBjb25maWd1cmF0aW9uXG5cdFx0XHRjb25maWcuZXh0ZW5kKCBQYXJlbnQsIHByb3RvLCBvcHRpb25zICk7XG5cdFx0XHRWaWV3bW9kZWwuZXh0ZW5kKCBQYXJlbnQsIHByb3RvICk7XG5cdFx0XHRDaGlsZC5wcm90b3R5cGUgPSBwcm90bztcblx0XHRcdHJldHVybiBDaGlsZDtcblx0XHR9O1xuXHR9KCBjcmVhdGUsIGRlZmluZVByb3BlcnRpZXMsIGdldEd1aWQsIGNvbmZpZywgUmFjdGl2ZV9pbml0aWFsaXNlLCBWaWV3bW9kZWwsIHVud3JhcEV4dGVuZGVkICk7XG5cblx0LyogUmFjdGl2ZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSA9IGZ1bmN0aW9uKCBkZWZhdWx0cywgZWFzaW5nLCBpbnRlcnBvbGF0b3JzLCBzdmcsIG1hZ2ljLCBkZWZpbmVQcm9wZXJ0aWVzLCBwcm90bywgUHJvbWlzZSwgZXh0ZW5kT2JqLCBleHRlbmQsIHBhcnNlLCBpbml0aWFsaXNlLCBjaXJjdWxhciApIHtcblxuXHRcdHZhciBSYWN0aXZlLCBwcm9wZXJ0aWVzO1xuXHRcdC8vIE1haW4gUmFjdGl2ZSByZXF1aXJlZCBvYmplY3Rcblx0XHRSYWN0aXZlID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHRpbml0aWFsaXNlKCB0aGlzLCBvcHRpb25zICk7XG5cdFx0fTtcblx0XHQvLyBSYWN0aXZlIHByb3BlcnRpZXNcblx0XHRwcm9wZXJ0aWVzID0ge1xuXHRcdFx0Ly8gc3RhdGljIG1ldGhvZHM6XG5cdFx0XHRleHRlbmQ6IHtcblx0XHRcdFx0dmFsdWU6IGV4dGVuZFxuXHRcdFx0fSxcblx0XHRcdHBhcnNlOiB7XG5cdFx0XHRcdHZhbHVlOiBwYXJzZVxuXHRcdFx0fSxcblx0XHRcdC8vIE5hbWVzcGFjZWQgY29uc3RydWN0b3JzXG5cdFx0XHRQcm9taXNlOiB7XG5cdFx0XHRcdHZhbHVlOiBQcm9taXNlXG5cdFx0XHR9LFxuXHRcdFx0Ly8gc3VwcG9ydFxuXHRcdFx0c3ZnOiB7XG5cdFx0XHRcdHZhbHVlOiBzdmdcblx0XHRcdH0sXG5cdFx0XHRtYWdpYzoge1xuXHRcdFx0XHR2YWx1ZTogbWFnaWNcblx0XHRcdH0sXG5cdFx0XHQvLyB2ZXJzaW9uXG5cdFx0XHRWRVJTSU9OOiB7XG5cdFx0XHRcdHZhbHVlOiAnMC42LjEnXG5cdFx0XHR9LFxuXHRcdFx0Ly8gUGx1Z2luc1xuXHRcdFx0YWRhcHRvcnM6IHtcblx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiB7fVxuXHRcdFx0fSxcblx0XHRcdGNvbXBvbmVudHM6IHtcblx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiB7fVxuXHRcdFx0fSxcblx0XHRcdGRlY29yYXRvcnM6IHtcblx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiB7fVxuXHRcdFx0fSxcblx0XHRcdGVhc2luZzoge1xuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IGVhc2luZ1xuXHRcdFx0fSxcblx0XHRcdGV2ZW50czoge1xuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHt9XG5cdFx0XHR9LFxuXHRcdFx0aW50ZXJwb2xhdG9yczoge1xuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IGludGVycG9sYXRvcnNcblx0XHRcdH0sXG5cdFx0XHRwYXJ0aWFsczoge1xuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHt9XG5cdFx0XHR9LFxuXHRcdFx0dHJhbnNpdGlvbnM6IHtcblx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiB7fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0Ly8gUmFjdGl2ZSBwcm9wZXJ0aWVzXG5cdFx0ZGVmaW5lUHJvcGVydGllcyggUmFjdGl2ZSwgcHJvcGVydGllcyApO1xuXHRcdFJhY3RpdmUucHJvdG90eXBlID0gZXh0ZW5kT2JqKCBwcm90bywgZGVmYXVsdHMgKTtcblx0XHRSYWN0aXZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJhY3RpdmU7XG5cdFx0Ly8gYWxpYXMgcHJvdG90eXBlIGFzIGRlZmF1bHRzXG5cdFx0UmFjdGl2ZS5kZWZhdWx0cyA9IFJhY3RpdmUucHJvdG90eXBlO1xuXHRcdC8vIENlcnRhaW4gbW9kdWxlcyBoYXZlIGNpcmN1bGFyIGRlcGVuZGVuY2llcy4gSWYgd2Ugd2VyZSBidW5kbGluZyBhXG5cdFx0Ly8gbW9kdWxlIGxvYWRlciwgZS5nLiBhbG1vbmQuanMsIHRoaXMgd291bGRuJ3QgYmUgYSBwcm9ibGVtLCBidXQgd2UncmVcblx0XHQvLyBub3QgLSB3ZSdyZSB1c2luZyBhbWRjbGVhbiBhcyBwYXJ0IG9mIHRoZSBidWlsZCBwcm9jZXNzLiBCZWNhdXNlIG9mXG5cdFx0Ly8gdGhpcywgd2UgbmVlZCB0byB3YWl0IHVudGlsIGFsbCBtb2R1bGVzIGhhdmUgbG9hZGVkIGJlZm9yZSB0aG9zZVxuXHRcdC8vIGNpcmN1bGFyIGRlcGVuZGVuY2llcyBjYW4gYmUgcmVxdWlyZWQuXG5cdFx0Y2lyY3VsYXIuUmFjdGl2ZSA9IFJhY3RpdmU7XG5cdFx0d2hpbGUgKCBjaXJjdWxhci5sZW5ndGggKSB7XG5cdFx0XHRjaXJjdWxhci5wb3AoKSgpO1xuXHRcdH1cblx0XHQvLyBSYWN0aXZlLmpzIG1ha2VzIGxpYmVyYWwgdXNlIG9mIHRoaW5ncyBsaWtlIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLiBJblxuXHRcdC8vIG9sZGVyIGJyb3dzZXJzLCB0aGVzZSBhcmUgbWFkZSBhdmFpbGFibGUgdmlhIGEgc2hpbSAtIGhlcmUsIHdlIGRvIGEgcXVpY2tcblx0XHQvLyBwcmUtZmxpZ2h0IGNoZWNrIHRvIG1ha2Ugc3VyZSB0aGF0IGVpdGhlciBhKSB3ZSdyZSBub3QgaW4gYSBzaGl0IGJyb3dzZXIsXG5cdFx0Ly8gb3IgYikgd2UncmUgdXNpbmcgYSBSYWN0aXZlLWxlZ2FjeS5qcyBidWlsZFxuXHRcdHZhciBGVU5DVElPTiA9ICdmdW5jdGlvbic7XG5cdFx0aWYgKCB0eXBlb2YgRGF0ZS5ub3cgIT09IEZVTkNUSU9OIHx8IHR5cGVvZiBTdHJpbmcucHJvdG90eXBlLnRyaW0gIT09IEZVTkNUSU9OIHx8IHR5cGVvZiBPYmplY3Qua2V5cyAhPT0gRlVOQ1RJT04gfHwgdHlwZW9mIEFycmF5LnByb3RvdHlwZS5pbmRleE9mICE9PSBGVU5DVElPTiB8fCB0eXBlb2YgQXJyYXkucHJvdG90eXBlLmZvckVhY2ggIT09IEZVTkNUSU9OIHx8IHR5cGVvZiBBcnJheS5wcm90b3R5cGUubWFwICE9PSBGVU5DVElPTiB8fCB0eXBlb2YgQXJyYXkucHJvdG90eXBlLmZpbHRlciAhPT0gRlVOQ1RJT04gfHwgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyICE9PSBGVU5DVElPTiApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvciggJ0l0IGxvb2tzIGxpa2UgeW91XFwncmUgYXR0ZW1wdGluZyB0byB1c2UgUmFjdGl2ZS5qcyBpbiBhbiBvbGRlciBicm93c2VyLiBZb3VcXCdsbCBuZWVkIHRvIHVzZSBvbmUgb2YgdGhlIFxcJ2xlZ2FjeSBidWlsZHNcXCcgaW4gb3JkZXIgdG8gY29udGludWUgLSBzZWUgaHR0cDovL2RvY3MucmFjdGl2ZWpzLm9yZy9sYXRlc3QvbGVnYWN5LWJ1aWxkcyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nICk7XG5cdFx0fVxuXHRcdHJldHVybiBSYWN0aXZlO1xuXHR9KCBvcHRpb25zLCBlYXNpbmcsIGludGVycG9sYXRvcnMsIHN2ZywgbWFnaWMsIGRlZmluZVByb3BlcnRpZXMsIHByb3RvdHlwZSwgUHJvbWlzZSwgZXh0ZW5kLCBSYWN0aXZlX2V4dGVuZCwgcGFyc2UsIFJhY3RpdmVfaW5pdGlhbGlzZSwgY2lyY3VsYXIgKTtcblxuXG5cdC8vIGV4cG9ydCBhcyBDb21tb24gSlMgbW9kdWxlLi4uXG5cdGlmICggdHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cyApIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IFJhY3RpdmU7XG5cdH1cblxuXHQvLyAuLi4gb3IgYXMgQU1EIG1vZHVsZVxuXHRlbHNlIGlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdFx0ZGVmaW5lKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBSYWN0aXZlO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIC4uLiBvciBhcyBicm93c2VyIGdsb2JhbFxuXHRnbG9iYWwuUmFjdGl2ZSA9IFJhY3RpdmU7XG5cblx0UmFjdGl2ZS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0Z2xvYmFsLlJhY3RpdmUgPSBub0NvbmZsaWN0O1xuXHRcdHJldHVybiBSYWN0aXZlO1xuXHR9O1xuXG59KCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMgKSApO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmFjdGl2ZS9yYWN0aXZlLmpzXG4gKiogbW9kdWxlIGlkID0gNlxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIiwiLyogc3ZnLmpzIDEuMC4xIC0gc3ZnIHNlbGVjdG9yIGludmVudG9yIHBvbHlmaWxsIHJlZ2V4IGRlZmF1bHQgY29sb3IgYXJyYXkgcG9pbnRhcnJheSBwYXRoYXJyYXkgbnVtYmVyIHZpZXdib3ggYmJveCByYm94IGVsZW1lbnQgcGFyZW50IGNvbnRhaW5lciBmeCByZWxhdGl2ZSBldmVudCBkZWZzIGdyb3VwIGFycmFuZ2UgbWFzayBjbGlwIGdyYWRpZW50IHBhdHRlcm4gZG9jIHNoYXBlIHN5bWJvbCB1c2UgcmVjdCBlbGxpcHNlIGxpbmUgcG9seSBwYXRoIGltYWdlIHRleHQgdGV4dHBhdGggbmVzdGVkIGh5cGVybGluayBtYXJrZXIgc3VnYXIgc2V0IGRhdGEgbWVtb3J5IGxvYWRlciBoZWxwZXJzIC0gc3ZnanMuY29tL2xpY2Vuc2UgKi9cbjsoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZhY3RvcnkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuU1ZHID0gZmFjdG9yeSgpO1xuICB9XG59KHRoaXMsIGZ1bmN0aW9uKCkge1xuXG4gIHZhciBTVkcgPSB0aGlzLlNWRyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBpZiAoU1ZHLnN1cHBvcnRlZCkge1xuICAgICAgZWxlbWVudCA9IG5ldyBTVkcuRG9jKGVsZW1lbnQpXG4gIFxuICAgICAgaWYgKCFTVkcucGFyc2VyKVxuICAgICAgICBTVkcucHJlcGFyZShlbGVtZW50KVxuICBcbiAgICAgIHJldHVybiBlbGVtZW50XG4gICAgfVxuICB9XG4gIFxuICAvLyBEZWZhdWx0IG5hbWVzcGFjZXNcbiAgU1ZHLm5zICAgID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJ1xuICBTVkcueG1sbnMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nXG4gIFNWRy54bGluayA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJ1xuICBcbiAgLy8gRWxlbWVudCBpZCBzZXF1ZW5jZVxuICBTVkcuZGlkICA9IDEwMDBcbiAgXG4gIC8vIEdldCBuZXh0IG5hbWVkIGVsZW1lbnQgaWRcbiAgU1ZHLmVpZCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gJ1N2Z2pzJyArIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpICsgKFNWRy5kaWQrKylcbiAgfVxuICBcbiAgLy8gTWV0aG9kIGZvciBlbGVtZW50IGNyZWF0aW9uXG4gIFNWRy5jcmVhdGUgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgLyogY3JlYXRlIGVsZW1lbnQgKi9cbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh0aGlzLm5zLCBuYW1lKVxuICAgIFxuICAgIC8qIGFwcGx5IHVuaXF1ZSBpZCAqL1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMuZWlkKG5hbWUpKVxuICAgIFxuICAgIHJldHVybiBlbGVtZW50XG4gIH1cbiAgXG4gIC8vIE1ldGhvZCBmb3IgZXh0ZW5kaW5nIG9iamVjdHNcbiAgU1ZHLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtb2R1bGVzLCBtZXRob2RzLCBrZXksIGlcbiAgICBcbiAgICAvKiBnZXQgbGlzdCBvZiBtb2R1bGVzICovXG4gICAgbW9kdWxlcyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICAgIFxuICAgIC8qIGdldCBvYmplY3Qgd2l0aCBleHRlbnNpb25zICovXG4gICAgbWV0aG9kcyA9IG1vZHVsZXMucG9wKClcbiAgICBcbiAgICBmb3IgKGkgPSBtb2R1bGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgaWYgKG1vZHVsZXNbaV0pXG4gICAgICAgIGZvciAoa2V5IGluIG1ldGhvZHMpXG4gICAgICAgICAgbW9kdWxlc1tpXS5wcm90b3R5cGVba2V5XSA9IG1ldGhvZHNba2V5XVxuICBcbiAgICAvKiBtYWtlIHN1cmUgU1ZHLlNldCBpbmhlcml0cyBhbnkgbmV3bHkgYWRkZWQgbWV0aG9kcyAqL1xuICAgIGlmIChTVkcuU2V0ICYmIFNWRy5TZXQuaW5oZXJpdClcbiAgICAgIFNWRy5TZXQuaW5oZXJpdCgpXG4gIH1cbiAgXG4gIC8vIEluaXRpYWxpemUgcGFyc2luZyBlbGVtZW50XG4gIFNWRy5wcmVwYXJlID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIC8qIHNlbGVjdCBkb2N1bWVudCBib2R5IGFuZCBjcmVhdGUgaW52aXNpYmxlIHN2ZyBlbGVtZW50ICovXG4gICAgdmFyIGJvZHkgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYm9keScpWzBdXG4gICAgICAsIGRyYXcgPSAoYm9keSA/IG5ldyBTVkcuRG9jKGJvZHkpIDogZWxlbWVudC5uZXN0ZWQoKSkuc2l6ZSgyLCAwKVxuICAgICAgLCBwYXRoID0gU1ZHLmNyZWF0ZSgncGF0aCcpXG4gIFxuICAgIC8qIGluc2VydCBwYXJzZXJzICovXG4gICAgZHJhdy5ub2RlLmFwcGVuZENoaWxkKHBhdGgpXG4gIFxuICAgIC8qIGNyZWF0ZSBwYXJzZXIgb2JqZWN0ICovXG4gICAgU1ZHLnBhcnNlciA9IHtcbiAgICAgIGJvZHk6IGJvZHkgfHwgZWxlbWVudC5wYXJlbnRcbiAgICAsIGRyYXc6IGRyYXcuc3R5bGUoJ29wYWNpdHk6MDtwb3NpdGlvbjpmaXhlZDtsZWZ0OjEwMCU7dG9wOjEwMCU7b3ZlcmZsb3c6aGlkZGVuJylcbiAgICAsIHBvbHk6IGRyYXcucG9seWxpbmUoKS5ub2RlXG4gICAgLCBwYXRoOiBwYXRoXG4gICAgfVxuICB9XG4gIFxuICAvLyBzdmcgc3VwcG9ydCB0ZXN0XG4gIFNWRy5zdXBwb3J0ZWQgPSAoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICEhIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyAmJlxuICAgICAgICAgICAhISBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHLm5zLCdzdmcnKS5jcmVhdGVTVkdSZWN0XG4gIH0pKClcbiAgXG4gIGlmICghU1ZHLnN1cHBvcnRlZCkgcmV0dXJuIGZhbHNlXG5cblxuICBTVkcuZ2V0ID0gZnVuY3Rpb24oaWQpIHtcbiAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkRnJvbVJlZmVyZW5jZShpZCkgfHwgaWQpXG4gICAgaWYgKG5vZGUpIHJldHVybiBub2RlLmluc3RhbmNlXG4gIH1cblxuICBTVkcuaW52ZW50ID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gIFx0LyogY3JlYXRlIGVsZW1lbnQgaW5pdGlhbGl6ZXIgKi9cbiAgXHR2YXIgaW5pdGlhbGl6ZXIgPSB0eXBlb2YgY29uZmlnLmNyZWF0ZSA9PSAnZnVuY3Rpb24nID9cbiAgXHRcdGNvbmZpZy5jcmVhdGUgOlxuICBcdFx0ZnVuY3Rpb24oKSB7XG4gIFx0XHRcdHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBTVkcuY3JlYXRlKGNvbmZpZy5jcmVhdGUpKVxuICBcdFx0fVxuICBcbiAgXHQvKiBpbmhlcml0IHByb3RvdHlwZSAqL1xuICBcdGlmIChjb25maWcuaW5oZXJpdClcbiAgXHRcdGluaXRpYWxpemVyLnByb3RvdHlwZSA9IG5ldyBjb25maWcuaW5oZXJpdFxuICBcbiAgXHQvKiBleHRlbmQgd2l0aCBtZXRob2RzICovXG4gIFx0aWYgKGNvbmZpZy5leHRlbmQpXG4gIFx0XHRTVkcuZXh0ZW5kKGluaXRpYWxpemVyLCBjb25maWcuZXh0ZW5kKVxuICBcbiAgXHQvKiBhdHRhY2ggY29uc3RydWN0IG1ldGhvZCB0byBwYXJlbnQgKi9cbiAgXHRpZiAoY29uZmlnLmNvbnN0cnVjdClcbiAgXHRcdFNWRy5leHRlbmQoY29uZmlnLnBhcmVudCB8fCBTVkcuQ29udGFpbmVyLCBjb25maWcuY29uc3RydWN0KVxuICBcbiAgXHRyZXR1cm4gaW5pdGlhbGl6ZXJcbiAgfVxuXG4gIGlmICh0eXBlb2YgQ3VzdG9tRXZlbnQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBDb2RlIGZyb206IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudFxuICAgIGZ1bmN0aW9uIEN1c3RvbUV2ZW50IChldmVudCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UsIGRldGFpbDogdW5kZWZpbmVkIH1cbiAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50JylcbiAgICAgIGUuaW5pdEN1c3RvbUV2ZW50KGV2ZW50LCBvcHRpb25zLmJ1YmJsZXMsIG9wdGlvbnMuY2FuY2VsYWJsZSwgb3B0aW9ucy5kZXRhaWwpXG4gICAgICByZXR1cm4gZVxuICAgIH1cbiAgXG4gICAgQ3VzdG9tRXZlbnQucHJvdG90eXBlID0gd2luZG93LkV2ZW50LnByb3RvdHlwZVxuICBcbiAgICB3aW5kb3cuQ3VzdG9tRXZlbnQgPSBDdXN0b21FdmVudFxuICB9XG5cbiAgU1ZHLnJlZ2V4ID0ge1xuICAgIC8qIHBhcnNlIHVuaXQgdmFsdWUgKi9cbiAgICB1bml0OiAgICAgICAgIC9eKC0/W1xcZFxcLl0rKShbYS16JV17MCwyfSkkL1xuICAgIFxuICAgIC8qIHBhcnNlIGhleCB2YWx1ZSAqL1xuICAsIGhleDogICAgICAgICAgL14jPyhbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KSQvaVxuICAgIFxuICAgIC8qIHBhcnNlIHJnYiB2YWx1ZSAqL1xuICAsIHJnYjogICAgICAgICAgL3JnYlxcKChcXGQrKSwoXFxkKyksKFxcZCspXFwpL1xuICAgIFxuICAgIC8qIHBhcnNlIHJlZmVyZW5jZSBpZCAqL1xuICAsIHJlZmVyZW5jZTogICAgLyMoW2EtejAtOVxcLV9dKykvaVxuICBcbiAgICAvKiB0ZXN0IGhleCB2YWx1ZSAqL1xuICAsIGlzSGV4OiAgICAgICAgL14jW2EtZjAtOV17Myw2fSQvaVxuICAgIFxuICAgIC8qIHRlc3QgcmdiIHZhbHVlICovXG4gICwgaXNSZ2I6ICAgICAgICAvXnJnYlxcKC9cbiAgICBcbiAgICAvKiB0ZXN0IGNzcyBkZWNsYXJhdGlvbiAqL1xuICAsIGlzQ3NzOiAgICAgICAgL1teOl0rOlteO10rOz8vXG4gICAgXG4gICAgLyogdGVzdCBmb3IgYmxhbmsgc3RyaW5nICovXG4gICwgaXNCbGFuazogICAgICAvXihcXHMrKT8kL1xuICAgIFxuICAgIC8qIHRlc3QgZm9yIG51bWVyaWMgc3RyaW5nICovXG4gICwgaXNOdW1iZXI6ICAgICAvXi0/W1xcZFxcLl0rJC9cbiAgXG4gICAgLyogdGVzdCBmb3IgcGVyY2VudCB2YWx1ZSAqL1xuICAsIGlzUGVyY2VudDogICAgL14tP1tcXGRcXC5dKyUkL1xuICBcbiAgICAvKiB0ZXN0IGZvciBpbWFnZSB1cmwgKi9cbiAgLCBpc0ltYWdlOiAgICAgIC9cXC4oanBnfGpwZWd8cG5nfGdpZikoXFw/W149XSsuKik/L2lcbiAgICBcbiAgICAvKiB0ZXN0IGZvciBuYW1lc3BhY2VkIGV2ZW50ICovXG4gICwgaXNFdmVudDogICAgICAvXltcXHddKzpbXFx3XSskL1xuICBcbiAgfVxuXG4gIFNWRy5kZWZhdWx0cyA9IHtcbiAgICAvLyBEZWZhdWx0IG1hdHJpeFxuICAgIG1hdHJpeDogICAgICAgJzEgMCAwIDEgMCAwJ1xuICAgIFxuICAgIC8vIERlZmF1bHQgYXR0cmlidXRlIHZhbHVlc1xuICAsIGF0dHJzOiB7XG4gICAgICAvKiBmaWxsIGFuZCBzdHJva2UgKi9cbiAgICAgICdmaWxsLW9wYWNpdHknOiAgICAgMVxuICAgICwgJ3N0cm9rZS1vcGFjaXR5JzogICAxXG4gICAgLCAnc3Ryb2tlLXdpZHRoJzogICAgIDBcbiAgICAsICdzdHJva2UtbGluZWpvaW4nOiAgJ21pdGVyJ1xuICAgICwgJ3N0cm9rZS1saW5lY2FwJzogICAnYnV0dCdcbiAgICAsIGZpbGw6ICAgICAgICAgICAgICAgJyMwMDAwMDAnXG4gICAgLCBzdHJva2U6ICAgICAgICAgICAgICcjMDAwMDAwJ1xuICAgICwgb3BhY2l0eTogICAgICAgICAgICAxXG4gICAgICAvKiBwb3NpdGlvbiAqL1xuICAgICwgeDogICAgICAgICAgICAgICAgICAwXG4gICAgLCB5OiAgICAgICAgICAgICAgICAgIDBcbiAgICAsIGN4OiAgICAgICAgICAgICAgICAgMFxuICAgICwgY3k6ICAgICAgICAgICAgICAgICAwXG4gICAgICAvKiBzaXplICovICBcbiAgICAsIHdpZHRoOiAgICAgICAgICAgICAgMFxuICAgICwgaGVpZ2h0OiAgICAgICAgICAgICAwXG4gICAgICAvKiByYWRpdXMgKi8gIFxuICAgICwgcjogICAgICAgICAgICAgICAgICAwXG4gICAgLCByeDogICAgICAgICAgICAgICAgIDBcbiAgICAsIHJ5OiAgICAgICAgICAgICAgICAgMFxuICAgICAgLyogZ3JhZGllbnQgKi8gIFxuICAgICwgb2Zmc2V0OiAgICAgICAgICAgICAwXG4gICAgLCAnc3RvcC1vcGFjaXR5JzogICAgIDFcbiAgICAsICdzdG9wLWNvbG9yJzogICAgICAgJyMwMDAwMDAnXG4gICAgICAvKiB0ZXh0ICovXG4gICAgLCAnZm9udC1zaXplJzogICAgICAgIDE2XG4gICAgLCAnZm9udC1mYW1pbHknOiAgICAgICdIZWx2ZXRpY2EsIEFyaWFsLCBzYW5zLXNlcmlmJ1xuICAgICwgJ3RleHQtYW5jaG9yJzogICAgICAnc3RhcnQnXG4gICAgfVxuICAgIFxuICAgIC8vIERlZmF1bHQgdHJhbnNmb3JtYXRpb24gdmFsdWVzXG4gICwgdHJhbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLyogdHJhbnNsYXRlICovXG4gICAgICAgIHg6ICAgICAgICAwXG4gICAgICAsIHk6ICAgICAgICAwXG4gICAgICAgIC8qIHNjYWxlICovXG4gICAgICAsIHNjYWxlWDogICAxXG4gICAgICAsIHNjYWxlWTogICAxXG4gICAgICAgIC8qIHJvdGF0ZSAqL1xuICAgICAgLCByb3RhdGlvbjogMFxuICAgICAgICAvKiBza2V3ICovXG4gICAgICAsIHNrZXdYOiAgICAwXG4gICAgICAsIHNrZXdZOiAgICAwXG4gICAgICAgIC8qIG1hdHJpeCAqL1xuICAgICAgLCBtYXRyaXg6ICAgdGhpcy5tYXRyaXhcbiAgICAgICwgYTogICAgICAgIDFcbiAgICAgICwgYjogICAgICAgIDBcbiAgICAgICwgYzogICAgICAgIDBcbiAgICAgICwgZDogICAgICAgIDFcbiAgICAgICwgZTogICAgICAgIDBcbiAgICAgICwgZjogICAgICAgIDBcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gIH1cblxuICBTVkcuQ29sb3IgPSBmdW5jdGlvbihjb2xvcikge1xuICAgIHZhciBtYXRjaFxuICAgIFxuICAgIC8qIGluaXRpYWxpemUgZGVmYXVsdHMgKi9cbiAgICB0aGlzLnIgPSAwXG4gICAgdGhpcy5nID0gMFxuICAgIHRoaXMuYiA9IDBcbiAgICBcbiAgICAvKiBwYXJzZSBjb2xvciAqL1xuICAgIGlmICh0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoU1ZHLnJlZ2V4LmlzUmdiLnRlc3QoY29sb3IpKSB7XG4gICAgICAgIC8qIGdldCByZ2IgdmFsdWVzICovXG4gICAgICAgIG1hdGNoID0gU1ZHLnJlZ2V4LnJnYi5leGVjKGNvbG9yLnJlcGxhY2UoL1xccy9nLCcnKSlcbiAgICAgICAgXG4gICAgICAgIC8qIHBhcnNlIG51bWVyaWMgdmFsdWVzICovXG4gICAgICAgIHRoaXMuciA9IHBhcnNlSW50KG1hdGNoWzFdKVxuICAgICAgICB0aGlzLmcgPSBwYXJzZUludChtYXRjaFsyXSlcbiAgICAgICAgdGhpcy5iID0gcGFyc2VJbnQobWF0Y2hbM10pXG4gICAgICAgIFxuICAgICAgfSBlbHNlIGlmIChTVkcucmVnZXguaXNIZXgudGVzdChjb2xvcikpIHtcbiAgICAgICAgLyogZ2V0IGhleCB2YWx1ZXMgKi9cbiAgICAgICAgbWF0Y2ggPSBTVkcucmVnZXguaGV4LmV4ZWMoZnVsbEhleChjb2xvcikpXG4gIFxuICAgICAgICAvKiBwYXJzZSBudW1lcmljIHZhbHVlcyAqL1xuICAgICAgICB0aGlzLnIgPSBwYXJzZUludChtYXRjaFsxXSwgMTYpXG4gICAgICAgIHRoaXMuZyA9IHBhcnNlSW50KG1hdGNoWzJdLCAxNilcbiAgICAgICAgdGhpcy5iID0gcGFyc2VJbnQobWF0Y2hbM10sIDE2KVxuICBcbiAgICAgIH1cbiAgICAgIFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbG9yID09PSAnb2JqZWN0Jykge1xuICAgICAgdGhpcy5yID0gY29sb3IuclxuICAgICAgdGhpcy5nID0gY29sb3IuZ1xuICAgICAgdGhpcy5iID0gY29sb3IuYlxuICAgICAgXG4gICAgfVxuICAgICAgXG4gIH1cbiAgXG4gIFNWRy5leHRlbmQoU1ZHLkNvbG9yLCB7XG4gICAgLy8gRGVmYXVsdCB0byBoZXggY29udmVyc2lvblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvSGV4KClcbiAgICB9XG4gICAgLy8gQnVpbGQgaGV4IHZhbHVlXG4gICwgdG9IZXg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICcjJ1xuICAgICAgICArIGNvbXBUb0hleCh0aGlzLnIpXG4gICAgICAgICsgY29tcFRvSGV4KHRoaXMuZylcbiAgICAgICAgKyBjb21wVG9IZXgodGhpcy5iKVxuICAgIH1cbiAgICAvLyBCdWlsZCByZ2IgdmFsdWVcbiAgLCB0b1JnYjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJ3JnYignICsgW3RoaXMuciwgdGhpcy5nLCB0aGlzLmJdLmpvaW4oKSArICcpJ1xuICAgIH1cbiAgICAvLyBDYWxjdWxhdGUgdHJ1ZSBicmlnaHRuZXNzXG4gICwgYnJpZ2h0bmVzczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKHRoaXMuciAvIDI1NSAqIDAuMzApXG4gICAgICAgICAgICsgKHRoaXMuZyAvIDI1NSAqIDAuNTkpXG4gICAgICAgICAgICsgKHRoaXMuYiAvIDI1NSAqIDAuMTEpXG4gICAgfVxuICAgIC8vIE1ha2UgY29sb3IgbW9ycGhhYmxlXG4gICwgbW9ycGg6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uID0gbmV3IFNWRy5Db2xvcihjb2xvcilcbiAgXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICAvLyBHZXQgbW9ycGhlZCBjb2xvciBhdCBnaXZlbiBwb3NpdGlvblxuICAsIGF0OiBmdW5jdGlvbihwb3MpIHtcbiAgICAgIC8qIG1ha2Ugc3VyZSBhIGRlc3RpbmF0aW9uIGlzIGRlZmluZWQgKi9cbiAgICAgIGlmICghdGhpcy5kZXN0aW5hdGlvbikgcmV0dXJuIHRoaXNcbiAgXG4gICAgICAvKiBub3JtYWxpc2UgcG9zICovXG4gICAgICBwb3MgPSBwb3MgPCAwID8gMCA6IHBvcyA+IDEgPyAxIDogcG9zXG4gIFxuICAgICAgLyogZ2VuZXJhdGUgbW9ycGhlZCBjb2xvciAqL1xuICAgICAgcmV0dXJuIG5ldyBTVkcuQ29sb3Ioe1xuICAgICAgICByOiB+fih0aGlzLnIgKyAodGhpcy5kZXN0aW5hdGlvbi5yIC0gdGhpcy5yKSAqIHBvcylcbiAgICAgICwgZzogfn4odGhpcy5nICsgKHRoaXMuZGVzdGluYXRpb24uZyAtIHRoaXMuZykgKiBwb3MpXG4gICAgICAsIGI6IH5+KHRoaXMuYiArICh0aGlzLmRlc3RpbmF0aW9uLmIgLSB0aGlzLmIpICogcG9zKVxuICAgICAgfSlcbiAgICB9XG4gICAgXG4gIH0pXG4gIFxuICAvLyBUZXN0ZXJzXG4gIFxuICAvLyBUZXN0IGlmIGdpdmVuIHZhbHVlIGlzIGEgY29sb3Igc3RyaW5nXG4gIFNWRy5Db2xvci50ZXN0ID0gZnVuY3Rpb24oY29sb3IpIHtcbiAgICBjb2xvciArPSAnJ1xuICAgIHJldHVybiBTVkcucmVnZXguaXNIZXgudGVzdChjb2xvcilcbiAgICAgICAgfHwgU1ZHLnJlZ2V4LmlzUmdiLnRlc3QoY29sb3IpXG4gIH1cbiAgXG4gIC8vIFRlc3QgaWYgZ2l2ZW4gdmFsdWUgaXMgYSByZ2Igb2JqZWN0XG4gIFNWRy5Db2xvci5pc1JnYiA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgcmV0dXJuIGNvbG9yICYmIHR5cGVvZiBjb2xvci5yID09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICYmIHR5cGVvZiBjb2xvci5nID09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICYmIHR5cGVvZiBjb2xvci5iID09ICdudW1iZXInXG4gIH1cbiAgXG4gIC8vIFRlc3QgaWYgZ2l2ZW4gdmFsdWUgaXMgYSBjb2xvclxuICBTVkcuQ29sb3IuaXNDb2xvciA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgcmV0dXJuIFNWRy5Db2xvci5pc1JnYihjb2xvcikgfHwgU1ZHLkNvbG9yLnRlc3QoY29sb3IpXG4gIH1cblxuICBTVkcuQXJyYXkgPSBmdW5jdGlvbihhcnJheSwgZmFsbGJhY2spIHtcbiAgICBhcnJheSA9IChhcnJheSB8fCBbXSkudmFsdWVPZigpXG4gIFxuICAgIC8qIGlmIGFycmF5IGlzIGVtcHR5IGFuZCBmYWxsYmFjayBpcyBwcm92aWRlZCwgdXNlIGZhbGxiYWNrICovXG4gICAgaWYgKGFycmF5Lmxlbmd0aCA9PSAwICYmIGZhbGxiYWNrKVxuICAgICAgYXJyYXkgPSBmYWxsYmFjay52YWx1ZU9mKClcbiAgXG4gICAgLyogcGFyc2UgYXJyYXkgKi9cbiAgICB0aGlzLnZhbHVlID0gdGhpcy5wYXJzZShhcnJheSlcbiAgfVxuICBcbiAgU1ZHLmV4dGVuZChTVkcuQXJyYXksIHtcbiAgICAvLyBNYWtlIGFycmF5IG1vcnBoYWJsZVxuICAgIG1vcnBoOiBmdW5jdGlvbihhcnJheSkge1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IHRoaXMucGFyc2UoYXJyYXkpXG4gIFxuICAgICAgLyogbm9ybWFsaXplIGxlbmd0aCBvZiBhcnJheXMgKi9cbiAgICAgIGlmICh0aGlzLnZhbHVlLmxlbmd0aCAhPSB0aGlzLmRlc3RpbmF0aW9uLmxlbmd0aCkge1xuICAgICAgICB2YXIgbGFzdFZhbHVlICAgICAgID0gdGhpcy52YWx1ZVt0aGlzLnZhbHVlLmxlbmd0aCAtIDFdXG4gICAgICAgICAgLCBsYXN0RGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uW3RoaXMuZGVzdGluYXRpb24ubGVuZ3RoIC0gMV1cbiAgXG4gICAgICAgIHdoaWxlKHRoaXMudmFsdWUubGVuZ3RoID4gdGhpcy5kZXN0aW5hdGlvbi5sZW5ndGgpXG4gICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5wdXNoKGxhc3REZXN0aW5hdGlvbilcbiAgICAgICAgd2hpbGUodGhpcy52YWx1ZS5sZW5ndGggPCB0aGlzLmRlc3RpbmF0aW9uLmxlbmd0aClcbiAgICAgICAgICB0aGlzLnZhbHVlLnB1c2gobGFzdFZhbHVlKVxuICAgICAgfVxuICBcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIC8vIENsZWFuIHVwIGFueSBkdXBsaWNhdGUgcG9pbnRzXG4gICwgc2V0dGxlOiBmdW5jdGlvbigpIHtcbiAgICAgIC8qIGZpbmQgYWxsIHVuaXF1ZSB2YWx1ZXMgKi9cbiAgICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHRoaXMudmFsdWUubGVuZ3RoLCBzZWVuID0gW107IGkgPCBpbDsgaSsrKVxuICAgICAgICBpZiAoc2Vlbi5pbmRleE9mKHRoaXMudmFsdWVbaV0pID09IC0xKVxuICAgICAgICAgIHNlZW4ucHVzaCh0aGlzLnZhbHVlW2ldKVxuICBcbiAgICAgIC8qIHNldCBuZXcgdmFsdWUgKi9cbiAgICAgIHJldHVybiB0aGlzLnZhbHVlID0gc2VlblxuICAgIH1cbiAgICAvLyBHZXQgbW9ycGhlZCBhcnJheSBhdCBnaXZlbiBwb3NpdGlvblxuICAsIGF0OiBmdW5jdGlvbihwb3MpIHtcbiAgICAgIC8qIG1ha2Ugc3VyZSBhIGRlc3RpbmF0aW9uIGlzIGRlZmluZWQgKi9cbiAgICAgIGlmICghdGhpcy5kZXN0aW5hdGlvbikgcmV0dXJuIHRoaXNcbiAgXG4gICAgICAvKiBnZW5lcmF0ZSBtb3JwaGVkIGFycmF5ICovXG4gICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSB0aGlzLnZhbHVlLmxlbmd0aCwgYXJyYXkgPSBbXTsgaSA8IGlsOyBpKyspXG4gICAgICAgIGFycmF5LnB1c2godGhpcy52YWx1ZVtpXSArICh0aGlzLmRlc3RpbmF0aW9uW2ldIC0gdGhpcy52YWx1ZVtpXSkgKiBwb3MpXG4gIFxuICAgICAgcmV0dXJuIG5ldyBTVkcuQXJyYXkoYXJyYXkpXG4gICAgfVxuICAgIC8vIENvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXG4gICwgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWUuam9pbignICcpXG4gICAgfVxuICAgIC8vIFJlYWwgdmFsdWVcbiAgLCB2YWx1ZU9mOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlXG4gICAgfVxuICAgIC8vIFBhcnNlIHdoaXRlc3BhY2Ugc2VwYXJhdGVkIHN0cmluZ1xuICAsIHBhcnNlOiBmdW5jdGlvbihhcnJheSkge1xuICAgICAgYXJyYXkgPSBhcnJheS52YWx1ZU9mKClcbiAgXG4gICAgICAvKiBpZiBhbHJlYWR5IGlzIGFuIGFycmF5LCBubyBuZWVkIHRvIHBhcnNlIGl0ICovXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhcnJheSkpIHJldHVybiBhcnJheVxuICBcbiAgICAgIHJldHVybiB0aGlzLnNwbGl0KGFycmF5KVxuICAgIH1cbiAgICAvLyBTdHJpcCB1bm5lY2Vzc2FyeSB3aGl0ZXNwYWNlXG4gICwgc3BsaXQ6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9cXHMrL2csICcgJykucmVwbGFjZSgvXlxccyt8XFxzKyQvZywnJykuc3BsaXQoJyAnKSBcbiAgICB9XG4gICAgLy8gUmV2ZXJzZSBhcnJheVxuICAsIHJldmVyc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy52YWx1ZS5yZXZlcnNlKClcbiAgXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgXG4gIH0pXG4gIFxuXG5cbiAgU1ZHLlBvaW50QXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxuICBcbiAgLy8gSW5oZXJpdCBmcm9tIFNWRy5BcnJheVxuICBTVkcuUG9pbnRBcnJheS5wcm90b3R5cGUgPSBuZXcgU1ZHLkFycmF5XG4gIFxuICBTVkcuZXh0ZW5kKFNWRy5Qb2ludEFycmF5LCB7XG4gICAgLy8gQ29udmVydCBhcnJheSB0byBzdHJpbmdcbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAvKiBjb252ZXJ0IHRvIGEgcG9seSBwb2ludCBzdHJpbmcgKi9cbiAgICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHRoaXMudmFsdWUubGVuZ3RoLCBhcnJheSA9IFtdOyBpIDwgaWw7IGkrKylcbiAgICAgICAgYXJyYXkucHVzaCh0aGlzLnZhbHVlW2ldLmpvaW4oJywnKSlcbiAgXG4gICAgICByZXR1cm4gYXJyYXkuam9pbignICcpXG4gICAgfVxuICAgIC8vIEdldCBtb3JwaGVkIGFycmF5IGF0IGdpdmVuIHBvc2l0aW9uXG4gICwgYXQ6IGZ1bmN0aW9uKHBvcykge1xuICAgICAgLyogbWFrZSBzdXJlIGEgZGVzdGluYXRpb24gaXMgZGVmaW5lZCAqL1xuICAgICAgaWYgKCF0aGlzLmRlc3RpbmF0aW9uKSByZXR1cm4gdGhpc1xuICBcbiAgICAgIC8qIGdlbmVyYXRlIG1vcnBoZWQgcG9pbnQgc3RyaW5nICovXG4gICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSB0aGlzLnZhbHVlLmxlbmd0aCwgYXJyYXkgPSBbXTsgaSA8IGlsOyBpKyspXG4gICAgICAgIGFycmF5LnB1c2goW1xuICAgICAgICAgIHRoaXMudmFsdWVbaV1bMF0gKyAodGhpcy5kZXN0aW5hdGlvbltpXVswXSAtIHRoaXMudmFsdWVbaV1bMF0pICogcG9zXG4gICAgICAgICwgdGhpcy52YWx1ZVtpXVsxXSArICh0aGlzLmRlc3RpbmF0aW9uW2ldWzFdIC0gdGhpcy52YWx1ZVtpXVsxXSkgKiBwb3NcbiAgICAgICAgXSlcbiAgXG4gICAgICByZXR1cm4gbmV3IFNWRy5Qb2ludEFycmF5KGFycmF5KVxuICAgIH1cbiAgICAvLyBQYXJzZSBwb2ludCBzdHJpbmdcbiAgLCBwYXJzZTogZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgIGFycmF5ID0gYXJyYXkudmFsdWVPZigpXG4gIFxuICAgICAgLyogaWYgYWxyZWFkeSBpcyBhbiBhcnJheSwgbm8gbmVlZCB0byBwYXJzZSBpdCAqL1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXkpKSByZXR1cm4gYXJyYXlcbiAgXG4gICAgICAvKiBzcGxpdCBwb2ludHMgKi9cbiAgICAgIGFycmF5ID0gdGhpcy5zcGxpdChhcnJheSlcbiAgXG4gICAgICAvKiBwYXJzZSBwb2ludHMgKi9cbiAgICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGFycmF5Lmxlbmd0aCwgcCwgcG9pbnRzID0gW107IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIHAgPSBhcnJheVtpXS5zcGxpdCgnLCcpXG4gICAgICAgIHBvaW50cy5wdXNoKFtwYXJzZUZsb2F0KHBbMF0pLCBwYXJzZUZsb2F0KHBbMV0pXSlcbiAgICAgIH1cbiAgXG4gICAgICByZXR1cm4gcG9pbnRzXG4gICAgfVxuICAgIC8vIE1vdmUgcG9pbnQgc3RyaW5nXG4gICwgbW92ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgdmFyIGJveCA9IHRoaXMuYmJveCgpXG4gIFxuICAgICAgLyogZ2V0IHJlbGF0aXZlIG9mZnNldCAqL1xuICAgICAgeCAtPSBib3gueFxuICAgICAgeSAtPSBib3gueVxuICBcbiAgICAgIC8qIG1vdmUgZXZlcnkgcG9pbnQgKi9cbiAgICAgIGlmICghaXNOYU4oeCkgJiYgIWlzTmFOKHkpKVxuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy52YWx1ZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICB0aGlzLnZhbHVlW2ldID0gW3RoaXMudmFsdWVbaV1bMF0gKyB4LCB0aGlzLnZhbHVlW2ldWzFdICsgeV1cbiAgXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICAvLyBSZXNpemUgcG9seSBzdHJpbmdcbiAgLCBzaXplOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB2YXIgaSwgYm94ID0gdGhpcy5iYm94KClcbiAgXG4gICAgICAvKiByZWNhbGN1bGF0ZSBwb3NpdGlvbiBvZiBhbGwgcG9pbnRzIGFjY29yZGluZyB0byBuZXcgc2l6ZSAqL1xuICAgICAgZm9yIChpID0gdGhpcy52YWx1ZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB0aGlzLnZhbHVlW2ldWzBdID0gKCh0aGlzLnZhbHVlW2ldWzBdIC0gYm94LngpICogd2lkdGgpICAvIGJveC53aWR0aCAgKyBib3gueFxuICAgICAgICB0aGlzLnZhbHVlW2ldWzFdID0gKCh0aGlzLnZhbHVlW2ldWzFdIC0gYm94LnkpICogaGVpZ2h0KSAvIGJveC5oZWlnaHQgKyBib3gueVxuICAgICAgfVxuICBcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIC8vIEdldCBib3VuZGluZyBib3ggb2YgcG9pbnRzXG4gICwgYmJveDogZnVuY3Rpb24oKSB7XG4gICAgICBTVkcucGFyc2VyLnBvbHkuc2V0QXR0cmlidXRlKCdwb2ludHMnLCB0aGlzLnRvU3RyaW5nKCkpXG4gIFxuICAgICAgcmV0dXJuIFNWRy5wYXJzZXIucG9seS5nZXRCQm94KClcbiAgICB9XG4gIFxuICB9KVxuXG4gIFNWRy5QYXRoQXJyYXkgPSBmdW5jdGlvbihhcnJheSwgZmFsbGJhY2spIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgYXJyYXksIGZhbGxiYWNrKVxuICB9XG4gIFxuICAvLyBJbmhlcml0IGZyb20gU1ZHLkFycmF5XG4gIFNWRy5QYXRoQXJyYXkucHJvdG90eXBlID0gbmV3IFNWRy5BcnJheVxuICBcbiAgU1ZHLmV4dGVuZChTVkcuUGF0aEFycmF5LCB7XG4gICAgLy8gQ29udmVydCBhcnJheSB0byBzdHJpbmdcbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYXJyYXlUb1N0cmluZyh0aGlzLnZhbHVlKVxuICAgIH1cbiAgICAvLyBNb3ZlIHBhdGggc3RyaW5nXG4gICwgbW92ZTogZnVuY3Rpb24oeCwgeSkge1xuICBcdFx0LyogZ2V0IGJvdW5kaW5nIGJveCBvZiBjdXJyZW50IHNpdHVhdGlvbiAqL1xuICBcdFx0dmFyIGJveCA9IHRoaXMuYmJveCgpXG4gIFx0XHRcbiAgICAgIC8qIGdldCByZWxhdGl2ZSBvZmZzZXQgKi9cbiAgICAgIHggLT0gYm94LnhcbiAgICAgIHkgLT0gYm94LnlcbiAgXG4gICAgICBpZiAoIWlzTmFOKHgpICYmICFpc05hTih5KSkge1xuICAgICAgICAvKiBtb3ZlIGV2ZXJ5IHBvaW50ICovXG4gICAgICAgIGZvciAodmFyIGwsIGkgPSB0aGlzLnZhbHVlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgbCA9IHRoaXMudmFsdWVbaV1bMF1cbiAgXG4gICAgICAgICAgaWYgKGwgPT0gJ00nIHx8IGwgPT0gJ0wnIHx8IGwgPT0gJ1QnKSAge1xuICAgICAgICAgICAgdGhpcy52YWx1ZVtpXVsxXSArPSB4XG4gICAgICAgICAgICB0aGlzLnZhbHVlW2ldWzJdICs9IHlcbiAgXG4gICAgICAgICAgfSBlbHNlIGlmIChsID09ICdIJykgIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVbaV1bMV0gKz0geFxuICBcbiAgICAgICAgICB9IGVsc2UgaWYgKGwgPT0gJ1YnKSAge1xuICAgICAgICAgICAgdGhpcy52YWx1ZVtpXVsxXSArPSB5XG4gIFxuICAgICAgICAgIH0gZWxzZSBpZiAobCA9PSAnQycgfHwgbCA9PSAnUycgfHwgbCA9PSAnUScpICB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlW2ldWzFdICs9IHhcbiAgICAgICAgICAgIHRoaXMudmFsdWVbaV1bMl0gKz0geVxuICAgICAgICAgICAgdGhpcy52YWx1ZVtpXVszXSArPSB4XG4gICAgICAgICAgICB0aGlzLnZhbHVlW2ldWzRdICs9IHlcbiAgXG4gICAgICAgICAgICBpZiAobCA9PSAnQycpICB7XG4gICAgICAgICAgICAgIHRoaXMudmFsdWVbaV1bNV0gKz0geFxuICAgICAgICAgICAgICB0aGlzLnZhbHVlW2ldWzZdICs9IHlcbiAgICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgfSBlbHNlIGlmIChsID09ICdBJykgIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVbaV1bNl0gKz0geFxuICAgICAgICAgICAgdGhpcy52YWx1ZVtpXVs3XSArPSB5XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgfVxuICAgICAgfVxuICBcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIC8vIFJlc2l6ZSBwYXRoIHN0cmluZ1xuICAsIHNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgXHRcdC8qIGdldCBib3VuZGluZyBib3ggb2YgY3VycmVudCBzaXR1YXRpb24gKi9cbiAgXHRcdHZhciBpLCBsLCBib3ggPSB0aGlzLmJib3goKVxuICBcbiAgICAgIC8qIHJlY2FsY3VsYXRlIHBvc2l0aW9uIG9mIGFsbCBwb2ludHMgYWNjb3JkaW5nIHRvIG5ldyBzaXplICovXG4gICAgICBmb3IgKGkgPSB0aGlzLnZhbHVlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGwgPSB0aGlzLnZhbHVlW2ldWzBdXG4gIFxuICAgICAgICBpZiAobCA9PSAnTScgfHwgbCA9PSAnTCcgfHwgbCA9PSAnVCcpICB7XG4gICAgICAgICAgdGhpcy52YWx1ZVtpXVsxXSA9ICgodGhpcy52YWx1ZVtpXVsxXSAtIGJveC54KSAqIHdpZHRoKSAgLyBib3gud2lkdGggICsgYm94LnhcbiAgICAgICAgICB0aGlzLnZhbHVlW2ldWzJdID0gKCh0aGlzLnZhbHVlW2ldWzJdIC0gYm94LnkpICogaGVpZ2h0KSAvIGJveC5oZWlnaHQgKyBib3gueVxuICBcbiAgICAgICAgfSBlbHNlIGlmIChsID09ICdIJykgIHtcbiAgICAgICAgICB0aGlzLnZhbHVlW2ldWzFdID0gKCh0aGlzLnZhbHVlW2ldWzFdIC0gYm94LngpICogd2lkdGgpICAvIGJveC53aWR0aCAgKyBib3gueFxuICBcbiAgICAgICAgfSBlbHNlIGlmIChsID09ICdWJykgIHtcbiAgICAgICAgICB0aGlzLnZhbHVlW2ldWzFdID0gKCh0aGlzLnZhbHVlW2ldWzFdIC0gYm94LnkpICogaGVpZ2h0KSAvIGJveC5oZWlnaHQgKyBib3gueVxuICBcbiAgICAgICAgfSBlbHNlIGlmIChsID09ICdDJyB8fCBsID09ICdTJyB8fCBsID09ICdRJykgIHtcbiAgICAgICAgICB0aGlzLnZhbHVlW2ldWzFdID0gKCh0aGlzLnZhbHVlW2ldWzFdIC0gYm94LngpICogd2lkdGgpICAvIGJveC53aWR0aCAgKyBib3gueFxuICAgICAgICAgIHRoaXMudmFsdWVbaV1bMl0gPSAoKHRoaXMudmFsdWVbaV1bMl0gLSBib3gueSkgKiBoZWlnaHQpIC8gYm94LmhlaWdodCArIGJveC55XG4gICAgICAgICAgdGhpcy52YWx1ZVtpXVszXSA9ICgodGhpcy52YWx1ZVtpXVszXSAtIGJveC54KSAqIHdpZHRoKSAgLyBib3gud2lkdGggICsgYm94LnhcbiAgICAgICAgICB0aGlzLnZhbHVlW2ldWzRdID0gKCh0aGlzLnZhbHVlW2ldWzRdIC0gYm94LnkpICogaGVpZ2h0KSAvIGJveC5oZWlnaHQgKyBib3gueVxuICBcbiAgICAgICAgICBpZiAobCA9PSAnQycpICB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlW2ldWzVdID0gKCh0aGlzLnZhbHVlW2ldWzVdIC0gYm94LngpICogd2lkdGgpICAvIGJveC53aWR0aCAgKyBib3gueFxuICAgICAgICAgICAgdGhpcy52YWx1ZVtpXVs2XSA9ICgodGhpcy52YWx1ZVtpXVs2XSAtIGJveC55KSAqIGhlaWdodCkgLyBib3guaGVpZ2h0ICsgYm94LnlcbiAgICAgICAgICB9XG4gIFxuICAgICAgICB9IGVsc2UgaWYgKGwgPT0gJ0EnKSAge1xuICAgICAgICAgIC8qIHJlc2l6ZSByYWRpaSAqL1xuICAgICAgICAgIHRoaXMudmFsdWVbaV1bMV0gPSAodGhpcy52YWx1ZVtpXVsxXSAqIHdpZHRoKSAgLyBib3gud2lkdGhcbiAgICAgICAgICB0aGlzLnZhbHVlW2ldWzJdID0gKHRoaXMudmFsdWVbaV1bMl0gKiBoZWlnaHQpIC8gYm94LmhlaWdodFxuICBcbiAgICAgICAgICAvKiBtb3ZlIHBvc2l0aW9uIHZhbHVlcyAqL1xuICAgICAgICAgIHRoaXMudmFsdWVbaV1bNl0gPSAoKHRoaXMudmFsdWVbaV1bNl0gLSBib3gueCkgKiB3aWR0aCkgIC8gYm94LndpZHRoICArIGJveC54XG4gICAgICAgICAgdGhpcy52YWx1ZVtpXVs3XSA9ICgodGhpcy52YWx1ZVtpXVs3XSAtIGJveC55KSAqIGhlaWdodCkgLyBib3guaGVpZ2h0ICsgYm94LnlcbiAgICAgICAgfVxuICBcbiAgICAgIH1cbiAgXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICAvLyBBYnNvbHV0aXplIGFuZCBwYXJzZSBwYXRoIHRvIGFycmF5XG4gICwgcGFyc2U6IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICAvKiBpZiBpdCdzIGFscmVhZHkgaXMgYSBwYXRoYXJyYXksIG5vIG5lZWQgdG8gcGFyc2UgaXQgKi9cbiAgICAgIGlmIChhcnJheSBpbnN0YW5jZW9mIFNWRy5QYXRoQXJyYXkpIHJldHVybiBhcnJheS52YWx1ZU9mKClcbiAgXG4gICAgICAvKiBwcmVwYXJlIGZvciBwYXJzaW5nICovXG4gICAgICB2YXIgaSwgaWwsIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHMsIHNlZywgc2Vnc1xuICAgICAgICAsIHggPSAwXG4gICAgICAgICwgeSA9IDBcbiAgICAgIFxuICAgICAgLyogcG9wdWxhdGUgd29ya2luZyBwYXRoICovXG4gICAgICBTVkcucGFyc2VyLnBhdGguc2V0QXR0cmlidXRlKCdkJywgdHlwZW9mIGFycmF5ID09PSAnc3RyaW5nJyA/IGFycmF5IDogYXJyYXlUb1N0cmluZyhhcnJheSkpXG4gICAgICBcbiAgICAgIC8qIGdldCBzZWdtZW50cyAqL1xuICAgICAgc2VncyA9IFNWRy5wYXJzZXIucGF0aC5wYXRoU2VnTGlzdFxuICBcbiAgICAgIGZvciAoaSA9IDAsIGlsID0gc2Vncy5udW1iZXJPZkl0ZW1zOyBpIDwgaWw7ICsraSkge1xuICAgICAgICBzZWcgPSBzZWdzLmdldEl0ZW0oaSlcbiAgICAgICAgcyA9IHNlZy5wYXRoU2VnVHlwZUFzTGV0dGVyXG4gIFxuICAgICAgICAvKiB5ZXMsIHRoaXMgSVMgcXVpdGUgdmVyYm9zZSBidXQgYWxzbyBhYm91dCAzMCB0aW1lcyBmYXN0ZXIgdGhhbiAudGVzdCgpIHdpdGggYSBwcmVjb21waWxlZCByZWdleCAqL1xuICAgICAgICBpZiAocyA9PSAnTScgfHwgcyA9PSAnTCcgfHwgcyA9PSAnSCcgfHwgcyA9PSAnVicgfHwgcyA9PSAnQycgfHwgcyA9PSAnUycgfHwgcyA9PSAnUScgfHwgcyA9PSAnVCcgfHwgcyA9PSAnQScpIHtcbiAgICAgICAgICBpZiAoJ3gnIGluIHNlZykgeCA9IHNlZy54XG4gICAgICAgICAgaWYgKCd5JyBpbiBzZWcpIHkgPSBzZWcueVxuICBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoJ3gxJyBpbiBzZWcpIHgxID0geCArIHNlZy54MVxuICAgICAgICAgIGlmICgneDInIGluIHNlZykgeDIgPSB4ICsgc2VnLngyXG4gICAgICAgICAgaWYgKCd5MScgaW4gc2VnKSB5MSA9IHkgKyBzZWcueTFcbiAgICAgICAgICBpZiAoJ3kyJyBpbiBzZWcpIHkyID0geSArIHNlZy55MlxuICAgICAgICAgIGlmICgneCcgIGluIHNlZykgeCArPSBzZWcueFxuICAgICAgICAgIGlmICgneScgIGluIHNlZykgeSArPSBzZWcueVxuICBcbiAgICAgICAgICBpZiAocyA9PSAnbScpXG4gICAgICAgICAgICBzZWdzLnJlcGxhY2VJdGVtKFNWRy5wYXJzZXIucGF0aC5jcmVhdGVTVkdQYXRoU2VnTW92ZXRvQWJzKHgsIHkpLCBpKVxuICAgICAgICAgIGVsc2UgaWYgKHMgPT0gJ2wnKVxuICAgICAgICAgICAgc2Vncy5yZXBsYWNlSXRlbShTVkcucGFyc2VyLnBhdGguY3JlYXRlU1ZHUGF0aFNlZ0xpbmV0b0Ficyh4LCB5KSwgaSlcbiAgICAgICAgICBlbHNlIGlmIChzID09ICdoJylcbiAgICAgICAgICAgIHNlZ3MucmVwbGFjZUl0ZW0oU1ZHLnBhcnNlci5wYXRoLmNyZWF0ZVNWR1BhdGhTZWdMaW5ldG9Ib3Jpem9udGFsQWJzKHgpLCBpKVxuICAgICAgICAgIGVsc2UgaWYgKHMgPT0gJ3YnKVxuICAgICAgICAgICAgc2Vncy5yZXBsYWNlSXRlbShTVkcucGFyc2VyLnBhdGguY3JlYXRlU1ZHUGF0aFNlZ0xpbmV0b1ZlcnRpY2FsQWJzKHkpLCBpKVxuICAgICAgICAgIGVsc2UgaWYgKHMgPT0gJ2MnKVxuICAgICAgICAgICAgc2Vncy5yZXBsYWNlSXRlbShTVkcucGFyc2VyLnBhdGguY3JlYXRlU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY0Ficyh4LCB5LCB4MSwgeTEsIHgyLCB5MiksIGkpXG4gICAgICAgICAgZWxzZSBpZiAocyA9PSAncycpXG4gICAgICAgICAgICBzZWdzLnJlcGxhY2VJdGVtKFNWRy5wYXJzZXIucGF0aC5jcmVhdGVTVkdQYXRoU2VnQ3VydmV0b0N1YmljU21vb3RoQWJzKHgsIHksIHgyLCB5MiksIGkpXG4gICAgICAgICAgZWxzZSBpZiAocyA9PSAncScpXG4gICAgICAgICAgICBzZWdzLnJlcGxhY2VJdGVtKFNWRy5wYXJzZXIucGF0aC5jcmVhdGVTVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY0Ficyh4LCB5LCB4MSwgeTEpLCBpKVxuICAgICAgICAgIGVsc2UgaWYgKHMgPT0gJ3QnKVxuICAgICAgICAgICAgc2Vncy5yZXBsYWNlSXRlbShTVkcucGFyc2VyLnBhdGguY3JlYXRlU1ZHUGF0aFNlZ0N1cnZldG9RdWFkcmF0aWNTbW9vdGhBYnMoeCwgeSksIGkpXG4gICAgICAgICAgZWxzZSBpZiAocyA9PSAnYScpXG4gICAgICAgICAgICBzZWdzLnJlcGxhY2VJdGVtKFNWRy5wYXJzZXIucGF0aC5jcmVhdGVTVkdQYXRoU2VnQXJjQWJzKHgsIHksIHNlZy5yMSwgc2VnLnIyLCBzZWcuYW5nbGUsIHNlZy5sYXJnZUFyY0ZsYWcsIHNlZy5zd2VlcEZsYWcpLCBpKVxuICAgICAgICAgIGVsc2UgaWYgKHMgPT0gJ3onIHx8IHMgPT0gJ1onKSB7XG4gICAgICAgICAgICB4ID0geDBcbiAgICAgICAgICAgIHkgPSB5MFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICBcbiAgICAgICAgLyogcmVjb3JkIHRoZSBzdGFydCBvZiBhIHN1YnBhdGggKi9cbiAgICAgICAgaWYgKHMgPT0gJ00nIHx8IHMgPT0gJ20nKSB7XG4gICAgICAgICAgeDAgPSB4XG4gICAgICAgICAgeTAgPSB5XG4gICAgICAgIH1cbiAgICAgIH1cbiAgXG4gICAgICAvKiBidWlsZCBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiAqL1xuICAgICAgYXJyYXkgPSBbXVxuICAgICAgc2VncyAgPSBTVkcucGFyc2VyLnBhdGgucGF0aFNlZ0xpc3RcbiAgICAgIFxuICAgICAgZm9yIChpID0gMCwgaWwgPSBzZWdzLm51bWJlck9mSXRlbXM7IGkgPCBpbDsgKytpKSB7XG4gICAgICAgIHNlZyA9IHNlZ3MuZ2V0SXRlbShpKVxuICAgICAgICBzID0gc2VnLnBhdGhTZWdUeXBlQXNMZXR0ZXJcbiAgICAgICAgeCA9IFtzXVxuICBcbiAgICAgICAgaWYgKHMgPT0gJ00nIHx8IHMgPT0gJ0wnIHx8IHMgPT0gJ1QnKVxuICAgICAgICAgIHgucHVzaChzZWcueCwgc2VnLnkpXG4gICAgICAgIGVsc2UgaWYgKHMgPT0gJ0gnKVxuICAgICAgICAgIHgucHVzaChzZWcueClcbiAgICAgICAgZWxzZSBpZiAocyA9PSAnVicpXG4gICAgICAgICAgeC5wdXNoKHNlZy55KVxuICAgICAgICBlbHNlIGlmIChzID09ICdDJylcbiAgICAgICAgICB4LnB1c2goc2VnLngxLCBzZWcueTEsIHNlZy54Miwgc2VnLnkyLCBzZWcueCwgc2VnLnkpXG4gICAgICAgIGVsc2UgaWYgKHMgPT0gJ1MnKVxuICAgICAgICAgIHgucHVzaChzZWcueDIsIHNlZy55Miwgc2VnLngsIHNlZy55KVxuICAgICAgICBlbHNlIGlmIChzID09ICdRJylcbiAgICAgICAgICB4LnB1c2goc2VnLngxLCBzZWcueTEsIHNlZy54LCBzZWcueSlcbiAgICAgICAgZWxzZSBpZiAocyA9PSAnQScpXG4gICAgICAgICAgeC5wdXNoKHNlZy5yMSwgc2VnLnIyLCBzZWcuYW5nbGUsIHNlZy5sYXJnZUFyY0ZsYWd8MCwgc2VnLnN3ZWVwRmxhZ3wwLCBzZWcueCwgc2VnLnkpXG4gIFxuICAgICAgICAvKiBzdG9yZSBzZWdtZW50ICovXG4gICAgICAgIGFycmF5LnB1c2goeClcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGFycmF5XG4gICAgfVxuICAgIC8vIEdldCBib3VuZGluZyBib3ggb2YgcGF0aFxuICAsIGJib3g6IGZ1bmN0aW9uKCkge1xuICAgICAgU1ZHLnBhcnNlci5wYXRoLnNldEF0dHJpYnV0ZSgnZCcsIHRoaXMudG9TdHJpbmcoKSlcbiAgXG4gICAgICByZXR1cm4gU1ZHLnBhcnNlci5wYXRoLmdldEJCb3goKVxuICAgIH1cbiAgXG4gIH0pXG5cbiAgU1ZHLk51bWJlciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIFxuICAgIC8qIGluaXRpYWxpemUgZGVmYXVsdHMgKi9cbiAgICB0aGlzLnZhbHVlID0gMFxuICAgIHRoaXMudW5pdCA9ICcnXG4gIFxuICAgIC8qIHBhcnNlIHZhbHVlICovXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8qIGVuc3VyZSBhIHZhbGlkIG51bWVyaWMgdmFsdWUgKi9cbiAgICAgIHRoaXMudmFsdWUgPSBpc05hTih2YWx1ZSkgPyAwIDogIWlzRmluaXRlKHZhbHVlKSA/ICh2YWx1ZSA8IDAgPyAtMy40ZSszOCA6ICszLjRlKzM4KSA6IHZhbHVlXG4gIFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIG1hdGNoID0gdmFsdWUubWF0Y2goU1ZHLnJlZ2V4LnVuaXQpXG4gIFxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIC8qIG1ha2UgdmFsdWUgbnVtZXJpYyAqL1xuICAgICAgICB0aGlzLnZhbHVlID0gcGFyc2VGbG9hdChtYXRjaFsxXSlcbiAgICAgIFxuICAgICAgICAvKiBub3JtYWxpemUgcGVyY2VudCB2YWx1ZSAqL1xuICAgICAgICBpZiAobWF0Y2hbMl0gPT0gJyUnKVxuICAgICAgICAgIHRoaXMudmFsdWUgLz0gMTAwXG4gICAgICAgIGVsc2UgaWYgKG1hdGNoWzJdID09ICdzJylcbiAgICAgICAgICB0aGlzLnZhbHVlICo9IDEwMDBcbiAgICAgIFxuICAgICAgICAvKiBzdG9yZSB1bml0ICovXG4gICAgICAgIHRoaXMudW5pdCA9IG1hdGNoWzJdXG4gICAgICB9XG4gIFxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTVkcuTnVtYmVyKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZS52YWx1ZVxuICAgICAgICB0aGlzLnVuaXQgID0gdmFsdWUudW5pdFxuICAgICAgfVxuICAgIH1cbiAgXG4gIH1cbiAgXG4gIFNWRy5leHRlbmQoU1ZHLk51bWJlciwge1xuICAgIC8vIFN0cmluZ2FsaXplXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy51bml0ID09ICclJyA/XG4gICAgICAgICAgfn4odGhpcy52YWx1ZSAqIDFlOCkgLyAxZTY6XG4gICAgICAgIHRoaXMudW5pdCA9PSAncycgP1xuICAgICAgICAgIHRoaXMudmFsdWUgLyAxZTMgOlxuICAgICAgICAgIHRoaXMudmFsdWVcbiAgICAgICkgKyB0aGlzLnVuaXRcbiAgICB9XG4gICwgLy8gQ29udmVydCB0byBwcmltaXRpdmVcbiAgICB2YWx1ZU9mOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlXG4gICAgfVxuICAgIC8vIEFkZCBudW1iZXJcbiAgLCBwbHVzOiBmdW5jdGlvbihudW1iZXIpIHtcbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzICsgbmV3IFNWRy5OdW1iZXIobnVtYmVyKVxuICBcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIC8vIFN1YnRyYWN0IG51bWJlclxuICAsIG1pbnVzOiBmdW5jdGlvbihudW1iZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLnBsdXMoLW5ldyBTVkcuTnVtYmVyKG51bWJlcikpXG4gICAgfVxuICAgIC8vIE11bHRpcGx5IG51bWJlclxuICAsIHRpbWVzOiBmdW5jdGlvbihudW1iZXIpIHtcbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzICogbmV3IFNWRy5OdW1iZXIobnVtYmVyKVxuICBcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIC8vIERpdmlkZSBudW1iZXJcbiAgLCBkaXZpZGU6IGZ1bmN0aW9uKG51bWJlcikge1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMgLyBuZXcgU1ZHLk51bWJlcihudW1iZXIpXG4gIFxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgLy8gQ29udmVydCB0byBkaWZmZXJlbnQgdW5pdFxuICAsIHRvOiBmdW5jdGlvbih1bml0KSB7XG4gICAgICBpZiAodHlwZW9mIHVuaXQgPT09ICdzdHJpbmcnKVxuICAgICAgICB0aGlzLnVuaXQgPSB1bml0XG4gIFxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgLy8gTWFrZSBudW1iZXIgbW9ycGhhYmxlXG4gICwgbW9ycGg6IGZ1bmN0aW9uKG51bWJlcikge1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTVkcuTnVtYmVyKG51bWJlcilcbiAgXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICAvLyBHZXQgbW9ycGhlZCBudW1iZXIgYXQgZ2l2ZW4gcG9zaXRpb25cbiAgLCBhdDogZnVuY3Rpb24ocG9zKSB7XG4gICAgICAvKiBtYWtlIHN1cmUgYSBkZXN0aW5hdGlvbiBpcyBkZWZpbmVkICovXG4gICAgICBpZiAoIXRoaXMuZGVzdGluYXRpb24pIHJldHVybiB0aGlzXG4gIFxuICAgICAgLyogZ2VuZXJhdGUgbmV3IG1vcnBoZWQgbnVtYmVyICovXG4gICAgICByZXR1cm4gbmV3IFNWRy5OdW1iZXIodGhpcy5kZXN0aW5hdGlvbilcbiAgICAgICAgICAubWludXModGhpcylcbiAgICAgICAgICAudGltZXMocG9zKVxuICAgICAgICAgIC5wbHVzKHRoaXMpXG4gICAgfVxuICBcbiAgfSlcblxuICBTVkcuVmlld0JveCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICB2YXIgeCwgeSwgd2lkdGgsIGhlaWdodFxuICAgICAgLCB3bSAgID0gMSAvKiB3aWR0aCBtdWx0aXBsaWVyICovXG4gICAgICAsIGhtICAgPSAxIC8qIGhlaWdodCBtdWx0aXBsaWVyICovXG4gICAgICAsIGJveCAgPSBlbGVtZW50LmJib3goKVxuICAgICAgLCB2aWV3ID0gKGVsZW1lbnQuYXR0cigndmlld0JveCcpIHx8ICcnKS5tYXRjaCgvLT9bXFxkXFwuXSsvZylcbiAgICAgICwgd2UgICA9IGVsZW1lbnRcbiAgICAgICwgaGUgICA9IGVsZW1lbnRcbiAgXG4gICAgLyogZ2V0IGRpbWVuc2lvbnMgb2YgY3VycmVudCBub2RlICovXG4gICAgd2lkdGggID0gbmV3IFNWRy5OdW1iZXIoZWxlbWVudC53aWR0aCgpKVxuICAgIGhlaWdodCA9IG5ldyBTVkcuTnVtYmVyKGVsZW1lbnQuaGVpZ2h0KCkpXG4gIFxuICAgIC8qIGZpbmQgbmVhcmVzdCBub24tcGVyY2VudHVhbCBkaW1lbnNpb25zICovXG4gICAgd2hpbGUgKHdpZHRoLnVuaXQgPT0gJyUnKSB7XG4gICAgICB3bSAqPSB3aWR0aC52YWx1ZVxuICAgICAgd2lkdGggPSBuZXcgU1ZHLk51bWJlcih3ZSBpbnN0YW5jZW9mIFNWRy5Eb2MgPyB3ZS5wYXJlbnQub2Zmc2V0V2lkdGggOiB3ZS5wYXJlbnQud2lkdGgoKSlcbiAgICAgIHdlID0gd2UucGFyZW50XG4gICAgfVxuICAgIHdoaWxlIChoZWlnaHQudW5pdCA9PSAnJScpIHtcbiAgICAgIGhtICo9IGhlaWdodC52YWx1ZVxuICAgICAgaGVpZ2h0ID0gbmV3IFNWRy5OdW1iZXIoaGUgaW5zdGFuY2VvZiBTVkcuRG9jID8gaGUucGFyZW50Lm9mZnNldEhlaWdodCA6IGhlLnBhcmVudC5oZWlnaHQoKSlcbiAgICAgIGhlID0gaGUucGFyZW50XG4gICAgfVxuICAgIFxuICAgIC8qIGVuc3VyZSBkZWZhdWx0cyAqL1xuICAgIHRoaXMueCAgICAgID0gYm94LnhcbiAgICB0aGlzLnkgICAgICA9IGJveC55XG4gICAgdGhpcy53aWR0aCAgPSB3aWR0aCAgKiB3bVxuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0ICogaG1cbiAgICB0aGlzLnpvb20gICA9IDFcbiAgICBcbiAgICBpZiAodmlldykge1xuICAgICAgLyogZ2V0IHdpZHRoIGFuZCBoZWlnaHQgZnJvbSB2aWV3Ym94ICovXG4gICAgICB4ICAgICAgPSBwYXJzZUZsb2F0KHZpZXdbMF0pXG4gICAgICB5ICAgICAgPSBwYXJzZUZsb2F0KHZpZXdbMV0pXG4gICAgICB3aWR0aCAgPSBwYXJzZUZsb2F0KHZpZXdbMl0pXG4gICAgICBoZWlnaHQgPSBwYXJzZUZsb2F0KHZpZXdbM10pXG4gICAgICBcbiAgICAgIC8qIGNhbGN1bGF0ZSB6b29tIGFjY29yaW5nIHRvIHZpZXdib3ggKi9cbiAgICAgIHRoaXMuem9vbSA9ICgodGhpcy53aWR0aCAvIHRoaXMuaGVpZ2h0KSA+ICh3aWR0aCAvIGhlaWdodCkpID9cbiAgICAgICAgdGhpcy5oZWlnaHQgLyBoZWlnaHQgOlxuICAgICAgICB0aGlzLndpZHRoICAvIHdpZHRoXG4gIFxuICAgICAgLyogY2FsY3VsYXRlIHJlYWwgcGl4ZWwgZGltZW5zaW9ucyBvbiBwYXJlbnQgU1ZHLkRvYyBlbGVtZW50ICovXG4gICAgICB0aGlzLnggICAgICA9IHhcbiAgICAgIHRoaXMueSAgICAgID0geVxuICAgICAgdGhpcy53aWR0aCAgPSB3aWR0aFxuICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHRcbiAgICAgIFxuICAgIH1cbiAgICBcbiAgfVxuICBcbiAgLy9cbiAgU1ZHLmV4dGVuZChTVkcuVmlld0JveCwge1xuICAgIC8vIFBhcnNlIHZpZXdib3ggdG8gc3RyaW5nXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMueCArICcgJyArIHRoaXMueSArICcgJyArIHRoaXMud2lkdGggKyAnICcgKyB0aGlzLmhlaWdodFxuICAgIH1cbiAgICBcbiAgfSlcblxuICBTVkcuQkJveCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICB2YXIgYm94XG4gIFxuICAgIC8qIGluaXRpYWxpemUgemVybyBib3ggKi9cbiAgICB0aGlzLnggICAgICA9IDBcbiAgICB0aGlzLnkgICAgICA9IDBcbiAgICB0aGlzLndpZHRoICA9IDBcbiAgICB0aGlzLmhlaWdodCA9IDBcbiAgICBcbiAgICAvKiBnZXQgdmFsdWVzIGlmIGVsZW1lbnQgaXMgZ2l2ZW4gKi9cbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLyogYWN0dWFsLCBuYXRpdmUgYm91bmRpbmcgYm94ICovXG4gICAgICAgIGJveCA9IGVsZW1lbnQubm9kZS5nZXRCQm94KClcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAvKiBmYWxsYmFjayBmb3Igc29tZSBicm93c2VycyAqL1xuICAgICAgICBib3ggPSB7XG4gICAgICAgICAgeDogICAgICBlbGVtZW50Lm5vZGUuY2xpZW50TGVmdFxuICAgICAgICAsIHk6ICAgICAgZWxlbWVudC5ub2RlLmNsaWVudFRvcFxuICAgICAgICAsIHdpZHRoOiAgZWxlbWVudC5ub2RlLmNsaWVudFdpZHRoXG4gICAgICAgICwgaGVpZ2h0OiBlbGVtZW50Lm5vZGUuY2xpZW50SGVpZ2h0XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogaW5jbHVkZSB0cmFuc2xhdGlvbnMgb24geCBhbiB5ICovXG4gICAgICB0aGlzLnggPSBib3gueCArIGVsZW1lbnQudHJhbnMueFxuICAgICAgdGhpcy55ID0gYm94LnkgKyBlbGVtZW50LnRyYW5zLnlcbiAgICAgIFxuICAgICAgLyogcGxhaW4gd2lkdGggYW5kIGhlaWdodCAqL1xuICAgICAgdGhpcy53aWR0aCAgPSBib3gud2lkdGggICogZWxlbWVudC50cmFucy5zY2FsZVhcbiAgICAgIHRoaXMuaGVpZ2h0ID0gYm94LmhlaWdodCAqIGVsZW1lbnQudHJhbnMuc2NhbGVZXG4gICAgfVxuICBcbiAgICAvKiBhZGQgY2VudGVyLCByaWdodCBhbmQgYm90dG9tICovXG4gICAgYm94UHJvcGVydGllcyh0aGlzKVxuICAgIFxuICB9XG4gIFxuICAvL1xuICBTVkcuZXh0ZW5kKFNWRy5CQm94LCB7XG4gICAgLy8gbWVyZ2UgYm91bmRpbmcgYm94IHdpdGggYW5vdGhlciwgcmV0dXJuIGEgbmV3IGluc3RhbmNlXG4gICAgbWVyZ2U6IGZ1bmN0aW9uKGJveCkge1xuICAgICAgdmFyIGIgPSBuZXcgU1ZHLkJCb3goKVxuICBcbiAgICAgIC8qIG1lcmdlIGJveCAqL1xuICAgICAgYi54ICAgICAgPSBNYXRoLm1pbih0aGlzLngsIGJveC54KVxuICAgICAgYi55ICAgICAgPSBNYXRoLm1pbih0aGlzLnksIGJveC55KVxuICAgICAgYi53aWR0aCAgPSBNYXRoLm1heCh0aGlzLnggKyB0aGlzLndpZHRoLCAgYm94LnggKyBib3gud2lkdGgpICAtIGIueFxuICAgICAgYi5oZWlnaHQgPSBNYXRoLm1heCh0aGlzLnkgKyB0aGlzLmhlaWdodCwgYm94LnkgKyBib3guaGVpZ2h0KSAtIGIueVxuICBcbiAgICAgIC8qIGFkZCBjZW50ZXIsIHJpZ2h0IGFuZCBib3R0b20gKi9cbiAgICAgIGJveFByb3BlcnRpZXMoYilcbiAgXG4gICAgICByZXR1cm4gYlxuICAgIH1cbiAgXG4gIH0pXG5cbiAgU1ZHLlJCb3ggPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgdmFyIGUsIHpvb21cbiAgICAgICwgYm94ID0ge31cbiAgXG4gICAgLyogaW5pdGlhbGl6ZSB6ZXJvIGJveCAqL1xuICAgIHRoaXMueCAgICAgID0gMFxuICAgIHRoaXMueSAgICAgID0gMFxuICAgIHRoaXMud2lkdGggID0gMFxuICAgIHRoaXMuaGVpZ2h0ID0gMFxuICAgIFxuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICBlID0gZWxlbWVudC5kb2MoKS5wYXJlbnRcbiAgICAgIHpvb20gPSBlbGVtZW50LmRvYygpLnZpZXdib3goKS56b29tXG4gICAgICBcbiAgICAgIC8qIGFjdHVhbCwgbmF0aXZlIGJvdW5kaW5nIGJveCAqL1xuICAgICAgYm94ID0gZWxlbWVudC5ub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICBcbiAgICAgIC8qIGdldCBzY3JlZW4gb2Zmc2V0ICovXG4gICAgICB0aGlzLnggPSBib3gubGVmdFxuICAgICAgdGhpcy55ID0gYm94LnRvcFxuICAgICAgXG4gICAgICAvKiBzdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0ICovXG4gICAgICB0aGlzLnggLT0gZS5vZmZzZXRMZWZ0XG4gICAgICB0aGlzLnkgLT0gZS5vZmZzZXRUb3BcbiAgICAgIFxuICAgICAgd2hpbGUgKGUgPSBlLm9mZnNldFBhcmVudCkge1xuICAgICAgICB0aGlzLnggLT0gZS5vZmZzZXRMZWZ0XG4gICAgICAgIHRoaXMueSAtPSBlLm9mZnNldFRvcFxuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBjYWxjdWxhdGUgY3VtdWxhdGl2ZSB6b29tIGZyb20gc3ZnIGRvY3VtZW50cyAqL1xuICAgICAgZSA9IGVsZW1lbnRcbiAgICAgIHdoaWxlIChlID0gZS5wYXJlbnQpIHtcbiAgICAgICAgaWYgKGUudHlwZSA9PSAnc3ZnJyAmJiBlLnZpZXdib3gpIHtcbiAgICAgICAgICB6b29tICo9IGUudmlld2JveCgpLnpvb21cbiAgICAgICAgICB0aGlzLnggLT0gZS54KCkgfHwgMFxuICAgICAgICAgIHRoaXMueSAtPSBlLnkoKSB8fCAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLyogcmVjYWxjdWxhdGUgdmlld2JveCBkaXN0b3J0aW9uICovXG4gICAgdGhpcy54IC89IHpvb21cbiAgICB0aGlzLnkgLz0gem9vbVxuICAgIHRoaXMud2lkdGggID0gYm94LndpZHRoICAvPSB6b29tXG4gICAgdGhpcy5oZWlnaHQgPSBib3guaGVpZ2h0IC89IHpvb21cbiAgICBcbiAgICAvKiBvZmZzZXQgYnkgd2luZG93IHNjcm9sbCBwb3NpdGlvbiwgYmVjYXVzZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgY2hhbmdlcyB3aGVuIHdpbmRvdyBpcyBzY3JvbGxlZCAqL1xuICAgIHRoaXMueCArPSB0eXBlb2Ygd2luZG93LnNjcm9sbFggPT09ICdudW1iZXInID8gd2luZG93LnNjcm9sbFggOiB3aW5kb3cucGFnZVhPZmZzZXRcbiAgICB0aGlzLnkgKz0gdHlwZW9mIHdpbmRvdy5zY3JvbGxZID09PSAnbnVtYmVyJyA/IHdpbmRvdy5zY3JvbGxZIDogd2luZG93LnBhZ2VZT2Zmc2V0XG4gIFxuICAgIC8qIGFkZCBjZW50ZXIsIHJpZ2h0IGFuZCBib3R0b20gKi9cbiAgICBib3hQcm9wZXJ0aWVzKHRoaXMpXG4gICAgXG4gIH1cbiAgXG4gIC8vXG4gIFNWRy5leHRlbmQoU1ZHLlJCb3gsIHtcbiAgICAvLyBtZXJnZSByZWN0IGJveCB3aXRoIGFub3RoZXIsIHJldHVybiBhIG5ldyBpbnN0YW5jZVxuICAgIG1lcmdlOiBmdW5jdGlvbihib3gpIHtcbiAgICAgIHZhciBiID0gbmV3IFNWRy5SQm94KClcbiAgXG4gICAgICAvKiBtZXJnZSBib3ggKi9cbiAgICAgIGIueCAgICAgID0gTWF0aC5taW4odGhpcy54LCBib3gueClcbiAgICAgIGIueSAgICAgID0gTWF0aC5taW4odGhpcy55LCBib3gueSlcbiAgICAgIGIud2lkdGggID0gTWF0aC5tYXgodGhpcy54ICsgdGhpcy53aWR0aCwgIGJveC54ICsgYm94LndpZHRoKSAgLSBiLnhcbiAgICAgIGIuaGVpZ2h0ID0gTWF0aC5tYXgodGhpcy55ICsgdGhpcy5oZWlnaHQsIGJveC55ICsgYm94LmhlaWdodCkgLSBiLnlcbiAgXG4gICAgICAvKiBhZGQgY2VudGVyLCByaWdodCBhbmQgYm90dG9tICovXG4gICAgICBib3hQcm9wZXJ0aWVzKGIpXG4gIFxuICAgICAgcmV0dXJuIGJcbiAgICB9XG4gIFxuICB9KVxuXG5cbiAgU1ZHLkVsZW1lbnQgPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIC8qIG1ha2Ugc3Ryb2tlIHZhbHVlIGFjY2Vzc2libGUgZHluYW1pY2FsbHkgKi9cbiAgICAgIHRoaXMuX3N0cm9rZSA9IFNWRy5kZWZhdWx0cy5hdHRycy5zdHJva2VcbiAgXG4gICAgICAvKiBpbml0aWFsaXplIHRyYW5zZm9ybWF0aW9uIHN0b3JlIHdpdGggZGVmYXVsdHMgKi9cbiAgICAgIHRoaXMudHJhbnMgPSBTVkcuZGVmYXVsdHMudHJhbnMoKVxuICAgICAgXG4gICAgICAvKiBjcmVhdGUgY2lyY3VsYXIgcmVmZXJlbmNlICovXG4gICAgICBpZiAodGhpcy5ub2RlID0gbm9kZSkge1xuICAgICAgICB0aGlzLnR5cGUgPSBub2RlLm5vZGVOYW1lXG4gICAgICAgIHRoaXMubm9kZS5pbnN0YW5jZSA9IHRoaXNcbiAgICAgIH1cbiAgICB9XG4gIFxuICAgIC8vIEFkZCBjbGFzcyBtZXRob2RzXG4gICwgZXh0ZW5kOiB7XG4gICAgICAvLyBNb3ZlIG92ZXIgeC1heGlzXG4gICAgICB4OiBmdW5jdGlvbih4KSB7XG4gICAgICAgIGlmICh4ICE9IG51bGwpIHtcbiAgICAgICAgICB4ID0gbmV3IFNWRy5OdW1iZXIoeClcbiAgICAgICAgICB4LnZhbHVlIC89IHRoaXMudHJhbnMuc2NhbGVYXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cigneCcsIHgpXG4gICAgICB9XG4gICAgICAvLyBNb3ZlIG92ZXIgeS1heGlzXG4gICAgLCB5OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIGlmICh5ICE9IG51bGwpIHtcbiAgICAgICAgICB5ID0gbmV3IFNWRy5OdW1iZXIoeSlcbiAgICAgICAgICB5LnZhbHVlIC89IHRoaXMudHJhbnMuc2NhbGVZXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cigneScsIHkpXG4gICAgICB9XG4gICAgICAvLyBNb3ZlIGJ5IGNlbnRlciBvdmVyIHgtYXhpc1xuICAgICwgY3g6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIHggPT0gbnVsbCA/IHRoaXMueCgpICsgdGhpcy53aWR0aCgpIC8gMiA6IHRoaXMueCh4IC0gdGhpcy53aWR0aCgpIC8gMilcbiAgICAgIH1cbiAgICAgIC8vIE1vdmUgYnkgY2VudGVyIG92ZXIgeS1heGlzXG4gICAgLCBjeTogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4geSA9PSBudWxsID8gdGhpcy55KCkgKyB0aGlzLmhlaWdodCgpIC8gMiA6IHRoaXMueSh5IC0gdGhpcy5oZWlnaHQoKSAvIDIpXG4gICAgICB9XG4gICAgICAvLyBNb3ZlIGVsZW1lbnQgdG8gZ2l2ZW4geCBhbmQgeSB2YWx1ZXNcbiAgICAsIG1vdmU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCh4KS55KHkpXG4gICAgICB9XG4gICAgICAvLyBNb3ZlIGVsZW1lbnQgYnkgaXRzIGNlbnRlclxuICAgICwgY2VudGVyOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN4KHgpLmN5KHkpXG4gICAgICB9XG4gICAgICAvLyBTZXQgd2lkdGggb2YgZWxlbWVudFxuICAgICwgd2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3dpZHRoJywgd2lkdGgpXG4gICAgICB9XG4gICAgICAvLyBTZXQgaGVpZ2h0IG9mIGVsZW1lbnRcbiAgICAsIGhlaWdodDogZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2hlaWdodCcsIGhlaWdodClcbiAgICAgIH1cbiAgICAgIC8vIFNldCBlbGVtZW50IHNpemUgdG8gZ2l2ZW4gd2lkdGggYW5kIGhlaWdodFxuICAgICwgc2l6ZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgcCA9IHByb3BvcnRpb25hbFNpemUodGhpcy5iYm94KCksIHdpZHRoLCBoZWlnaHQpXG4gIFxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgIC53aWR0aChuZXcgU1ZHLk51bWJlcihwLndpZHRoKSlcbiAgICAgICAgICAuaGVpZ2h0KG5ldyBTVkcuTnVtYmVyKHAuaGVpZ2h0KSlcbiAgICAgIH1cbiAgICAgIC8vIENsb25lIGVsZW1lbnRcbiAgICAsIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNsb25lICwgYXR0clxuICAgICAgICAgICwgdHlwZSA9IHRoaXMudHlwZVxuICAgICAgICBcbiAgICAgICAgLyogaW52b2tlIHNoYXBlIG1ldGhvZCB3aXRoIHNoYXBlLXNwZWNpZmljIGFyZ3VtZW50cyAqL1xuICAgICAgICBjbG9uZSA9IHR5cGUgPT0gJ3JlY3QnIHx8IHR5cGUgPT0gJ2VsbGlwc2UnID9cbiAgICAgICAgICB0aGlzLnBhcmVudFt0eXBlXSgwLDApIDpcbiAgICAgICAgdHlwZSA9PSAnbGluZScgP1xuICAgICAgICAgIHRoaXMucGFyZW50W3R5cGVdKDAsMCwwLDApIDpcbiAgICAgICAgdHlwZSA9PSAnaW1hZ2UnID9cbiAgICAgICAgICB0aGlzLnBhcmVudFt0eXBlXSh0aGlzLnNyYykgOlxuICAgICAgICB0eXBlID09ICd0ZXh0JyA/XG4gICAgICAgICAgdGhpcy5wYXJlbnRbdHlwZV0odGhpcy5jb250ZW50KSA6XG4gICAgICAgIHR5cGUgPT0gJ3BhdGgnID9cbiAgICAgICAgICB0aGlzLnBhcmVudFt0eXBlXSh0aGlzLmF0dHIoJ2QnKSkgOlxuICAgICAgICB0eXBlID09ICdwb2x5bGluZScgfHwgdHlwZSA9PSAncG9seWdvbicgP1xuICAgICAgICAgIHRoaXMucGFyZW50W3R5cGVdKHRoaXMuYXR0cigncG9pbnRzJykpIDpcbiAgICAgICAgdHlwZSA9PSAnZycgP1xuICAgICAgICAgIHRoaXMucGFyZW50Lmdyb3VwKCkgOlxuICAgICAgICAgIHRoaXMucGFyZW50W3R5cGVdKClcbiAgICAgICAgXG4gICAgICAgIC8qIGFwcGx5IGF0dHJpYnV0ZXMgYXR0cmlidXRlcyAqL1xuICAgICAgICBhdHRyID0gdGhpcy5hdHRyKClcbiAgICAgICAgZGVsZXRlIGF0dHIuaWRcbiAgICAgICAgY2xvbmUuYXR0cihhdHRyKVxuICAgICAgICBcbiAgICAgICAgLyogY29weSB0cmFuc2Zvcm1hdGlvbnMgKi9cbiAgICAgICAgY2xvbmUudHJhbnMgPSB0aGlzLnRyYW5zXG4gICAgICAgIFxuICAgICAgICAvKiBhcHBseSBhdHRyaWJ1dGVzIGFuZCB0cmFuc2xhdGlvbnMgKi9cbiAgICAgICAgcmV0dXJuIGNsb25lLnRyYW5zZm9ybSh7fSlcbiAgICAgIH1cbiAgICAgIC8vIFJlbW92ZSBlbGVtZW50XG4gICAgLCByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQpXG4gICAgICAgICAgdGhpcy5wYXJlbnQucmVtb3ZlRWxlbWVudCh0aGlzKVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICAgIC8vIFJlcGxhY2UgZWxlbWVudFxuICAgICwgcmVwbGFjZTogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICB0aGlzLmFmdGVyKGVsZW1lbnQpLnJlbW92ZSgpXG4gIFxuICAgICAgICByZXR1cm4gZWxlbWVudFxuICAgICAgfVxuICAgICAgLy8gQWRkIGVsZW1lbnQgdG8gZ2l2ZW4gY29udGFpbmVyIGFuZCByZXR1cm4gc2VsZlxuICAgICwgYWRkVG86IGZ1bmN0aW9uKHBhcmVudCkge1xuICAgICAgICByZXR1cm4gcGFyZW50LnB1dCh0aGlzKVxuICAgICAgfVxuICAgICAgLy8gQWRkIGVsZW1lbnQgdG8gZ2l2ZW4gY29udGFpbmVyIGFuZCByZXR1cm4gY29udGFpbmVyXG4gICAgLCBwdXRJbjogZnVuY3Rpb24ocGFyZW50KSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQuYWRkKHRoaXMpXG4gICAgICB9XG4gICAgICAvLyBHZXQgcGFyZW50IGRvY3VtZW50XG4gICAgLCBkb2M6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCh0eXBlIHx8IFNWRy5Eb2MpXG4gICAgICB9XG4gICAgICAvLyBTZXQgc3ZnIGVsZW1lbnQgYXR0cmlidXRlXG4gICAgLCBhdHRyOiBmdW5jdGlvbihhLCB2LCBuKSB7XG4gICAgICAgIGlmIChhID09IG51bGwpIHtcbiAgICAgICAgICAvKiBnZXQgYW4gb2JqZWN0IG9mIGF0dHJpYnV0ZXMgKi9cbiAgICAgICAgICBhID0ge31cbiAgICAgICAgICB2ID0gdGhpcy5ub2RlLmF0dHJpYnV0ZXNcbiAgICAgICAgICBmb3IgKG4gPSB2Lmxlbmd0aCAtIDE7IG4gPj0gMDsgbi0tKVxuICAgICAgICAgICAgYVt2W25dLm5vZGVOYW1lXSA9IFNWRy5yZWdleC5pc051bWJlci50ZXN0KHZbbl0ubm9kZVZhbHVlKSA/IHBhcnNlRmxvYXQodltuXS5ub2RlVmFsdWUpIDogdltuXS5ub2RlVmFsdWVcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gYVxuICAgICAgICAgIFxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgLyogYXBwbHkgZXZlcnkgYXR0cmlidXRlIGluZGl2aWR1YWxseSBpZiBhbiBvYmplY3QgaXMgcGFzc2VkICovXG4gICAgICAgICAgZm9yICh2IGluIGEpIHRoaXMuYXR0cih2LCBhW3ZdKVxuICAgICAgICAgIFxuICAgICAgICB9IGVsc2UgaWYgKHYgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8qIHJlbW92ZSB2YWx1ZSAqL1xuICAgICAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUF0dHJpYnV0ZShhKVxuICAgICAgICAgIFxuICAgICAgICB9IGVsc2UgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICAgIC8qIGFjdCBhcyBhIGdldHRlciBpZiB0aGUgZmlyc3QgYW5kIG9ubHkgYXJndW1lbnQgaXMgbm90IGFuIG9iamVjdCAqL1xuICAgICAgICAgIHYgPSB0aGlzLm5vZGUuYXR0cmlidXRlc1thXVxuICAgICAgICAgIHJldHVybiB2ID09IG51bGwgPyBcbiAgICAgICAgICAgIFNWRy5kZWZhdWx0cy5hdHRyc1thXSA6XG4gICAgICAgICAgU1ZHLnJlZ2V4LmlzTnVtYmVyLnRlc3Qodi5ub2RlVmFsdWUpID9cbiAgICAgICAgICAgIHBhcnNlRmxvYXQodi5ub2RlVmFsdWUpIDogdi5ub2RlVmFsdWVcbiAgICAgICAgXG4gICAgICAgIH0gZWxzZSBpZiAoYSA9PSAnc3R5bGUnKSB7XG4gICAgICAgICAgLyogcmVkaXJlY3QgdG8gdGhlIHN0eWxlIG1ldGhvZCAqL1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0eWxlKHYpXG4gICAgICAgIFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8qIEJVRyBGSVg6IHNvbWUgYnJvd3NlcnMgd2lsbCByZW5kZXIgYSBzdHJva2UgaWYgYSBjb2xvciBpcyBnaXZlbiBldmVuIHRob3VnaCBzdHJva2Ugd2lkdGggaXMgMCAqL1xuICAgICAgICAgIGlmIChhID09ICdzdHJva2Utd2lkdGgnKVxuICAgICAgICAgICAgdGhpcy5hdHRyKCdzdHJva2UnLCBwYXJzZUZsb2F0KHYpID4gMCA/IHRoaXMuX3N0cm9rZSA6IG51bGwpXG4gICAgICAgICAgZWxzZSBpZiAoYSA9PSAnc3Ryb2tlJylcbiAgICAgICAgICAgIHRoaXMuX3N0cm9rZSA9IHZcbiAgXG4gICAgICAgICAgLyogY29udmVydCBpbWFnZSBmaWxsIGFuZCBzdHJva2UgdG8gcGF0dGVybnMgKi9cbiAgICAgICAgICBpZiAoYSA9PSAnZmlsbCcgfHwgYSA9PSAnc3Ryb2tlJykge1xuICAgICAgICAgICAgaWYgKFNWRy5yZWdleC5pc0ltYWdlLnRlc3QodikpXG4gICAgICAgICAgICAgIHYgPSB0aGlzLmRvYygpLmRlZnMoKS5pbWFnZSh2LCAwLCAwKVxuICBcbiAgICAgICAgICAgIGlmICh2IGluc3RhbmNlb2YgU1ZHLkltYWdlKVxuICAgICAgICAgICAgICB2ID0gdGhpcy5kb2MoKS5kZWZzKCkucGF0dGVybigwLCAwLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZCh2KVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvKiBlbnN1cmUgY29ycmVjdCBudW1lcmljIHZhbHVlcyAoYWxzbyBhY2NlcHRzIE5hTiBhbmQgSW5maW5pdHkpICovXG4gICAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHYgPSBuZXcgU1ZHLk51bWJlcih2KVxuICBcbiAgICAgICAgICAvKiBlbnN1cmUgZnVsbCBoZXggY29sb3IgKi9cbiAgICAgICAgICBlbHNlIGlmIChTVkcuQ29sb3IuaXNDb2xvcih2KSlcbiAgICAgICAgICAgIHYgPSBuZXcgU1ZHLkNvbG9yKHYpXG4gICAgICAgICAgXG4gICAgICAgICAgLyogcGFyc2UgYXJyYXkgdmFsdWVzICovXG4gICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2KSlcbiAgICAgICAgICAgIHYgPSBuZXcgU1ZHLkFycmF5KHYpXG4gIFxuICAgICAgICAgIC8qIGlmIHRoZSBwYXNzZWQgYXR0cmlidXRlIGlzIGxlYWRpbmcuLi4gKi9cbiAgICAgICAgICBpZiAoYSA9PSAnbGVhZGluZycpIHtcbiAgICAgICAgICAgIC8qIC4uLiBjYWxsIHRoZSBsZWFkaW5nIG1ldGhvZCBpbnN0ZWFkICovXG4gICAgICAgICAgICBpZiAodGhpcy5sZWFkaW5nKVxuICAgICAgICAgICAgICB0aGlzLmxlYWRpbmcodilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLyogc2V0IGdpdmVuIGF0dHJpYnV0ZSBvbiBub2RlICovXG4gICAgICAgICAgICB0eXBlb2YgbiA9PT0gJ3N0cmluZycgP1xuICAgICAgICAgICAgICB0aGlzLm5vZGUuc2V0QXR0cmlidXRlTlMobiwgYSwgdi50b1N0cmluZygpKSA6XG4gICAgICAgICAgICAgIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoYSwgdi50b1N0cmluZygpKVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvKiByZWJ1aWxkIGlmIHJlcXVpcmVkICovXG4gICAgICAgICAgaWYgKHRoaXMucmVidWlsZCAmJiAoYSA9PSAnZm9udC1zaXplJyB8fCBhID09ICd4JykpXG4gICAgICAgICAgICB0aGlzLnJlYnVpbGQoYSwgdilcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICAgIC8vIE1hbmFnZSB0cmFuc2Zvcm1hdGlvbnNcbiAgICAsIHRyYW5zZm9ybTogZnVuY3Rpb24obywgdikge1xuICAgICAgICBcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgIC8qIGFjdCBhcyBhIGdldHRlciBpZiBubyBhcmd1bWVudCBpcyBnaXZlbiAqL1xuICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zXG4gICAgICAgICAgXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgLyogYWN0IGFzIGEgZ2V0dGVyIGlmIG9ubHkgb25lIHN0cmluZyBhcmd1bWVudCBpcyBnaXZlbiAqL1xuICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zW29dXG4gICAgICAgICAgXG4gICAgICAgICAgLyogYXBwbHkgdHJhbnNmb3JtYXRpb25zIGFzIG9iamVjdCBpZiBrZXkgdmFsdWUgYXJndW1lbnRzIGFyZSBnaXZlbiovXG4gICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHt9XG4gICAgICAgICAgdHJhbnNmb3JtW29dID0gdlxuICAgICAgICAgIFxuICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh0cmFuc2Zvcm0pXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8qIC4uLiBvdGhlcndpc2UgY29udGludWUgYXMgYSBzZXR0ZXIgKi9cbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IFtdXG4gICAgICAgIFxuICAgICAgICAvKiBwYXJzZSBtYXRyaXggKi9cbiAgICAgICAgbyA9IHBhcnNlTWF0cml4KG8pXG4gICAgICAgIFxuICAgICAgICAvKiBtZXJnZSB2YWx1ZXMgKi9cbiAgICAgICAgZm9yICh2IGluIG8pXG4gICAgICAgICAgaWYgKG9bdl0gIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMudHJhbnNbdl0gPSBvW3ZdXG4gICAgICAgIFxuICAgICAgICAvKiBjb21waWxlIG1hdHJpeCAqL1xuICAgICAgICB0aGlzLnRyYW5zLm1hdHJpeCA9IHRoaXMudHJhbnMuYVxuICAgICAgICAgICAgICAgICAgICArICcgJyArIHRoaXMudHJhbnMuYlxuICAgICAgICAgICAgICAgICAgICArICcgJyArIHRoaXMudHJhbnMuY1xuICAgICAgICAgICAgICAgICAgICArICcgJyArIHRoaXMudHJhbnMuZFxuICAgICAgICAgICAgICAgICAgICArICcgJyArIHRoaXMudHJhbnMuZVxuICAgICAgICAgICAgICAgICAgICArICcgJyArIHRoaXMudHJhbnMuZlxuICAgICAgICBcbiAgICAgICAgLyogYWxpYXMgY3VycmVudCB0cmFuc2Zvcm1hdGlvbnMgKi9cbiAgICAgICAgbyA9IHRoaXMudHJhbnNcbiAgICAgICAgXG4gICAgICAgIC8qIGFkZCBtYXRyaXggKi9cbiAgICAgICAgaWYgKG8ubWF0cml4ICE9IFNWRy5kZWZhdWx0cy5tYXRyaXgpXG4gICAgICAgICAgdHJhbnNmb3JtLnB1c2goJ21hdHJpeCgnICsgby5tYXRyaXggKyAnKScpXG4gICAgICAgIFxuICAgICAgICAvKiBhZGQgcm90YXRpb24gKi9cbiAgICAgICAgaWYgKG8ucm90YXRpb24gIT0gMClcbiAgICAgICAgICB0cmFuc2Zvcm0ucHVzaCgncm90YXRlKCcgKyBvLnJvdGF0aW9uICsgJyAnICsgKG8uY3ggPT0gbnVsbCA/IHRoaXMuYmJveCgpLmN4IDogby5jeCkgKyAnICcgKyAoby5jeSA9PSBudWxsID8gdGhpcy5iYm94KCkuY3kgOiBvLmN5KSArICcpJylcbiAgICAgICAgXG4gICAgICAgIC8qIGFkZCBzY2FsZSAqL1xuICAgICAgICBpZiAoby5zY2FsZVggIT0gMSB8fCBvLnNjYWxlWSAhPSAxKVxuICAgICAgICAgIHRyYW5zZm9ybS5wdXNoKCdzY2FsZSgnICsgby5zY2FsZVggKyAnICcgKyBvLnNjYWxlWSArICcpJylcbiAgICAgICAgXG4gICAgICAgIC8qIGFkZCBza2V3IG9uIHggYXhpcyAqL1xuICAgICAgICBpZiAoby5za2V3WCAhPSAwKVxuICAgICAgICAgIHRyYW5zZm9ybS5wdXNoKCdza2V3WCgnICsgby5za2V3WCArICcpJylcbiAgICAgICAgXG4gICAgICAgIC8qIGFkZCBza2V3IG9uIHkgYXhpcyAqL1xuICAgICAgICBpZiAoby5za2V3WSAhPSAwKVxuICAgICAgICAgIHRyYW5zZm9ybS5wdXNoKCdza2V3WSgnICsgby5za2V3WSArICcpJylcbiAgICAgICAgXG4gICAgICAgIC8qIGFkZCB0cmFuc2xhdGlvbiAqL1xuICAgICAgICBpZiAoby54ICE9IDAgfHwgby55ICE9IDApXG4gICAgICAgICAgdHJhbnNmb3JtLnB1c2goJ3RyYW5zbGF0ZSgnICsgbmV3IFNWRy5OdW1iZXIoby54IC8gby5zY2FsZVgpICsgJyAnICsgbmV3IFNWRy5OdW1iZXIoby55IC8gby5zY2FsZVkpICsgJyknKVxuICAgICAgICBcbiAgICAgICAgLyogdXBkYXRlIHRyYW5zZm9ybWF0aW9ucywgZXZlbiBpZiB0aGVyZSBhcmUgbm9uZSAqL1xuICAgICAgICBpZiAodHJhbnNmb3JtLmxlbmd0aCA9PSAwKVxuICAgICAgICAgIHRoaXMubm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCB0cmFuc2Zvcm0uam9pbignICcpKVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICAgIC8vIER5bmFtaWMgc3R5bGUgZ2VuZXJhdG9yXG4gICAgLCBzdHlsZTogZnVuY3Rpb24ocywgdikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgLyogZ2V0IGZ1bGwgc3R5bGUgKi9cbiAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlLnN0eWxlLmNzc1RleHQgfHwgJydcbiAgICAgICAgXG4gICAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAvKiBhcHBseSBldmVyeSBzdHlsZSBpbmRpdmlkdWFsbHkgaWYgYW4gb2JqZWN0IGlzIHBhc3NlZCAqL1xuICAgICAgICAgIGlmICh0eXBlb2YgcyA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZm9yICh2IGluIHMpIHRoaXMuc3R5bGUodiwgc1t2XSlcbiAgICAgICAgICBcbiAgICAgICAgICB9IGVsc2UgaWYgKFNWRy5yZWdleC5pc0Nzcy50ZXN0KHMpKSB7XG4gICAgICAgICAgICAvKiBwYXJzZSBjc3Mgc3RyaW5nICovXG4gICAgICAgICAgICBzID0gcy5zcGxpdCgnOycpXG4gIFxuICAgICAgICAgICAgLyogYXBwbHkgZXZlcnkgZGVmaW5pdGlvbiBpbmRpdmlkdWFsbHkgKi9cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2ID0gc1tpXS5zcGxpdCgnOicpXG4gICAgICAgICAgICAgIHRoaXMuc3R5bGUodlswXS5yZXBsYWNlKC9cXHMrL2csICcnKSwgdlsxXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLyogYWN0IGFzIGEgZ2V0dGVyIGlmIHRoZSBmaXJzdCBhbmQgb25seSBhcmd1bWVudCBpcyBub3QgYW4gb2JqZWN0ICovXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlLnN0eWxlW2NhbWVsQ2FzZShzKV1cbiAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubm9kZS5zdHlsZVtjYW1lbENhc2UocyldID0gdiA9PT0gbnVsbCB8fCBTVkcucmVnZXguaXNCbGFuay50ZXN0KHYpID8gJycgOiB2XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gICAgICAvLyBHZXQgLyBzZXQgaWRcbiAgICAsIGlkOiBmdW5jdGlvbihpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCdpZCcsIGlkKVxuICAgICAgfVxuICAgICAgLy8gR2V0IGJvdW5kaW5nIGJveFxuICAgICwgYmJveDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgU1ZHLkJCb3godGhpcylcbiAgICAgIH1cbiAgICAgIC8vIEdldCByZWN0IGJveFxuICAgICwgcmJveDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgU1ZHLlJCb3godGhpcylcbiAgICAgIH1cbiAgICAgIC8vIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBwb2ludCBpbnNpZGUgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgZWxlbWVudFxuICAgICwgaW5zaWRlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciBib3ggPSB0aGlzLmJib3goKVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHggPiBib3gueFxuICAgICAgICAgICAgJiYgeSA+IGJveC55XG4gICAgICAgICAgICAmJiB4IDwgYm94LnggKyBib3gud2lkdGhcbiAgICAgICAgICAgICYmIHkgPCBib3gueSArIGJveC5oZWlnaHRcbiAgICAgIH1cbiAgICAgIC8vIFNob3cgZWxlbWVudFxuICAgICwgc2hvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlKCdkaXNwbGF5JywgJycpXG4gICAgICB9XG4gICAgICAvLyBIaWRlIGVsZW1lbnRcbiAgICAsIGhpZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZSgnZGlzcGxheScsICdub25lJylcbiAgICAgIH1cbiAgICAgIC8vIElzIGVsZW1lbnQgdmlzaWJsZT9cbiAgICAsIHZpc2libGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZSgnZGlzcGxheScpICE9ICdub25lJ1xuICAgICAgfVxuICAgICAgLy8gUmV0dXJuIGlkIG9uIHN0cmluZyBjb252ZXJzaW9uXG4gICAgLCB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2lkJylcbiAgICAgIH1cbiAgICAgIC8vIFJldHVybiBhcnJheSBvZiBjbGFzc2VzIG9uIHRoZSBub2RlXG4gICAgLCBjbGFzc2VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNsYXNzQXR0ciA9IHRoaXMubm9kZS5nZXRBdHRyaWJ1dGUoJ2NsYXNzJylcbiAgICAgICAgaWYgKGNsYXNzQXR0ciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBbXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBjbGFzc0F0dHIudHJpbSgpLnNwbGl0KC9cXHMrLylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gUmV0dXJuIHRydWUgaWYgY2xhc3MgZXhpc3RzIG9uIHRoZSBub2RlLCBmYWxzZSBvdGhlcndpc2VcbiAgICAsIGhhc0NsYXNzOiBmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xhc3NlcygpLmluZGV4T2YoY2xhc3NOYW1lKSAhPSAtMVxuICAgICAgfVxuICAgICAgLy8gQWRkIGNsYXNzIHRvIHRoZSBub2RlXG4gICAgLCBhZGRDbGFzczogZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gICAgICAgIHZhciBjbGFzc0FycmF5XG4gICAgICAgIGlmICghKHRoaXMuaGFzQ2xhc3MoY2xhc3NOYW1lKSkpIHtcbiAgICAgICAgICBjbGFzc0FycmF5ID0gdGhpcy5jbGFzc2VzKClcbiAgICAgICAgICBjbGFzc0FycmF5LnB1c2goY2xhc3NOYW1lKVxuICAgICAgICAgIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xhc3NBcnJheS5qb2luKCcgJykpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICAgIC8vIFJlbW92ZSBjbGFzcyBmcm9tIHRoZSBub2RlXG4gICAgLCByZW1vdmVDbGFzczogZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gICAgICAgIHZhciBjbGFzc0FycmF5XG4gICAgICAgIGlmICh0aGlzLmhhc0NsYXNzKGNsYXNzTmFtZSkpIHtcbiAgICAgICAgICBjbGFzc0FycmF5ID0gdGhpcy5jbGFzc2VzKCkuZmlsdGVyKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgIHJldHVybiBjICE9IGNsYXNzTmFtZVxuICAgICAgICAgIH0pXG4gICAgICAgICAgdGhpcy5ub2RlLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbGFzc0FycmF5LmpvaW4oJyAnKSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgICAgLy8gVG9nZ2xlIHRoZSBwcmVzZW5jZSBvZiBhIGNsYXNzIG9uIHRoZSBub2RlXG4gICAgLCB0b2dnbGVDbGFzczogZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0NsYXNzKGNsYXNzTmFtZSkpIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKGNsYXNzTmFtZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFkZENsYXNzKGNsYXNzTmFtZSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgICAgLy8gR2V0IHJlZmVyZW5jZWQgZWxlbWVudCBmb3JtIGF0dHJpYnV0ZSB2YWx1ZVxuICAgICwgcmVmZXJlbmNlOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICAgIHJldHVybiBTVkcuZ2V0KHRoaXMuYXR0cigpW2F0dHJdKVxuICAgICAgfVxuICAgICAgLy8gUHJpdmF0ZTogZmluZCBzdmcgcGFyZW50IGJ5IGluc3RhbmNlXG4gICAgLCBfcGFyZW50OiBmdW5jdGlvbihwYXJlbnQpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzXG4gICAgICAgIFxuICAgICAgICB3aGlsZSAoZWxlbWVudCAhPSBudWxsICYmICEoZWxlbWVudCBpbnN0YW5jZW9mIHBhcmVudCkpXG4gICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50XG4gIFxuICAgICAgICByZXR1cm4gZWxlbWVudFxuICAgICAgfVxuICAgIH1cbiAgfSlcblxuXG4gIFNWRy5QYXJlbnQgPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBlbGVtZW50KVxuICAgIH1cbiAgXG4gICAgLy8gSW5oZXJpdCBmcm9tXG4gICwgaW5oZXJpdDogU1ZHLkVsZW1lbnRcbiAgXG4gICAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcbiAgLCBleHRlbmQ6IHtcbiAgICAgIC8vIFJldHVybnMgYWxsIGNoaWxkIGVsZW1lbnRzXG4gICAgICBjaGlsZHJlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbiB8fCAodGhpcy5fY2hpbGRyZW4gPSBbXSlcbiAgICAgIH1cbiAgICAgIC8vIEFkZCBnaXZlbiBlbGVtZW50IGF0IGEgcG9zaXRpb25cbiAgICAsIGFkZDogZnVuY3Rpb24oZWxlbWVudCwgaSkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgLyogZGVmaW5lIGluc2VydGlvbiBpbmRleCBpZiBub25lIGdpdmVuICovXG4gICAgICAgICAgaSA9IGkgPT0gbnVsbCA/IHRoaXMuY2hpbGRyZW4oKS5sZW5ndGggOiBpXG4gICAgICAgICAgXG4gICAgICAgICAgLyogcmVtb3ZlIHJlZmVyZW5jZXMgZnJvbSBwcmV2aW91cyBwYXJlbnQgKi9cbiAgICAgICAgICBpZiAoZWxlbWVudC5wYXJlbnQpXG4gICAgICAgICAgICBlbGVtZW50LnBhcmVudC5jaGlsZHJlbigpLnNwbGljZShlbGVtZW50LnBhcmVudC5pbmRleChlbGVtZW50KSwgMSlcbiAgICAgICAgICBcbiAgICAgICAgICAvKiBhZGQgZWxlbWVudCByZWZlcmVuY2VzICovXG4gICAgICAgICAgdGhpcy5jaGlsZHJlbigpLnNwbGljZShpLCAwLCBlbGVtZW50KVxuICAgICAgICAgIHRoaXMubm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudC5ub2RlLCB0aGlzLm5vZGUuY2hpbGROb2Rlc1tpXSB8fCBudWxsKVxuICAgICAgICAgIGVsZW1lbnQucGFyZW50ID0gdGhpc1xuICAgICAgICB9XG4gIFxuICAgICAgICAvKiByZXBvc2l0aW9uIGRlZnMgKi9cbiAgICAgICAgaWYgKHRoaXMuX2RlZnMpIHtcbiAgICAgICAgICB0aGlzLm5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fZGVmcy5ub2RlKVxuICAgICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZCh0aGlzLl9kZWZzLm5vZGUpXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gICAgICAvLyBCYXNpY2FsbHkgZG9lcyB0aGUgc2FtZSBhcyBgYWRkKClgIGJ1dCByZXR1cm5zIHRoZSBhZGRlZCBlbGVtZW50IGluc3RlYWRcbiAgICAsIHB1dDogZnVuY3Rpb24oZWxlbWVudCwgaSkge1xuICAgICAgICB0aGlzLmFkZChlbGVtZW50LCBpKVxuICAgICAgICByZXR1cm4gZWxlbWVudFxuICAgICAgfVxuICAgICAgLy8gQ2hlY2tzIGlmIHRoZSBnaXZlbiBlbGVtZW50IGlzIGEgY2hpbGRcbiAgICAsIGhhczogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleChlbGVtZW50KSA+PSAwXG4gICAgICB9XG4gICAgICAvLyBHZXRzIGluZGV4IG9mIGdpdmVuIGVsZW1lbnRcbiAgICAsIGluZGV4OiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuKCkuaW5kZXhPZihlbGVtZW50KVxuICAgICAgfVxuICAgICAgLy8gR2V0IGEgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXhcbiAgICAsIGdldDogZnVuY3Rpb24oaSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbigpW2ldXG4gICAgICB9XG4gICAgICAvLyBHZXQgZmlyc3QgY2hpbGQsIHNraXBwaW5nIHRoZSBkZWZzIG5vZGVcbiAgICAsIGZpcnN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4oKVswXVxuICAgICAgfVxuICAgICAgLy8gR2V0IHRoZSBsYXN0IGNoaWxkXG4gICAgLCBsYXN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4oKVt0aGlzLmNoaWxkcmVuKCkubGVuZ3RoIC0gMV1cbiAgICAgIH1cbiAgICAgIC8vIEl0ZXJhdGVzIG92ZXIgYWxsIGNoaWxkcmVuIGFuZCBpbnZva2VzIGEgZ2l2ZW4gYmxvY2tcbiAgICAsIGVhY2g6IGZ1bmN0aW9uKGJsb2NrLCBkZWVwKSB7XG4gICAgICAgIHZhciBpLCBpbFxuICAgICAgICAgICwgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuKClcbiAgICAgICAgXG4gICAgICAgIGZvciAoaSA9IDAsIGlsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICAgIGlmIChjaGlsZHJlbltpXSBpbnN0YW5jZW9mIFNWRy5FbGVtZW50KVxuICAgICAgICAgICAgYmxvY2suYXBwbHkoY2hpbGRyZW5baV0sIFtpLCBjaGlsZHJlbl0pXG4gIFxuICAgICAgICAgIGlmIChkZWVwICYmIChjaGlsZHJlbltpXSBpbnN0YW5jZW9mIFNWRy5Db250YWluZXIpKVxuICAgICAgICAgICAgY2hpbGRyZW5baV0uZWFjaChibG9jaywgZGVlcClcbiAgICAgICAgfVxuICAgICAgXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gICAgICAvLyBSZW1vdmUgYSBjaGlsZCBlbGVtZW50IGF0IGEgcG9zaXRpb25cbiAgICAsIHJlbW92ZUVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbigpLnNwbGljZSh0aGlzLmluZGV4KGVsZW1lbnQpLCAxKVxuICAgICAgICB0aGlzLm5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudC5ub2RlKVxuICAgICAgICBlbGVtZW50LnBhcmVudCA9IG51bGxcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gICAgICAvLyBSZW1vdmUgYWxsIGVsZW1lbnRzIGluIHRoaXMgY29udGFpbmVyXG4gICAgLCBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8qIHJlbW92ZSBjaGlsZHJlbiAqL1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5jaGlsZHJlbigpLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgIHRoaXMucmVtb3ZlRWxlbWVudCh0aGlzLmNoaWxkcmVuKClbaV0pXG4gIFxuICAgICAgICAvKiByZW1vdmUgZGVmcyBub2RlICovXG4gICAgICAgIGlmICh0aGlzLl9kZWZzKVxuICAgICAgICAgIHRoaXMuX2RlZnMuY2xlYXIoKVxuICBcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICAgLCAvLyBHZXQgZGVmc1xuICAgICAgZGVmczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvYygpLmRlZnMoKVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgfSlcblxuXG4gIFNWRy5Db250YWluZXIgPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBlbGVtZW50KVxuICAgIH1cbiAgXG4gICAgLy8gSW5oZXJpdCBmcm9tXG4gICwgaW5oZXJpdDogU1ZHLlBhcmVudFxuICBcbiAgICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xuICAsIGV4dGVuZDoge1xuICAgICAgLy8gR2V0IHRoZSB2aWV3Qm94IGFuZCBjYWxjdWxhdGUgdGhlIHpvb20gdmFsdWVcbiAgICAgIHZpZXdib3g6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMClcbiAgICAgICAgICAvKiBhY3QgYXMgYSBnZXR0ZXIgaWYgdGhlcmUgYXJlIG5vIGFyZ3VtZW50cyAqL1xuICAgICAgICAgIHJldHVybiBuZXcgU1ZHLlZpZXdCb3godGhpcylcbiAgICAgICAgXG4gICAgICAgIC8qIG90aGVyd2lzZSBhY3QgYXMgYSBzZXR0ZXIgKi9cbiAgICAgICAgdiA9IGFyZ3VtZW50cy5sZW5ndGggPT0gMSA/XG4gICAgICAgICAgW3YueCwgdi55LCB2LndpZHRoLCB2LmhlaWdodF0gOlxuICAgICAgICAgIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cigndmlld0JveCcsIHYpXG4gICAgICB9XG4gICAgfVxuICAgIFxuICB9KVxuXG4gIFNWRy5GWCA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemUgRlggb2JqZWN0XG4gICAgY3JlYXRlOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAvKiBzdG9yZSB0YXJnZXQgZWxlbWVudCAqL1xuICAgICAgdGhpcy50YXJnZXQgPSBlbGVtZW50XG4gICAgfVxuICBcbiAgICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xuICAsIGV4dGVuZDoge1xuICAgICAgLy8gQWRkIGFuaW1hdGlvbiBwYXJhbWV0ZXJzIGFuZCBzdGFydCBhbmltYXRpb25cbiAgICAgIGFuaW1hdGU6IGZ1bmN0aW9uKGQsIGVhc2UsIGRlbGF5KSB7XG4gICAgICAgIHZhciBha2V5cywgdGtleXMsIHNrZXlzLCBrZXlcbiAgICAgICAgICAsIGVsZW1lbnQgPSB0aGlzLnRhcmdldFxuICAgICAgICAgICwgZnggPSB0aGlzXG4gICAgICAgIFxuICAgICAgICAvKiBkaXNzZWN0IG9iamVjdCBpZiBvbmUgaXMgcGFzc2VkICovXG4gICAgICAgIGlmICh0eXBlb2YgZCA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGRlbGF5ID0gZC5kZWxheVxuICAgICAgICAgIGVhc2UgPSBkLmVhc2VcbiAgICAgICAgICBkID0gZC5kdXJhdGlvblxuICAgICAgICB9XG4gIFxuICAgICAgICAvKiBlbnN1cmUgZGVmYXVsdCBkdXJhdGlvbiBhbmQgZWFzaW5nICovXG4gICAgICAgIGQgPSBkID09ICc9JyA/IGQgOiBkID09IG51bGwgPyAxMDAwIDogbmV3IFNWRy5OdW1iZXIoZCkudmFsdWVPZigpXG4gICAgICAgIGVhc2UgPSBlYXNlIHx8ICc8PidcbiAgXG4gICAgICAgIC8qIHByb2Nlc3MgdmFsdWVzICovXG4gICAgICAgIGZ4LnRvID0gZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgICAgdmFyIGlcbiAgXG4gICAgICAgICAgLyogbm9ybWFsaXNlIHBvcyAqL1xuICAgICAgICAgIHBvcyA9IHBvcyA8IDAgPyAwIDogcG9zID4gMSA/IDEgOiBwb3NcbiAgXG4gICAgICAgICAgLyogY29sbGVjdCBhdHRyaWJ1dGUga2V5cyAqL1xuICAgICAgICAgIGlmIChha2V5cyA9PSBudWxsKSB7XG4gICAgICAgICAgICBha2V5cyA9IFtdXG4gICAgICAgICAgICBmb3IgKGtleSBpbiBmeC5hdHRycylcbiAgICAgICAgICAgICAgYWtleXMucHVzaChrZXkpXG4gIFxuICAgICAgICAgICAgLyogbWFrZSBzdXJlIG1vcnBoYWJsZSBlbGVtZW50cyBhcmUgc2NhbGVkLCB0cmFuc2xhdGVkIGFuZCBtb3JwaGVkIGFsbCB0b2dldGhlciAqL1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQubW9ycGhBcnJheSAmJiAoZnguX3Bsb3QgfHwgYWtleXMuaW5kZXhPZigncG9pbnRzJykgPiAtMSkpIHtcbiAgICAgICAgICAgICAgLyogZ2V0IGRlc3RpbmF0aW9uICovXG4gICAgICAgICAgICAgIHZhciBib3hcbiAgICAgICAgICAgICAgICAsIHAgPSBuZXcgZWxlbWVudC5tb3JwaEFycmF5KGZ4Ll9wbG90IHx8IGZ4LmF0dHJzLnBvaW50cyB8fCBlbGVtZW50LmFycmF5KVxuICBcbiAgICAgICAgICAgICAgLyogYWRkIHNpemUgKi9cbiAgICAgICAgICAgICAgaWYgKGZ4Ll9zaXplKSBwLnNpemUoZnguX3NpemUud2lkdGgudG8sIGZ4Ll9zaXplLmhlaWdodC50bylcbiAgXG4gICAgICAgICAgICAgIC8qIGFkZCBtb3ZlbWVudCAqL1xuICAgICAgICAgICAgICBib3ggPSBwLmJib3goKVxuICAgICAgICAgICAgICBpZiAoZnguX3gpIHAubW92ZShmeC5feC50bywgYm94LnkpXG4gICAgICAgICAgICAgIGVsc2UgaWYgKGZ4Ll9jeCkgcC5tb3ZlKGZ4Ll9jeC50byAtIGJveC53aWR0aCAvIDIsIGJveC55KVxuICBcbiAgICAgICAgICAgICAgYm94ID0gcC5iYm94KClcbiAgICAgICAgICAgICAgaWYgKGZ4Ll95KSBwLm1vdmUoYm94LngsIGZ4Ll95LnRvKVxuICAgICAgICAgICAgICBlbHNlIGlmIChmeC5fY3kpIHAubW92ZShib3gueCwgZnguX2N5LnRvIC0gYm94LmhlaWdodCAvIDIpXG4gIFxuICAgICAgICAgICAgICAvKiBkZWxldGUgZWxlbWVudCBvcmllbnRlZCBjaGFuZ2VzICovXG4gICAgICAgICAgICAgIGRlbGV0ZSBmeC5feFxuICAgICAgICAgICAgICBkZWxldGUgZnguX3lcbiAgICAgICAgICAgICAgZGVsZXRlIGZ4Ll9jeFxuICAgICAgICAgICAgICBkZWxldGUgZnguX2N5XG4gICAgICAgICAgICAgIGRlbGV0ZSBmeC5fc2l6ZVxuICBcbiAgICAgICAgICAgICAgZnguX3Bsb3QgPSBlbGVtZW50LmFycmF5Lm1vcnBoKHApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICAvKiBjb2xsZWN0IHRyYW5zZm9ybWF0aW9uIGtleXMgKi9cbiAgICAgICAgICBpZiAodGtleXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGtleXMgPSBbXVxuICAgICAgICAgICAgZm9yIChrZXkgaW4gZngudHJhbnMpXG4gICAgICAgICAgICAgIHRrZXlzLnB1c2goa2V5KVxuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgLyogY29sbGVjdCBzdHlsZSBrZXlzICovXG4gICAgICAgICAgaWYgKHNrZXlzID09IG51bGwpIHtcbiAgICAgICAgICAgIHNrZXlzID0gW11cbiAgICAgICAgICAgIGZvciAoa2V5IGluIGZ4LnN0eWxlcylcbiAgICAgICAgICAgICAgc2tleXMucHVzaChrZXkpXG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICAvKiBhcHBseSBlYXNpbmcgKi9cbiAgICAgICAgICBwb3MgPSBlYXNlID09ICc8PicgP1xuICAgICAgICAgICAgKC1NYXRoLmNvcyhwb3MgKiBNYXRoLlBJKSAvIDIpICsgMC41IDpcbiAgICAgICAgICBlYXNlID09ICc+JyA/XG4gICAgICAgICAgICBNYXRoLnNpbihwb3MgKiBNYXRoLlBJIC8gMikgOlxuICAgICAgICAgIGVhc2UgPT0gJzwnID9cbiAgICAgICAgICAgIC1NYXRoLmNvcyhwb3MgKiBNYXRoLlBJIC8gMikgKyAxIDpcbiAgICAgICAgICBlYXNlID09ICctJyA/XG4gICAgICAgICAgICBwb3MgOlxuICAgICAgICAgIHR5cGVvZiBlYXNlID09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgZWFzZShwb3MpIDpcbiAgICAgICAgICAgIHBvc1xuICAgICAgICAgIFxuICAgICAgICAgIC8qIHJ1biBwbG90IGZ1bmN0aW9uICovXG4gICAgICAgICAgaWYgKGZ4Ll9wbG90KSB7XG4gICAgICAgICAgICBlbGVtZW50LnBsb3QoZnguX3Bsb3QuYXQocG9zKSlcbiAgXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8qIHJ1biBhbGwgeC1wb3NpdGlvbiBwcm9wZXJ0aWVzICovXG4gICAgICAgICAgICBpZiAoZnguX3gpXG4gICAgICAgICAgICAgIGVsZW1lbnQueChmeC5feC5hdChwb3MpKVxuICAgICAgICAgICAgZWxzZSBpZiAoZnguX2N4KVxuICAgICAgICAgICAgICBlbGVtZW50LmN4KGZ4Ll9jeC5hdChwb3MpKVxuICBcbiAgICAgICAgICAgIC8qIHJ1biBhbGwgeS1wb3NpdGlvbiBwcm9wZXJ0aWVzICovXG4gICAgICAgICAgICBpZiAoZnguX3kpXG4gICAgICAgICAgICAgIGVsZW1lbnQueShmeC5feS5hdChwb3MpKVxuICAgICAgICAgICAgZWxzZSBpZiAoZnguX2N5KVxuICAgICAgICAgICAgICBlbGVtZW50LmN5KGZ4Ll9jeS5hdChwb3MpKVxuICBcbiAgICAgICAgICAgIC8qIHJ1biBhbGwgc2l6ZSBwcm9wZXJ0aWVzICovXG4gICAgICAgICAgICBpZiAoZnguX3NpemUpXG4gICAgICAgICAgICAgIGVsZW1lbnQuc2l6ZShmeC5fc2l6ZS53aWR0aC5hdChwb3MpLCBmeC5fc2l6ZS5oZWlnaHQuYXQocG9zKSlcbiAgICAgICAgICB9XG4gIFxuICAgICAgICAgIC8qIHJ1biBhbGwgdmlld2JveCBwcm9wZXJ0aWVzICovXG4gICAgICAgICAgaWYgKGZ4Ll92aWV3Ym94KVxuICAgICAgICAgICAgZWxlbWVudC52aWV3Ym94KFxuICAgICAgICAgICAgICBmeC5fdmlld2JveC54LmF0KHBvcylcbiAgICAgICAgICAgICwgZnguX3ZpZXdib3gueS5hdChwb3MpXG4gICAgICAgICAgICAsIGZ4Ll92aWV3Ym94LndpZHRoLmF0KHBvcylcbiAgICAgICAgICAgICwgZnguX3ZpZXdib3guaGVpZ2h0LmF0KHBvcylcbiAgICAgICAgICAgIClcbiAgXG4gICAgICAgICAgLyogcnVuIGxlYWRpbmcgcHJvcGVydHkgKi9cbiAgICAgICAgICBpZiAoZnguX2xlYWRpbmcpXG4gICAgICAgICAgICBlbGVtZW50LmxlYWRpbmcoZnguX2xlYWRpbmcuYXQocG9zKSlcbiAgXG4gICAgICAgICAgLyogYW5pbWF0ZSBhdHRyaWJ1dGVzICovXG4gICAgICAgICAgZm9yIChpID0gYWtleXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICBlbGVtZW50LmF0dHIoYWtleXNbaV0sIGF0KGZ4LmF0dHJzW2FrZXlzW2ldXSwgcG9zKSlcbiAgXG4gICAgICAgICAgLyogYW5pbWF0ZSB0cmFuc2Zvcm1hdGlvbnMgKi9cbiAgICAgICAgICBmb3IgKGkgPSB0a2V5cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgIGVsZW1lbnQudHJhbnNmb3JtKHRrZXlzW2ldLCBhdChmeC50cmFuc1t0a2V5c1tpXV0sIHBvcykpXG4gIFxuICAgICAgICAgIC8qIGFuaW1hdGUgc3R5bGVzICovXG4gICAgICAgICAgZm9yIChpID0gc2tleXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlKHNrZXlzW2ldLCBhdChmeC5zdHlsZXNbc2tleXNbaV1dLCBwb3MpKVxuICBcbiAgICAgICAgICAvKiBjYWxsYmFjayBmb3IgZWFjaCBrZXlmcmFtZSAqL1xuICAgICAgICAgIGlmIChmeC5fZHVyaW5nKVxuICAgICAgICAgICAgZnguX2R1cmluZy5jYWxsKGVsZW1lbnQsIHBvcywgZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGF0KHsgZnJvbTogZnJvbSwgdG86IHRvIH0sIHBvcylcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICh0eXBlb2YgZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAvKiBkZWxheSBhbmltYXRpb24gKi9cbiAgICAgICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKClcbiAgXG4gICAgICAgICAgICAvKiBpbml0aWFsaXplIHNpdHVhdGlvbiBvYmplY3QgKi9cbiAgICAgICAgICAgIGZ4LnNpdHVhdGlvbiA9IHtcbiAgICAgICAgICAgICAgaW50ZXJ2YWw6IDEwMDAgLyA2MFxuICAgICAgICAgICAgLCBzdGFydDogICAgc3RhcnRcbiAgICAgICAgICAgICwgcGxheTogICAgIHRydWVcbiAgICAgICAgICAgICwgZmluaXNoOiAgIHN0YXJ0ICsgZFxuICAgICAgICAgICAgLCBkdXJhdGlvbjogZFxuICAgICAgICAgICAgfVxuICBcbiAgICAgICAgICAgIC8qIHJlbmRlciBmdW5jdGlvbiAqL1xuICAgICAgICAgICAgZngucmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBpZiAoZnguc2l0dWF0aW9uLnBsYXkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNvZGUgd2FzIGJvcnJvd2VkIGZyb20gdGhlIGVtaWxlLmpzIG1pY3JvIGZyYW1ld29yayBieSBUaG9tYXMgRnVjaHMsIGFrYSBNYWRSb2JieS5cbiAgICAgICAgICAgICAgICB2YXIgdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpXG4gICAgICAgICAgICAgICAgICAsIHBvcyA9IHRpbWUgPiBmeC5zaXR1YXRpb24uZmluaXNoID8gMSA6ICh0aW1lIC0gZnguc2l0dWF0aW9uLnN0YXJ0KSAvIGRcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvKiBwcm9jZXNzIHZhbHVlcyAqL1xuICAgICAgICAgICAgICAgIGZ4LnRvKHBvcylcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvKiBmaW5pc2ggb2ZmIGFuaW1hdGlvbiAqL1xuICAgICAgICAgICAgICAgIGlmICh0aW1lID4gZnguc2l0dWF0aW9uLmZpbmlzaCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGZ4Ll9wbG90KVxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnBsb3QobmV3IFNWRy5Qb2ludEFycmF5KGZ4Ll9wbG90LmRlc3RpbmF0aW9uKS5zZXR0bGUoKSlcbiAgXG4gICAgICAgICAgICAgICAgICBpZiAoZnguX2xvb3AgPT09IHRydWUgfHwgKHR5cGVvZiBmeC5fbG9vcCA9PSAnbnVtYmVyJyAmJiBmeC5fbG9vcCA+IDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZnguX2xvb3AgPT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgICAgICAgLS1meC5fbG9vcFxuICAgICAgICAgICAgICAgICAgICBmeC5hbmltYXRlKGQsIGVhc2UsIGRlbGF5KVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZnguX2FmdGVyID8gZnguX2FmdGVyLmFwcGx5KGVsZW1lbnQsIFtmeF0pIDogZnguc3RvcCgpXG4gICAgICAgICAgICAgICAgICB9XG4gIFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbUZyYW1lKGZ4LnJlbmRlcilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1GcmFtZShmeC5yZW5kZXIpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gIFxuICAgICAgICAgICAgLyogc3RhcnQgYW5pbWF0aW9uICovXG4gICAgICAgICAgICBmeC5yZW5kZXIoKVxuICAgICAgICAgICAgXG4gICAgICAgICAgfSwgbmV3IFNWRy5OdW1iZXIoZGVsYXkpLnZhbHVlT2YoKSlcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICAgIC8vIEdldCBib3VuZGluZyBib3ggb2YgdGFyZ2V0IGVsZW1lbnRcbiAgICAsIGJib3g6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YXJnZXQuYmJveCgpXG4gICAgICB9XG4gICAgICAvLyBBZGQgYW5pbWF0YWJsZSBhdHRyaWJ1dGVzXG4gICAgLCBhdHRyOiBmdW5jdGlvbihhLCB2KSB7XG4gICAgICAgIGlmICh0eXBlb2YgYSA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBhKVxuICAgICAgICAgICAgdGhpcy5hdHRyKGtleSwgYVtrZXldKVxuICAgICAgICBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZnJvbSA9IHRoaXMudGFyZ2V0LmF0dHIoYSlcbiAgXG4gICAgICAgICAgdGhpcy5hdHRyc1thXSA9IFNWRy5Db2xvci5pc0NvbG9yKGZyb20pID9cbiAgICAgICAgICAgIG5ldyBTVkcuQ29sb3IoZnJvbSkubW9ycGgodikgOlxuICAgICAgICAgIFNWRy5yZWdleC51bml0LnRlc3QoZnJvbSkgP1xuICAgICAgICAgICAgbmV3IFNWRy5OdW1iZXIoZnJvbSkubW9ycGgodikgOlxuICAgICAgICAgICAgeyBmcm9tOiBmcm9tLCB0bzogdiB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gICAgICAvLyBBZGQgYW5pbWF0YWJsZSB0cmFuc2Zvcm1hdGlvbnNcbiAgICAsIHRyYW5zZm9ybTogZnVuY3Rpb24obywgdikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgLyogcGFyc2UgbWF0cml4IHN0cmluZyAqL1xuICAgICAgICAgIG8gPSBwYXJzZU1hdHJpeChvKVxuICAgICAgICAgIFxuICAgICAgICAgIC8qIGRsZXRlIG1hdHJpeHN0cmluZyBmcm9tIG9iamVjdCAqL1xuICAgICAgICAgIGRlbGV0ZSBvLm1hdHJpeFxuICAgICAgICAgIFxuICAgICAgICAgIC8qIHN0b3JlIG1hdHJpeCB2YWx1ZXMgKi9cbiAgICAgICAgICBmb3IgKHYgaW4gbylcbiAgICAgICAgICAgIHRoaXMudHJhbnNbdl0gPSB7IGZyb206IHRoaXMudGFyZ2V0LnRyYW5zW3ZdLCB0bzogb1t2XSB9XG4gICAgICAgICAgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLyogYXBwbHkgdHJhbnNmb3JtYXRpb25zIGFzIG9iamVjdCBpZiBrZXkgdmFsdWUgYXJndW1lbnRzIGFyZSBnaXZlbiovXG4gICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHt9XG4gICAgICAgICAgdHJhbnNmb3JtW29dID0gdlxuICAgICAgICAgIFxuICAgICAgICAgIHRoaXMudHJhbnNmb3JtKHRyYW5zZm9ybSlcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICAgIC8vIEFkZCBhbmltYXRhYmxlIHN0eWxlc1xuICAgICwgc3R5bGU6IGZ1bmN0aW9uKHMsIHYpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzID09ICdvYmplY3QnKVxuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzKVxuICAgICAgICAgICAgdGhpcy5zdHlsZShrZXksIHNba2V5XSlcbiAgICAgICAgXG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aGlzLnN0eWxlc1tzXSA9IHsgZnJvbTogdGhpcy50YXJnZXQuc3R5bGUocyksIHRvOiB2IH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gICAgICAvLyBBbmltYXRhYmxlIHgtYXhpc1xuICAgICwgeDogZnVuY3Rpb24oeCkge1xuICAgICAgICB0aGlzLl94ID0gbmV3IFNWRy5OdW1iZXIodGhpcy50YXJnZXQueCgpKS5tb3JwaCh4KVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICAgIC8vIEFuaW1hdGFibGUgeS1heGlzXG4gICAgLCB5OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHRoaXMuX3kgPSBuZXcgU1ZHLk51bWJlcih0aGlzLnRhcmdldC55KCkpLm1vcnBoKHkpXG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgICAgLy8gQW5pbWF0YWJsZSBjZW50ZXIgeC1heGlzXG4gICAgLCBjeDogZnVuY3Rpb24oeCkge1xuICAgICAgICB0aGlzLl9jeCA9IG5ldyBTVkcuTnVtYmVyKHRoaXMudGFyZ2V0LmN4KCkpLm1vcnBoKHgpXG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgICAgLy8gQW5pbWF0YWJsZSBjZW50ZXIgeS1heGlzXG4gICAgLCBjeTogZnVuY3Rpb24oeSkge1xuICAgICAgICB0aGlzLl9jeSA9IG5ldyBTVkcuTnVtYmVyKHRoaXMudGFyZ2V0LmN5KCkpLm1vcnBoKHkpXG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgICAgLy8gQWRkIGFuaW1hdGFibGUgbW92ZVxuICAgICwgbW92ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy54KHgpLnkoeSlcbiAgICAgIH1cbiAgICAgIC8vIEFkZCBhbmltYXRhYmxlIGNlbnRlclxuICAgICwgY2VudGVyOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN4KHgpLmN5KHkpXG4gICAgICB9XG4gICAgICAvLyBBZGQgYW5pbWF0YWJsZSBzaXplXG4gICAgLCBzaXplOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGlmICh0aGlzLnRhcmdldCBpbnN0YW5jZW9mIFNWRy5UZXh0KSB7XG4gICAgICAgICAgLyogYW5pbWF0ZSBmb250IHNpemUgZm9yIFRleHQgZWxlbWVudHMgKi9cbiAgICAgICAgICB0aGlzLmF0dHIoJ2ZvbnQtc2l6ZScsIHdpZHRoKVxuICAgICAgICAgIFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8qIGFuaW1hdGUgYmJveCBiYXNlZCBzaXplIGZvciBhbGwgb3RoZXIgZWxlbWVudHMgKi9cbiAgICAgICAgICB2YXIgYm94ID0gdGhpcy50YXJnZXQuYmJveCgpXG4gIFxuICAgICAgICAgIHRoaXMuX3NpemUgPSB7XG4gICAgICAgICAgICB3aWR0aDogIG5ldyBTVkcuTnVtYmVyKGJveC53aWR0aCkubW9ycGgod2lkdGgpXG4gICAgICAgICAgLCBoZWlnaHQ6IG5ldyBTVkcuTnVtYmVyKGJveC5oZWlnaHQpLm1vcnBoKGhlaWdodClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gICAgICAvLyBBZGQgYW5pbWF0YWJsZSBwbG90XG4gICAgLCBwbG90OiBmdW5jdGlvbihwKSB7XG4gICAgICAgIHRoaXMuX3Bsb3QgPSBwXG4gIFxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgICAgLy8gQWRkIGxlYWRpbmcgbWV0aG9kXG4gICAgLCBsZWFkaW5nOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy50YXJnZXQuX2xlYWRpbmcpXG4gICAgICAgICAgdGhpcy5fbGVhZGluZyA9IG5ldyBTVkcuTnVtYmVyKHRoaXMudGFyZ2V0Ll9sZWFkaW5nKS5tb3JwaCh2YWx1ZSlcbiAgXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gICAgICAvLyBBZGQgYW5pbWF0YWJsZSB2aWV3Ym94XG4gICAgLCB2aWV3Ym94OiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGlmICh0aGlzLnRhcmdldCBpbnN0YW5jZW9mIFNWRy5Db250YWluZXIpIHtcbiAgICAgICAgICB2YXIgYm94ID0gdGhpcy50YXJnZXQudmlld2JveCgpXG4gICAgICAgICAgXG4gICAgICAgICAgdGhpcy5fdmlld2JveCA9IHtcbiAgICAgICAgICAgIHg6ICAgICAgbmV3IFNWRy5OdW1iZXIoYm94LngpLm1vcnBoKHgpXG4gICAgICAgICAgLCB5OiAgICAgIG5ldyBTVkcuTnVtYmVyKGJveC55KS5tb3JwaCh5KVxuICAgICAgICAgICwgd2lkdGg6ICBuZXcgU1ZHLk51bWJlcihib3gud2lkdGgpLm1vcnBoKHdpZHRoKVxuICAgICAgICAgICwgaGVpZ2h0OiBuZXcgU1ZHLk51bWJlcihib3guaGVpZ2h0KS5tb3JwaChoZWlnaHQpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgICAgLy8gQWRkIGFuaW1hdGVhYmxlIGdyYWRpZW50IHVwZGF0ZVxuICAgICwgdXBkYXRlOiBmdW5jdGlvbihvKSB7XG4gICAgICAgIGlmICh0aGlzLnRhcmdldCBpbnN0YW5jZW9mIFNWRy5TdG9wKSB7XG4gICAgICAgICAgaWYgKG8ub3BhY2l0eSAhPSBudWxsKSB0aGlzLmF0dHIoJ3N0b3Atb3BhY2l0eScsIG8ub3BhY2l0eSlcbiAgICAgICAgICBpZiAoby5jb2xvciAgICE9IG51bGwpIHRoaXMuYXR0cignc3RvcC1jb2xvcicsIG8uY29sb3IpXG4gICAgICAgICAgaWYgKG8ub2Zmc2V0ICAhPSBudWxsKSB0aGlzLmF0dHIoJ29mZnNldCcsIG5ldyBTVkcuTnVtYmVyKG8ub2Zmc2V0KSlcbiAgICAgICAgfVxuICBcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICAgIC8vIEFkZCBjYWxsYmFjayBmb3IgZWFjaCBrZXlmcmFtZVxuICAgICwgZHVyaW5nOiBmdW5jdGlvbihkdXJpbmcpIHtcbiAgICAgICAgdGhpcy5fZHVyaW5nID0gZHVyaW5nXG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgICAgLy8gQ2FsbGJhY2sgYWZ0ZXIgYW5pbWF0aW9uXG4gICAgLCBhZnRlcjogZnVuY3Rpb24oYWZ0ZXIpIHtcbiAgICAgICAgdGhpcy5fYWZ0ZXIgPSBhZnRlclxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICAgIC8vIE1ha2UgbG9vcGFibGVcbiAgICAsIGxvb3A6IGZ1bmN0aW9uKHRpbWVzKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSB0aW1lcyB8fCB0cnVlXG4gIFxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgICAgLy8gU3RvcCBydW5uaW5nIGFuaW1hdGlvblxuICAgICwgc3RvcDogZnVuY3Rpb24oZnVsZmlsbCkge1xuICAgICAgICAvKiBmdWxmaWxsIGFuaW1hdGlvbiAqL1xuICAgICAgICBpZiAoZnVsZmlsbCA9PT0gdHJ1ZSkge1xuICBcbiAgICAgICAgICB0aGlzLmFuaW1hdGUoMClcbiAgXG4gICAgICAgICAgaWYgKHRoaXMuX2FmdGVyKVxuICAgICAgICAgICAgdGhpcy5fYWZ0ZXIuYXBwbHkodGhpcy50YXJnZXQsIFt0aGlzXSlcbiAgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLyogc3RvcCBjdXJyZW50IGFuaW1hdGlvbiAqL1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpXG4gIFxuICAgICAgICAgIC8qIHJlc2V0IHN0b3JhZ2UgZm9yIHByb3BlcnRpZXMgdGhhdCBuZWVkIGFuaW1hdGlvbiAqL1xuICAgICAgICAgIHRoaXMuYXR0cnMgICAgID0ge31cbiAgICAgICAgICB0aGlzLnRyYW5zICAgICA9IHt9XG4gICAgICAgICAgdGhpcy5zdHlsZXMgICAgPSB7fVxuICAgICAgICAgIHRoaXMuc2l0dWF0aW9uID0ge31cbiAgXG4gICAgICAgICAgLyogZGVsZXRlIGRlc3RpbmF0aW9ucyAqL1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl94XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX3lcbiAgICAgICAgICBkZWxldGUgdGhpcy5fY3hcbiAgICAgICAgICBkZWxldGUgdGhpcy5fY3lcbiAgICAgICAgICBkZWxldGUgdGhpcy5fc2l6ZVxuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wbG90XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX2xvb3BcbiAgICAgICAgICBkZWxldGUgdGhpcy5fYWZ0ZXJcbiAgICAgICAgICBkZWxldGUgdGhpcy5fZHVyaW5nXG4gICAgICAgICAgZGVsZXRlIHRoaXMuX2xlYWRpbmdcbiAgICAgICAgICBkZWxldGUgdGhpcy5fdmlld2JveFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgICAgLy8gUGF1c2UgcnVubmluZyBhbmltYXRpb25cbiAgICAsIHBhdXNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc2l0dWF0aW9uLnBsYXkgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLnNpdHVhdGlvbi5wbGF5ICA9IGZhbHNlXG4gICAgICAgICAgdGhpcy5zaXR1YXRpb24ucGF1c2UgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuICAgICAgICB9XG4gIFxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgICAgLy8gUGxheSBydW5uaW5nIGFuaW1hdGlvblxuICAgICwgcGxheTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnNpdHVhdGlvbi5wbGF5ID09PSBmYWxzZSkge1xuICAgICAgICAgIHZhciBwYXVzZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5zaXR1YXRpb24ucGF1c2VcbiAgICAgICAgICBcbiAgICAgICAgICB0aGlzLnNpdHVhdGlvbi5maW5pc2ggKz0gcGF1c2VcbiAgICAgICAgICB0aGlzLnNpdHVhdGlvbi5zdGFydCAgKz0gcGF1c2VcbiAgICAgICAgICB0aGlzLnNpdHVhdGlvbi5wbGF5ICAgID0gdHJ1ZVxuICAgICAgICB9XG4gIFxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgICAgXG4gICAgfVxuICBcbiAgICAvLyBEZWZpbmUgcGFyZW50IGNsYXNzXG4gICwgcGFyZW50OiBTVkcuRWxlbWVudFxuICBcbiAgICAvLyBBZGQgbWV0aG9kIHRvIHBhcmVudCBlbGVtZW50c1xuICAsIGNvbnN0cnVjdDoge1xuICAgICAgLy8gR2V0IGZ4IG1vZHVsZSBvciBjcmVhdGUgYSBuZXcgb25lLCB0aGVuIGFuaW1hdGUgd2l0aCBnaXZlbiBkdXJhdGlvbiBhbmQgZWFzZVxuICAgICAgYW5pbWF0ZTogZnVuY3Rpb24oZCwgZWFzZSwgZGVsYXkpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmZ4IHx8ICh0aGlzLmZ4ID0gbmV3IFNWRy5GWCh0aGlzKSkpLnN0b3AoKS5hbmltYXRlKGQsIGVhc2UsIGRlbGF5KVxuICAgICAgfVxuICAgICAgLy8gU3RvcCBjdXJyZW50IGFuaW1hdGlvbjsgdGhpcyBpcyBhbiBhbGlhcyB0byB0aGUgZnggaW5zdGFuY2VcbiAgICAsIHN0b3A6IGZ1bmN0aW9uKGZ1bGZpbGwpIHtcbiAgICAgICAgaWYgKHRoaXMuZngpXG4gICAgICAgICAgdGhpcy5meC5zdG9wKGZ1bGZpbGwpXG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgICAgLy8gUGF1c2UgY3VycmVudCBhbmltYXRpb25cbiAgICAsIHBhdXNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZngpXG4gICAgICAgICAgdGhpcy5meC5wYXVzZSgpXG4gIFxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgICAgLy8gUGxheSBwYXVzZWQgY3VycmVudCBhbmltYXRpb25cbiAgICAsIHBsYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5meClcbiAgICAgICAgICB0aGlzLmZ4LnBsYXkoKVxuICBcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICAgIFxuICAgIH1cbiAgfSlcblxuXG4gIFNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIFNWRy5GWCwge1xuICAgIC8vIFJlbGF0aXZlIG1vdmUgb3ZlciB4IGF4aXNcbiAgICBkeDogZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHRoaXMueCgodGhpcy50YXJnZXQgfHwgdGhpcykueCgpICsgeClcbiAgICB9XG4gICAgLy8gUmVsYXRpdmUgbW92ZSBvdmVyIHkgYXhpc1xuICAsIGR5OiBmdW5jdGlvbih5KSB7XG4gICAgICByZXR1cm4gdGhpcy55KCh0aGlzLnRhcmdldCB8fCB0aGlzKS55KCkgKyB5KVxuICAgIH1cbiAgICAvLyBSZWxhdGl2ZSBtb3ZlIG92ZXIgeCBhbmQgeSBheGVzXG4gICwgZG1vdmU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHJldHVybiB0aGlzLmR4KHgpLmR5KHkpXG4gICAgfVxuICBcbiAgfSlcblxuICA7WyAgJ2NsaWNrJ1xuICAgICwgJ2RibGNsaWNrJ1xuICAgICwgJ21vdXNlZG93bidcbiAgICAsICdtb3VzZXVwJ1xuICAgICwgJ21vdXNlb3ZlcidcbiAgICAsICdtb3VzZW91dCdcbiAgICAsICdtb3VzZW1vdmUnXG4gICAgLy8gLCAnbW91c2VlbnRlcicgLT4gbm90IHN1cHBvcnRlZCBieSBJRVxuICAgIC8vICwgJ21vdXNlbGVhdmUnIC0+IG5vdCBzdXBwb3J0ZWQgYnkgSUVcbiAgICAsICd0b3VjaHN0YXJ0J1xuICAgICwgJ3RvdWNobW92ZSdcbiAgICAsICd0b3VjaGxlYXZlJ1xuICAgICwgJ3RvdWNoZW5kJ1xuICAgICwgJ3RvdWNoY2FuY2VsJyBdLmZvckVhY2goZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBcbiAgICAvKiBhZGQgZXZlbnQgdG8gU1ZHLkVsZW1lbnQgKi9cbiAgICBTVkcuRWxlbWVudC5wcm90b3R5cGVbZXZlbnRdID0gZnVuY3Rpb24oZikge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgICBcbiAgICAgIC8qIGJpbmQgZXZlbnQgdG8gZWxlbWVudCByYXRoZXIgdGhhbiBlbGVtZW50IG5vZGUgKi9cbiAgICAgIHRoaXMubm9kZVsnb24nICsgZXZlbnRdID0gdHlwZW9mIGYgPT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gZi5hcHBseShzZWxmLCBhcmd1bWVudHMpIH0gOiBudWxsXG4gICAgICBcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIFxuICB9KVxuICBcbiAgLy8gSW5pdGlhbGl6ZSBldmVudHMgYW5kIGxpc3RlbmVycyBzdGFja1xuICBTVkcuZXZlbnRzID0ge31cbiAgU1ZHLmxpc3RlbmVycyA9IHt9XG4gIFxuICAvLyBFdmVudCBjb25zdHJ1Y3RvclxuICBTVkcucmVnaXN0ZXJFdmVudCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKCFTVkcuZXZlbnRzW2V2ZW50XSlcbiAgICAgIFNWRy5ldmVudHNbZXZlbnRdID0gbmV3IEN1c3RvbUV2ZW50KGV2ZW50KVxuICB9XG4gIFxuICAvLyBBZGQgZXZlbnQgYmluZGVyIGluIHRoZSBTVkcgbmFtZXNwYWNlXG4gIFNWRy5vbiA9IGZ1bmN0aW9uKG5vZGUsIGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIC8vIGNyZWF0ZSBsaXN0ZW5lclxuICAgIHZhciBsID0gbGlzdGVuZXIuYmluZChub2RlLmluc3RhbmNlIHx8IG5vZGUpXG4gIFxuICAgIC8vIGVuc3VyZSByZWZlcmVuY2Ugb2JqZWN0c1xuICAgIFNWRy5saXN0ZW5lcnNbbm9kZV0gICAgICAgID0gU1ZHLmxpc3RlbmVyc1tub2RlXSAgICAgICAgfHwge31cbiAgICBTVkcubGlzdGVuZXJzW25vZGVdW2V2ZW50XSA9IFNWRy5saXN0ZW5lcnNbbm9kZV1bZXZlbnRdIHx8IHt9XG4gIFxuICAgIC8vIHJlZmVyZW5jZSBsaXN0ZW5lclxuICAgIFNWRy5saXN0ZW5lcnNbbm9kZV1bZXZlbnRdW2xpc3RlbmVyXSA9IGxcbiAgXG4gICAgLy8gYWRkIGxpc3RlbmVyXG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsLCBmYWxzZSlcbiAgfVxuICBcbiAgLy8gQWRkIGV2ZW50IHVuYmluZGVyIGluIHRoZSBTVkcgbmFtZXNwYWNlXG4gIFNWRy5vZmYgPSBmdW5jdGlvbihub2RlLCBldmVudCwgbGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIC8vIHJlbW92ZSBsaXN0ZW5lciByZWZlcmVuY2VcbiAgICAgIGlmIChTVkcubGlzdGVuZXJzW25vZGVdICYmIFNWRy5saXN0ZW5lcnNbbm9kZV1bZXZlbnRdKSB7XG4gICAgICAgIC8vIHJlbW92ZSBsaXN0ZW5lclxuICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIFNWRy5saXN0ZW5lcnNbbm9kZV1bZXZlbnRdW2xpc3RlbmVyXSwgZmFsc2UpXG4gIFxuICAgICAgICBkZWxldGUgU1ZHLmxpc3RlbmVyc1tub2RlXVtldmVudF1bbGlzdGVuZXJdXG4gICAgICB9XG4gIFxuICAgIH0gZWxzZSBpZiAoZXZlbnQpIHtcbiAgICAgIC8vIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvciB0aGUgZXZlbnRcbiAgICAgIGlmIChTVkcubGlzdGVuZXJzW25vZGVdW2V2ZW50XSkge1xuICAgICAgICBmb3IgKGxpc3RlbmVyIGluIFNWRy5saXN0ZW5lcnNbbm9kZV1bZXZlbnRdKVxuICAgICAgICAgIFNWRy5vZmYobm9kZSwgZXZlbnQsIGxpc3RlbmVyKVxuICBcbiAgICAgICAgZGVsZXRlIFNWRy5saXN0ZW5lcnNbbm9kZV1bZXZlbnRdXG4gICAgICB9XG4gIFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZW1vdmUgYWxsIGxpc3RlbmVycyBvbiBhIGdpdmVuIG5vZGVcbiAgICAgIGlmIChTVkcubGlzdGVuZXJzW25vZGVdKSB7XG4gICAgICAgIGZvciAoZXZlbnQgaW4gU1ZHLmxpc3RlbmVyc1tub2RlXSlcbiAgICAgICAgICBTVkcub2ZmKG5vZGUsIGV2ZW50KVxuICBcbiAgICAgICAgZGVsZXRlIFNWRy5saXN0ZW5lcnNbbm9kZV1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIC8vXG4gIFNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcbiAgICAvLyBCaW5kIGdpdmVuIGV2ZW50IHRvIGxpc3RlbmVyXG4gICAgb246IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgU1ZHLm9uKHRoaXMubm9kZSwgZXZlbnQsIGxpc3RlbmVyKVxuICAgICAgXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICAvLyBVbmJpbmQgZXZlbnQgZnJvbSBsaXN0ZW5lclxuICAsIG9mZjogZnVuY3Rpb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICBTVkcub2ZmKHRoaXMubm9kZSwgZXZlbnQsIGxpc3RlbmVyKVxuICAgICAgXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICAvLyBGaXJlIGdpdmVuIGV2ZW50XG4gICwgZmlyZTogZnVuY3Rpb24oZXZlbnQsIGRhdGEpIHtcbiAgICAgIC8vIEFkZCBkZXRhaWwgZGF0YSB0byBldmVudFxuICAgICAgU1ZHLmV2ZW50c1tldmVudF0uZGV0YWlsID0gZGF0YVxuICAgICAgXG4gICAgICAvLyBEaXNwYXRjaCBldmVudFxuICAgICAgdGhpcy5ub2RlLmRpc3BhdGNoRXZlbnQoU1ZHLmV2ZW50c1tldmVudF0pXG4gIFxuICAgICAgLy8gUmVtb3ZlIGRldGFpbFxuICAgICAgZGVsZXRlIFNWRy5ldmVudHNbZXZlbnRdLmRldGFpbFxuICBcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICB9KVxuXG4gIFNWRy5EZWZzID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgY3JlYXRlOiAnZGVmcydcbiAgXG4gICAgLy8gSW5oZXJpdCBmcm9tXG4gICwgaW5oZXJpdDogU1ZHLkNvbnRhaW5lclxuICAgIFxuICB9KVxuXG4gIFNWRy5HID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgY3JlYXRlOiAnZydcbiAgXG4gICAgLy8gSW5oZXJpdCBmcm9tXG4gICwgaW5oZXJpdDogU1ZHLkNvbnRhaW5lclxuICAgIFxuICAgIC8vIEFkZCBjbGFzcyBtZXRob2RzXG4gICwgZXh0ZW5kOiB7XG4gICAgICAvLyBNb3ZlIG92ZXIgeC1heGlzXG4gICAgICB4OiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiB4ID09IG51bGwgPyB0aGlzLnRyYW5zLnggOiB0aGlzLnRyYW5zZm9ybSgneCcsIHgpXG4gICAgICB9XG4gICAgICAvLyBNb3ZlIG92ZXIgeS1heGlzXG4gICAgLCB5OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB5ID09IG51bGwgPyB0aGlzLnRyYW5zLnkgOiB0aGlzLnRyYW5zZm9ybSgneScsIHkpXG4gICAgICB9XG4gICAgICAvLyBNb3ZlIGJ5IGNlbnRlciBvdmVyIHgtYXhpc1xuICAgICwgY3g6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIHggPT0gbnVsbCA/IHRoaXMuYmJveCgpLmN4IDogdGhpcy54KHggLSB0aGlzLmJib3goKS53aWR0aCAvIDIpXG4gICAgICB9XG4gICAgICAvLyBNb3ZlIGJ5IGNlbnRlciBvdmVyIHktYXhpc1xuICAgICwgY3k6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHkgPT0gbnVsbCA/IHRoaXMuYmJveCgpLmN5IDogdGhpcy55KHkgLSB0aGlzLmJib3goKS5oZWlnaHQgLyAyKVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAsIGNvbnN0cnVjdDoge1xuICAgICAgLy8gQ3JlYXRlIGEgZ3JvdXAgZWxlbWVudFxuICAgICAgZ3JvdXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5HKVxuICAgICAgfVxuICAgIH1cbiAgfSlcblxuICBTVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCB7XG4gICAgLy8gR2V0IGFsbCBzaWJsaW5ncywgaW5jbHVkaW5nIG15c2VsZlxuICAgIHNpYmxpbmdzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5jaGlsZHJlbigpXG4gICAgfVxuICAgIC8vIEdldCB0aGUgY3VyZW50IHBvc2l0aW9uIHNpYmxpbmdzXG4gICwgcG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmluZGV4KHRoaXMpXG4gICAgfVxuICAgIC8vIEdldCB0aGUgbmV4dCBlbGVtZW50ICh3aWxsIHJldHVybiBudWxsIGlmIHRoZXJlIGlzIG5vbmUpXG4gICwgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaWJsaW5ncygpW3RoaXMucG9zaXRpb24oKSArIDFdXG4gICAgfVxuICAgIC8vIEdldCB0aGUgbmV4dCBlbGVtZW50ICh3aWxsIHJldHVybiBudWxsIGlmIHRoZXJlIGlzIG5vbmUpXG4gICwgcHJldmlvdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2libGluZ3MoKVt0aGlzLnBvc2l0aW9uKCkgLSAxXVxuICAgIH1cbiAgICAvLyBTZW5kIGdpdmVuIGVsZW1lbnQgb25lIHN0ZXAgZm9yd2FyZFxuICAsIGZvcndhcmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGkgPSB0aGlzLnBvc2l0aW9uKClcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5yZW1vdmVFbGVtZW50KHRoaXMpLnB1dCh0aGlzLCBpICsgMSlcbiAgICB9XG4gICAgLy8gU2VuZCBnaXZlbiBlbGVtZW50IG9uZSBzdGVwIGJhY2t3YXJkXG4gICwgYmFja3dhcmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGkgPSB0aGlzLnBvc2l0aW9uKClcbiAgICAgIFxuICAgICAgaWYgKGkgPiAwKVxuICAgICAgICB0aGlzLnBhcmVudC5yZW1vdmVFbGVtZW50KHRoaXMpLmFkZCh0aGlzLCBpIC0gMSlcbiAgXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICAvLyBTZW5kIGdpdmVuIGVsZW1lbnQgYWxsIHRoZSB3YXkgdG8gdGhlIGZyb250XG4gICwgZnJvbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnJlbW92ZUVsZW1lbnQodGhpcykucHV0KHRoaXMpXG4gICAgfVxuICAgIC8vIFNlbmQgZ2l2ZW4gZWxlbWVudCBhbGwgdGhlIHdheSB0byB0aGUgYmFja1xuICAsIGJhY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucG9zaXRpb24oKSA+IDApXG4gICAgICAgIHRoaXMucGFyZW50LnJlbW92ZUVsZW1lbnQodGhpcykuYWRkKHRoaXMsIDApXG4gICAgICBcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIC8vIEluc2VydHMgYSBnaXZlbiBlbGVtZW50IGJlZm9yZSB0aGUgdGFyZ2V0ZWQgZWxlbWVudFxuICAsIGJlZm9yZTogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgZWxlbWVudC5yZW1vdmUoKVxuICBcbiAgICAgIHZhciBpID0gdGhpcy5wb3NpdGlvbigpXG4gICAgICBcbiAgICAgIHRoaXMucGFyZW50LmFkZChlbGVtZW50LCBpKVxuICBcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIC8vIEluc3RlcnMgYSBnaXZlbiBlbGVtZW50IGFmdGVyIHRoZSB0YXJnZXRlZCBlbGVtZW50XG4gICwgYWZ0ZXI6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlKClcbiAgICAgIFxuICAgICAgdmFyIGkgPSB0aGlzLnBvc2l0aW9uKClcbiAgICAgIFxuICAgICAgdGhpcy5wYXJlbnQuYWRkKGVsZW1lbnQsIGkgKyAxKVxuICBcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICBcbiAgfSlcblxuICBTVkcuTWFzayA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgIGNyZWF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgU1ZHLmNyZWF0ZSgnbWFzaycpKVxuICBcbiAgICAgIC8qIGtlZXAgcmVmZXJlbmNlcyB0byBtYXNrZWQgZWxlbWVudHMgKi9cbiAgICAgIHRoaXMudGFyZ2V0cyA9IFtdXG4gICAgfVxuICBcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgLCBpbmhlcml0OiBTVkcuQ29udGFpbmVyXG4gIFxuICAgIC8vIEFkZCBjbGFzcyBtZXRob2RzXG4gICwgZXh0ZW5kOiB7XG4gICAgICAvLyBVbm1hc2sgYWxsIG1hc2tlZCBlbGVtZW50cyBhbmQgcmVtb3ZlIGl0c2VsZlxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLyogdW5tYXNrIGFsbCB0YXJnZXRzICovXG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRhcmdldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgaWYgKHRoaXMudGFyZ2V0c1tpXSlcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0c1tpXS51bm1hc2soKVxuICAgICAgICBkZWxldGUgdGhpcy50YXJnZXRzXG4gIFxuICAgICAgICAvKiByZW1vdmUgbWFzayBmcm9tIHBhcmVudCAqL1xuICAgICAgICB0aGlzLnBhcmVudC5yZW1vdmVFbGVtZW50KHRoaXMpXG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAsIGNvbnN0cnVjdDoge1xuICAgICAgLy8gQ3JlYXRlIG1hc2tpbmcgZWxlbWVudFxuICAgICAgbWFzazogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZnMoKS5wdXQobmV3IFNWRy5NYXNrKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgXG4gIFxuICBTVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCB7XG4gICAgLy8gRGlzdHJpYnV0ZSBtYXNrIHRvIHN2ZyBlbGVtZW50XG4gICAgbWFza1dpdGg6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIC8qIHVzZSBnaXZlbiBtYXNrIG9yIGNyZWF0ZSBhIG5ldyBvbmUgKi9cbiAgICAgIHRoaXMubWFza2VyID0gZWxlbWVudCBpbnN0YW5jZW9mIFNWRy5NYXNrID8gZWxlbWVudCA6IHRoaXMucGFyZW50Lm1hc2soKS5hZGQoZWxlbWVudClcbiAgXG4gICAgICAvKiBzdG9yZSByZXZlcmVuY2Ugb24gc2VsZiBpbiBtYXNrICovXG4gICAgICB0aGlzLm1hc2tlci50YXJnZXRzLnB1c2godGhpcylcbiAgICAgIFxuICAgICAgLyogYXBwbHkgbWFzayAqL1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cignbWFzaycsICd1cmwoXCIjJyArIHRoaXMubWFza2VyLmF0dHIoJ2lkJykgKyAnXCIpJylcbiAgICB9XG4gICAgLy8gVW5tYXNrIGVsZW1lbnRcbiAgLCB1bm1hc2s6IGZ1bmN0aW9uKCkge1xuICAgICAgZGVsZXRlIHRoaXMubWFza2VyXG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdtYXNrJywgbnVsbClcbiAgICB9XG4gICAgXG4gIH0pXG5cblxuICBTVkcuQ2xpcCA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgIGNyZWF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgU1ZHLmNyZWF0ZSgnY2xpcFBhdGgnKSlcbiAgXG4gICAgICAvKiBrZWVwIHJlZmVyZW5jZXMgdG8gY2xpcHBlZCBlbGVtZW50cyAqL1xuICAgICAgdGhpcy50YXJnZXRzID0gW11cbiAgICB9XG4gIFxuICAgIC8vIEluaGVyaXQgZnJvbVxuICAsIGluaGVyaXQ6IFNWRy5Db250YWluZXJcbiAgXG4gICAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcbiAgLCBleHRlbmQ6IHtcbiAgICAgIC8vIFVuY2xpcCBhbGwgY2xpcHBlZCBlbGVtZW50cyBhbmQgcmVtb3ZlIGl0c2VsZlxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLyogdW5jbGlwIGFsbCB0YXJnZXRzICovXG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRhcmdldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgaWYgKHRoaXMudGFyZ2V0c1tpXSlcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0c1tpXS51bmNsaXAoKVxuICAgICAgICBkZWxldGUgdGhpcy50YXJnZXRzXG4gIFxuICAgICAgICAvKiByZW1vdmUgY2xpcFBhdGggZnJvbSBwYXJlbnQgKi9cbiAgICAgICAgdGhpcy5wYXJlbnQucmVtb3ZlRWxlbWVudCh0aGlzKVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgLCBjb25zdHJ1Y3Q6IHtcbiAgICAgIC8vIENyZWF0ZSBjbGlwcGluZyBlbGVtZW50XG4gICAgICBjbGlwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmcygpLnB1dChuZXcgU1ZHLkNsaXApXG4gICAgICB9XG4gICAgfVxuICB9KVxuICBcbiAgLy9cbiAgU1ZHLmV4dGVuZChTVkcuRWxlbWVudCwge1xuICAgIC8vIERpc3RyaWJ1dGUgY2xpcFBhdGggdG8gc3ZnIGVsZW1lbnRcbiAgICBjbGlwV2l0aDogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgLyogdXNlIGdpdmVuIGNsaXAgb3IgY3JlYXRlIGEgbmV3IG9uZSAqL1xuICAgICAgdGhpcy5jbGlwcGVyID0gZWxlbWVudCBpbnN0YW5jZW9mIFNWRy5DbGlwID8gZWxlbWVudCA6IHRoaXMucGFyZW50LmNsaXAoKS5hZGQoZWxlbWVudClcbiAgXG4gICAgICAvKiBzdG9yZSByZXZlcmVuY2Ugb24gc2VsZiBpbiBtYXNrICovXG4gICAgICB0aGlzLmNsaXBwZXIudGFyZ2V0cy5wdXNoKHRoaXMpXG4gICAgICBcbiAgICAgIC8qIGFwcGx5IG1hc2sgKi9cbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2NsaXAtcGF0aCcsICd1cmwoXCIjJyArIHRoaXMuY2xpcHBlci5hdHRyKCdpZCcpICsgJ1wiKScpXG4gICAgfVxuICAgIC8vIFVuY2xpcCBlbGVtZW50XG4gICwgdW5jbGlwOiBmdW5jdGlvbigpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmNsaXBwZXJcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2NsaXAtcGF0aCcsIG51bGwpXG4gICAgfVxuICAgIFxuICB9KVxuXG4gIFNWRy5HcmFkaWVudCA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgIGNyZWF0ZTogZnVuY3Rpb24odHlwZSkge1xuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIFNWRy5jcmVhdGUodHlwZSArICdHcmFkaWVudCcpKVxuICAgICAgXG4gICAgICAvKiBzdG9yZSB0eXBlICovXG4gICAgICB0aGlzLnR5cGUgPSB0eXBlXG4gICAgfVxuICBcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgLCBpbmhlcml0OiBTVkcuQ29udGFpbmVyXG4gIFxuICAgIC8vIEFkZCBjbGFzcyBtZXRob2RzXG4gICwgZXh0ZW5kOiB7XG4gICAgICAvLyBGcm9tIHBvc2l0aW9uXG4gICAgICBmcm9tOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gJ3JhZGlhbCcgP1xuICAgICAgICAgIHRoaXMuYXR0cih7IGZ4OiBuZXcgU1ZHLk51bWJlcih4KSwgZnk6IG5ldyBTVkcuTnVtYmVyKHkpIH0pIDpcbiAgICAgICAgICB0aGlzLmF0dHIoeyB4MTogbmV3IFNWRy5OdW1iZXIoeCksIHkxOiBuZXcgU1ZHLk51bWJlcih5KSB9KVxuICAgICAgfVxuICAgICAgLy8gVG8gcG9zaXRpb25cbiAgICAsIHRvOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gJ3JhZGlhbCcgP1xuICAgICAgICAgIHRoaXMuYXR0cih7IGN4OiBuZXcgU1ZHLk51bWJlcih4KSwgY3k6IG5ldyBTVkcuTnVtYmVyKHkpIH0pIDpcbiAgICAgICAgICB0aGlzLmF0dHIoeyB4MjogbmV3IFNWRy5OdW1iZXIoeCksIHkyOiBuZXcgU1ZHLk51bWJlcih5KSB9KVxuICAgICAgfVxuICAgICAgLy8gUmFkaXVzIGZvciByYWRpYWwgZ3JhZGllbnRcbiAgICAsIHJhZGl1czogZnVuY3Rpb24ocikge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09ICdyYWRpYWwnID9cbiAgICAgICAgICB0aGlzLmF0dHIoeyByOiBuZXcgU1ZHLk51bWJlcihyKSB9KSA6XG4gICAgICAgICAgdGhpc1xuICAgICAgfVxuICAgICAgLy8gQWRkIGEgY29sb3Igc3RvcFxuICAgICwgYXQ6IGZ1bmN0aW9uKG9mZnNldCwgY29sb3IsIG9wYWNpdHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuU3RvcCkudXBkYXRlKG9mZnNldCwgY29sb3IsIG9wYWNpdHkpXG4gICAgICB9XG4gICAgICAvLyBVcGRhdGUgZ3JhZGllbnRcbiAgICAsIHVwZGF0ZTogZnVuY3Rpb24oYmxvY2spIHtcbiAgICAgICAgLyogcmVtb3ZlIGFsbCBzdG9wcyAqL1xuICAgICAgICB0aGlzLmNsZWFyKClcbiAgICAgICAgXG4gICAgICAgIC8qIGludm9rZSBwYXNzZWQgYmxvY2sgKi9cbiAgICAgICAgaWYgKHR5cGVvZiBibG9jayA9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgIGJsb2NrLmNhbGwodGhpcywgdGhpcylcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gICAgICAvLyBSZXR1cm4gdGhlIGZpbGwgaWRcbiAgICAsIGZpbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJ3VybCgjJyArIHRoaXMuaWQoKSArICcpJ1xuICAgICAgfVxuICAgICAgLy8gQWxpYXMgc3RyaW5nIGNvbnZlcnRpb24gdG8gZmlsbFxuICAgICwgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWxsKClcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgLCBjb25zdHJ1Y3Q6IHtcbiAgICAgIC8vIENyZWF0ZSBncmFkaWVudCBlbGVtZW50IGluIGRlZnNcbiAgICAgIGdyYWRpZW50OiBmdW5jdGlvbih0eXBlLCBibG9jaykge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWZzKCkuZ3JhZGllbnQodHlwZSwgYmxvY2spXG4gICAgICB9XG4gICAgfVxuICB9KVxuICBcbiAgU1ZHLmV4dGVuZChTVkcuRGVmcywge1xuICAgIC8vIGRlZmluZSBncmFkaWVudFxuICAgIGdyYWRpZW50OiBmdW5jdGlvbih0eXBlLCBibG9jaykge1xuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuR3JhZGllbnQodHlwZSkpLnVwZGF0ZShibG9jaylcbiAgICB9XG4gICAgXG4gIH0pXG4gIFxuICBTVkcuU3RvcCA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgIGNyZWF0ZTogJ3N0b3AnXG4gIFxuICAgIC8vIEluaGVyaXQgZnJvbVxuICAsIGluaGVyaXQ6IFNWRy5FbGVtZW50XG4gIFxuICAgIC8vIEFkZCBjbGFzcyBtZXRob2RzXG4gICwgZXh0ZW5kOiB7XG4gICAgICAvLyBhZGQgY29sb3Igc3RvcHNcbiAgICAgIHVwZGF0ZTogZnVuY3Rpb24obykge1xuICAgICAgICBpZiAodHlwZW9mIG8gPT0gJ251bWJlcicgfHwgbyBpbnN0YW5jZW9mIFNWRy5OdW1iZXIpIHtcbiAgICAgICAgICBvID0ge1xuICAgICAgICAgICAgb2Zmc2V0OiAgYXJndW1lbnRzWzBdXG4gICAgICAgICAgLCBjb2xvcjogICBhcmd1bWVudHNbMV1cbiAgICAgICAgICAsIG9wYWNpdHk6IGFyZ3VtZW50c1syXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICBcbiAgICAgICAgLyogc2V0IGF0dHJpYnV0ZXMgKi9cbiAgICAgICAgaWYgKG8ub3BhY2l0eSAhPSBudWxsKSB0aGlzLmF0dHIoJ3N0b3Atb3BhY2l0eScsIG8ub3BhY2l0eSlcbiAgICAgICAgaWYgKG8uY29sb3IgICAhPSBudWxsKSB0aGlzLmF0dHIoJ3N0b3AtY29sb3InLCBvLmNvbG9yKVxuICAgICAgICBpZiAoby5vZmZzZXQgICE9IG51bGwpIHRoaXMuYXR0cignb2Zmc2V0JywgbmV3IFNWRy5OdW1iZXIoby5vZmZzZXQpKVxuICBcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICB9XG4gIFxuICB9KVxuXG5cbiAgU1ZHLlBhdHRlcm4gPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6ICdwYXR0ZXJuJ1xuICBcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgLCBpbmhlcml0OiBTVkcuQ29udGFpbmVyXG4gIFxuICAgIC8vIEFkZCBjbGFzcyBtZXRob2RzXG4gICwgZXh0ZW5kOiB7XG4gICAgICAvLyBSZXR1cm4gdGhlIGZpbGwgaWRcbiAgXHQgIGZpbGw6IGZ1bmN0aW9uKCkge1xuICBcdCAgICByZXR1cm4gJ3VybCgjJyArIHRoaXMuaWQoKSArICcpJ1xuICBcdCAgfVxuICBcdCAgLy8gVXBkYXRlIHBhdHRlcm4gYnkgcmVidWlsZGluZ1xuICBcdCwgdXBkYXRlOiBmdW5jdGlvbihibG9jaykge1xuICBcdFx0XHQvKiByZW1vdmUgY29udGVudCAqL1xuICAgICAgICB0aGlzLmNsZWFyKClcbiAgICAgICAgXG4gICAgICAgIC8qIGludm9rZSBwYXNzZWQgYmxvY2sgKi9cbiAgICAgICAgaWYgKHR5cGVvZiBibG9jayA9PSAnZnVuY3Rpb24nKVxuICAgICAgICBcdGJsb2NrLmNhbGwodGhpcywgdGhpcylcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0aGlzXG4gIFx0XHR9XG4gIFx0ICAvLyBBbGlhcyBzdHJpbmcgY29udmVydGlvbiB0byBmaWxsXG4gIFx0LCB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gIFx0ICAgIHJldHVybiB0aGlzLmZpbGwoKVxuICBcdCAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAsIGNvbnN0cnVjdDoge1xuICAgICAgLy8gQ3JlYXRlIHBhdHRlcm4gZWxlbWVudCBpbiBkZWZzXG4gIFx0ICBwYXR0ZXJuOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBibG9jaykge1xuICBcdCAgICByZXR1cm4gdGhpcy5kZWZzKCkucGF0dGVybih3aWR0aCwgaGVpZ2h0LCBibG9jaylcbiAgXHQgIH1cbiAgICB9XG4gIH0pXG4gIFxuICBTVkcuZXh0ZW5kKFNWRy5EZWZzLCB7XG4gICAgLy8gRGVmaW5lIGdyYWRpZW50XG4gICAgcGF0dGVybjogZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgYmxvY2spIHtcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLlBhdHRlcm4pLnVwZGF0ZShibG9jaykuYXR0cih7XG4gICAgICAgIHg6ICAgICAgICAgICAgMFxuICAgICAgLCB5OiAgICAgICAgICAgIDBcbiAgICAgICwgd2lkdGg6ICAgICAgICB3aWR0aFxuICAgICAgLCBoZWlnaHQ6ICAgICAgIGhlaWdodFxuICAgICAgLCBwYXR0ZXJuVW5pdHM6ICd1c2VyU3BhY2VPblVzZSdcbiAgICAgIH0pXG4gICAgfVxuICBcbiAgfSlcblxuICBTVkcuRG9jID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgY3JlYXRlOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAvKiBlbnN1cmUgdGhlIHByZXNlbmNlIG9mIGEgaHRtbCBlbGVtZW50ICovXG4gICAgICB0aGlzLnBhcmVudCA9IHR5cGVvZiBlbGVtZW50ID09ICdzdHJpbmcnID9cbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudCkgOlxuICAgICAgICBlbGVtZW50XG4gICAgICBcbiAgICAgIC8qIElmIHRoZSB0YXJnZXQgaXMgYW4gc3ZnIGVsZW1lbnQsIHVzZSB0aGF0IGVsZW1lbnQgYXMgdGhlIG1haW4gd3JhcHBlci5cbiAgICAgICAgIFRoaXMgYWxsb3dzIHN2Zy5qcyB0byB3b3JrIHdpdGggc3ZnIGRvY3VtZW50cyBhcyB3ZWxsLiAqL1xuICAgICAgdGhpcy5jb25zdHJ1Y3RvclxuICAgICAgICAuY2FsbCh0aGlzLCB0aGlzLnBhcmVudC5ub2RlTmFtZSA9PSAnc3ZnJyA/IHRoaXMucGFyZW50IDogU1ZHLmNyZWF0ZSgnc3ZnJykpXG4gICAgICBcbiAgICAgIC8qIHNldCBzdmcgZWxlbWVudCBhdHRyaWJ1dGVzICovXG4gICAgICB0aGlzXG4gICAgICAgIC5hdHRyKHsgeG1sbnM6IFNWRy5ucywgdmVyc2lvbjogJzEuMScsIHdpZHRoOiAnMTAwJScsIGhlaWdodDogJzEwMCUnIH0pXG4gICAgICAgIC5hdHRyKCd4bWxuczp4bGluaycsIFNWRy54bGluaywgU1ZHLnhtbG5zKVxuICAgICAgXG4gICAgICAvKiBjcmVhdGUgdGhlIDxkZWZzPiBub2RlICovXG4gICAgICB0aGlzLl9kZWZzID0gbmV3IFNWRy5EZWZzXG4gICAgICB0aGlzLl9kZWZzLnBhcmVudCA9IHRoaXNcbiAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZCh0aGlzLl9kZWZzLm5vZGUpXG4gIFxuICAgICAgLyogdHVybiBvZmYgc3ViIHBpeGVsIG9mZnNldCBieSBkZWZhdWx0ICovXG4gICAgICB0aGlzLmRvU3BvZiA9IGZhbHNlXG4gICAgICBcbiAgICAgIC8qIGVuc3VyZSBjb3JyZWN0IHJlbmRlcmluZyAqL1xuICAgICAgaWYgKHRoaXMucGFyZW50ICE9IHRoaXMubm9kZSlcbiAgICAgICAgdGhpcy5zdGFnZSgpXG4gICAgfVxuICBcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgLCBpbmhlcml0OiBTVkcuQ29udGFpbmVyXG4gIFxuICAgIC8vIEFkZCBjbGFzcyBtZXRob2RzXG4gICwgZXh0ZW5kOiB7XG4gICAgICAvKiBlbmFibGUgZHJhd2luZyAqL1xuICAgICAgc3RhZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXNcbiAgXG4gICAgICAgIC8qIGluc2VydCBlbGVtZW50ICovXG4gICAgICAgIHRoaXMucGFyZW50LmFwcGVuZENoaWxkKHRoaXMubm9kZSlcbiAgXG4gICAgICAgIC8qIGZpeCBzdWItcGl4ZWwgb2Zmc2V0ICovXG4gICAgICAgIGVsZW1lbnQuc3BvZigpXG4gICAgICAgIFxuICAgICAgICAvKiBtYWtlIHN1cmUgc3ViLXBpeGVsIG9mZnNldCBpcyBmaXhlZCBldmVyeSB0aW1lIHRoZSB3aW5kb3cgaXMgcmVzaXplZCAqL1xuICAgICAgICBTVkcub24od2luZG93LCAncmVzaXplJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZWxlbWVudC5zcG9mKClcbiAgICAgICAgfSlcbiAgXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gIFxuICAgICAgLy8gQ3JlYXRlcyBhbmQgcmV0dXJucyBkZWZzIGVsZW1lbnRcbiAgICAsIGRlZnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmc1xuICAgICAgfVxuICBcbiAgICAgIC8vIEZpeCBmb3IgcG9zc2libGUgc3ViLXBpeGVsIG9mZnNldC4gU2VlOlxuICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjA4ODEyXG4gICAgLCBzcG9mOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9TcG9mKSB7XG4gICAgICAgICAgdmFyIHBvcyA9IHRoaXMubm9kZS5nZXRTY3JlZW5DVE0oKVxuICAgICAgICAgIFxuICAgICAgICAgIGlmIChwb3MpXG4gICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICAgIC5zdHlsZSgnbGVmdCcsICgtcG9zLmUgJSAxKSArICdweCcpXG4gICAgICAgICAgICAgIC5zdHlsZSgndG9wJywgICgtcG9zLmYgJSAxKSArICdweCcpXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gIFxuICAgICAgLy8gRW5hYmxlIHN1Yi1waXhlbCBvZmZzZXRcbiAgICAsIGZpeFN1YlBpeGVsT2Zmc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kb1Nwb2YgPSB0cnVlXG4gIFxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgfSlcblxuXG4gIFNWRy5TaGFwZSA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgIGNyZWF0ZTogZnVuY3Rpb24oZWxlbWVudCkge1xuICBcdCAgdGhpcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIGVsZW1lbnQpXG4gIFx0fVxuICBcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgLCBpbmhlcml0OiBTVkcuRWxlbWVudFxuICBcbiAgfSlcblxuICBTVkcuU3ltYm9sID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgY3JlYXRlOiAnc3ltYm9sJ1xuICBcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgLCBpbmhlcml0OiBTVkcuQ29udGFpbmVyXG4gIFxuICAgIC8vIEFkZCBwYXJlbnQgbWV0aG9kXG4gICwgY29uc3RydWN0OiB7XG4gICAgICAvLyBDcmVhdGUgYSBuZXcgc3ltYm9sXG4gICAgICBzeW1ib2w6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWZzKCkucHV0KG5ldyBTVkcuU3ltYm9sKVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgfSlcblxuICBTVkcuVXNlID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgY3JlYXRlOiAndXNlJ1xuICBcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgLCBpbmhlcml0OiBTVkcuU2hhcGVcbiAgXG4gICAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcbiAgLCBleHRlbmQ6IHtcbiAgICAgIC8vIFVzZSBlbGVtZW50IGFzIGEgcmVmZXJlbmNlXG4gICAgICBlbGVtZW50OiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIC8qIHN0b3JlIHRhcmdldCBlbGVtZW50ICovXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gZWxlbWVudFxuICBcbiAgICAgICAgLyogc2V0IGxpbmVkIGVsZW1lbnQgKi9cbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cignaHJlZicsICcjJyArIGVsZW1lbnQsIFNWRy54bGluaylcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgLCBjb25zdHJ1Y3Q6IHtcbiAgICAgIC8vIENyZWF0ZSBhIHVzZSBlbGVtZW50XG4gICAgICB1c2U6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuVXNlKS5lbGVtZW50KGVsZW1lbnQpXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIFNWRy5SZWN0ID0gU1ZHLmludmVudCh7XG4gIFx0Ly8gSW5pdGlhbGl6ZSBub2RlXG4gICAgY3JlYXRlOiAncmVjdCdcbiAgXG4gIFx0Ly8gSW5oZXJpdCBmcm9tXG4gICwgaW5oZXJpdDogU1ZHLlNoYXBlXG4gIFx0XG4gIFx0Ly8gQWRkIHBhcmVudCBtZXRob2RcbiAgLCBjb25zdHJ1Y3Q6IHtcbiAgICBcdC8vIENyZWF0ZSBhIHJlY3QgZWxlbWVudFxuICAgIFx0cmVjdDogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgIFx0ICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5SZWN0KCkuc2l6ZSh3aWR0aCwgaGVpZ2h0KSlcbiAgICBcdH1cbiAgICBcdFxuICBcdH1cbiAgXHRcbiAgfSlcblxuICBTVkcuRWxsaXBzZSA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgIGNyZWF0ZTogJ2VsbGlwc2UnXG4gIFxuICAgIC8vIEluaGVyaXQgZnJvbVxuICAsIGluaGVyaXQ6IFNWRy5TaGFwZVxuICBcbiAgICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xuICAsIGV4dGVuZDoge1xuICAgICAgLy8gTW92ZSBvdmVyIHgtYXhpc1xuICAgICAgeDogZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4geCA9PSBudWxsID8gdGhpcy5jeCgpIC0gdGhpcy5hdHRyKCdyeCcpIDogdGhpcy5jeCh4ICsgdGhpcy5hdHRyKCdyeCcpKVxuICAgICAgfVxuICAgICAgLy8gTW92ZSBvdmVyIHktYXhpc1xuICAgICwgeTogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4geSA9PSBudWxsID8gdGhpcy5jeSgpIC0gdGhpcy5hdHRyKCdyeScpIDogdGhpcy5jeSh5ICsgdGhpcy5hdHRyKCdyeScpKVxuICAgICAgfVxuICAgICAgLy8gTW92ZSBieSBjZW50ZXIgb3ZlciB4LWF4aXNcbiAgICAsIGN4OiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiB4ID09IG51bGwgPyB0aGlzLmF0dHIoJ2N4JykgOiB0aGlzLmF0dHIoJ2N4JywgbmV3IFNWRy5OdW1iZXIoeCkuZGl2aWRlKHRoaXMudHJhbnMuc2NhbGVYKSlcbiAgICAgIH1cbiAgICAgIC8vIE1vdmUgYnkgY2VudGVyIG92ZXIgeS1heGlzXG4gICAgLCBjeTogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4geSA9PSBudWxsID8gdGhpcy5hdHRyKCdjeScpIDogdGhpcy5hdHRyKCdjeScsIG5ldyBTVkcuTnVtYmVyKHkpLmRpdmlkZSh0aGlzLnRyYW5zLnNjYWxlWSkpXG4gICAgICB9XG4gICAgICAvLyBTZXQgd2lkdGggb2YgZWxlbWVudFxuICAgICwgd2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG4gICAgICAgIHJldHVybiB3aWR0aCA9PSBudWxsID8gdGhpcy5hdHRyKCdyeCcpICogMiA6IHRoaXMuYXR0cigncngnLCBuZXcgU1ZHLk51bWJlcih3aWR0aCkuZGl2aWRlKDIpKVxuICAgICAgfVxuICAgICAgLy8gU2V0IGhlaWdodCBvZiBlbGVtZW50XG4gICAgLCBoZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgICByZXR1cm4gaGVpZ2h0ID09IG51bGwgPyB0aGlzLmF0dHIoJ3J5JykgKiAyIDogdGhpcy5hdHRyKCdyeScsIG5ldyBTVkcuTnVtYmVyKGhlaWdodCkuZGl2aWRlKDIpKVxuICAgICAgfVxuICAgICAgLy8gQ3VzdG9tIHNpemUgZnVuY3Rpb25cbiAgICAsIHNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIHAgPSBwcm9wb3J0aW9uYWxTaXplKHRoaXMuYmJveCgpLCB3aWR0aCwgaGVpZ2h0KVxuICBcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cih7XG4gICAgICAgICAgcng6IG5ldyBTVkcuTnVtYmVyKHAud2lkdGgpLmRpdmlkZSgyKVxuICAgICAgICAsIHJ5OiBuZXcgU1ZHLk51bWJlcihwLmhlaWdodCkuZGl2aWRlKDIpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBcbiAgICB9XG4gIFxuICAgIC8vIEFkZCBwYXJlbnQgbWV0aG9kXG4gICwgY29uc3RydWN0OiB7XG4gICAgICAvLyBDcmVhdGUgY2lyY2xlIGVsZW1lbnQsIGJhc2VkIG9uIGVsbGlwc2VcbiAgICAgIGNpcmNsZTogZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGxpcHNlKHNpemUsIHNpemUpXG4gICAgICB9XG4gICAgICAvLyBDcmVhdGUgYW4gZWxsaXBzZVxuICAgICwgZWxsaXBzZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5FbGxpcHNlKS5zaXplKHdpZHRoLCBoZWlnaHQpLm1vdmUoMCwgMClcbiAgICAgIH1cbiAgICAgIFxuICAgIH1cbiAgXG4gIH0pXG5cbiAgU1ZHLkxpbmUgPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6ICdsaW5lJ1xuICBcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgLCBpbmhlcml0OiBTVkcuU2hhcGVcbiAgXG4gICAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcbiAgLCBleHRlbmQ6IHtcbiAgICAgIC8vIE1vdmUgb3ZlciB4LWF4aXNcbiAgICAgIHg6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLmJib3goKVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHggPT0gbnVsbCA/IGIueCA6IHRoaXMuYXR0cih7XG4gICAgICAgICAgeDE6IHRoaXMuYXR0cigneDEnKSAtIGIueCArIHhcbiAgICAgICAgLCB4MjogdGhpcy5hdHRyKCd4MicpIC0gYi54ICsgeFxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgLy8gTW92ZSBvdmVyIHktYXhpc1xuICAgICwgeTogZnVuY3Rpb24oeSkge1xuICAgICAgICB2YXIgYiA9IHRoaXMuYmJveCgpXG4gICAgICAgIFxuICAgICAgICByZXR1cm4geSA9PSBudWxsID8gYi55IDogdGhpcy5hdHRyKHtcbiAgICAgICAgICB5MTogdGhpcy5hdHRyKCd5MScpIC0gYi55ICsgeVxuICAgICAgICAsIHkyOiB0aGlzLmF0dHIoJ3kyJykgLSBiLnkgKyB5XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICAvLyBNb3ZlIGJ5IGNlbnRlciBvdmVyIHgtYXhpc1xuICAgICwgY3g6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgdmFyIGhhbGYgPSB0aGlzLmJib3goKS53aWR0aCAvIDJcbiAgICAgICAgcmV0dXJuIHggPT0gbnVsbCA/IHRoaXMueCgpICsgaGFsZiA6IHRoaXMueCh4IC0gaGFsZilcbiAgICAgIH1cbiAgICAgIC8vIE1vdmUgYnkgY2VudGVyIG92ZXIgeS1heGlzXG4gICAgLCBjeTogZnVuY3Rpb24oeSkge1xuICAgICAgICB2YXIgaGFsZiA9IHRoaXMuYmJveCgpLmhlaWdodCAvIDJcbiAgICAgICAgcmV0dXJuIHkgPT0gbnVsbCA/IHRoaXMueSgpICsgaGFsZiA6IHRoaXMueSh5IC0gaGFsZilcbiAgICAgIH1cbiAgICAgIC8vIFNldCB3aWR0aCBvZiBlbGVtZW50XG4gICAgLCB3aWR0aDogZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLmJib3goKVxuICBcbiAgICAgICAgcmV0dXJuIHdpZHRoID09IG51bGwgPyBiLndpZHRoIDogdGhpcy5hdHRyKHRoaXMuYXR0cigneDEnKSA8IHRoaXMuYXR0cigneDInKSA/ICd4MicgOiAneDEnLCBiLnggKyB3aWR0aClcbiAgICAgIH1cbiAgICAgIC8vIFNldCBoZWlnaHQgb2YgZWxlbWVudFxuICAgICwgaGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLmJib3goKVxuICBcbiAgICAgICAgcmV0dXJuIGhlaWdodCA9PSBudWxsID8gYi5oZWlnaHQgOiB0aGlzLmF0dHIodGhpcy5hdHRyKCd5MScpIDwgdGhpcy5hdHRyKCd5MicpID8gJ3kyJyA6ICd5MScsIGIueSArIGhlaWdodClcbiAgICAgIH1cbiAgICAgIC8vIFNldCBsaW5lIHNpemUgYnkgd2lkdGggYW5kIGhlaWdodFxuICAgICwgc2l6ZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgcCA9IHByb3BvcnRpb25hbFNpemUodGhpcy5iYm94KCksIHdpZHRoLCBoZWlnaHQpXG4gIFxuICAgICAgICByZXR1cm4gdGhpcy53aWR0aChwLndpZHRoKS5oZWlnaHQocC5oZWlnaHQpXG4gICAgICB9XG4gICAgICAvLyBTZXQgcGF0aCBkYXRhXG4gICAgLCBwbG90OiBmdW5jdGlvbih4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKHtcbiAgICAgICAgICB4MTogeDFcbiAgICAgICAgLCB5MTogeTFcbiAgICAgICAgLCB4MjogeDJcbiAgICAgICAgLCB5MjogeTJcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgLCBjb25zdHJ1Y3Q6IHtcbiAgICAgIC8vIENyZWF0ZSBhIGxpbmUgZWxlbWVudFxuICAgICAgbGluZTogZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuTGluZSgpLnBsb3QoeDEsIHkxLCB4MiwgeTIpKVxuICAgICAgfVxuICAgIH1cbiAgfSlcblxuXG4gIFNWRy5Qb2x5bGluZSA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgIGNyZWF0ZTogJ3BvbHlsaW5lJ1xuICBcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgLCBpbmhlcml0OiBTVkcuU2hhcGVcbiAgICBcbiAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAsIGNvbnN0cnVjdDoge1xuICAgICAgLy8gQ3JlYXRlIGEgd3JhcHBlZCBwb2x5bGluZSBlbGVtZW50XG4gICAgICBwb2x5bGluZTogZnVuY3Rpb24ocCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5Qb2x5bGluZSkucGxvdChwKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgXG4gIFNWRy5Qb2x5Z29uID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgY3JlYXRlOiAncG9seWdvbidcbiAgXG4gICAgLy8gSW5oZXJpdCBmcm9tXG4gICwgaW5oZXJpdDogU1ZHLlNoYXBlXG4gICAgXG4gICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgLCBjb25zdHJ1Y3Q6IHtcbiAgICAgIC8vIENyZWF0ZSBhIHdyYXBwZWQgcG9seWdvbiBlbGVtZW50XG4gICAgICBwb2x5Z29uOiBmdW5jdGlvbihwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLlBvbHlnb24pLnBsb3QocClcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIFxuICAvLyBBZGQgcG9seWdvbi1zcGVjaWZpYyBmdW5jdGlvbnNcbiAgU1ZHLmV4dGVuZChTVkcuUG9seWxpbmUsIFNWRy5Qb2x5Z29uLCB7XG4gICAgLy8gRGVmaW5lIG1vcnBoYWJsZSBhcnJheVxuICAgIG1vcnBoQXJyYXk6ICBTVkcuUG9pbnRBcnJheVxuICAgIC8vIFBsb3QgbmV3IHBhdGhcbiAgLCBwbG90OiBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdwb2ludHMnLCAodGhpcy5hcnJheSA9IG5ldyBTVkcuUG9pbnRBcnJheShwLCBbWzAsMF1dKSkpXG4gICAgfVxuICAgIC8vIE1vdmUgYnkgbGVmdCB0b3AgY29ybmVyXG4gICwgbW92ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cigncG9pbnRzJywgdGhpcy5hcnJheS5tb3ZlKHgsIHkpKVxuICAgIH1cbiAgICAvLyBNb3ZlIGJ5IGxlZnQgdG9wIGNvcm5lciBvdmVyIHgtYXhpc1xuICAsIHg6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB4ID09IG51bGwgPyB0aGlzLmJib3goKS54IDogdGhpcy5tb3ZlKHgsIHRoaXMuYmJveCgpLnkpXG4gICAgfVxuICAgIC8vIE1vdmUgYnkgbGVmdCB0b3AgY29ybmVyIG92ZXIgeS1heGlzXG4gICwgeTogZnVuY3Rpb24oeSkge1xuICAgICAgcmV0dXJuIHkgPT0gbnVsbCA/IHRoaXMuYmJveCgpLnkgOiB0aGlzLm1vdmUodGhpcy5iYm94KCkueCwgeSlcbiAgICB9XG4gICAgLy8gU2V0IHdpZHRoIG9mIGVsZW1lbnRcbiAgLCB3aWR0aDogZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgIHZhciBiID0gdGhpcy5iYm94KClcbiAgXG4gICAgICByZXR1cm4gd2lkdGggPT0gbnVsbCA/IGIud2lkdGggOiB0aGlzLnNpemUod2lkdGgsIGIuaGVpZ2h0KVxuICAgIH1cbiAgICAvLyBTZXQgaGVpZ2h0IG9mIGVsZW1lbnRcbiAgLCBoZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgdmFyIGIgPSB0aGlzLmJib3goKVxuICBcbiAgICAgIHJldHVybiBoZWlnaHQgPT0gbnVsbCA/IGIuaGVpZ2h0IDogdGhpcy5zaXplKGIud2lkdGgsIGhlaWdodCkgXG4gICAgfVxuICAgIC8vIFNldCBlbGVtZW50IHNpemUgdG8gZ2l2ZW4gd2lkdGggYW5kIGhlaWdodFxuICAsIHNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHZhciBwID0gcHJvcG9ydGlvbmFsU2l6ZSh0aGlzLmJib3goKSwgd2lkdGgsIGhlaWdodClcbiAgXG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdwb2ludHMnLCB0aGlzLmFycmF5LnNpemUocC53aWR0aCwgcC5oZWlnaHQpKVxuICAgIH1cbiAgXG4gIH0pXG5cbiAgU1ZHLlBhdGggPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6ICdwYXRoJ1xuICBcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgLCBpbmhlcml0OiBTVkcuU2hhcGVcbiAgXG4gICAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcbiAgLCBleHRlbmQ6IHtcbiAgICAgIC8vIFBsb3QgbmV3IHBvbHkgcG9pbnRzXG4gICAgICBwbG90OiBmdW5jdGlvbihwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2QnLCAodGhpcy5hcnJheSA9IG5ldyBTVkcuUGF0aEFycmF5KHAsIFtbJ00nLCAwLCAwXV0pKSlcbiAgICAgIH1cbiAgICAgIC8vIE1vdmUgYnkgbGVmdCB0b3AgY29ybmVyXG4gICAgLCBtb3ZlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2QnLCB0aGlzLmFycmF5Lm1vdmUoeCwgeSkpXG4gICAgICB9XG4gICAgICAvLyBNb3ZlIGJ5IGxlZnQgdG9wIGNvcm5lciBvdmVyIHgtYXhpc1xuICAgICwgeDogZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4geCA9PSBudWxsID8gdGhpcy5iYm94KCkueCA6IHRoaXMubW92ZSh4LCB0aGlzLmJib3goKS55KVxuICAgICAgfVxuICAgICAgLy8gTW92ZSBieSBsZWZ0IHRvcCBjb3JuZXIgb3ZlciB5LWF4aXNcbiAgICAsIHk6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHkgPT0gbnVsbCA/IHRoaXMuYmJveCgpLnkgOiB0aGlzLm1vdmUodGhpcy5iYm94KCkueCwgeSlcbiAgICAgIH1cbiAgICAgIC8vIFNldCBlbGVtZW50IHNpemUgdG8gZ2l2ZW4gd2lkdGggYW5kIGhlaWdodFxuICAgICwgc2l6ZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgcCA9IHByb3BvcnRpb25hbFNpemUodGhpcy5iYm94KCksIHdpZHRoLCBoZWlnaHQpXG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCdkJywgdGhpcy5hcnJheS5zaXplKHAud2lkdGgsIHAuaGVpZ2h0KSlcbiAgICAgIH1cbiAgICAgIC8vIFNldCB3aWR0aCBvZiBlbGVtZW50XG4gICAgLCB3aWR0aDogZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgICAgcmV0dXJuIHdpZHRoID09IG51bGwgPyB0aGlzLmJib3goKS53aWR0aCA6IHRoaXMuc2l6ZSh3aWR0aCwgdGhpcy5iYm94KCkuaGVpZ2h0KVxuICAgICAgfVxuICAgICAgLy8gU2V0IGhlaWdodCBvZiBlbGVtZW50XG4gICAgLCBoZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgICByZXR1cm4gaGVpZ2h0ID09IG51bGwgPyB0aGlzLmJib3goKS5oZWlnaHQgOiB0aGlzLnNpemUodGhpcy5iYm94KCkud2lkdGgsIGhlaWdodClcbiAgICAgIH1cbiAgICAgIFxuICAgIH1cbiAgICBcbiAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAsIGNvbnN0cnVjdDoge1xuICAgICAgLy8gQ3JlYXRlIGEgd3JhcHBlZCBwYXRoIGVsZW1lbnRcbiAgICAgIHBhdGg6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuUGF0aCkucGxvdChkKVxuICAgICAgfVxuICAgIH1cbiAgfSlcblxuICBTVkcuSW1hZ2UgPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6ICdpbWFnZSdcbiAgXG4gICAgLy8gSW5oZXJpdCBmcm9tXG4gICwgaW5oZXJpdDogU1ZHLlNoYXBlXG4gIFxuICAgIC8vIEFkZCBjbGFzcyBtZXRob2RzXG4gICwgZXh0ZW5kOiB7XG4gICAgICAvLyAocmUpbG9hZCBpbWFnZVxuICAgICAgbG9hZDogZnVuY3Rpb24odXJsKSB7XG4gICAgICAgIGlmICghdXJsKSByZXR1cm4gdGhpc1xuICBcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgICAgICAgLCBpbWcgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJylcbiAgICAgICAgXG4gICAgICAgIC8qIHByZWxvYWQgaW1hZ2UgKi9cbiAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBwID0gc2VsZi5kb2MoU1ZHLlBhdHRlcm4pXG4gIFxuICAgICAgICAgIC8qIGVuc3VyZSBpbWFnZSBzaXplICovXG4gICAgICAgICAgaWYgKHNlbGYud2lkdGgoKSA9PSAwICYmIHNlbGYuaGVpZ2h0KCkgPT0gMClcbiAgICAgICAgICAgIHNlbGYuc2l6ZShpbWcud2lkdGgsIGltZy5oZWlnaHQpXG4gIFxuICAgICAgICAgIC8qIGVuc3VyZSBwYXR0ZXJuIHNpemUgaWYgbm90IHNldCAqL1xuICAgICAgICAgIGlmIChwICYmIHAud2lkdGgoKSA9PSAwICYmIHAuaGVpZ2h0KCkgPT0gMClcbiAgICAgICAgICAgIHAuc2l6ZShzZWxmLndpZHRoKCksIHNlbGYuaGVpZ2h0KCkpXG4gICAgICAgICAgXG4gICAgICAgICAgLyogY2FsbGJhY2sgKi9cbiAgICAgICAgICBpZiAodHlwZW9mIHNlbGYuX2xvYWRlZCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHNlbGYuX2xvYWRlZC5jYWxsKHNlbGYsIHtcbiAgICAgICAgICAgICAgd2lkdGg6ICBpbWcud2lkdGhcbiAgICAgICAgICAgICwgaGVpZ2h0OiBpbWcuaGVpZ2h0XG4gICAgICAgICAgICAsIHJhdGlvOiAgaW1nLndpZHRoIC8gaW1nLmhlaWdodFxuICAgICAgICAgICAgLCB1cmw6ICAgIHVybFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICBcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cignaHJlZicsIChpbWcuc3JjID0gdGhpcy5zcmMgPSB1cmwpLCBTVkcueGxpbmspXG4gICAgICB9XG4gICAgICAvLyBBZGQgbG9hZGUgY2FsbGJhY2tcbiAgICAsIGxvYWRlZDogZnVuY3Rpb24obG9hZGVkKSB7XG4gICAgICAgIHRoaXMuX2xvYWRlZCA9IGxvYWRlZFxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAsIGNvbnN0cnVjdDoge1xuICAgICAgLy8gQ3JlYXRlIGltYWdlIGVsZW1lbnQsIGxvYWQgaW1hZ2UgYW5kIHNldCBpdHMgc2l6ZVxuICAgICAgaW1hZ2U6IGZ1bmN0aW9uKHNvdXJjZSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5JbWFnZSkubG9hZChzb3VyY2UpLnNpemUod2lkdGggfHwgMCwgaGVpZ2h0IHx8IHdpZHRoIHx8IDApXG4gICAgICB9XG4gICAgfVxuICBcbiAgfSlcblxuICBTVkcuVGV4dCA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgIGNyZWF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgU1ZHLmNyZWF0ZSgndGV4dCcpKVxuICAgICAgXG4gICAgICB0aGlzLl9sZWFkaW5nID0gbmV3IFNWRy5OdW1iZXIoMS4zKSAgICAvKiBzdG9yZSBsZWFkaW5nIHZhbHVlIGZvciByZWJ1aWxkaW5nICovXG4gICAgICB0aGlzLl9yZWJ1aWxkID0gdHJ1ZSAgICAgICAgICAgICAgICAgICAvKiBlbmFibGUgYXV0b21hdGljIHVwZGF0aW5nIG9mIGR5IHZhbHVlcyAqL1xuICAgICAgdGhpcy5fYnVpbGQgICA9IGZhbHNlICAgICAgICAgICAgICAgICAgLyogZGlzYWJsZSBidWlsZCBtb2RlIGZvciBhZGRpbmcgbXVsdGlwbGUgbGluZXMgKi9cbiAgXG4gICAgICAvKiBzZXQgZGVmYXVsdCBmb250ICovXG4gICAgICB0aGlzLmF0dHIoJ2ZvbnQtZmFtaWx5JywgU1ZHLmRlZmF1bHRzLmF0dHJzWydmb250LWZhbWlseSddKVxuICAgIH1cbiAgXG4gICAgLy8gSW5oZXJpdCBmcm9tXG4gICwgaW5oZXJpdDogU1ZHLlNoYXBlXG4gIFxuICAgIC8vIEFkZCBjbGFzcyBtZXRob2RzXG4gICwgZXh0ZW5kOiB7XG4gICAgICAvLyBNb3ZlIG92ZXIgeC1heGlzXG4gICAgICB4OiBmdW5jdGlvbih4KSB7XG4gICAgICAgIC8qIGFjdCBhcyBnZXR0ZXIgKi9cbiAgICAgICAgaWYgKHggPT0gbnVsbClcbiAgICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCd4JylcbiAgICAgICAgXG4gICAgICAgIC8qIG1vdmUgbGluZXMgYXMgd2VsbCBpZiBubyB0ZXh0UGF0aCBpcyBwcmVzZW50ICovXG4gICAgICAgIGlmICghdGhpcy50ZXh0UGF0aClcbiAgICAgICAgICB0aGlzLmxpbmVzLmVhY2goZnVuY3Rpb24oKSB7IGlmICh0aGlzLm5ld0xpbmVkKSB0aGlzLngoeCkgfSlcbiAgXG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3gnLCB4KVxuICAgICAgfVxuICAgICAgLy8gTW92ZSBvdmVyIHktYXhpc1xuICAgICwgeTogZnVuY3Rpb24oeSkge1xuICAgICAgICB2YXIgb3kgPSB0aGlzLmF0dHIoJ3knKVxuICAgICAgICAgICwgbyAgPSB0eXBlb2Ygb3kgPT09ICdudW1iZXInID8gb3kgLSB0aGlzLmJib3goKS55IDogMFxuICBcbiAgICAgICAgLyogYWN0IGFzIGdldHRlciAqL1xuICAgICAgICBpZiAoeSA9PSBudWxsKVxuICAgICAgICAgIHJldHVybiB0eXBlb2Ygb3kgPT09ICdudW1iZXInID8gb3kgLSBvIDogb3lcbiAgXG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3knLCB0eXBlb2YgeSA9PT0gJ251bWJlcicgPyB5ICsgbyA6IHkpXG4gICAgICB9XG4gICAgICAvLyBNb3ZlIGNlbnRlciBvdmVyIHgtYXhpc1xuICAgICwgY3g6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIHggPT0gbnVsbCA/IHRoaXMuYmJveCgpLmN4IDogdGhpcy54KHggLSB0aGlzLmJib3goKS53aWR0aCAvIDIpXG4gICAgICB9XG4gICAgICAvLyBNb3ZlIGNlbnRlciBvdmVyIHktYXhpc1xuICAgICwgY3k6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHkgPT0gbnVsbCA/IHRoaXMuYmJveCgpLmN5IDogdGhpcy55KHkgLSB0aGlzLmJib3goKS5oZWlnaHQgLyAyKVxuICAgICAgfVxuICAgICAgLy8gU2V0IHRoZSB0ZXh0IGNvbnRlbnRcbiAgICAsIHRleHQ6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgLyogYWN0IGFzIGdldHRlciAqL1xuICAgICAgICBpZiAodHlwZW9mIHRleHQgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gdGhpcy5jb250ZW50XG4gICAgICAgIFxuICAgICAgICAvKiByZW1vdmUgZXhpc3RpbmcgY29udGVudCAqL1xuICAgICAgICB0aGlzLmNsZWFyKCkuYnVpbGQodHJ1ZSlcbiAgICAgICAgXG4gICAgICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8qIGNhbGwgYmxvY2sgKi9cbiAgICAgICAgICB0ZXh0LmNhbGwodGhpcywgdGhpcylcbiAgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLyogc3RvcmUgdGV4dCBhbmQgbWFrZSBzdXJlIHRleHQgaXMgbm90IGJsYW5rICovXG4gICAgICAgICAgdGV4dCA9ICh0aGlzLmNvbnRlbnQgPSB0ZXh0KS5zcGxpdCgnXFxuJylcbiAgICAgICAgICBcbiAgICAgICAgICAvKiBidWlsZCBuZXcgbGluZXMgKi9cbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSB0ZXh0Lmxlbmd0aDsgaSA8IGlsOyBpKyspXG4gICAgICAgICAgICB0aGlzLnRzcGFuKHRleHRbaV0pLm5ld0xpbmUoKVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvKiBkaXNhYmxlIGJ1aWxkIG1vZGUgYW5kIHJlYnVpbGQgbGluZXMgKi9cbiAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGQoZmFsc2UpLnJlYnVpbGQoKVxuICAgICAgfVxuICAgICAgLy8gU2V0IGZvbnQgc2l6ZVxuICAgICwgc2l6ZTogZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCdmb250LXNpemUnLCBzaXplKS5yZWJ1aWxkKClcbiAgICAgIH1cbiAgICAgIC8vIFNldCAvIGdldCBsZWFkaW5nXG4gICAgLCBsZWFkaW5nOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAvKiBhY3QgYXMgZ2V0dGVyICovXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICAgIHJldHVybiB0aGlzLl9sZWFkaW5nXG4gICAgICAgIFxuICAgICAgICAvKiBhY3QgYXMgc2V0dGVyICovXG4gICAgICAgIHRoaXMuX2xlYWRpbmcgPSBuZXcgU1ZHLk51bWJlcih2YWx1ZSlcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0aGlzLnJlYnVpbGQoKVxuICAgICAgfVxuICAgICAgLy8gUmVidWlsZCBhcHBlYXJhbmNlIHR5cGVcbiAgICAsIHJlYnVpbGQ6IGZ1bmN0aW9uKHJlYnVpbGQpIHtcbiAgICAgICAgLyogc3RvcmUgbmV3IHJlYnVpbGQgZmxhZyBpZiBnaXZlbiAqL1xuICAgICAgICBpZiAodHlwZW9mIHJlYnVpbGQgPT0gJ2Jvb2xlYW4nKVxuICAgICAgICAgIHRoaXMuX3JlYnVpbGQgPSByZWJ1aWxkXG4gIFxuICAgICAgICAvKiBkZWZpbmUgcG9zaXRpb24gb2YgYWxsIGxpbmVzICovXG4gICAgICAgIGlmICh0aGlzLl9yZWJ1aWxkKSB7XG4gICAgICAgICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgICAgICAgXG4gICAgICAgICAgdGhpcy5saW5lcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubmV3TGluZWQpIHtcbiAgICAgICAgICAgICAgaWYgKCF0aGlzLnRleHRQYXRoKVxuICAgICAgICAgICAgICAgIHRoaXMuYXR0cigneCcsIHNlbGYuYXR0cigneCcpKVxuICAgICAgICAgICAgICB0aGlzLmF0dHIoJ2R5Jywgc2VsZi5fbGVhZGluZyAqIG5ldyBTVkcuTnVtYmVyKHNlbGYuYXR0cignZm9udC1zaXplJykpKSBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICBcbiAgICAgICAgICB0aGlzLmZpcmUoJ3JlYnVpbGQnKVxuICAgICAgICB9XG4gIFxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgICAgLy8gRW5hYmxlIC8gZGlzYWJsZSBidWlsZCBtb2RlXG4gICAgLCBidWlsZDogZnVuY3Rpb24oYnVpbGQpIHtcbiAgICAgICAgdGhpcy5fYnVpbGQgPSAhIWJ1aWxkXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEFkZCBwYXJlbnQgbWV0aG9kXG4gICwgY29uc3RydWN0OiB7XG4gICAgICAvLyBDcmVhdGUgdGV4dCBlbGVtZW50XG4gICAgICB0ZXh0OiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLlRleHQpLnRleHQodGV4dClcbiAgICAgIH1cbiAgICAgIC8vIENyZWF0ZSBwbGFpbiB0ZXh0IGVsZW1lbnRcbiAgICAsIHBsYWluOiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLlRleHQpLnBsYWluKHRleHQpXG4gICAgICB9XG4gICAgfVxuICBcbiAgfSlcbiAgXG4gIFNWRy5UU3BhbiA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgIGNyZWF0ZTogJ3RzcGFuJ1xuICBcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgLCBpbmhlcml0OiBTVkcuU2hhcGVcbiAgXG4gICAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcbiAgLCBleHRlbmQ6IHtcbiAgICAgIC8vIFNldCB0ZXh0IGNvbnRlbnRcbiAgICAgIHRleHQ6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgdHlwZW9mIHRleHQgPT09ICdmdW5jdGlvbicgPyB0ZXh0LmNhbGwodGhpcywgdGhpcykgOiB0aGlzLnBsYWluKHRleHQpXG4gIFxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgICAgLy8gU2hvcnRjdXQgZHhcbiAgICAsIGR4OiBmdW5jdGlvbihkeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCdkeCcsIGR4KVxuICAgICAgfVxuICAgICAgLy8gU2hvcnRjdXQgZHlcbiAgICAsIGR5OiBmdW5jdGlvbihkeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCdkeScsIGR5KVxuICAgICAgfVxuICAgICAgLy8gQ3JlYXRlIG5ldyBsaW5lXG4gICAgLCBuZXdMaW5lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLyogZmV0Y2ggdGV4dCBwYXJlbnQgKi9cbiAgICAgICAgdmFyIHQgPSB0aGlzLmRvYyhTVkcuVGV4dClcbiAgXG4gICAgICAgIC8qIG1hcmsgbmV3IGxpbmUgKi9cbiAgICAgICAgdGhpcy5uZXdMaW5lZCA9IHRydWVcbiAgXG4gICAgICAgIC8qIGFwcGx5IG5ldyBoecKhbiAqL1xuICAgICAgICByZXR1cm4gdGhpcy5keSh0Ll9sZWFkaW5nICogdC5hdHRyKCdmb250LXNpemUnKSkuYXR0cigneCcsIHQueCgpKVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgfSlcbiAgXG4gIFNWRy5leHRlbmQoU1ZHLlRleHQsIFNWRy5UU3Bhbiwge1xuICAgIC8vIENyZWF0ZSBwbGFpbiB0ZXh0IG5vZGVcbiAgICBwbGFpbjogZnVuY3Rpb24odGV4dCkge1xuICAgICAgLyogY2xlYXIgaWYgYnVpbGQgbW9kZSBpcyBkaXNhYmxlZCAqL1xuICAgICAgaWYgKHRoaXMuX2J1aWxkID09PSBmYWxzZSlcbiAgICAgICAgdGhpcy5jbGVhcigpXG4gIFxuICAgICAgLyogY3JlYXRlIHRleHQgbm9kZSAqL1xuICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCh0aGlzLmNvbnRlbnQgPSB0ZXh0KSkpXG4gICAgICBcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIC8vIENyZWF0ZSBhIHRzcGFuXG4gICwgdHNwYW46IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgIHZhciBub2RlICA9ICh0aGlzLnRleHRQYXRoIHx8IHRoaXMpLm5vZGVcbiAgICAgICAgLCB0c3BhbiA9IG5ldyBTVkcuVFNwYW5cbiAgXG4gICAgICAvKiBjbGVhciBpZiBidWlsZCBtb2RlIGlzIGRpc2FibGVkICovXG4gICAgICBpZiAodGhpcy5fYnVpbGQgPT09IGZhbHNlKVxuICAgICAgICB0aGlzLmNsZWFyKClcbiAgICAgIFxuICAgICAgLyogYWRkIG5ldyB0c3BhbiBhbmQgcmVmZXJlbmNlICovXG4gICAgICBub2RlLmFwcGVuZENoaWxkKHRzcGFuLm5vZGUpXG4gICAgICB0c3Bhbi5wYXJlbnQgPSB0aGlzXG4gIFxuICAgICAgLyogb25seSBmaXJzdCBsZXZlbCB0c3BhbnMgYXJlIGNvbnNpZGVyZWQgdG8gYmUgXCJsaW5lc1wiICovXG4gICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFNWRy5UZXh0KVxuICAgICAgICB0aGlzLmxpbmVzLmFkZCh0c3BhbilcbiAgXG4gICAgICByZXR1cm4gdHNwYW4udGV4dCh0ZXh0KVxuICAgIH1cbiAgICAvLyBDbGVhciBhbGwgbGluZXNcbiAgLCBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm9kZSA9ICh0aGlzLnRleHRQYXRoIHx8IHRoaXMpLm5vZGVcbiAgXG4gICAgICAvKiByZW1vdmUgZXhpc3RpbmcgY2hpbGQgbm9kZXMgKi9cbiAgICAgIHdoaWxlIChub2RlLmhhc0NoaWxkTm9kZXMoKSlcbiAgICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmxhc3RDaGlsZClcbiAgICAgIFxuICAgICAgLyogcmVzZXQgY29udGVudCByZWZlcmVuY2VzICAqL1xuICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBTVkcuVGV4dCkge1xuICAgICAgICBkZWxldGUgdGhpcy5saW5lc1xuICAgICAgICB0aGlzLmxpbmVzID0gbmV3IFNWRy5TZXRcbiAgICAgICAgdGhpcy5jb250ZW50ID0gJydcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgLy8gR2V0IGxlbmd0aCBvZiB0ZXh0IGVsZW1lbnRcbiAgLCBsZW5ndGg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZS5nZXRDb21wdXRlZFRleHRMZW5ndGgoKVxuICAgIH1cbiAgfSlcbiAgXG4gIC8vIFJlZ2lzdGVyIHJlYnVpbGQgZXZlbnRcbiAgU1ZHLnJlZ2lzdGVyRXZlbnQoJ3JlYnVpbGQnKVxuXG5cbiAgU1ZHLlRleHRQYXRoID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgY3JlYXRlOiAndGV4dFBhdGgnXG4gIFxuICAgIC8vIEluaGVyaXQgZnJvbVxuICAsIGluaGVyaXQ6IFNWRy5FbGVtZW50XG4gIFxuICAgIC8vIERlZmluZSBwYXJlbnQgY2xhc3NcbiAgLCBwYXJlbnQ6IFNWRy5UZXh0XG4gIFxuICAgIC8vIEFkZCBwYXJlbnQgbWV0aG9kXG4gICwgY29uc3RydWN0OiB7XG4gICAgICAvLyBDcmVhdGUgcGF0aCBmb3IgdGV4dCB0byBydW4gb25cbiAgICAgIHBhdGg6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgLyogY3JlYXRlIHRleHRQYXRoIGVsZW1lbnQgKi9cbiAgICAgICAgdGhpcy50ZXh0UGF0aCA9IG5ldyBTVkcuVGV4dFBhdGhcbiAgXG4gICAgICAgIC8qIG1vdmUgbGluZXMgdG8gdGV4dHBhdGggKi9cbiAgICAgICAgd2hpbGUodGhpcy5ub2RlLmhhc0NoaWxkTm9kZXMoKSlcbiAgICAgICAgICB0aGlzLnRleHRQYXRoLm5vZGUuYXBwZW5kQ2hpbGQodGhpcy5ub2RlLmZpcnN0Q2hpbGQpXG4gIFxuICAgICAgICAvKiBhZGQgdGV4dFBhdGggZWxlbWVudCBhcyBjaGlsZCBub2RlICovXG4gICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZCh0aGlzLnRleHRQYXRoLm5vZGUpXG4gIFxuICAgICAgICAvKiBjcmVhdGUgcGF0aCBpbiBkZWZzICovXG4gICAgICAgIHRoaXMudHJhY2sgPSB0aGlzLmRvYygpLmRlZnMoKS5wYXRoKGQpXG4gIFxuICAgICAgICAvKiBjcmVhdGUgY2lyY3VsYXIgcmVmZXJlbmNlICovXG4gICAgICAgIHRoaXMudGV4dFBhdGgucGFyZW50ID0gdGhpc1xuICBcbiAgICAgICAgLyogbGluayB0ZXh0UGF0aCB0byBwYXRoIGFuZCBhZGQgY29udGVudCAqL1xuICAgICAgICB0aGlzLnRleHRQYXRoLmF0dHIoJ2hyZWYnLCAnIycgKyB0aGlzLnRyYWNrLCBTVkcueGxpbmspXG4gIFxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgICAgLy8gUGxvdCBwYXRoIGlmIGFueVxuICAgICwgcGxvdDogZnVuY3Rpb24oZCkge1xuICAgICAgICBpZiAodGhpcy50cmFjaykgdGhpcy50cmFjay5wbG90KGQpXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIFNWRy5OZXN0ZWQgPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIFNWRy5jcmVhdGUoJ3N2ZycpKVxuICAgICAgXG4gICAgICB0aGlzLnN0eWxlKCdvdmVyZmxvdycsICd2aXNpYmxlJylcbiAgICB9XG4gIFxuICAgIC8vIEluaGVyaXQgZnJvbVxuICAsIGluaGVyaXQ6IFNWRy5Db250YWluZXJcbiAgICBcbiAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAsIGNvbnN0cnVjdDoge1xuICAgICAgLy8gQ3JlYXRlIG5lc3RlZCBzdmcgZG9jdW1lbnRcbiAgICAgIG5lc3RlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLk5lc3RlZClcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgU1ZHLkEgPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6ICdhJ1xuICBcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgLCBpbmhlcml0OiBTVkcuQ29udGFpbmVyXG4gIFxuICAgIC8vIEFkZCBjbGFzcyBtZXRob2RzXG4gICwgZXh0ZW5kOiB7XG4gICAgICAvLyBMaW5rIHVybFxuICAgICAgdG86IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCdocmVmJywgdXJsLCBTVkcueGxpbmspXG4gICAgICB9XG4gICAgICAvLyBMaW5rIHNob3cgYXR0cmlidXRlXG4gICAgLCBzaG93OiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cignc2hvdycsIHRhcmdldCwgU1ZHLnhsaW5rKVxuICAgICAgfVxuICAgICAgLy8gTGluayB0YXJnZXQgYXR0cmlidXRlXG4gICAgLCB0YXJnZXQ6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCd0YXJnZXQnLCB0YXJnZXQpXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEFkZCBwYXJlbnQgbWV0aG9kXG4gICwgY29uc3RydWN0OiB7XG4gICAgICAvLyBDcmVhdGUgYSBoeXBlcmxpbmsgZWxlbWVudFxuICAgICAgbGluazogZnVuY3Rpb24odXJsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLkEpLnRvKHVybClcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIFxuICBTVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCB7XG4gICAgLy8gQ3JlYXRlIGEgaHlwZXJsaW5rIGVsZW1lbnRcbiAgICBsaW5rVG86IGZ1bmN0aW9uKHVybCkge1xuICAgICAgdmFyIGxpbmsgPSBuZXcgU1ZHLkFcbiAgXG4gICAgICBpZiAodHlwZW9mIHVybCA9PSAnZnVuY3Rpb24nKVxuICAgICAgICB1cmwuY2FsbChsaW5rLCBsaW5rKVxuICAgICAgZWxzZVxuICAgICAgICBsaW5rLnRvKHVybClcbiAgXG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQucHV0KGxpbmspLnB1dCh0aGlzKVxuICAgIH1cbiAgICBcbiAgfSlcblxuICBTVkcuTWFya2VyID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgY3JlYXRlOiAnbWFya2VyJ1xuICBcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgLCBpbmhlcml0OiBTVkcuQ29udGFpbmVyXG4gIFxuICAgIC8vIEFkZCBjbGFzcyBtZXRob2RzXG4gICwgZXh0ZW5kOiB7XG4gICAgICAvLyBTZXQgd2lkdGggb2YgZWxlbWVudFxuICAgICAgd2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ21hcmtlcldpZHRoJywgd2lkdGgpXG4gICAgICB9XG4gICAgICAvLyBTZXQgaGVpZ2h0IG9mIGVsZW1lbnRcbiAgICAsIGhlaWdodDogZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ21hcmtlckhlaWdodCcsIGhlaWdodClcbiAgICAgIH1cbiAgICAgIC8vIFNldCBtYXJrZXIgcmVmWCBhbmQgcmVmWVxuICAgICwgcmVmOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3JlZlgnLCB4KS5hdHRyKCdyZWZZJywgeSlcbiAgICAgIH1cbiAgICAgIC8vIFVwZGF0ZSBtYXJrZXJcbiAgICAsIHVwZGF0ZTogZnVuY3Rpb24oYmxvY2spIHtcbiAgICAgICAgLyogcmVtb3ZlIGFsbCBjb250ZW50ICovXG4gICAgICAgIHRoaXMuY2xlYXIoKVxuICAgICAgICBcbiAgICAgICAgLyogaW52b2tlIHBhc3NlZCBibG9jayAqL1xuICAgICAgICBpZiAodHlwZW9mIGJsb2NrID09ICdmdW5jdGlvbicpXG4gICAgICAgICAgYmxvY2suY2FsbCh0aGlzLCB0aGlzKVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICAgIC8vIFJldHVybiB0aGUgZmlsbCBpZFxuICAgICwgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJ3VybCgjJyArIHRoaXMuaWQoKSArICcpJ1xuICAgICAgfVxuICAgIH1cbiAgXG4gICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgLCBjb25zdHJ1Y3Q6IHtcbiAgICAgIG1hcmtlcjogZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgYmxvY2spIHtcbiAgICAgICAgLy8gQ3JlYXRlIG1hcmtlciBlbGVtZW50IGluIGRlZnNcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmcygpLm1hcmtlcih3aWR0aCwgaGVpZ2h0LCBibG9jaylcbiAgICAgIH1cbiAgICB9XG4gIFxuICB9KVxuICBcbiAgU1ZHLmV4dGVuZChTVkcuRGVmcywge1xuICAgIC8vIENyZWF0ZSBtYXJrZXJcbiAgICBtYXJrZXI6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIGJsb2NrKSB7XG4gICAgICAvLyBTZXQgZGVmYXVsdCB2aWV3Ym94IHRvIG1hdGNoIHRoZSB3aWR0aCBhbmQgaGVpZ2h0LCBzZXQgcmVmIHRvIGN4IGFuZCBjeSBhbmQgc2V0IG9yaWVudCB0byBhdXRvXG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5NYXJrZXIpXG4gICAgICAgIC5zaXplKHdpZHRoLCBoZWlnaHQpXG4gICAgICAgIC5yZWYod2lkdGggLyAyLCBoZWlnaHQgLyAyKVxuICAgICAgICAudmlld2JveCgwLCAwLCB3aWR0aCwgaGVpZ2h0KVxuICAgICAgICAuYXR0cignb3JpZW50JywgJ2F1dG8nKVxuICAgICAgICAudXBkYXRlKGJsb2NrKVxuICAgIH1cbiAgICBcbiAgfSlcbiAgXG4gIFNWRy5leHRlbmQoU1ZHLkxpbmUsIFNWRy5Qb2x5bGluZSwgU1ZHLlBvbHlnb24sIFNWRy5QYXRoLCB7XG4gICAgLy8gQ3JlYXRlIGFuZCBhdHRhY2ggbWFya2Vyc1xuICAgIG1hcmtlcjogZnVuY3Rpb24obWFya2VyLCB3aWR0aCwgaGVpZ2h0LCBibG9jaykge1xuICAgICAgdmFyIGF0dHIgPSBbJ21hcmtlciddXG4gIFxuICAgICAgLy8gQnVpbGQgYXR0cmlidXRlIG5hbWVcbiAgICAgIGlmIChtYXJrZXIgIT0gJ2FsbCcpIGF0dHIucHVzaChtYXJrZXIpXG4gICAgICBhdHRyID0gYXR0ci5qb2luKCctJylcbiAgXG4gICAgICAvLyBTZXQgbWFya2VyIGF0dHJpYnV0ZVxuICAgICAgbWFya2VyID0gYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgU1ZHLk1hcmtlciA/XG4gICAgICAgIGFyZ3VtZW50c1sxXSA6XG4gICAgICAgIHRoaXMuZG9jKCkubWFya2VyKHdpZHRoLCBoZWlnaHQsIGJsb2NrKVxuICAgICAgXG4gICAgICByZXR1cm4gdGhpcy5hdHRyKGF0dHIsIG1hcmtlcilcbiAgICB9XG4gICAgXG4gIH0pXG5cbiAgdmFyIHN1Z2FyID0ge1xuICAgIHN0cm9rZTogWydjb2xvcicsICd3aWR0aCcsICdvcGFjaXR5JywgJ2xpbmVjYXAnLCAnbGluZWpvaW4nLCAnbWl0ZXJsaW1pdCcsICdkYXNoYXJyYXknLCAnZGFzaG9mZnNldCddXG4gICwgZmlsbDogICBbJ2NvbG9yJywgJ29wYWNpdHknLCAncnVsZSddXG4gICwgcHJlZml4OiBmdW5jdGlvbih0LCBhKSB7XG4gICAgICByZXR1cm4gYSA9PSAnY29sb3InID8gdCA6IHQgKyAnLScgKyBhXG4gICAgfVxuICB9XG4gIFxuICAvKiBBZGQgc3VnYXIgZm9yIGZpbGwgYW5kIHN0cm9rZSAqL1xuICA7WydmaWxsJywgJ3N0cm9rZSddLmZvckVhY2goZnVuY3Rpb24obSkge1xuICAgIHZhciBpLCBleHRlbnNpb24gPSB7fVxuICAgIFxuICAgIGV4dGVuc2lvblttXSA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgIGlmICh0eXBlb2YgbyA9PSAnc3RyaW5nJyB8fCBTVkcuQ29sb3IuaXNSZ2IobykgfHwgKG8gJiYgdHlwZW9mIG8uZmlsbCA9PT0gJ2Z1bmN0aW9uJykpXG4gICAgICAgIHRoaXMuYXR0cihtLCBvKVxuICBcbiAgICAgIGVsc2VcbiAgICAgICAgLyogc2V0IGFsbCBhdHRyaWJ1dGVzIGZyb20gc3VnYXIuZmlsbCBhbmQgc3VnYXIuc3Ryb2tlIGxpc3QgKi9cbiAgICAgICAgZm9yIChpID0gc3VnYXJbbV0ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgaWYgKG9bc3VnYXJbbV1baV1dICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLmF0dHIoc3VnYXIucHJlZml4KG0sIHN1Z2FyW21dW2ldKSwgb1tzdWdhclttXVtpXV0pXG4gICAgICBcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIFxuICAgIFNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIFNWRy5GWCwgZXh0ZW5zaW9uKVxuICAgIFxuICB9KVxuICBcbiAgU1ZHLmV4dGVuZChTVkcuRWxlbWVudCwgU1ZHLkZYLCB7XG4gICAgLy8gUm90YXRpb25cbiAgICByb3RhdGU6IGZ1bmN0aW9uKGRlZywgeCwgeSkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHtcbiAgICAgICAgcm90YXRpb246IGRlZyB8fCAwXG4gICAgICAsIGN4OiB4XG4gICAgICAsIGN5OiB5XG4gICAgICB9KVxuICAgIH1cbiAgICAvLyBTa2V3XG4gICwgc2tldzogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHtcbiAgICAgICAgc2tld1g6IHggfHwgMFxuICAgICAgLCBza2V3WTogeSB8fCAwXG4gICAgICB9KVxuICAgIH1cbiAgICAvLyBTY2FsZVxuICAsIHNjYWxlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oe1xuICAgICAgICBzY2FsZVg6IHhcbiAgICAgICwgc2NhbGVZOiB5ID09IG51bGwgPyB4IDogeVxuICAgICAgfSlcbiAgICB9XG4gICAgLy8gVHJhbnNsYXRlXG4gICwgdHJhbnNsYXRlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oe1xuICAgICAgICB4OiB4XG4gICAgICAsIHk6IHlcbiAgICAgIH0pXG4gICAgfVxuICAgIC8vIE1hdHJpeFxuICAsIG1hdHJpeDogZnVuY3Rpb24obSkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHsgbWF0cml4OiBtIH0pXG4gICAgfVxuICAgIC8vIE9wYWNpdHlcbiAgLCBvcGFjaXR5OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cignb3BhY2l0eScsIHZhbHVlKVxuICAgIH1cbiAgXG4gIH0pXG4gIFxuICBTVkcuZXh0ZW5kKFNWRy5SZWN0LCBTVkcuRWxsaXBzZSwgU1ZHLkZYLCB7XG4gICAgLy8gQWRkIHggYW5kIHkgcmFkaXVzXG4gICAgcmFkaXVzOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyKHsgcng6IHgsIHJ5OiB5IHx8IHggfSlcbiAgICB9XG4gIFxuICB9KVxuICBcbiAgU1ZHLmV4dGVuZChTVkcuUGF0aCwge1xuICAgIC8vIEdldCBwYXRoIGxlbmd0aFxuICAgIGxlbmd0aDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlLmdldFRvdGFsTGVuZ3RoKClcbiAgICB9XG4gICAgLy8gR2V0IHBvaW50IGF0IGxlbmd0aFxuICAsIHBvaW50QXQ6IGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZS5nZXRQb2ludEF0TGVuZ3RoKGxlbmd0aClcbiAgICB9XG4gIFxuICB9KVxuICBcbiAgU1ZHLmV4dGVuZChTVkcuUGFyZW50LCBTVkcuVGV4dCwgU1ZHLkZYLCB7XG4gICAgLy8gU2V0IGZvbnQgXG4gICAgZm9udDogZnVuY3Rpb24obykge1xuICAgICAgZm9yICh2YXIgayBpbiBvKVxuICAgICAgICBrID09ICdsZWFkaW5nJyA/XG4gICAgICAgICAgdGhpcy5sZWFkaW5nKG9ba10pIDpcbiAgICAgICAgayA9PSAnYW5jaG9yJyA/XG4gICAgICAgICAgdGhpcy5hdHRyKCd0ZXh0LWFuY2hvcicsIG9ba10pIDpcbiAgICAgICAgayA9PSAnc2l6ZScgfHwgayA9PSAnZmFtaWx5JyB8fCBrID09ICd3ZWlnaHQnIHx8IGsgPT0gJ3N0cmV0Y2gnIHx8IGsgPT0gJ3ZhcmlhbnQnIHx8IGsgPT0gJ3N0eWxlJyA/XG4gICAgICAgICAgdGhpcy5hdHRyKCdmb250LScrIGssIG9ba10pIDpcbiAgICAgICAgICB0aGlzLmF0dHIoaywgb1trXSlcbiAgICAgIFxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgXG4gIH0pXG4gIFxuXG5cbiAgU1ZHLlNldCA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemVcbiAgICBjcmVhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgLyogc2V0IGluaXRpYWwgc3RhdGUgKi9cbiAgICAgIHRoaXMuY2xlYXIoKVxuICAgIH1cbiAgXG4gICAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcbiAgLCBleHRlbmQ6IHtcbiAgICAgIC8vIEFkZCBlbGVtZW50IHRvIHNldFxuICAgICAgYWRkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGksIGlsLCBlbGVtZW50cyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICBcbiAgICAgICAgZm9yIChpID0gMCwgaWwgPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKVxuICAgICAgICAgIHRoaXMubWVtYmVycy5wdXNoKGVsZW1lbnRzW2ldKVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICAgIC8vIFJlbW92ZSBlbGVtZW50IGZyb20gc2V0XG4gICAgLCByZW1vdmU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLmluZGV4KGVsZW1lbnQpXG4gICAgICAgIFxuICAgICAgICAvKiByZW1vdmUgZ2l2ZW4gY2hpbGQgKi9cbiAgICAgICAgaWYgKGkgPiAtMSlcbiAgICAgICAgICB0aGlzLm1lbWJlcnMuc3BsaWNlKGksIDEpXG4gIFxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgICAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBtZW1iZXJzXG4gICAgLCBlYWNoOiBmdW5jdGlvbihibG9jaykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSB0aGlzLm1lbWJlcnMubGVuZ3RoOyBpIDwgaWw7IGkrKylcbiAgICAgICAgICBibG9jay5hcHBseSh0aGlzLm1lbWJlcnNbaV0sIFtpLCB0aGlzLm1lbWJlcnNdKVxuICBcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICAgIC8vIFJlc3RvcmUgdG8gZGVmYXVsdHNcbiAgICAsIGNsZWFyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLyogaW5pdGlhbGl6ZSBzdG9yZSAqL1xuICAgICAgICB0aGlzLm1lbWJlcnMgPSBbXVxuICBcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICAgIC8vIENoZWNrcyBpZiBhIGdpdmVuIGVsZW1lbnQgaXMgcHJlc2VudCBpbiBzZXRcbiAgICAsIGhhczogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleChlbGVtZW50KSA+PSAwXG4gICAgICB9XG4gICAgICAvLyByZXR1bnMgaW5kZXggb2YgZ2l2ZW4gZWxlbWVudCBpbiBzZXRcbiAgICAsIGluZGV4OiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lbWJlcnMuaW5kZXhPZihlbGVtZW50KVxuICAgICAgfVxuICAgICAgLy8gR2V0IG1lbWJlciBhdCBnaXZlbiBpbmRleFxuICAgICwgZ2V0OiBmdW5jdGlvbihpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lbWJlcnNbaV1cbiAgICAgIH1cbiAgICAgIC8vIEdldCBmaXJzdCBtZW1iZXJcbiAgICAsIGZpcnN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KDApXG4gICAgICB9XG4gICAgICAvLyBHZXQgbGFzdCBtZW1iZXJcbiAgICAsIGxhc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQodGhpcy5tZW1iZXJzLmxlbmd0aCAtIDEpXG4gICAgICB9XG4gICAgICAvLyBEZWZhdWx0IHZhbHVlXG4gICAgLCB2YWx1ZU9mOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVtYmVyc1xuICAgICAgfVxuICAgICAgLy8gR2V0IHRoZSBib3VuZGluZyBib3ggb2YgYWxsIG1lbWJlcnMgaW5jbHVkZWQgb3IgZW1wdHkgYm94IGlmIHNldCBoYXMgbm8gaXRlbXNcbiAgICAsIGJib3g6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBib3ggPSBuZXcgU1ZHLkJCb3goKVxuICBcbiAgICAgICAgLyogcmV0dXJuIGFuIGVtcHR5IGJveCBvZiB0aGVyZSBhcmUgbm8gbWVtYmVycyAqL1xuICAgICAgICBpZiAodGhpcy5tZW1iZXJzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgIHJldHVybiBib3hcbiAgXG4gICAgICAgIC8qIGdldCB0aGUgZmlyc3QgcmJveCBhbmQgdXBkYXRlIHRoZSB0YXJnZXQgYmJveCAqL1xuICAgICAgICB2YXIgcmJveCA9IHRoaXMubWVtYmVyc1swXS5yYm94KClcbiAgICAgICAgYm94LnggICAgICA9IHJib3gueFxuICAgICAgICBib3gueSAgICAgID0gcmJveC55XG4gICAgICAgIGJveC53aWR0aCAgPSByYm94LndpZHRoXG4gICAgICAgIGJveC5oZWlnaHQgPSByYm94LmhlaWdodFxuICBcbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8qIHVzZXIgcmJveCBmb3IgY29ycmVjdCBwb3NpdGlvbiBhbmQgdmlzdWFsIHJlcHJlc2VudGF0aW9uICovXG4gICAgICAgICAgYm94ID0gYm94Lm1lcmdlKHRoaXMucmJveCgpKVxuICAgICAgICB9KVxuICBcbiAgICAgICAgcmV0dXJuIGJveFxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAsIGNvbnN0cnVjdDoge1xuICAgICAgLy8gQ3JlYXRlIGEgbmV3IHNldFxuICAgICAgc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTVkcuU2V0XG4gICAgICB9XG4gICAgfVxuICB9KVxuICBcbiAgU1ZHLlNldEZYID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgY3JlYXRlOiBmdW5jdGlvbihzZXQpIHtcbiAgICAgIC8qIHN0b3JlIHJlZmVyZW5jZSB0byBzZXQgKi9cbiAgICAgIHRoaXMuc2V0ID0gc2V0XG4gICAgfVxuICBcbiAgfSlcbiAgXG4gIC8vIEFsaWFzIG1ldGhvZHNcbiAgU1ZHLlNldC5pbmhlcml0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1cbiAgICAgICwgbWV0aG9kcyA9IFtdXG4gICAgXG4gICAgLyogZ2F0aGVyIHNoYXBlIG1ldGhvZHMgKi9cbiAgICBmb3IodmFyIG0gaW4gU1ZHLlNoYXBlLnByb3RvdHlwZSlcbiAgICAgIGlmICh0eXBlb2YgU1ZHLlNoYXBlLnByb3RvdHlwZVttXSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTVkcuU2V0LnByb3RvdHlwZVttXSAhPSAnZnVuY3Rpb24nKVxuICAgICAgICBtZXRob2RzLnB1c2gobSlcbiAgXG4gICAgLyogYXBwbHkgc2hhcGUgYWxpYXNzZXMgKi9cbiAgICBtZXRob2RzLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBTVkcuU2V0LnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHRoaXMubWVtYmVycy5sZW5ndGg7IGkgPCBpbDsgaSsrKVxuICAgICAgICAgIGlmICh0aGlzLm1lbWJlcnNbaV0gJiYgdHlwZW9mIHRoaXMubWVtYmVyc1tpXVttZXRob2RdID09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aGlzLm1lbWJlcnNbaV1bbWV0aG9kXS5hcHBseSh0aGlzLm1lbWJlcnNbaV0sIGFyZ3VtZW50cylcbiAgXG4gICAgICAgIHJldHVybiBtZXRob2QgPT0gJ2FuaW1hdGUnID8gKHRoaXMuZnggfHwgKHRoaXMuZnggPSBuZXcgU1ZHLlNldEZYKHRoaXMpKSkgOiB0aGlzXG4gICAgICB9XG4gICAgfSlcbiAgXG4gICAgLyogY2xlYXIgbWV0aG9kcyBmb3IgdGhlIG5leHQgcm91bmQgKi9cbiAgICBtZXRob2RzID0gW11cbiAgXG4gICAgLyogZ2F0aGVyIGZ4IG1ldGhvZHMgKi9cbiAgICBmb3IodmFyIG0gaW4gU1ZHLkZYLnByb3RvdHlwZSlcbiAgICAgIGlmICh0eXBlb2YgU1ZHLkZYLnByb3RvdHlwZVttXSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTVkcuU2V0RlgucHJvdG90eXBlW21dICE9ICdmdW5jdGlvbicpXG4gICAgICAgIG1ldGhvZHMucHVzaChtKVxuICBcbiAgICAvKiBhcHBseSBmeCBhbGlhc3NlcyAqL1xuICAgIG1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIFNWRy5TZXRGWC5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSB0aGlzLnNldC5tZW1iZXJzLmxlbmd0aDsgaSA8IGlsOyBpKyspXG4gICAgICAgICAgdGhpcy5zZXQubWVtYmVyc1tpXS5meFttZXRob2RdLmFwcGx5KHRoaXMuc2V0Lm1lbWJlcnNbaV0uZngsIGFyZ3VtZW50cylcbiAgXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gICAgfSlcbiAgfVxuICBcbiAgXG5cblxuICBTVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCB7XG4gIFx0Ly8gU3RvcmUgZGF0YSB2YWx1ZXMgb24gc3ZnIG5vZGVzXG4gICAgZGF0YTogZnVuY3Rpb24oYSwgdiwgcikge1xuICAgIFx0aWYgKHR5cGVvZiBhID09ICdvYmplY3QnKSB7XG4gICAgXHRcdGZvciAodiBpbiBhKVxuICAgIFx0XHRcdHRoaXMuZGF0YSh2LCBhW3ZdKVxuICBcbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0aGlzLmF0dHIoJ2RhdGEtJyArIGEpKVxuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCdkYXRhLScgKyBhKVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hdHRyKFxuICAgICAgICAgICdkYXRhLScgKyBhXG4gICAgICAgICwgdiA9PT0gbnVsbCA/XG4gICAgICAgICAgICBudWxsIDpcbiAgICAgICAgICByID09PSB0cnVlIHx8IHR5cGVvZiB2ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdiA9PT0gJ251bWJlcicgP1xuICAgICAgICAgICAgdiA6XG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh2KVxuICAgICAgICApXG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICB9KVxuXG4gIFNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcbiAgICAvLyBSZW1lbWJlciBhcmJpdHJhcnkgZGF0YVxuICAgIHJlbWVtYmVyOiBmdW5jdGlvbihrLCB2KSB7XG4gICAgICAvKiByZW1lbWJlciBldmVyeSBpdGVtIGluIGFuIG9iamVjdCBpbmRpdmlkdWFsbHkgKi9cbiAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09ICdvYmplY3QnKVxuICAgICAgICBmb3IgKHZhciB2IGluIGspXG4gICAgICAgICAgdGhpcy5yZW1lbWJlcih2LCBrW3ZdKVxuICBcbiAgICAgIC8qIHJldHJpZXZlIG1lbW9yeSAqL1xuICAgICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKVxuICAgICAgICByZXR1cm4gdGhpcy5tZW1vcnkoKVtrXVxuICBcbiAgICAgIC8qIHN0b3JlIG1lbW9yeSAqL1xuICAgICAgZWxzZVxuICAgICAgICB0aGlzLm1lbW9yeSgpW2tdID0gdlxuICBcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICBcbiAgICAvLyBFcmFzZSBhIGdpdmVuIG1lbW9yeVxuICAsIGZvcmdldDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAwKVxuICAgICAgICB0aGlzLl9tZW1vcnkgPSB7fVxuICAgICAgZWxzZVxuICAgICAgICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgIGRlbGV0ZSB0aGlzLm1lbW9yeSgpW2FyZ3VtZW50c1tpXV1cbiAgXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgXG4gICAgLy8gSW5pdGlhbGl6ZSBvciByZXR1cm4gbG9jYWwgbWVtb3J5IG9iamVjdFxuICAsIG1lbW9yeTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWVtb3J5IHx8ICh0aGlzLl9tZW1vcnkgPSB7fSlcbiAgICB9XG4gIFxuICB9KVxuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gU1ZHIH0pXG4gIGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJylcbiAgICBleHBvcnRzLlNWRyA9IFNWR1xuXG4gIGZ1bmN0aW9uIGNhbWVsQ2FzZShzKSB7IFxuICAgIHJldHVybiBzLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLSguKS9nLCBmdW5jdGlvbihtLCBnKSB7XG4gICAgICByZXR1cm4gZy50b1VwcGVyQ2FzZSgpXG4gICAgfSlcbiAgfVxuICBcbiAgLy8gRW5zdXJlIHRvIHNpeC1iYXNlZCBoZXggXG4gIGZ1bmN0aW9uIGZ1bGxIZXgoaGV4KSB7XG4gICAgcmV0dXJuIGhleC5sZW5ndGggPT0gNCA/XG4gICAgICBbICcjJyxcbiAgICAgICAgaGV4LnN1YnN0cmluZygxLCAyKSwgaGV4LnN1YnN0cmluZygxLCAyKVxuICAgICAgLCBoZXguc3Vic3RyaW5nKDIsIDMpLCBoZXguc3Vic3RyaW5nKDIsIDMpXG4gICAgICAsIGhleC5zdWJzdHJpbmcoMywgNCksIGhleC5zdWJzdHJpbmcoMywgNClcbiAgICAgIF0uam9pbignJykgOiBoZXhcbiAgfVxuICBcbiAgLy8gQ29tcG9uZW50IHRvIGhleCB2YWx1ZVxuICBmdW5jdGlvbiBjb21wVG9IZXgoY29tcCkge1xuICAgIHZhciBoZXggPSBjb21wLnRvU3RyaW5nKDE2KVxuICAgIHJldHVybiBoZXgubGVuZ3RoID09IDEgPyAnMCcgKyBoZXggOiBoZXhcbiAgfVxuICBcbiAgLy8gQ2FsY3VsYXRlIHByb3BvcnRpb25hbCB3aWR0aCBhbmQgaGVpZ2h0IHZhbHVlcyB3aGVuIG5lY2Vzc2FyeVxuICBmdW5jdGlvbiBwcm9wb3J0aW9uYWxTaXplKGJveCwgd2lkdGgsIGhlaWdodCkge1xuICAgIGlmICh3aWR0aCA9PSBudWxsIHx8IGhlaWdodCA9PSBudWxsKSB7XG4gICAgICBpZiAoaGVpZ2h0ID09IG51bGwpXG4gICAgICAgIGhlaWdodCA9IGJveC5oZWlnaHQgLyBib3gud2lkdGggKiB3aWR0aFxuICAgICAgZWxzZSBpZiAod2lkdGggPT0gbnVsbClcbiAgICAgICAgd2lkdGggPSBib3gud2lkdGggLyBib3guaGVpZ2h0ICogaGVpZ2h0XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogIHdpZHRoXG4gICAgLCBoZWlnaHQ6IGhlaWdodFxuICAgIH1cbiAgfVxuICBcbiAgLy8gQ2FsY3VsYXRlIHBvc2l0aW9uIGFjY29yZGluZyB0byBmcm9tIGFuZCB0b1xuICBmdW5jdGlvbiBhdChvLCBwb3MpIHtcbiAgICAvKiBudW1iZXIgcmVjYWxjdWxhdGlvbiAoZG9uJ3QgYm90aGVyIGNvbnZlcnRpbmcgdG8gU1ZHLk51bWJlciBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucykgKi9cbiAgICByZXR1cm4gdHlwZW9mIG8uZnJvbSA9PSAnbnVtYmVyJyA/XG4gICAgICBvLmZyb20gKyAoby50byAtIG8uZnJvbSkgKiBwb3MgOlxuICAgIFxuICAgIC8qIGluc3RhbmNlIHJlY2FsY3VsYXRpb24gKi9cbiAgICBvIGluc3RhbmNlb2YgU1ZHLkNvbG9yIHx8IG8gaW5zdGFuY2VvZiBTVkcuTnVtYmVyID8gby5hdChwb3MpIDpcbiAgICBcbiAgICAvKiBmb3IgYWxsIG90aGVyIHZhbHVlcyB3YWl0IHVudGlsIHBvcyBoYXMgcmVhY2hlZCAxIHRvIHJldHVybiB0aGUgZmluYWwgdmFsdWUgKi9cbiAgICBwb3MgPCAxID8gby5mcm9tIDogby50b1xuICB9XG4gIFxuICAvLyBQYXRoQXJyYXkgSGVscGVyc1xuICBmdW5jdGlvbiBhcnJheVRvU3RyaW5nKGEpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBhLmxlbmd0aCwgcyA9ICcnOyBpIDwgaWw7IGkrKykge1xuICAgICAgcyArPSBhW2ldWzBdXG4gIFxuICAgICAgaWYgKGFbaV1bMV0gIT0gbnVsbCkge1xuICAgICAgICBzICs9IGFbaV1bMV1cbiAgXG4gICAgICAgIGlmIChhW2ldWzJdICE9IG51bGwpIHtcbiAgICAgICAgICBzICs9ICcgJ1xuICAgICAgICAgIHMgKz0gYVtpXVsyXVxuICBcbiAgICAgICAgICBpZiAoYVtpXVszXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzICs9ICcgJ1xuICAgICAgICAgICAgcyArPSBhW2ldWzNdXG4gICAgICAgICAgICBzICs9ICcgJ1xuICAgICAgICAgICAgcyArPSBhW2ldWzRdXG4gIFxuICAgICAgICAgICAgaWYgKGFbaV1bNV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICBzICs9ICcgJ1xuICAgICAgICAgICAgICBzICs9IGFbaV1bNV1cbiAgICAgICAgICAgICAgcyArPSAnICdcbiAgICAgICAgICAgICAgcyArPSBhW2ldWzZdXG4gIFxuICAgICAgICAgICAgICBpZiAoYVtpXVs3XSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcyArPSAnICdcbiAgICAgICAgICAgICAgICBzICs9IGFbaV1bN11cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcyArICcgJ1xuICB9XG4gIFxuICAvLyBBZGQgbW9yZSBib3VuZGluZyBib3ggcHJvcGVydGllc1xuICBmdW5jdGlvbiBib3hQcm9wZXJ0aWVzKGIpIHtcbiAgICBiLngyID0gYi54ICsgYi53aWR0aFxuICAgIGIueTIgPSBiLnkgKyBiLmhlaWdodFxuICAgIGIuY3ggPSBiLnggKyBiLndpZHRoIC8gMlxuICAgIGIuY3kgPSBiLnkgKyBiLmhlaWdodCAvIDJcbiAgfVxuICBcbiAgLy8gUGFyc2UgYSBtYXRyaXggc3RyaW5nXG4gIGZ1bmN0aW9uIHBhcnNlTWF0cml4KG8pIHtcbiAgICBpZiAoby5tYXRyaXgpIHtcbiAgICAgIC8qIHNwbGl0IG1hdHJpeCBzdHJpbmcgKi9cbiAgICAgIHZhciBtID0gby5tYXRyaXgucmVwbGFjZSgvXFxzL2csICcnKS5zcGxpdCgnLCcpXG4gICAgICBcbiAgICAgIC8qIHBhc3JzZSB2YWx1ZXMgKi9cbiAgICAgIGlmIChtLmxlbmd0aCA9PSA2KSB7XG4gICAgICAgIG8uYSA9IHBhcnNlRmxvYXQobVswXSlcbiAgICAgICAgby5iID0gcGFyc2VGbG9hdChtWzFdKVxuICAgICAgICBvLmMgPSBwYXJzZUZsb2F0KG1bMl0pXG4gICAgICAgIG8uZCA9IHBhcnNlRmxvYXQobVszXSlcbiAgICAgICAgby5lID0gcGFyc2VGbG9hdChtWzRdKVxuICAgICAgICBvLmYgPSBwYXJzZUZsb2F0KG1bNV0pXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvXG4gIH1cbiAgXG4gIC8vIEdldCBpZCBmcm9tIHJlZmVyZW5jZSBzdHJpbmdcbiAgZnVuY3Rpb24gaWRGcm9tUmVmZXJlbmNlKHVybCkge1xuICAgIHZhciBtID0gdXJsLnRvU3RyaW5nKCkubWF0Y2goU1ZHLnJlZ2V4LnJlZmVyZW5jZSlcbiAgXG4gICAgaWYgKG0pIHJldHVybiBtWzFdXG4gIH1cbiAgXG4gIC8vIFNoaW0gbGF5ZXIgd2l0aCBzZXRUaW1lb3V0IGZhbGxiYWNrIGJ5IFBhdWwgSXJpc2hcbiAgd2luZG93LnJlcXVlc3RBbmltRnJhbWUgPSAoZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgICAgfHxcbiAgICAgICAgICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgfHxcbiAgICAgICAgICAgIHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChjKSB7IHdpbmRvdy5zZXRUaW1lb3V0KGMsIDEwMDAgLyA2MCkgfVxuICB9KSgpXG5cbiAgcmV0dXJuIFNWR1xufSkpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc3ZnLmpzL2Rpc3Qvc3ZnLmpzXG4gKiogbW9kdWxlIGlkID0gN1xuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgT3BlbiBUZWNobm9sb2dpZXMsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcblxyXG47KGZ1bmN0aW9uICh1bmRlZmluZWQpIHtcclxuXHJcbiAgdmFyIG9iamVjdFR5cGVzID0ge1xyXG4gICAgJ2Jvb2xlYW4nOiBmYWxzZSxcclxuICAgICdmdW5jdGlvbic6IHRydWUsXHJcbiAgICAnb2JqZWN0JzogdHJ1ZSxcclxuICAgICdudW1iZXInOiBmYWxzZSxcclxuICAgICdzdHJpbmcnOiBmYWxzZSxcclxuICAgICd1bmRlZmluZWQnOiBmYWxzZVxyXG4gIH07XHJcblxyXG4gIHZhciByb290ID0gKG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdykgfHwgdGhpcyxcclxuICAgIGZyZWVFeHBvcnRzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGV4cG9ydHNdICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cyxcclxuICAgIGZyZWVNb2R1bGUgPSBvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGUsXHJcbiAgICBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzICYmIGZyZWVFeHBvcnRzLFxyXG4gICAgZnJlZUdsb2JhbCA9IG9iamVjdFR5cGVzW3R5cGVvZiBnbG9iYWxdICYmIGdsb2JhbDtcclxuXHJcbiAgaWYgKGZyZWVHbG9iYWwgJiYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsKSkge1xyXG4gICAgcm9vdCA9IGZyZWVHbG9iYWw7XHJcbiAgfVxyXG5cclxuICB2YXIgUnggPSB7XHJcbiAgICAgIGludGVybmFsczoge30sXHJcbiAgICAgIGNvbmZpZzoge1xyXG4gICAgICAgIFByb21pc2U6IHJvb3QuUHJvbWlzZSAvLyBEZXRlY3QgaWYgcHJvbWlzZSBleGlzdHNcclxuICAgICAgfSxcclxuICAgICAgaGVscGVyczogeyB9XHJcbiAgfTtcclxuXHJcbiAgLy8gRGVmYXVsdHNcclxuICB2YXIgbm9vcCA9IFJ4LmhlbHBlcnMubm9vcCA9IGZ1bmN0aW9uICgpIHsgfSxcclxuICAgIG5vdERlZmluZWQgPSBSeC5oZWxwZXJzLm5vdERlZmluZWQgPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4gdHlwZW9mIHggPT09ICd1bmRlZmluZWQnOyB9LFxyXG4gICAgaXNTY2hlZHVsZXIgPSBSeC5oZWxwZXJzLmlzU2NoZWR1bGVyID0gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggaW5zdGFuY2VvZiBSeC5TY2hlZHVsZXI7IH0sXHJcbiAgICBpZGVudGl0eSA9IFJ4LmhlbHBlcnMuaWRlbnRpdHkgPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSxcclxuICAgIHBsdWNrID0gUnguaGVscGVycy5wbHVjayA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkgeyByZXR1cm4gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHhbcHJvcGVydHldOyB9OyB9LFxyXG4gICAganVzdCA9IFJ4LmhlbHBlcnMuanVzdCA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWU7IH07IH0sXHJcbiAgICBkZWZhdWx0Tm93ID0gUnguaGVscGVycy5kZWZhdWx0Tm93ID0gRGF0ZS5ub3csXHJcbiAgICBkZWZhdWx0Q29tcGFyZXIgPSBSeC5oZWxwZXJzLmRlZmF1bHRDb21wYXJlciA9IGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiBpc0VxdWFsKHgsIHkpOyB9LFxyXG4gICAgZGVmYXVsdFN1YkNvbXBhcmVyID0gUnguaGVscGVycy5kZWZhdWx0U3ViQ29tcGFyZXIgPSBmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4geCA+IHkgPyAxIDogKHggPCB5ID8gLTEgOiAwKTsgfSxcclxuICAgIGRlZmF1bHRLZXlTZXJpYWxpemVyID0gUnguaGVscGVycy5kZWZhdWx0S2V5U2VyaWFsaXplciA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnRvU3RyaW5nKCk7IH0sXHJcbiAgICBkZWZhdWx0RXJyb3IgPSBSeC5oZWxwZXJzLmRlZmF1bHRFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHsgdGhyb3cgZXJyOyB9LFxyXG4gICAgaXNQcm9taXNlID0gUnguaGVscGVycy5pc1Byb21pc2UgPSBmdW5jdGlvbiAocCkgeyByZXR1cm4gISFwICYmIHR5cGVvZiBwLnRoZW4gPT09ICdmdW5jdGlvbic7IH0sXHJcbiAgICBhc0FycmF5ID0gUnguaGVscGVycy5hc0FycmF5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTsgfSxcclxuICAgIG5vdCA9IFJ4LmhlbHBlcnMubm90ID0gZnVuY3Rpb24gKGEpIHsgcmV0dXJuICFhOyB9LFxyXG4gICAgaXNGdW5jdGlvbiA9IFJ4LmhlbHBlcnMuaXNGdW5jdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICB2YXIgaXNGbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyB8fCBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gZmFsbGJhY2sgZm9yIG9sZGVyIHZlcnNpb25zIG9mIENocm9tZSBhbmQgU2FmYXJpXHJcbiAgICAgIGlmIChpc0ZuKC94LykpIHtcclxuICAgICAgICBpc0ZuID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSAnW29iamVjdCBGdW5jdGlvbl0nO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBpc0ZuO1xyXG4gICAgfSgpKTtcclxuXHJcbiAgLy8gRXJyb3JzXHJcbiAgdmFyIHNlcXVlbmNlQ29udGFpbnNOb0VsZW1lbnRzID0gJ1NlcXVlbmNlIGNvbnRhaW5zIG5vIGVsZW1lbnRzLic7XHJcbiAgdmFyIGFyZ3VtZW50T3V0T2ZSYW5nZSA9ICdBcmd1bWVudCBvdXQgb2YgcmFuZ2UnO1xyXG4gIHZhciBvYmplY3REaXNwb3NlZCA9ICdPYmplY3QgaGFzIGJlZW4gZGlzcG9zZWQnO1xyXG4gIGZ1bmN0aW9uIGNoZWNrRGlzcG9zZWQoKSB7IGlmICh0aGlzLmlzRGlzcG9zZWQpIHsgdGhyb3cgbmV3IEVycm9yKG9iamVjdERpc3Bvc2VkKTsgfSB9XHJcblxyXG4gIC8vIFNoaW0gaW4gaXRlcmF0b3Igc3VwcG9ydFxyXG4gIHZhciAkaXRlcmF0b3IkID0gKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yKSB8fFxyXG4gICAgJ19lczZzaGltX2l0ZXJhdG9yXyc7XHJcbiAgLy8gQnVnIGZvciBtb3ppbGxhIHZlcnNpb25cclxuICBpZiAocm9vdC5TZXQgJiYgdHlwZW9mIG5ldyByb290LlNldCgpWydAQGl0ZXJhdG9yJ10gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICRpdGVyYXRvciQgPSAnQEBpdGVyYXRvcic7XHJcbiAgfVxyXG5cclxuICB2YXIgZG9uZUVudW1lcmF0b3IgPSBSeC5kb25lRW51bWVyYXRvciA9IHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9O1xyXG5cclxuICBSeC5pdGVyYXRvciA9ICRpdGVyYXRvciQ7XHJcblxyXG4gIC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgc2hvcnRjdXRzICovXG4gIHZhciBhcmdzQ2xhc3MgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheUNsYXNzID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sQ2xhc3MgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZUNsYXNzID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yQ2xhc3MgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNDbGFzcyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbnVtYmVyQ2xhc3MgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RDbGFzcyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cENsYXNzID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc3RyaW5nQ2xhc3MgPSAnW29iamVjdCBTdHJpbmddJztcblxuICB2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFxuICAgIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICBzdXBwb3J0c0FyZ3NDbGFzcyA9IHRvU3RyaW5nLmNhbGwoYXJndW1lbnRzKSA9PSBhcmdzQ2xhc3MsIC8vIEZvciBsZXNzIDxJRTkgJiYgRkY8NFxuICAgIHN1cG9ydE5vZGVDbGFzcyxcbiAgICBlcnJvclByb3RvID0gRXJyb3IucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZSxcbiAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4gIHRyeSB7XG4gICAgc3Vwb3J0Tm9kZUNsYXNzID0gISh0b1N0cmluZy5jYWxsKGRvY3VtZW50KSA9PSBvYmplY3RDbGFzcyAmJiAhKHsgJ3RvU3RyaW5nJzogMCB9ICsgJycpKTtcbiAgfSBjYXRjaChlKSB7XG4gICAgc3Vwb3J0Tm9kZUNsYXNzID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBzaGFkb3dlZFByb3BzID0gW1xuICAgICdjb25zdHJ1Y3RvcicsICdoYXNPd25Qcm9wZXJ0eScsICdpc1Byb3RvdHlwZU9mJywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJ3RvTG9jYWxlU3RyaW5nJywgJ3RvU3RyaW5nJywgJ3ZhbHVlT2YnXG4gIF07XG5cbiAgdmFyIG5vbkVudW1Qcm9wcyA9IHt9O1xuICBub25FbnVtUHJvcHNbYXJyYXlDbGFzc10gPSBub25FbnVtUHJvcHNbZGF0ZUNsYXNzXSA9IG5vbkVudW1Qcm9wc1tudW1iZXJDbGFzc10gPSB7ICdjb25zdHJ1Y3Rvcic6IHRydWUsICd0b0xvY2FsZVN0cmluZyc6IHRydWUsICd0b1N0cmluZyc6IHRydWUsICd2YWx1ZU9mJzogdHJ1ZSB9O1xuICBub25FbnVtUHJvcHNbYm9vbENsYXNzXSA9IG5vbkVudW1Qcm9wc1tzdHJpbmdDbGFzc10gPSB7ICdjb25zdHJ1Y3Rvcic6IHRydWUsICd0b1N0cmluZyc6IHRydWUsICd2YWx1ZU9mJzogdHJ1ZSB9O1xuICBub25FbnVtUHJvcHNbZXJyb3JDbGFzc10gPSBub25FbnVtUHJvcHNbZnVuY0NsYXNzXSA9IG5vbkVudW1Qcm9wc1tyZWdleHBDbGFzc10gPSB7ICdjb25zdHJ1Y3Rvcic6IHRydWUsICd0b1N0cmluZyc6IHRydWUgfTtcbiAgbm9uRW51bVByb3BzW29iamVjdENsYXNzXSA9IHsgJ2NvbnN0cnVjdG9yJzogdHJ1ZSB9O1xuXG4gIHZhciBzdXBwb3J0ID0ge307XG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGN0b3IgPSBmdW5jdGlvbigpIHsgdGhpcy54ID0gMTsgfSxcbiAgICAgIHByb3BzID0gW107XG5cbiAgICBjdG9yLnByb3RvdHlwZSA9IHsgJ3ZhbHVlT2YnOiAxLCAneSc6IDEgfTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbmV3IGN0b3IpIHsgcHJvcHMucHVzaChrZXkpOyB9XG4gICAgZm9yIChrZXkgaW4gYXJndW1lbnRzKSB7IH1cblxuICAgIC8vIERldGVjdCBpZiBgbmFtZWAgb3IgYG1lc3NhZ2VgIHByb3BlcnRpZXMgb2YgYEVycm9yLnByb3RvdHlwZWAgYXJlIGVudW1lcmFibGUgYnkgZGVmYXVsdC5cbiAgICBzdXBwb3J0LmVudW1FcnJvclByb3BzID0gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlcnJvclByb3RvLCAnbWVzc2FnZScpIHx8IHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoZXJyb3JQcm90bywgJ25hbWUnKTtcblxuICAgIC8vIERldGVjdCBpZiBgcHJvdG90eXBlYCBwcm9wZXJ0aWVzIGFyZSBlbnVtZXJhYmxlIGJ5IGRlZmF1bHQuXG4gICAgc3VwcG9ydC5lbnVtUHJvdG90eXBlcyA9IHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoY3RvciwgJ3Byb3RvdHlwZScpO1xuXG4gICAgLy8gRGV0ZWN0IGlmIGBhcmd1bWVudHNgIG9iamVjdCBpbmRleGVzIGFyZSBub24tZW51bWVyYWJsZVxuICAgIHN1cHBvcnQubm9uRW51bUFyZ3MgPSBrZXkgIT0gMDtcblxuICAgIC8vIERldGVjdCBpZiBwcm9wZXJ0aWVzIHNoYWRvd2luZyB0aG9zZSBvbiBgT2JqZWN0LnByb3RvdHlwZWAgYXJlIG5vbi1lbnVtZXJhYmxlLlxuICAgIHN1cHBvcnQubm9uRW51bVNoYWRvd3MgPSAhL3ZhbHVlT2YvLnRlc3QocHJvcHMpO1xuICB9KDEpKTtcblxuICBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIC8vIGNoZWNrIGlmIHRoZSB2YWx1ZSBpcyB0aGUgRUNNQVNjcmlwdCBsYW5ndWFnZSB0eXBlIG9mIE9iamVjdFxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4OFxuICAgIC8vIGFuZCBhdm9pZCBhIFY4IGJ1Z1xuICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxXG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlICYmICh0eXBlID09ICdmdW5jdGlvbicgfHwgdHlwZSA9PSAnb2JqZWN0JykgfHwgZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHN1cHBvcnQubm9uRW51bUFyZ3MgJiYgb2JqZWN0Lmxlbmd0aCAmJiBpc0FyZ3VtZW50cyhvYmplY3QpKSB7XG4gICAgICBvYmplY3QgPSBzbGljZS5jYWxsKG9iamVjdCk7XG4gICAgfVxuICAgIHZhciBza2lwUHJvdG8gPSBzdXBwb3J0LmVudW1Qcm90b3R5cGVzICYmIHR5cGVvZiBvYmplY3QgPT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgc2tpcEVycm9yUHJvcHMgPSBzdXBwb3J0LmVudW1FcnJvclByb3BzICYmIChvYmplY3QgPT09IGVycm9yUHJvdG8gfHwgb2JqZWN0IGluc3RhbmNlb2YgRXJyb3IpO1xuXG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgaWYgKCEoc2tpcFByb3RvICYmIGtleSA9PSAncHJvdG90eXBlJykgJiZcbiAgICAgICAgICAhKHNraXBFcnJvclByb3BzICYmIChrZXkgPT0gJ21lc3NhZ2UnIHx8IGtleSA9PSAnbmFtZScpKSkge1xuICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdXBwb3J0Lm5vbkVudW1TaGFkb3dzICYmIG9iamVjdCAhPT0gb2JqZWN0UHJvdG8pIHtcbiAgICAgIHZhciBjdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gc2hhZG93ZWRQcm9wcy5sZW5ndGg7XG5cbiAgICAgIGlmIChvYmplY3QgPT09IChjdG9yICYmIGN0b3IucHJvdG90eXBlKSkge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gb2JqZWN0ID09PSBzdHJpbmdQcm90byA/IHN0cmluZ0NsYXNzIDogb2JqZWN0ID09PSBlcnJvclByb3RvID8gZXJyb3JDbGFzcyA6IHRvU3RyaW5nLmNhbGwob2JqZWN0KSxcbiAgICAgICAgICAgIG5vbkVudW0gPSBub25FbnVtUHJvcHNbY2xhc3NOYW1lXTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGtleSA9IHNoYWRvd2VkUHJvcHNbaW5kZXhdO1xuICAgICAgICBpZiAoIShub25FbnVtICYmIG5vbkVudW1ba2V5XSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBpbnRlcm5hbEZvcihvYmplY3QsIGNhbGxiYWNrLCBrZXlzRnVuYykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICBpZiAoY2FsbGJhY2sob2JqZWN0W2tleV0sIGtleSwgb2JqZWN0KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cblxuICBmdW5jdGlvbiBpbnRlcm5hbEZvckluKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gaW50ZXJuYWxGb3Iob2JqZWN0LCBjYWxsYmFjaywga2V5c0luKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm9kZSh2YWx1ZSkge1xuICAgIC8vIElFIDwgOSBwcmVzZW50cyBET00gbm9kZXMgYXMgYE9iamVjdGAgb2JqZWN0cyBleGNlcHQgdGhleSBoYXZlIGB0b1N0cmluZ2BcbiAgICAvLyBtZXRob2RzIHRoYXQgYXJlIGB0eXBlb2ZgIFwic3RyaW5nXCIgYW5kIHN0aWxsIGNhbiBjb2VyY2Ugbm9kZXMgdG8gc3RyaW5nc1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgKHZhbHVlICsgJycpID09ICdzdHJpbmcnO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JykgPyB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcmdzQ2xhc3MgOiBmYWxzZTtcbiAgfVxuXG4gIC8vIGZhbGxiYWNrIGZvciBicm93c2VycyB0aGF0IGNhbid0IGRldGVjdCBgYXJndW1lbnRzYCBvYmplY3RzIGJ5IFtbQ2xhc3NdXVxuICBpZiAoIXN1cHBvcnRzQXJnc0NsYXNzKSB7XG4gICAgaXNBcmd1bWVudHMgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpID8gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpIDogZmFsc2U7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBpc0VxdWFsID0gUnguaW50ZXJuYWxzLmlzRXF1YWwgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHJldHVybiBkZWVwRXF1YWxzKHgsIHksIFtdLCBbXSk7XG4gIH07XG5cbiAgLyoqIEBwcml2YXRlXG4gICAqIFVzZWQgZm9yIGRlZXAgY29tcGFyaXNvblxuICAgKiovXG4gIGZ1bmN0aW9uIGRlZXBFcXVhbHMoYSwgYiwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAvLyBleGl0IGVhcmx5IGZvciBpZGVudGljYWwgdmFsdWVzXG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgIC8vIHRyZWF0IGArMGAgdnMuIGAtMGAgYXMgbm90IGVxdWFsXG4gICAgICByZXR1cm4gYSAhPT0gMCB8fCAoMSAvIGEgPT0gMSAvIGIpO1xuICAgIH1cblxuICAgIHZhciB0eXBlID0gdHlwZW9mIGEsXG4gICAgICAgIG90aGVyVHlwZSA9IHR5cGVvZiBiO1xuXG4gICAgLy8gZXhpdCBlYXJseSBmb3IgdW5saWtlIHByaW1pdGl2ZSB2YWx1ZXNcbiAgICBpZiAoYSA9PT0gYSAmJiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCB8fFxuICAgICAgICAodHlwZSAhPSAnZnVuY3Rpb24nICYmIHR5cGUgIT0gJ29iamVjdCcgJiYgb3RoZXJUeXBlICE9ICdmdW5jdGlvbicgJiYgb3RoZXJUeXBlICE9ICdvYmplY3QnKSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBjb21wYXJlIFtbQ2xhc3NdXSBuYW1lc1xuICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpLFxuICAgICAgICBvdGhlckNsYXNzID0gdG9TdHJpbmcuY2FsbChiKTtcblxuICAgIGlmIChjbGFzc05hbWUgPT0gYXJnc0NsYXNzKSB7XG4gICAgICBjbGFzc05hbWUgPSBvYmplY3RDbGFzcztcbiAgICB9XG4gICAgaWYgKG90aGVyQ2xhc3MgPT0gYXJnc0NsYXNzKSB7XG4gICAgICBvdGhlckNsYXNzID0gb2JqZWN0Q2xhc3M7XG4gICAgfVxuICAgIGlmIChjbGFzc05hbWUgIT0gb3RoZXJDbGFzcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgY2FzZSBib29sQ2xhc3M6XG4gICAgICBjYXNlIGRhdGVDbGFzczpcbiAgICAgICAgLy8gY29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1iZXJzLCBkYXRlcyB0byBtaWxsaXNlY29uZHMgYW5kIGJvb2xlYW5zXG4gICAgICAgIC8vIHRvIGAxYCBvciBgMGAgdHJlYXRpbmcgaW52YWxpZCBkYXRlcyBjb2VyY2VkIHRvIGBOYU5gIGFzIG5vdCBlcXVhbFxuICAgICAgICByZXR1cm4gK2EgPT0gK2I7XG5cbiAgICAgIGNhc2UgbnVtYmVyQ2xhc3M6XG4gICAgICAgIC8vIHRyZWF0IGBOYU5gIHZzLiBgTmFOYCBhcyBlcXVhbFxuICAgICAgICByZXR1cm4gKGEgIT0gK2EpXG4gICAgICAgICAgPyBiICE9ICtiXG4gICAgICAgICAgLy8gYnV0IHRyZWF0IGAtMGAgdnMuIGArMGAgYXMgbm90IGVxdWFsXG4gICAgICAgICAgOiAoYSA9PSAwID8gKDEgLyBhID09IDEgLyBiKSA6IGEgPT0gK2IpO1xuXG4gICAgICBjYXNlIHJlZ2V4cENsYXNzOlxuICAgICAgY2FzZSBzdHJpbmdDbGFzczpcbiAgICAgICAgLy8gY29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyAoaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS4xMC42LjQpXG4gICAgICAgIC8vIHRyZWF0IHN0cmluZyBwcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCBpbnN0YW5jZXMgYXMgZXF1YWxcbiAgICAgICAgcmV0dXJuIGEgPT0gU3RyaW5nKGIpO1xuICAgIH1cbiAgICB2YXIgaXNBcnIgPSBjbGFzc05hbWUgPT0gYXJyYXlDbGFzcztcbiAgICBpZiAoIWlzQXJyKSB7XG5cbiAgICAgIC8vIGV4aXQgZm9yIGZ1bmN0aW9ucyBhbmQgRE9NIG5vZGVzXG4gICAgICBpZiAoY2xhc3NOYW1lICE9IG9iamVjdENsYXNzIHx8ICghc3VwcG9ydC5ub2RlQ2xhc3MgJiYgKGlzTm9kZShhKSB8fCBpc05vZGUoYikpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBpbiBvbGRlciB2ZXJzaW9ucyBvZiBPcGVyYSwgYGFyZ3VtZW50c2Agb2JqZWN0cyBoYXZlIGBBcnJheWAgY29uc3RydWN0b3JzXG4gICAgICB2YXIgY3RvckEgPSAhc3VwcG9ydC5hcmdzT2JqZWN0ICYmIGlzQXJndW1lbnRzKGEpID8gT2JqZWN0IDogYS5jb25zdHJ1Y3RvcixcbiAgICAgICAgICBjdG9yQiA9ICFzdXBwb3J0LmFyZ3NPYmplY3QgJiYgaXNBcmd1bWVudHMoYikgPyBPYmplY3QgOiBiLmNvbnN0cnVjdG9yO1xuXG4gICAgICAvLyBub24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbFxuICAgICAgaWYgKGN0b3JBICE9IGN0b3JCICYmXG4gICAgICAgICAgICAhKGhhc093blByb3BlcnR5LmNhbGwoYSwgJ2NvbnN0cnVjdG9yJykgJiYgaGFzT3duUHJvcGVydHkuY2FsbChiLCAnY29uc3RydWN0b3InKSkgJiZcbiAgICAgICAgICAgICEoaXNGdW5jdGlvbihjdG9yQSkgJiYgY3RvckEgaW5zdGFuY2VvZiBjdG9yQSAmJiBpc0Z1bmN0aW9uKGN0b3JCKSAmJiBjdG9yQiBpbnN0YW5jZW9mIGN0b3JCKSAmJlxuICAgICAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gYSAmJiAnY29uc3RydWN0b3InIGluIGIpXG4gICAgICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gYXNzdW1lIGN5Y2xpYyBzdHJ1Y3R1cmVzIGFyZSBlcXVhbFxuICAgIC8vIHRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWMgc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xXG4gICAgLy8gc2VjdGlvbiAxNS4xMi4zLCBhYnN0cmFjdCBvcGVyYXRpb24gYEpPYCAoaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS4xMi4zKVxuICAgIHZhciBpbml0ZWRTdGFjayA9ICFzdGFja0E7XG4gICAgc3RhY2tBIHx8IChzdGFja0EgPSBbXSk7XG4gICAgc3RhY2tCIHx8IChzdGFja0IgPSBbXSk7XG5cbiAgICB2YXIgbGVuZ3RoID0gc3RhY2tBLmxlbmd0aDtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGlmIChzdGFja0FbbGVuZ3RoXSA9PSBhKSB7XG4gICAgICAgIHJldHVybiBzdGFja0JbbGVuZ3RoXSA9PSBiO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgc2l6ZSA9IDA7XG4gICAgdmFyIHJlc3VsdCA9IHRydWU7XG5cbiAgICAvLyBhZGQgYGFgIGFuZCBgYmAgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzXG4gICAgc3RhY2tBLnB1c2goYSk7XG4gICAgc3RhY2tCLnB1c2goYik7XG5cbiAgICAvLyByZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpXG4gICAgaWYgKGlzQXJyKSB7XG4gICAgICAvLyBjb21wYXJlIGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeVxuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBzaXplID0gYi5sZW5ndGg7XG4gICAgICByZXN1bHQgPSBzaXplID09IGxlbmd0aDtcblxuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAvLyBkZWVwIGNvbXBhcmUgdGhlIGNvbnRlbnRzLCBpZ25vcmluZyBub24tbnVtZXJpYyBwcm9wZXJ0aWVzXG4gICAgICAgIHdoaWxlIChzaXplLS0pIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSBsZW5ndGgsXG4gICAgICAgICAgICAgIHZhbHVlID0gYltzaXplXTtcblxuICAgICAgICAgIGlmICghKHJlc3VsdCA9IGRlZXBFcXVhbHMoYVtzaXplXSwgdmFsdWUsIHN0YWNrQSwgc3RhY2tCKSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGRlZXAgY29tcGFyZSBvYmplY3RzIHVzaW5nIGBmb3JJbmAsIGluc3RlYWQgb2YgYGZvck93bmAsIHRvIGF2b2lkIGBPYmplY3Qua2V5c2BcbiAgICAgIC8vIHdoaWNoLCBpbiB0aGlzIGNhc2UsIGlzIG1vcmUgY29zdGx5XG4gICAgICBpbnRlcm5hbEZvckluKGIsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGIpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoYiwga2V5KSkge1xuICAgICAgICAgIC8vIGNvdW50IHRoZSBudW1iZXIgb2YgcHJvcGVydGllcy5cbiAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgLy8gZGVlcCBjb21wYXJlIGVhY2ggcHJvcGVydHkgdmFsdWUuXG4gICAgICAgICAgcmV0dXJuIChyZXN1bHQgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGtleSkgJiYgZGVlcEVxdWFscyhhW2tleV0sIHZhbHVlLCBzdGFja0EsIHN0YWNrQikpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAvLyBlbnN1cmUgYm90aCBvYmplY3RzIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHByb3BlcnRpZXNcbiAgICAgICAgaW50ZXJuYWxGb3JJbihhLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBhKSB7XG4gICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoYSwga2V5KSkge1xuICAgICAgICAgICAgLy8gYHNpemVgIHdpbGwgYmUgYC0xYCBpZiBgYWAgaGFzIG1vcmUgcHJvcGVydGllcyB0aGFuIGBiYFxuICAgICAgICAgICAgcmV0dXJuIChyZXN1bHQgPSAtLXNpemUgPiAtMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhY2tBLnBvcCgpO1xuICAgIHN0YWNrQi5wb3AoKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxyXG4gIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcclxuICBmdW5jdGlvbiBhcmdzT3JBcnJheShhcmdzLCBpZHgpIHtcclxuICAgIHJldHVybiBhcmdzLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KGFyZ3NbaWR4XSkgP1xyXG4gICAgICBhcmdzW2lkeF0gOlxyXG4gICAgICBzbGljZS5jYWxsKGFyZ3MpO1xyXG4gIH1cclxuICB2YXIgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xyXG5cclxuICB2YXIgaW5oZXJpdHMgPSB0aGlzLmluaGVyaXRzID0gUnguaW50ZXJuYWxzLmluaGVyaXRzID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH1cclxuICAgIF9fLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XHJcbiAgICBjaGlsZC5wcm90b3R5cGUgPSBuZXcgX18oKTtcclxuICB9O1xyXG5cclxuICB2YXIgYWRkUHJvcGVydGllcyA9IFJ4LmludGVybmFscy5hZGRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgdmFyIHNvdXJjZXMgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc291cmNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICB2YXIgc291cmNlID0gc291cmNlc1tpXTtcclxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcclxuICAgICAgICBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBSeCBVdGlsc1xyXG4gIHZhciBhZGRSZWYgPSBSeC5pbnRlcm5hbHMuYWRkUmVmID0gZnVuY3Rpb24gKHhzLCByKSB7XHJcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgIHJldHVybiBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZShyLmdldERpc3Bvc2FibGUoKSwgeHMuc3Vic2NyaWJlKG9ic2VydmVyKSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBhcnJheUluaXRpYWxpemUoY291bnQsIGZhY3RvcnkpIHtcclxuICAgIHZhciBhID0gbmV3IEFycmF5KGNvdW50KTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICBhW2ldID0gZmFjdG9yeSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGE7XHJcbiAgfVxyXG5cclxuICAvLyBDb2xsZWN0aW9uc1xyXG4gIGZ1bmN0aW9uIEluZGV4ZWRJdGVtKGlkLCB2YWx1ZSkge1xyXG4gICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgSW5kZXhlZEl0ZW0ucHJvdG90eXBlLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIChvdGhlcikge1xyXG4gICAgdmFyIGMgPSB0aGlzLnZhbHVlLmNvbXBhcmVUbyhvdGhlci52YWx1ZSk7XHJcbiAgICBjID09PSAwICYmIChjID0gdGhpcy5pZCAtIG90aGVyLmlkKTtcclxuICAgIHJldHVybiBjO1xyXG4gIH07XHJcblxyXG4gIC8vIFByaW9yaXR5IFF1ZXVlIGZvciBTY2hlZHVsaW5nXHJcbiAgdmFyIFByaW9yaXR5UXVldWUgPSBSeC5pbnRlcm5hbHMuUHJpb3JpdHlRdWV1ZSA9IGZ1bmN0aW9uIChjYXBhY2l0eSkge1xyXG4gICAgdGhpcy5pdGVtcyA9IG5ldyBBcnJheShjYXBhY2l0eSk7XHJcbiAgICB0aGlzLmxlbmd0aCA9IDA7XHJcbiAgfTtcclxuXHJcbiAgdmFyIHByaW9yaXR5UHJvdG8gPSBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZTtcclxuICBwcmlvcml0eVByb3RvLmlzSGlnaGVyUHJpb3JpdHkgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcclxuICAgIHJldHVybiB0aGlzLml0ZW1zW2xlZnRdLmNvbXBhcmVUbyh0aGlzLml0ZW1zW3JpZ2h0XSkgPCAwO1xyXG4gIH07XHJcblxyXG4gIHByaW9yaXR5UHJvdG8ucGVyY29sYXRlID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICBpZiAoaW5kZXggPj0gdGhpcy5sZW5ndGggfHwgaW5kZXggPCAwKSB7IHJldHVybjsgfVxyXG4gICAgdmFyIHBhcmVudCA9IGluZGV4IC0gMSA+PiAxO1xyXG4gICAgaWYgKHBhcmVudCA8IDAgfHwgcGFyZW50ID09PSBpbmRleCkgeyByZXR1cm47IH1cclxuICAgIGlmICh0aGlzLmlzSGlnaGVyUHJpb3JpdHkoaW5kZXgsIHBhcmVudCkpIHtcclxuICAgICAgdmFyIHRlbXAgPSB0aGlzLml0ZW1zW2luZGV4XTtcclxuICAgICAgdGhpcy5pdGVtc1tpbmRleF0gPSB0aGlzLml0ZW1zW3BhcmVudF07XHJcbiAgICAgIHRoaXMuaXRlbXNbcGFyZW50XSA9IHRlbXA7XHJcbiAgICAgIHRoaXMucGVyY29sYXRlKHBhcmVudCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgcHJpb3JpdHlQcm90by5oZWFwaWZ5ID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAraW5kZXggfHwgKGluZGV4ID0gMCk7XHJcbiAgICBpZiAoaW5kZXggPj0gdGhpcy5sZW5ndGggfHwgaW5kZXggPCAwKSB7IHJldHVybjsgfVxyXG4gICAgdmFyIGxlZnQgPSAyICogaW5kZXggKyAxLFxyXG4gICAgICAgIHJpZ2h0ID0gMiAqIGluZGV4ICsgMixcclxuICAgICAgICBmaXJzdCA9IGluZGV4O1xyXG4gICAgaWYgKGxlZnQgPCB0aGlzLmxlbmd0aCAmJiB0aGlzLmlzSGlnaGVyUHJpb3JpdHkobGVmdCwgZmlyc3QpKSB7XHJcbiAgICAgIGZpcnN0ID0gbGVmdDtcclxuICAgIH1cclxuICAgIGlmIChyaWdodCA8IHRoaXMubGVuZ3RoICYmIHRoaXMuaXNIaWdoZXJQcmlvcml0eShyaWdodCwgZmlyc3QpKSB7XHJcbiAgICAgIGZpcnN0ID0gcmlnaHQ7XHJcbiAgICB9XHJcbiAgICBpZiAoZmlyc3QgIT09IGluZGV4KSB7XHJcbiAgICAgIHZhciB0ZW1wID0gdGhpcy5pdGVtc1tpbmRleF07XHJcbiAgICAgIHRoaXMuaXRlbXNbaW5kZXhdID0gdGhpcy5pdGVtc1tmaXJzdF07XHJcbiAgICAgIHRoaXMuaXRlbXNbZmlyc3RdID0gdGVtcDtcclxuICAgICAgdGhpcy5oZWFwaWZ5KGZpcnN0KTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBwcmlvcml0eVByb3RvLnBlZWsgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLml0ZW1zWzBdLnZhbHVlOyB9O1xyXG5cclxuICBwcmlvcml0eVByb3RvLnJlbW92ZUF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICB0aGlzLml0ZW1zW2luZGV4XSA9IHRoaXMuaXRlbXNbLS10aGlzLmxlbmd0aF07XHJcbiAgICBkZWxldGUgdGhpcy5pdGVtc1t0aGlzLmxlbmd0aF07XHJcbiAgICB0aGlzLmhlYXBpZnkoKTtcclxuICB9O1xyXG5cclxuICBwcmlvcml0eVByb3RvLmRlcXVldWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5wZWVrKCk7XHJcbiAgICB0aGlzLnJlbW92ZUF0KDApO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9O1xyXG5cclxuICBwcmlvcml0eVByb3RvLmVucXVldWUgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgdmFyIGluZGV4ID0gdGhpcy5sZW5ndGgrKztcclxuICAgIHRoaXMuaXRlbXNbaW5kZXhdID0gbmV3IEluZGV4ZWRJdGVtKFByaW9yaXR5UXVldWUuY291bnQrKywgaXRlbSk7XHJcbiAgICB0aGlzLnBlcmNvbGF0ZShpbmRleCk7XHJcbiAgfTtcclxuXHJcbiAgcHJpb3JpdHlQcm90by5yZW1vdmUgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmICh0aGlzLml0ZW1zW2ldLnZhbHVlID09PSBpdGVtKSB7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVBdChpKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH07XHJcbiAgUHJpb3JpdHlRdWV1ZS5jb3VudCA9IDA7XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlcHJlc2VudHMgYSBncm91cCBvZiBkaXNwb3NhYmxlIHJlc291cmNlcyB0aGF0IGFyZSBkaXNwb3NlZCB0b2dldGhlci5cclxuICAgKiBAY29uc3RydWN0b3JcclxuICAgKi9cclxuICB2YXIgQ29tcG9zaXRlRGlzcG9zYWJsZSA9IFJ4LkNvbXBvc2l0ZURpc3Bvc2FibGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmRpc3Bvc2FibGVzID0gYXJnc09yQXJyYXkoYXJndW1lbnRzLCAwKTtcclxuICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5sZW5ndGggPSB0aGlzLmRpc3Bvc2FibGVzLmxlbmd0aDtcclxuICB9O1xyXG5cclxuICB2YXIgQ29tcG9zaXRlRGlzcG9zYWJsZVByb3RvdHlwZSA9IENvbXBvc2l0ZURpc3Bvc2FibGUucHJvdG90eXBlO1xyXG5cclxuICAvKipcclxuICAgKiBBZGRzIGEgZGlzcG9zYWJsZSB0byB0aGUgQ29tcG9zaXRlRGlzcG9zYWJsZSBvciBkaXNwb3NlcyB0aGUgZGlzcG9zYWJsZSBpZiB0aGUgQ29tcG9zaXRlRGlzcG9zYWJsZSBpcyBkaXNwb3NlZC5cclxuICAgKiBAcGFyYW0ge01peGVkfSBpdGVtIERpc3Bvc2FibGUgdG8gYWRkLlxyXG4gICAqL1xyXG4gIENvbXBvc2l0ZURpc3Bvc2FibGVQcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgIGlmICh0aGlzLmlzRGlzcG9zZWQpIHtcclxuICAgICAgaXRlbS5kaXNwb3NlKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmRpc3Bvc2FibGVzLnB1c2goaXRlbSk7XHJcbiAgICAgIHRoaXMubGVuZ3RoKys7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBhbmQgZGlzcG9zZXMgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYSBkaXNwb3NhYmxlIGZyb20gdGhlIENvbXBvc2l0ZURpc3Bvc2FibGUuXHJcbiAgICogQHBhcmFtIHtNaXhlZH0gaXRlbSBEaXNwb3NhYmxlIHRvIHJlbW92ZS5cclxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiBmb3VuZDsgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAqL1xyXG4gIENvbXBvc2l0ZURpc3Bvc2FibGVQcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgIHZhciBzaG91bGREaXNwb3NlID0gZmFsc2U7XHJcbiAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCkge1xyXG4gICAgICB2YXIgaWR4ID0gdGhpcy5kaXNwb3NhYmxlcy5pbmRleE9mKGl0ZW0pO1xyXG4gICAgICBpZiAoaWR4ICE9PSAtMSkge1xyXG4gICAgICAgIHNob3VsZERpc3Bvc2UgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZGlzcG9zYWJsZXMuc3BsaWNlKGlkeCwgMSk7XHJcbiAgICAgICAgdGhpcy5sZW5ndGgtLTtcclxuICAgICAgICBpdGVtLmRpc3Bvc2UoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNob3VsZERpc3Bvc2U7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogIERpc3Bvc2VzIGFsbCBkaXNwb3NhYmxlcyBpbiB0aGUgZ3JvdXAgYW5kIHJlbW92ZXMgdGhlbSBmcm9tIHRoZSBncm91cC5cclxuICAgKi9cclxuICBDb21wb3NpdGVEaXNwb3NhYmxlUHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCkge1xyXG4gICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xyXG4gICAgICB2YXIgY3VycmVudERpc3Bvc2FibGVzID0gdGhpcy5kaXNwb3NhYmxlcy5zbGljZSgwKTtcclxuICAgICAgdGhpcy5kaXNwb3NhYmxlcyA9IFtdO1xyXG4gICAgICB0aGlzLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY3VycmVudERpc3Bvc2FibGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgY3VycmVudERpc3Bvc2FibGVzW2ldLmRpc3Bvc2UoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnRzIHRoZSBleGlzdGluZyBDb21wb3NpdGVEaXNwb3NhYmxlIHRvIGFuIGFycmF5IG9mIGRpc3Bvc2FibGVzXHJcbiAgICogQHJldHVybnMge0FycmF5fSBBbiBhcnJheSBvZiBkaXNwb3NhYmxlIG9iamVjdHMuXHJcbiAgICovXHJcbiAgQ29tcG9zaXRlRGlzcG9zYWJsZVByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGlzcG9zYWJsZXMuc2xpY2UoMCk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUHJvdmlkZXMgYSBzZXQgb2Ygc3RhdGljIG1ldGhvZHMgZm9yIGNyZWF0aW5nIERpc3Bvc2FibGVzLlxyXG4gICAqXHJcbiAgICogQGNvbnN0cnVjdG9yXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZGlzcG9zZSBBY3Rpb24gdG8gcnVuIGR1cmluZyB0aGUgZmlyc3QgY2FsbCB0byBkaXNwb3NlLiBUaGUgYWN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gYmUgcnVuIGF0IG1vc3Qgb25jZS5cclxuICAgKi9cclxuICB2YXIgRGlzcG9zYWJsZSA9IFJ4LkRpc3Bvc2FibGUgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuYWN0aW9uID0gYWN0aW9uIHx8IG5vb3A7XHJcbiAgfTtcclxuXHJcbiAgLyoqIFBlcmZvcm1zIHRoZSB0YXNrIG9mIGNsZWFuaW5nIHVwIHJlc291cmNlcy4gKi9cclxuICBEaXNwb3NhYmxlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKCF0aGlzLmlzRGlzcG9zZWQpIHtcclxuICAgICAgdGhpcy5hY3Rpb24oKTtcclxuICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgZGlzcG9zYWJsZSBvYmplY3QgdGhhdCBpbnZva2VzIHRoZSBzcGVjaWZpZWQgYWN0aW9uIHdoZW4gZGlzcG9zZWQuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZGlzcG9zZSBBY3Rpb24gdG8gcnVuIGR1cmluZyB0aGUgZmlyc3QgY2FsbCB0byBkaXNwb3NlLiBUaGUgYWN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gYmUgcnVuIGF0IG1vc3Qgb25jZS5cclxuICAgKiBAcmV0dXJuIHtEaXNwb3NhYmxlfSBUaGUgZGlzcG9zYWJsZSBvYmplY3QgdGhhdCBydW5zIHRoZSBnaXZlbiBhY3Rpb24gdXBvbiBkaXNwb3NhbC5cclxuICAgKi9cclxuICB2YXIgZGlzcG9zYWJsZUNyZWF0ZSA9IERpc3Bvc2FibGUuY3JlYXRlID0gZnVuY3Rpb24gKGFjdGlvbikgeyByZXR1cm4gbmV3IERpc3Bvc2FibGUoYWN0aW9uKTsgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgZGlzcG9zYWJsZSB0aGF0IGRvZXMgbm90aGluZyB3aGVuIGRpc3Bvc2VkLlxyXG4gICAqL1xyXG4gIHZhciBkaXNwb3NhYmxlRW1wdHkgPSBEaXNwb3NhYmxlLmVtcHR5ID0geyBkaXNwb3NlOiBub29wIH07XHJcblxyXG4gIHZhciBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSA9IFJ4LlNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJvb2xlYW5EaXNwb3NhYmxlICgpIHtcclxuICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuY3VycmVudCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGJvb2xlYW5EaXNwb3NhYmxlUHJvdG90eXBlID0gQm9vbGVhbkRpc3Bvc2FibGUucHJvdG90eXBlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgdW5kZXJseWluZyBkaXNwb3NhYmxlLlxyXG4gICAgICogQHJldHVybiBUaGUgdW5kZXJseWluZyBkaXNwb3NhYmxlLlxyXG4gICAgICovXHJcbiAgICBib29sZWFuRGlzcG9zYWJsZVByb3RvdHlwZS5nZXREaXNwb3NhYmxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHVuZGVybHlpbmcgZGlzcG9zYWJsZS5cclxuICAgICAqIEBwYXJhbSB7RGlzcG9zYWJsZX0gdmFsdWUgVGhlIG5ldyB1bmRlcmx5aW5nIGRpc3Bvc2FibGUuXHJcbiAgICAgKi9cclxuICAgIGJvb2xlYW5EaXNwb3NhYmxlUHJvdG90eXBlLnNldERpc3Bvc2FibGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgdmFyIHNob3VsZERpc3Bvc2UgPSB0aGlzLmlzRGlzcG9zZWQsIG9sZDtcclxuICAgICAgaWYgKCFzaG91bGREaXNwb3NlKSB7XHJcbiAgICAgICAgb2xkID0gdGhpcy5jdXJyZW50O1xyXG4gICAgICAgIHRoaXMuY3VycmVudCA9IHZhbHVlO1xyXG4gICAgICB9XHJcbiAgICAgIG9sZCAmJiBvbGQuZGlzcG9zZSgpO1xyXG4gICAgICBzaG91bGREaXNwb3NlICYmIHZhbHVlICYmIHZhbHVlLmRpc3Bvc2UoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwb3NlcyB0aGUgdW5kZXJseWluZyBkaXNwb3NhYmxlIGFzIHdlbGwgYXMgYWxsIGZ1dHVyZSByZXBsYWNlbWVudHMuXHJcbiAgICAgKi9cclxuICAgIGJvb2xlYW5EaXNwb3NhYmxlUHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBvbGQ7XHJcbiAgICAgIGlmICghdGhpcy5pc0Rpc3Bvc2VkKSB7XHJcbiAgICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcclxuICAgICAgICBvbGQgPSB0aGlzLmN1cnJlbnQ7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICBvbGQgJiYgb2xkLmRpc3Bvc2UoKTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIEJvb2xlYW5EaXNwb3NhYmxlO1xyXG4gIH0oKSk7XHJcbiAgdmFyIFNlcmlhbERpc3Bvc2FibGUgPSBSeC5TZXJpYWxEaXNwb3NhYmxlID0gU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXByZXNlbnRzIGEgZGlzcG9zYWJsZSByZXNvdXJjZSB0aGF0IG9ubHkgZGlzcG9zZXMgaXRzIHVuZGVybHlpbmcgZGlzcG9zYWJsZSByZXNvdXJjZSB3aGVuIGFsbCBkZXBlbmRlbnQgZGlzcG9zYWJsZSBvYmplY3RzIGhhdmUgYmVlbiBkaXNwb3NlZC5cclxuICAgICAqL1xyXG4gICAgdmFyIFJlZkNvdW50RGlzcG9zYWJsZSA9IFJ4LlJlZkNvdW50RGlzcG9zYWJsZSA9IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIElubmVyRGlzcG9zYWJsZShkaXNwb3NhYmxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zYWJsZSA9IGRpc3Bvc2FibGU7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zYWJsZS5jb3VudCsrO1xyXG4gICAgICAgICAgICB0aGlzLmlzSW5uZXJEaXNwb3NlZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgSW5uZXJEaXNwb3NhYmxlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZGlzcG9zYWJsZS5pc0Rpc3Bvc2VkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNJbm5lckRpc3Bvc2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0lubmVyRGlzcG9zZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zYWJsZS5jb3VudC0tO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRpc3Bvc2FibGUuY291bnQgPT09IDAgJiYgdGhpcy5kaXNwb3NhYmxlLmlzUHJpbWFyeURpc3Bvc2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zYWJsZS5pc0Rpc3Bvc2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NhYmxlLnVuZGVybHlpbmdEaXNwb3NhYmxlLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgUmVmQ291bnREaXNwb3NhYmxlIHdpdGggdGhlIHNwZWNpZmllZCBkaXNwb3NhYmxlLlxyXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqIEBwYXJhbSB7RGlzcG9zYWJsZX0gZGlzcG9zYWJsZSBVbmRlcmx5aW5nIGRpc3Bvc2FibGUuXHJcbiAgICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFJlZkNvdW50RGlzcG9zYWJsZShkaXNwb3NhYmxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMudW5kZXJseWluZ0Rpc3Bvc2FibGUgPSBkaXNwb3NhYmxlO1xyXG4gICAgICAgICAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5pc1ByaW1hcnlEaXNwb3NlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmNvdW50ID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERpc3Bvc2VzIHRoZSB1bmRlcmx5aW5nIGRpc3Bvc2FibGUgb25seSB3aGVuIGFsbCBkZXBlbmRlbnQgZGlzcG9zYWJsZXMgaGF2ZSBiZWVuIGRpc3Bvc2VkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVmQ291bnREaXNwb3NhYmxlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzUHJpbWFyeURpc3Bvc2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1ByaW1hcnlEaXNwb3NlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY291bnQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51bmRlcmx5aW5nRGlzcG9zYWJsZS5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIGRlcGVuZGVudCBkaXNwb3NhYmxlIHRoYXQgd2hlbiBkaXNwb3NlZCBkZWNyZWFzZXMgdGhlIHJlZmNvdW50IG9uIHRoZSB1bmRlcmx5aW5nIGRpc3Bvc2FibGUuXHJcbiAgICAgICAgICogQHJldHVybnMge0Rpc3Bvc2FibGV9IEEgZGVwZW5kZW50IGRpc3Bvc2FibGUgY29udHJpYnV0aW5nIHRvIHRoZSByZWZlcmVuY2UgY291bnQgdGhhdCBtYW5hZ2VzIHRoZSB1bmRlcmx5aW5nIGRpc3Bvc2FibGUncyBsaWZldGltZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSZWZDb3VudERpc3Bvc2FibGUucHJvdG90eXBlLmdldERpc3Bvc2FibGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzRGlzcG9zZWQgPyBkaXNwb3NhYmxlRW1wdHkgOiBuZXcgSW5uZXJEaXNwb3NhYmxlKHRoaXMpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBSZWZDb3VudERpc3Bvc2FibGU7XHJcbiAgICB9KSgpO1xyXG5cclxuICAgIGZ1bmN0aW9uIFNjaGVkdWxlZERpc3Bvc2FibGUoc2NoZWR1bGVyLCBkaXNwb3NhYmxlKSB7XHJcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XHJcbiAgICAgICAgdGhpcy5kaXNwb3NhYmxlID0gZGlzcG9zYWJsZTtcclxuICAgICAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBTY2hlZHVsZWREaXNwb3NhYmxlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuc2NoZWR1bGVyLnNjaGVkdWxlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCFwYXJlbnQuaXNEaXNwb3NlZCkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50LmlzRGlzcG9zZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50LmRpc3Bvc2FibGUuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICB2YXIgU2NoZWR1bGVkSXRlbSA9IFJ4LmludGVybmFscy5TY2hlZHVsZWRJdGVtID0gZnVuY3Rpb24gKHNjaGVkdWxlciwgc3RhdGUsIGFjdGlvbiwgZHVlVGltZSwgY29tcGFyZXIpIHtcbiAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgdGhpcy5hY3Rpb24gPSBhY3Rpb247XG4gICAgdGhpcy5kdWVUaW1lID0gZHVlVGltZTtcbiAgICB0aGlzLmNvbXBhcmVyID0gY29tcGFyZXIgfHwgZGVmYXVsdFN1YkNvbXBhcmVyO1xuICAgIHRoaXMuZGlzcG9zYWJsZSA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICB9XG5cbiAgU2NoZWR1bGVkSXRlbS5wcm90b3R5cGUuaW52b2tlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGlzcG9zYWJsZS5zZXREaXNwb3NhYmxlKHRoaXMuaW52b2tlQ29yZSgpKTtcbiAgfTtcblxuICBTY2hlZHVsZWRJdGVtLnByb3RvdHlwZS5jb21wYXJlVG8gPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wYXJlcih0aGlzLmR1ZVRpbWUsIG90aGVyLmR1ZVRpbWUpO1xuICB9O1xuXG4gIFNjaGVkdWxlZEl0ZW0ucHJvdG90eXBlLmlzQ2FuY2VsbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmRpc3Bvc2FibGUuaXNEaXNwb3NlZDtcbiAgfTtcblxuICBTY2hlZHVsZWRJdGVtLnByb3RvdHlwZS5pbnZva2VDb3JlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmFjdGlvbih0aGlzLnNjaGVkdWxlciwgdGhpcy5zdGF0ZSk7XG4gIH07XG5cclxuICAvKiogUHJvdmlkZXMgYSBzZXQgb2Ygc3RhdGljIHByb3BlcnRpZXMgdG8gYWNjZXNzIGNvbW1vbmx5IHVzZWQgc2NoZWR1bGVycy4gKi9cbiAgdmFyIFNjaGVkdWxlciA9IFJ4LlNjaGVkdWxlciA9IChmdW5jdGlvbiAoKSB7XG5cbiAgICBmdW5jdGlvbiBTY2hlZHVsZXIobm93LCBzY2hlZHVsZSwgc2NoZWR1bGVSZWxhdGl2ZSwgc2NoZWR1bGVBYnNvbHV0ZSkge1xuICAgICAgdGhpcy5ub3cgPSBub3c7XG4gICAgICB0aGlzLl9zY2hlZHVsZSA9IHNjaGVkdWxlO1xuICAgICAgdGhpcy5fc2NoZWR1bGVSZWxhdGl2ZSA9IHNjaGVkdWxlUmVsYXRpdmU7XG4gICAgICB0aGlzLl9zY2hlZHVsZUFic29sdXRlID0gc2NoZWR1bGVBYnNvbHV0ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZva2VBY3Rpb24oc2NoZWR1bGVyLCBhY3Rpb24pIHtcbiAgICAgIGFjdGlvbigpO1xuICAgICAgcmV0dXJuIGRpc3Bvc2FibGVFbXB0eTtcbiAgICB9XG5cbiAgICB2YXIgc2NoZWR1bGVyUHJvdG8gPSBTY2hlZHVsZXIucHJvdG90eXBlO1xuXG4gICAgLyoqXG4gICAgICogU2NoZWR1bGVzIGFuIGFjdGlvbiB0byBiZSBleGVjdXRlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY3Rpb24gQWN0aW9uIHRvIGV4ZWN1dGUuXG4gICAgICogQHJldHVybnMge0Rpc3Bvc2FibGV9IFRoZSBkaXNwb3NhYmxlIG9iamVjdCB1c2VkIHRvIGNhbmNlbCB0aGUgc2NoZWR1bGVkIGFjdGlvbiAoYmVzdCBlZmZvcnQpLlxuICAgICAqL1xuICAgIHNjaGVkdWxlclByb3RvLnNjaGVkdWxlID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3NjaGVkdWxlKGFjdGlvbiwgaW52b2tlQWN0aW9uKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2NoZWR1bGVzIGFuIGFjdGlvbiB0byBiZSBleGVjdXRlZC5cbiAgICAgKiBAcGFyYW0gc3RhdGUgU3RhdGUgcGFzc2VkIHRvIHRoZSBhY3Rpb24gdG8gYmUgZXhlY3V0ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYWN0aW9uIEFjdGlvbiB0byBiZSBleGVjdXRlZC5cbiAgICAgKiBAcmV0dXJucyB7RGlzcG9zYWJsZX0gVGhlIGRpc3Bvc2FibGUgb2JqZWN0IHVzZWQgdG8gY2FuY2VsIHRoZSBzY2hlZHVsZWQgYWN0aW9uIChiZXN0IGVmZm9ydCkuXG4gICAgICovXG4gICAgc2NoZWR1bGVyUHJvdG8uc2NoZWR1bGVXaXRoU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIGFjdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3NjaGVkdWxlKHN0YXRlLCBhY3Rpb24pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXMgYW4gYWN0aW9uIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSBzcGVjaWZpZWQgcmVsYXRpdmUgZHVlIHRpbWUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYWN0aW9uIEFjdGlvbiB0byBleGVjdXRlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkdWVUaW1lIFJlbGF0aXZlIHRpbWUgYWZ0ZXIgd2hpY2ggdG8gZXhlY3V0ZSB0aGUgYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtEaXNwb3NhYmxlfSBUaGUgZGlzcG9zYWJsZSBvYmplY3QgdXNlZCB0byBjYW5jZWwgdGhlIHNjaGVkdWxlZCBhY3Rpb24gKGJlc3QgZWZmb3J0KS5cbiAgICAgKi9cbiAgICBzY2hlZHVsZXJQcm90by5zY2hlZHVsZVdpdGhSZWxhdGl2ZSA9IGZ1bmN0aW9uIChkdWVUaW1lLCBhY3Rpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLl9zY2hlZHVsZVJlbGF0aXZlKGFjdGlvbiwgZHVlVGltZSwgaW52b2tlQWN0aW9uKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2NoZWR1bGVzIGFuIGFjdGlvbiB0byBiZSBleGVjdXRlZCBhZnRlciBkdWVUaW1lLlxuICAgICAqIEBwYXJhbSBzdGF0ZSBTdGF0ZSBwYXNzZWQgdG8gdGhlIGFjdGlvbiB0byBiZSBleGVjdXRlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY3Rpb24gQWN0aW9uIHRvIGJlIGV4ZWN1dGVkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkdWVUaW1lIFJlbGF0aXZlIHRpbWUgYWZ0ZXIgd2hpY2ggdG8gZXhlY3V0ZSB0aGUgYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtEaXNwb3NhYmxlfSBUaGUgZGlzcG9zYWJsZSBvYmplY3QgdXNlZCB0byBjYW5jZWwgdGhlIHNjaGVkdWxlZCBhY3Rpb24gKGJlc3QgZWZmb3J0KS5cbiAgICAgKi9cbiAgICBzY2hlZHVsZXJQcm90by5zY2hlZHVsZVdpdGhSZWxhdGl2ZUFuZFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlLCBkdWVUaW1lLCBhY3Rpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLl9zY2hlZHVsZVJlbGF0aXZlKHN0YXRlLCBkdWVUaW1lLCBhY3Rpb24pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXMgYW4gYWN0aW9uIHRvIGJlIGV4ZWN1dGVkIGF0IHRoZSBzcGVjaWZpZWQgYWJzb2x1dGUgZHVlIHRpbWUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYWN0aW9uIEFjdGlvbiB0byBleGVjdXRlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkdWVUaW1lIEFic29sdXRlIHRpbWUgYXQgd2hpY2ggdG8gZXhlY3V0ZSB0aGUgYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtEaXNwb3NhYmxlfSBUaGUgZGlzcG9zYWJsZSBvYmplY3QgdXNlZCB0byBjYW5jZWwgdGhlIHNjaGVkdWxlZCBhY3Rpb24gKGJlc3QgZWZmb3J0KS5cbiAgICAgICovXG4gICAgc2NoZWR1bGVyUHJvdG8uc2NoZWR1bGVXaXRoQWJzb2x1dGUgPSBmdW5jdGlvbiAoZHVlVGltZSwgYWN0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2NoZWR1bGVBYnNvbHV0ZShhY3Rpb24sIGR1ZVRpbWUsIGludm9rZUFjdGlvbik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlcyBhbiBhY3Rpb24gdG8gYmUgZXhlY3V0ZWQgYXQgZHVlVGltZS5cbiAgICAgKiBAcGFyYW0ge01peGVkfSBzdGF0ZSBTdGF0ZSBwYXNzZWQgdG8gdGhlIGFjdGlvbiB0byBiZSBleGVjdXRlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY3Rpb24gQWN0aW9uIHRvIGJlIGV4ZWN1dGVkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfWR1ZVRpbWUgQWJzb2x1dGUgdGltZSBhdCB3aGljaCB0byBleGVjdXRlIHRoZSBhY3Rpb24uXG4gICAgICogQHJldHVybnMge0Rpc3Bvc2FibGV9IFRoZSBkaXNwb3NhYmxlIG9iamVjdCB1c2VkIHRvIGNhbmNlbCB0aGUgc2NoZWR1bGVkIGFjdGlvbiAoYmVzdCBlZmZvcnQpLlxuICAgICAqL1xuICAgIHNjaGVkdWxlclByb3RvLnNjaGVkdWxlV2l0aEFic29sdXRlQW5kU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIGR1ZVRpbWUsIGFjdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3NjaGVkdWxlQWJzb2x1dGUoc3RhdGUsIGR1ZVRpbWUsIGFjdGlvbik7XG4gICAgfTtcblxuICAgIC8qKiBHZXRzIHRoZSBjdXJyZW50IHRpbWUgYWNjb3JkaW5nIHRvIHRoZSBsb2NhbCBtYWNoaW5lJ3Mgc3lzdGVtIGNsb2NrLiAqL1xuICAgIFNjaGVkdWxlci5ub3cgPSBkZWZhdWx0Tm93O1xuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplcyB0aGUgc3BlY2lmaWVkIFRpbWVTcGFuIHZhbHVlIHRvIGEgcG9zaXRpdmUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVTcGFuIFRoZSB0aW1lIHNwYW4gdmFsdWUgdG8gbm9ybWFsaXplLlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBzcGVjaWZpZWQgVGltZVNwYW4gdmFsdWUgaWYgaXQgaXMgemVybyBvciBwb3NpdGl2ZTsgb3RoZXJ3aXNlLCAwXG4gICAgICovXG4gICAgU2NoZWR1bGVyLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uICh0aW1lU3Bhbikge1xuICAgICAgdGltZVNwYW4gPCAwICYmICh0aW1lU3BhbiA9IDApO1xuICAgICAgcmV0dXJuIHRpbWVTcGFuO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2NoZWR1bGVyO1xuICB9KCkpO1xuXG4gIHZhciBub3JtYWxpemVUaW1lID0gU2NoZWR1bGVyLm5vcm1hbGl6ZTtcblxyXG4gIChmdW5jdGlvbiAoc2NoZWR1bGVyUHJvdG8pIHtcclxuICAgIGZ1bmN0aW9uIGludm9rZVJlY0ltbWVkaWF0ZShzY2hlZHVsZXIsIHBhaXIpIHtcclxuICAgICAgdmFyIHN0YXRlID0gcGFpci5maXJzdCwgYWN0aW9uID0gcGFpci5zZWNvbmQsIGdyb3VwID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKSxcclxuICAgICAgcmVjdXJzaXZlQWN0aW9uID0gZnVuY3Rpb24gKHN0YXRlMSkge1xyXG4gICAgICAgIGFjdGlvbihzdGF0ZTEsIGZ1bmN0aW9uIChzdGF0ZTIpIHtcclxuICAgICAgICAgIHZhciBpc0FkZGVkID0gZmFsc2UsIGlzRG9uZSA9IGZhbHNlLFxyXG4gICAgICAgICAgZCA9IHNjaGVkdWxlci5zY2hlZHVsZVdpdGhTdGF0ZShzdGF0ZTIsIGZ1bmN0aW9uIChzY2hlZHVsZXIxLCBzdGF0ZTMpIHtcclxuICAgICAgICAgICAgaWYgKGlzQWRkZWQpIHtcclxuICAgICAgICAgICAgICBncm91cC5yZW1vdmUoZCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgaXNEb25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZWN1cnNpdmVBY3Rpb24oc3RhdGUzKTtcclxuICAgICAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGVFbXB0eTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgaWYgKCFpc0RvbmUpIHtcclxuICAgICAgICAgICAgZ3JvdXAuYWRkKGQpO1xyXG4gICAgICAgICAgICBpc0FkZGVkID0gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfTtcclxuICAgICAgcmVjdXJzaXZlQWN0aW9uKHN0YXRlKTtcclxuICAgICAgcmV0dXJuIGdyb3VwO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGludm9rZVJlY0RhdGUoc2NoZWR1bGVyLCBwYWlyLCBtZXRob2QpIHtcclxuICAgICAgdmFyIHN0YXRlID0gcGFpci5maXJzdCwgYWN0aW9uID0gcGFpci5zZWNvbmQsIGdyb3VwID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKSxcclxuICAgICAgcmVjdXJzaXZlQWN0aW9uID0gZnVuY3Rpb24gKHN0YXRlMSkge1xyXG4gICAgICAgIGFjdGlvbihzdGF0ZTEsIGZ1bmN0aW9uIChzdGF0ZTIsIGR1ZVRpbWUxKSB7XHJcbiAgICAgICAgICB2YXIgaXNBZGRlZCA9IGZhbHNlLCBpc0RvbmUgPSBmYWxzZSxcclxuICAgICAgICAgIGQgPSBzY2hlZHVsZXJbbWV0aG9kXS5jYWxsKHNjaGVkdWxlciwgc3RhdGUyLCBkdWVUaW1lMSwgZnVuY3Rpb24gKHNjaGVkdWxlcjEsIHN0YXRlMykge1xyXG4gICAgICAgICAgICBpZiAoaXNBZGRlZCkge1xyXG4gICAgICAgICAgICAgIGdyb3VwLnJlbW92ZShkKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBpc0RvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlY3Vyc2l2ZUFjdGlvbihzdGF0ZTMpO1xyXG4gICAgICAgICAgICByZXR1cm4gZGlzcG9zYWJsZUVtcHR5O1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBpZiAoIWlzRG9uZSkge1xyXG4gICAgICAgICAgICBncm91cC5hZGQoZCk7XHJcbiAgICAgICAgICAgIGlzQWRkZWQgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9O1xyXG4gICAgICByZWN1cnNpdmVBY3Rpb24oc3RhdGUpO1xyXG4gICAgICByZXR1cm4gZ3JvdXA7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVJbm5lclJlY3Vyc2l2ZShhY3Rpb24sIHNlbGYpIHtcclxuICAgICAgYWN0aW9uKGZ1bmN0aW9uKGR0KSB7IHNlbGYoYWN0aW9uLCBkdCk7IH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2NoZWR1bGVzIGFuIGFjdGlvbiB0byBiZSBleGVjdXRlZCByZWN1cnNpdmVseS5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFjdGlvbiBBY3Rpb24gdG8gZXhlY3V0ZSByZWN1cnNpdmVseS4gVGhlIHBhcmFtZXRlciBwYXNzZWQgdG8gdGhlIGFjdGlvbiBpcyB1c2VkIHRvIHRyaWdnZXIgcmVjdXJzaXZlIHNjaGVkdWxpbmcgb2YgdGhlIGFjdGlvbi5cclxuICAgICAqIEByZXR1cm5zIHtEaXNwb3NhYmxlfSBUaGUgZGlzcG9zYWJsZSBvYmplY3QgdXNlZCB0byBjYW5jZWwgdGhlIHNjaGVkdWxlZCBhY3Rpb24gKGJlc3QgZWZmb3J0KS5cclxuICAgICAqL1xyXG4gICAgc2NoZWR1bGVyUHJvdG8uc2NoZWR1bGVSZWN1cnNpdmUgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNjaGVkdWxlUmVjdXJzaXZlV2l0aFN0YXRlKGFjdGlvbiwgZnVuY3Rpb24gKF9hY3Rpb24sIHNlbGYpIHtcclxuICAgICAgICBfYWN0aW9uKGZ1bmN0aW9uICgpIHsgc2VsZihfYWN0aW9uKTsgfSk7IH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNjaGVkdWxlcyBhbiBhY3Rpb24gdG8gYmUgZXhlY3V0ZWQgcmVjdXJzaXZlbHkuXHJcbiAgICAgKiBAcGFyYW0ge01peGVkfSBzdGF0ZSBTdGF0ZSBwYXNzZWQgdG8gdGhlIGFjdGlvbiB0byBiZSBleGVjdXRlZC5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFjdGlvbiBBY3Rpb24gdG8gZXhlY3V0ZSByZWN1cnNpdmVseS4gVGhlIGxhc3QgcGFyYW1ldGVyIHBhc3NlZCB0byB0aGUgYWN0aW9uIGlzIHVzZWQgdG8gdHJpZ2dlciByZWN1cnNpdmUgc2NoZWR1bGluZyBvZiB0aGUgYWN0aW9uLCBwYXNzaW5nIGluIHJlY3Vyc2l2ZSBpbnZvY2F0aW9uIHN0YXRlLlxyXG4gICAgICogQHJldHVybnMge0Rpc3Bvc2FibGV9IFRoZSBkaXNwb3NhYmxlIG9iamVjdCB1c2VkIHRvIGNhbmNlbCB0aGUgc2NoZWR1bGVkIGFjdGlvbiAoYmVzdCBlZmZvcnQpLlxyXG4gICAgICovXHJcbiAgICBzY2hlZHVsZXJQcm90by5zY2hlZHVsZVJlY3Vyc2l2ZVdpdGhTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgYWN0aW9uKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNjaGVkdWxlV2l0aFN0YXRlKHsgZmlyc3Q6IHN0YXRlLCBzZWNvbmQ6IGFjdGlvbiB9LCBpbnZva2VSZWNJbW1lZGlhdGUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNjaGVkdWxlcyBhbiBhY3Rpb24gdG8gYmUgZXhlY3V0ZWQgcmVjdXJzaXZlbHkgYWZ0ZXIgYSBzcGVjaWZpZWQgcmVsYXRpdmUgZHVlIHRpbWUuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY3Rpb24gQWN0aW9uIHRvIGV4ZWN1dGUgcmVjdXJzaXZlbHkuIFRoZSBwYXJhbWV0ZXIgcGFzc2VkIHRvIHRoZSBhY3Rpb24gaXMgdXNlZCB0byB0cmlnZ2VyIHJlY3Vyc2l2ZSBzY2hlZHVsaW5nIG9mIHRoZSBhY3Rpb24gYXQgdGhlIHNwZWNpZmllZCByZWxhdGl2ZSB0aW1lLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ZHVlVGltZSBSZWxhdGl2ZSB0aW1lIGFmdGVyIHdoaWNoIHRvIGV4ZWN1dGUgdGhlIGFjdGlvbiBmb3IgdGhlIGZpcnN0IHRpbWUuXHJcbiAgICAgKiBAcmV0dXJucyB7RGlzcG9zYWJsZX0gVGhlIGRpc3Bvc2FibGUgb2JqZWN0IHVzZWQgdG8gY2FuY2VsIHRoZSBzY2hlZHVsZWQgYWN0aW9uIChiZXN0IGVmZm9ydCkuXHJcbiAgICAgKi9cclxuICAgIHNjaGVkdWxlclByb3RvLnNjaGVkdWxlUmVjdXJzaXZlV2l0aFJlbGF0aXZlID0gZnVuY3Rpb24gKGR1ZVRpbWUsIGFjdGlvbikge1xyXG4gICAgICByZXR1cm4gdGhpcy5zY2hlZHVsZVJlY3Vyc2l2ZVdpdGhSZWxhdGl2ZUFuZFN0YXRlKGFjdGlvbiwgZHVlVGltZSwgc2NoZWR1bGVJbm5lclJlY3Vyc2l2ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2NoZWR1bGVzIGFuIGFjdGlvbiB0byBiZSBleGVjdXRlZCByZWN1cnNpdmVseSBhZnRlciBhIHNwZWNpZmllZCByZWxhdGl2ZSBkdWUgdGltZS5cclxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IHN0YXRlIFN0YXRlIHBhc3NlZCB0byB0aGUgYWN0aW9uIHRvIGJlIGV4ZWN1dGVkLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYWN0aW9uIEFjdGlvbiB0byBleGVjdXRlIHJlY3Vyc2l2ZWx5LiBUaGUgbGFzdCBwYXJhbWV0ZXIgcGFzc2VkIHRvIHRoZSBhY3Rpb24gaXMgdXNlZCB0byB0cmlnZ2VyIHJlY3Vyc2l2ZSBzY2hlZHVsaW5nIG9mIHRoZSBhY3Rpb24sIHBhc3NpbmcgaW4gdGhlIHJlY3Vyc2l2ZSBkdWUgdGltZSBhbmQgaW52b2NhdGlvbiBzdGF0ZS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfWR1ZVRpbWUgUmVsYXRpdmUgdGltZSBhZnRlciB3aGljaCB0byBleGVjdXRlIHRoZSBhY3Rpb24gZm9yIHRoZSBmaXJzdCB0aW1lLlxyXG4gICAgICogQHJldHVybnMge0Rpc3Bvc2FibGV9IFRoZSBkaXNwb3NhYmxlIG9iamVjdCB1c2VkIHRvIGNhbmNlbCB0aGUgc2NoZWR1bGVkIGFjdGlvbiAoYmVzdCBlZmZvcnQpLlxyXG4gICAgICovXHJcbiAgICBzY2hlZHVsZXJQcm90by5zY2hlZHVsZVJlY3Vyc2l2ZVdpdGhSZWxhdGl2ZUFuZFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlLCBkdWVUaW1lLCBhY3Rpb24pIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX3NjaGVkdWxlUmVsYXRpdmUoeyBmaXJzdDogc3RhdGUsIHNlY29uZDogYWN0aW9uIH0sIGR1ZVRpbWUsIGZ1bmN0aW9uIChzLCBwKSB7XHJcbiAgICAgICAgcmV0dXJuIGludm9rZVJlY0RhdGUocywgcCwgJ3NjaGVkdWxlV2l0aFJlbGF0aXZlQW5kU3RhdGUnKTtcclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2NoZWR1bGVzIGFuIGFjdGlvbiB0byBiZSBleGVjdXRlZCByZWN1cnNpdmVseSBhdCBhIHNwZWNpZmllZCBhYnNvbHV0ZSBkdWUgdGltZS5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFjdGlvbiBBY3Rpb24gdG8gZXhlY3V0ZSByZWN1cnNpdmVseS4gVGhlIHBhcmFtZXRlciBwYXNzZWQgdG8gdGhlIGFjdGlvbiBpcyB1c2VkIHRvIHRyaWdnZXIgcmVjdXJzaXZlIHNjaGVkdWxpbmcgb2YgdGhlIGFjdGlvbiBhdCB0aGUgc3BlY2lmaWVkIGFic29sdXRlIHRpbWUuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn1kdWVUaW1lIEFic29sdXRlIHRpbWUgYXQgd2hpY2ggdG8gZXhlY3V0ZSB0aGUgYWN0aW9uIGZvciB0aGUgZmlyc3QgdGltZS5cclxuICAgICAqIEByZXR1cm5zIHtEaXNwb3NhYmxlfSBUaGUgZGlzcG9zYWJsZSBvYmplY3QgdXNlZCB0byBjYW5jZWwgdGhlIHNjaGVkdWxlZCBhY3Rpb24gKGJlc3QgZWZmb3J0KS5cclxuICAgICAqL1xyXG4gICAgc2NoZWR1bGVyUHJvdG8uc2NoZWR1bGVSZWN1cnNpdmVXaXRoQWJzb2x1dGUgPSBmdW5jdGlvbiAoZHVlVGltZSwgYWN0aW9uKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNjaGVkdWxlUmVjdXJzaXZlV2l0aEFic29sdXRlQW5kU3RhdGUoYWN0aW9uLCBkdWVUaW1lLCBzY2hlZHVsZUlubmVyUmVjdXJzaXZlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTY2hlZHVsZXMgYW4gYWN0aW9uIHRvIGJlIGV4ZWN1dGVkIHJlY3Vyc2l2ZWx5IGF0IGEgc3BlY2lmaWVkIGFic29sdXRlIGR1ZSB0aW1lLlxyXG4gICAgICogQHBhcmFtIHtNaXhlZH0gc3RhdGUgU3RhdGUgcGFzc2VkIHRvIHRoZSBhY3Rpb24gdG8gYmUgZXhlY3V0ZWQuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY3Rpb24gQWN0aW9uIHRvIGV4ZWN1dGUgcmVjdXJzaXZlbHkuIFRoZSBsYXN0IHBhcmFtZXRlciBwYXNzZWQgdG8gdGhlIGFjdGlvbiBpcyB1c2VkIHRvIHRyaWdnZXIgcmVjdXJzaXZlIHNjaGVkdWxpbmcgb2YgdGhlIGFjdGlvbiwgcGFzc2luZyBpbiB0aGUgcmVjdXJzaXZlIGR1ZSB0aW1lIGFuZCBpbnZvY2F0aW9uIHN0YXRlLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ZHVlVGltZSBBYnNvbHV0ZSB0aW1lIGF0IHdoaWNoIHRvIGV4ZWN1dGUgdGhlIGFjdGlvbiBmb3IgdGhlIGZpcnN0IHRpbWUuXHJcbiAgICAgKiBAcmV0dXJucyB7RGlzcG9zYWJsZX0gVGhlIGRpc3Bvc2FibGUgb2JqZWN0IHVzZWQgdG8gY2FuY2VsIHRoZSBzY2hlZHVsZWQgYWN0aW9uIChiZXN0IGVmZm9ydCkuXHJcbiAgICAgKi9cclxuICAgIHNjaGVkdWxlclByb3RvLnNjaGVkdWxlUmVjdXJzaXZlV2l0aEFic29sdXRlQW5kU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIGR1ZVRpbWUsIGFjdGlvbikge1xyXG4gICAgICByZXR1cm4gdGhpcy5fc2NoZWR1bGVBYnNvbHV0ZSh7IGZpcnN0OiBzdGF0ZSwgc2Vjb25kOiBhY3Rpb24gfSwgZHVlVGltZSwgZnVuY3Rpb24gKHMsIHApIHtcclxuICAgICAgICByZXR1cm4gaW52b2tlUmVjRGF0ZShzLCBwLCAnc2NoZWR1bGVXaXRoQWJzb2x1dGVBbmRTdGF0ZScpO1xyXG4gICAgICB9KTtcclxuICAgIH07XHJcbiAgfShTY2hlZHVsZXIucHJvdG90eXBlKSk7XHJcblxyXG4gIChmdW5jdGlvbiAoc2NoZWR1bGVyUHJvdG8pIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNjaGVkdWxlcyBhIHBlcmlvZGljIHBpZWNlIG9mIHdvcmsgYnkgZHluYW1pY2FsbHkgZGlzY292ZXJpbmcgdGhlIHNjaGVkdWxlcidzIGNhcGFiaWxpdGllcy4gVGhlIHBlcmlvZGljIHRhc2sgd2lsbCBiZSBzY2hlZHVsZWQgdXNpbmcgd2luZG93LnNldEludGVydmFsIGZvciB0aGUgYmFzZSBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwZXJpb2QgUGVyaW9kIGZvciBydW5uaW5nIHRoZSB3b3JrIHBlcmlvZGljYWxseS5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFjdGlvbiBBY3Rpb24gdG8gYmUgZXhlY3V0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7RGlzcG9zYWJsZX0gVGhlIGRpc3Bvc2FibGUgb2JqZWN0IHVzZWQgdG8gY2FuY2VsIHRoZSBzY2hlZHVsZWQgcmVjdXJyaW5nIGFjdGlvbiAoYmVzdCBlZmZvcnQpLlxyXG4gICAgICovXHJcbiAgICBTY2hlZHVsZXIucHJvdG90eXBlLnNjaGVkdWxlUGVyaW9kaWMgPSBmdW5jdGlvbiAocGVyaW9kLCBhY3Rpb24pIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc2NoZWR1bGVQZXJpb2RpY1dpdGhTdGF0ZShudWxsLCBwZXJpb2QsIGFjdGlvbik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2NoZWR1bGVzIGEgcGVyaW9kaWMgcGllY2Ugb2Ygd29yayBieSBkeW5hbWljYWxseSBkaXNjb3ZlcmluZyB0aGUgc2NoZWR1bGVyJ3MgY2FwYWJpbGl0aWVzLiBUaGUgcGVyaW9kaWMgdGFzayB3aWxsIGJlIHNjaGVkdWxlZCB1c2luZyB3aW5kb3cuc2V0SW50ZXJ2YWwgZm9yIHRoZSBiYXNlIGltcGxlbWVudGF0aW9uLlxyXG4gICAgICogQHBhcmFtIHtNaXhlZH0gc3RhdGUgSW5pdGlhbCBzdGF0ZSBwYXNzZWQgdG8gdGhlIGFjdGlvbiB1cG9uIHRoZSBmaXJzdCBpdGVyYXRpb24uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcGVyaW9kIFBlcmlvZCBmb3IgcnVubmluZyB0aGUgd29yayBwZXJpb2RpY2FsbHkuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY3Rpb24gQWN0aW9uIHRvIGJlIGV4ZWN1dGVkLCBwb3RlbnRpYWxseSB1cGRhdGluZyB0aGUgc3RhdGUuXHJcbiAgICAgKiBAcmV0dXJucyB7RGlzcG9zYWJsZX0gVGhlIGRpc3Bvc2FibGUgb2JqZWN0IHVzZWQgdG8gY2FuY2VsIHRoZSBzY2hlZHVsZWQgcmVjdXJyaW5nIGFjdGlvbiAoYmVzdCBlZmZvcnQpLlxyXG4gICAgICovXHJcbiAgICBTY2hlZHVsZXIucHJvdG90eXBlLnNjaGVkdWxlUGVyaW9kaWNXaXRoU3RhdGUgPSBmdW5jdGlvbihzdGF0ZSwgcGVyaW9kLCBhY3Rpb24pIHtcclxuICAgICAgaWYgKHR5cGVvZiByb290LnNldEludGVydmFsID09PSAndW5kZWZpbmVkJykgeyB0aHJvdyBuZXcgRXJyb3IoJ1BlcmlvZGljIHNjaGVkdWxpbmcgbm90IHN1cHBvcnRlZC4nKTsgfVxyXG4gICAgICB2YXIgcyA9IHN0YXRlO1xyXG5cclxuICAgICAgdmFyIGlkID0gcm9vdC5zZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcyA9IGFjdGlvbihzKTtcclxuICAgICAgfSwgcGVyaW9kKTtcclxuXHJcbiAgICAgIHJldHVybiBkaXNwb3NhYmxlQ3JlYXRlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByb290LmNsZWFySW50ZXJ2YWwoaWQpO1xyXG4gICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gIH0oU2NoZWR1bGVyLnByb3RvdHlwZSkpO1xyXG5cclxuICAoZnVuY3Rpb24gKHNjaGVkdWxlclByb3RvKSB7XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBzY2hlZHVsZXIgdGhhdCB3cmFwcyB0aGUgb3JpZ2luYWwgc2NoZWR1bGVyLCBhZGRpbmcgZXhjZXB0aW9uIGhhbmRsaW5nIGZvciBzY2hlZHVsZWQgYWN0aW9ucy5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgSGFuZGxlciB0aGF0J3MgcnVuIGlmIGFuIGV4Y2VwdGlvbiBpcyBjYXVnaHQuIFRoZSBleGNlcHRpb24gd2lsbCBiZSByZXRocm93biBpZiB0aGUgaGFuZGxlciByZXR1cm5zIGZhbHNlLlxyXG4gICAgICogQHJldHVybnMge1NjaGVkdWxlcn0gV3JhcHBlciBhcm91bmQgdGhlIG9yaWdpbmFsIHNjaGVkdWxlciwgZW5mb3JjaW5nIGV4Y2VwdGlvbiBoYW5kbGluZy5cclxuICAgICAqL1xyXG4gICAgc2NoZWR1bGVyUHJvdG8uY2F0Y2hFcnJvciA9IHNjaGVkdWxlclByb3RvWydjYXRjaCddID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgICAgcmV0dXJuIG5ldyBDYXRjaFNjaGVkdWxlcih0aGlzLCBoYW5kbGVyKTtcclxuICAgIH07XHJcbiAgfShTY2hlZHVsZXIucHJvdG90eXBlKSk7XHJcblxyXG4gIHZhciBTY2hlZHVsZVBlcmlvZGljUmVjdXJzaXZlID0gUnguaW50ZXJuYWxzLlNjaGVkdWxlUGVyaW9kaWNSZWN1cnNpdmUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIHRpY2soY29tbWFuZCwgcmVjdXJzZSkge1xuICAgICAgcmVjdXJzZSgwLCB0aGlzLl9wZXJpb2QpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSB0aGlzLl9hY3Rpb24odGhpcy5fc3RhdGUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLl9jYW5jZWwuZGlzcG9zZSgpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIFNjaGVkdWxlUGVyaW9kaWNSZWN1cnNpdmUoc2NoZWR1bGVyLCBzdGF0ZSwgcGVyaW9kLCBhY3Rpb24pIHtcbiAgICAgIHRoaXMuX3NjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgICB0aGlzLl9wZXJpb2QgPSBwZXJpb2Q7XG4gICAgICB0aGlzLl9hY3Rpb24gPSBhY3Rpb247XG4gICAgfVxuXG4gICAgU2NoZWR1bGVQZXJpb2RpY1JlY3Vyc2l2ZS5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgdGhpcy5fY2FuY2VsID0gZDtcbiAgICAgIGQuc2V0RGlzcG9zYWJsZSh0aGlzLl9zY2hlZHVsZXIuc2NoZWR1bGVSZWN1cnNpdmVXaXRoUmVsYXRpdmVBbmRTdGF0ZSgwLCB0aGlzLl9wZXJpb2QsIHRpY2suYmluZCh0aGlzKSkpO1xuXG4gICAgICByZXR1cm4gZDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNjaGVkdWxlUGVyaW9kaWNSZWN1cnNpdmU7XG4gIH0oKSk7XG5cclxuICAvKipcclxuICAgKiBHZXRzIGEgc2NoZWR1bGVyIHRoYXQgc2NoZWR1bGVzIHdvcmsgaW1tZWRpYXRlbHkgb24gdGhlIGN1cnJlbnQgdGhyZWFkLlxyXG4gICAqL1xyXG4gIHZhciBpbW1lZGlhdGVTY2hlZHVsZXIgPSBTY2hlZHVsZXIuaW1tZWRpYXRlID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICBmdW5jdGlvbiBzY2hlZHVsZU5vdyhzdGF0ZSwgYWN0aW9uKSB7IHJldHVybiBhY3Rpb24odGhpcywgc3RhdGUpOyB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVSZWxhdGl2ZShzdGF0ZSwgZHVlVGltZSwgYWN0aW9uKSB7XHJcbiAgICAgIHZhciBkdCA9IG5vcm1hbGl6ZVRpbWUoZHQpO1xyXG4gICAgICB3aGlsZSAoZHQgLSB0aGlzLm5vdygpID4gMCkgeyB9XHJcbiAgICAgIHJldHVybiBhY3Rpb24odGhpcywgc3RhdGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlQWJzb2x1dGUoc3RhdGUsIGR1ZVRpbWUsIGFjdGlvbikge1xyXG4gICAgICByZXR1cm4gdGhpcy5zY2hlZHVsZVdpdGhSZWxhdGl2ZUFuZFN0YXRlKHN0YXRlLCBkdWVUaW1lIC0gdGhpcy5ub3coKSwgYWN0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IFNjaGVkdWxlcihkZWZhdWx0Tm93LCBzY2hlZHVsZU5vdywgc2NoZWR1bGVSZWxhdGl2ZSwgc2NoZWR1bGVBYnNvbHV0ZSk7XHJcbiAgfSgpKTtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyBhIHNjaGVkdWxlciB0aGF0IHNjaGVkdWxlcyB3b3JrIGFzIHNvb24gYXMgcG9zc2libGUgb24gdGhlIGN1cnJlbnQgdGhyZWFkLlxyXG4gICAqL1xyXG4gIHZhciBjdXJyZW50VGhyZWFkU2NoZWR1bGVyID0gU2NoZWR1bGVyLmN1cnJlbnRUaHJlYWQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHF1ZXVlO1xyXG5cclxuICAgIGZ1bmN0aW9uIHJ1blRyYW1wb2xpbmUgKHEpIHtcclxuICAgICAgdmFyIGl0ZW07XHJcbiAgICAgIHdoaWxlIChxLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBpdGVtID0gcS5kZXF1ZXVlKCk7XHJcbiAgICAgICAgaWYgKCFpdGVtLmlzQ2FuY2VsbGVkKCkpIHtcclxuICAgICAgICAgIC8vIE5vdGUsIGRvIG5vdCBzY2hlZHVsZSBibG9ja2luZyB3b3JrIVxyXG4gICAgICAgICAgd2hpbGUgKGl0ZW0uZHVlVGltZSAtIFNjaGVkdWxlci5ub3coKSA+IDApIHtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICghaXRlbS5pc0NhbmNlbGxlZCgpKSB7XHJcbiAgICAgICAgICAgIGl0ZW0uaW52b2tlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVOb3coc3RhdGUsIGFjdGlvbikge1xyXG4gICAgICByZXR1cm4gdGhpcy5zY2hlZHVsZVdpdGhSZWxhdGl2ZUFuZFN0YXRlKHN0YXRlLCAwLCBhY3Rpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlUmVsYXRpdmUoc3RhdGUsIGR1ZVRpbWUsIGFjdGlvbikge1xyXG4gICAgICB2YXIgZHQgPSB0aGlzLm5vdygpICsgU2NoZWR1bGVyLm5vcm1hbGl6ZShkdWVUaW1lKSxcclxuICAgICAgICAgIHNpID0gbmV3IFNjaGVkdWxlZEl0ZW0odGhpcywgc3RhdGUsIGFjdGlvbiwgZHQpO1xyXG5cclxuICAgICAgaWYgKCFxdWV1ZSkge1xyXG4gICAgICAgIHF1ZXVlID0gbmV3IFByaW9yaXR5UXVldWUoNCk7XHJcbiAgICAgICAgcXVldWUuZW5xdWV1ZShzaSk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHJ1blRyYW1wb2xpbmUocXVldWUpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgIHF1ZXVlID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcXVldWUuZW5xdWV1ZShzaSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHNpLmRpc3Bvc2FibGU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVBYnNvbHV0ZShzdGF0ZSwgZHVlVGltZSwgYWN0aW9uKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNjaGVkdWxlV2l0aFJlbGF0aXZlQW5kU3RhdGUoc3RhdGUsIGR1ZVRpbWUgLSB0aGlzLm5vdygpLCBhY3Rpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjdXJyZW50U2NoZWR1bGVyID0gbmV3IFNjaGVkdWxlcihkZWZhdWx0Tm93LCBzY2hlZHVsZU5vdywgc2NoZWR1bGVSZWxhdGl2ZSwgc2NoZWR1bGVBYnNvbHV0ZSk7XHJcblxyXG4gICAgY3VycmVudFNjaGVkdWxlci5zY2hlZHVsZVJlcXVpcmVkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gIXF1ZXVlOyB9O1xyXG4gICAgY3VycmVudFNjaGVkdWxlci5lbnN1cmVUcmFtcG9saW5lID0gZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICBpZiAoIXF1ZXVlKSB7IHRoaXMuc2NoZWR1bGUoYWN0aW9uKTsgfSBlbHNlIHsgYWN0aW9uKCk7IH1cclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIGN1cnJlbnRTY2hlZHVsZXI7XHJcbiAgfSgpKTtcclxuXHJcbiAgdmFyIHNjaGVkdWxlTWV0aG9kLCBjbGVhck1ldGhvZCA9IG5vb3A7XHJcbiAgdmFyIGxvY2FsVGltZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGxvY2FsU2V0VGltZW91dCwgbG9jYWxDbGVhclRpbWVvdXQgPSBub29wO1xyXG4gICAgaWYgKCdXU2NyaXB0JyBpbiB0aGlzKSB7XHJcbiAgICAgIGxvY2FsU2V0VGltZW91dCA9IGZ1bmN0aW9uIChmbiwgdGltZSkge1xyXG4gICAgICAgIFdTY3JpcHQuU2xlZXAodGltZSk7XHJcbiAgICAgICAgZm4oKTtcclxuICAgICAgfTtcclxuICAgIH0gZWxzZSBpZiAoISFyb290LnNldFRpbWVvdXQpIHtcclxuICAgICAgbG9jYWxTZXRUaW1lb3V0ID0gcm9vdC5zZXRUaW1lb3V0O1xyXG4gICAgICBsb2NhbENsZWFyVGltZW91dCA9IHJvb3QuY2xlYXJUaW1lb3V0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjb25jdXJyZW5jeSBkZXRlY3RlZCEnKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzZXRUaW1lb3V0OiBsb2NhbFNldFRpbWVvdXQsXHJcbiAgICAgIGNsZWFyVGltZW91dDogbG9jYWxDbGVhclRpbWVvdXRcclxuICAgIH07XHJcbiAgfSgpKTtcclxuICB2YXIgbG9jYWxTZXRUaW1lb3V0ID0gbG9jYWxUaW1lci5zZXRUaW1lb3V0LFxyXG4gICAgbG9jYWxDbGVhclRpbWVvdXQgPSBsb2NhbFRpbWVyLmNsZWFyVGltZW91dDtcclxuXHJcbiAgKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgcmVOYXRpdmUgPSBSZWdFeHAoJ14nICtcclxuICAgICAgU3RyaW5nKHRvU3RyaW5nKVxyXG4gICAgICAgIC5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpXHJcbiAgICAgICAgLnJlcGxhY2UoL3RvU3RyaW5nfCBmb3IgW15cXF1dKy9nLCAnLio/JykgKyAnJCdcclxuICAgICk7XHJcblxyXG4gICAgdmFyIHNldEltbWVkaWF0ZSA9IHR5cGVvZiAoc2V0SW1tZWRpYXRlID0gZnJlZUdsb2JhbCAmJiBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwuc2V0SW1tZWRpYXRlKSA9PSAnZnVuY3Rpb24nICYmXHJcbiAgICAgICFyZU5hdGl2ZS50ZXN0KHNldEltbWVkaWF0ZSkgJiYgc2V0SW1tZWRpYXRlLFxyXG4gICAgICBjbGVhckltbWVkaWF0ZSA9IHR5cGVvZiAoY2xlYXJJbW1lZGlhdGUgPSBmcmVlR2xvYmFsICYmIG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5jbGVhckltbWVkaWF0ZSkgPT0gJ2Z1bmN0aW9uJyAmJlxyXG4gICAgICAhcmVOYXRpdmUudGVzdChjbGVhckltbWVkaWF0ZSkgJiYgY2xlYXJJbW1lZGlhdGU7XHJcblxyXG4gICAgZnVuY3Rpb24gcG9zdE1lc3NhZ2VTdXBwb3J0ZWQgKCkge1xyXG4gICAgICAvLyBFbnN1cmUgbm90IGluIGEgd29ya2VyXHJcbiAgICAgIGlmICghcm9vdC5wb3N0TWVzc2FnZSB8fCByb290LmltcG9ydFNjcmlwdHMpIHsgcmV0dXJuIGZhbHNlOyB9XHJcbiAgICAgIHZhciBpc0FzeW5jID0gZmFsc2UsXHJcbiAgICAgICAgICBvbGRIYW5kbGVyID0gcm9vdC5vbm1lc3NhZ2U7XHJcbiAgICAgIC8vIFRlc3QgZm9yIGFzeW5jXHJcbiAgICAgIHJvb3Qub25tZXNzYWdlID0gZnVuY3Rpb24gKCkgeyBpc0FzeW5jID0gdHJ1ZTsgfTtcclxuICAgICAgcm9vdC5wb3N0TWVzc2FnZSgnJywnKicpO1xyXG4gICAgICByb290Lm9ubWVzc2FnZSA9IG9sZEhhbmRsZXI7XHJcblxyXG4gICAgICByZXR1cm4gaXNBc3luYztcclxuICAgIH1cclxuXHJcbiAgICAvLyBVc2UgaW4gb3JkZXIsIG5leHRUaWNrLCBzZXRJbW1lZGlhdGUsIHBvc3RNZXNzYWdlLCBNZXNzYWdlQ2hhbm5lbCwgc2NyaXB0IHJlYWR5c3RhdGVjaGFuZ2VkLCBzZXRUaW1lb3V0XHJcbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHt9LnRvU3RyaW5nLmNhbGwocHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJykge1xyXG4gICAgICBzY2hlZHVsZU1ldGhvZCA9IHByb2Nlc3MubmV4dFRpY2s7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgc2NoZWR1bGVNZXRob2QgPSBzZXRJbW1lZGlhdGU7XHJcbiAgICAgIGNsZWFyTWV0aG9kID0gY2xlYXJJbW1lZGlhdGU7XHJcbiAgICB9IGVsc2UgaWYgKHBvc3RNZXNzYWdlU3VwcG9ydGVkKCkpIHtcclxuICAgICAgdmFyIE1TR19QUkVGSVggPSAnbXMucnguc2NoZWR1bGUnICsgTWF0aC5yYW5kb20oKSxcclxuICAgICAgICB0YXNrcyA9IHt9LFxyXG4gICAgICAgIHRhc2tJZCA9IDA7XHJcblxyXG4gICAgICBmdW5jdGlvbiBvbkdsb2JhbFBvc3RNZXNzYWdlKGV2ZW50KSB7XHJcbiAgICAgICAgLy8gT25seSBpZiB3ZSdyZSBhIG1hdGNoIHRvIGF2b2lkIGFueSBvdGhlciBnbG9iYWwgZXZlbnRzXHJcbiAgICAgICAgaWYgKHR5cGVvZiBldmVudC5kYXRhID09PSAnc3RyaW5nJyAmJiBldmVudC5kYXRhLnN1YnN0cmluZygwLCBNU0dfUFJFRklYLmxlbmd0aCkgPT09IE1TR19QUkVGSVgpIHtcclxuICAgICAgICAgIHZhciBoYW5kbGVJZCA9IGV2ZW50LmRhdGEuc3Vic3RyaW5nKE1TR19QUkVGSVgubGVuZ3RoKSxcclxuICAgICAgICAgICAgYWN0aW9uID0gdGFza3NbaGFuZGxlSWRdO1xyXG4gICAgICAgICAgYWN0aW9uKCk7XHJcbiAgICAgICAgICBkZWxldGUgdGFza3NbaGFuZGxlSWRdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHJvb3QuYWRkRXZlbnRMaXN0ZW5lcikge1xyXG4gICAgICAgIHJvb3QuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG9uR2xvYmFsUG9zdE1lc3NhZ2UsIGZhbHNlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByb290LmF0dGFjaEV2ZW50KCdvbm1lc3NhZ2UnLCBvbkdsb2JhbFBvc3RNZXNzYWdlLCBmYWxzZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNjaGVkdWxlTWV0aG9kID0gZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgIHZhciBjdXJyZW50SWQgPSB0YXNrSWQrKztcclxuICAgICAgICB0YXNrc1tjdXJyZW50SWRdID0gYWN0aW9uO1xyXG4gICAgICAgIHJvb3QucG9zdE1lc3NhZ2UoTVNHX1BSRUZJWCArIGN1cnJlbnRJZCwgJyonKTtcclxuICAgICAgfTtcclxuICAgIH0gZWxzZSBpZiAoISFyb290Lk1lc3NhZ2VDaGFubmVsKSB7XHJcbiAgICAgIHZhciBjaGFubmVsID0gbmV3IHJvb3QuTWVzc2FnZUNoYW5uZWwoKSxcclxuICAgICAgICBjaGFubmVsVGFza3MgPSB7fSxcclxuICAgICAgICBjaGFubmVsVGFza0lkID0gMDtcclxuXHJcbiAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgdmFyIGlkID0gZXZlbnQuZGF0YSxcclxuICAgICAgICAgIGFjdGlvbiA9IGNoYW5uZWxUYXNrc1tpZF07XHJcbiAgICAgICAgYWN0aW9uKCk7XHJcbiAgICAgICAgZGVsZXRlIGNoYW5uZWxUYXNrc1tpZF07XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBzY2hlZHVsZU1ldGhvZCA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICB2YXIgaWQgPSBjaGFubmVsVGFza0lkKys7XHJcbiAgICAgICAgY2hhbm5lbFRhc2tzW2lkXSA9IGFjdGlvbjtcclxuICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGlkKTtcclxuICAgICAgfTtcclxuICAgIH0gZWxzZSBpZiAoJ2RvY3VtZW50JyBpbiByb290ICYmICdvbnJlYWR5c3RhdGVjaGFuZ2UnIGluIHJvb3QuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpIHtcclxuXHJcbiAgICAgIHNjaGVkdWxlTWV0aG9kID0gZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgIHZhciBzY3JpcHRFbGVtZW50ID0gcm9vdC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcclxuICAgICAgICBzY3JpcHRFbGVtZW50Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGFjdGlvbigpO1xyXG4gICAgICAgICAgc2NyaXB0RWxlbWVudC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xyXG4gICAgICAgICAgc2NyaXB0RWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdEVsZW1lbnQpO1xyXG4gICAgICAgICAgc2NyaXB0RWxlbWVudCA9IG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByb290LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChzY3JpcHRFbGVtZW50KTtcclxuICAgICAgfTtcclxuXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzY2hlZHVsZU1ldGhvZCA9IGZ1bmN0aW9uIChhY3Rpb24pIHsgcmV0dXJuIGxvY2FsU2V0VGltZW91dChhY3Rpb24sIDApOyB9O1xyXG4gICAgICBjbGVhck1ldGhvZCA9IGxvY2FsQ2xlYXJUaW1lb3V0O1xyXG4gICAgfVxyXG4gIH0oKSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgYSBzY2hlZHVsZXIgdGhhdCBzY2hlZHVsZXMgd29yayB2aWEgYSB0aW1lZCBjYWxsYmFjayBiYXNlZCB1cG9uIHBsYXRmb3JtLlxyXG4gICAqL1xyXG4gIHZhciB0aW1lb3V0U2NoZWR1bGVyID0gU2NoZWR1bGVyLnRpbWVvdXQgPSAoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlTm93KHN0YXRlLCBhY3Rpb24pIHtcclxuICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMsXHJcbiAgICAgICAgZGlzcG9zYWJsZSA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xyXG4gICAgICB2YXIgaWQgPSBzY2hlZHVsZU1ldGhvZChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCFkaXNwb3NhYmxlLmlzRGlzcG9zZWQpIHtcclxuICAgICAgICAgIGRpc3Bvc2FibGUuc2V0RGlzcG9zYWJsZShhY3Rpb24oc2NoZWR1bGVyLCBzdGF0ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZShkaXNwb3NhYmxlLCBkaXNwb3NhYmxlQ3JlYXRlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjbGVhck1ldGhvZChpZCk7XHJcbiAgICAgIH0pKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzY2hlZHVsZVJlbGF0aXZlKHN0YXRlLCBkdWVUaW1lLCBhY3Rpb24pIHtcclxuICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMsXHJcbiAgICAgICAgZHQgPSBTY2hlZHVsZXIubm9ybWFsaXplKGR1ZVRpbWUpO1xyXG4gICAgICBpZiAoZHQgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlV2l0aFN0YXRlKHN0YXRlLCBhY3Rpb24pO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBkaXNwb3NhYmxlID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XHJcbiAgICAgIHZhciBpZCA9IGxvY2FsU2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCFkaXNwb3NhYmxlLmlzRGlzcG9zZWQpIHtcclxuICAgICAgICAgIGRpc3Bvc2FibGUuc2V0RGlzcG9zYWJsZShhY3Rpb24oc2NoZWR1bGVyLCBzdGF0ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSwgZHQpO1xyXG4gICAgICByZXR1cm4gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoZGlzcG9zYWJsZSwgZGlzcG9zYWJsZUNyZWF0ZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgbG9jYWxDbGVhclRpbWVvdXQoaWQpO1xyXG4gICAgICB9KSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVBYnNvbHV0ZShzdGF0ZSwgZHVlVGltZSwgYWN0aW9uKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNjaGVkdWxlV2l0aFJlbGF0aXZlQW5kU3RhdGUoc3RhdGUsIGR1ZVRpbWUgLSB0aGlzLm5vdygpLCBhY3Rpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXcgU2NoZWR1bGVyKGRlZmF1bHROb3csIHNjaGVkdWxlTm93LCBzY2hlZHVsZVJlbGF0aXZlLCBzY2hlZHVsZUFic29sdXRlKTtcclxuICB9KSgpO1xyXG5cclxuICB2YXIgQ2F0Y2hTY2hlZHVsZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVOb3coc3RhdGUsIGFjdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3NjaGVkdWxlci5zY2hlZHVsZVdpdGhTdGF0ZShzdGF0ZSwgdGhpcy5fd3JhcChhY3Rpb24pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2hlZHVsZVJlbGF0aXZlKHN0YXRlLCBkdWVUaW1lLCBhY3Rpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLl9zY2hlZHVsZXIuc2NoZWR1bGVXaXRoUmVsYXRpdmVBbmRTdGF0ZShzdGF0ZSwgZHVlVGltZSwgdGhpcy5fd3JhcChhY3Rpb24pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2hlZHVsZUFic29sdXRlKHN0YXRlLCBkdWVUaW1lLCBhY3Rpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLl9zY2hlZHVsZXIuc2NoZWR1bGVXaXRoQWJzb2x1dGVBbmRTdGF0ZShzdGF0ZSwgZHVlVGltZSwgdGhpcy5fd3JhcChhY3Rpb24pKTtcbiAgICB9XG5cbiAgICBpbmhlcml0cyhDYXRjaFNjaGVkdWxlciwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIENhdGNoU2NoZWR1bGVyKHNjaGVkdWxlciwgaGFuZGxlcikge1xuICAgICAgdGhpcy5fc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgdGhpcy5faGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICB0aGlzLl9yZWN1cnNpdmVPcmlnaW5hbCA9IG51bGw7XG4gICAgICB0aGlzLl9yZWN1cnNpdmVXcmFwcGVyID0gbnVsbDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMsIHRoaXMuX3NjaGVkdWxlci5ub3cuYmluZCh0aGlzLl9zY2hlZHVsZXIpLCBzY2hlZHVsZU5vdywgc2NoZWR1bGVSZWxhdGl2ZSwgc2NoZWR1bGVBYnNvbHV0ZSk7XG4gICAgfVxuXG4gICAgQ2F0Y2hTY2hlZHVsZXIucHJvdG90eXBlLl9jbG9uZSA9IGZ1bmN0aW9uIChzY2hlZHVsZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDYXRjaFNjaGVkdWxlcihzY2hlZHVsZXIsIHRoaXMuX2hhbmRsZXIpO1xuICAgIH07XG5cbiAgICBDYXRjaFNjaGVkdWxlci5wcm90b3R5cGUuX3dyYXAgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcztcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoc2VsZiwgc3RhdGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gYWN0aW9uKHBhcmVudC5fZ2V0UmVjdXJzaXZlV3JhcHBlcihzZWxmKSwgc3RhdGUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKCFwYXJlbnQuX2hhbmRsZXIoZSkpIHsgdGhyb3cgZTsgfVxuICAgICAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcblxuICAgIENhdGNoU2NoZWR1bGVyLnByb3RvdHlwZS5fZ2V0UmVjdXJzaXZlV3JhcHBlciA9IGZ1bmN0aW9uIChzY2hlZHVsZXIpIHtcbiAgICAgIGlmICh0aGlzLl9yZWN1cnNpdmVPcmlnaW5hbCAhPT0gc2NoZWR1bGVyKSB7XG4gICAgICAgIHRoaXMuX3JlY3Vyc2l2ZU9yaWdpbmFsID0gc2NoZWR1bGVyO1xuICAgICAgICB2YXIgd3JhcHBlciA9IHRoaXMuX2Nsb25lKHNjaGVkdWxlcik7XG4gICAgICAgIHdyYXBwZXIuX3JlY3Vyc2l2ZU9yaWdpbmFsID0gc2NoZWR1bGVyO1xuICAgICAgICB3cmFwcGVyLl9yZWN1cnNpdmVXcmFwcGVyID0gd3JhcHBlcjtcbiAgICAgICAgdGhpcy5fcmVjdXJzaXZlV3JhcHBlciA9IHdyYXBwZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fcmVjdXJzaXZlV3JhcHBlcjtcbiAgICB9O1xuXG4gICAgQ2F0Y2hTY2hlZHVsZXIucHJvdG90eXBlLnNjaGVkdWxlUGVyaW9kaWNXaXRoU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIHBlcmlvZCwgYWN0aW9uKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXMsIGZhaWxlZCA9IGZhbHNlLCBkID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG5cbiAgICAgIGQuc2V0RGlzcG9zYWJsZSh0aGlzLl9zY2hlZHVsZXIuc2NoZWR1bGVQZXJpb2RpY1dpdGhTdGF0ZShzdGF0ZSwgcGVyaW9kLCBmdW5jdGlvbiAoc3RhdGUxKSB7XG4gICAgICAgIGlmIChmYWlsZWQpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gYWN0aW9uKHN0YXRlMSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBmYWlsZWQgPSB0cnVlO1xuICAgICAgICAgIGlmICghc2VsZi5faGFuZGxlcihlKSkgeyB0aHJvdyBlOyB9XG4gICAgICAgICAgZC5kaXNwb3NlKCk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcblxuICAgICAgcmV0dXJuIGQ7XG4gICAgfTtcblxuICAgIHJldHVybiBDYXRjaFNjaGVkdWxlcjtcbiAgfShTY2hlZHVsZXIpKTtcblxyXG4gIC8qKlxyXG4gICAqICBSZXByZXNlbnRzIGEgbm90aWZpY2F0aW9uIHRvIGFuIG9ic2VydmVyLlxyXG4gICAqL1xyXG4gIHZhciBOb3RpZmljYXRpb24gPSBSeC5Ob3RpZmljYXRpb24gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTm90aWZpY2F0aW9uKGtpbmQsIGhhc1ZhbHVlKSB7XHJcbiAgICAgIHRoaXMuaGFzVmFsdWUgPSBoYXNWYWx1ZSA9PSBudWxsID8gZmFsc2UgOiBoYXNWYWx1ZTtcclxuICAgICAgdGhpcy5raW5kID0ga2luZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEludm9rZXMgdGhlIGRlbGVnYXRlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIG5vdGlmaWNhdGlvbiBvciB0aGUgb2JzZXJ2ZXIncyBtZXRob2QgY29ycmVzcG9uZGluZyB0byB0aGUgbm90aWZpY2F0aW9uIGFuZCByZXR1cm5zIHRoZSBwcm9kdWNlZCByZXN1bHQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlck9mIE5vdGlmaWNhdGlvblxyXG4gICAgICogQHBhcmFtIHtBbnl9IG9ic2VydmVyT3JPbk5leHQgRGVsZWdhdGUgdG8gaW52b2tlIGZvciBhbiBPbk5leHQgbm90aWZpY2F0aW9uIG9yIE9ic2VydmVyIHRvIGludm9rZSB0aGUgbm90aWZpY2F0aW9uIG9uLi5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uRXJyb3IgRGVsZWdhdGUgdG8gaW52b2tlIGZvciBhbiBPbkVycm9yIG5vdGlmaWNhdGlvbi5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uQ29tcGxldGVkIERlbGVnYXRlIHRvIGludm9rZSBmb3IgYW4gT25Db21wbGV0ZWQgbm90aWZpY2F0aW9uLlxyXG4gICAgICogQHJldHVybnMge0FueX0gUmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBvYnNlcnZhdGlvbi5cclxuICAgICAqL1xyXG4gICAgTm90aWZpY2F0aW9uLnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbiAob2JzZXJ2ZXJPck9uTmV4dCwgb25FcnJvciwgb25Db21wbGV0ZWQpIHtcclxuICAgICAgcmV0dXJuIG9ic2VydmVyT3JPbk5leHQgJiYgdHlwZW9mIG9ic2VydmVyT3JPbk5leHQgPT09ICdvYmplY3QnID9cclxuICAgICAgICB0aGlzLl9hY2NlcHRPYnNlcnZhYmxlKG9ic2VydmVyT3JPbk5leHQpIDpcclxuICAgICAgICB0aGlzLl9hY2NlcHQob2JzZXJ2ZXJPck9uTmV4dCwgb25FcnJvciwgb25Db21wbGV0ZWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIGEgc2luZ2xlIG5vdGlmaWNhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyT2YgTm90aWZpY2F0aW9uc1xyXG4gICAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIFNjaGVkdWxlciB0byBzZW5kIG91dCB0aGUgbm90aWZpY2F0aW9uIGNhbGxzIG9uLlxyXG4gICAgICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgc3VyZmFjZXMgdGhlIGJlaGF2aW9yIG9mIHRoZSBub3RpZmljYXRpb24gdXBvbiBzdWJzY3JpcHRpb24uXHJcbiAgICAgKi9cclxuICAgIE5vdGlmaWNhdGlvbi5wcm90b3R5cGUudG9PYnNlcnZhYmxlID0gZnVuY3Rpb24gKHNjaGVkdWxlcikge1xyXG4gICAgICB2YXIgbm90aWZpY2F0aW9uID0gdGhpcztcclxuICAgICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gaW1tZWRpYXRlU2NoZWR1bGVyKTtcclxuICAgICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgbm90aWZpY2F0aW9uLl9hY2NlcHRPYnNlcnZhYmxlKG9ic2VydmVyKTtcclxuICAgICAgICAgIG5vdGlmaWNhdGlvbi5raW5kID09PSAnTicgJiYgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBOb3RpZmljYXRpb247XHJcbiAgfSkoKTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIGFuIE9uTmV4dCBub3RpZmljYXRpb24gdG8gYW4gb2JzZXJ2ZXIuXHJcbiAgICogQHBhcmFtIHtBbnl9IHZhbHVlIFRoZSB2YWx1ZSBjb250YWluZWQgaW4gdGhlIG5vdGlmaWNhdGlvbi5cclxuICAgKiBAcmV0dXJucyB7Tm90aWZpY2F0aW9ufSBUaGUgT25OZXh0IG5vdGlmaWNhdGlvbiBjb250YWluaW5nIHRoZSB2YWx1ZS5cclxuICAgKi9cclxuICB2YXIgbm90aWZpY2F0aW9uQ3JlYXRlT25OZXh0ID0gTm90aWZpY2F0aW9uLmNyZWF0ZU9uTmV4dCA9IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICBmdW5jdGlvbiBfYWNjZXB0IChvbk5leHQpIHsgcmV0dXJuIG9uTmV4dCh0aGlzLnZhbHVlKTsgfVxyXG4gICAgICBmdW5jdGlvbiBfYWNjZXB0T2JzZXJ2YWJsZShvYnNlcnZlcikgeyByZXR1cm4gb2JzZXJ2ZXIub25OZXh0KHRoaXMudmFsdWUpOyB9XHJcbiAgICAgIGZ1bmN0aW9uIHRvU3RyaW5nICgpIHsgcmV0dXJuICdPbk5leHQoJyArIHRoaXMudmFsdWUgKyAnKSc7IH1cclxuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICB2YXIgbm90aWZpY2F0aW9uID0gbmV3IE5vdGlmaWNhdGlvbignTicsIHRydWUpO1xyXG4gICAgICAgIG5vdGlmaWNhdGlvbi52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIG5vdGlmaWNhdGlvbi5fYWNjZXB0ID0gX2FjY2VwdDtcclxuICAgICAgICBub3RpZmljYXRpb24uX2FjY2VwdE9ic2VydmFibGUgPSBfYWNjZXB0T2JzZXJ2YWJsZTtcclxuICAgICAgICBub3RpZmljYXRpb24udG9TdHJpbmcgPSB0b1N0cmluZztcclxuICAgICAgICByZXR1cm4gbm90aWZpY2F0aW9uO1xyXG4gICAgICB9O1xyXG4gIH0oKSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhbiBPbkVycm9yIG5vdGlmaWNhdGlvbiB0byBhbiBvYnNlcnZlci5cclxuICAgKiBAcGFyYW0ge0FueX0gZXJyb3IgVGhlIGV4Y2VwdGlvbiBjb250YWluZWQgaW4gdGhlIG5vdGlmaWNhdGlvbi5cclxuICAgKiBAcmV0dXJucyB7Tm90aWZpY2F0aW9ufSBUaGUgT25FcnJvciBub3RpZmljYXRpb24gY29udGFpbmluZyB0aGUgZXhjZXB0aW9uLlxyXG4gICAqL1xyXG4gIHZhciBub3RpZmljYXRpb25DcmVhdGVPbkVycm9yID0gTm90aWZpY2F0aW9uLmNyZWF0ZU9uRXJyb3IgPSAoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIGZ1bmN0aW9uIF9hY2NlcHQgKG9uTmV4dCwgb25FcnJvcikgeyByZXR1cm4gb25FcnJvcih0aGlzLmV4Y2VwdGlvbik7IH1cclxuICAgIGZ1bmN0aW9uIF9hY2NlcHRPYnNlcnZhYmxlKG9ic2VydmVyKSB7IHJldHVybiBvYnNlcnZlci5vbkVycm9yKHRoaXMuZXhjZXB0aW9uKTsgfVxyXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcgKCkgeyByZXR1cm4gJ09uRXJyb3IoJyArIHRoaXMuZXhjZXB0aW9uICsgJyknOyB9XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgIHZhciBub3RpZmljYXRpb24gPSBuZXcgTm90aWZpY2F0aW9uKCdFJyk7XHJcbiAgICAgIG5vdGlmaWNhdGlvbi5leGNlcHRpb24gPSBlO1xyXG4gICAgICBub3RpZmljYXRpb24uX2FjY2VwdCA9IF9hY2NlcHQ7XHJcbiAgICAgIG5vdGlmaWNhdGlvbi5fYWNjZXB0T2JzZXJ2YWJsZSA9IF9hY2NlcHRPYnNlcnZhYmxlO1xyXG4gICAgICBub3RpZmljYXRpb24udG9TdHJpbmcgPSB0b1N0cmluZztcclxuICAgICAgcmV0dXJuIG5vdGlmaWNhdGlvbjtcclxuICAgIH07XHJcbiAgfSgpKTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIGFuIE9uQ29tcGxldGVkIG5vdGlmaWNhdGlvbiB0byBhbiBvYnNlcnZlci5cclxuICAgKiBAcmV0dXJucyB7Tm90aWZpY2F0aW9ufSBUaGUgT25Db21wbGV0ZWQgbm90aWZpY2F0aW9uLlxyXG4gICAqL1xyXG4gIHZhciBub3RpZmljYXRpb25DcmVhdGVPbkNvbXBsZXRlZCA9IE5vdGlmaWNhdGlvbi5jcmVhdGVPbkNvbXBsZXRlZCA9IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgZnVuY3Rpb24gX2FjY2VwdCAob25OZXh0LCBvbkVycm9yLCBvbkNvbXBsZXRlZCkgeyByZXR1cm4gb25Db21wbGV0ZWQoKTsgfVxyXG4gICAgZnVuY3Rpb24gX2FjY2VwdE9ic2VydmFibGUob2JzZXJ2ZXIpIHsgcmV0dXJuIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7IH1cclxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nICgpIHsgcmV0dXJuICdPbkNvbXBsZXRlZCgpJzsgfVxyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBub3RpZmljYXRpb24gPSBuZXcgTm90aWZpY2F0aW9uKCdDJyk7XHJcbiAgICAgIG5vdGlmaWNhdGlvbi5fYWNjZXB0ID0gX2FjY2VwdDtcclxuICAgICAgbm90aWZpY2F0aW9uLl9hY2NlcHRPYnNlcnZhYmxlID0gX2FjY2VwdE9ic2VydmFibGU7XHJcbiAgICAgIG5vdGlmaWNhdGlvbi50b1N0cmluZyA9IHRvU3RyaW5nO1xyXG4gICAgICByZXR1cm4gbm90aWZpY2F0aW9uO1xyXG4gICAgfTtcclxuICB9KCkpO1xyXG5cclxuICB2YXIgRW51bWVyYXRvciA9IFJ4LmludGVybmFscy5FbnVtZXJhdG9yID0gZnVuY3Rpb24gKG5leHQpIHtcclxuICAgIHRoaXMuX25leHQgPSBuZXh0O1xyXG4gIH07XHJcblxyXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbmV4dCgpO1xyXG4gIH07XHJcblxyXG4gIEVudW1lcmF0b3IucHJvdG90eXBlWyRpdGVyYXRvciRdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuICB2YXIgRW51bWVyYWJsZSA9IFJ4LmludGVybmFscy5FbnVtZXJhYmxlID0gZnVuY3Rpb24gKGl0ZXJhdG9yKSB7XHJcbiAgICB0aGlzLl9pdGVyYXRvciA9IGl0ZXJhdG9yO1xyXG4gIH07XHJcblxyXG4gIEVudW1lcmFibGUucHJvdG90eXBlWyRpdGVyYXRvciRdID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2l0ZXJhdG9yKCk7XHJcbiAgfTtcclxuXHJcbiAgRW51bWVyYWJsZS5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHNvdXJjZXMgPSB0aGlzO1xyXG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICB2YXIgZTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBlID0gc291cmNlc1skaXRlcmF0b3IkXSgpO1xyXG4gICAgICB9IGNhdGNoKGVycikge1xyXG4gICAgICAgIG9ic2VydmVyLm9uRXJyb3IoKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBpc0Rpc3Bvc2VkLFxyXG4gICAgICAgIHN1YnNjcmlwdGlvbiA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCk7XHJcbiAgICAgIHZhciBjYW5jZWxhYmxlID0gaW1tZWRpYXRlU2NoZWR1bGVyLnNjaGVkdWxlUmVjdXJzaXZlKGZ1bmN0aW9uIChzZWxmKSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRJdGVtO1xyXG4gICAgICAgIGlmIChpc0Rpc3Bvc2VkKSB7IHJldHVybjsgfVxyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY3VycmVudEl0ZW0gPSBlLm5leHQoKTtcclxuICAgICAgICB9IGNhdGNoIChleCkge1xyXG4gICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihleCk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY3VycmVudEl0ZW0uZG9uZSkge1xyXG4gICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGlmIHByb21pc2VcclxuICAgICAgICB2YXIgY3VycmVudFZhbHVlID0gY3VycmVudEl0ZW0udmFsdWU7XHJcbiAgICAgICAgaXNQcm9taXNlKGN1cnJlbnRWYWx1ZSkgJiYgKGN1cnJlbnRWYWx1ZSA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShjdXJyZW50VmFsdWUpKTtcclxuXHJcbiAgICAgICAgdmFyIGQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcclxuICAgICAgICBzdWJzY3JpcHRpb24uc2V0RGlzcG9zYWJsZShkKTtcclxuICAgICAgICBkLnNldERpc3Bvc2FibGUoY3VycmVudFZhbHVlLnN1YnNjcmliZShcclxuICAgICAgICAgIG9ic2VydmVyLm9uTmV4dC5iaW5kKG9ic2VydmVyKSxcclxuICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IuYmluZChvYnNlcnZlciksXHJcbiAgICAgICAgICBmdW5jdGlvbiAoKSB7IHNlbGYoKTsgfSlcclxuICAgICAgICApO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJldHVybiBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZShzdWJzY3JpcHRpb24sIGNhbmNlbGFibGUsIGRpc3Bvc2FibGVDcmVhdGUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlzRGlzcG9zZWQgPSB0cnVlO1xyXG4gICAgICB9KSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICBFbnVtZXJhYmxlLnByb3RvdHlwZS5jYXRjaEV4Y2VwdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBzb3VyY2VzID0gdGhpcztcclxuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgdmFyIGU7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgZSA9IHNvdXJjZXNbJGl0ZXJhdG9yJF0oKTtcclxuICAgICAgfSBjYXRjaChlcnIpIHtcclxuICAgICAgICBvYnNlcnZlci5vbkVycm9yKCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgaXNEaXNwb3NlZCxcclxuICAgICAgICBsYXN0RXhjZXB0aW9uLFxyXG4gICAgICAgIHN1YnNjcmlwdGlvbiA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCk7XHJcbiAgICAgIHZhciBjYW5jZWxhYmxlID0gaW1tZWRpYXRlU2NoZWR1bGVyLnNjaGVkdWxlUmVjdXJzaXZlKGZ1bmN0aW9uIChzZWxmKSB7XHJcbiAgICAgICAgaWYgKGlzRGlzcG9zZWQpIHsgcmV0dXJuOyB9XHJcblxyXG4gICAgICAgIHZhciBjdXJyZW50SXRlbTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY3VycmVudEl0ZW0gPSBlLm5leHQoKTtcclxuICAgICAgICB9IGNhdGNoIChleCkge1xyXG4gICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihleCk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY3VycmVudEl0ZW0uZG9uZSkge1xyXG4gICAgICAgICAgaWYgKGxhc3RFeGNlcHRpb24pIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihsYXN0RXhjZXB0aW9uKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVjayBpZiBwcm9taXNlXHJcbiAgICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IGN1cnJlbnRJdGVtLnZhbHVlO1xyXG4gICAgICAgIGlzUHJvbWlzZShjdXJyZW50VmFsdWUpICYmIChjdXJyZW50VmFsdWUgPSBvYnNlcnZhYmxlRnJvbVByb21pc2UoY3VycmVudFZhbHVlKSk7XHJcblxyXG4gICAgICAgIHZhciBkID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XHJcbiAgICAgICAgc3Vic2NyaXB0aW9uLnNldERpc3Bvc2FibGUoZCk7XHJcbiAgICAgICAgZC5zZXREaXNwb3NhYmxlKGN1cnJlbnRWYWx1ZS5zdWJzY3JpYmUoXHJcbiAgICAgICAgICBvYnNlcnZlci5vbk5leHQuYmluZChvYnNlcnZlciksXHJcbiAgICAgICAgICBmdW5jdGlvbiAoZXhuKSB7XHJcbiAgICAgICAgICAgIGxhc3RFeGNlcHRpb24gPSBleG47XHJcbiAgICAgICAgICAgIHNlbGYoKTtcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZC5iaW5kKG9ic2VydmVyKSkpO1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKHN1YnNjcmlwdGlvbiwgY2FuY2VsYWJsZSwgZGlzcG9zYWJsZUNyZWF0ZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaXNEaXNwb3NlZCA9IHRydWU7XHJcbiAgICAgIH0pKTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIHZhciBlbnVtZXJhYmxlUmVwZWF0ID0gRW51bWVyYWJsZS5yZXBlYXQgPSBmdW5jdGlvbiAodmFsdWUsIHJlcGVhdENvdW50KSB7XHJcbiAgICBpZiAocmVwZWF0Q291bnQgPT0gbnVsbCkgeyByZXBlYXRDb3VudCA9IC0xOyB9XHJcbiAgICByZXR1cm4gbmV3IEVudW1lcmFibGUoZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgbGVmdCA9IHJlcGVhdENvdW50O1xyXG4gICAgICByZXR1cm4gbmV3IEVudW1lcmF0b3IoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChsZWZ0ID09PSAwKSB7IHJldHVybiBkb25lRW51bWVyYXRvcjsgfVxyXG4gICAgICAgIGlmIChsZWZ0ID4gMCkgeyBsZWZ0LS07IH1cclxuICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IHZhbHVlIH07XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgdmFyIGVudW1lcmFibGVPZiA9IEVudW1lcmFibGUub2YgPSBmdW5jdGlvbiAoc291cmNlLCBzZWxlY3RvciwgdGhpc0FyZykge1xyXG4gICAgc2VsZWN0b3IgfHwgKHNlbGVjdG9yID0gaWRlbnRpdHkpO1xyXG4gICAgcmV0dXJuIG5ldyBFbnVtZXJhYmxlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGluZGV4ID0gLTE7XHJcbiAgICAgIHJldHVybiBuZXcgRW51bWVyYXRvcihcclxuICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICByZXR1cm4gKytpbmRleCA8IHNvdXJjZS5sZW5ndGggP1xyXG4gICAgICAgICAgICB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogc2VsZWN0b3IuY2FsbCh0aGlzQXJnLCBzb3VyY2VbaW5kZXhdLCBpbmRleCwgc291cmNlKSB9IDpcclxuICAgICAgICAgICAgZG9uZUVudW1lcmF0b3I7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBTdXBwb3J0cyBwdXNoLXN0eWxlIGl0ZXJhdGlvbiBvdmVyIGFuIG9ic2VydmFibGUgc2VxdWVuY2UuXHJcbiAgICovXHJcbiAgdmFyIE9ic2VydmVyID0gUnguT2JzZXJ2ZXIgPSBmdW5jdGlvbiAoKSB7IH07XHJcblxyXG4gIC8qKlxyXG4gICAqICBDcmVhdGVzIGEgbm90aWZpY2F0aW9uIGNhbGxiYWNrIGZyb20gYW4gb2JzZXJ2ZXIuXHJcbiAgICogQHJldHVybnMgVGhlIGFjdGlvbiB0aGF0IGZvcndhcmRzIGl0cyBpbnB1dCBub3RpZmljYXRpb24gdG8gdGhlIHVuZGVybHlpbmcgb2JzZXJ2ZXIuXHJcbiAgICovXHJcbiAgT2JzZXJ2ZXIucHJvdG90eXBlLnRvTm90aWZpZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgb2JzZXJ2ZXIgPSB0aGlzO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLmFjY2VwdChvYnNlcnZlcik7IH07XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogIEhpZGVzIHRoZSBpZGVudGl0eSBvZiBhbiBvYnNlcnZlci5cclxuICAgKiBAcmV0dXJucyBBbiBvYnNlcnZlciB0aGF0IGhpZGVzIHRoZSBpZGVudGl0eSBvZiB0aGUgc3BlY2lmaWVkIG9ic2VydmVyLlxyXG4gICAqL1xyXG4gIE9ic2VydmVyLnByb3RvdHlwZS5hc09ic2VydmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZlcih0aGlzLm9uTmV4dC5iaW5kKHRoaXMpLCB0aGlzLm9uRXJyb3IuYmluZCh0aGlzKSwgdGhpcy5vbkNvbXBsZXRlZC5iaW5kKHRoaXMpKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiAgQ2hlY2tzIGFjY2VzcyB0byB0aGUgb2JzZXJ2ZXIgZm9yIGdyYW1tYXIgdmlvbGF0aW9ucy4gVGhpcyBpbmNsdWRlcyBjaGVja2luZyBmb3IgbXVsdGlwbGUgT25FcnJvciBvciBPbkNvbXBsZXRlZCBjYWxscywgYXMgd2VsbCBhcyByZWVudHJhbmN5IGluIGFueSBvZiB0aGUgb2JzZXJ2ZXIgbWV0aG9kcy5cclxuICAgKiAgSWYgYSB2aW9sYXRpb24gaXMgZGV0ZWN0ZWQsIGFuIEVycm9yIGlzIHRocm93biBmcm9tIHRoZSBvZmZlbmRpbmcgb2JzZXJ2ZXIgbWV0aG9kIGNhbGwuXHJcbiAgICogQHJldHVybnMgQW4gb2JzZXJ2ZXIgdGhhdCBjaGVja3MgY2FsbGJhY2tzIGludm9jYXRpb25zIGFnYWluc3QgdGhlIG9ic2VydmVyIGdyYW1tYXIgYW5kLCBpZiB0aGUgY2hlY2tzIHBhc3MsIGZvcndhcmRzIHRob3NlIHRvIHRoZSBzcGVjaWZpZWQgb2JzZXJ2ZXIuXHJcbiAgICovXHJcbiAgT2JzZXJ2ZXIucHJvdG90eXBlLmNoZWNrZWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgQ2hlY2tlZE9ic2VydmVyKHRoaXMpOyB9O1xyXG5cclxuICAvKipcclxuICAgKiAgQ3JlYXRlcyBhbiBvYnNlcnZlciBmcm9tIHRoZSBzcGVjaWZpZWQgT25OZXh0LCBhbG9uZyB3aXRoIG9wdGlvbmFsIE9uRXJyb3IsIGFuZCBPbkNvbXBsZXRlZCBhY3Rpb25zLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbk5leHRdIE9ic2VydmVyJ3MgT25OZXh0IGFjdGlvbiBpbXBsZW1lbnRhdGlvbi5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25FcnJvcl0gT2JzZXJ2ZXIncyBPbkVycm9yIGFjdGlvbiBpbXBsZW1lbnRhdGlvbi5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25Db21wbGV0ZWRdIE9ic2VydmVyJ3MgT25Db21wbGV0ZWQgYWN0aW9uIGltcGxlbWVudGF0aW9uLlxyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZlcn0gVGhlIG9ic2VydmVyIG9iamVjdCBpbXBsZW1lbnRlZCB1c2luZyB0aGUgZ2l2ZW4gYWN0aW9ucy5cclxuICAgKi9cclxuICB2YXIgb2JzZXJ2ZXJDcmVhdGUgPSBPYnNlcnZlci5jcmVhdGUgPSBmdW5jdGlvbiAob25OZXh0LCBvbkVycm9yLCBvbkNvbXBsZXRlZCkge1xyXG4gICAgb25OZXh0IHx8IChvbk5leHQgPSBub29wKTtcclxuICAgIG9uRXJyb3IgfHwgKG9uRXJyb3IgPSBkZWZhdWx0RXJyb3IpO1xyXG4gICAgb25Db21wbGV0ZWQgfHwgKG9uQ29tcGxldGVkID0gbm9vcCk7XHJcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmVyKG9uTmV4dCwgb25FcnJvciwgb25Db21wbGV0ZWQpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqICBDcmVhdGVzIGFuIG9ic2VydmVyIGZyb20gYSBub3RpZmljYXRpb24gY2FsbGJhY2suXHJcbiAgICpcclxuICAgKiBAc3RhdGljXHJcbiAgICogQG1lbWJlck9mIE9ic2VydmVyXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBBY3Rpb24gdGhhdCBoYW5kbGVzIGEgbm90aWZpY2F0aW9uLlxyXG4gICAqIEByZXR1cm5zIFRoZSBvYnNlcnZlciBvYmplY3QgdGhhdCBpbnZva2VzIHRoZSBzcGVjaWZpZWQgaGFuZGxlciB1c2luZyBhIG5vdGlmaWNhdGlvbiBjb3JyZXNwb25kaW5nIHRvIGVhY2ggbWVzc2FnZSBpdCByZWNlaXZlcy5cclxuICAgKi9cclxuICBPYnNlcnZlci5mcm9tTm90aWZpZXIgPSBmdW5jdGlvbiAoaGFuZGxlciwgdGhpc0FyZykge1xyXG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZlcihmdW5jdGlvbiAoeCkge1xyXG4gICAgICByZXR1cm4gaGFuZGxlci5jYWxsKHRoaXNBcmcsIG5vdGlmaWNhdGlvbkNyZWF0ZU9uTmV4dCh4KSk7XHJcbiAgICB9LCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICByZXR1cm4gaGFuZGxlci5jYWxsKHRoaXNBcmcsIG5vdGlmaWNhdGlvbkNyZWF0ZU9uRXJyb3IoZSkpO1xyXG4gICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gaGFuZGxlci5jYWxsKHRoaXNBcmcsIG5vdGlmaWNhdGlvbkNyZWF0ZU9uQ29tcGxldGVkKCkpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogU2NoZWR1bGVzIHRoZSBpbnZvY2F0aW9uIG9mIG9ic2VydmVyIG1ldGhvZHMgb24gdGhlIGdpdmVuIHNjaGVkdWxlci5cclxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gc2NoZWR1bGVyIFNjaGVkdWxlciB0byBzY2hlZHVsZSBvYnNlcnZlciBtZXNzYWdlcyBvbi5cclxuICAgKiBAcmV0dXJucyB7T2JzZXJ2ZXJ9IE9ic2VydmVyIHdob3NlIG1lc3NhZ2VzIGFyZSBzY2hlZHVsZWQgb24gdGhlIGdpdmVuIHNjaGVkdWxlci5cclxuICAgKi9cclxuICBPYnNlcnZlci5ub3RpZnlPbiA9IGZ1bmN0aW9uIChzY2hlZHVsZXIpIHtcclxuICAgIHJldHVybiBuZXcgT2JzZXJ2ZU9uT2JzZXJ2ZXIoc2NoZWR1bGVyLCB0aGlzKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIE9ic2VydmVyIGNsYXNzLlxyXG4gICAqIFRoaXMgYmFzZSBjbGFzcyBlbmZvcmNlcyB0aGUgZ3JhbW1hciBvZiBvYnNlcnZlcnMgd2hlcmUgT25FcnJvciBhbmQgT25Db21wbGV0ZWQgYXJlIHRlcm1pbmFsIG1lc3NhZ2VzLlxyXG4gICAqL1xyXG4gIHZhciBBYnN0cmFjdE9ic2VydmVyID0gUnguaW50ZXJuYWxzLkFic3RyYWN0T2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xyXG4gICAgaW5oZXJpdHMoQWJzdHJhY3RPYnNlcnZlciwgX19zdXBlcl9fKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgb2JzZXJ2ZXIgaW4gYSBub24tc3RvcHBlZCBzdGF0ZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQWJzdHJhY3RPYnNlcnZlcigpIHtcclxuICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOb3RpZmllcyB0aGUgb2JzZXJ2ZXIgb2YgYSBuZXcgZWxlbWVudCBpbiB0aGUgc2VxdWVuY2UuXHJcbiAgICAgKiBAcGFyYW0ge0FueX0gdmFsdWUgTmV4dCBlbGVtZW50IGluIHRoZSBzZXF1ZW5jZS5cclxuICAgICAqL1xyXG4gICAgQWJzdHJhY3RPYnNlcnZlci5wcm90b3R5cGUub25OZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHsgdGhpcy5uZXh0KHZhbHVlKTsgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5vdGlmaWVzIHRoZSBvYnNlcnZlciB0aGF0IGFuIGV4Y2VwdGlvbiBoYXMgb2NjdXJyZWQuXHJcbiAgICAgKiBAcGFyYW0ge0FueX0gZXJyb3IgVGhlIGVycm9yIHRoYXQgaGFzIG9jY3VycmVkLlxyXG4gICAgICovXHJcbiAgICBBYnN0cmFjdE9ic2VydmVyLnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcclxuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5lcnJvcihlcnJvcik7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOb3RpZmllcyB0aGUgb2JzZXJ2ZXIgb2YgdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2UuXHJcbiAgICAgKi9cclxuICAgIEFic3RyYWN0T2JzZXJ2ZXIucHJvdG90eXBlLm9uQ29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XHJcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuY29tcGxldGVkKCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwb3NlcyB0aGUgb2JzZXJ2ZXIsIGNhdXNpbmcgaXQgdG8gdHJhbnNpdGlvbiB0byB0aGUgc3RvcHBlZCBzdGF0ZS5cclxuICAgICAqL1xyXG4gICAgQWJzdHJhY3RPYnNlcnZlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBBYnN0cmFjdE9ic2VydmVyLnByb3RvdHlwZS5mYWlsID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xyXG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmVycm9yKGUpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBBYnN0cmFjdE9ic2VydmVyO1xyXG4gIH0oT2JzZXJ2ZXIpKTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2xhc3MgdG8gY3JlYXRlIGFuIE9ic2VydmVyIGluc3RhbmNlIGZyb20gZGVsZWdhdGUtYmFzZWQgaW1wbGVtZW50YXRpb25zIG9mIHRoZSBvbiogbWV0aG9kcy5cclxuICAgKi9cclxuICB2YXIgQW5vbnltb3VzT2JzZXJ2ZXIgPSBSeC5Bbm9ueW1vdXNPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XHJcbiAgICBpbmhlcml0cyhBbm9ueW1vdXNPYnNlcnZlciwgX19zdXBlcl9fKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gb2JzZXJ2ZXIgZnJvbSB0aGUgc3BlY2lmaWVkIE9uTmV4dCwgT25FcnJvciwgYW5kIE9uQ29tcGxldGVkIGFjdGlvbnMuXHJcbiAgICAgKiBAcGFyYW0ge0FueX0gb25OZXh0IE9ic2VydmVyJ3MgT25OZXh0IGFjdGlvbiBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAqIEBwYXJhbSB7QW55fSBvbkVycm9yIE9ic2VydmVyJ3MgT25FcnJvciBhY3Rpb24gaW1wbGVtZW50YXRpb24uXHJcbiAgICAgKiBAcGFyYW0ge0FueX0gb25Db21wbGV0ZWQgT2JzZXJ2ZXIncyBPbkNvbXBsZXRlZCBhY3Rpb24gaW1wbGVtZW50YXRpb24uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEFub255bW91c09ic2VydmVyKG9uTmV4dCwgb25FcnJvciwgb25Db21wbGV0ZWQpIHtcclxuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XHJcbiAgICAgIHRoaXMuX29uTmV4dCA9IG9uTmV4dDtcclxuICAgICAgdGhpcy5fb25FcnJvciA9IG9uRXJyb3I7XHJcbiAgICAgIHRoaXMuX29uQ29tcGxldGVkID0gb25Db21wbGV0ZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxscyB0aGUgb25OZXh0IGFjdGlvbi5cclxuICAgICAqIEBwYXJhbSB7QW55fSB2YWx1ZSBOZXh0IGVsZW1lbnQgaW4gdGhlIHNlcXVlbmNlLlxyXG4gICAgICovXHJcbiAgICBBbm9ueW1vdXNPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICB0aGlzLl9vbk5leHQodmFsdWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxzIHRoZSBvbkVycm9yIGFjdGlvbi5cclxuICAgICAqIEBwYXJhbSB7QW55fSBlcnJvciBUaGUgZXJyb3IgdGhhdCBoYXMgb2NjdXJyZWQuXHJcbiAgICAgKi9cclxuICAgIEFub255bW91c09ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICB0aGlzLl9vbkVycm9yKGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAgQ2FsbHMgdGhlIG9uQ29tcGxldGVkIGFjdGlvbi5cclxuICAgICAqL1xyXG4gICAgQW5vbnltb3VzT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5fb25Db21wbGV0ZWQoKTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIEFub255bW91c09ic2VydmVyO1xyXG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xyXG5cclxuICAgIHZhciBDaGVja2VkT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIGluaGVyaXRzKENoZWNrZWRPYnNlcnZlciwgX3N1cGVyKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gQ2hlY2tlZE9ic2VydmVyKG9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLl9vYnNlcnZlciA9IG9ic2VydmVyO1xyXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDA7IC8vIDAgLSBpZGxlLCAxIC0gYnVzeSwgMiAtIGRvbmVcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBDaGVja2VkT2JzZXJ2ZXJQcm90b3R5cGUgPSBDaGVja2VkT2JzZXJ2ZXIucHJvdG90eXBlO1xyXG5cclxuICAgICAgICBDaGVja2VkT2JzZXJ2ZXJQcm90b3R5cGUub25OZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hlY2tBY2Nlc3MoKTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX29ic2VydmVyLm9uTmV4dCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBDaGVja2VkT2JzZXJ2ZXJQcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgdGhpcy5jaGVja0FjY2VzcygpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fb2JzZXJ2ZXIub25FcnJvcihlcnIpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgQ2hlY2tlZE9ic2VydmVyUHJvdG90eXBlLm9uQ29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmNoZWNrQWNjZXNzKCk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgQ2hlY2tlZE9ic2VydmVyUHJvdG90eXBlLmNoZWNrQWNjZXNzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IDEpIHsgdGhyb3cgbmV3IEVycm9yKCdSZS1lbnRyYW5jeSBkZXRlY3RlZCcpOyB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gMikgeyB0aHJvdyBuZXcgRXJyb3IoJ09ic2VydmVyIGNvbXBsZXRlZCcpOyB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gMCkgeyB0aGlzLl9zdGF0ZSA9IDE7IH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gQ2hlY2tlZE9ic2VydmVyO1xyXG4gICAgfShPYnNlcnZlcikpO1xyXG5cclxuICB2YXIgU2NoZWR1bGVkT2JzZXJ2ZXIgPSBSeC5pbnRlcm5hbHMuU2NoZWR1bGVkT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xyXG4gICAgaW5oZXJpdHMoU2NoZWR1bGVkT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XHJcblxyXG4gICAgZnVuY3Rpb24gU2NoZWR1bGVkT2JzZXJ2ZXIoc2NoZWR1bGVyLCBvYnNlcnZlcikge1xyXG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcclxuICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XHJcbiAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcclxuICAgICAgdGhpcy5pc0FjcXVpcmVkID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuaGFzRmF1bHRlZCA9IGZhbHNlO1xyXG4gICAgICB0aGlzLnF1ZXVlID0gW107XHJcbiAgICAgIHRoaXMuZGlzcG9zYWJsZSA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgU2NoZWR1bGVkT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICB0aGlzLnF1ZXVlLnB1c2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNlbGYub2JzZXJ2ZXIub25OZXh0KHZhbHVlKTtcclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFNjaGVkdWxlZE9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICB0aGlzLnF1ZXVlLnB1c2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNlbGYub2JzZXJ2ZXIub25FcnJvcihlcnIpO1xyXG4gICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgU2NoZWR1bGVkT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICB0aGlzLnF1ZXVlLnB1c2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNlbGYub2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFNjaGVkdWxlZE9ic2VydmVyLnByb3RvdHlwZS5lbnN1cmVBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBpc093bmVyID0gZmFsc2UsIHBhcmVudCA9IHRoaXM7XHJcbiAgICAgIGlmICghdGhpcy5oYXNGYXVsdGVkICYmIHRoaXMucXVldWUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGlzT3duZXIgPSAhdGhpcy5pc0FjcXVpcmVkO1xyXG4gICAgICAgIHRoaXMuaXNBY3F1aXJlZCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGlzT3duZXIpIHtcclxuICAgICAgICB0aGlzLmRpc3Bvc2FibGUuc2V0RGlzcG9zYWJsZSh0aGlzLnNjaGVkdWxlci5zY2hlZHVsZVJlY3Vyc2l2ZShmdW5jdGlvbiAoc2VsZikge1xyXG4gICAgICAgICAgdmFyIHdvcms7XHJcbiAgICAgICAgICBpZiAocGFyZW50LnF1ZXVlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgd29yayA9IHBhcmVudC5xdWV1ZS5zaGlmdCgpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcGFyZW50LmlzQWNxdWlyZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgd29yaygpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZXgpIHtcclxuICAgICAgICAgICAgcGFyZW50LnF1ZXVlID0gW107XHJcbiAgICAgICAgICAgIHBhcmVudC5oYXNGYXVsdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhyb3cgZXg7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBzZWxmKCk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIFNjaGVkdWxlZE9ic2VydmVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBfX3N1cGVyX18ucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcclxuICAgICAgdGhpcy5kaXNwb3NhYmxlLmRpc3Bvc2UoKTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIFNjaGVkdWxlZE9ic2VydmVyO1xyXG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xyXG5cclxuICB2YXIgT2JzZXJ2ZU9uT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xyXG4gICAgaW5oZXJpdHMoT2JzZXJ2ZU9uT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XHJcblxyXG4gICAgZnVuY3Rpb24gT2JzZXJ2ZU9uT2JzZXJ2ZXIoKSB7XHJcbiAgICAgIF9fc3VwZXJfXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfVxyXG5cclxuICAgIE9ic2VydmVPbk9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgIF9fc3VwZXJfXy5wcm90b3R5cGUubmV4dC5jYWxsKHRoaXMsIHZhbHVlKTtcclxuICAgICAgdGhpcy5lbnN1cmVBY3RpdmUoKTtcclxuICAgIH07XHJcblxyXG4gICAgT2JzZXJ2ZU9uT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgX19zdXBlcl9fLnByb3RvdHlwZS5lcnJvci5jYWxsKHRoaXMsIGUpO1xyXG4gICAgICB0aGlzLmVuc3VyZUFjdGl2ZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBPYnNlcnZlT25PYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBfX3N1cGVyX18ucHJvdG90eXBlLmNvbXBsZXRlZC5jYWxsKHRoaXMpO1xyXG4gICAgICB0aGlzLmVuc3VyZUFjdGl2ZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gT2JzZXJ2ZU9uT2JzZXJ2ZXI7XHJcbiAgfSkoU2NoZWR1bGVkT2JzZXJ2ZXIpO1xyXG5cclxuICB2YXIgb2JzZXJ2YWJsZVByb3RvO1xyXG5cclxuICAvKipcclxuICAgKiBSZXByZXNlbnRzIGEgcHVzaC1zdHlsZSBjb2xsZWN0aW9uLlxyXG4gICAqL1xyXG4gIHZhciBPYnNlcnZhYmxlID0gUnguT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgZnVuY3Rpb24gT2JzZXJ2YWJsZShzdWJzY3JpYmUpIHtcclxuICAgICAgdGhpcy5fc3Vic2NyaWJlID0gc3Vic2NyaWJlO1xyXG4gICAgfVxyXG5cclxuICAgIG9ic2VydmFibGVQcm90byA9IE9ic2VydmFibGUucHJvdG90eXBlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogIFN1YnNjcmliZXMgYW4gb2JzZXJ2ZXIgdG8gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuXHJcbiAgICAgKiAgQHBhcmFtIHtNaXhlZH0gW29ic2VydmVyT3JPbk5leHRdIFRoZSBvYmplY3QgdGhhdCBpcyB0byByZWNlaXZlIG5vdGlmaWNhdGlvbnMgb3IgYW4gYWN0aW9uIHRvIGludm9rZSBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxyXG4gICAgICogIEBwYXJhbSB7RnVuY3Rpb259IFtvbkVycm9yXSBBY3Rpb24gdG8gaW52b2tlIHVwb24gZXhjZXB0aW9uYWwgdGVybWluYXRpb24gb2YgdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuXHJcbiAgICAgKiAgQHBhcmFtIHtGdW5jdGlvbn0gW29uQ29tcGxldGVkXSBBY3Rpb24gdG8gaW52b2tlIHVwb24gZ3JhY2VmdWwgdGVybWluYXRpb24gb2YgdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuXHJcbiAgICAgKiAgQHJldHVybnMge0RpcG9zYWJsZX0gQSBkaXNwb3NhYmxlIGhhbmRsaW5nIHRoZSBzdWJzY3JpcHRpb25zIGFuZCB1bnN1YnNjcmlwdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIG9ic2VydmFibGVQcm90by5zdWJzY3JpYmUgPSBvYnNlcnZhYmxlUHJvdG8uZm9yRWFjaCA9IGZ1bmN0aW9uIChvYnNlcnZlck9yT25OZXh0LCBvbkVycm9yLCBvbkNvbXBsZXRlZCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fc3Vic2NyaWJlKHR5cGVvZiBvYnNlcnZlck9yT25OZXh0ID09PSAnb2JqZWN0JyA/XHJcbiAgICAgICAgb2JzZXJ2ZXJPck9uTmV4dCA6XHJcbiAgICAgICAgb2JzZXJ2ZXJDcmVhdGUob2JzZXJ2ZXJPck9uTmV4dCwgb25FcnJvciwgb25Db21wbGV0ZWQpKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJzY3JpYmVzIHRvIHRoZSBuZXh0IHZhbHVlIGluIHRoZSBzZXF1ZW5jZSB3aXRoIGFuIG9wdGlvbmFsIFwidGhpc1wiIGFyZ3VtZW50LlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25OZXh0IFRoZSBmdW5jdGlvbiB0byBpbnZva2Ugb24gZWFjaCBlbGVtZW50IGluIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxyXG4gICAgICogQHBhcmFtIHtBbnl9IFt0aGlzQXJnXSBPYmplY3QgdG8gdXNlIGFzIHRoaXMgd2hlbiBleGVjdXRpbmcgY2FsbGJhY2suXHJcbiAgICAgKiBAcmV0dXJucyB7RGlzcG9zYWJsZX0gQSBkaXNwb3NhYmxlIGhhbmRsaW5nIHRoZSBzdWJzY3JpcHRpb25zIGFuZCB1bnN1YnNjcmlwdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIG9ic2VydmFibGVQcm90by5zdWJzY3JpYmVPbk5leHQgPSBmdW5jdGlvbiAob25OZXh0LCB0aGlzQXJnKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9zdWJzY3JpYmUob2JzZXJ2ZXJDcmVhdGUoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiA/IGZ1bmN0aW9uKHgpIHsgb25OZXh0LmNhbGwodGhpc0FyZywgeCk7IH0gOiBvbk5leHQpKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJzY3JpYmVzIHRvIGFuIGV4Y2VwdGlvbmFsIGNvbmRpdGlvbiBpbiB0aGUgc2VxdWVuY2Ugd2l0aCBhbiBvcHRpb25hbCBcInRoaXNcIiBhcmd1bWVudC5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uRXJyb3IgVGhlIGZ1bmN0aW9uIHRvIGludm9rZSB1cG9uIGV4Y2VwdGlvbmFsIHRlcm1pbmF0aW9uIG9mIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxyXG4gICAgICogQHBhcmFtIHtBbnl9IFt0aGlzQXJnXSBPYmplY3QgdG8gdXNlIGFzIHRoaXMgd2hlbiBleGVjdXRpbmcgY2FsbGJhY2suXHJcbiAgICAgKiBAcmV0dXJucyB7RGlzcG9zYWJsZX0gQSBkaXNwb3NhYmxlIGhhbmRsaW5nIHRoZSBzdWJzY3JpcHRpb25zIGFuZCB1bnN1YnNjcmlwdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIG9ic2VydmFibGVQcm90by5zdWJzY3JpYmVPbkVycm9yID0gZnVuY3Rpb24gKG9uRXJyb3IsIHRoaXNBcmcpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX3N1YnNjcmliZShvYnNlcnZlckNyZWF0ZShudWxsLCBhcmd1bWVudHMubGVuZ3RoID09PSAyID8gZnVuY3Rpb24oZSkgeyBvbkVycm9yLmNhbGwodGhpc0FyZywgZSk7IH0gOiBvbkVycm9yKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3Vic2NyaWJlcyB0byB0aGUgbmV4dCB2YWx1ZSBpbiB0aGUgc2VxdWVuY2Ugd2l0aCBhbiBvcHRpb25hbCBcInRoaXNcIiBhcmd1bWVudC5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uQ29tcGxldGVkIFRoZSBmdW5jdGlvbiB0byBpbnZva2UgdXBvbiBncmFjZWZ1bCB0ZXJtaW5hdGlvbiBvZiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cclxuICAgICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyB0aGlzIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxyXG4gICAgICogQHJldHVybnMge0Rpc3Bvc2FibGV9IEEgZGlzcG9zYWJsZSBoYW5kbGluZyB0aGUgc3Vic2NyaXB0aW9ucyBhbmQgdW5zdWJzY3JpcHRpb25zLlxyXG4gICAgICovXHJcbiAgICBvYnNlcnZhYmxlUHJvdG8uc3Vic2NyaWJlT25Db21wbGV0ZWQgPSBmdW5jdGlvbiAob25Db21wbGV0ZWQsIHRoaXNBcmcpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX3N1YnNjcmliZShvYnNlcnZlckNyZWF0ZShudWxsLCBudWxsLCBhcmd1bWVudHMubGVuZ3RoID09PSAyID8gZnVuY3Rpb24oKSB7IG9uQ29tcGxldGVkLmNhbGwodGhpc0FyZyk7IH0gOiBvbkNvbXBsZXRlZCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gT2JzZXJ2YWJsZTtcclxuICB9KSgpO1xyXG5cclxuICAgLyoqXHJcbiAgICogIFdyYXBzIHRoZSBzb3VyY2Ugc2VxdWVuY2UgaW4gb3JkZXIgdG8gcnVuIGl0cyBvYnNlcnZlciBjYWxsYmFja3Mgb24gdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIuXHJcbiAgICpcclxuICAgKiAgVGhpcyBvbmx5IGludm9rZXMgb2JzZXJ2ZXIgY2FsbGJhY2tzIG9uIGEgc2NoZWR1bGVyLiBJbiBjYXNlIHRoZSBzdWJzY3JpcHRpb24gYW5kL29yIHVuc3Vic2NyaXB0aW9uIGFjdGlvbnMgaGF2ZSBzaWRlLWVmZmVjdHNcclxuICAgKiAgdGhhdCByZXF1aXJlIHRvIGJlIHJ1biBvbiBhIHNjaGVkdWxlciwgdXNlIHN1YnNjcmliZU9uLlxyXG4gICAqXHJcbiAgICogIEBwYXJhbSB7U2NoZWR1bGVyfSBzY2hlZHVsZXIgU2NoZWR1bGVyIHRvIG5vdGlmeSBvYnNlcnZlcnMgb24uXHJcbiAgICogIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgc291cmNlIHNlcXVlbmNlIHdob3NlIG9ic2VydmF0aW9ucyBoYXBwZW4gb24gdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIuXHJcbiAgICovXHJcbiAgb2JzZXJ2YWJsZVByb3RvLm9ic2VydmVPbiA9IGZ1bmN0aW9uIChzY2hlZHVsZXIpIHtcclxuICAgIHZhciBzb3VyY2UgPSB0aGlzO1xyXG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgT2JzZXJ2ZU9uT2JzZXJ2ZXIoc2NoZWR1bGVyLCBvYnNlcnZlcikpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgIC8qKlxyXG4gICAqICBXcmFwcyB0aGUgc291cmNlIHNlcXVlbmNlIGluIG9yZGVyIHRvIHJ1biBpdHMgc3Vic2NyaXB0aW9uIGFuZCB1bnN1YnNjcmlwdGlvbiBsb2dpYyBvbiB0aGUgc3BlY2lmaWVkIHNjaGVkdWxlci4gVGhpcyBvcGVyYXRpb24gaXMgbm90IGNvbW1vbmx5IHVzZWQ7XHJcbiAgICogIHNlZSB0aGUgcmVtYXJrcyBzZWN0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZSBkaXN0aW5jdGlvbiBiZXR3ZWVuIHN1YnNjcmliZU9uIGFuZCBvYnNlcnZlT24uXHJcblxyXG4gICAqICBUaGlzIG9ubHkgcGVyZm9ybXMgdGhlIHNpZGUtZWZmZWN0cyBvZiBzdWJzY3JpcHRpb24gYW5kIHVuc3Vic2NyaXB0aW9uIG9uIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVyLiBJbiBvcmRlciB0byBpbnZva2Ugb2JzZXJ2ZXJcclxuICAgKiAgY2FsbGJhY2tzIG9uIGEgc2NoZWR1bGVyLCB1c2Ugb2JzZXJ2ZU9uLlxyXG5cclxuICAgKiAgQHBhcmFtIHtTY2hlZHVsZXJ9IHNjaGVkdWxlciBTY2hlZHVsZXIgdG8gcGVyZm9ybSBzdWJzY3JpcHRpb24gYW5kIHVuc3Vic2NyaXB0aW9uIGFjdGlvbnMgb24uXHJcbiAgICogIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgc291cmNlIHNlcXVlbmNlIHdob3NlIHN1YnNjcmlwdGlvbnMgYW5kIHVuc3Vic2NyaXB0aW9ucyBoYXBwZW4gb24gdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIuXHJcbiAgICovXHJcbiAgb2JzZXJ2YWJsZVByb3RvLnN1YnNjcmliZU9uID0gZnVuY3Rpb24gKHNjaGVkdWxlcikge1xyXG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XHJcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgIHZhciBtID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCksIGQgPSBuZXcgU2VyaWFsRGlzcG9zYWJsZSgpO1xyXG4gICAgICBkLnNldERpc3Bvc2FibGUobSk7XHJcbiAgICAgIG0uc2V0RGlzcG9zYWJsZShzY2hlZHVsZXIuc2NoZWR1bGUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGQuc2V0RGlzcG9zYWJsZShuZXcgU2NoZWR1bGVkRGlzcG9zYWJsZShzY2hlZHVsZXIsIHNvdXJjZS5zdWJzY3JpYmUob2JzZXJ2ZXIpKSk7XHJcbiAgICAgIH0pKTtcclxuICAgICAgcmV0dXJuIGQ7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDb252ZXJ0cyBhIFByb21pc2UgdG8gYW4gT2JzZXJ2YWJsZSBzZXF1ZW5jZVxyXG4gICAqIEBwYXJhbSB7UHJvbWlzZX0gQW4gRVM2IENvbXBsaWFudCBwcm9taXNlLlxyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHNlcXVlbmNlIHdoaWNoIHdyYXBzIHRoZSBleGlzdGluZyBwcm9taXNlIHN1Y2Nlc3MgYW5kIGZhaWx1cmUuXHJcbiAgICovXHJcbiAgdmFyIG9ic2VydmFibGVGcm9tUHJvbWlzZSA9IE9ic2VydmFibGUuZnJvbVByb21pc2UgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xyXG4gICAgcmV0dXJuIG9ic2VydmFibGVEZWZlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBzdWJqZWN0ID0gbmV3IFJ4LkFzeW5jU3ViamVjdCgpO1xyXG5cclxuICAgICAgcHJvbWlzZS50aGVuKFxyXG4gICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgaWYgKCFzdWJqZWN0LmlzRGlzcG9zZWQpIHtcclxuICAgICAgICAgICAgc3ViamVjdC5vbk5leHQodmFsdWUpO1xyXG4gICAgICAgICAgICBzdWJqZWN0Lm9uQ29tcGxldGVkKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdWJqZWN0Lm9uRXJyb3IuYmluZChzdWJqZWN0KSk7XHJcblxyXG4gICAgICByZXR1cm4gc3ViamVjdDtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qXHJcbiAgICogQ29udmVydHMgYW4gZXhpc3Rpbmcgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0byBhbiBFUzYgQ29tcGF0aWJsZSBQcm9taXNlXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiB2YXIgcHJvbWlzZSA9IFJ4Lk9ic2VydmFibGUucmV0dXJuKDQyKS50b1Byb21pc2UoUlNWUC5Qcm9taXNlKTtcclxuICAgKlxyXG4gICAqIC8vIFdpdGggY29uZmlnXHJcbiAgICogUnguY29uZmlnLlByb21pc2UgPSBSU1ZQLlByb21pc2U7XHJcbiAgICogdmFyIHByb21pc2UgPSBSeC5PYnNlcnZhYmxlLnJldHVybig0MikudG9Qcm9taXNlKCk7XHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Byb21pc2VDdG9yXSBUaGUgY29uc3RydWN0b3Igb2YgdGhlIHByb21pc2UuIElmIG5vdCBwcm92aWRlZCwgaXQgbG9va3MgZm9yIGl0IGluIFJ4LmNvbmZpZy5Qcm9taXNlLlxyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBBbiBFUzYgY29tcGF0aWJsZSBwcm9taXNlIHdpdGggdGhlIGxhc3QgdmFsdWUgZnJvbSB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cclxuICAgKi9cclxuICBvYnNlcnZhYmxlUHJvdG8udG9Qcm9taXNlID0gZnVuY3Rpb24gKHByb21pc2VDdG9yKSB7XHJcbiAgICBwcm9taXNlQ3RvciB8fCAocHJvbWlzZUN0b3IgPSBSeC5jb25maWcuUHJvbWlzZSk7XHJcbiAgICBpZiAoIXByb21pc2VDdG9yKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2UgdHlwZSBub3QgcHJvdmlkZWQgbm9yIGluIFJ4LmNvbmZpZy5Qcm9taXNlJyk7IH1cclxuICAgIHZhciBzb3VyY2UgPSB0aGlzO1xyXG4gICAgcmV0dXJuIG5ldyBwcm9taXNlQ3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgIC8vIE5vIGNhbmNlbGxhdGlvbiBjYW4gYmUgZG9uZVxyXG4gICAgICB2YXIgdmFsdWUsIGhhc1ZhbHVlID0gZmFsc2U7XHJcbiAgICAgIHNvdXJjZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB2YWx1ZSA9IHY7XHJcbiAgICAgICAgaGFzVmFsdWUgPSB0cnVlO1xyXG4gICAgICB9LCByZWplY3QsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBoYXNWYWx1ZSAmJiByZXNvbHZlKHZhbHVlKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgbGlzdCBmcm9tIGFuIG9ic2VydmFibGUgc2VxdWVuY2UuXHJcbiAgICogQHJldHVybnMgQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIGEgc2luZ2xlIGVsZW1lbnQgd2l0aCBhIGxpc3QgY29udGFpbmluZyBhbGwgdGhlIGVsZW1lbnRzIG9mIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXHJcbiAgICovXHJcbiAgb2JzZXJ2YWJsZVByb3RvLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24ob2JzZXJ2ZXIpIHtcclxuICAgICAgdmFyIGFyciA9IFtdO1xyXG4gICAgICByZXR1cm4gc2VsZi5zdWJzY3JpYmUoXHJcbiAgICAgICAgYXJyLnB1c2guYmluZChhcnIpLFxyXG4gICAgICAgIG9ic2VydmVyLm9uRXJyb3IuYmluZChvYnNlcnZlciksXHJcbiAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KGFycik7XHJcbiAgICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogIENyZWF0ZXMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBmcm9tIGEgc3BlY2lmaWVkIHN1YnNjcmliZSBtZXRob2QgaW1wbGVtZW50YXRpb24uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqICB2YXIgcmVzID0gUnguT2JzZXJ2YWJsZS5jcmVhdGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IH0gKTtcclxuICAgKiAgdmFyIHJlcyA9IFJ4Lk9ic2VydmFibGUuY3JlYXRlKGZ1bmN0aW9uIChvYnNlcnZlcikgeyByZXR1cm4gUnguRGlzcG9zYWJsZS5lbXB0eTsgfSApO1xyXG4gICAqICB2YXIgcmVzID0gUnguT2JzZXJ2YWJsZS5jcmVhdGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7IH0gKTtcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHN1YnNjcmliZSBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgcmVzdWx0aW5nIG9ic2VydmFibGUgc2VxdWVuY2UncyBzdWJzY3JpYmUgbWV0aG9kLCByZXR1cm5pbmcgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgd3JhcHBlZCBpbiBhIERpc3Bvc2FibGUuXHJcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggdGhlIHNwZWNpZmllZCBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIFN1YnNjcmliZSBtZXRob2QuXHJcbiAgICovXHJcbiAgT2JzZXJ2YWJsZS5jcmVhdGUgPSBPYnNlcnZhYmxlLmNyZWF0ZVdpdGhEaXNwb3NhYmxlID0gZnVuY3Rpb24gKHN1YnNjcmliZSkge1xyXG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKHN1YnNjcmliZSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogIFJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGludm9rZXMgdGhlIHNwZWNpZmllZCBmYWN0b3J5IGZ1bmN0aW9uIHdoZW5ldmVyIGEgbmV3IG9ic2VydmVyIHN1YnNjcmliZXMuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqICB2YXIgcmVzID0gUnguT2JzZXJ2YWJsZS5kZWZlcihmdW5jdGlvbiAoKSB7IHJldHVybiBSeC5PYnNlcnZhYmxlLmZyb21BcnJheShbMSwyLDNdKTsgfSk7XHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb2JzZXJ2YWJsZUZhY3RvcnkgT2JzZXJ2YWJsZSBmYWN0b3J5IGZ1bmN0aW9uIHRvIGludm9rZSBmb3IgZWFjaCBvYnNlcnZlciB0aGF0IHN1YnNjcmliZXMgdG8gdGhlIHJlc3VsdGluZyBzZXF1ZW5jZSBvciBQcm9taXNlLlxyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdob3NlIG9ic2VydmVycyB0cmlnZ2VyIGFuIGludm9jYXRpb24gb2YgdGhlIGdpdmVuIG9ic2VydmFibGUgZmFjdG9yeSBmdW5jdGlvbi5cclxuICAgKi9cclxuICB2YXIgb2JzZXJ2YWJsZURlZmVyID0gT2JzZXJ2YWJsZS5kZWZlciA9IGZ1bmN0aW9uIChvYnNlcnZhYmxlRmFjdG9yeSkge1xyXG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICB2YXIgcmVzdWx0O1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHJlc3VsdCA9IG9ic2VydmFibGVGYWN0b3J5KCk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZVRocm93KGUpLnN1YnNjcmliZShvYnNlcnZlcik7XHJcbiAgICAgIH1cclxuICAgICAgaXNQcm9taXNlKHJlc3VsdCkgJiYgKHJlc3VsdCA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShyZXN1bHQpKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdC5zdWJzY3JpYmUob2JzZXJ2ZXIpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogIFJldHVybnMgYW4gZW1wdHkgb2JzZXJ2YWJsZSBzZXF1ZW5jZSwgdXNpbmcgdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIgdG8gc2VuZCBvdXQgdGhlIHNpbmdsZSBPbkNvbXBsZXRlZCBtZXNzYWdlLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiAgdmFyIHJlcyA9IFJ4Lk9ic2VydmFibGUuZW1wdHkoKTtcclxuICAgKiAgdmFyIHJlcyA9IFJ4Lk9ic2VydmFibGUuZW1wdHkoUnguU2NoZWR1bGVyLnRpbWVvdXQpO1xyXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBTY2hlZHVsZXIgdG8gc2VuZCB0aGUgdGVybWluYXRpb24gY2FsbCBvbi5cclxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIG5vIGVsZW1lbnRzLlxyXG4gICAqL1xyXG4gIHZhciBvYnNlcnZhYmxlRW1wdHkgPSBPYnNlcnZhYmxlLmVtcHR5ID0gZnVuY3Rpb24gKHNjaGVkdWxlcikge1xyXG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gaW1tZWRpYXRlU2NoZWR1bGVyKTtcclxuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICB2YXIgbWF4U2FmZUludGVnZXIgPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuXG4gIGZ1bmN0aW9uIG51bWJlcklzRmluaXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgcm9vdC5pc0Zpbml0ZSh2YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05hbihuKSB7XG4gICAgcmV0dXJuIG4gIT09IG47XG4gIH1cblxuICBmdW5jdGlvbiBpc0l0ZXJhYmxlKG8pIHtcbiAgICByZXR1cm4gb1skaXRlcmF0b3IkXSAhPT0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gc2lnbih2YWx1ZSkge1xuICAgIHZhciBudW1iZXIgPSArdmFsdWU7XG4gICAgaWYgKG51bWJlciA9PT0gMCkgeyByZXR1cm4gbnVtYmVyOyB9XG4gICAgaWYgKGlzTmFOKG51bWJlcikpIHsgcmV0dXJuIG51bWJlcjsgfVxuICAgIHJldHVybiBudW1iZXIgPCAwID8gLTEgOiAxO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9MZW5ndGgobykge1xuICAgIHZhciBsZW4gPSArby5sZW5ndGg7XG4gICAgaWYgKGlzTmFOKGxlbikpIHsgcmV0dXJuIDA7IH1cbiAgICBpZiAobGVuID09PSAwIHx8ICFudW1iZXJJc0Zpbml0ZShsZW4pKSB7IHJldHVybiBsZW47IH1cbiAgICBsZW4gPSBzaWduKGxlbikgKiBNYXRoLmZsb29yKE1hdGguYWJzKGxlbikpO1xuICAgIGlmIChsZW4gPD0gMCkgeyByZXR1cm4gMDsgfVxuICAgIGlmIChsZW4gPiBtYXhTYWZlSW50ZWdlcikgeyByZXR1cm4gbWF4U2FmZUludGVnZXI7IH1cbiAgICByZXR1cm4gbGVuO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNDYWxsYWJsZShmKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChmKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJyAmJiB0eXBlb2YgZiA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBjcmVhdGVzIGEgbmV3IE9ic2VydmFibGUgc2VxdWVuY2UgZnJvbSBhbiBhcnJheS1saWtlIG9yIGl0ZXJhYmxlIG9iamVjdC5cbiAgICogQHBhcmFtIHtBbnl9IGFycmF5TGlrZSBBbiBhcnJheS1saWtlIG9yIGl0ZXJhYmxlIG9iamVjdCB0byBjb252ZXJ0IHRvIGFuIE9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFttYXBGbl0gTWFwIGZ1bmN0aW9uIHRvIGNhbGwgb24gZXZlcnkgZWxlbWVudCBvZiB0aGUgYXJyYXkuXG4gICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gVGhlIGNvbnRleHQgdG8gdXNlIGNhbGxpbmcgdGhlIG1hcEZuIGlmIHByb3ZpZGVkLlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gT3B0aW9uYWwgc2NoZWR1bGVyIHRvIHVzZSBmb3Igc2NoZWR1bGluZy4gIElmIG5vdCBwcm92aWRlZCwgZGVmYXVsdHMgdG8gU2NoZWR1bGVyLmN1cnJlbnRUaHJlYWQuXG4gICAqL1xuICB2YXIgb2JzZXJ2YWJsZUZyb20gPSBPYnNlcnZhYmxlLmZyb20gPSBmdW5jdGlvbiAoaXRlcmFibGUsIG1hcEZuLCB0aGlzQXJnLCBzY2hlZHVsZXIpIHtcbiAgICBpZiAoaXRlcmFibGUgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpdGVyYWJsZSBjYW5ub3QgYmUgbnVsbC4nKVxuICAgIH1cbiAgICBpZiAobWFwRm4gJiYgIWlzQ2FsbGFibGUobWFwRm4pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcEZuIHdoZW4gcHJvdmlkZWQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGN1cnJlbnRUaHJlYWRTY2hlZHVsZXIpO1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciBsaXN0ID0gT2JqZWN0KGl0ZXJhYmxlKSxcbiAgICAgICAgb2JqSXNJdGVyYWJsZSA9IGlzSXRlcmFibGUobGlzdCksXG4gICAgICAgIGxlbiA9IG9iaklzSXRlcmFibGUgPyAwIDogdG9MZW5ndGgobGlzdCksXG4gICAgICAgIGl0ID0gb2JqSXNJdGVyYWJsZSA/IGxpc3RbJGl0ZXJhdG9yJF0oKSA6IG51bGwsXG4gICAgICAgIGkgPSAwO1xuICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZVJlY3Vyc2l2ZShmdW5jdGlvbiAoc2VsZikge1xuICAgICAgICBpZiAoaSA8IGxlbiB8fCBvYmpJc0l0ZXJhYmxlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICBpZiAob2JqSXNJdGVyYWJsZSkge1xuICAgICAgICAgICAgdmFyIG5leHQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBuZXh0ID0gaXQubmV4dCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBvYnNlcnZlci5vbkVycm9yKGUpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dC5kb25lKSB7XG4gICAgICAgICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0ID0gbmV4dC52YWx1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gISFsaXN0LmNoYXJBdCA/IGxpc3QuY2hhckF0KGkpIDogbGlzdFtpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobWFwRm4gJiYgaXNDYWxsYWJsZShtYXBGbikpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXNBcmcgPyBtYXBGbi5jYWxsKHRoaXNBcmcsIHJlc3VsdCwgaSkgOiBtYXBGbihyZXN1bHQsIGkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBvYnNlcnZlci5vbkVycm9yKGUpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KHJlc3VsdCk7XG4gICAgICAgICAgaSsrO1xuICAgICAgICAgIHNlbGYoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxyXG4gIC8qKlxyXG4gICAqICBDb252ZXJ0cyBhbiBhcnJheSB0byBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlLCB1c2luZyBhbiBvcHRpb25hbCBzY2hlZHVsZXIgdG8gZW51bWVyYXRlIHRoZSBhcnJheS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogIHZhciByZXMgPSBSeC5PYnNlcnZhYmxlLmZyb21BcnJheShbMSwyLDNdKTtcclxuICAgKiAgdmFyIHJlcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUFycmF5KFsxLDIsM10sIFJ4LlNjaGVkdWxlci50aW1lb3V0KTtcclxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gU2NoZWR1bGVyIHRvIHJ1biB0aGUgZW51bWVyYXRpb24gb2YgdGhlIGlucHV0IHNlcXVlbmNlIG9uLlxyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aG9zZSBlbGVtZW50cyBhcmUgcHVsbGVkIGZyb20gdGhlIGdpdmVuIGVudW1lcmFibGUgc2VxdWVuY2UuXHJcbiAgICovXHJcbiAgdmFyIG9ic2VydmFibGVGcm9tQXJyYXkgPSBPYnNlcnZhYmxlLmZyb21BcnJheSA9IGZ1bmN0aW9uIChhcnJheSwgc2NoZWR1bGVyKSB7XHJcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBjdXJyZW50VGhyZWFkU2NoZWR1bGVyKTtcclxuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgdmFyIGNvdW50ID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoO1xyXG4gICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlUmVjdXJzaXZlKGZ1bmN0aW9uIChzZWxmKSB7XHJcbiAgICAgICAgaWYgKGNvdW50IDwgbGVuKSB7XHJcbiAgICAgICAgICBvYnNlcnZlci5vbk5leHQoYXJyYXlbY291bnQrK10pO1xyXG4gICAgICAgICAgc2VsZigpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiAgR2VuZXJhdGVzIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgYnkgcnVubmluZyBhIHN0YXRlLWRyaXZlbiBsb29wIHByb2R1Y2luZyB0aGUgc2VxdWVuY2UncyBlbGVtZW50cywgdXNpbmcgdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIgdG8gc2VuZCBvdXQgb2JzZXJ2ZXIgbWVzc2FnZXMuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqICB2YXIgcmVzID0gUnguT2JzZXJ2YWJsZS5nZW5lcmF0ZSgwLCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCA8IDEwOyB9LCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCArIDE7IH0sIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9KTtcclxuICAgKiAgdmFyIHJlcyA9IFJ4Lk9ic2VydmFibGUuZ2VuZXJhdGUoMCwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggPCAxMDsgfSwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggKyAxOyB9LCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSwgUnguU2NoZWR1bGVyLnRpbWVvdXQpO1xyXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGluaXRpYWxTdGF0ZSBJbml0aWFsIHN0YXRlLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbmRpdGlvbiBDb25kaXRpb24gdG8gdGVybWluYXRlIGdlbmVyYXRpb24gKHVwb24gcmV0dXJuaW5nIGZhbHNlKS5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlIEl0ZXJhdGlvbiBzdGVwIGZ1bmN0aW9uLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc3VsdFNlbGVjdG9yIFNlbGVjdG9yIGZ1bmN0aW9uIGZvciByZXN1bHRzIHByb2R1Y2VkIGluIHRoZSBzZXF1ZW5jZS5cclxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gU2NoZWR1bGVyIG9uIHdoaWNoIHRvIHJ1biB0aGUgZ2VuZXJhdG9yIGxvb3AuIElmIG5vdCBwcm92aWRlZCwgZGVmYXVsdHMgdG8gU2NoZWR1bGVyLmN1cnJlbnRUaHJlYWQuXHJcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBnZW5lcmF0ZWQgc2VxdWVuY2UuXHJcbiAgICovXHJcbiAgT2JzZXJ2YWJsZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUsIGNvbmRpdGlvbiwgaXRlcmF0ZSwgcmVzdWx0U2VsZWN0b3IsIHNjaGVkdWxlcikge1xyXG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gY3VycmVudFRocmVhZFNjaGVkdWxlcik7XHJcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgIHZhciBmaXJzdCA9IHRydWUsIHN0YXRlID0gaW5pdGlhbFN0YXRlO1xyXG4gICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlUmVjdXJzaXZlKGZ1bmN0aW9uIChzZWxmKSB7XHJcbiAgICAgICAgdmFyIGhhc1Jlc3VsdCwgcmVzdWx0O1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBpZiAoZmlyc3QpIHtcclxuICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHN0YXRlID0gaXRlcmF0ZShzdGF0ZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBoYXNSZXN1bHQgPSBjb25kaXRpb24oc3RhdGUpO1xyXG4gICAgICAgICAgaWYgKGhhc1Jlc3VsdCkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHRTZWxlY3RvcihzdGF0ZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XHJcbiAgICAgICAgICBvYnNlcnZlci5vbkVycm9yKGV4Y2VwdGlvbik7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChoYXNSZXN1bHQpIHtcclxuICAgICAgICAgIG9ic2VydmVyLm9uTmV4dChyZXN1bHQpO1xyXG4gICAgICAgICAgc2VsZigpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiAgVGhpcyBtZXRob2QgY3JlYXRlcyBhIG5ldyBPYnNlcnZhYmxlIGluc3RhbmNlIHdpdGggYSB2YXJpYWJsZSBudW1iZXIgb2YgYXJndW1lbnRzLCByZWdhcmRsZXNzIG9mIG51bWJlciBvciB0eXBlIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiAgdmFyIHJlcyA9IFJ4Lk9ic2VydmFibGUub2YoMSwyLDMpO1xyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aG9zZSBlbGVtZW50cyBhcmUgcHVsbGVkIGZyb20gdGhlIGdpdmVuIGFyZ3VtZW50cy5cclxuICAgKi9cclxuICBPYnNlcnZhYmxlLm9mID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgeyBhcmdzW2ldID0gYXJndW1lbnRzW2ldOyB9XHJcbiAgICByZXR1cm4gb2JzZXJ2YWJsZUZyb21BcnJheShhcmdzKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiAgVGhpcyBtZXRob2QgY3JlYXRlcyBhIG5ldyBPYnNlcnZhYmxlIGluc3RhbmNlIHdpdGggYSB2YXJpYWJsZSBudW1iZXIgb2YgYXJndW1lbnRzLCByZWdhcmRsZXNzIG9mIG51bWJlciBvciB0eXBlIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiAgdmFyIHJlcyA9IFJ4Lk9ic2VydmFibGUub2YoMSwyLDMpO1xyXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBzY2hlZHVsZXIgQSBzY2hlZHVsZXIgdG8gdXNlIGZvciBzY2hlZHVsaW5nIHRoZSBhcmd1bWVudHMuXHJcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHdob3NlIGVsZW1lbnRzIGFyZSBwdWxsZWQgZnJvbSB0aGUgZ2l2ZW4gYXJndW1lbnRzLlxyXG4gICAqL1xyXG4gIHZhciBvYnNlcnZhYmxlT2YgPSBPYnNlcnZhYmxlLm9mV2l0aFNjaGVkdWxlciA9IGZ1bmN0aW9uIChzY2hlZHVsZXIpIHtcclxuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4pO1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7IGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdOyB9XHJcbiAgICByZXR1cm4gb2JzZXJ2YWJsZUZyb21BcnJheShhcmdzLCBzY2hlZHVsZXIpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqICBSZXR1cm5zIGEgbm9uLXRlcm1pbmF0aW5nIG9ic2VydmFibGUgc2VxdWVuY2UsIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGRlbm90ZSBhbiBpbmZpbml0ZSBkdXJhdGlvbiAoZS5nLiB3aGVuIHVzaW5nIHJlYWN0aXZlIGpvaW5zKS5cclxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aG9zZSBvYnNlcnZlcnMgd2lsbCBuZXZlciBnZXQgY2FsbGVkLlxyXG4gICAqL1xyXG4gIHZhciBvYnNlcnZhYmxlTmV2ZXIgPSBPYnNlcnZhYmxlLm5ldmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIGRpc3Bvc2FibGVFbXB0eTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqICBHZW5lcmF0ZXMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvZiBpbnRlZ3JhbCBudW1iZXJzIHdpdGhpbiBhIHNwZWNpZmllZCByYW5nZSwgdXNpbmcgdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIgdG8gc2VuZCBvdXQgb2JzZXJ2ZXIgbWVzc2FnZXMuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqICB2YXIgcmVzID0gUnguT2JzZXJ2YWJsZS5yYW5nZSgwLCAxMCk7XHJcbiAgICogIHZhciByZXMgPSBSeC5PYnNlcnZhYmxlLnJhbmdlKDAsIDEwLCBSeC5TY2hlZHVsZXIudGltZW91dCk7XHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IFRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgaW50ZWdlciBpbiB0aGUgc2VxdWVuY2UuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IFRoZSBudW1iZXIgb2Ygc2VxdWVudGlhbCBpbnRlZ2VycyB0byBnZW5lcmF0ZS5cclxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gU2NoZWR1bGVyIHRvIHJ1biB0aGUgZ2VuZXJhdG9yIGxvb3Agb24uIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIFNjaGVkdWxlci5jdXJyZW50VGhyZWFkLlxyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgYSByYW5nZSBvZiBzZXF1ZW50aWFsIGludGVncmFsIG51bWJlcnMuXHJcbiAgICovXHJcbiAgT2JzZXJ2YWJsZS5yYW5nZSA9IGZ1bmN0aW9uIChzdGFydCwgY291bnQsIHNjaGVkdWxlcikge1xyXG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gY3VycmVudFRocmVhZFNjaGVkdWxlcik7XHJcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGVSZWN1cnNpdmVXaXRoU3RhdGUoMCwgZnVuY3Rpb24gKGksIHNlbGYpIHtcclxuICAgICAgICBpZiAoaSA8IGNvdW50KSB7XHJcbiAgICAgICAgICBvYnNlcnZlci5vbk5leHQoc3RhcnQgKyBpKTtcclxuICAgICAgICAgIHNlbGYoaSArIDEpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiAgR2VuZXJhdGVzIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCByZXBlYXRzIHRoZSBnaXZlbiBlbGVtZW50IHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHRpbWVzLCB1c2luZyB0aGUgc3BlY2lmaWVkIHNjaGVkdWxlciB0byBzZW5kIG91dCBvYnNlcnZlciBtZXNzYWdlcy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogIHZhciByZXMgPSBSeC5PYnNlcnZhYmxlLnJlcGVhdCg0Mik7XHJcbiAgICogIHZhciByZXMgPSBSeC5PYnNlcnZhYmxlLnJlcGVhdCg0MiwgNCk7XHJcbiAgICogIDMgLSByZXMgPSBSeC5PYnNlcnZhYmxlLnJlcGVhdCg0MiwgNCwgUnguU2NoZWR1bGVyLnRpbWVvdXQpO1xyXG4gICAqICA0IC0gcmVzID0gUnguT2JzZXJ2YWJsZS5yZXBlYXQoNDIsIG51bGwsIFJ4LlNjaGVkdWxlci50aW1lb3V0KTtcclxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBFbGVtZW50IHRvIHJlcGVhdC5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gcmVwZWF0Q291bnQgW09wdGlvbmFdIE51bWJlciBvZiB0aW1lcyB0byByZXBlYXQgdGhlIGVsZW1lbnQuIElmIG5vdCBzcGVjaWZpZWQsIHJlcGVhdHMgaW5kZWZpbml0ZWx5LlxyXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBzY2hlZHVsZXIgU2NoZWR1bGVyIHRvIHJ1biB0aGUgcHJvZHVjZXIgbG9vcCBvbi4gSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gU2NoZWR1bGVyLmltbWVkaWF0ZS5cclxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHJlcGVhdHMgdGhlIGdpdmVuIGVsZW1lbnQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgdGltZXMuXHJcbiAgICovXHJcbiAgT2JzZXJ2YWJsZS5yZXBlYXQgPSBmdW5jdGlvbiAodmFsdWUsIHJlcGVhdENvdW50LCBzY2hlZHVsZXIpIHtcclxuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGN1cnJlbnRUaHJlYWRTY2hlZHVsZXIpO1xyXG4gICAgcmV0dXJuIG9ic2VydmFibGVSZXR1cm4odmFsdWUsIHNjaGVkdWxlcikucmVwZWF0KHJlcGVhdENvdW50ID09IG51bGwgPyAtMSA6IHJlcGVhdENvdW50KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiAgUmV0dXJucyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgYSBzaW5nbGUgZWxlbWVudCwgdXNpbmcgdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIgdG8gc2VuZCBvdXQgb2JzZXJ2ZXIgbWVzc2FnZXMuXHJcbiAgICogIFRoZXJlIGlzIGFuIGFsaWFzIGNhbGxlZCAnanVzdCcsIGFuZCAncmV0dXJuVmFsdWUnIGZvciBicm93c2VycyA8SUU5LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiAgdmFyIHJlcyA9IFJ4Lk9ic2VydmFibGUucmV0dXJuKDQyKTtcclxuICAgKiAgdmFyIHJlcyA9IFJ4Lk9ic2VydmFibGUucmV0dXJuKDQyLCBSeC5TY2hlZHVsZXIudGltZW91dCk7XHJcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgU2luZ2xlIGVsZW1lbnQgaW4gdGhlIHJlc3VsdGluZyBvYnNlcnZhYmxlIHNlcXVlbmNlLlxyXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBzY2hlZHVsZXIgU2NoZWR1bGVyIHRvIHNlbmQgdGhlIHNpbmdsZSBlbGVtZW50IG9uLiBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byBTY2hlZHVsZXIuaW1tZWRpYXRlLlxyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIHNpbmdsZSBzcGVjaWZpZWQgZWxlbWVudC5cclxuICAgKi9cclxuICB2YXIgb2JzZXJ2YWJsZVJldHVybiA9IE9ic2VydmFibGVbJ3JldHVybiddID0gT2JzZXJ2YWJsZS5yZXR1cm5WYWx1ZSA9IE9ic2VydmFibGUuanVzdCA9IGZ1bmN0aW9uICh2YWx1ZSwgc2NoZWR1bGVyKSB7XHJcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBpbW1lZGlhdGVTY2hlZHVsZXIpO1xyXG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBvYnNlcnZlci5vbk5leHQodmFsdWUpO1xyXG4gICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogIFJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHRlcm1pbmF0ZXMgd2l0aCBhbiBleGNlcHRpb24sIHVzaW5nIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVyIHRvIHNlbmQgb3V0IHRoZSBzaW5nbGUgb25FcnJvciBtZXNzYWdlLlxyXG4gICAqICBUaGVyZSBpcyBhbiBhbGlhcyB0byB0aGlzIG1ldGhvZCBjYWxsZWQgJ3Rocm93RXJyb3InIGZvciBicm93c2VycyA8SUU5LlxyXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4Y2VwdGlvbiBBbiBvYmplY3QgdXNlZCBmb3IgdGhlIHNlcXVlbmNlJ3MgdGVybWluYXRpb24uXHJcbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IHNjaGVkdWxlciBTY2hlZHVsZXIgdG8gc2VuZCB0aGUgZXhjZXB0aW9uYWwgdGVybWluYXRpb24gY2FsbCBvbi4gSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gU2NoZWR1bGVyLmltbWVkaWF0ZS5cclxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gVGhlIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCB0ZXJtaW5hdGVzIGV4Y2VwdGlvbmFsbHkgd2l0aCB0aGUgc3BlY2lmaWVkIGV4Y2VwdGlvbiBvYmplY3QuXHJcbiAgICovXHJcbiAgdmFyIG9ic2VydmFibGVUaHJvdyA9IE9ic2VydmFibGVbJ3Rocm93J10gPSBPYnNlcnZhYmxlLnRocm93RXhjZXB0aW9uID0gT2JzZXJ2YWJsZS50aHJvd0Vycm9yID0gZnVuY3Rpb24gKGV4Y2VwdGlvbiwgc2NoZWR1bGVyKSB7XHJcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBpbW1lZGlhdGVTY2hlZHVsZXIpO1xyXG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBvYnNlcnZlci5vbkVycm9yKGV4Y2VwdGlvbik7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RydWN0cyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgZGVwZW5kcyBvbiBhIHJlc291cmNlIG9iamVjdCwgd2hvc2UgbGlmZXRpbWUgaXMgdGllZCB0byB0aGUgcmVzdWx0aW5nIG9ic2VydmFibGUgc2VxdWVuY2UncyBsaWZldGltZS5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvdXJjZUZhY3RvcnkgRmFjdG9yeSBmdW5jdGlvbiB0byBvYnRhaW4gYSByZXNvdXJjZSBvYmplY3QuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb2JzZXJ2YWJsZUZhY3RvcnkgRmFjdG9yeSBmdW5jdGlvbiB0byBvYnRhaW4gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGRlcGVuZHMgb24gdGhlIG9idGFpbmVkIHJlc291cmNlLlxyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdob3NlIGxpZmV0aW1lIGNvbnRyb2xzIHRoZSBsaWZldGltZSBvZiB0aGUgZGVwZW5kZW50IHJlc291cmNlIG9iamVjdC5cclxuICAgKi9cclxuICBPYnNlcnZhYmxlLnVzaW5nID0gZnVuY3Rpb24gKHJlc291cmNlRmFjdG9yeSwgb2JzZXJ2YWJsZUZhY3RvcnkpIHtcclxuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgdmFyIGRpc3Bvc2FibGUgPSBkaXNwb3NhYmxlRW1wdHksIHJlc291cmNlLCBzb3VyY2U7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgcmVzb3VyY2UgPSByZXNvdXJjZUZhY3RvcnkoKTtcclxuICAgICAgICByZXNvdXJjZSAmJiAoZGlzcG9zYWJsZSA9IHJlc291cmNlKTtcclxuICAgICAgICBzb3VyY2UgPSBvYnNlcnZhYmxlRmFjdG9yeShyZXNvdXJjZSk7XHJcbiAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZShvYnNlcnZhYmxlVGhyb3coZXhjZXB0aW9uKS5zdWJzY3JpYmUob2JzZXJ2ZXIpLCBkaXNwb3NhYmxlKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoc291cmNlLnN1YnNjcmliZShvYnNlcnZlciksIGRpc3Bvc2FibGUpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUHJvcGFnYXRlcyB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvciBQcm9taXNlIHRoYXQgcmVhY3RzIGZpcnN0LlxyXG4gICAqIEBwYXJhbSB7T2JzZXJ2YWJsZX0gcmlnaHRTb3VyY2UgU2Vjb25kIG9ic2VydmFibGUgc2VxdWVuY2Ugb3IgUHJvbWlzZS5cclxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0ge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBzdXJmYWNlcyBlaXRoZXIgb2YgdGhlIGdpdmVuIHNlcXVlbmNlcywgd2hpY2hldmVyIHJlYWN0ZWQgZmlyc3QuXHJcbiAgICovXHJcbiAgb2JzZXJ2YWJsZVByb3RvLmFtYiA9IGZ1bmN0aW9uIChyaWdodFNvdXJjZSkge1xyXG4gICAgdmFyIGxlZnRTb3VyY2UgPSB0aGlzO1xyXG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICB2YXIgY2hvaWNlLFxyXG4gICAgICAgIGxlZnRDaG9pY2UgPSAnTCcsIHJpZ2h0Q2hvaWNlID0gJ1InLFxyXG4gICAgICAgIGxlZnRTdWJzY3JpcHRpb24gPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKSxcclxuICAgICAgICByaWdodFN1YnNjcmlwdGlvbiA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xyXG5cclxuICAgICAgaXNQcm9taXNlKHJpZ2h0U291cmNlKSAmJiAocmlnaHRTb3VyY2UgPSBvYnNlcnZhYmxlRnJvbVByb21pc2UocmlnaHRTb3VyY2UpKTtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIGNob2ljZUwoKSB7XHJcbiAgICAgICAgaWYgKCFjaG9pY2UpIHtcclxuICAgICAgICAgIGNob2ljZSA9IGxlZnRDaG9pY2U7XHJcbiAgICAgICAgICByaWdodFN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBjaG9pY2VSKCkge1xyXG4gICAgICAgIGlmICghY2hvaWNlKSB7XHJcbiAgICAgICAgICBjaG9pY2UgPSByaWdodENob2ljZTtcclxuICAgICAgICAgIGxlZnRTdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgbGVmdFN1YnNjcmlwdGlvbi5zZXREaXNwb3NhYmxlKGxlZnRTb3VyY2Uuc3Vic2NyaWJlKGZ1bmN0aW9uIChsZWZ0KSB7XHJcbiAgICAgICAgY2hvaWNlTCgpO1xyXG4gICAgICAgIGlmIChjaG9pY2UgPT09IGxlZnRDaG9pY2UpIHtcclxuICAgICAgICAgIG9ic2VydmVyLm9uTmV4dChsZWZ0KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICBjaG9pY2VMKCk7XHJcbiAgICAgICAgaWYgKGNob2ljZSA9PT0gbGVmdENob2ljZSkge1xyXG4gICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlcnIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNob2ljZUwoKTtcclxuICAgICAgICBpZiAoY2hvaWNlID09PSBsZWZ0Q2hvaWNlKSB7XHJcbiAgICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSkpO1xyXG5cclxuICAgICAgcmlnaHRTdWJzY3JpcHRpb24uc2V0RGlzcG9zYWJsZShyaWdodFNvdXJjZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHJpZ2h0KSB7XHJcbiAgICAgICAgY2hvaWNlUigpO1xyXG4gICAgICAgIGlmIChjaG9pY2UgPT09IHJpZ2h0Q2hvaWNlKSB7XHJcbiAgICAgICAgICBvYnNlcnZlci5vbk5leHQocmlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgIGNob2ljZVIoKTtcclxuICAgICAgICBpZiAoY2hvaWNlID09PSByaWdodENob2ljZSkge1xyXG4gICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlcnIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNob2ljZVIoKTtcclxuICAgICAgICBpZiAoY2hvaWNlID09PSByaWdodENob2ljZSkge1xyXG4gICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pKTtcclxuXHJcbiAgICAgIHJldHVybiBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZShsZWZ0U3Vic2NyaXB0aW9uLCByaWdodFN1YnNjcmlwdGlvbik7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBQcm9wYWdhdGVzIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIG9yIFByb21pc2UgdGhhdCByZWFjdHMgZmlyc3QuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIHZhciA9IFJ4Lk9ic2VydmFibGUuYW1iKHhzLCB5cywgenMpO1xyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgc3VyZmFjZXMgYW55IG9mIHRoZSBnaXZlbiBzZXF1ZW5jZXMsIHdoaWNoZXZlciByZWFjdGVkIGZpcnN0LlxyXG4gICAqL1xyXG4gIE9ic2VydmFibGUuYW1iID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGFjYyA9IG9ic2VydmFibGVOZXZlcigpLFxyXG4gICAgICBpdGVtcyA9IGFyZ3NPckFycmF5KGFyZ3VtZW50cywgMCk7XHJcbiAgICBmdW5jdGlvbiBmdW5jKHByZXZpb3VzLCBjdXJyZW50KSB7XHJcbiAgICAgIHJldHVybiBwcmV2aW91cy5hbWIoY3VycmVudCk7XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgYWNjID0gZnVuYyhhY2MsIGl0ZW1zW2ldKTtcclxuICAgIH1cclxuICAgIHJldHVybiBhY2M7XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gb2JzZXJ2YWJsZUNhdGNoSGFuZGxlcihzb3VyY2UsIGhhbmRsZXIpIHtcclxuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgdmFyIGQxID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCksIHN1YnNjcmlwdGlvbiA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCk7XHJcbiAgICAgIHN1YnNjcmlwdGlvbi5zZXREaXNwb3NhYmxlKGQxKTtcclxuICAgICAgZDEuc2V0RGlzcG9zYWJsZShzb3VyY2Uuc3Vic2NyaWJlKG9ic2VydmVyLm9uTmV4dC5iaW5kKG9ic2VydmVyKSwgZnVuY3Rpb24gKGV4Y2VwdGlvbikge1xyXG4gICAgICAgIHZhciBkLCByZXN1bHQ7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHJlc3VsdCA9IGhhbmRsZXIoZXhjZXB0aW9uKTtcclxuICAgICAgICB9IGNhdGNoIChleCkge1xyXG4gICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihleCk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlzUHJvbWlzZShyZXN1bHQpICYmIChyZXN1bHQgPSBvYnNlcnZhYmxlRnJvbVByb21pc2UocmVzdWx0KSk7XHJcblxyXG4gICAgICAgIGQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcclxuICAgICAgICBzdWJzY3JpcHRpb24uc2V0RGlzcG9zYWJsZShkKTtcclxuICAgICAgICBkLnNldERpc3Bvc2FibGUocmVzdWx0LnN1YnNjcmliZShvYnNlcnZlcikpO1xyXG4gICAgICB9LCBvYnNlcnZlci5vbkNvbXBsZXRlZC5iaW5kKG9ic2VydmVyKSkpO1xyXG5cclxuICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29udGludWVzIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBpcyB0ZXJtaW5hdGVkIGJ5IGFuIGV4Y2VwdGlvbiB3aXRoIHRoZSBuZXh0IG9ic2VydmFibGUgc2VxdWVuY2UuXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiAxIC0geHMuY2F0Y2hFeGNlcHRpb24oeXMpXHJcbiAgICogMiAtIHhzLmNhdGNoRXhjZXB0aW9uKGZ1bmN0aW9uIChleCkgeyByZXR1cm4geXMoZXgpOyB9KVxyXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGhhbmRsZXJPclNlY29uZCBFeGNlcHRpb24gaGFuZGxlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBnaXZlbiB0aGUgZXJyb3IgdGhhdCBvY2N1cnJlZCBpbiB0aGUgZmlyc3Qgc2VxdWVuY2UsIG9yIGEgc2Vjb25kIG9ic2VydmFibGUgc2VxdWVuY2UgdXNlZCB0byBwcm9kdWNlIHJlc3VsdHMgd2hlbiBhbiBlcnJvciBvY2N1cnJlZCBpbiB0aGUgZmlyc3Qgc2VxdWVuY2UuXHJcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyB0aGUgZmlyc3Qgc2VxdWVuY2UncyBlbGVtZW50cywgZm9sbG93ZWQgYnkgdGhlIGVsZW1lbnRzIG9mIHRoZSBoYW5kbGVyIHNlcXVlbmNlIGluIGNhc2UgYW4gZXhjZXB0aW9uIG9jY3VycmVkLlxyXG4gICAqL1xyXG4gIG9ic2VydmFibGVQcm90b1snY2F0Y2gnXSA9IG9ic2VydmFibGVQcm90by5jYXRjaEVycm9yID0gb2JzZXJ2YWJsZVByb3RvLmNhdGNoRXhjZXB0aW9uID0gZnVuY3Rpb24gKGhhbmRsZXJPclNlY29uZCkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBoYW5kbGVyT3JTZWNvbmQgPT09ICdmdW5jdGlvbicgP1xyXG4gICAgICBvYnNlcnZhYmxlQ2F0Y2hIYW5kbGVyKHRoaXMsIGhhbmRsZXJPclNlY29uZCkgOlxyXG4gICAgICBvYnNlcnZhYmxlQ2F0Y2goW3RoaXMsIGhhbmRsZXJPclNlY29uZF0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnRpbnVlcyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgaXMgdGVybWluYXRlZCBieSBhbiBleGNlcHRpb24gd2l0aCB0aGUgbmV4dCBvYnNlcnZhYmxlIHNlcXVlbmNlLlxyXG4gICAqIEBwYXJhbSB7QXJyYXkgfCBBcmd1bWVudHN9IGFyZ3MgQXJndW1lbnRzIG9yIGFuIGFycmF5IHRvIHVzZSBhcyB0aGUgbmV4dCBzZXF1ZW5jZSBpZiBhbiBlcnJvciBvY2N1cnMuXHJcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBlbGVtZW50cyBmcm9tIGNvbnNlY3V0aXZlIHNvdXJjZSBzZXF1ZW5jZXMgdW50aWwgYSBzb3VyY2Ugc2VxdWVuY2UgdGVybWluYXRlcyBzdWNjZXNzZnVsbHkuXHJcbiAgICovXHJcbiAgdmFyIG9ic2VydmFibGVDYXRjaCA9IE9ic2VydmFibGUuY2F0Y2hFeGNlcHRpb24gPSBPYnNlcnZhYmxlLmNhdGNoRXJyb3IgPSBPYnNlcnZhYmxlWydjYXRjaCddID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIGVudW1lcmFibGVPZihhcmdzT3JBcnJheShhcmd1bWVudHMsIDApKS5jYXRjaEV4Y2VwdGlvbigpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIE1lcmdlcyB0aGUgc3BlY2lmaWVkIG9ic2VydmFibGUgc2VxdWVuY2VzIGludG8gb25lIG9ic2VydmFibGUgc2VxdWVuY2UgYnkgdXNpbmcgdGhlIHNlbGVjdG9yIGZ1bmN0aW9uIHdoZW5ldmVyIGFueSBvZiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgb3IgUHJvbWlzZXMgcHJvZHVjZXMgYW4gZWxlbWVudC5cclxuICAgKiBUaGlzIGNhbiBiZSBpbiB0aGUgZm9ybSBvZiBhbiBhcmd1bWVudCBsaXN0IG9mIG9ic2VydmFibGVzIG9yIGFuIGFycmF5LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiAxIC0gb2JzID0gb2JzZXJ2YWJsZS5jb21iaW5lTGF0ZXN0KG9iczEsIG9iczIsIG9iczMsIGZ1bmN0aW9uIChvMSwgbzIsIG8zKSB7IHJldHVybiBvMSArIG8yICsgbzM7IH0pO1xyXG4gICAqIDIgLSBvYnMgPSBvYnNlcnZhYmxlLmNvbWJpbmVMYXRlc3QoW29iczEsIG9iczIsIG9iczNdLCBmdW5jdGlvbiAobzEsIG8yLCBvMykgeyByZXR1cm4gbzEgKyBvMiArIG8zOyB9KTtcclxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIHRoZSByZXN1bHQgb2YgY29tYmluaW5nIGVsZW1lbnRzIG9mIHRoZSBzb3VyY2VzIHVzaW5nIHRoZSBzcGVjaWZpZWQgcmVzdWx0IHNlbGVjdG9yIGZ1bmN0aW9uLlxyXG4gICAqL1xyXG4gIG9ic2VydmFibGVQcm90by5jb21iaW5lTGF0ZXN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzWzBdKSkge1xyXG4gICAgICBhcmdzWzBdLnVuc2hpZnQodGhpcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBhcmdzLnVuc2hpZnQodGhpcyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29tYmluZUxhdGVzdC5hcHBseSh0aGlzLCBhcmdzKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBNZXJnZXMgdGhlIHNwZWNpZmllZCBvYnNlcnZhYmxlIHNlcXVlbmNlcyBpbnRvIG9uZSBvYnNlcnZhYmxlIHNlcXVlbmNlIGJ5IHVzaW5nIHRoZSBzZWxlY3RvciBmdW5jdGlvbiB3aGVuZXZlciBhbnkgb2YgdGhlIG9ic2VydmFibGUgc2VxdWVuY2VzIG9yIFByb21pc2VzIHByb2R1Y2VzIGFuIGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIDEgLSBvYnMgPSBSeC5PYnNlcnZhYmxlLmNvbWJpbmVMYXRlc3Qob2JzMSwgb2JzMiwgb2JzMywgZnVuY3Rpb24gKG8xLCBvMiwgbzMpIHsgcmV0dXJuIG8xICsgbzIgKyBvMzsgfSk7XHJcbiAgICogMiAtIG9icyA9IFJ4Lk9ic2VydmFibGUuY29tYmluZUxhdGVzdChbb2JzMSwgb2JzMiwgb2JzM10sIGZ1bmN0aW9uIChvMSwgbzIsIG8zKSB7IHJldHVybiBvMSArIG8yICsgbzM7IH0pO1xyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIHJlc3VsdCBvZiBjb21iaW5pbmcgZWxlbWVudHMgb2YgdGhlIHNvdXJjZXMgdXNpbmcgdGhlIHNwZWNpZmllZCByZXN1bHQgc2VsZWN0b3IgZnVuY3Rpb24uXHJcbiAgICovXHJcbiAgdmFyIGNvbWJpbmVMYXRlc3QgPSBPYnNlcnZhYmxlLmNvbWJpbmVMYXRlc3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKSwgcmVzdWx0U2VsZWN0b3IgPSBhcmdzLnBvcCgpO1xyXG5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3NbMF0pKSB7XHJcbiAgICAgIGFyZ3MgPSBhcmdzWzBdO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgdmFyIGZhbHNlRmFjdG9yeSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9LFxyXG4gICAgICAgIG4gPSBhcmdzLmxlbmd0aCxcclxuICAgICAgICBoYXNWYWx1ZSA9IGFycmF5SW5pdGlhbGl6ZShuLCBmYWxzZUZhY3RvcnkpLFxyXG4gICAgICAgIGhhc1ZhbHVlQWxsID0gZmFsc2UsXHJcbiAgICAgICAgaXNEb25lID0gYXJyYXlJbml0aWFsaXplKG4sIGZhbHNlRmFjdG9yeSksXHJcbiAgICAgICAgdmFsdWVzID0gbmV3IEFycmF5KG4pO1xyXG5cclxuICAgICAgZnVuY3Rpb24gbmV4dChpKSB7XHJcbiAgICAgICAgdmFyIHJlcztcclxuICAgICAgICBoYXNWYWx1ZVtpXSA9IHRydWU7XHJcbiAgICAgICAgaWYgKGhhc1ZhbHVlQWxsIHx8IChoYXNWYWx1ZUFsbCA9IGhhc1ZhbHVlLmV2ZXJ5KGlkZW50aXR5KSkpIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJlcyA9IHJlc3VsdFNlbGVjdG9yLmFwcGx5KG51bGwsIHZhbHVlcyk7XHJcbiAgICAgICAgICB9IGNhdGNoIChleCkge1xyXG4gICAgICAgICAgICBvYnNlcnZlci5vbkVycm9yKGV4KTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KHJlcyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc0RvbmUuZmlsdGVyKGZ1bmN0aW9uICh4LCBqKSB7IHJldHVybiBqICE9PSBpOyB9KS5ldmVyeShpZGVudGl0eSkpIHtcclxuICAgICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBkb25lIChpKSB7XHJcbiAgICAgICAgaXNEb25lW2ldID0gdHJ1ZTtcclxuICAgICAgICBpZiAoaXNEb25lLmV2ZXJ5KGlkZW50aXR5KSkge1xyXG4gICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBzdWJzY3JpcHRpb25zID0gbmV3IEFycmF5KG4pO1xyXG4gICAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBuOyBpZHgrKykge1xyXG4gICAgICAgIChmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3NbaV0sIHNhZCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xyXG4gICAgICAgICAgaXNQcm9taXNlKHNvdXJjZSkgJiYgKHNvdXJjZSA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShzb3VyY2UpKTtcclxuICAgICAgICAgIHNhZC5zZXREaXNwb3NhYmxlKHNvdXJjZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgdmFsdWVzW2ldID0geDtcclxuICAgICAgICAgICAgbmV4dChpKTtcclxuICAgICAgICAgIH0sIG9ic2VydmVyLm9uRXJyb3IuYmluZChvYnNlcnZlciksIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZG9uZShpKTtcclxuICAgICAgICAgIH0pKTtcclxuICAgICAgICAgIHN1YnNjcmlwdGlvbnNbaV0gPSBzYWQ7XHJcbiAgICAgICAgfShpZHgpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKHN1YnNjcmlwdGlvbnMpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbmNhdGVuYXRlcyBhbGwgdGhlIG9ic2VydmFibGUgc2VxdWVuY2VzLiAgVGhpcyB0YWtlcyBpbiBlaXRoZXIgYW4gYXJyYXkgb3IgdmFyaWFibGUgYXJndW1lbnRzIHRvIGNvbmNhdGVuYXRlLlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAxIC0gY29uY2F0ZW5hdGVkID0geHMuY29uY2F0KHlzLCB6cyk7XHJcbiAgICAgKiAyIC0gY29uY2F0ZW5hdGVkID0geHMuY29uY2F0KFt5cywgenNdKTtcclxuICAgICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIGVsZW1lbnRzIG9mIGVhY2ggZ2l2ZW4gc2VxdWVuY2UsIGluIHNlcXVlbnRpYWwgb3JkZXIuXHJcbiAgICAgKi9cclxuICAgIG9ic2VydmFibGVQcm90by5jb25jYXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGl0ZW1zID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xyXG4gICAgICAgIGl0ZW1zLnVuc2hpZnQodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGVDb25jYXQuYXBwbHkodGhpcywgaXRlbXMpO1xyXG4gICAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ29uY2F0ZW5hdGVzIGFsbCB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMuXHJcbiAgICogQHBhcmFtIHtBcnJheSB8IEFyZ3VtZW50c30gYXJncyBBcmd1bWVudHMgb3IgYW4gYXJyYXkgdG8gY29uY2F0IHRvIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIGVsZW1lbnRzIG9mIGVhY2ggZ2l2ZW4gc2VxdWVuY2UsIGluIHNlcXVlbnRpYWwgb3JkZXIuXHJcbiAgICovXHJcbiAgdmFyIG9ic2VydmFibGVDb25jYXQgPSBPYnNlcnZhYmxlLmNvbmNhdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBlbnVtZXJhYmxlT2YoYXJnc09yQXJyYXkoYXJndW1lbnRzLCAwKSkuY29uY2F0KCk7XHJcbiAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbmNhdGVuYXRlcyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIG9mIG9ic2VydmFibGUgc2VxdWVuY2VzLlxyXG4gICAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyB0aGUgZWxlbWVudHMgb2YgZWFjaCBvYnNlcnZlZCBpbm5lciBzZXF1ZW5jZSwgaW4gc2VxdWVudGlhbCBvcmRlci5cclxuICAgICAqL1xyXG4gICAgb2JzZXJ2YWJsZVByb3RvLmNvbmNhdE9ic2VydmFibGUgPSBvYnNlcnZhYmxlUHJvdG8uY29uY2F0QWxsID1mdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWVyZ2UoMSk7XHJcbiAgICB9O1xyXG5cclxuICAvKipcclxuICAgKiBNZXJnZXMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvZiBvYnNlcnZhYmxlIHNlcXVlbmNlcyBpbnRvIGFuIG9ic2VydmFibGUgc2VxdWVuY2UsIGxpbWl0aW5nIHRoZSBudW1iZXIgb2YgY29uY3VycmVudCBzdWJzY3JpcHRpb25zIHRvIGlubmVyIHNlcXVlbmNlcy5cclxuICAgKiBPciBtZXJnZXMgdHdvIG9ic2VydmFibGUgc2VxdWVuY2VzIGludG8gYSBzaW5nbGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogMSAtIG1lcmdlZCA9IHNvdXJjZXMubWVyZ2UoMSk7XHJcbiAgICogMiAtIG1lcmdlZCA9IHNvdXJjZS5tZXJnZShvdGhlclNvdXJjZSk7XHJcbiAgICogQHBhcmFtIHtNaXhlZH0gW21heENvbmN1cnJlbnRPck90aGVyXSBNYXhpbXVtIG51bWJlciBvZiBpbm5lciBvYnNlcnZhYmxlIHNlcXVlbmNlcyBiZWluZyBzdWJzY3JpYmVkIHRvIGNvbmN1cnJlbnRseSBvciB0aGUgc2Vjb25kIG9ic2VydmFibGUgc2VxdWVuY2UuXHJcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgbWVyZ2VzIHRoZSBlbGVtZW50cyBvZiB0aGUgaW5uZXIgc2VxdWVuY2VzLlxyXG4gICAqL1xyXG4gIG9ic2VydmFibGVQcm90by5tZXJnZSA9IGZ1bmN0aW9uIChtYXhDb25jdXJyZW50T3JPdGhlcikge1xyXG4gICAgaWYgKHR5cGVvZiBtYXhDb25jdXJyZW50T3JPdGhlciAhPT0gJ251bWJlcicpIHsgcmV0dXJuIG9ic2VydmFibGVNZXJnZSh0aGlzLCBtYXhDb25jdXJyZW50T3JPdGhlcik7IH1cclxuICAgIHZhciBzb3VyY2VzID0gdGhpcztcclxuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgdmFyIGFjdGl2ZUNvdW50ID0gMCwgZ3JvdXAgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpLCBpc1N0b3BwZWQgPSBmYWxzZSwgcSA9IFtdO1xyXG5cclxuICAgICAgZnVuY3Rpb24gc3Vic2NyaWJlKHhzKSB7XHJcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xyXG4gICAgICAgIGdyb3VwLmFkZChzdWJzY3JpcHRpb24pO1xyXG5cclxuICAgICAgICAvLyBDaGVjayBmb3IgcHJvbWlzZXMgc3VwcG9ydFxyXG4gICAgICAgIGlzUHJvbWlzZSh4cykgJiYgKHhzID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHhzKSk7XHJcblxyXG4gICAgICAgIHN1YnNjcmlwdGlvbi5zZXREaXNwb3NhYmxlKHhzLnN1YnNjcmliZShvYnNlcnZlci5vbk5leHQuYmluZChvYnNlcnZlciksIG9ic2VydmVyLm9uRXJyb3IuYmluZChvYnNlcnZlciksIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGdyb3VwLnJlbW92ZShzdWJzY3JpcHRpb24pO1xyXG4gICAgICAgICAgaWYgKHEubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBzdWJzY3JpYmUocS5zaGlmdCgpKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGFjdGl2ZUNvdW50LS07XHJcbiAgICAgICAgICAgIGlzU3RvcHBlZCAmJiBhY3RpdmVDb3VudCA9PT0gMCAmJiBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pKTtcclxuICAgICAgfVxyXG4gICAgICBncm91cC5hZGQoc291cmNlcy5zdWJzY3JpYmUoZnVuY3Rpb24gKGlubmVyU291cmNlKSB7XHJcbiAgICAgICAgaWYgKGFjdGl2ZUNvdW50IDwgbWF4Q29uY3VycmVudE9yT3RoZXIpIHtcclxuICAgICAgICAgIGFjdGl2ZUNvdW50Kys7XHJcbiAgICAgICAgICBzdWJzY3JpYmUoaW5uZXJTb3VyY2UpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBxLnB1c2goaW5uZXJTb3VyY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSwgb2JzZXJ2ZXIub25FcnJvci5iaW5kKG9ic2VydmVyKSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlzU3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgYWN0aXZlQ291bnQgPT09IDAgJiYgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgfSkpO1xyXG4gICAgICByZXR1cm4gZ3JvdXA7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWVyZ2VzIGFsbCB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaW50byBhIHNpbmdsZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxyXG4gICAgICogVGhlIHNjaGVkdWxlciBpcyBvcHRpb25hbCBhbmQgaWYgbm90IHNwZWNpZmllZCwgdGhlIGltbWVkaWF0ZSBzY2hlZHVsZXIgaXMgdXNlZC5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogMSAtIG1lcmdlZCA9IFJ4Lk9ic2VydmFibGUubWVyZ2UoeHMsIHlzLCB6cyk7XHJcbiAgICAgKiAyIC0gbWVyZ2VkID0gUnguT2JzZXJ2YWJsZS5tZXJnZShbeHMsIHlzLCB6c10pO1xyXG4gICAgICogMyAtIG1lcmdlZCA9IFJ4Lk9ic2VydmFibGUubWVyZ2Uoc2NoZWR1bGVyLCB4cywgeXMsIHpzKTtcclxuICAgICAqIDQgLSBtZXJnZWQgPSBSeC5PYnNlcnZhYmxlLm1lcmdlKHNjaGVkdWxlciwgW3hzLCB5cywgenNdKTtcclxuICAgICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IG1lcmdlcyB0aGUgZWxlbWVudHMgb2YgdGhlIG9ic2VydmFibGUgc2VxdWVuY2VzLlxyXG4gICAgICovXHJcbiAgICB2YXIgb2JzZXJ2YWJsZU1lcmdlID0gT2JzZXJ2YWJsZS5tZXJnZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2NoZWR1bGVyLCBzb3VyY2VzO1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzWzBdKSB7XHJcbiAgICAgICAgICAgIHNjaGVkdWxlciA9IGltbWVkaWF0ZVNjaGVkdWxlcjtcclxuICAgICAgICAgICAgc291cmNlcyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXS5ub3cpIHtcclxuICAgICAgICAgICAgc2NoZWR1bGVyID0gYXJndW1lbnRzWzBdO1xyXG4gICAgICAgICAgICBzb3VyY2VzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNjaGVkdWxlciA9IGltbWVkaWF0ZVNjaGVkdWxlcjtcclxuICAgICAgICAgICAgc291cmNlcyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlc1swXSkpIHtcclxuICAgICAgICAgICAgc291cmNlcyA9IHNvdXJjZXNbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlRnJvbUFycmF5KHNvdXJjZXMsIHNjaGVkdWxlcikubWVyZ2VPYnNlcnZhYmxlKCk7XHJcbiAgICB9O1xyXG5cclxuICAvKipcclxuICAgKiBNZXJnZXMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvZiBvYnNlcnZhYmxlIHNlcXVlbmNlcyBpbnRvIGFuIG9ic2VydmFibGUgc2VxdWVuY2UuXHJcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgbWVyZ2VzIHRoZSBlbGVtZW50cyBvZiB0aGUgaW5uZXIgc2VxdWVuY2VzLlxyXG4gICAqL1xyXG4gIG9ic2VydmFibGVQcm90by5tZXJnZU9ic2VydmFibGUgPSBvYnNlcnZhYmxlUHJvdG8ubWVyZ2VBbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgc291cmNlcyA9IHRoaXM7XHJcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgIHZhciBncm91cCA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCksXHJcbiAgICAgICAgaXNTdG9wcGVkID0gZmFsc2UsXHJcbiAgICAgICAgbSA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xyXG5cclxuICAgICAgZ3JvdXAuYWRkKG0pO1xyXG4gICAgICBtLnNldERpc3Bvc2FibGUoc291cmNlcy5zdWJzY3JpYmUoZnVuY3Rpb24gKGlubmVyU291cmNlKSB7XHJcbiAgICAgICAgdmFyIGlubmVyU3Vic2NyaXB0aW9uID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XHJcbiAgICAgICAgZ3JvdXAuYWRkKGlubmVyU3Vic2NyaXB0aW9uKTtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgZm9yIHByb21pc2VzIHN1cHBvcnRcclxuICAgICAgICBpc1Byb21pc2UoaW5uZXJTb3VyY2UpICYmIChpbm5lclNvdXJjZSA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShpbm5lclNvdXJjZSkpO1xyXG5cclxuICAgICAgICBpbm5lclN1YnNjcmlwdGlvbi5zZXREaXNwb3NhYmxlKGlubmVyU291cmNlLnN1YnNjcmliZShvYnNlcnZlci5vbk5leHQuYmluZChvYnNlcnZlciksIG9ic2VydmVyLm9uRXJyb3IuYmluZChvYnNlcnZlciksIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGdyb3VwLnJlbW92ZShpbm5lclN1YnNjcmlwdGlvbik7XHJcbiAgICAgICAgICBpc1N0b3BwZWQgJiYgZ3JvdXAubGVuZ3RoID09PSAxICYmIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICB9LCBvYnNlcnZlci5vbkVycm9yLmJpbmQob2JzZXJ2ZXIpLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaXNTdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICBncm91cC5sZW5ndGggPT09IDEgJiYgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgfSkpO1xyXG4gICAgICByZXR1cm4gZ3JvdXA7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDb250aW51ZXMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGlzIHRlcm1pbmF0ZWQgbm9ybWFsbHkgb3IgYnkgYW4gZXhjZXB0aW9uIHdpdGggdGhlIG5leHQgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cclxuICAgKiBAcGFyYW0ge09ic2VydmFibGV9IHNlY29uZCBTZWNvbmQgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB1c2VkIHRvIHByb2R1Y2UgcmVzdWx0cyBhZnRlciB0aGUgZmlyc3Qgc2VxdWVuY2UgdGVybWluYXRlcy5cclxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGNvbmNhdGVuYXRlcyB0aGUgZmlyc3QgYW5kIHNlY29uZCBzZXF1ZW5jZSwgZXZlbiBpZiB0aGUgZmlyc3Qgc2VxdWVuY2UgdGVybWluYXRlcyBleGNlcHRpb25hbGx5LlxyXG4gICAqL1xyXG4gIG9ic2VydmFibGVQcm90by5vbkVycm9yUmVzdW1lTmV4dCA9IGZ1bmN0aW9uIChzZWNvbmQpIHtcclxuICAgIGlmICghc2Vjb25kKSB7IHRocm93IG5ldyBFcnJvcignU2Vjb25kIG9ic2VydmFibGUgaXMgcmVxdWlyZWQnKTsgfVxyXG4gICAgcmV0dXJuIG9uRXJyb3JSZXN1bWVOZXh0KFt0aGlzLCBzZWNvbmRdKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDb250aW51ZXMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGlzIHRlcm1pbmF0ZWQgbm9ybWFsbHkgb3IgYnkgYW4gZXhjZXB0aW9uIHdpdGggdGhlIG5leHQgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogMSAtIHJlcyA9IFJ4Lk9ic2VydmFibGUub25FcnJvclJlc3VtZU5leHQoeHMsIHlzLCB6cyk7XHJcbiAgICogMSAtIHJlcyA9IFJ4Lk9ic2VydmFibGUub25FcnJvclJlc3VtZU5leHQoW3hzLCB5cywgenNdKTtcclxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGNvbmNhdGVuYXRlcyB0aGUgc291cmNlIHNlcXVlbmNlcywgZXZlbiBpZiBhIHNlcXVlbmNlIHRlcm1pbmF0ZXMgZXhjZXB0aW9uYWxseS5cclxuICAgKi9cclxuICB2YXIgb25FcnJvclJlc3VtZU5leHQgPSBPYnNlcnZhYmxlLm9uRXJyb3JSZXN1bWVOZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHNvdXJjZXMgPSBhcmdzT3JBcnJheShhcmd1bWVudHMsIDApO1xyXG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICB2YXIgcG9zID0gMCwgc3Vic2NyaXB0aW9uID0gbmV3IFNlcmlhbERpc3Bvc2FibGUoKSxcclxuICAgICAgY2FuY2VsYWJsZSA9IGltbWVkaWF0ZVNjaGVkdWxlci5zY2hlZHVsZVJlY3Vyc2l2ZShmdW5jdGlvbiAoc2VsZikge1xyXG4gICAgICAgIHZhciBjdXJyZW50LCBkO1xyXG4gICAgICAgIGlmIChwb3MgPCBzb3VyY2VzLmxlbmd0aCkge1xyXG4gICAgICAgICAgY3VycmVudCA9IHNvdXJjZXNbcG9zKytdO1xyXG4gICAgICAgICAgaXNQcm9taXNlKGN1cnJlbnQpICYmIChjdXJyZW50ID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKGN1cnJlbnQpKTtcclxuICAgICAgICAgIGQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcclxuICAgICAgICAgIHN1YnNjcmlwdGlvbi5zZXREaXNwb3NhYmxlKGQpO1xyXG4gICAgICAgICAgZC5zZXREaXNwb3NhYmxlKGN1cnJlbnQuc3Vic2NyaWJlKG9ic2VydmVyLm9uTmV4dC5iaW5kKG9ic2VydmVyKSwgc2VsZiwgc2VsZikpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZShzdWJzY3JpcHRpb24sIGNhbmNlbGFibGUpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgdmFsdWVzIGZyb20gdGhlIHNvdXJjZSBvYnNlcnZhYmxlIHNlcXVlbmNlIG9ubHkgYWZ0ZXIgdGhlIG90aGVyIG9ic2VydmFibGUgc2VxdWVuY2UgcHJvZHVjZXMgYSB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge09ic2VydmFibGUgfCBQcm9taXNlfSBvdGhlciBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvciBQcm9taXNlIHRoYXQgdHJpZ2dlcnMgcHJvcGFnYXRpb24gb2YgZWxlbWVudHMgb2YgdGhlIHNvdXJjZSBzZXF1ZW5jZS5cclxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIHRoZSBlbGVtZW50cyBvZiB0aGUgc291cmNlIHNlcXVlbmNlIHN0YXJ0aW5nIGZyb20gdGhlIHBvaW50IHRoZSBvdGhlciBzZXF1ZW5jZSB0cmlnZ2VyZWQgcHJvcGFnYXRpb24uXHJcbiAgICovXHJcbiAgb2JzZXJ2YWJsZVByb3RvLnNraXBVbnRpbCA9IGZ1bmN0aW9uIChvdGhlcikge1xyXG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XHJcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgIHZhciBpc09wZW4gPSBmYWxzZTtcclxuICAgICAgdmFyIGRpc3Bvc2FibGVzID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoc291cmNlLnN1YnNjcmliZShmdW5jdGlvbiAobGVmdCkge1xyXG4gICAgICAgIGlzT3BlbiAmJiBvYnNlcnZlci5vbk5leHQobGVmdCk7XHJcbiAgICAgIH0sIG9ic2VydmVyLm9uRXJyb3IuYmluZChvYnNlcnZlciksIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpc09wZW4gJiYgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgfSkpO1xyXG5cclxuICAgICAgaXNQcm9taXNlKG90aGVyKSAmJiAob3RoZXIgPSBvYnNlcnZhYmxlRnJvbVByb21pc2Uob3RoZXIpKTtcclxuXHJcbiAgICAgIHZhciByaWdodFN1YnNjcmlwdGlvbiA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xyXG4gICAgICBkaXNwb3NhYmxlcy5hZGQocmlnaHRTdWJzY3JpcHRpb24pO1xyXG4gICAgICByaWdodFN1YnNjcmlwdGlvbi5zZXREaXNwb3NhYmxlKG90aGVyLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaXNPcGVuID0gdHJ1ZTtcclxuICAgICAgICByaWdodFN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XHJcbiAgICAgIH0sIG9ic2VydmVyLm9uRXJyb3IuYmluZChvYnNlcnZlciksIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByaWdodFN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XHJcbiAgICAgIH0pKTtcclxuXHJcbiAgICAgIHJldHVybiBkaXNwb3NhYmxlcztcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybXMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvZiBvYnNlcnZhYmxlIHNlcXVlbmNlcyBpbnRvIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgcHJvZHVjaW5nIHZhbHVlcyBvbmx5IGZyb20gdGhlIG1vc3QgcmVjZW50IG9ic2VydmFibGUgc2VxdWVuY2UuXHJcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgYXQgYW55IHBvaW50IGluIHRpbWUgcHJvZHVjZXMgdGhlIGVsZW1lbnRzIG9mIHRoZSBtb3N0IHJlY2VudCBpbm5lciBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgaGFzIGJlZW4gcmVjZWl2ZWQuXHJcbiAgICovXHJcbiAgb2JzZXJ2YWJsZVByb3RvWydzd2l0Y2gnXSA9IG9ic2VydmFibGVQcm90by5zd2l0Y2hMYXRlc3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgc291cmNlcyA9IHRoaXM7XHJcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgIHZhciBoYXNMYXRlc3QgPSBmYWxzZSxcclxuICAgICAgICBpbm5lclN1YnNjcmlwdGlvbiA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCksXHJcbiAgICAgICAgaXNTdG9wcGVkID0gZmFsc2UsXHJcbiAgICAgICAgbGF0ZXN0ID0gMCxcclxuICAgICAgICBzdWJzY3JpcHRpb24gPSBzb3VyY2VzLnN1YnNjcmliZShcclxuICAgICAgICAgIGZ1bmN0aW9uIChpbm5lclNvdXJjZSkge1xyXG4gICAgICAgICAgICB2YXIgZCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpLCBpZCA9ICsrbGF0ZXN0O1xyXG4gICAgICAgICAgICBoYXNMYXRlc3QgPSB0cnVlO1xyXG4gICAgICAgICAgICBpbm5lclN1YnNjcmlwdGlvbi5zZXREaXNwb3NhYmxlKGQpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgUHJvbWlzZSBvciBPYnNlcnZhYmxlXHJcbiAgICAgICAgICAgIGlzUHJvbWlzZShpbm5lclNvdXJjZSkgJiYgKGlubmVyU291cmNlID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKGlubmVyU291cmNlKSk7XHJcblxyXG4gICAgICAgICAgICBkLnNldERpc3Bvc2FibGUoaW5uZXJTb3VyY2Uuc3Vic2NyaWJlKFxyXG4gICAgICAgICAgICAgIGZ1bmN0aW9uICh4KSB7IGxhdGVzdCA9PT0gaWQgJiYgb2JzZXJ2ZXIub25OZXh0KHgpOyB9LFxyXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIChlKSB7IGxhdGVzdCA9PT0gaWQgJiYgb2JzZXJ2ZXIub25FcnJvcihlKTsgfSxcclxuICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGF0ZXN0ID09PSBpZCkge1xyXG4gICAgICAgICAgICAgICAgICBoYXNMYXRlc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgaXNTdG9wcGVkICYmIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IuYmluZChvYnNlcnZlciksXHJcbiAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlzU3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICFoYXNMYXRlc3QgJiYgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoc3Vic2NyaXB0aW9uLCBpbm5lclN1YnNjcmlwdGlvbik7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZXMgZnJvbSB0aGUgc291cmNlIG9ic2VydmFibGUgc2VxdWVuY2UgdW50aWwgdGhlIG90aGVyIG9ic2VydmFibGUgc2VxdWVuY2UgcHJvZHVjZXMgYSB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge09ic2VydmFibGUgfCBQcm9taXNlfSBvdGhlciBPYnNlcnZhYmxlIHNlcXVlbmNlIG9yIFByb21pc2UgdGhhdCB0ZXJtaW5hdGVzIHByb3BhZ2F0aW9uIG9mIGVsZW1lbnRzIG9mIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXHJcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyB0aGUgZWxlbWVudHMgb2YgdGhlIHNvdXJjZSBzZXF1ZW5jZSB1cCB0byB0aGUgcG9pbnQgdGhlIG90aGVyIHNlcXVlbmNlIGludGVycnVwdGVkIGZ1cnRoZXIgcHJvcGFnYXRpb24uXHJcbiAgICovXHJcbiAgb2JzZXJ2YWJsZVByb3RvLnRha2VVbnRpbCA9IGZ1bmN0aW9uIChvdGhlcikge1xyXG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XHJcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgIGlzUHJvbWlzZShvdGhlcikgJiYgKG90aGVyID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKG90aGVyKSk7XHJcbiAgICAgIHJldHVybiBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZShcclxuICAgICAgICBzb3VyY2Uuc3Vic2NyaWJlKG9ic2VydmVyKSxcclxuICAgICAgICBvdGhlci5zdWJzY3JpYmUob2JzZXJ2ZXIub25Db21wbGV0ZWQuYmluZChvYnNlcnZlciksIG9ic2VydmVyLm9uRXJyb3IuYmluZChvYnNlcnZlciksIG5vb3ApXHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiB6aXBBcnJheShzZWNvbmQsIHJlc3VsdFNlbGVjdG9yKSB7XHJcbiAgICB2YXIgZmlyc3QgPSB0aGlzO1xyXG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICB2YXIgaW5kZXggPSAwLCBsZW4gPSBzZWNvbmQubGVuZ3RoO1xyXG4gICAgICByZXR1cm4gZmlyc3Quc3Vic2NyaWJlKGZ1bmN0aW9uIChsZWZ0KSB7XHJcbiAgICAgICAgaWYgKGluZGV4IDwgbGVuKSB7XHJcbiAgICAgICAgICB2YXIgcmlnaHQgPSBzZWNvbmRbaW5kZXgrK10sIHJlc3VsdDtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdFNlbGVjdG9yKGxlZnQsIHJpZ2h0KTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KHJlc3VsdCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LCBvYnNlcnZlci5vbkVycm9yLmJpbmQob2JzZXJ2ZXIpLCBvYnNlcnZlci5vbkNvbXBsZXRlZC5iaW5kKG9ic2VydmVyKSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1lcmdlcyB0aGUgc3BlY2lmaWVkIG9ic2VydmFibGUgc2VxdWVuY2VzIGludG8gb25lIG9ic2VydmFibGUgc2VxdWVuY2UgYnkgdXNpbmcgdGhlIHNlbGVjdG9yIGZ1bmN0aW9uIHdoZW5ldmVyIGFsbCBvZiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgb3IgYW4gYXJyYXkgaGF2ZSBwcm9kdWNlZCBhbiBlbGVtZW50IGF0IGEgY29ycmVzcG9uZGluZyBpbmRleC5cclxuICAgKiBUaGUgbGFzdCBlbGVtZW50IGluIHRoZSBhcmd1bWVudHMgbXVzdCBiZSBhIGZ1bmN0aW9uIHRvIGludm9rZSBmb3IgZWFjaCBzZXJpZXMgb2YgZWxlbWVudHMgYXQgY29ycmVzcG9uZGluZyBpbmRleGVzIGluIHRoZSBzb3VyY2VzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiAxIC0gcmVzID0gb2JzMS56aXAob2JzMiwgZm4pO1xyXG4gICAqIDEgLSByZXMgPSB4MS56aXAoWzEsMiwzXSwgZm4pO1xyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIHJlc3VsdCBvZiBjb21iaW5pbmcgZWxlbWVudHMgb2YgdGhlIHNvdXJjZXMgdXNpbmcgdGhlIHNwZWNpZmllZCByZXN1bHQgc2VsZWN0b3IgZnVuY3Rpb24uXHJcbiAgICovXHJcbiAgb2JzZXJ2YWJsZVByb3RvLnppcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcclxuICAgICAgcmV0dXJuIHppcEFycmF5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcbiAgICB2YXIgcGFyZW50ID0gdGhpcywgc291cmNlcyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKSwgcmVzdWx0U2VsZWN0b3IgPSBzb3VyY2VzLnBvcCgpO1xyXG4gICAgc291cmNlcy51bnNoaWZ0KHBhcmVudCk7XHJcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgIHZhciBuID0gc291cmNlcy5sZW5ndGgsXHJcbiAgICAgICAgcXVldWVzID0gYXJyYXlJbml0aWFsaXplKG4sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9KSxcclxuICAgICAgICBpc0RvbmUgPSBhcnJheUluaXRpYWxpemUobiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH0pO1xyXG5cclxuICAgICAgZnVuY3Rpb24gbmV4dChpKSB7XHJcbiAgICAgICAgdmFyIHJlcywgcXVldWVkVmFsdWVzO1xyXG4gICAgICAgIGlmIChxdWV1ZXMuZXZlcnkoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgubGVuZ3RoID4gMDsgfSkpIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHF1ZXVlZFZhbHVlcyA9IHF1ZXVlcy5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguc2hpZnQoKTsgfSk7XHJcbiAgICAgICAgICAgIHJlcyA9IHJlc3VsdFNlbGVjdG9yLmFwcGx5KHBhcmVudCwgcXVldWVkVmFsdWVzKTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZXgpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBvYnNlcnZlci5vbk5leHQocmVzKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGlzRG9uZS5maWx0ZXIoZnVuY3Rpb24gKHgsIGopIHsgcmV0dXJuIGogIT09IGk7IH0pLmV2ZXJ5KGlkZW50aXR5KSkge1xyXG4gICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBmdW5jdGlvbiBkb25lKGkpIHtcclxuICAgICAgICBpc0RvbmVbaV0gPSB0cnVlO1xyXG4gICAgICAgIGlmIChpc0RvbmUuZXZlcnkoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0pKSB7XHJcbiAgICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHN1YnNjcmlwdGlvbnMgPSBuZXcgQXJyYXkobik7XHJcbiAgICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IG47IGlkeCsrKSB7XHJcbiAgICAgICAgKGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICB2YXIgc291cmNlID0gc291cmNlc1tpXSwgc2FkID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XHJcbiAgICAgICAgICBpc1Byb21pc2Uoc291cmNlKSAmJiAoc291cmNlID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHNvdXJjZSkpO1xyXG4gICAgICAgICAgc2FkLnNldERpc3Bvc2FibGUoc291cmNlLnN1YnNjcmliZShmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICBxdWV1ZXNbaV0ucHVzaCh4KTtcclxuICAgICAgICAgICAgbmV4dChpKTtcclxuICAgICAgICAgIH0sIG9ic2VydmVyLm9uRXJyb3IuYmluZChvYnNlcnZlciksIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZG9uZShpKTtcclxuICAgICAgICAgIH0pKTtcclxuICAgICAgICAgIHN1YnNjcmlwdGlvbnNbaV0gPSBzYWQ7XHJcbiAgICAgICAgfSkoaWR4KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKHN1YnNjcmlwdGlvbnMpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogTWVyZ2VzIHRoZSBzcGVjaWZpZWQgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaW50byBvbmUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBieSB1c2luZyB0aGUgc2VsZWN0b3IgZnVuY3Rpb24gd2hlbmV2ZXIgYWxsIG9mIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlcyBoYXZlIHByb2R1Y2VkIGFuIGVsZW1lbnQgYXQgYSBjb3JyZXNwb25kaW5nIGluZGV4LlxyXG4gICAqIEBwYXJhbSBhcmd1bWVudHMgT2JzZXJ2YWJsZSBzb3VyY2VzLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc3VsdFNlbGVjdG9yIEZ1bmN0aW9uIHRvIGludm9rZSBmb3IgZWFjaCBzZXJpZXMgb2YgZWxlbWVudHMgYXQgY29ycmVzcG9uZGluZyBpbmRleGVzIGluIHRoZSBzb3VyY2VzLlxyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIHJlc3VsdCBvZiBjb21iaW5pbmcgZWxlbWVudHMgb2YgdGhlIHNvdXJjZXMgdXNpbmcgdGhlIHNwZWNpZmllZCByZXN1bHQgc2VsZWN0b3IgZnVuY3Rpb24uXHJcbiAgICovXHJcbiAgT2JzZXJ2YWJsZS56aXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSwgZmlyc3QgPSBhcmdzLnNoaWZ0KCk7XHJcbiAgICByZXR1cm4gZmlyc3QuemlwLmFwcGx5KGZpcnN0LCBhcmdzKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBNZXJnZXMgdGhlIHNwZWNpZmllZCBvYnNlcnZhYmxlIHNlcXVlbmNlcyBpbnRvIG9uZSBvYnNlcnZhYmxlIHNlcXVlbmNlIGJ5IGVtaXR0aW5nIGEgbGlzdCB3aXRoIHRoZSBlbGVtZW50cyBvZiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgYXQgY29ycmVzcG9uZGluZyBpbmRleGVzLlxyXG4gICAqIEBwYXJhbSBhcmd1bWVudHMgT2JzZXJ2YWJsZSBzb3VyY2VzLlxyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgbGlzdHMgb2YgZWxlbWVudHMgYXQgY29ycmVzcG9uZGluZyBpbmRleGVzLlxyXG4gICAqL1xyXG4gIE9ic2VydmFibGUuemlwQXJyYXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgc291cmNlcyA9IGFyZ3NPckFycmF5KGFyZ3VtZW50cywgMCk7XHJcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgIHZhciBuID0gc291cmNlcy5sZW5ndGgsXHJcbiAgICAgICAgcXVldWVzID0gYXJyYXlJbml0aWFsaXplKG4sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9KSxcclxuICAgICAgICBpc0RvbmUgPSBhcnJheUluaXRpYWxpemUobiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH0pO1xyXG5cclxuICAgICAgZnVuY3Rpb24gbmV4dChpKSB7XHJcbiAgICAgICAgaWYgKHF1ZXVlcy5ldmVyeShmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5sZW5ndGggPiAwOyB9KSkge1xyXG4gICAgICAgICAgdmFyIHJlcyA9IHF1ZXVlcy5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguc2hpZnQoKTsgfSk7XHJcbiAgICAgICAgICBvYnNlcnZlci5vbk5leHQocmVzKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGlzRG9uZS5maWx0ZXIoZnVuY3Rpb24gKHgsIGopIHsgcmV0dXJuIGogIT09IGk7IH0pLmV2ZXJ5KGlkZW50aXR5KSkge1xyXG4gICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBmdW5jdGlvbiBkb25lKGkpIHtcclxuICAgICAgICBpc0RvbmVbaV0gPSB0cnVlO1xyXG4gICAgICAgIGlmIChpc0RvbmUuZXZlcnkoaWRlbnRpdHkpKSB7XHJcbiAgICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHN1YnNjcmlwdGlvbnMgPSBuZXcgQXJyYXkobik7XHJcbiAgICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IG47IGlkeCsrKSB7XHJcbiAgICAgICAgKGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICBzdWJzY3JpcHRpb25zW2ldID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XHJcbiAgICAgICAgICBzdWJzY3JpcHRpb25zW2ldLnNldERpc3Bvc2FibGUoc291cmNlc1tpXS5zdWJzY3JpYmUoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgcXVldWVzW2ldLnB1c2goeCk7XHJcbiAgICAgICAgICAgIG5leHQoaSk7XHJcbiAgICAgICAgICB9LCBvYnNlcnZlci5vbkVycm9yLmJpbmQob2JzZXJ2ZXIpLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGRvbmUoaSk7XHJcbiAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfSkoaWR4KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGNvbXBvc2l0ZURpc3Bvc2FibGUgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZShzdWJzY3JpcHRpb25zKTtcclxuICAgICAgY29tcG9zaXRlRGlzcG9zYWJsZS5hZGQoZGlzcG9zYWJsZUNyZWF0ZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgcUlkeCA9IDAsIHFMZW4gPSBxdWV1ZXMubGVuZ3RoOyBxSWR4IDwgcUxlbjsgcUlkeCsrKSB7IHF1ZXVlc1txSWR4XSA9IFtdOyB9XHJcbiAgICAgIH0pKTtcclxuICAgICAgcmV0dXJuIGNvbXBvc2l0ZURpc3Bvc2FibGU7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiAgSGlkZXMgdGhlIGlkZW50aXR5IG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UuXHJcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBoaWRlcyB0aGUgaWRlbnRpdHkgb2YgdGhlIHNvdXJjZSBzZXF1ZW5jZS5cclxuICAgKi9cclxuICBvYnNlcnZhYmxlUHJvdG8uYXNPYnNlcnZhYmxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKHRoaXMuc3Vic2NyaWJlLmJpbmQodGhpcykpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqICBQcm9qZWN0cyBlYWNoIGVsZW1lbnQgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBpbnRvIHplcm8gb3IgbW9yZSBidWZmZXJzIHdoaWNoIGFyZSBwcm9kdWNlZCBiYXNlZCBvbiBlbGVtZW50IGNvdW50IGluZm9ybWF0aW9uLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiAgdmFyIHJlcyA9IHhzLmJ1ZmZlcldpdGhDb3VudCgxMCk7XHJcbiAgICogIHZhciByZXMgPSB4cy5idWZmZXJXaXRoQ291bnQoMTAsIDEpO1xyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBMZW5ndGggb2YgZWFjaCBidWZmZXIuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtza2lwXSBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBiZXR3ZWVuIGNyZWF0aW9uIG9mIGNvbnNlY3V0aXZlIGJ1ZmZlcnMuIElmIG5vdCBwcm92aWRlZCwgZGVmYXVsdHMgdG8gdGhlIGNvdW50LlxyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIG9mIGJ1ZmZlcnMuXHJcbiAgICovXHJcbiAgb2JzZXJ2YWJsZVByb3RvLmJ1ZmZlcldpdGhDb3VudCA9IGZ1bmN0aW9uIChjb3VudCwgc2tpcCkge1xyXG4gICAgaWYgKHR5cGVvZiBza2lwICE9PSAnbnVtYmVyJykge1xyXG4gICAgICBza2lwID0gY291bnQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy53aW5kb3dXaXRoQ291bnQoY291bnQsIHNraXApLnNlbGVjdE1hbnkoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgcmV0dXJuIHgudG9BcnJheSgpO1xyXG4gICAgfSkud2hlcmUoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgcmV0dXJuIHgubGVuZ3RoID4gMDtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZW1hdGVyaWFsaXplcyB0aGUgZXhwbGljaXQgbm90aWZpY2F0aW9uIHZhbHVlcyBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGFzIGltcGxpY2l0IG5vdGlmaWNhdGlvbnMuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBleGhpYml0aW5nIHRoZSBiZWhhdmlvciBjb3JyZXNwb25kaW5nIHRvIHRoZSBzb3VyY2Ugc2VxdWVuY2UncyBub3RpZmljYXRpb24gdmFsdWVzLlxyXG4gICAgICovXHJcbiAgICBvYnNlcnZhYmxlUHJvdG8uZGVtYXRlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc291cmNlID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geC5hY2NlcHQob2JzZXJ2ZXIpO1xyXG4gICAgICAgICAgICB9LCBvYnNlcnZlci5vbkVycm9yLmJpbmQob2JzZXJ2ZXIpLCBvYnNlcnZlci5vbkNvbXBsZXRlZC5iaW5kKG9ic2VydmVyKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGNvbnRhaW5zIG9ubHkgZGlzdGluY3QgY29udGlndW91cyBlbGVtZW50cyBhY2NvcmRpbmcgdG8gdGhlIGtleVNlbGVjdG9yIGFuZCB0aGUgY29tcGFyZXIuXHJcbiAgICAgKlxyXG4gICAgICogIHZhciBvYnMgPSBvYnNlcnZhYmxlLmRpc3RpbmN0VW50aWxDaGFuZ2VkKCk7XHJcbiAgICAgKiAgdmFyIG9icyA9IG9ic2VydmFibGUuZGlzdGluY3RVbnRpbENoYW5nZWQoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguaWQ7IH0pO1xyXG4gICAgICogIHZhciBvYnMgPSBvYnNlcnZhYmxlLmRpc3RpbmN0VW50aWxDaGFuZ2VkKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmlkOyB9LCBmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4geCA9PT0geTsgfSk7XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2tleVNlbGVjdG9yXSBBIGZ1bmN0aW9uIHRvIGNvbXB1dGUgdGhlIGNvbXBhcmlzb24ga2V5IGZvciBlYWNoIGVsZW1lbnQuIElmIG5vdCBwcm92aWRlZCwgaXQgcHJvamVjdHMgdGhlIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmVyXSBFcXVhbGl0eSBjb21wYXJlciBmb3IgY29tcHV0ZWQga2V5IHZhbHVlcy4gSWYgbm90IHByb3ZpZGVkLCBkZWZhdWx0cyB0byBhbiBlcXVhbGl0eSBjb21wYXJlciBmdW5jdGlvbi5cclxuICAgICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIG9ubHkgY29udGFpbmluZyB0aGUgZGlzdGluY3QgY29udGlndW91cyBlbGVtZW50cywgYmFzZWQgb24gYSBjb21wdXRlZCBrZXkgdmFsdWUsIGZyb20gdGhlIHNvdXJjZSBzZXF1ZW5jZS5cclxuICAgICAqL1xyXG4gICAgb2JzZXJ2YWJsZVByb3RvLmRpc3RpbmN0VW50aWxDaGFuZ2VkID0gZnVuY3Rpb24gKGtleVNlbGVjdG9yLCBjb21wYXJlcikge1xyXG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzO1xyXG4gICAgICAgIGtleVNlbGVjdG9yIHx8IChrZXlTZWxlY3RvciA9IGlkZW50aXR5KTtcclxuICAgICAgICBjb21wYXJlciB8fCAoY29tcGFyZXIgPSBkZWZhdWx0Q29tcGFyZXIpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgdmFyIGhhc0N1cnJlbnRLZXkgPSBmYWxzZSwgY3VycmVudEtleTtcclxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29tcGFyZXJFcXVhbHMgPSBmYWxzZSwga2V5O1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBrZXkgPSBrZXlTZWxlY3Rvcih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5vbkVycm9yKGV4Y2VwdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGhhc0N1cnJlbnRLZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wYXJlckVxdWFscyA9IGNvbXBhcmVyKGN1cnJlbnRLZXksIGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZXhjZXB0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghaGFzQ3VycmVudEtleSB8fCAhY29tcGFyZXJFcXVhbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXNDdXJyZW50S2V5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50S2V5ID0ga2V5O1xyXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm9uTmV4dCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIG9ic2VydmVyLm9uRXJyb3IuYmluZChvYnNlcnZlciksIG9ic2VydmVyLm9uQ29tcGxldGVkLmJpbmQob2JzZXJ2ZXIpKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gIC8qKlxyXG4gICAqICBJbnZva2VzIGFuIGFjdGlvbiBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIGFuZCBpbnZva2VzIGFuIGFjdGlvbiB1cG9uIGdyYWNlZnVsIG9yIGV4Y2VwdGlvbmFsIHRlcm1pbmF0aW9uIG9mIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxyXG4gICAqICBUaGlzIG1ldGhvZCBjYW4gYmUgdXNlZCBmb3IgZGVidWdnaW5nLCBsb2dnaW5nLCBldGMuIG9mIHF1ZXJ5IGJlaGF2aW9yIGJ5IGludGVyY2VwdGluZyB0aGUgbWVzc2FnZSBzdHJlYW0gdG8gcnVuIGFyYml0cmFyeSBhY3Rpb25zIGZvciBtZXNzYWdlcyBvbiB0aGUgcGlwZWxpbmUuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbiB8IE9ic2VydmVyfSBvYnNlcnZlck9yT25OZXh0IEFjdGlvbiB0byBpbnZva2UgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvciBhbiBvYnNlcnZlci5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25FcnJvcl0gIEFjdGlvbiB0byBpbnZva2UgdXBvbiBleGNlcHRpb25hbCB0ZXJtaW5hdGlvbiBvZiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS4gVXNlZCBpZiBvbmx5IHRoZSBvYnNlcnZlck9yT25OZXh0IHBhcmFtZXRlciBpcyBhbHNvIGEgZnVuY3Rpb24uXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uQ29tcGxldGVkXSAgQWN0aW9uIHRvIGludm9rZSB1cG9uIGdyYWNlZnVsIHRlcm1pbmF0aW9uIG9mIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLiBVc2VkIGlmIG9ubHkgdGhlIG9ic2VydmVyT3JPbk5leHQgcGFyYW1ldGVyIGlzIGFsc28gYSBmdW5jdGlvbi5cclxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gVGhlIHNvdXJjZSBzZXF1ZW5jZSB3aXRoIHRoZSBzaWRlLWVmZmVjdGluZyBiZWhhdmlvciBhcHBsaWVkLlxyXG4gICAqL1xyXG4gIG9ic2VydmFibGVQcm90b1snZG8nXSA9IG9ic2VydmFibGVQcm90by5kb0FjdGlvbiA9IG9ic2VydmFibGVQcm90by50YXAgPSBmdW5jdGlvbiAob2JzZXJ2ZXJPck9uTmV4dCwgb25FcnJvciwgb25Db21wbGV0ZWQpIHtcclxuICAgIHZhciBzb3VyY2UgPSB0aGlzLCBvbk5leHRGdW5jO1xyXG4gICAgaWYgKHR5cGVvZiBvYnNlcnZlck9yT25OZXh0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIG9uTmV4dEZ1bmMgPSBvYnNlcnZlck9yT25OZXh0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgb25OZXh0RnVuYyA9IG9ic2VydmVyT3JPbk5leHQub25OZXh0LmJpbmQob2JzZXJ2ZXJPck9uTmV4dCk7XHJcbiAgICAgIG9uRXJyb3IgPSBvYnNlcnZlck9yT25OZXh0Lm9uRXJyb3IuYmluZChvYnNlcnZlck9yT25OZXh0KTtcclxuICAgICAgb25Db21wbGV0ZWQgPSBvYnNlcnZlck9yT25OZXh0Lm9uQ29tcGxldGVkLmJpbmQob2JzZXJ2ZXJPck9uTmV4dCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIG9uTmV4dEZ1bmMoeCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb2JzZXJ2ZXIub25OZXh0KHgpO1xyXG4gICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgaWYgKG9uRXJyb3IpIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIG9uRXJyb3IoZXJyKTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlcnIpO1xyXG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKG9uQ29tcGxldGVkKSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBvbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBvYnNlcnZlci5vbkVycm9yKGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqICBJbnZva2VzIGFuIGFjdGlvbiBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxyXG4gICAqICBUaGlzIG1ldGhvZCBjYW4gYmUgdXNlZCBmb3IgZGVidWdnaW5nLCBsb2dnaW5nLCBldGMuIG9mIHF1ZXJ5IGJlaGF2aW9yIGJ5IGludGVyY2VwdGluZyB0aGUgbWVzc2FnZSBzdHJlYW0gdG8gcnVuIGFyYml0cmFyeSBhY3Rpb25zIGZvciBtZXNzYWdlcyBvbiB0aGUgcGlwZWxpbmUuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25OZXh0IEFjdGlvbiB0byBpbnZva2UgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cclxuICAgKiBAcGFyYW0ge0FueX0gW3RoaXNBcmddIE9iamVjdCB0byB1c2UgYXMgdGhpcyB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cclxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gVGhlIHNvdXJjZSBzZXF1ZW5jZSB3aXRoIHRoZSBzaWRlLWVmZmVjdGluZyBiZWhhdmlvciBhcHBsaWVkLlxyXG4gICAqL1xyXG4gIG9ic2VydmFibGVQcm90by5kb09uTmV4dCA9IG9ic2VydmFibGVQcm90by50YXBPbk5leHQgPSBmdW5jdGlvbiAob25OZXh0LCB0aGlzQXJnKSB7XHJcbiAgICByZXR1cm4gdGhpcy50YXAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiA/IGZ1bmN0aW9uICh4KSB7IG9uTmV4dC5jYWxsKHRoaXNBcmcsIHgpOyB9IDogb25OZXh0KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiAgSW52b2tlcyBhbiBhY3Rpb24gdXBvbiBleGNlcHRpb25hbCB0ZXJtaW5hdGlvbiBvZiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cclxuICAgKiAgVGhpcyBtZXRob2QgY2FuIGJlIHVzZWQgZm9yIGRlYnVnZ2luZywgbG9nZ2luZywgZXRjLiBvZiBxdWVyeSBiZWhhdmlvciBieSBpbnRlcmNlcHRpbmcgdGhlIG1lc3NhZ2Ugc3RyZWFtIHRvIHJ1biBhcmJpdHJhcnkgYWN0aW9ucyBmb3IgbWVzc2FnZXMgb24gdGhlIHBpcGVsaW5lLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uRXJyb3IgQWN0aW9uIHRvIGludm9rZSB1cG9uIGV4Y2VwdGlvbmFsIHRlcm1pbmF0aW9uIG9mIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxyXG4gICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyB0aGlzIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgc291cmNlIHNlcXVlbmNlIHdpdGggdGhlIHNpZGUtZWZmZWN0aW5nIGJlaGF2aW9yIGFwcGxpZWQuXHJcbiAgICovXHJcbiAgb2JzZXJ2YWJsZVByb3RvLmRvT25FcnJvciA9IG9ic2VydmFibGVQcm90by50YXBPbkVycm9yID0gZnVuY3Rpb24gKG9uRXJyb3IsIHRoaXNBcmcpIHtcclxuICAgIHJldHVybiB0aGlzLnRhcChub29wLCBhcmd1bWVudHMubGVuZ3RoID09PSAyID8gZnVuY3Rpb24gKGUpIHsgb25FcnJvci5jYWxsKHRoaXNBcmcsIGUpOyB9IDogb25FcnJvcik7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogIEludm9rZXMgYW4gYWN0aW9uIHVwb24gZ3JhY2VmdWwgdGVybWluYXRpb24gb2YgdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuXHJcbiAgICogIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIGZvciBkZWJ1Z2dpbmcsIGxvZ2dpbmcsIGV0Yy4gb2YgcXVlcnkgYmVoYXZpb3IgYnkgaW50ZXJjZXB0aW5nIHRoZSBtZXNzYWdlIHN0cmVhbSB0byBydW4gYXJiaXRyYXJ5IGFjdGlvbnMgZm9yIG1lc3NhZ2VzIG9uIHRoZSBwaXBlbGluZS5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbkNvbXBsZXRlZCBBY3Rpb24gdG8gaW52b2tlIHVwb24gZ3JhY2VmdWwgdGVybWluYXRpb24gb2YgdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuXHJcbiAgICogQHBhcmFtIHtBbnl9IFt0aGlzQXJnXSBPYmplY3QgdG8gdXNlIGFzIHRoaXMgd2hlbiBleGVjdXRpbmcgY2FsbGJhY2suXHJcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBzb3VyY2Ugc2VxdWVuY2Ugd2l0aCB0aGUgc2lkZS1lZmZlY3RpbmcgYmVoYXZpb3IgYXBwbGllZC5cclxuICAgKi9cclxuICBvYnNlcnZhYmxlUHJvdG8uZG9PbkNvbXBsZXRlZCA9IG9ic2VydmFibGVQcm90by50YXBPbkNvbXBsZXRlZCA9IGZ1bmN0aW9uIChvbkNvbXBsZXRlZCwgdGhpc0FyZykge1xyXG4gICAgcmV0dXJuIHRoaXMudGFwKG5vb3AsIG51bGwsIGFyZ3VtZW50cy5sZW5ndGggPT09IDIgPyBmdW5jdGlvbiAoKSB7IG9uQ29tcGxldGVkLmNhbGwodGhpc0FyZyk7IH0gOiBvbkNvbXBsZXRlZCk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogIEludm9rZXMgYSBzcGVjaWZpZWQgYWN0aW9uIGFmdGVyIHRoZSBzb3VyY2Ugb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0ZXJtaW5hdGVzIGdyYWNlZnVsbHkgb3IgZXhjZXB0aW9uYWxseS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogIHZhciByZXMgPSBvYnNlcnZhYmxlLmZpbmFsbHlBY3Rpb24oZnVuY3Rpb24gKCkgeyBjb25zb2xlLmxvZygnc2VxdWVuY2UgZW5kZWQnOyB9KTtcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmaW5hbGx5QWN0aW9uIEFjdGlvbiB0byBpbnZva2UgYWZ0ZXIgdGhlIHNvdXJjZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRlcm1pbmF0ZXMuXHJcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFNvdXJjZSBzZXF1ZW5jZSB3aXRoIHRoZSBhY3Rpb24taW52b2tpbmcgdGVybWluYXRpb24gYmVoYXZpb3IgYXBwbGllZC5cclxuICAgKi9cclxuICBvYnNlcnZhYmxlUHJvdG9bJ2ZpbmFsbHknXSA9IG9ic2VydmFibGVQcm90by5maW5hbGx5QWN0aW9uID0gZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XHJcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgIHZhciBzdWJzY3JpcHRpb247XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgc3Vic2NyaXB0aW9uID0gc291cmNlLnN1YnNjcmliZShvYnNlcnZlcik7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBhY3Rpb24oKTtcclxuICAgICAgICB0aHJvdyBlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBkaXNwb3NhYmxlQ3JlYXRlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgc3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICBhY3Rpb24oKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogIElnbm9yZXMgYWxsIGVsZW1lbnRzIGluIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgbGVhdmluZyBvbmx5IHRoZSB0ZXJtaW5hdGlvbiBtZXNzYWdlcy5cclxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gZW1wdHkgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHNpZ25hbHMgdGVybWluYXRpb24sIHN1Y2Nlc3NmdWwgb3IgZXhjZXB0aW9uYWwsIG9mIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXHJcbiAgICovXHJcbiAgb2JzZXJ2YWJsZVByb3RvLmlnbm9yZUVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XHJcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5vb3AsIG9ic2VydmVyLm9uRXJyb3IuYmluZChvYnNlcnZlciksIG9ic2VydmVyLm9uQ29tcGxldGVkLmJpbmQob2JzZXJ2ZXIpKTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqICBNYXRlcmlhbGl6ZXMgdGhlIGltcGxpY2l0IG5vdGlmaWNhdGlvbnMgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBhcyBleHBsaWNpdCBub3RpZmljYXRpb24gdmFsdWVzLlxyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIG1hdGVyaWFsaXplZCBub3RpZmljYXRpb24gdmFsdWVzIGZyb20gdGhlIHNvdXJjZSBzZXF1ZW5jZS5cclxuICAgKi9cclxuICBvYnNlcnZhYmxlUHJvdG8ubWF0ZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgc291cmNlID0gdGhpcztcclxuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgb2JzZXJ2ZXIub25OZXh0KG5vdGlmaWNhdGlvbkNyZWF0ZU9uTmV4dCh2YWx1ZSkpO1xyXG4gICAgICB9LCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIG9ic2VydmVyLm9uTmV4dChub3RpZmljYXRpb25DcmVhdGVPbkVycm9yKGUpKTtcclxuICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgb2JzZXJ2ZXIub25OZXh0KG5vdGlmaWNhdGlvbkNyZWF0ZU9uQ29tcGxldGVkKCkpO1xyXG4gICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqICBSZXBlYXRzIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIGEgc3BlY2lmaWVkIG51bWJlciBvZiB0aW1lcy4gSWYgdGhlIHJlcGVhdCBjb3VudCBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgc2VxdWVuY2UgcmVwZWF0cyBpbmRlZmluaXRlbHkuXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICB2YXIgcmVzID0gcmVwZWF0ZWQgPSBzb3VyY2UucmVwZWF0KCk7XHJcbiAgICAgKiAgdmFyIHJlcyA9IHJlcGVhdGVkID0gc291cmNlLnJlcGVhdCg0Mik7XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3JlcGVhdENvdW50XSAgTnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCB0aGUgc2VxdWVuY2UuIElmIG5vdCBwcm92aWRlZCwgcmVwZWF0cyB0aGUgc2VxdWVuY2UgaW5kZWZpbml0ZWx5LlxyXG4gICAgICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHByb2R1Y2luZyB0aGUgZWxlbWVudHMgb2YgdGhlIGdpdmVuIHNlcXVlbmNlIHJlcGVhdGVkbHkuXHJcbiAgICAgKi9cclxuICAgIG9ic2VydmFibGVQcm90by5yZXBlYXQgPSBmdW5jdGlvbiAocmVwZWF0Q291bnQpIHtcclxuICAgICAgICByZXR1cm4gZW51bWVyYWJsZVJlcGVhdCh0aGlzLCByZXBlYXRDb3VudCkuY29uY2F0KCk7XHJcbiAgICB9O1xyXG5cclxuICAvKipcclxuICAgKiAgUmVwZWF0cyB0aGUgc291cmNlIG9ic2VydmFibGUgc2VxdWVuY2UgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgdGltZXMgb3IgdW50aWwgaXQgc3VjY2Vzc2Z1bGx5IHRlcm1pbmF0ZXMuIElmIHRoZSByZXRyeSBjb3VudCBpcyBub3Qgc3BlY2lmaWVkLCBpdCByZXRyaWVzIGluZGVmaW5pdGVseS5cclxuICAgKiAgTm90ZSBpZiB5b3UgZW5jb3VudGVyIGFuIGVycm9yIGFuZCB3YW50IGl0IHRvIHJldHJ5IG9uY2UsIHRoZW4geW91IG11c3QgdXNlIC5yZXRyeSgyKTtcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogIHZhciByZXMgPSByZXRyaWVkID0gcmV0cnkucmVwZWF0KCk7XHJcbiAgICogIHZhciByZXMgPSByZXRyaWVkID0gcmV0cnkucmVwZWF0KDIpO1xyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcmV0cnlDb3VudF0gIE51bWJlciBvZiB0aW1lcyB0byByZXRyeSB0aGUgc2VxdWVuY2UuIElmIG5vdCBwcm92aWRlZCwgcmV0cnkgdGhlIHNlcXVlbmNlIGluZGVmaW5pdGVseS5cclxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBwcm9kdWNpbmcgdGhlIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBzZXF1ZW5jZSByZXBlYXRlZGx5IHVudGlsIGl0IHRlcm1pbmF0ZXMgc3VjY2Vzc2Z1bGx5LlxyXG4gICAqL1xyXG4gIG9ic2VydmFibGVQcm90by5yZXRyeSA9IGZ1bmN0aW9uIChyZXRyeUNvdW50KSB7XHJcbiAgICByZXR1cm4gZW51bWVyYWJsZVJlcGVhdCh0aGlzLCByZXRyeUNvdW50KS5jYXRjaEV4Y2VwdGlvbigpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqICBBcHBsaWVzIGFuIGFjY3VtdWxhdG9yIGZ1bmN0aW9uIG92ZXIgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBhbmQgcmV0dXJucyBlYWNoIGludGVybWVkaWF0ZSByZXN1bHQuIFRoZSBvcHRpb25hbCBzZWVkIHZhbHVlIGlzIHVzZWQgYXMgdGhlIGluaXRpYWwgYWNjdW11bGF0b3IgdmFsdWUuXHJcbiAgICogIEZvciBhZ2dyZWdhdGlvbiBiZWhhdmlvciB3aXRoIG5vIGludGVybWVkaWF0ZSByZXN1bHRzLCBzZWUgT2JzZXJ2YWJsZS5hZ2dyZWdhdGUuXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiAgdmFyIHJlcyA9IHNvdXJjZS5zY2FuKGZ1bmN0aW9uIChhY2MsIHgpIHsgcmV0dXJuIGFjYyArIHg7IH0pO1xyXG4gICAqICB2YXIgcmVzID0gc291cmNlLnNjYW4oMCwgZnVuY3Rpb24gKGFjYywgeCkgeyByZXR1cm4gYWNjICsgeDsgfSk7XHJcbiAgICogQHBhcmFtIHtNaXhlZH0gW3NlZWRdIFRoZSBpbml0aWFsIGFjY3VtdWxhdG9yIHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGFjY3VtdWxhdG9yIEFuIGFjY3VtdWxhdG9yIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgb24gZWFjaCBlbGVtZW50LlxyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIGFjY3VtdWxhdGVkIHZhbHVlcy5cclxuICAgKi9cclxuICBvYnNlcnZhYmxlUHJvdG8uc2NhbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBoYXNTZWVkID0gZmFsc2UsIHNlZWQsIGFjY3VtdWxhdG9yLCBzb3VyY2UgPSB0aGlzO1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcclxuICAgICAgaGFzU2VlZCA9IHRydWU7XHJcbiAgICAgIHNlZWQgPSBhcmd1bWVudHNbMF07XHJcbiAgICAgIGFjY3VtdWxhdG9yID0gYXJndW1lbnRzWzFdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYWNjdW11bGF0b3IgPSBhcmd1bWVudHNbMF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgIHZhciBoYXNBY2N1bXVsYXRpb24sIGFjY3VtdWxhdGlvbiwgaGFzVmFsdWU7XHJcbiAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlIChcclxuICAgICAgICBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgIWhhc1ZhbHVlICYmIChoYXNWYWx1ZSA9IHRydWUpO1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGhhc0FjY3VtdWxhdGlvbikge1xyXG4gICAgICAgICAgICAgIGFjY3VtdWxhdGlvbiA9IGFjY3VtdWxhdG9yKGFjY3VtdWxhdGlvbiwgeCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgYWNjdW11bGF0aW9uID0gaGFzU2VlZCA/IGFjY3VtdWxhdG9yKHNlZWQsIHgpIDogeDtcclxuICAgICAgICAgICAgICBoYXNBY2N1bXVsYXRpb24gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBvYnNlcnZlci5vbk5leHQoYWNjdW11bGF0aW9uKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9ic2VydmVyLm9uRXJyb3IuYmluZChvYnNlcnZlciksXHJcbiAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgIWhhc1ZhbHVlICYmIGhhc1NlZWQgJiYgb2JzZXJ2ZXIub25OZXh0KHNlZWQpO1xyXG4gICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiAgQnlwYXNzZXMgYSBzcGVjaWZpZWQgbnVtYmVyIG9mIGVsZW1lbnRzIGF0IHRoZSBlbmQgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgVGhpcyBvcGVyYXRvciBhY2N1bXVsYXRlcyBhIHF1ZXVlIHdpdGggYSBsZW5ndGggZW5vdWdoIHRvIHN0b3JlIHRoZSBmaXJzdCBgY291bnRgIGVsZW1lbnRzLiBBcyBtb3JlIGVsZW1lbnRzIGFyZVxyXG4gICAqICByZWNlaXZlZCwgZWxlbWVudHMgYXJlIHRha2VuIGZyb20gdGhlIGZyb250IG9mIHRoZSBxdWV1ZSBhbmQgcHJvZHVjZWQgb24gdGhlIHJlc3VsdCBzZXF1ZW5jZS4gVGhpcyBjYXVzZXMgZWxlbWVudHMgdG8gYmUgZGVsYXllZC5cclxuICAgKiBAcGFyYW0gY291bnQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIGJ5cGFzcyBhdCB0aGUgZW5kIG9mIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXHJcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyB0aGUgc291cmNlIHNlcXVlbmNlIGVsZW1lbnRzIGV4Y2VwdCBmb3IgdGhlIGJ5cGFzc2VkIG9uZXMgYXQgdGhlIGVuZC5cclxuICAgKi9cclxuICBvYnNlcnZhYmxlUHJvdG8uc2tpcExhc3QgPSBmdW5jdGlvbiAoY291bnQpIHtcclxuICAgIHZhciBzb3VyY2UgPSB0aGlzO1xyXG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICB2YXIgcSA9IFtdO1xyXG4gICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIHEucHVzaCh4KTtcclxuICAgICAgICBxLmxlbmd0aCA+IGNvdW50ICYmIG9ic2VydmVyLm9uTmV4dChxLnNoaWZ0KCkpO1xyXG4gICAgICB9LCBvYnNlcnZlci5vbkVycm9yLmJpbmQob2JzZXJ2ZXIpLCBvYnNlcnZlci5vbkNvbXBsZXRlZC5iaW5kKG9ic2VydmVyKSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiAgUHJlcGVuZHMgYSBzZXF1ZW5jZSBvZiB2YWx1ZXMgdG8gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIGFuIG9wdGlvbmFsIHNjaGVkdWxlciBhbmQgYW4gYXJndW1lbnQgbGlzdCBvZiB2YWx1ZXMgdG8gcHJlcGVuZC5cclxuICAgKiAgQGV4YW1wbGVcclxuICAgKiAgdmFyIHJlcyA9IHNvdXJjZS5zdGFydFdpdGgoMSwgMiwgMyk7XHJcbiAgICogIHZhciByZXMgPSBzb3VyY2Uuc3RhcnRXaXRoKFJ4LlNjaGVkdWxlci50aW1lb3V0LCAxLCAyLCAzKTtcclxuICAgKiBAcGFyYW0ge0FyZ3VtZW50c30gYXJncyBUaGUgc3BlY2lmaWVkIHZhbHVlcyB0byBwcmVwZW5kIHRvIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlXHJcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBzb3VyY2Ugc2VxdWVuY2UgcHJlcGVuZGVkIHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZXMuXHJcbiAgICovXHJcbiAgb2JzZXJ2YWJsZVByb3RvLnN0YXJ0V2l0aCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB2YWx1ZXMsIHNjaGVkdWxlciwgc3RhcnQgPSAwO1xyXG4gICAgaWYgKCEhYXJndW1lbnRzLmxlbmd0aCAmJiBpc1NjaGVkdWxlcihhcmd1bWVudHNbMF0pKSB7XHJcbiAgICAgIHNjaGVkdWxlciA9IGFyZ3VtZW50c1swXTtcclxuICAgICAgc3RhcnQgPSAxO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc2NoZWR1bGVyID0gaW1tZWRpYXRlU2NoZWR1bGVyO1xyXG4gICAgfVxyXG4gICAgdmFsdWVzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIHN0YXJ0KTtcclxuICAgIHJldHVybiBlbnVtZXJhYmxlT2YoW29ic2VydmFibGVGcm9tQXJyYXkodmFsdWVzLCBzY2hlZHVsZXIpLCB0aGlzXSkuY29uY2F0KCk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogIFJldHVybnMgYSBzcGVjaWZpZWQgbnVtYmVyIG9mIGNvbnRpZ3VvdXMgZWxlbWVudHMgZnJvbSB0aGUgZW5kIG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UuXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogIFRoaXMgb3BlcmF0b3IgYWNjdW11bGF0ZXMgYSBidWZmZXIgd2l0aCBhIGxlbmd0aCBlbm91Z2ggdG8gc3RvcmUgZWxlbWVudHMgY291bnQgZWxlbWVudHMuIFVwb24gY29tcGxldGlvbiBvZlxyXG4gICAqICB0aGUgc291cmNlIHNlcXVlbmNlLCB0aGlzIGJ1ZmZlciBpcyBkcmFpbmVkIG9uIHRoZSByZXN1bHQgc2VxdWVuY2UuIFRoaXMgY2F1c2VzIHRoZSBlbGVtZW50cyB0byBiZSBkZWxheWVkLlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gdGFrZSBmcm9tIHRoZSBlbmQgb2YgdGhlIHNvdXJjZSBzZXF1ZW5jZS5cclxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGVsZW1lbnRzIGZyb20gdGhlIGVuZCBvZiB0aGUgc291cmNlIHNlcXVlbmNlLlxyXG4gICAqL1xyXG4gIG9ic2VydmFibGVQcm90by50YWtlTGFzdCA9IGZ1bmN0aW9uIChjb3VudCkge1xyXG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XHJcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgIHZhciBxID0gW107XHJcbiAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgcS5wdXNoKHgpO1xyXG4gICAgICAgIHEubGVuZ3RoID4gY291bnQgJiYgcS5zaGlmdCgpO1xyXG4gICAgICB9LCBvYnNlcnZlci5vbkVycm9yLmJpbmQob2JzZXJ2ZXIpLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgd2hpbGUocS5sZW5ndGggPiAwKSB7IG9ic2VydmVyLm9uTmV4dChxLnNoaWZ0KCkpOyB9XHJcbiAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiAgUmV0dXJucyBhbiBhcnJheSB3aXRoIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGNvbnRpZ3VvdXMgZWxlbWVudHMgZnJvbSB0aGUgZW5kIG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UuXHJcbiAgICpcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgVGhpcyBvcGVyYXRvciBhY2N1bXVsYXRlcyBhIGJ1ZmZlciB3aXRoIGEgbGVuZ3RoIGVub3VnaCB0byBzdG9yZSBjb3VudCBlbGVtZW50cy4gVXBvbiBjb21wbGV0aW9uIG9mIHRoZVxyXG4gICAqICBzb3VyY2Ugc2VxdWVuY2UsIHRoaXMgYnVmZmVyIGlzIHByb2R1Y2VkIG9uIHRoZSByZXN1bHQgc2VxdWVuY2UuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiBlbGVtZW50cyB0byB0YWtlIGZyb20gdGhlIGVuZCBvZiB0aGUgc291cmNlIHNlcXVlbmNlLlxyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgYSBzaW5nbGUgYXJyYXkgd2l0aCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBlbGVtZW50cyBmcm9tIHRoZSBlbmQgb2YgdGhlIHNvdXJjZSBzZXF1ZW5jZS5cclxuICAgKi9cclxuICBvYnNlcnZhYmxlUHJvdG8udGFrZUxhc3RCdWZmZXIgPSBmdW5jdGlvbiAoY291bnQpIHtcclxuICAgIHZhciBzb3VyY2UgPSB0aGlzO1xyXG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICB2YXIgcSA9IFtdO1xyXG4gICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIHEucHVzaCh4KTtcclxuICAgICAgICBxLmxlbmd0aCA+IGNvdW50ICYmIHEuc2hpZnQoKTtcclxuICAgICAgfSwgb2JzZXJ2ZXIub25FcnJvci5iaW5kKG9ic2VydmVyKSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIG9ic2VydmVyLm9uTmV4dChxKTtcclxuICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqICBQcm9qZWN0cyBlYWNoIGVsZW1lbnQgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBpbnRvIHplcm8gb3IgbW9yZSB3aW5kb3dzIHdoaWNoIGFyZSBwcm9kdWNlZCBiYXNlZCBvbiBlbGVtZW50IGNvdW50IGluZm9ybWF0aW9uLlxyXG4gICAqXHJcbiAgICogIHZhciByZXMgPSB4cy53aW5kb3dXaXRoQ291bnQoMTApO1xyXG4gICAqICB2YXIgcmVzID0geHMud2luZG93V2l0aENvdW50KDEwLCAxKTtcclxuICAgKiBAcGFyYW0ge051bWJlcn0gY291bnQgTGVuZ3RoIG9mIGVhY2ggd2luZG93LlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbc2tpcF0gTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYmV0d2VlbiBjcmVhdGlvbiBvZiBjb25zZWN1dGl2ZSB3aW5kb3dzLiBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byB0aGUgY291bnQuXHJcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugb2Ygd2luZG93cy5cclxuICAgKi9cclxuICBvYnNlcnZhYmxlUHJvdG8ud2luZG93V2l0aENvdW50ID0gZnVuY3Rpb24gKGNvdW50LCBza2lwKSB7XHJcbiAgICB2YXIgc291cmNlID0gdGhpcztcclxuICAgICtjb3VudCB8fCAoY291bnQgPSAwKTtcclxuICAgIE1hdGguYWJzKGNvdW50KSA9PT0gSW5maW5pdHkgJiYgKGNvdW50ID0gMCk7XHJcbiAgICBpZiAoY291bnQgPD0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoYXJndW1lbnRPdXRPZlJhbmdlKTsgfVxyXG4gICAgc2tpcCA9PSBudWxsICYmIChza2lwID0gY291bnQpO1xyXG4gICAgK3NraXAgfHwgKHNraXAgPSAwKTtcclxuICAgIE1hdGguYWJzKHNraXApID09PSBJbmZpbml0eSAmJiAoc2tpcCA9IDApO1xyXG5cclxuICAgIGlmIChza2lwIDw9IDApIHsgdGhyb3cgbmV3IEVycm9yKGFyZ3VtZW50T3V0T2ZSYW5nZSk7IH1cclxuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgdmFyIG0gPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKSxcclxuICAgICAgICByZWZDb3VudERpc3Bvc2FibGUgPSBuZXcgUmVmQ291bnREaXNwb3NhYmxlKG0pLFxyXG4gICAgICAgIG4gPSAwLFxyXG4gICAgICAgIHEgPSBbXTtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZVdpbmRvdyAoKSB7XHJcbiAgICAgICAgdmFyIHMgPSBuZXcgU3ViamVjdCgpO1xyXG4gICAgICAgIHEucHVzaChzKTtcclxuICAgICAgICBvYnNlcnZlci5vbk5leHQoYWRkUmVmKHMsIHJlZkNvdW50RGlzcG9zYWJsZSkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjcmVhdGVXaW5kb3coKTtcclxuXHJcbiAgICAgIG0uc2V0RGlzcG9zYWJsZShzb3VyY2Uuc3Vic2NyaWJlKFxyXG4gICAgICAgIGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcS5sZW5ndGg7IGkgPCBsZW47IGkrKykgeyBxW2ldLm9uTmV4dCh4KTsgfVxyXG4gICAgICAgICAgdmFyIGMgPSBuIC0gY291bnQgKyAxO1xyXG4gICAgICAgICAgYyA+PTAgJiYgYyAlIHNraXAgPT09IDAgJiYgcS5zaGlmdCgpLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgICAgICArK24gJSBza2lwID09PSAwICYmIGNyZWF0ZVdpbmRvdygpO1xyXG4gICAgICAgIH0sIFxyXG4gICAgICAgIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICB3aGlsZSAocS5sZW5ndGggPiAwKSB7IHEuc2hpZnQoKS5vbkVycm9yKGUpOyB9XHJcbiAgICAgICAgICBvYnNlcnZlci5vbkVycm9yKGUpO1xyXG4gICAgICAgIH0sIFxyXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHdoaWxlIChxLmxlbmd0aCA+IDApIHsgcS5zaGlmdCgpLm9uQ29tcGxldGVkKCk7IH1cclxuICAgICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICApKTtcclxuICAgICAgcmV0dXJuIHJlZkNvdW50RGlzcG9zYWJsZTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIGNvbmNhdE1hcChzb3VyY2UsIHNlbGVjdG9yLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIHNvdXJjZS5tYXAoZnVuY3Rpb24gKHgsIGkpIHtcbiAgICAgIHZhciByZXN1bHQgPSBzZWxlY3Rvci5jYWxsKHRoaXNBcmcsIHgsIGksIHNvdXJjZSk7XG4gICAgICBpc1Byb21pc2UocmVzdWx0KSAmJiAocmVzdWx0ID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHJlc3VsdCkpO1xuICAgICAgKEFycmF5LmlzQXJyYXkocmVzdWx0KSB8fCBpc0l0ZXJhYmxlKHJlc3VsdCkpICYmIChyZXN1bHQgPSBvYnNlcnZhYmxlRnJvbShyZXN1bHQpKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSkuY29uY2F0QWxsKCk7XG4gIH1cblxuICAvKipcbiAgICogIE9uZSBvZiB0aGUgRm9sbG93aW5nOlxuICAgKiAgUHJvamVjdHMgZWFjaCBlbGVtZW50IG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdG8gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBhbmQgbWVyZ2VzIHRoZSByZXN1bHRpbmcgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaW50byBvbmUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogIHZhciByZXMgPSBzb3VyY2UuY29uY2F0TWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBSeC5PYnNlcnZhYmxlLnJhbmdlKDAsIHgpOyB9KTtcbiAgICogIE9yOlxuICAgKiAgUHJvamVjdHMgZWFjaCBlbGVtZW50IG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdG8gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSwgaW52b2tlcyB0aGUgcmVzdWx0IHNlbGVjdG9yIGZvciB0aGUgc291cmNlIGVsZW1lbnQgYW5kIGVhY2ggb2YgdGhlIGNvcnJlc3BvbmRpbmcgaW5uZXIgc2VxdWVuY2UncyBlbGVtZW50cywgYW5kIG1lcmdlcyB0aGUgcmVzdWx0cyBpbnRvIG9uZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKlxuICAgKiAgdmFyIHJlcyA9IHNvdXJjZS5jb25jYXRNYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIFJ4Lk9ic2VydmFibGUucmFuZ2UoMCwgeCk7IH0sIGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiB4ICsgeTsgfSk7XG4gICAqICBPcjpcbiAgICogIFByb2plY3RzIGVhY2ggZWxlbWVudCBvZiB0aGUgc291cmNlIG9ic2VydmFibGUgc2VxdWVuY2UgdG8gdGhlIG90aGVyIG9ic2VydmFibGUgc2VxdWVuY2UgYW5kIG1lcmdlcyB0aGUgcmVzdWx0aW5nIG9ic2VydmFibGUgc2VxdWVuY2VzIGludG8gb25lIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAqXG4gICAqICB2YXIgcmVzID0gc291cmNlLmNvbmNhdE1hcChSeC5PYnNlcnZhYmxlLmZyb21BcnJheShbMSwyLDNdKSk7XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHNlbGVjdG9yIEEgdHJhbnNmb3JtIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggZWxlbWVudCBvciBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRvIHByb2plY3QgZWFjaCBlbGVtZW50IGZyb20gdGhlXG4gICAqIHNvdXJjZSBzZXF1ZW5jZSBvbnRvIHdoaWNoIGNvdWxkIGJlIGVpdGhlciBhbiBvYnNlcnZhYmxlIG9yIFByb21pc2UuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXN1bHRTZWxlY3Rvcl0gIEEgdHJhbnNmb3JtIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgaW50ZXJtZWRpYXRlIHNlcXVlbmNlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aG9zZSBlbGVtZW50cyBhcmUgdGhlIHJlc3VsdCBvZiBpbnZva2luZyB0aGUgb25lLXRvLW1hbnkgdHJhbnNmb3JtIGZ1bmN0aW9uIGNvbGxlY3Rpb25TZWxlY3RvciBvbiBlYWNoIGVsZW1lbnQgb2YgdGhlIGlucHV0IHNlcXVlbmNlIGFuZCB0aGVuIG1hcHBpbmcgZWFjaCBvZiB0aG9zZSBzZXF1ZW5jZSBlbGVtZW50cyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBzb3VyY2UgZWxlbWVudCB0byBhIHJlc3VsdCBlbGVtZW50LlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnNlbGVjdENvbmNhdCA9IG9ic2VydmFibGVQcm90by5jb25jYXRNYXAgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHJlc3VsdFNlbGVjdG9yLCB0aGlzQXJnKSB7XG4gICAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcmVzdWx0U2VsZWN0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbmNhdE1hcChmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgICB2YXIgc2VsZWN0b3JSZXN1bHQgPSBzZWxlY3Rvcih4LCBpKTtcbiAgICAgICAgaXNQcm9taXNlKHNlbGVjdG9yUmVzdWx0KSAmJiAoc2VsZWN0b3JSZXN1bHQgPSBvYnNlcnZhYmxlRnJvbVByb21pc2Uoc2VsZWN0b3JSZXN1bHQpKTtcbiAgICAgICAgKEFycmF5LmlzQXJyYXkoc2VsZWN0b3JSZXN1bHQpIHx8IGlzSXRlcmFibGUoc2VsZWN0b3JSZXN1bHQpKSAmJiAoc2VsZWN0b3JSZXN1bHQgPSBvYnNlcnZhYmxlRnJvbShzZWxlY3RvclJlc3VsdCkpO1xuXG4gICAgICAgIHJldHVybiBzZWxlY3RvclJlc3VsdC5tYXAoZnVuY3Rpb24gKHksIGkyKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdFNlbGVjdG9yKHgsIHksIGksIGkyKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiBzZWxlY3RvciA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICBjb25jYXRNYXAodGhpcywgc2VsZWN0b3IsIHRoaXNBcmcpIDpcbiAgICAgIGNvbmNhdE1hcCh0aGlzLCBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxlY3RvcjsgfSk7XG4gIH07XG5cclxuICAvKipcclxuICAgKiBQcm9qZWN0cyBlYWNoIG5vdGlmaWNhdGlvbiBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRvIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgYW5kIGNvbmNhdHMgdGhlIHJlc3VsdGluZyBvYnNlcnZhYmxlIHNlcXVlbmNlcyBpbnRvIG9uZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uTmV4dCBBIHRyYW5zZm9ybSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGVsZW1lbnQ7IHRoZSBzZWNvbmQgcGFyYW1ldGVyIG9mIHRoZSBmdW5jdGlvbiByZXByZXNlbnRzIHRoZSBpbmRleCBvZiB0aGUgc291cmNlIGVsZW1lbnQuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25FcnJvciBBIHRyYW5zZm9ybSBmdW5jdGlvbiB0byBhcHBseSB3aGVuIGFuIGVycm9yIG9jY3VycyBpbiB0aGUgc291cmNlIHNlcXVlbmNlLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uQ29tcGxldGVkIEEgdHJhbnNmb3JtIGZ1bmN0aW9uIHRvIGFwcGx5IHdoZW4gdGhlIGVuZCBvZiB0aGUgc291cmNlIHNlcXVlbmNlIGlzIHJlYWNoZWQuXHJcbiAgICogQHBhcmFtIHtBbnl9IFt0aGlzQXJnXSBBbiBvcHRpb25hbCBcInRoaXNcIiB0byB1c2UgdG8gaW52b2tlIGVhY2ggdHJhbnNmb3JtLlxyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdob3NlIGVsZW1lbnRzIGFyZSB0aGUgcmVzdWx0IG9mIGludm9raW5nIHRoZSBvbmUtdG8tbWFueSB0cmFuc2Zvcm0gZnVuY3Rpb24gY29ycmVzcG9uZGluZyB0byBlYWNoIG5vdGlmaWNhdGlvbiBpbiB0aGUgaW5wdXQgc2VxdWVuY2UuXHJcbiAgICovXHJcbiAgb2JzZXJ2YWJsZVByb3RvLmNvbmNhdE1hcE9ic2VydmVyID0gb2JzZXJ2YWJsZVByb3RvLnNlbGVjdENvbmNhdE9ic2VydmVyID0gZnVuY3Rpb24ob25OZXh0LCBvbkVycm9yLCBvbkNvbXBsZXRlZCwgdGhpc0FyZykge1xyXG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XHJcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgIHZhciBpbmRleCA9IDA7XHJcblxyXG4gICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShcclxuICAgICAgICBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgdmFyIHJlc3VsdDtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IG9uTmV4dC5jYWxsKHRoaXNBcmcsIHgsIGluZGV4KyspO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBvYnNlcnZlci5vbkVycm9yKGUpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpc1Byb21pc2UocmVzdWx0KSAmJiAocmVzdWx0ID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHJlc3VsdCkpO1xyXG4gICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KHJlc3VsdCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICB2YXIgcmVzdWx0O1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gb25FcnJvci5jYWxsKHRoaXNBcmcsIGVycik7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlzUHJvbWlzZShyZXN1bHQpICYmIChyZXN1bHQgPSBvYnNlcnZhYmxlRnJvbVByb21pc2UocmVzdWx0KSk7XHJcbiAgICAgICAgICBvYnNlcnZlci5vbk5leHQocmVzdWx0KTtcclxuICAgICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICB2YXIgcmVzdWx0O1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gb25Db21wbGV0ZWQuY2FsbCh0aGlzQXJnKTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaXNQcm9taXNlKHJlc3VsdCkgJiYgKHJlc3VsdCA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShyZXN1bHQpKTtcclxuICAgICAgICAgIG9ic2VydmVyLm9uTmV4dChyZXN1bHQpO1xyXG4gICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pLmNvbmNhdEFsbCgpO1xyXG4gIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0aGUgZWxlbWVudHMgb2YgdGhlIHNwZWNpZmllZCBzZXF1ZW5jZSBvciB0aGUgc3BlY2lmaWVkIHZhbHVlIGluIGEgc2luZ2xldG9uIHNlcXVlbmNlIGlmIHRoZSBzZXF1ZW5jZSBpcyBlbXB0eS5cclxuICAgICAqXHJcbiAgICAgKiAgdmFyIHJlcyA9IG9icyA9IHhzLmRlZmF1bHRJZkVtcHR5KCk7XHJcbiAgICAgKiAgMiAtIG9icyA9IHhzLmRlZmF1bHRJZkVtcHR5KGZhbHNlKTtcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyT2YgT2JzZXJ2YWJsZSNcclxuICAgICAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBpZiB0aGUgc2VxdWVuY2UgaXMgZW1wdHkuIElmIG5vdCBwcm92aWRlZCwgdGhpcyBkZWZhdWx0cyB0byBudWxsLlxyXG4gICAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyB0aGUgc3BlY2lmaWVkIGRlZmF1bHQgdmFsdWUgaWYgdGhlIHNvdXJjZSBpcyBlbXB0eTsgb3RoZXJ3aXNlLCB0aGUgZWxlbWVudHMgb2YgdGhlIHNvdXJjZSBpdHNlbGYuXHJcbiAgICAgKi9cclxuICAgIG9ic2VydmFibGVQcm90by5kZWZhdWx0SWZFbXB0eSA9IGZ1bmN0aW9uIChkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICB2YXIgc291cmNlID0gdGhpcztcclxuICAgICAgICBpZiAoZGVmYXVsdFZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIG9ic2VydmVyLm9uTmV4dCh4KTtcclxuICAgICAgICAgICAgfSwgb2JzZXJ2ZXIub25FcnJvci5iaW5kKG9ic2VydmVyKSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm9uTmV4dChkZWZhdWx0VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAvLyBTd2FwIG91dCBmb3IgQXJyYXkuZmluZEluZGV4XHJcbiAgZnVuY3Rpb24gYXJyYXlJbmRleE9mQ29tcGFyZXIoYXJyYXksIGl0ZW0sIGNvbXBhcmVyKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgaWYgKGNvbXBhcmVyKGFycmF5W2ldLCBpdGVtKSkgeyByZXR1cm4gaTsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIC0xO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gSGFzaFNldChjb21wYXJlcikge1xyXG4gICAgdGhpcy5jb21wYXJlciA9IGNvbXBhcmVyO1xyXG4gICAgdGhpcy5zZXQgPSBbXTtcclxuICB9XHJcbiAgSGFzaFNldC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICB2YXIgcmV0VmFsdWUgPSBhcnJheUluZGV4T2ZDb21wYXJlcih0aGlzLnNldCwgdmFsdWUsIHRoaXMuY29tcGFyZXIpID09PSAtMTtcclxuICAgIHJldFZhbHVlICYmIHRoaXMuc2V0LnB1c2godmFsdWUpO1xyXG4gICAgcmV0dXJuIHJldFZhbHVlO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqICBSZXR1cm5zIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyBvbmx5IGRpc3RpbmN0IGVsZW1lbnRzIGFjY29yZGluZyB0byB0aGUga2V5U2VsZWN0b3IgYW5kIHRoZSBjb21wYXJlci5cclxuICAgKiAgVXNhZ2Ugb2YgdGhpcyBvcGVyYXRvciBzaG91bGQgYmUgY29uc2lkZXJlZCBjYXJlZnVsbHkgZHVlIHRvIHRoZSBtYWludGVuYW5jZSBvZiBhbiBpbnRlcm5hbCBsb29rdXAgc3RydWN0dXJlIHdoaWNoIGNhbiBncm93IGxhcmdlLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiAgdmFyIHJlcyA9IG9icyA9IHhzLmRpc3RpbmN0KCk7XHJcbiAgICogIDIgLSBvYnMgPSB4cy5kaXN0aW5jdChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5pZDsgfSk7XHJcbiAgICogIDIgLSBvYnMgPSB4cy5kaXN0aW5jdChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5pZDsgfSwgZnVuY3Rpb24gKGEsYikgeyByZXR1cm4gYSA9PT0gYjsgfSk7XHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2tleVNlbGVjdG9yXSAgQSBmdW5jdGlvbiB0byBjb21wdXRlIHRoZSBjb21wYXJpc29uIGtleSBmb3IgZWFjaCBlbGVtZW50LlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJlcl0gIFVzZWQgdG8gY29tcGFyZSBpdGVtcyBpbiB0aGUgY29sbGVjdGlvbi5cclxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvbmx5IGNvbnRhaW5pbmcgdGhlIGRpc3RpbmN0IGVsZW1lbnRzLCBiYXNlZCBvbiBhIGNvbXB1dGVkIGtleSB2YWx1ZSwgZnJvbSB0aGUgc291cmNlIHNlcXVlbmNlLlxyXG4gICAqL1xyXG4gIG9ic2VydmFibGVQcm90by5kaXN0aW5jdCA9IGZ1bmN0aW9uIChrZXlTZWxlY3RvciwgY29tcGFyZXIpIHtcclxuICAgIHZhciBzb3VyY2UgPSB0aGlzO1xyXG4gICAgY29tcGFyZXIgfHwgKGNvbXBhcmVyID0gZGVmYXVsdENvbXBhcmVyKTtcclxuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgdmFyIGhhc2hTZXQgPSBuZXcgSGFzaFNldChjb21wYXJlcik7XHJcbiAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgdmFyIGtleSA9IHg7XHJcblxyXG4gICAgICAgIGlmIChrZXlTZWxlY3Rvcikge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAga2V5ID0ga2V5U2VsZWN0b3IoeCk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaGFzaFNldC5wdXNoKGtleSkgJiYgb2JzZXJ2ZXIub25OZXh0KHgpO1xyXG4gICAgICB9LFxyXG4gICAgICBvYnNlcnZlci5vbkVycm9yLmJpbmQob2JzZXJ2ZXIpLFxyXG4gICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZC5iaW5kKG9ic2VydmVyKSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiAgR3JvdXBzIHRoZSBlbGVtZW50cyBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGFjY29yZGluZyB0byBhIHNwZWNpZmllZCBrZXkgc2VsZWN0b3IgZnVuY3Rpb24gYW5kIGNvbXBhcmVyIGFuZCBzZWxlY3RzIHRoZSByZXN1bHRpbmcgZWxlbWVudHMgYnkgdXNpbmcgYSBzcGVjaWZpZWQgZnVuY3Rpb24uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqICB2YXIgcmVzID0gb2JzZXJ2YWJsZS5ncm91cEJ5KGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmlkOyB9KTtcclxuICAgKiAgMiAtIG9ic2VydmFibGUuZ3JvdXBCeShmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5pZDsgfSksIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Lm5hbWU7IH0pO1xyXG4gICAqICAzIC0gb2JzZXJ2YWJsZS5ncm91cEJ5KGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmlkOyB9KSwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgubmFtZTsgfSwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgudG9TdHJpbmcoKTsgfSk7XHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5U2VsZWN0b3IgQSBmdW5jdGlvbiB0byBleHRyYWN0IHRoZSBrZXkgZm9yIGVhY2ggZWxlbWVudC5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZWxlbWVudFNlbGVjdG9yXSAgQSBmdW5jdGlvbiB0byBtYXAgZWFjaCBzb3VyY2UgZWxlbWVudCB0byBhbiBlbGVtZW50IGluIGFuIG9ic2VydmFibGUgZ3JvdXAuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmVyXSBVc2VkIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBvYmplY3RzIGFyZSBlcXVhbC5cclxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQSBzZXF1ZW5jZSBvZiBvYnNlcnZhYmxlIGdyb3VwcywgZWFjaCBvZiB3aGljaCBjb3JyZXNwb25kcyB0byBhIHVuaXF1ZSBrZXkgdmFsdWUsIGNvbnRhaW5pbmcgYWxsIGVsZW1lbnRzIHRoYXQgc2hhcmUgdGhhdCBzYW1lIGtleSB2YWx1ZS5cclxuICAgKi9cclxuICBvYnNlcnZhYmxlUHJvdG8uZ3JvdXBCeSA9IGZ1bmN0aW9uIChrZXlTZWxlY3RvciwgZWxlbWVudFNlbGVjdG9yLCBjb21wYXJlcikge1xyXG4gICAgcmV0dXJuIHRoaXMuZ3JvdXBCeVVudGlsKGtleVNlbGVjdG9yLCBlbGVtZW50U2VsZWN0b3IsIG9ic2VydmFibGVOZXZlciwgY29tcGFyZXIpO1xyXG4gIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAgR3JvdXBzIHRoZSBlbGVtZW50cyBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGFjY29yZGluZyB0byBhIHNwZWNpZmllZCBrZXkgc2VsZWN0b3IgZnVuY3Rpb24uXHJcbiAgICAgKiAgQSBkdXJhdGlvbiBzZWxlY3RvciBmdW5jdGlvbiBpcyB1c2VkIHRvIGNvbnRyb2wgdGhlIGxpZmV0aW1lIG9mIGdyb3Vwcy4gV2hlbiBhIGdyb3VwIGV4cGlyZXMsIGl0IHJlY2VpdmVzIGFuIE9uQ29tcGxldGVkIG5vdGlmaWNhdGlvbi4gV2hlbiBhIG5ldyBlbGVtZW50IHdpdGggdGhlIHNhbWVcclxuICAgICAqICBrZXkgdmFsdWUgYXMgYSByZWNsYWltZWQgZ3JvdXAgb2NjdXJzLCB0aGUgZ3JvdXAgd2lsbCBiZSByZWJvcm4gd2l0aCBhIG5ldyBsaWZldGltZSByZXF1ZXN0LlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgdmFyIHJlcyA9IG9ic2VydmFibGUuZ3JvdXBCeVVudGlsKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmlkOyB9LCBudWxsLCAgZnVuY3Rpb24gKCkgeyByZXR1cm4gUnguT2JzZXJ2YWJsZS5uZXZlcigpOyB9KTtcclxuICAgICAqICAyIC0gb2JzZXJ2YWJsZS5ncm91cEJ5KGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmlkOyB9KSwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgubmFtZTsgfSwgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJ4Lk9ic2VydmFibGUubmV2ZXIoKTsgfSk7XHJcbiAgICAgKiAgMyAtIG9ic2VydmFibGUuZ3JvdXBCeShmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5pZDsgfSksIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Lm5hbWU7IH0sICBmdW5jdGlvbiAoKSB7IHJldHVybiBSeC5PYnNlcnZhYmxlLm5ldmVyKCk7IH0sIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnRvU3RyaW5nKCk7IH0pO1xyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5U2VsZWN0b3IgQSBmdW5jdGlvbiB0byBleHRyYWN0IHRoZSBrZXkgZm9yIGVhY2ggZWxlbWVudC5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGR1cmF0aW9uU2VsZWN0b3IgQSBmdW5jdGlvbiB0byBzaWduYWwgdGhlIGV4cGlyYXRpb24gb2YgYSBncm91cC5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJlcl0gVXNlZCB0byBjb21wYXJlIG9iamVjdHMuIFdoZW4gbm90IHNwZWNpZmllZCwgdGhlIGRlZmF1bHQgY29tcGFyZXIgaXMgdXNlZC5cclxuICAgICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfVxyXG4gICAgICogIEEgc2VxdWVuY2Ugb2Ygb2JzZXJ2YWJsZSBncm91cHMsIGVhY2ggb2Ygd2hpY2ggY29ycmVzcG9uZHMgdG8gYSB1bmlxdWUga2V5IHZhbHVlLCBjb250YWluaW5nIGFsbCBlbGVtZW50cyB0aGF0IHNoYXJlIHRoYXQgc2FtZSBrZXkgdmFsdWUuXHJcbiAgICAgKiAgSWYgYSBncm91cCdzIGxpZmV0aW1lIGV4cGlyZXMsIGEgbmV3IGdyb3VwIHdpdGggdGhlIHNhbWUga2V5IHZhbHVlIGNhbiBiZSBjcmVhdGVkIG9uY2UgYW4gZWxlbWVudCB3aXRoIHN1Y2ggYSBrZXkgdmFsdWUgaXMgZW5jb3V0ZXJlZC5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIG9ic2VydmFibGVQcm90by5ncm91cEJ5VW50aWwgPSBmdW5jdGlvbiAoa2V5U2VsZWN0b3IsIGVsZW1lbnRTZWxlY3RvciwgZHVyYXRpb25TZWxlY3RvciwgY29tcGFyZXIpIHtcclxuICAgICAgdmFyIHNvdXJjZSA9IHRoaXM7XHJcbiAgICAgIGVsZW1lbnRTZWxlY3RvciB8fCAoZWxlbWVudFNlbGVjdG9yID0gaWRlbnRpdHkpO1xyXG4gICAgICBjb21wYXJlciB8fCAoY29tcGFyZXIgPSBkZWZhdWx0Q29tcGFyZXIpO1xyXG4gICAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlRXJyb3IoZSkgeyByZXR1cm4gZnVuY3Rpb24gKGl0ZW0pIHsgaXRlbS5vbkVycm9yKGUpOyB9OyB9XHJcbiAgICAgICAgdmFyIG1hcCA9IG5ldyBEaWN0aW9uYXJ5KDAsIGNvbXBhcmVyKSxcclxuICAgICAgICAgIGdyb3VwRGlzcG9zYWJsZSA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCksXHJcbiAgICAgICAgICByZWZDb3VudERpc3Bvc2FibGUgPSBuZXcgUmVmQ291bnREaXNwb3NhYmxlKGdyb3VwRGlzcG9zYWJsZSk7XHJcblxyXG4gICAgICAgIGdyb3VwRGlzcG9zYWJsZS5hZGQoc291cmNlLnN1YnNjcmliZShmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgdmFyIGtleTtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGtleSA9IGtleVNlbGVjdG9yKHgpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBtYXAuZ2V0VmFsdWVzKCkuZm9yRWFjaChoYW5kbGVFcnJvcihlKSk7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB2YXIgZmlyZU5ld01hcEVudHJ5ID0gZmFsc2UsXHJcbiAgICAgICAgICAgIHdyaXRlciA9IG1hcC50cnlHZXRWYWx1ZShrZXkpO1xyXG4gICAgICAgICAgaWYgKCF3cml0ZXIpIHtcclxuICAgICAgICAgICAgd3JpdGVyID0gbmV3IFN1YmplY3QoKTtcclxuICAgICAgICAgICAgbWFwLnNldChrZXksIHdyaXRlcik7XHJcbiAgICAgICAgICAgIGZpcmVOZXdNYXBFbnRyeSA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKGZpcmVOZXdNYXBFbnRyeSkge1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBuZXcgR3JvdXBlZE9ic2VydmFibGUoa2V5LCB3cml0ZXIsIHJlZkNvdW50RGlzcG9zYWJsZSksXHJcbiAgICAgICAgICAgICAgZHVyYXRpb25Hcm91cCA9IG5ldyBHcm91cGVkT2JzZXJ2YWJsZShrZXksIHdyaXRlcik7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgZHVyYXRpb24gPSBkdXJhdGlvblNlbGVjdG9yKGR1cmF0aW9uR3JvdXApO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgbWFwLmdldFZhbHVlcygpLmZvckVhY2goaGFuZGxlRXJyb3IoZSkpO1xyXG4gICAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBvYnNlcnZlci5vbk5leHQoZ3JvdXApO1xyXG5cclxuICAgICAgICAgICAgdmFyIG1kID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XHJcbiAgICAgICAgICAgIGdyb3VwRGlzcG9zYWJsZS5hZGQobWQpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGV4cGlyZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICBtYXAucmVtb3ZlKGtleSkgJiYgd3JpdGVyLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgICAgICAgICAgZ3JvdXBEaXNwb3NhYmxlLnJlbW92ZShtZCk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBtZC5zZXREaXNwb3NhYmxlKGR1cmF0aW9uLnRha2UoMSkuc3Vic2NyaWJlKFxyXG4gICAgICAgICAgICAgIG5vb3AsXHJcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKGV4bikge1xyXG4gICAgICAgICAgICAgICAgbWFwLmdldFZhbHVlcygpLmZvckVhY2goaGFuZGxlRXJyb3IoZXhuKSk7XHJcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5vbkVycm9yKGV4bik7XHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICBleHBpcmUpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdmFyIGVsZW1lbnQ7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudFNlbGVjdG9yKHgpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBtYXAuZ2V0VmFsdWVzKCkuZm9yRWFjaChoYW5kbGVFcnJvcihlKSk7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB3cml0ZXIub25OZXh0KGVsZW1lbnQpO1xyXG4gICAgICB9LCBmdW5jdGlvbiAoZXgpIHtcclxuICAgICAgICBtYXAuZ2V0VmFsdWVzKCkuZm9yRWFjaChoYW5kbGVFcnJvcihleCkpO1xyXG4gICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZXgpO1xyXG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgbWFwLmdldFZhbHVlcygpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHsgaXRlbS5vbkNvbXBsZXRlZCgpOyB9KTtcclxuICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICB9KSk7XHJcblxyXG4gICAgICByZXR1cm4gcmVmQ291bnREaXNwb3NhYmxlO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogIFByb2plY3RzIGVhY2ggZWxlbWVudCBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGludG8gYSBuZXcgZm9ybSBieSBpbmNvcnBvcmF0aW5nIHRoZSBlbGVtZW50J3MgaW5kZXguXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2VsZWN0b3IgQSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBzb3VyY2UgZWxlbWVudDsgdGhlIHNlY29uZCBwYXJhbWV0ZXIgb2YgdGhlIGZ1bmN0aW9uIHJlcHJlc2VudHMgdGhlIGluZGV4IG9mIHRoZSBzb3VyY2UgZWxlbWVudC5cclxuICAgKiBAcGFyYW0ge0FueX0gW3RoaXNBcmddIE9iamVjdCB0byB1c2UgYXMgdGhpcyB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cclxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aG9zZSBlbGVtZW50cyBhcmUgdGhlIHJlc3VsdCBvZiBpbnZva2luZyB0aGUgdHJhbnNmb3JtIGZ1bmN0aW9uIG9uIGVhY2ggZWxlbWVudCBvZiBzb3VyY2UuXHJcbiAgICovXHJcbiAgb2JzZXJ2YWJsZVByb3RvLnNlbGVjdCA9IG9ic2VydmFibGVQcm90by5tYXAgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHRoaXNBcmcpIHtcclxuICAgIHZhciBwYXJlbnQgPSB0aGlzO1xyXG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICB2YXIgY291bnQgPSAwO1xyXG4gICAgICByZXR1cm4gcGFyZW50LnN1YnNjcmliZShmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICB2YXIgcmVzdWx0O1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICByZXN1bHQgPSBzZWxlY3Rvci5jYWxsKHRoaXNBcmcsIHZhbHVlLCBjb3VudCsrLCBwYXJlbnQpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9ic2VydmVyLm9uTmV4dChyZXN1bHQpO1xyXG4gICAgICB9LCBvYnNlcnZlci5vbkVycm9yLmJpbmQob2JzZXJ2ZXIpLCBvYnNlcnZlci5vbkNvbXBsZXRlZC5iaW5kKG9ic2VydmVyKSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZXRyaWV2ZXMgdGhlIHZhbHVlIG9mIGEgc3BlY2lmaWVkIHByb3BlcnR5IGZyb20gYWxsIGVsZW1lbnRzIGluIHRoZSBPYnNlcnZhYmxlIHNlcXVlbmNlLlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIFRoZSBwcm9wZXJ0eSB0byBwbHVjay5cclxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gUmV0dXJucyBhIG5ldyBPYnNlcnZhYmxlIHNlcXVlbmNlIG9mIHByb3BlcnR5IHZhbHVlcy5cclxuICAgKi9cclxuICBvYnNlcnZhYmxlUHJvdG8ucGx1Y2sgPSBmdW5jdGlvbiAocHJvcCkge1xyXG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4W3Byb3BdOyB9KTtcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBmbGF0TWFwKHNvdXJjZSwgc2VsZWN0b3IsIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gc291cmNlLm1hcChmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHNlbGVjdG9yLmNhbGwodGhpc0FyZywgeCwgaSwgc291cmNlKTtcbiAgICAgIGlzUHJvbWlzZShyZXN1bHQpICYmIChyZXN1bHQgPSBvYnNlcnZhYmxlRnJvbVByb21pc2UocmVzdWx0KSk7XG4gICAgICAoQXJyYXkuaXNBcnJheShyZXN1bHQpIHx8IGlzSXRlcmFibGUocmVzdWx0KSkgJiYgKHJlc3VsdCA9IG9ic2VydmFibGVGcm9tKHJlc3VsdCkpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KS5tZXJnZU9ic2VydmFibGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAgT25lIG9mIHRoZSBGb2xsb3dpbmc6XG4gICAqICBQcm9qZWN0cyBlYWNoIGVsZW1lbnQgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0byBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGFuZCBtZXJnZXMgdGhlIHJlc3VsdGluZyBvYnNlcnZhYmxlIHNlcXVlbmNlcyBpbnRvIG9uZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgdmFyIHJlcyA9IHNvdXJjZS5zZWxlY3RNYW55KGZ1bmN0aW9uICh4KSB7IHJldHVybiBSeC5PYnNlcnZhYmxlLnJhbmdlKDAsIHgpOyB9KTtcbiAgICogIE9yOlxuICAgKiAgUHJvamVjdHMgZWFjaCBlbGVtZW50IG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdG8gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSwgaW52b2tlcyB0aGUgcmVzdWx0IHNlbGVjdG9yIGZvciB0aGUgc291cmNlIGVsZW1lbnQgYW5kIGVhY2ggb2YgdGhlIGNvcnJlc3BvbmRpbmcgaW5uZXIgc2VxdWVuY2UncyBlbGVtZW50cywgYW5kIG1lcmdlcyB0aGUgcmVzdWx0cyBpbnRvIG9uZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKlxuICAgKiAgdmFyIHJlcyA9IHNvdXJjZS5zZWxlY3RNYW55KGZ1bmN0aW9uICh4KSB7IHJldHVybiBSeC5PYnNlcnZhYmxlLnJhbmdlKDAsIHgpOyB9LCBmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4geCArIHk7IH0pO1xuICAgKiAgT3I6XG4gICAqICBQcm9qZWN0cyBlYWNoIGVsZW1lbnQgb2YgdGhlIHNvdXJjZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRvIHRoZSBvdGhlciBvYnNlcnZhYmxlIHNlcXVlbmNlIGFuZCBtZXJnZXMgdGhlIHJlc3VsdGluZyBvYnNlcnZhYmxlIHNlcXVlbmNlcyBpbnRvIG9uZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKlxuICAgKiAgdmFyIHJlcyA9IHNvdXJjZS5zZWxlY3RNYW55KFJ4Lk9ic2VydmFibGUuZnJvbUFycmF5KFsxLDIsM10pKTtcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2VsZWN0b3IgQSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBlbGVtZW50IG9yIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdG8gcHJvamVjdCBlYWNoIGVsZW1lbnQgZnJvbSB0aGUgc291cmNlIHNlcXVlbmNlIG9udG8gd2hpY2ggY291bGQgYmUgZWl0aGVyIGFuIG9ic2VydmFibGUgb3IgUHJvbWlzZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc3VsdFNlbGVjdG9yXSAgQSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSBpbnRlcm1lZGlhdGUgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyB0aGlzIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aG9zZSBlbGVtZW50cyBhcmUgdGhlIHJlc3VsdCBvZiBpbnZva2luZyB0aGUgb25lLXRvLW1hbnkgdHJhbnNmb3JtIGZ1bmN0aW9uIGNvbGxlY3Rpb25TZWxlY3RvciBvbiBlYWNoIGVsZW1lbnQgb2YgdGhlIGlucHV0IHNlcXVlbmNlIGFuZCB0aGVuIG1hcHBpbmcgZWFjaCBvZiB0aG9zZSBzZXF1ZW5jZSBlbGVtZW50cyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBzb3VyY2UgZWxlbWVudCB0byBhIHJlc3VsdCBlbGVtZW50LlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnNlbGVjdE1hbnkgPSBvYnNlcnZhYmxlUHJvdG8uZmxhdE1hcCA9IGZ1bmN0aW9uIChzZWxlY3RvciwgcmVzdWx0U2VsZWN0b3IsIHRoaXNBcmcpIHtcbiAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiByZXN1bHRTZWxlY3RvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMuZmxhdE1hcChmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgICB2YXIgc2VsZWN0b3JSZXN1bHQgPSBzZWxlY3Rvcih4LCBpKTtcbiAgICAgICAgaXNQcm9taXNlKHNlbGVjdG9yUmVzdWx0KSAmJiAoc2VsZWN0b3JSZXN1bHQgPSBvYnNlcnZhYmxlRnJvbVByb21pc2Uoc2VsZWN0b3JSZXN1bHQpKTtcbiAgICAgICAgKEFycmF5LmlzQXJyYXkoc2VsZWN0b3JSZXN1bHQpIHx8IGlzSXRlcmFibGUoc2VsZWN0b3JSZXN1bHQpKSAmJiAoc2VsZWN0b3JSZXN1bHQgPSBvYnNlcnZhYmxlRnJvbShzZWxlY3RvclJlc3VsdCkpO1xuXG4gICAgICAgIHJldHVybiBzZWxlY3RvclJlc3VsdC5tYXAoZnVuY3Rpb24gKHksIGkyKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdFNlbGVjdG9yKHgsIHksIGksIGkyKTtcbiAgICAgICAgfSk7XG4gICAgICB9LCB0aGlzQXJnKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiBzZWxlY3RvciA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICBmbGF0TWFwKHRoaXMsIHNlbGVjdG9yLCB0aGlzQXJnKSA6XG4gICAgICBmbGF0TWFwKHRoaXMsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGVjdG9yOyB9KTtcbiAgfTtcblxyXG4gIC8qKlxyXG4gICAqIFByb2plY3RzIGVhY2ggbm90aWZpY2F0aW9uIG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdG8gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBhbmQgbWVyZ2VzIHRoZSByZXN1bHRpbmcgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaW50byBvbmUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbk5leHQgQSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBlbGVtZW50OyB0aGUgc2Vjb25kIHBhcmFtZXRlciBvZiB0aGUgZnVuY3Rpb24gcmVwcmVzZW50cyB0aGUgaW5kZXggb2YgdGhlIHNvdXJjZSBlbGVtZW50LlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uRXJyb3IgQSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gYXBwbHkgd2hlbiBhbiBlcnJvciBvY2N1cnMgaW4gdGhlIHNvdXJjZSBzZXF1ZW5jZS5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbkNvbXBsZXRlZCBBIHRyYW5zZm9ybSBmdW5jdGlvbiB0byBhcHBseSB3aGVuIHRoZSBlbmQgb2YgdGhlIHNvdXJjZSBzZXF1ZW5jZSBpcyByZWFjaGVkLlxyXG4gICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gQW4gb3B0aW9uYWwgXCJ0aGlzXCIgdG8gdXNlIHRvIGludm9rZSBlYWNoIHRyYW5zZm9ybS5cclxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aG9zZSBlbGVtZW50cyBhcmUgdGhlIHJlc3VsdCBvZiBpbnZva2luZyB0aGUgb25lLXRvLW1hbnkgdHJhbnNmb3JtIGZ1bmN0aW9uIGNvcnJlc3BvbmRpbmcgdG8gZWFjaCBub3RpZmljYXRpb24gaW4gdGhlIGlucHV0IHNlcXVlbmNlLlxyXG4gICAqL1xyXG4gIG9ic2VydmFibGVQcm90by5mbGF0TWFwT2JzZXJ2ZXIgPSBvYnNlcnZhYmxlUHJvdG8uc2VsZWN0TWFueU9ic2VydmVyID0gZnVuY3Rpb24gKG9uTmV4dCwgb25FcnJvciwgb25Db21wbGV0ZWQsIHRoaXNBcmcpIHtcclxuICAgIHZhciBzb3VyY2UgPSB0aGlzO1xyXG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICB2YXIgaW5kZXggPSAwO1xyXG5cclxuICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUoXHJcbiAgICAgICAgZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgIHZhciByZXN1bHQ7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBvbk5leHQuY2FsbCh0aGlzQXJnLCB4LCBpbmRleCsrKTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaXNQcm9taXNlKHJlc3VsdCkgJiYgKHJlc3VsdCA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShyZXN1bHQpKTtcclxuICAgICAgICAgIG9ic2VydmVyLm9uTmV4dChyZXN1bHQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgdmFyIHJlc3VsdDtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IG9uRXJyb3IuY2FsbCh0aGlzQXJnLCBlcnIpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBvYnNlcnZlci5vbkVycm9yKGUpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpc1Byb21pc2UocmVzdWx0KSAmJiAocmVzdWx0ID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHJlc3VsdCkpO1xyXG4gICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KHJlc3VsdCk7XHJcbiAgICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgdmFyIHJlc3VsdDtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IG9uQ29tcGxldGVkLmNhbGwodGhpc0FyZyk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlzUHJvbWlzZShyZXN1bHQpICYmIChyZXN1bHQgPSBvYnNlcnZhYmxlRnJvbVByb21pc2UocmVzdWx0KSk7XHJcbiAgICAgICAgICBvYnNlcnZlci5vbk5leHQocmVzdWx0KTtcclxuICAgICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KS5tZXJnZUFsbCgpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqICBQcm9qZWN0cyBlYWNoIGVsZW1lbnQgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBpbnRvIGEgbmV3IHNlcXVlbmNlIG9mIG9ic2VydmFibGUgc2VxdWVuY2VzIGJ5IGluY29ycG9yYXRpbmcgdGhlIGVsZW1lbnQncyBpbmRleCBhbmQgdGhlblxyXG4gICAqICB0cmFuc2Zvcm1zIGFuIG9ic2VydmFibGUgc2VxdWVuY2Ugb2Ygb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaW50byBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHByb2R1Y2luZyB2YWx1ZXMgb25seSBmcm9tIHRoZSBtb3N0IHJlY2VudCBvYnNlcnZhYmxlIHNlcXVlbmNlLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHNlbGVjdG9yIEEgdHJhbnNmb3JtIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggc291cmNlIGVsZW1lbnQ7IHRoZSBzZWNvbmQgcGFyYW1ldGVyIG9mIHRoZSBmdW5jdGlvbiByZXByZXNlbnRzIHRoZSBpbmRleCBvZiB0aGUgc291cmNlIGVsZW1lbnQuXHJcbiAgICogQHBhcmFtIHtBbnl9IFt0aGlzQXJnXSBPYmplY3QgdG8gdXNlIGFzIHRoaXMgd2hlbiBleGVjdXRpbmcgY2FsbGJhY2suXHJcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hvc2UgZWxlbWVudHMgYXJlIHRoZSByZXN1bHQgb2YgaW52b2tpbmcgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiBvbiBlYWNoIGVsZW1lbnQgb2Ygc291cmNlIHByb2R1Y2luZyBhbiBPYnNlcnZhYmxlIG9mIE9ic2VydmFibGUgc2VxdWVuY2VzXHJcbiAgICogIGFuZCB0aGF0IGF0IGFueSBwb2ludCBpbiB0aW1lIHByb2R1Y2VzIHRoZSBlbGVtZW50cyBvZiB0aGUgbW9zdCByZWNlbnQgaW5uZXIgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGhhcyBiZWVuIHJlY2VpdmVkLlxyXG4gICAqL1xyXG4gIG9ic2VydmFibGVQcm90by5zZWxlY3RTd2l0Y2ggPSBvYnNlcnZhYmxlUHJvdG8uZmxhdE1hcExhdGVzdCA9IG9ic2VydmFibGVQcm90by5zd2l0Y2hNYXAgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHRoaXNBcmcpIHtcclxuICAgIHJldHVybiB0aGlzLnNlbGVjdChzZWxlY3RvciwgdGhpc0FyZykuc3dpdGNoTGF0ZXN0KCk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQnlwYXNzZXMgYSBzcGVjaWZpZWQgbnVtYmVyIG9mIGVsZW1lbnRzIGluIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgYW5kIHRoZW4gcmV0dXJucyB0aGUgcmVtYWluaW5nIGVsZW1lbnRzLlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYmVmb3JlIHJldHVybmluZyB0aGUgcmVtYWluaW5nIGVsZW1lbnRzLlxyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIGVsZW1lbnRzIHRoYXQgb2NjdXIgYWZ0ZXIgdGhlIHNwZWNpZmllZCBpbmRleCBpbiB0aGUgaW5wdXQgc2VxdWVuY2UuXHJcbiAgICovXHJcbiAgb2JzZXJ2YWJsZVByb3RvLnNraXAgPSBmdW5jdGlvbiAoY291bnQpIHtcclxuICAgICAgaWYgKGNvdW50IDwgMCkgeyB0aHJvdyBuZXcgRXJyb3IoYXJndW1lbnRPdXRPZlJhbmdlKTsgfVxyXG4gICAgICB2YXIgc291cmNlID0gdGhpcztcclxuICAgICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgIHZhciByZW1haW5pbmcgPSBjb3VudDtcclxuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgaWYgKHJlbWFpbmluZyA8PSAwKSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm9uTmV4dCh4KTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlbWFpbmluZy0tO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sIG9ic2VydmVyLm9uRXJyb3IuYmluZChvYnNlcnZlciksIG9ic2VydmVyLm9uQ29tcGxldGVkLmJpbmQob2JzZXJ2ZXIpKTtcclxuICAgICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogIEJ5cGFzc2VzIGVsZW1lbnRzIGluIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgYXMgbG9uZyBhcyBhIHNwZWNpZmllZCBjb25kaXRpb24gaXMgdHJ1ZSBhbmQgdGhlbiByZXR1cm5zIHRoZSByZW1haW5pbmcgZWxlbWVudHMuXHJcbiAgICogIFRoZSBlbGVtZW50J3MgaW5kZXggaXMgdXNlZCBpbiB0aGUgbG9naWMgb2YgdGhlIHByZWRpY2F0ZSBmdW5jdGlvbi5cclxuICAgKlxyXG4gICAqICB2YXIgcmVzID0gc291cmNlLnNraXBXaGlsZShmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlIDwgMTA7IH0pO1xyXG4gICAqICB2YXIgcmVzID0gc291cmNlLnNraXBXaGlsZShmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7IHJldHVybiB2YWx1ZSA8IDEwIHx8IGluZGV4IDwgMTA7IH0pO1xyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBBIGZ1bmN0aW9uIHRvIHRlc3QgZWFjaCBlbGVtZW50IGZvciBhIGNvbmRpdGlvbjsgdGhlIHNlY29uZCBwYXJhbWV0ZXIgb2YgdGhlIGZ1bmN0aW9uIHJlcHJlc2VudHMgdGhlIGluZGV4IG9mIHRoZSBzb3VyY2UgZWxlbWVudC5cclxuICAgKiBAcGFyYW0ge0FueX0gW3RoaXNBcmddIE9iamVjdCB0byB1c2UgYXMgdGhpcyB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cclxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGNvbnRhaW5zIHRoZSBlbGVtZW50cyBmcm9tIHRoZSBpbnB1dCBzZXF1ZW5jZSBzdGFydGluZyBhdCB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgbGluZWFyIHNlcmllcyB0aGF0IGRvZXMgbm90IHBhc3MgdGhlIHRlc3Qgc3BlY2lmaWVkIGJ5IHByZWRpY2F0ZS5cclxuICAgKi9cclxuICBvYnNlcnZhYmxlUHJvdG8uc2tpcFdoaWxlID0gZnVuY3Rpb24gKHByZWRpY2F0ZSwgdGhpc0FyZykge1xyXG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XHJcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgIHZhciBpID0gMCwgcnVubmluZyA9IGZhbHNlO1xyXG4gICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIGlmICghcnVubmluZykge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcnVubmluZyA9ICFwcmVkaWNhdGUuY2FsbCh0aGlzQXJnLCB4LCBpKyssIHNvdXJjZSk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcnVubmluZyAmJiBvYnNlcnZlci5vbk5leHQoeCk7XHJcbiAgICAgIH0sIG9ic2VydmVyLm9uRXJyb3IuYmluZChvYnNlcnZlciksIG9ic2VydmVyLm9uQ29tcGxldGVkLmJpbmQob2JzZXJ2ZXIpKTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqICBSZXR1cm5zIGEgc3BlY2lmaWVkIG51bWJlciBvZiBjb250aWd1b3VzIGVsZW1lbnRzIGZyb20gdGhlIHN0YXJ0IG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UsIHVzaW5nIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVyIGZvciB0aGUgZWRnZSBjYXNlIG9mIHRha2UoMCkuXHJcbiAgICpcclxuICAgKiAgdmFyIHJlcyA9IHNvdXJjZS50YWtlKDUpO1xyXG4gICAqICB2YXIgcmVzID0gc291cmNlLnRha2UoMCwgUnguU2NoZWR1bGVyLnRpbWVvdXQpO1xyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHJldHVybi5cclxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gU2NoZWR1bGVyIHVzZWQgdG8gcHJvZHVjZSBhbiBPbkNvbXBsZXRlZCBtZXNzYWdlIGluIGNhc2UgPHBhcmFtcmVmIG5hbWU9XCJjb3VudCBjb3VudDwvcGFyYW1yZWY+IGlzIHNldCB0byAwLlxyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgZWxlbWVudHMgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IHNlcXVlbmNlLlxyXG4gICAqL1xyXG4gIG9ic2VydmFibGVQcm90by50YWtlID0gZnVuY3Rpb24gKGNvdW50LCBzY2hlZHVsZXIpIHtcclxuICAgICAgaWYgKGNvdW50IDwgMCkgeyB0aHJvdyBuZXcgUmFuZ2VFcnJvcihhcmd1bWVudE91dE9mUmFuZ2UpOyB9XHJcbiAgICAgIGlmIChjb3VudCA9PT0gMCkgeyByZXR1cm4gb2JzZXJ2YWJsZUVtcHR5KHNjaGVkdWxlcik7IH1cclxuICAgICAgdmFyIG9ic2VydmFibGUgPSB0aGlzO1xyXG4gICAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IGNvdW50O1xyXG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlLnN1YnNjcmliZShmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgaWYgKHJlbWFpbmluZy0tID4gMCkge1xyXG4gICAgICAgICAgICBvYnNlcnZlci5vbk5leHQoeCk7XHJcbiAgICAgICAgICAgIHJlbWFpbmluZyA9PT0gMCAmJiBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sIG9ic2VydmVyLm9uRXJyb3IuYmluZChvYnNlcnZlciksIG9ic2VydmVyLm9uQ29tcGxldGVkLmJpbmQob2JzZXJ2ZXIpKTtcclxuICAgICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogIFJldHVybnMgZWxlbWVudHMgZnJvbSBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGFzIGxvbmcgYXMgYSBzcGVjaWZpZWQgY29uZGl0aW9uIGlzIHRydWUuXHJcbiAgICogIFRoZSBlbGVtZW50J3MgaW5kZXggaXMgdXNlZCBpbiB0aGUgbG9naWMgb2YgdGhlIHByZWRpY2F0ZSBmdW5jdGlvbi5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgQSBmdW5jdGlvbiB0byB0ZXN0IGVhY2ggZWxlbWVudCBmb3IgYSBjb25kaXRpb247IHRoZSBzZWNvbmQgcGFyYW1ldGVyIG9mIHRoZSBmdW5jdGlvbiByZXByZXNlbnRzIHRoZSBpbmRleCBvZiB0aGUgc291cmNlIGVsZW1lbnQuXHJcbiAgICogQHBhcmFtIHtBbnl9IFt0aGlzQXJnXSBPYmplY3QgdG8gdXNlIGFzIHRoaXMgd2hlbiBleGVjdXRpbmcgY2FsbGJhY2suXHJcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyB0aGUgZWxlbWVudHMgZnJvbSB0aGUgaW5wdXQgc2VxdWVuY2UgdGhhdCBvY2N1ciBiZWZvcmUgdGhlIGVsZW1lbnQgYXQgd2hpY2ggdGhlIHRlc3Qgbm8gbG9uZ2VyIHBhc3Nlcy5cclxuICAgKi9cclxuICBvYnNlcnZhYmxlUHJvdG8udGFrZVdoaWxlID0gZnVuY3Rpb24gKHByZWRpY2F0ZSwgdGhpc0FyZykge1xyXG4gICAgdmFyIG9ic2VydmFibGUgPSB0aGlzO1xyXG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICB2YXIgaSA9IDAsIHJ1bm5pbmcgPSB0cnVlO1xyXG4gICAgICByZXR1cm4gb2JzZXJ2YWJsZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICBpZiAocnVubmluZykge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcnVubmluZyA9IHByZWRpY2F0ZS5jYWxsKHRoaXNBcmcsIHgsIGkrKywgb2JzZXJ2YWJsZSk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChydW5uaW5nKSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm9uTmV4dCh4KTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9LCBvYnNlcnZlci5vbkVycm9yLmJpbmQob2JzZXJ2ZXIpLCBvYnNlcnZlci5vbkNvbXBsZXRlZC5iaW5kKG9ic2VydmVyKSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiAgRmlsdGVycyB0aGUgZWxlbWVudHMgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBiYXNlZCBvbiBhIHByZWRpY2F0ZSBieSBpbmNvcnBvcmF0aW5nIHRoZSBlbGVtZW50J3MgaW5kZXguXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqICB2YXIgcmVzID0gc291cmNlLndoZXJlKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgPCAxMDsgfSk7XHJcbiAgICogIHZhciByZXMgPSBzb3VyY2Uud2hlcmUoZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkgeyByZXR1cm4gdmFsdWUgPCAxMCB8fCBpbmRleCA8IDEwOyB9KTtcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgQSBmdW5jdGlvbiB0byB0ZXN0IGVhY2ggc291cmNlIGVsZW1lbnQgZm9yIGEgY29uZGl0aW9uOyB0aGUgc2Vjb25kIHBhcmFtZXRlciBvZiB0aGUgZnVuY3Rpb24gcmVwcmVzZW50cyB0aGUgaW5kZXggb2YgdGhlIHNvdXJjZSBlbGVtZW50LlxyXG4gICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyB0aGlzIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgZWxlbWVudHMgZnJvbSB0aGUgaW5wdXQgc2VxdWVuY2UgdGhhdCBzYXRpc2Z5IHRoZSBjb25kaXRpb24uXHJcbiAgICovXHJcbiAgb2JzZXJ2YWJsZVByb3RvLndoZXJlID0gb2JzZXJ2YWJsZVByb3RvLmZpbHRlciA9IGZ1bmN0aW9uIChwcmVkaWNhdGUsIHRoaXNBcmcpIHtcclxuICAgICAgdmFyIHBhcmVudCA9IHRoaXM7XHJcbiAgICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgICB2YXIgY291bnQgPSAwO1xyXG4gICAgICAgIHJldHVybiBwYXJlbnQuc3Vic2NyaWJlKGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgdmFyIHNob3VsZFJ1bjtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHNob3VsZFJ1biA9IHByZWRpY2F0ZS5jYWxsKHRoaXNBcmcsIHZhbHVlLCBjb3VudCsrLCBwYXJlbnQpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBvYnNlcnZlci5vbkVycm9yKGUpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBzaG91bGRSdW4gJiYgb2JzZXJ2ZXIub25OZXh0KHZhbHVlKTtcclxuICAgICAgICB9LCBvYnNlcnZlci5vbkVycm9yLmJpbmQob2JzZXJ2ZXIpLCBvYnNlcnZlci5vbkNvbXBsZXRlZC5iaW5kKG9ic2VydmVyKSk7XHJcbiAgICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIG9ic2VydmFibGVQcm90by5maW5hbFZhbHVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XHJcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgIHZhciBoYXNWYWx1ZSA9IGZhbHNlLCB2YWx1ZTtcclxuICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICBoYXNWYWx1ZSA9IHRydWU7XHJcbiAgICAgICAgdmFsdWUgPSB4O1xyXG4gICAgICB9LCBvYnNlcnZlci5vbkVycm9yLmJpbmQob2JzZXJ2ZXIpLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCFoYXNWYWx1ZSkge1xyXG4gICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihuZXcgRXJyb3Ioc2VxdWVuY2VDb250YWluc05vRWxlbWVudHMpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KHZhbHVlKTtcclxuICAgICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIGV4dHJlbWFCeShzb3VyY2UsIGtleVNlbGVjdG9yLCBjb21wYXJlcikge1xyXG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICB2YXIgaGFzVmFsdWUgPSBmYWxzZSwgbGFzdEtleSA9IG51bGwsIGxpc3QgPSBbXTtcclxuICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICB2YXIgY29tcGFyaXNvbiwga2V5O1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBrZXkgPSBrZXlTZWxlY3Rvcih4KTtcclxuICAgICAgICB9IGNhdGNoIChleCkge1xyXG4gICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihleCk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXBhcmlzb24gPSAwO1xyXG4gICAgICAgIGlmICghaGFzVmFsdWUpIHtcclxuICAgICAgICAgIGhhc1ZhbHVlID0gdHJ1ZTtcclxuICAgICAgICAgIGxhc3RLZXkgPSBrZXk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbXBhcmlzb24gPSBjb21wYXJlcihrZXksIGxhc3RLZXkpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZXgxKSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZXgxKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29tcGFyaXNvbiA+IDApIHtcclxuICAgICAgICAgIGxhc3RLZXkgPSBrZXk7XHJcbiAgICAgICAgICBsaXN0ID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb21wYXJpc29uID49IDApIHsgbGlzdC5wdXNoKHgpOyB9XHJcbiAgICAgIH0sIG9ic2VydmVyLm9uRXJyb3IuYmluZChvYnNlcnZlciksIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBvYnNlcnZlci5vbk5leHQobGlzdCk7XHJcbiAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZmlyc3RPbmx5KHgpIHtcclxuICAgICAgICBpZiAoeC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHNlcXVlbmNlQ29udGFpbnNOb0VsZW1lbnRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHhbMF07XHJcbiAgICB9XHJcblxyXG4gIC8qKlxuICAgKiBBcHBsaWVzIGFuIGFjY3VtdWxhdG9yIGZ1bmN0aW9uIG92ZXIgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSwgcmV0dXJuaW5nIHRoZSByZXN1bHQgb2YgdGhlIGFnZ3JlZ2F0aW9uIGFzIGEgc2luZ2xlIGVsZW1lbnQgaW4gdGhlIHJlc3VsdCBzZXF1ZW5jZS4gVGhlIHNwZWNpZmllZCBzZWVkIHZhbHVlIGlzIHVzZWQgYXMgdGhlIGluaXRpYWwgYWNjdW11bGF0b3IgdmFsdWUuXG4gICAqIEZvciBhZ2dyZWdhdGlvbiBiZWhhdmlvciB3aXRoIGluY3JlbWVudGFsIGludGVybWVkaWF0ZSByZXN1bHRzLCBzZWUgT2JzZXJ2YWJsZS5zY2FuLlxuICAgKiBAcGFyYW0ge01peGVkfSBbc2VlZF0gVGhlIGluaXRpYWwgYWNjdW11bGF0b3IgdmFsdWUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGFjY3VtdWxhdG9yIEFuIGFjY3VtdWxhdG9yIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgb24gZWFjaCBlbGVtZW50LlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIGEgc2luZ2xlIGVsZW1lbnQgd2l0aCB0aGUgZmluYWwgYWNjdW11bGF0b3IgdmFsdWUuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uYWdncmVnYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWVkLCBoYXNTZWVkLCBhY2N1bXVsYXRvcjtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgc2VlZCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGhhc1NlZWQgPSB0cnVlO1xuICAgICAgYWNjdW11bGF0b3IgPSBhcmd1bWVudHNbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gYXJndW1lbnRzWzBdO1xuICAgIH1cbiAgICByZXR1cm4gaGFzU2VlZCA/IHRoaXMuc2NhbihzZWVkLCBhY2N1bXVsYXRvcikuc3RhcnRXaXRoKHNlZWQpLmZpbmFsVmFsdWUoKSA6IHRoaXMuc2NhbihhY2N1bXVsYXRvcikuZmluYWxWYWx1ZSgpO1xuICB9O1xuXHJcbiAgLyoqXG4gICAqIEFwcGxpZXMgYW4gYWNjdW11bGF0b3IgZnVuY3Rpb24gb3ZlciBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlLCByZXR1cm5pbmcgdGhlIHJlc3VsdCBvZiB0aGUgYWdncmVnYXRpb24gYXMgYSBzaW5nbGUgZWxlbWVudCBpbiB0aGUgcmVzdWx0IHNlcXVlbmNlLiBUaGUgc3BlY2lmaWVkIHNlZWQgdmFsdWUgaXMgdXNlZCBhcyB0aGUgaW5pdGlhbCBhY2N1bXVsYXRvciB2YWx1ZS5cbiAgICogRm9yIGFnZ3JlZ2F0aW9uIGJlaGF2aW9yIHdpdGggaW5jcmVtZW50YWwgaW50ZXJtZWRpYXRlIHJlc3VsdHMsIHNlZSBPYnNlcnZhYmxlLnNjYW4uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGFjY3VtdWxhdG9yIEFuIGFjY3VtdWxhdG9yIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgb24gZWFjaCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0FueX0gW3NlZWRdIFRoZSBpbml0aWFsIGFjY3VtdWxhdG9yIHZhbHVlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIGEgc2luZ2xlIGVsZW1lbnQgd2l0aCB0aGUgZmluYWwgYWNjdW11bGF0b3IgdmFsdWUuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ucmVkdWNlID0gZnVuY3Rpb24gKGFjY3VtdWxhdG9yKSB7XG4gICAgdmFyIHNlZWQsIGhhc1NlZWQ7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIGhhc1NlZWQgPSB0cnVlO1xuICAgICAgc2VlZCA9IGFyZ3VtZW50c1sxXTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc1NlZWQgPyB0aGlzLnNjYW4oc2VlZCwgYWNjdW11bGF0b3IpLnN0YXJ0V2l0aChzZWVkKS5maW5hbFZhbHVlKCkgOiB0aGlzLnNjYW4oYWNjdW11bGF0b3IpLmZpbmFsVmFsdWUoKTtcbiAgfTtcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYW55IGVsZW1lbnQgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBzYXRpc2ZpZXMgYSBjb25kaXRpb24gaWYgcHJlc2VudCwgZWxzZSBpZiBhbnkgaXRlbXMgYXJlIGluIHRoZSBzZXF1ZW5jZS5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiB2YXIgcmVzdWx0ID0gc291cmNlLmFueSgpO1xyXG4gICAgICogdmFyIHJlc3VsdCA9IHNvdXJjZS5hbnkoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggPiAzOyB9KTtcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGVdIEEgZnVuY3Rpb24gdG8gdGVzdCBlYWNoIGVsZW1lbnQgZm9yIGEgY29uZGl0aW9uLlxyXG4gICAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBhIHNpbmdsZSBlbGVtZW50IGRldGVybWluaW5nIHdoZXRoZXIgYW55IGVsZW1lbnRzIGluIHRoZSBzb3VyY2Ugc2VxdWVuY2UgcGFzcyB0aGUgdGVzdCBpbiB0aGUgc3BlY2lmaWVkIHByZWRpY2F0ZSBpZiBnaXZlbiwgZWxzZSBpZiBhbnkgaXRlbXMgYXJlIGluIHRoZSBzZXF1ZW5jZS5cclxuICAgICAqL1xyXG4gICAgb2JzZXJ2YWJsZVByb3RvLnNvbWUgPSBvYnNlcnZhYmxlUHJvdG8uYW55ID0gZnVuY3Rpb24gKHByZWRpY2F0ZSwgdGhpc0FyZykge1xyXG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBwcmVkaWNhdGUgP1xyXG4gICAgICAgICAgICBzb3VyY2Uud2hlcmUocHJlZGljYXRlLCB0aGlzQXJnKS5hbnkoKSA6XHJcbiAgICAgICAgICAgIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm9uTmV4dCh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgICAgICAgICAgfSwgb2JzZXJ2ZXIub25FcnJvci5iaW5kKG9ic2VydmVyKSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm9uTmV4dChmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGVybWluZXMgd2hldGhlciBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGlzIGVtcHR5LlxyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgYSBzaW5nbGUgZWxlbWVudCBkZXRlcm1pbmluZyB3aGV0aGVyIHRoZSBzb3VyY2Ugc2VxdWVuY2UgaXMgZW1wdHkuXHJcbiAgICovXHJcbiAgb2JzZXJ2YWJsZVByb3RvLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5hbnkoKS5tYXAobm90KTtcclxuICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGFsbCBlbGVtZW50cyBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHNhdGlzZnkgYSBjb25kaXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogMSAtIHJlcyA9IHNvdXJjZS5hbGwoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZS5sZW5ndGggPiAzOyB9KTtcclxuICAgICAqIEBtZW1iZXJPZiBPYnNlcnZhYmxlI1xyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZV0gQSBmdW5jdGlvbiB0byB0ZXN0IGVhY2ggZWxlbWVudCBmb3IgYSBjb25kaXRpb24uXHJcbiAgICAgKiBAcGFyYW0ge0FueX0gW3RoaXNBcmddIE9iamVjdCB0byB1c2UgYXMgdGhpcyB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cclxuICAgICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgYSBzaW5nbGUgZWxlbWVudCBkZXRlcm1pbmluZyB3aGV0aGVyIGFsbCBlbGVtZW50cyBpbiB0aGUgc291cmNlIHNlcXVlbmNlIHBhc3MgdGhlIHRlc3QgaW4gdGhlIHNwZWNpZmllZCBwcmVkaWNhdGUuXHJcbiAgICAgKi9cclxuICAgIG9ic2VydmFibGVQcm90by5ldmVyeSA9IG9ic2VydmFibGVQcm90by5hbGwgPSBmdW5jdGlvbiAocHJlZGljYXRlLCB0aGlzQXJnKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud2hlcmUoZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgcmV0dXJuICFwcmVkaWNhdGUodik7XHJcbiAgICAgICAgfSwgdGhpc0FyZykuYW55KCkuc2VsZWN0KGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhYjtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGVybWluZXMgd2hldGhlciBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5zIGEgc3BlY2lmaWVkIGVsZW1lbnQgd2l0aCBhbiBvcHRpb25hbCBlcXVhbGl0eSBjb21wYXJlci5cclxuICAgKiBAcGFyYW0gc2VhcmNoRWxlbWVudCBUaGUgdmFsdWUgdG8gbG9jYXRlIGluIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtmcm9tSW5kZXhdIEFuIGVxdWFsaXR5IGNvbXBhcmVyIHRvIGNvbXBhcmUgZWxlbWVudHMuXHJcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBhIHNpbmdsZSBlbGVtZW50IGRldGVybWluaW5nIHdoZXRoZXIgdGhlIHNvdXJjZSBzZXF1ZW5jZSBjb250YWlucyBhbiBlbGVtZW50IHRoYXQgaGFzIHRoZSBzcGVjaWZpZWQgdmFsdWUgZnJvbSB0aGUgZ2l2ZW4gaW5kZXguXHJcbiAgICovXHJcbiAgb2JzZXJ2YWJsZVByb3RvLmNvbnRhaW5zID0gZnVuY3Rpb24gKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCkge1xyXG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XHJcbiAgICBmdW5jdGlvbiBjb21wYXJlcihhLCBiKSB7XHJcbiAgICAgIHJldHVybiAoYSA9PT0gMCAmJiBiID09PSAwKSB8fCAoYSA9PT0gYiB8fCAoaXNOYU4oYSkgJiYgaXNOYU4oYikpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgdmFyIGkgPSAwLCBuID0gK2Zyb21JbmRleCB8fCAwO1xyXG4gICAgICBNYXRoLmFicyhuKSA9PT0gSW5maW5pdHkgJiYgKG4gPSAwKTtcclxuICAgICAgaWYgKG4gPCAwKSB7XHJcbiAgICAgICAgb2JzZXJ2ZXIub25OZXh0KGZhbHNlKTtcclxuICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUoXHJcbiAgICAgICAgZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgIGlmIChpKysgPj0gbiAmJiBjb21wYXJlcih4LCBzZWFyY2hFbGVtZW50KSkge1xyXG4gICAgICAgICAgICBvYnNlcnZlci5vbk5leHQodHJ1ZSk7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvYnNlcnZlci5vbkVycm9yLmJpbmQob2JzZXJ2ZXIpLFxyXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIG9ic2VydmVyLm9uTmV4dChmYWxzZSk7XHJcbiAgICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIGEgdmFsdWUgdGhhdCByZXByZXNlbnRzIGhvdyBtYW55IGVsZW1lbnRzIGluIHRoZSBzcGVjaWZpZWQgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBzYXRpc2Z5IGEgY29uZGl0aW9uIGlmIHByb3ZpZGVkLCBlbHNlIHRoZSBjb3VudCBvZiBpdGVtcy5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiByZXMgPSBzb3VyY2UuY291bnQoKTtcclxuICAgICAqIHJlcyA9IHNvdXJjZS5jb3VudChmdW5jdGlvbiAoeCkgeyByZXR1cm4geCA+IDM7IH0pO1xyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZV1BIGZ1bmN0aW9uIHRvIHRlc3QgZWFjaCBlbGVtZW50IGZvciBhIGNvbmRpdGlvbi5cclxuICAgICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyB0aGlzIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxyXG4gICAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBhIHNpbmdsZSBlbGVtZW50IHdpdGggYSBudW1iZXIgdGhhdCByZXByZXNlbnRzIGhvdyBtYW55IGVsZW1lbnRzIGluIHRoZSBpbnB1dCBzZXF1ZW5jZSBzYXRpc2Z5IHRoZSBjb25kaXRpb24gaW4gdGhlIHByZWRpY2F0ZSBmdW5jdGlvbiBpZiBwcm92aWRlZCwgZWxzZSB0aGUgY291bnQgb2YgaXRlbXMgaW4gdGhlIHNlcXVlbmNlLlxyXG4gICAgICovXHJcbiAgICBvYnNlcnZhYmxlUHJvdG8uY291bnQgPSBmdW5jdGlvbiAocHJlZGljYXRlLCB0aGlzQXJnKSB7XHJcbiAgICAgICAgcmV0dXJuIHByZWRpY2F0ZSA/XHJcbiAgICAgICAgICAgIHRoaXMud2hlcmUocHJlZGljYXRlLCB0aGlzQXJnKS5jb3VudCgpIDpcclxuICAgICAgICAgICAgdGhpcy5hZ2dyZWdhdGUoMCwgZnVuY3Rpb24gKGNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY291bnQgKyAxO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IGluZGV4IGF0IHdoaWNoIGEgZ2l2ZW4gZWxlbWVudCBjYW4gYmUgZm91bmQgaW4gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UsIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50LlxyXG4gICAqIEBwYXJhbSB7QW55fSBzZWFyY2hFbGVtZW50IEVsZW1lbnQgdG8gbG9jYXRlIGluIHRoZSBhcnJheS5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gW2Zyb21JbmRleF0gVGhlIGluZGV4IHRvIHN0YXJ0IHRoZSBzZWFyY2guICBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byAwLlxyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbmQgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGdpdmVuIGVsZW1lbnQgY2FuIGJlIGZvdW5kIGluIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC5cclxuICAgKi9cclxuICBvYnNlcnZhYmxlUHJvdG8uaW5kZXhPZiA9IGZ1bmN0aW9uKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCkge1xyXG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XHJcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgIHZhciBpID0gMCwgbiA9ICtmcm9tSW5kZXggfHwgMDtcclxuICAgICAgTWF0aC5hYnMobikgPT09IEluZmluaXR5ICYmIChuID0gMCk7XHJcbiAgICAgIGlmIChuIDwgMCkge1xyXG4gICAgICAgIG9ic2VydmVyLm9uTmV4dCgtMSk7XHJcbiAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgICByZXR1cm4gZGlzcG9zYWJsZUVtcHR5O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKFxyXG4gICAgICAgIGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICBpZiAoaSA+PSBuICYmIHggPT09IHNlYXJjaEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KGkpO1xyXG4gICAgICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaSsrO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb2JzZXJ2ZXIub25FcnJvci5iaW5kKG9ic2VydmVyKSxcclxuICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBvYnNlcnZlci5vbk5leHQoLTEpO1xyXG4gICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH07XHJcbiAgLyoqXHJcbiAgICogQ29tcHV0ZXMgdGhlIHN1bSBvZiBhIHNlcXVlbmNlIG9mIHZhbHVlcyB0aGF0IGFyZSBvYnRhaW5lZCBieSBpbnZva2luZyBhbiBvcHRpb25hbCB0cmFuc2Zvcm0gZnVuY3Rpb24gb24gZWFjaCBlbGVtZW50IG9mIHRoZSBpbnB1dCBzZXF1ZW5jZSwgZWxzZSBpZiBub3Qgc3BlY2lmaWVkIGNvbXB1dGVzIHRoZSBzdW0gb24gZWFjaCBpdGVtIGluIHRoZSBzZXF1ZW5jZS5cclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIHZhciByZXMgPSBzb3VyY2Uuc3VtKCk7XHJcbiAgICogdmFyIHJlcyA9IHNvdXJjZS5zdW0oZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgudmFsdWU7IH0pO1xyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzZWxlY3Rvcl0gQSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBlbGVtZW50LlxyXG4gICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyB0aGlzIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgYSBzaW5nbGUgZWxlbWVudCB3aXRoIHRoZSBzdW0gb2YgdGhlIHZhbHVlcyBpbiB0aGUgc291cmNlIHNlcXVlbmNlLlxyXG4gICAqL1xyXG4gIG9ic2VydmFibGVQcm90by5zdW0gPSBmdW5jdGlvbiAoa2V5U2VsZWN0b3IsIHRoaXNBcmcpIHtcclxuICAgIHJldHVybiBrZXlTZWxlY3RvciAmJiBpc0Z1bmN0aW9uKGtleVNlbGVjdG9yKSA/XHJcbiAgICAgIHRoaXMubWFwKGtleVNlbGVjdG9yLCB0aGlzQXJnKS5zdW0oKSA6XHJcbiAgICAgIHRoaXMuYWdncmVnYXRlKDAsIGZ1bmN0aW9uIChwcmV2LCBjdXJyKSB7XHJcbiAgICAgICAgcmV0dXJuIHByZXYgKyBjdXJyO1xyXG4gICAgICB9KTtcclxuICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZWxlbWVudHMgaW4gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIHRoZSBtaW5pbXVtIGtleSB2YWx1ZSBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBjb21wYXJlci5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiB2YXIgcmVzID0gc291cmNlLm1pbkJ5KGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnZhbHVlOyB9KTtcclxuICAgICAqIHZhciByZXMgPSBzb3VyY2UubWluQnkoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgudmFsdWU7IH0sIGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiB4IC0geTsgfSk7XHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlTZWxlY3RvciBLZXkgc2VsZWN0b3IgZnVuY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyZXJdIENvbXBhcmVyIHVzZWQgdG8gY29tcGFyZSBrZXkgdmFsdWVzLlxyXG4gICAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBhIGxpc3Qgb2YgemVybyBvciBtb3JlIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1pbmltdW0ga2V5IHZhbHVlLlxyXG4gICAgICovXHJcbiAgICBvYnNlcnZhYmxlUHJvdG8ubWluQnkgPSBmdW5jdGlvbiAoa2V5U2VsZWN0b3IsIGNvbXBhcmVyKSB7XHJcbiAgICAgICAgY29tcGFyZXIgfHwgKGNvbXBhcmVyID0gZGVmYXVsdFN1YkNvbXBhcmVyKTtcclxuICAgICAgICByZXR1cm4gZXh0cmVtYUJ5KHRoaXMsIGtleVNlbGVjdG9yLCBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZXIoeCwgeSkgKiAtMTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBtaW5pbXVtIGVsZW1lbnQgaW4gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbmFsIGNvbXBhcmVyIGVsc2UgYSBkZWZhdWx0IGdyZWF0ZXIgdGhhbiBsZXNzIHRoYW4gY2hlY2suXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogdmFyIHJlcyA9IHNvdXJjZS5taW4oKTtcclxuICAgICAqIHZhciByZXMgPSBzb3VyY2UubWluKGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiB4LnZhbHVlIC0geS52YWx1ZTsgfSk7XHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyZXJdIENvbXBhcmVyIHVzZWQgdG8gY29tcGFyZSBlbGVtZW50cy5cclxuICAgICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgYSBzaW5nbGUgZWxlbWVudCB3aXRoIHRoZSBtaW5pbXVtIGVsZW1lbnQgaW4gdGhlIHNvdXJjZSBzZXF1ZW5jZS5cclxuICAgICAqL1xyXG4gICAgb2JzZXJ2YWJsZVByb3RvLm1pbiA9IGZ1bmN0aW9uIChjb21wYXJlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1pbkJ5KGlkZW50aXR5LCBjb21wYXJlcikuc2VsZWN0KGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmaXJzdE9ubHkoeCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZWxlbWVudHMgaW4gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIHRoZSBtYXhpbXVtICBrZXkgdmFsdWUgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgY29tcGFyZXIuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogdmFyIHJlcyA9IHNvdXJjZS5tYXhCeShmdW5jdGlvbiAoeCkgeyByZXR1cm4geC52YWx1ZTsgfSk7XHJcbiAgICAgKiB2YXIgcmVzID0gc291cmNlLm1heEJ5KGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnZhbHVlOyB9LCBmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4geCAtIHk7OyB9KTtcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleVNlbGVjdG9yIEtleSBzZWxlY3RvciBmdW5jdGlvbi5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJlcl0gIENvbXBhcmVyIHVzZWQgdG8gY29tcGFyZSBrZXkgdmFsdWVzLlxyXG4gICAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBhIGxpc3Qgb2YgemVybyBvciBtb3JlIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1heGltdW0ga2V5IHZhbHVlLlxyXG4gICAgICovXHJcbiAgICBvYnNlcnZhYmxlUHJvdG8ubWF4QnkgPSBmdW5jdGlvbiAoa2V5U2VsZWN0b3IsIGNvbXBhcmVyKSB7XHJcbiAgICAgICAgY29tcGFyZXIgfHwgKGNvbXBhcmVyID0gZGVmYXVsdFN1YkNvbXBhcmVyKTtcclxuICAgICAgICByZXR1cm4gZXh0cmVtYUJ5KHRoaXMsIGtleVNlbGVjdG9yLCBjb21wYXJlcik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZSBpbiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGNvbXBhcmVyLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIHZhciByZXMgPSBzb3VyY2UubWF4KCk7XHJcbiAgICAgKiB2YXIgcmVzID0gc291cmNlLm1heChmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4geC52YWx1ZSAtIHkudmFsdWU7IH0pO1xyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmVyXSBDb21wYXJlciB1c2VkIHRvIGNvbXBhcmUgZWxlbWVudHMuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIGEgc2luZ2xlIGVsZW1lbnQgd2l0aCB0aGUgbWF4aW11bSBlbGVtZW50IGluIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXHJcbiAgICAgKi9cclxuICAgIG9ic2VydmFibGVQcm90by5tYXggPSBmdW5jdGlvbiAoY29tcGFyZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXhCeShpZGVudGl0eSwgY29tcGFyZXIpLnNlbGVjdChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmlyc3RPbmx5KHgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBhdmVyYWdlIG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2Ugb2YgdmFsdWVzIHRoYXQgYXJlIGluIHRoZSBzZXF1ZW5jZSBvciBvYnRhaW5lZCBieSBpbnZva2luZyBhIHRyYW5zZm9ybSBmdW5jdGlvbiBvbiBlYWNoIGVsZW1lbnQgb2YgdGhlIGlucHV0IHNlcXVlbmNlIGlmIHByZXNlbnQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzZWxlY3Rvcl0gQSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0FueX0gW3RoaXNBcmddIE9iamVjdCB0byB1c2UgYXMgdGhpcyB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBhIHNpbmdsZSBlbGVtZW50IHdpdGggdGhlIGF2ZXJhZ2Ugb2YgdGhlIHNlcXVlbmNlIG9mIHZhbHVlcy5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5hdmVyYWdlID0gZnVuY3Rpb24gKGtleVNlbGVjdG9yLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGtleVNlbGVjdG9yICYmIGlzRnVuY3Rpb24oa2V5U2VsZWN0b3IpID9cbiAgICAgIHRoaXMuc2VsZWN0KGtleVNlbGVjdG9yLCB0aGlzQXJnKS5hdmVyYWdlKCkgOlxuICAgICAgdGhpcy5zY2FuKHtzdW06IDAsIGNvdW50OiAwIH0sIGZ1bmN0aW9uIChwcmV2LCBjdXIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdW06IHByZXYuc3VtICsgY3VyLFxuICAgICAgICAgIGNvdW50OiBwcmV2LmNvdW50ICsgMVxuICAgICAgICB9O1xuICAgICAgfSkuZmluYWxWYWx1ZSgpLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgICBpZiAocy5jb3VudCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGlucHV0IHNlcXVlbmNlIHdhcyBlbXB0eScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzLnN1bSAvIHMuY291bnQ7XG4gICAgICB9KTtcbiAgfTtcblxyXG4gIGZ1bmN0aW9uIHNlcXVlbmNlRXF1YWxBcnJheShmaXJzdCwgc2Vjb25kLCBjb21wYXJlcikge1xyXG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICB2YXIgY291bnQgPSAwLCBsZW4gPSBzZWNvbmQubGVuZ3RoO1xyXG4gICAgICByZXR1cm4gZmlyc3Quc3Vic2NyaWJlKGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHZhciBlcXVhbCA9IGZhbHNlO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb3VudCA8IGxlbiAmJiAoZXF1YWwgPSBjb21wYXJlcih2YWx1ZSwgc2Vjb25kW2NvdW50KytdKSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFlcXVhbCkge1xyXG4gICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KGZhbHNlKTtcclxuICAgICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LCBvYnNlcnZlci5vbkVycm9yLmJpbmQob2JzZXJ2ZXIpLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgb2JzZXJ2ZXIub25OZXh0KGNvdW50ID09PSBsZW4pO1xyXG4gICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiAgRGV0ZXJtaW5lcyB3aGV0aGVyIHR3byBzZXF1ZW5jZXMgYXJlIGVxdWFsIGJ5IGNvbXBhcmluZyB0aGUgZWxlbWVudHMgcGFpcndpc2UgdXNpbmcgYSBzcGVjaWZpZWQgZXF1YWxpdHkgY29tcGFyZXIuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIHZhciByZXMgPSByZXMgPSBzb3VyY2Uuc2VxdWVuY2VFcXVhbChbMSwyLDNdKTtcclxuICAgKiB2YXIgcmVzID0gcmVzID0gc291cmNlLnNlcXVlbmNlRXF1YWwoW3sgdmFsdWU6IDQyIH1dLCBmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4geC52YWx1ZSA9PT0geS52YWx1ZTsgfSk7XHJcbiAgICogMyAtIHJlcyA9IHNvdXJjZS5zZXF1ZW5jZUVxdWFsKFJ4Lk9ic2VydmFibGUucmV0dXJuVmFsdWUoNDIpKTtcclxuICAgKiA0IC0gcmVzID0gc291cmNlLnNlcXVlbmNlRXF1YWwoUnguT2JzZXJ2YWJsZS5yZXR1cm5WYWx1ZSh7IHZhbHVlOiA0MiB9KSwgZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIHgudmFsdWUgPT09IHkudmFsdWU7IH0pO1xyXG4gICAqIEBwYXJhbSB7T2JzZXJ2YWJsZX0gc2Vjb25kIFNlY29uZCBvYnNlcnZhYmxlIHNlcXVlbmNlIG9yIGFycmF5IHRvIGNvbXBhcmUuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmVyXSBDb21wYXJlciB1c2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYm90aCBzZXF1ZW5jZXMuXHJcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyBhIHNpbmdsZSBlbGVtZW50IHdoaWNoIGluZGljYXRlcyB3aGV0aGVyIGJvdGggc2VxdWVuY2VzIGFyZSBvZiBlcXVhbCBsZW5ndGggYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgZWxlbWVudHMgYXJlIGVxdWFsIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGVxdWFsaXR5IGNvbXBhcmVyLlxyXG4gICAqL1xyXG4gIG9ic2VydmFibGVQcm90by5zZXF1ZW5jZUVxdWFsID0gZnVuY3Rpb24gKHNlY29uZCwgY29tcGFyZXIpIHtcclxuICAgIHZhciBmaXJzdCA9IHRoaXM7XHJcbiAgICBjb21wYXJlciB8fCAoY29tcGFyZXIgPSBkZWZhdWx0Q29tcGFyZXIpO1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2Vjb25kKSkge1xyXG4gICAgICByZXR1cm4gc2VxdWVuY2VFcXVhbEFycmF5KGZpcnN0LCBzZWNvbmQsIGNvbXBhcmVyKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgdmFyIGRvbmVsID0gZmFsc2UsIGRvbmVyID0gZmFsc2UsIHFsID0gW10sIHFyID0gW107XHJcbiAgICAgIHZhciBzdWJzY3JpcHRpb24xID0gZmlyc3Quc3Vic2NyaWJlKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgdmFyIGVxdWFsLCB2O1xyXG4gICAgICAgIGlmIChxci5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICB2ID0gcXIuc2hpZnQoKTtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGVxdWFsID0gY29tcGFyZXIodiwgeCk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICghZXF1YWwpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KGZhbHNlKTtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGRvbmVyKSB7XHJcbiAgICAgICAgICBvYnNlcnZlci5vbk5leHQoZmFsc2UpO1xyXG4gICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcWwucHVzaCh4KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sIG9ic2VydmVyLm9uRXJyb3IuYmluZChvYnNlcnZlciksIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBkb25lbCA9IHRydWU7XHJcbiAgICAgICAgaWYgKHFsLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgaWYgKHFyLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KGZhbHNlKTtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoZG9uZXIpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KHRydWUpO1xyXG4gICAgICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpc1Byb21pc2Uoc2Vjb25kKSAmJiAoc2Vjb25kID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHNlY29uZCkpO1xyXG4gICAgICB2YXIgc3Vic2NyaXB0aW9uMiA9IHNlY29uZC5zdWJzY3JpYmUoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICB2YXIgZXF1YWw7XHJcbiAgICAgICAgaWYgKHFsLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIHZhciB2ID0gcWwuc2hpZnQoKTtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGVxdWFsID0gY29tcGFyZXIodiwgeCk7XHJcbiAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihleGNlcHRpb24pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoIWVxdWFsKSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm9uTmV4dChmYWxzZSk7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChkb25lbCkge1xyXG4gICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KGZhbHNlKTtcclxuICAgICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHFyLnB1c2goeCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LCBvYnNlcnZlci5vbkVycm9yLmJpbmQob2JzZXJ2ZXIpLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZG9uZXIgPSB0cnVlO1xyXG4gICAgICAgIGlmIChxci5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgIGlmIChxbC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm9uTmV4dChmYWxzZSk7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGRvbmVsKSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm9uTmV4dCh0cnVlKTtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoc3Vic2NyaXB0aW9uMSwgc3Vic2NyaXB0aW9uMik7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGVsZW1lbnRBdE9yRGVmYXVsdChzb3VyY2UsIGluZGV4LCBoYXNEZWZhdWx0LCBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihhcmd1bWVudE91dE9mUmFuZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gaW5kZXg7XHJcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm9uTmV4dCh4KTtcclxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaS0tO1xyXG4gICAgICAgICAgICB9LCBvYnNlcnZlci5vbkVycm9yLmJpbmQob2JzZXJ2ZXIpLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0RlZmF1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5vbkVycm9yKG5ldyBFcnJvcihhcmd1bWVudE91dE9mUmFuZ2UpKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KGRlZmF1bHRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBlbGVtZW50IGF0IGEgc3BlY2lmaWVkIGluZGV4IGluIGEgc2VxdWVuY2UuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogdmFyIHJlcyA9IHNvdXJjZS5lbGVtZW50QXQoNSk7XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggVGhlIHplcm8tYmFzZWQgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmV0cmlldmUuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHByb2R1Y2VzIHRoZSBlbGVtZW50IGF0IHRoZSBzcGVjaWZpZWQgcG9zaXRpb24gaW4gdGhlIHNvdXJjZSBzZXF1ZW5jZS5cclxuICAgICAqL1xyXG4gICAgb2JzZXJ2YWJsZVByb3RvLmVsZW1lbnRBdCA9ICBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gZWxlbWVudEF0T3JEZWZhdWx0KHRoaXMsIGluZGV4LCBmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZWxlbWVudCBhdCBhIHNwZWNpZmllZCBpbmRleCBpbiBhIHNlcXVlbmNlIG9yIGEgZGVmYXVsdCB2YWx1ZSBpZiB0aGUgaW5kZXggaXMgb3V0IG9mIHJhbmdlLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIHZhciByZXMgPSBzb3VyY2UuZWxlbWVudEF0T3JEZWZhdWx0KDUpO1xyXG4gICAgICogdmFyIHJlcyA9IHNvdXJjZS5lbGVtZW50QXRPckRlZmF1bHQoNSwgMCk7XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggVGhlIHplcm8tYmFzZWQgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmV0cmlldmUuXHJcbiAgICAgKiBAcGFyYW0gW2RlZmF1bHRWYWx1ZV0gVGhlIGRlZmF1bHQgdmFsdWUgaWYgdGhlIGluZGV4IGlzIG91dHNpZGUgdGhlIGJvdW5kcyBvZiB0aGUgc291cmNlIHNlcXVlbmNlLlxyXG4gICAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBwcm9kdWNlcyB0aGUgZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uIGluIHRoZSBzb3VyY2Ugc2VxdWVuY2UsIG9yIGEgZGVmYXVsdCB2YWx1ZSBpZiB0aGUgaW5kZXggaXMgb3V0c2lkZSB0aGUgYm91bmRzIG9mIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXHJcbiAgICAgKi9cclxuICAgIG9ic2VydmFibGVQcm90by5lbGVtZW50QXRPckRlZmF1bHQgPSBmdW5jdGlvbiAoaW5kZXgsIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBlbGVtZW50QXRPckRlZmF1bHQodGhpcywgaW5kZXgsIHRydWUsIGRlZmF1bHRWYWx1ZSk7XHJcbiAgICB9O1xyXG5cclxuICBmdW5jdGlvbiBzaW5nbGVPckRlZmF1bHRBc3luYyhzb3VyY2UsIGhhc0RlZmF1bHQsIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICB2YXIgdmFsdWUgPSBkZWZhdWx0VmFsdWUsIHNlZW5WYWx1ZSA9IGZhbHNlO1xyXG4gICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIGlmIChzZWVuVmFsdWUpIHtcclxuICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IobmV3IEVycm9yKCdTZXF1ZW5jZSBjb250YWlucyBtb3JlIHRoYW4gb25lIGVsZW1lbnQnKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHZhbHVlID0geDtcclxuICAgICAgICAgIHNlZW5WYWx1ZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LCBvYnNlcnZlci5vbkVycm9yLmJpbmQob2JzZXJ2ZXIpLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCFzZWVuVmFsdWUgJiYgIWhhc0RlZmF1bHQpIHtcclxuICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IobmV3IEVycm9yKHNlcXVlbmNlQ29udGFpbnNOb0VsZW1lbnRzKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG9ic2VydmVyLm9uTmV4dCh2YWx1ZSk7XHJcbiAgICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIG9ubHkgZWxlbWVudCBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgc2F0aXNmaWVzIHRoZSBjb25kaXRpb24gaW4gdGhlIG9wdGlvbmFsIHByZWRpY2F0ZSwgYW5kIHJlcG9ydHMgYW4gZXhjZXB0aW9uIGlmIHRoZXJlIGlzIG5vdCBleGFjdGx5IG9uZSBlbGVtZW50IGluIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogdmFyIHJlcyA9IHJlcyA9IHNvdXJjZS5zaW5nbGUoKTtcclxuICAgKiB2YXIgcmVzID0gcmVzID0gc291cmNlLnNpbmdsZShmdW5jdGlvbiAoeCkgeyByZXR1cm4geCA9PT0gNDI7IH0pO1xyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGVdIEEgcHJlZGljYXRlIGZ1bmN0aW9uIHRvIGV2YWx1YXRlIGZvciBlbGVtZW50cyBpbiB0aGUgc291cmNlIHNlcXVlbmNlLlxyXG4gICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgdGhlIHByZWRpY2F0ZS5cclxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gU2VxdWVuY2UgY29udGFpbmluZyB0aGUgc2luZ2xlIGVsZW1lbnQgaW4gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBzYXRpc2ZpZXMgdGhlIGNvbmRpdGlvbiBpbiB0aGUgcHJlZGljYXRlLlxyXG4gICAqL1xyXG4gIG9ic2VydmFibGVQcm90by5zaW5nbGUgPSBmdW5jdGlvbiAocHJlZGljYXRlLCB0aGlzQXJnKSB7XHJcbiAgICByZXR1cm4gcHJlZGljYXRlICYmIGlzRnVuY3Rpb24ocHJlZGljYXRlKSA/XHJcbiAgICAgIHRoaXMud2hlcmUocHJlZGljYXRlLCB0aGlzQXJnKS5zaW5nbGUoKSA6XHJcbiAgICAgIHNpbmdsZU9yRGVmYXVsdEFzeW5jKHRoaXMsIGZhbHNlKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBvbmx5IGVsZW1lbnQgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IG1hdGNoZXMgdGhlIHByZWRpY2F0ZSwgb3IgYSBkZWZhdWx0IHZhbHVlIGlmIG5vIHN1Y2ggZWxlbWVudCBleGlzdHM7IHRoaXMgbWV0aG9kIHJlcG9ydHMgYW4gZXhjZXB0aW9uIGlmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgZWxlbWVudCBpbiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIHZhciByZXMgPSByZXMgPSBzb3VyY2Uuc2luZ2xlT3JEZWZhdWx0KCk7XHJcbiAgICogdmFyIHJlcyA9IHJlcyA9IHNvdXJjZS5zaW5nbGVPckRlZmF1bHQoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggPT09IDQyOyB9KTtcclxuICAgKiByZXMgPSBzb3VyY2Uuc2luZ2xlT3JEZWZhdWx0KGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ID09PSA0MjsgfSwgMCk7XHJcbiAgICogcmVzID0gc291cmNlLnNpbmdsZU9yRGVmYXVsdChudWxsLCAwKTtcclxuICAgKiBAbWVtYmVyT2YgT2JzZXJ2YWJsZSNcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgQSBwcmVkaWNhdGUgZnVuY3Rpb24gdG8gZXZhbHVhdGUgZm9yIGVsZW1lbnRzIGluIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXHJcbiAgICogQHBhcmFtIFtkZWZhdWx0VmFsdWVdIFRoZSBkZWZhdWx0IHZhbHVlIGlmIHRoZSBpbmRleCBpcyBvdXRzaWRlIHRoZSBib3VuZHMgb2YgdGhlIHNvdXJjZSBzZXF1ZW5jZS5cclxuICAgKiBAcGFyYW0ge0FueX0gW3RoaXNBcmddIE9iamVjdCB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIHRoZSBwcmVkaWNhdGUuXHJcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIHNpbmdsZSBlbGVtZW50IGluIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgc2F0aXNmaWVzIHRoZSBjb25kaXRpb24gaW4gdGhlIHByZWRpY2F0ZSwgb3IgYSBkZWZhdWx0IHZhbHVlIGlmIG5vIHN1Y2ggZWxlbWVudCBleGlzdHMuXHJcbiAgICovXHJcbiAgb2JzZXJ2YWJsZVByb3RvLnNpbmdsZU9yRGVmYXVsdCA9IGZ1bmN0aW9uIChwcmVkaWNhdGUsIGRlZmF1bHRWYWx1ZSwgdGhpc0FyZykge1xyXG4gICAgcmV0dXJuIHByZWRpY2F0ZSAmJiBpc0Z1bmN0aW9uKHByZWRpY2F0ZSkgP1xyXG4gICAgICB0aGlzLndoZXJlKHByZWRpY2F0ZSwgdGhpc0FyZykuc2luZ2xlT3JEZWZhdWx0KG51bGwsIGRlZmF1bHRWYWx1ZSkgOlxyXG4gICAgICBzaW5nbGVPckRlZmF1bHRBc3luYyh0aGlzLCB0cnVlLCBkZWZhdWx0VmFsdWUpO1xyXG4gIH07XHJcblxyXG4gICAgZnVuY3Rpb24gZmlyc3RPckRlZmF1bHRBc3luYyhzb3VyY2UsIGhhc0RlZmF1bHQsIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgIG9ic2VydmVyLm9uTmV4dCh4KTtcclxuICAgICAgICAgICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgICAgICAgIH0sIG9ic2VydmVyLm9uRXJyb3IuYmluZChvYnNlcnZlciksIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaGFzRGVmYXVsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IobmV3IEVycm9yKHNlcXVlbmNlQ29udGFpbnNOb0VsZW1lbnRzKSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm9uTmV4dChkZWZhdWx0VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgc2F0aXNmaWVzIHRoZSBjb25kaXRpb24gaW4gdGhlIHByZWRpY2F0ZSBpZiBwcmVzZW50IGVsc2UgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIHNlcXVlbmNlLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIHZhciByZXMgPSByZXMgPSBzb3VyY2UuZmlyc3QoKTtcclxuICAgICAqIHZhciByZXMgPSByZXMgPSBzb3VyY2UuZmlyc3QoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggPiAzOyB9KTtcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGVdIEEgcHJlZGljYXRlIGZ1bmN0aW9uIHRvIGV2YWx1YXRlIGZvciBlbGVtZW50cyBpbiB0aGUgc291cmNlIHNlcXVlbmNlLlxyXG4gICAgICogQHBhcmFtIHtBbnl9IFt0aGlzQXJnXSBPYmplY3QgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyB0aGUgcHJlZGljYXRlLlxyXG4gICAgICogQHJldHVybnMge09ic2VydmFibGV9IFNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBzYXRpc2ZpZXMgdGhlIGNvbmRpdGlvbiBpbiB0aGUgcHJlZGljYXRlIGlmIHByb3ZpZGVkLCBlbHNlIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBzZXF1ZW5jZS5cclxuICAgICAqL1xyXG4gICAgb2JzZXJ2YWJsZVByb3RvLmZpcnN0ID0gZnVuY3Rpb24gKHByZWRpY2F0ZSwgdGhpc0FyZykge1xyXG4gICAgICAgIHJldHVybiBwcmVkaWNhdGUgP1xyXG4gICAgICAgICAgICB0aGlzLndoZXJlKHByZWRpY2F0ZSwgdGhpc0FyZykuZmlyc3QoKSA6XHJcbiAgICAgICAgICAgIGZpcnN0T3JEZWZhdWx0QXN5bmModGhpcywgZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHNhdGlzZmllcyB0aGUgY29uZGl0aW9uIGluIHRoZSBwcmVkaWNhdGUsIG9yIGEgZGVmYXVsdCB2YWx1ZSBpZiBubyBzdWNoIGVsZW1lbnQgZXhpc3RzLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIHZhciByZXMgPSByZXMgPSBzb3VyY2UuZmlyc3RPckRlZmF1bHQoKTtcclxuICAgICAqIHZhciByZXMgPSByZXMgPSBzb3VyY2UuZmlyc3RPckRlZmF1bHQoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggPiAzOyB9KTtcclxuICAgICAqIHZhciByZXMgPSBzb3VyY2UuZmlyc3RPckRlZmF1bHQoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggPiAzOyB9LCAwKTtcclxuICAgICAqIHZhciByZXMgPSBzb3VyY2UuZmlyc3RPckRlZmF1bHQobnVsbCwgMCk7XHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlXSBBIHByZWRpY2F0ZSBmdW5jdGlvbiB0byBldmFsdWF0ZSBmb3IgZWxlbWVudHMgaW4gdGhlIHNvdXJjZSBzZXF1ZW5jZS5cclxuICAgICAqIEBwYXJhbSB7QW55fSBbZGVmYXVsdFZhbHVlXSBUaGUgZGVmYXVsdCB2YWx1ZSBpZiBubyBzdWNoIGVsZW1lbnQgZXhpc3RzLiAgSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gbnVsbC5cclxuICAgICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgdGhlIHByZWRpY2F0ZS5cclxuICAgICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBTZXF1ZW5jZSBjb250YWluaW5nIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgc2F0aXNmaWVzIHRoZSBjb25kaXRpb24gaW4gdGhlIHByZWRpY2F0ZSwgb3IgYSBkZWZhdWx0IHZhbHVlIGlmIG5vIHN1Y2ggZWxlbWVudCBleGlzdHMuXHJcbiAgICAgKi9cclxuICAgIG9ic2VydmFibGVQcm90by5maXJzdE9yRGVmYXVsdCA9IGZ1bmN0aW9uIChwcmVkaWNhdGUsIGRlZmF1bHRWYWx1ZSwgdGhpc0FyZykge1xyXG4gICAgICAgIHJldHVybiBwcmVkaWNhdGUgP1xyXG4gICAgICAgICAgICB0aGlzLndoZXJlKHByZWRpY2F0ZSkuZmlyc3RPckRlZmF1bHQobnVsbCwgZGVmYXVsdFZhbHVlKSA6XHJcbiAgICAgICAgICAgIGZpcnN0T3JEZWZhdWx0QXN5bmModGhpcywgdHJ1ZSwgZGVmYXVsdFZhbHVlKTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gbGFzdE9yRGVmYXVsdEFzeW5jKHNvdXJjZSwgaGFzRGVmYXVsdCwgZGVmYXVsdFZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBkZWZhdWx0VmFsdWUsIHNlZW5WYWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB4O1xyXG4gICAgICAgICAgICAgICAgc2VlblZhbHVlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSwgb2JzZXJ2ZXIub25FcnJvci5iaW5kKG9ic2VydmVyKSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzZWVuVmFsdWUgJiYgIWhhc0RlZmF1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5vbkVycm9yKG5ldyBFcnJvcihzZXF1ZW5jZUNvbnRhaW5zTm9FbGVtZW50cykpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5vbk5leHQodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50IG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBzYXRpc2ZpZXMgdGhlIGNvbmRpdGlvbiBpbiB0aGUgcHJlZGljYXRlIGlmIHNwZWNpZmllZCwgZWxzZSB0aGUgbGFzdCBlbGVtZW50LlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIHZhciByZXMgPSBzb3VyY2UubGFzdCgpO1xyXG4gICAgICogdmFyIHJlcyA9IHNvdXJjZS5sYXN0KGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ID4gMzsgfSk7XHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlXSBBIHByZWRpY2F0ZSBmdW5jdGlvbiB0byBldmFsdWF0ZSBmb3IgZWxlbWVudHMgaW4gdGhlIHNvdXJjZSBzZXF1ZW5jZS5cclxuICAgICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgdGhlIHByZWRpY2F0ZS5cclxuICAgICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBTZXF1ZW5jZSBjb250YWluaW5nIHRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBzYXRpc2ZpZXMgdGhlIGNvbmRpdGlvbiBpbiB0aGUgcHJlZGljYXRlLlxyXG4gICAgICovXHJcbiAgICBvYnNlcnZhYmxlUHJvdG8ubGFzdCA9IGZ1bmN0aW9uIChwcmVkaWNhdGUsIHRoaXNBcmcpIHtcclxuICAgICAgICByZXR1cm4gcHJlZGljYXRlID9cclxuICAgICAgICAgICAgdGhpcy53aGVyZShwcmVkaWNhdGUsIHRoaXNBcmcpLmxhc3QoKSA6XHJcbiAgICAgICAgICAgIGxhc3RPckRlZmF1bHRBc3luYyh0aGlzLCBmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50IG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBzYXRpc2ZpZXMgdGhlIGNvbmRpdGlvbiBpbiB0aGUgcHJlZGljYXRlLCBvciBhIGRlZmF1bHQgdmFsdWUgaWYgbm8gc3VjaCBlbGVtZW50IGV4aXN0cy5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiB2YXIgcmVzID0gc291cmNlLmxhc3RPckRlZmF1bHQoKTtcclxuICAgICAqIHZhciByZXMgPSBzb3VyY2UubGFzdE9yRGVmYXVsdChmdW5jdGlvbiAoeCkgeyByZXR1cm4geCA+IDM7IH0pO1xyXG4gICAgICogdmFyIHJlcyA9IHNvdXJjZS5sYXN0T3JEZWZhdWx0KGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ID4gMzsgfSwgMCk7XHJcbiAgICAgKiB2YXIgcmVzID0gc291cmNlLmxhc3RPckRlZmF1bHQobnVsbCwgMCk7XHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlXSBBIHByZWRpY2F0ZSBmdW5jdGlvbiB0byBldmFsdWF0ZSBmb3IgZWxlbWVudHMgaW4gdGhlIHNvdXJjZSBzZXF1ZW5jZS5cclxuICAgICAqIEBwYXJhbSBbZGVmYXVsdFZhbHVlXSBUaGUgZGVmYXVsdCB2YWx1ZSBpZiBubyBzdWNoIGVsZW1lbnQgZXhpc3RzLiAgSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gbnVsbC5cclxuICAgICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgdGhlIHByZWRpY2F0ZS5cclxuICAgICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBTZXF1ZW5jZSBjb250YWluaW5nIHRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBzYXRpc2ZpZXMgdGhlIGNvbmRpdGlvbiBpbiB0aGUgcHJlZGljYXRlLCBvciBhIGRlZmF1bHQgdmFsdWUgaWYgbm8gc3VjaCBlbGVtZW50IGV4aXN0cy5cclxuICAgICAqL1xyXG4gICAgb2JzZXJ2YWJsZVByb3RvLmxhc3RPckRlZmF1bHQgPSBmdW5jdGlvbiAocHJlZGljYXRlLCBkZWZhdWx0VmFsdWUsIHRoaXNBcmcpIHtcclxuICAgICAgICByZXR1cm4gcHJlZGljYXRlID9cclxuICAgICAgICAgICAgdGhpcy53aGVyZShwcmVkaWNhdGUsIHRoaXNBcmcpLmxhc3RPckRlZmF1bHQobnVsbCwgZGVmYXVsdFZhbHVlKSA6XHJcbiAgICAgICAgICAgIGxhc3RPckRlZmF1bHRBc3luYyh0aGlzLCB0cnVlLCBkZWZhdWx0VmFsdWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBmaW5kVmFsdWUgKHNvdXJjZSwgcHJlZGljYXRlLCB0aGlzQXJnLCB5aWVsZEluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2hvdWxkUnVuO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBzaG91bGRSdW4gPSBwcmVkaWNhdGUuY2FsbCh0aGlzQXJnLCB4LCBpLCBzb3VyY2UpO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkUnVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KHlpZWxkSW5kZXggPyBpIDogeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBvYnNlcnZlci5vbkVycm9yLmJpbmQob2JzZXJ2ZXIpLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5vbk5leHQoeWllbGRJbmRleCA/IC0xIDogdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VhcmNoZXMgZm9yIGFuIGVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBjb25kaXRpb25zIGRlZmluZWQgYnkgdGhlIHNwZWNpZmllZCBwcmVkaWNhdGUsIGFuZCByZXR1cm5zIHRoZSBmaXJzdCBvY2N1cnJlbmNlIHdpdGhpbiB0aGUgZW50aXJlIE9ic2VydmFibGUgc2VxdWVuY2UuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIHByZWRpY2F0ZSB0aGF0IGRlZmluZXMgdGhlIGNvbmRpdGlvbnMgb2YgdGhlIGVsZW1lbnQgdG8gc2VhcmNoIGZvci5cclxuICAgICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgdGhlIHByZWRpY2F0ZS5cclxuICAgICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBjb25kaXRpb25zIGRlZmluZWQgYnkgdGhlIHNwZWNpZmllZCBwcmVkaWNhdGUsIGlmIGZvdW5kOyBvdGhlcndpc2UsIHVuZGVmaW5lZC5cclxuICAgICAqL1xyXG4gICAgb2JzZXJ2YWJsZVByb3RvLmZpbmQgPSBmdW5jdGlvbiAocHJlZGljYXRlLCB0aGlzQXJnKSB7XHJcbiAgICAgICAgcmV0dXJuIGZpbmRWYWx1ZSh0aGlzLCBwcmVkaWNhdGUsIHRoaXNBcmcsIGZhbHNlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZWFyY2hlcyBmb3IgYW4gZWxlbWVudCB0aGF0IG1hdGNoZXMgdGhlIGNvbmRpdGlvbnMgZGVmaW5lZCBieSB0aGUgc3BlY2lmaWVkIHByZWRpY2F0ZSwgYW5kIHJldHVybnNcclxuICAgICAqIGFuIE9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCB0aGUgemVyby1iYXNlZCBpbmRleCBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSB3aXRoaW4gdGhlIGVudGlyZSBPYnNlcnZhYmxlIHNlcXVlbmNlLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUgdGhhdCBkZWZpbmVzIHRoZSBjb25kaXRpb25zIG9mIHRoZSBlbGVtZW50IHRvIHNlYXJjaCBmb3IuXHJcbiAgICAgKiBAcGFyYW0ge0FueX0gW3RoaXNBcmddIE9iamVjdCB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIHRoZSBwcmVkaWNhdGUuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIHRoZSB6ZXJvLWJhc2VkIGluZGV4IG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGFuIGVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBjb25kaXRpb25zIGRlZmluZWQgYnkgbWF0Y2gsIGlmIGZvdW5kOyBvdGhlcndpc2UsIOKAkzEuXHJcbiAgICAqL1xyXG4gICAgb2JzZXJ2YWJsZVByb3RvLmZpbmRJbmRleCA9IGZ1bmN0aW9uIChwcmVkaWNhdGUsIHRoaXNBcmcpIHtcclxuICAgICAgICByZXR1cm4gZmluZFZhbHVlKHRoaXMsIHByZWRpY2F0ZSwgdGhpc0FyZywgdHJ1ZSk7XHJcbiAgICB9O1xyXG5cclxuICBpZiAoISFyb290LlNldCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0byBhIFNldCBpZiBpdCBleGlzdHMuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIGEgc2luZ2xlIHZhbHVlIG9mIGEgU2V0IGNvbnRhaW5pbmcgdGhlIHZhbHVlcyBmcm9tIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxyXG4gICAgICovXHJcbiAgICBvYnNlcnZhYmxlUHJvdG8udG9TZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzO1xyXG4gICAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgICAgdmFyIHMgPSBuZXcgcm9vdC5TZXQoKTtcclxuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShcclxuICAgICAgICAgIHMuYWRkLmJpbmQocyksXHJcbiAgICAgICAgICBvYnNlcnZlci5vbkVycm9yLmJpbmQob2JzZXJ2ZXIpLFxyXG4gICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBvYnNlcnZlci5vbk5leHQocyk7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgaWYgKCEhcm9vdC5NYXApIHtcclxuICAgIC8qKlxyXG4gICAgKiBDb252ZXJ0cyB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0byBhIE1hcCBpZiBpdCBleGlzdHMuXHJcbiAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleVNlbGVjdG9yIEEgZnVuY3Rpb24gd2hpY2ggcHJvZHVjZXMgdGhlIGtleSBmb3IgdGhlIE1hcC5cclxuICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2VsZW1lbnRTZWxlY3Rvcl0gQW4gb3B0aW9uYWwgZnVuY3Rpb24gd2hpY2ggcHJvZHVjZXMgdGhlIGVsZW1lbnQgZm9yIHRoZSBNYXAuIElmIG5vdCBwcmVzZW50LCBkZWZhdWx0cyB0byB0aGUgdmFsdWUgZnJvbSB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cclxuICAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCBhIHNpbmdsZSB2YWx1ZSBvZiBhIE1hcCBjb250YWluaW5nIHRoZSB2YWx1ZXMgZnJvbSB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cclxuICAgICovXHJcbiAgICBvYnNlcnZhYmxlUHJvdG8udG9NYXAgPSBmdW5jdGlvbiAoa2V5U2VsZWN0b3IsIGVsZW1lbnRTZWxlY3Rvcikge1xyXG4gICAgICB2YXIgc291cmNlID0gdGhpcztcclxuICAgICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgIHZhciBtID0gbmV3IHJvb3QuTWFwKCk7XHJcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUoXHJcbiAgICAgICAgICBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICB2YXIga2V5O1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIGtleSA9IGtleVNlbGVjdG9yKHgpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlKTtcclxuICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0geDtcclxuICAgICAgICAgICAgaWYgKGVsZW1lbnRTZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudFNlbGVjdG9yKHgpO1xyXG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBtLnNldChrZXksIGVsZW1lbnQpO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IuYmluZChvYnNlcnZlciksXHJcbiAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm9uTmV4dChtKTtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICB2YXIgZm5TdHJpbmcgPSAnZnVuY3Rpb24nLFxyXG4gICAgICB0aHJvd1N0cmluZyA9ICd0aHJvdyc7XHJcblxyXG4gIGZ1bmN0aW9uIHRvVGh1bmsob2JqLCBjdHgpIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHsgIHJldHVybiBvYmplY3RUb1RodW5rLmNhbGwoY3R4LCBvYmopOyB9XHJcbiAgICBpZiAoaXNHZW5lcmF0b3JGdW5jdGlvbihvYmopKSB7IHJldHVybiBvYnNlcnZhYmxlU3Bhd24ob2JqLmNhbGwoY3R4KSk7IH1cclxuICAgIGlmIChpc0dlbmVyYXRvcihvYmopKSB7ICByZXR1cm4gb2JzZXJ2YWJsZVNwYXduKG9iaik7IH1cclxuICAgIGlmIChpc09ic2VydmFibGUob2JqKSkgeyByZXR1cm4gb2JzZXJ2YWJsZVRvVGh1bmsob2JqKTsgfVxyXG4gICAgaWYgKGlzUHJvbWlzZShvYmopKSB7IHJldHVybiBwcm9taXNlVG9UaHVuayhvYmopOyB9XHJcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gZm5TdHJpbmcpIHsgcmV0dXJuIG9iajsgfVxyXG4gICAgaWYgKGlzT2JqZWN0KG9iaikgfHwgQXJyYXkuaXNBcnJheShvYmopKSB7IHJldHVybiBvYmplY3RUb1RodW5rLmNhbGwoY3R4LCBvYmopOyB9XHJcblxyXG4gICAgcmV0dXJuIG9iajtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG9iamVjdFRvVGh1bmsob2JqKSB7XHJcbiAgICB2YXIgY3R4ID0gdGhpcztcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGRvbmUpIHtcclxuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopLFxyXG4gICAgICAgICAgcGVuZGluZyA9IGtleXMubGVuZ3RoLFxyXG4gICAgICAgICAgcmVzdWx0cyA9IG5ldyBvYmouY29uc3RydWN0b3IoKSxcclxuICAgICAgICAgIGZpbmlzaGVkO1xyXG5cclxuICAgICAgaWYgKCFwZW5kaW5nKSB7XHJcbiAgICAgICAgdGltZW91dFNjaGVkdWxlci5zY2hlZHVsZShmdW5jdGlvbiAoKSB7IGRvbmUobnVsbCwgcmVzdWx0cyk7IH0pO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGtleXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBydW4ob2JqW2tleXNbaV1dLCBrZXlzW2ldKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gcnVuKGZuLCBrZXkpIHtcclxuICAgICAgICBpZiAoZmluaXNoZWQpIHsgcmV0dXJuOyB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGZuID0gdG9UaHVuayhmbiwgY3R4KTtcclxuXHJcbiAgICAgICAgICBpZiAodHlwZW9mIGZuICE9PSBmblN0cmluZykge1xyXG4gICAgICAgICAgICByZXN1bHRzW2tleV0gPSBmbjtcclxuICAgICAgICAgICAgcmV0dXJuIC0tcGVuZGluZyB8fCBkb25lKG51bGwsIHJlc3VsdHMpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZuLmNhbGwoY3R4LCBmdW5jdGlvbihlcnIsIHJlcyl7XHJcbiAgICAgICAgICAgIGlmIChmaW5pc2hlZCkgeyByZXR1cm47IH1cclxuXHJcbiAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGRvbmUoZXJyKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmVzdWx0c1trZXldID0gcmVzO1xyXG4gICAgICAgICAgICAtLXBlbmRpbmcgfHwgZG9uZShudWxsLCByZXN1bHRzKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcclxuICAgICAgICAgIGRvbmUoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBvYnNlcnZhYmxlVG9UaHVuayhvYnNlcnZhYmxlKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgIHZhciB2YWx1ZSwgaGFzVmFsdWUgPSBmYWxzZTtcclxuICAgICAgb2JzZXJ2YWJsZS5zdWJzY3JpYmUoXHJcbiAgICAgICAgZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgIHZhbHVlID0gdjtcclxuICAgICAgICAgIGhhc1ZhbHVlID0gdHJ1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZuLFxyXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGhhc1ZhbHVlICYmIGZuKG51bGwsIHZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHByb21pc2VUb1RodW5rKHByb21pc2UpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbihmbil7XHJcbiAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbihyZXMpIHtcclxuICAgICAgICBmbihudWxsLCByZXMpO1xyXG4gICAgICB9LCBmbik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpc09ic2VydmFibGUob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBvYmouc3Vic2NyaWJlID09PSBmblN0cmluZztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGlzR2VuZXJhdG9yRnVuY3Rpb24ob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqICYmIG9iai5jb25zdHJ1Y3RvciAmJiBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gJ0dlbmVyYXRvckZ1bmN0aW9uJztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGlzR2VuZXJhdG9yKG9iaikge1xyXG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2Ygb2JqLm5leHQgPT09IGZuU3RyaW5nICYmIHR5cGVvZiBvYmpbdGhyb3dTdHJpbmddID09PSBmblN0cmluZztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xyXG4gICAgcmV0dXJuIHZhbCAmJiB2YWwuY29uc3RydWN0b3IgPT09IE9iamVjdDtcclxuICB9XHJcblxyXG4gIC8qXHJcbiAgICogU3Bhd25zIGEgZ2VuZXJhdG9yIGZ1bmN0aW9uIHdoaWNoIGFsbG93cyBmb3IgUHJvbWlzZXMsIE9ic2VydmFibGUgc2VxdWVuY2VzLCBBcnJheXMsIE9iamVjdHMsIEdlbmVyYXRvcnMgYW5kIGZ1bmN0aW9ucy5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBUaGUgc3Bhd25pbmcgZnVuY3Rpb24uXHJcbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBhIGZ1bmN0aW9uIHdoaWNoIGhhcyBhIGRvbmUgY29udGludWF0aW9uLlxyXG4gICAqL1xyXG4gIHZhciBvYnNlcnZhYmxlU3Bhd24gPSBSeC5zcGF3biA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgdmFyIGlzR2VuRnVuID0gaXNHZW5lcmF0b3JGdW5jdGlvbihmbik7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkb25lKSB7XHJcbiAgICAgIHZhciBjdHggPSB0aGlzLFxyXG4gICAgICAgIGdlbiA9IGZuO1xyXG5cclxuICAgICAgaWYgKGlzR2VuRnVuKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyksXHJcbiAgICAgICAgICBsZW4gPSBhcmdzLmxlbmd0aCxcclxuICAgICAgICAgIGhhc0NhbGxiYWNrID0gbGVuICYmIHR5cGVvZiBhcmdzW2xlbiAtIDFdID09PSBmblN0cmluZztcclxuXHJcbiAgICAgICAgZG9uZSA9IGhhc0NhbGxiYWNrID8gYXJncy5wb3AoKSA6IGVycm9yO1xyXG4gICAgICAgIGdlbiA9IGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRvbmUgPSBkb25lIHx8IGVycm9yO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBuZXh0KCk7XHJcblxyXG4gICAgICBmdW5jdGlvbiBleGl0KGVyciwgcmVzKSB7XHJcbiAgICAgICAgdGltZW91dFNjaGVkdWxlci5zY2hlZHVsZShkb25lLmJpbmQoY3R4LCBlcnIsIHJlcykpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBuZXh0KGVyciwgcmVzKSB7XHJcbiAgICAgICAgdmFyIHJldDtcclxuXHJcbiAgICAgICAgLy8gbXVsdGlwbGUgYXJnc1xyXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikgcmVzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG5cclxuICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXQgPSBnZW5bdGhyb3dTdHJpbmddKGVycik7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBleGl0KGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFlcnIpIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldCA9IGdlbi5uZXh0KHJlcyk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBleGl0KGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHJldC5kb25lKSAge1xyXG4gICAgICAgICAgcmV0dXJuIGV4aXQobnVsbCwgcmV0LnZhbHVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldC52YWx1ZSA9IHRvVGh1bmsocmV0LnZhbHVlLCBjdHgpO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIHJldC52YWx1ZSA9PT0gZm5TdHJpbmcpIHtcclxuICAgICAgICAgIHZhciBjYWxsZWQgPSBmYWxzZTtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldC52YWx1ZS5jYWxsKGN0eCwgZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICBpZiAoY2FsbGVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgIG5leHQuYXBwbHkoY3R4LCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdGltZW91dFNjaGVkdWxlci5zY2hlZHVsZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGNhbGxlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICBuZXh0LmNhbGwoY3R4LCBlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBOb3Qgc3VwcG9ydGVkXHJcbiAgICAgICAgbmV4dChuZXcgVHlwZUVycm9yKCdSeC5zcGF3biBvbmx5IHN1cHBvcnRzIGEgZnVuY3Rpb24sIFByb21pc2UsIE9ic2VydmFibGUsIE9iamVjdCBvciBBcnJheS4nKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUYWtlcyBhIGZ1bmN0aW9uIHdpdGggYSBjYWxsYmFjayBhbmQgdHVybnMgaXQgaW50byBhIHRodW5rLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IEEgZnVuY3Rpb24gd2l0aCBhIGNhbGxiYWNrIHN1Y2ggYXMgZnMucmVhZEZpbGVcclxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24sIHdoZW4gZXhlY3V0ZWQgd2lsbCBjb250aW51ZSB0aGUgc3RhdGUgbWFjaGluZS5cclxuICAgKi9cclxuICBSeC5kZW5vZGlmeSA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpe1xyXG4gICAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKSxcclxuICAgICAgICByZXN1bHRzLFxyXG4gICAgICAgIGNhbGxlZCxcclxuICAgICAgICBjYWxsYmFjaztcclxuXHJcbiAgICAgIGFyZ3MucHVzaChmdW5jdGlvbigpe1xyXG4gICAgICAgIHJlc3VsdHMgPSBhcmd1bWVudHM7XHJcblxyXG4gICAgICAgIGlmIChjYWxsYmFjayAmJiAhY2FsbGVkKSB7XHJcbiAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgY2IuYXBwbHkodGhpcywgcmVzdWx0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmbil7XHJcbiAgICAgICAgY2FsbGJhY2sgPSBmbjtcclxuXHJcbiAgICAgICAgaWYgKHJlc3VsdHMgJiYgIWNhbGxlZCkge1xyXG4gICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcclxuICAgICAgICAgIGZuLmFwcGx5KHRoaXMsIHJlc3VsdHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIGVycm9yKGVycikge1xyXG4gICAgaWYgKCFlcnIpIHsgcmV0dXJuOyB9XHJcbiAgICB0aW1lb3V0U2NoZWR1bGVyLnNjaGVkdWxlKGZ1bmN0aW9uKCl7XHJcbiAgICAgIHRocm93IGVycjtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW52b2tlcyB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uIGFzeW5jaHJvbm91c2x5IG9uIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVyLCBzdXJmYWNpbmcgdGhlIHJlc3VsdCB0aHJvdWdoIGFuIG9ic2VydmFibGUgc2VxdWVuY2UuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIHZhciByZXMgPSBSeC5PYnNlcnZhYmxlLnN0YXJ0KGZ1bmN0aW9uICgpIHsgY29uc29sZS5sb2coJ2hlbGxvJyk7IH0pO1xyXG4gICAqIHZhciByZXMgPSBSeC5PYnNlcnZhYmxlLnN0YXJ0KGZ1bmN0aW9uICgpIHsgY29uc29sZS5sb2coJ2hlbGxvJyk7IH0sIFJ4LlNjaGVkdWxlci50aW1lb3V0KTtcclxuICAgKiB2YXIgcmVzID0gUnguT2JzZXJ2YWJsZS5zdGFydChmdW5jdGlvbiAoKSB7IHRoaXMubG9nKCdoZWxsbycpOyB9LCBSeC5TY2hlZHVsZXIudGltZW91dCwgY29uc29sZSk7XHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIEZ1bmN0aW9uIHRvIHJ1biBhc3luY2hyb25vdXNseS5cclxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gIFNjaGVkdWxlciB0byBydW4gdGhlIGZ1bmN0aW9uIG9uLiBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byBTY2hlZHVsZXIudGltZW91dC5cclxuICAgKiBAcGFyYW0gW2NvbnRleHRdICBUaGUgY29udGV4dCBmb3IgdGhlIGZ1bmMgcGFyYW1ldGVyIHRvIGJlIGV4ZWN1dGVkLiAgSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gdW5kZWZpbmVkLlxyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGV4cG9zaW5nIHRoZSBmdW5jdGlvbidzIHJlc3VsdCB2YWx1ZSwgb3IgYW4gZXhjZXB0aW9uLlxyXG4gICAqXHJcbiAgICogUmVtYXJrc1xyXG4gICAqICogVGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCBpbW1lZGlhdGVseSwgbm90IGR1cmluZyB0aGUgc3Vic2NyaXB0aW9uIG9mIHRoZSByZXN1bHRpbmcgc2VxdWVuY2UuXHJcbiAgICogKiBNdWx0aXBsZSBzdWJzY3JpcHRpb25zIHRvIHRoZSByZXN1bHRpbmcgc2VxdWVuY2UgY2FuIG9ic2VydmUgdGhlIGZ1bmN0aW9uJ3MgcmVzdWx0LlxyXG4gICAqL1xyXG4gIE9ic2VydmFibGUuc3RhcnQgPSBmdW5jdGlvbiAoZnVuYywgY29udGV4dCwgc2NoZWR1bGVyKSB7XHJcbiAgICByZXR1cm4gb2JzZXJ2YWJsZVRvQXN5bmMoZnVuYywgY29udGV4dCwgc2NoZWR1bGVyKSgpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnRzIHRoZSBmdW5jdGlvbiBpbnRvIGFuIGFzeW5jaHJvbm91cyBmdW5jdGlvbi4gRWFjaCBpbnZvY2F0aW9uIG9mIHRoZSByZXN1bHRpbmcgYXN5bmNocm9ub3VzIGZ1bmN0aW9uIGNhdXNlcyBhbiBpbnZvY2F0aW9uIG9mIHRoZSBvcmlnaW5hbCBzeW5jaHJvbm91cyBmdW5jdGlvbiBvbiB0aGUgc3BlY2lmaWVkIHNjaGVkdWxlci5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogdmFyIHJlcyA9IFJ4Lk9ic2VydmFibGUudG9Bc3luYyhmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4geCArIHk7IH0pKDQsIDMpO1xyXG4gICAqIHZhciByZXMgPSBSeC5PYnNlcnZhYmxlLnRvQXN5bmMoZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIHggKyB5OyB9LCBSeC5TY2hlZHVsZXIudGltZW91dCkoNCwgMyk7XHJcbiAgICogdmFyIHJlcyA9IFJ4Lk9ic2VydmFibGUudG9Bc3luYyhmdW5jdGlvbiAoeCkgeyB0aGlzLmxvZyh4KTsgfSwgUnguU2NoZWR1bGVyLnRpbWVvdXQsIGNvbnNvbGUpKCdoZWxsbycpO1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY3Rpb24gRnVuY3Rpb24gdG8gY29udmVydCB0byBhbiBhc3luY2hyb25vdXMgZnVuY3Rpb24uXHJcbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIFNjaGVkdWxlciB0byBydW4gdGhlIGZ1bmN0aW9uIG9uLiBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byBTY2hlZHVsZXIudGltZW91dC5cclxuICAgKiBAcGFyYW0ge01peGVkfSBbY29udGV4dF0gVGhlIGNvbnRleHQgZm9yIHRoZSBmdW5jIHBhcmFtZXRlciB0byBiZSBleGVjdXRlZC4gIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIHVuZGVmaW5lZC5cclxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEFzeW5jaHJvbm91cyBmdW5jdGlvbi5cclxuICAgKi9cclxuICB2YXIgb2JzZXJ2YWJsZVRvQXN5bmMgPSBPYnNlcnZhYmxlLnRvQXN5bmMgPSBmdW5jdGlvbiAoZnVuYywgY29udGV4dCwgc2NoZWR1bGVyKSB7XHJcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSB0aW1lb3V0U2NoZWR1bGVyKTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxyXG4gICAgICAgIHN1YmplY3QgPSBuZXcgQXN5bmNTdWJqZWN0KCk7XHJcblxyXG4gICAgICBzY2hlZHVsZXIuc2NoZWR1bGUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZXN1bHQ7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgc3ViamVjdC5vbkVycm9yKGUpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdWJqZWN0Lm9uTmV4dChyZXN1bHQpO1xyXG4gICAgICAgIHN1YmplY3Qub25Db21wbGV0ZWQoKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiBzdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDb252ZXJ0cyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGFuIG9ic2VydmFibGUgc2VxdWVuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jdGlvbiBGdW5jdGlvbiB3aXRoIGEgY2FsbGJhY2sgYXMgdGhlIGxhc3QgcGFyYW1ldGVyIHRvIGNvbnZlcnQgdG8gYW4gT2JzZXJ2YWJsZSBzZXF1ZW5jZS5cclxuICAgKiBAcGFyYW0ge01peGVkfSBbY29udGV4dF0gVGhlIGNvbnRleHQgZm9yIHRoZSBmdW5jIHBhcmFtZXRlciB0byBiZSBleGVjdXRlZC4gIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIHVuZGVmaW5lZC5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc2VsZWN0b3JdIEEgc2VsZWN0b3Igd2hpY2ggdGFrZXMgdGhlIGFyZ3VtZW50cyBmcm9tIHRoZSBjYWxsYmFjayB0byBwcm9kdWNlIGEgc2luZ2xlIGl0ZW0gdG8geWllbGQgb24gbmV4dC5cclxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24sIHdoZW4gZXhlY3V0ZWQgd2l0aCB0aGUgcmVxdWlyZWQgcGFyYW1ldGVycyBtaW51cyB0aGUgY2FsbGJhY2ssIHByb2R1Y2VzIGFuIE9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCBhIHNpbmdsZSB2YWx1ZSBvZiB0aGUgYXJndW1lbnRzIHRvIHRoZSBjYWxsYmFjayBhcyBhbiBhcnJheS5cclxuICAgKi9cclxuICBPYnNlcnZhYmxlLmZyb21DYWxsYmFjayA9IGZ1bmN0aW9uIChmdW5jLCBjb250ZXh0LCBzZWxlY3Rvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XHJcblxyXG4gICAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlcihlKSB7XHJcbiAgICAgICAgICB2YXIgcmVzdWx0cyA9IGU7XHJcblxyXG4gICAgICAgICAgaWYgKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgcmVzdWx0cyA9IHNlbGVjdG9yKGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG9ic2VydmVyLm9uTmV4dChyZXN1bHRzKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHRzLmxlbmd0aCA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgb2JzZXJ2ZXIub25OZXh0LmFwcGx5KG9ic2VydmVyLCByZXN1bHRzKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBvYnNlcnZlci5vbk5leHQocmVzdWx0cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYXJncy5wdXNoKGhhbmRsZXIpO1xyXG4gICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgICAgIH0pLnB1Ymxpc2hMYXN0KCkucmVmQ291bnQoKTtcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ29udmVydHMgYSBOb2RlLmpzIGNhbGxiYWNrIHN0eWxlIGZ1bmN0aW9uIHRvIGFuIG9ic2VydmFibGUgc2VxdWVuY2UuICBUaGlzIG11c3QgYmUgaW4gZnVuY3Rpb24gKGVyciwgLi4uKSBmb3JtYXQuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FsbFxyXG4gICAqIEBwYXJhbSB7TWl4ZWR9IFtjb250ZXh0XSBUaGUgY29udGV4dCBmb3IgdGhlIGZ1bmMgcGFyYW1ldGVyIHRvIGJlIGV4ZWN1dGVkLiAgSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gdW5kZWZpbmVkLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzZWxlY3Rvcl0gQSBzZWxlY3RvciB3aGljaCB0YWtlcyB0aGUgYXJndW1lbnRzIGZyb20gdGhlIGNhbGxiYWNrIG1pbnVzIHRoZSBlcnJvciB0byBwcm9kdWNlIGEgc2luZ2xlIGl0ZW0gdG8geWllbGQgb24gbmV4dC5cclxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEFuIGFzeW5jIGZ1bmN0aW9uIHdoaWNoIHdoZW4gYXBwbGllZCwgcmV0dXJucyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggdGhlIGNhbGxiYWNrIGFyZ3VtZW50cyBhcyBhbiBhcnJheS5cclxuICAgKi9cclxuICBPYnNlcnZhYmxlLmZyb21Ob2RlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZnVuYywgY29udGV4dCwgc2VsZWN0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xyXG5cclxuICAgICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZXIoZXJyKSB7XHJcbiAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHZhciByZXN1bHRzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG5cclxuICAgICAgICAgIGlmIChzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIHJlc3VsdHMgPSBzZWxlY3RvcihyZXN1bHRzKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm9uTmV4dChyZXN1bHRzKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHRzLmxlbmd0aCA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgb2JzZXJ2ZXIub25OZXh0LmFwcGx5KG9ic2VydmVyLCByZXN1bHRzKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBvYnNlcnZlci5vbk5leHQocmVzdWx0cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYXJncy5wdXNoKGhhbmRsZXIpO1xyXG4gICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgICAgIH0pLnB1Ymxpc2hMYXN0KCkucmVmQ291bnQoKTtcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gY3JlYXRlTGlzdGVuZXIgKGVsZW1lbnQsIG5hbWUsIGhhbmRsZXIpIHtcclxuICAgIGlmIChlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcclxuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIsIGZhbHNlKTtcclxuICAgICAgcmV0dXJuIGRpc3Bvc2FibGVDcmVhdGUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyLCBmYWxzZSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBsaXN0ZW5lciBmb3VuZCcpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY3JlYXRlRXZlbnRMaXN0ZW5lciAoZWwsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgdmFyIGRpc3Bvc2FibGVzID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKTtcclxuXHJcbiAgICAvLyBBc3VtZSBOb2RlTGlzdFxyXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlbCkgPT09ICdbb2JqZWN0IE5vZGVMaXN0XScpIHtcclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGVsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgZGlzcG9zYWJsZXMuYWRkKGNyZWF0ZUV2ZW50TGlzdGVuZXIoZWwuaXRlbShpKSwgZXZlbnROYW1lLCBoYW5kbGVyKSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoZWwpIHtcclxuICAgICAgZGlzcG9zYWJsZXMuYWRkKGNyZWF0ZUxpc3RlbmVyKGVsLCBldmVudE5hbWUsIGhhbmRsZXIpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGlzcG9zYWJsZXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbiB0byBkZXRlcm1pbmUgd2hldGhlciB0byB1c2UgbmF0aXZlIGV2ZW50cyBvbmx5XHJcbiAgICovXHJcbiAgUnguY29uZmlnLnVzZU5hdGl2ZUV2ZW50cyA9IGZhbHNlO1xyXG5cclxuICAvLyBDaGVjayBmb3IgQW5ndWxhci9qUXVlcnkvWmVwdG8gc3VwcG9ydFxyXG4gIHZhciBqcSA9XHJcbiAgICEhcm9vdC5hbmd1bGFyICYmICEhYW5ndWxhci5lbGVtZW50ID8gYW5ndWxhci5lbGVtZW50IDpcclxuICAgKCEhcm9vdC5qUXVlcnkgPyByb290LmpRdWVyeSA6IChcclxuICAgICAhIXJvb3QuWmVwdG8gPyByb290LlplcHRvIDogbnVsbCkpO1xyXG5cclxuICAvLyBDaGVjayBmb3IgZW1iZXJcclxuICB2YXIgZW1iZXIgPSAhIXJvb3QuRW1iZXIgJiYgdHlwZW9mIHJvb3QuRW1iZXIuYWRkTGlzdGVuZXIgPT09ICdmdW5jdGlvbic7XHJcblxyXG4gIC8vIENoZWNrIGZvciBCYWNrYm9uZS5NYXJpb25ldHRlLiBOb3RlIGlmIHVzaW5nIEFNRCBhZGQgTWFyaW9uZXR0ZSBhcyBhIGRlcGVuZGVuY3kgb2Ygcnhqc1xyXG4gIC8vIGZvciBwcm9wZXIgbG9hZGluZyBvcmRlciFcclxuICB2YXIgbWFyaW9uZXR0ZSA9ICEhcm9vdC5CYWNrYm9uZSAmJiAhIXJvb3QuQmFja2JvbmUuTWFyaW9uZXR0ZTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGJ5IGFkZGluZyBhbiBldmVudCBsaXN0ZW5lciB0byB0aGUgbWF0Y2hpbmcgRE9NRWxlbWVudCBvciBlYWNoIGl0ZW0gaW4gdGhlIE5vZGVMaXN0LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiAgIHZhciBzb3VyY2UgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChlbGVtZW50LCAnbW91c2V1cCcpO1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgVGhlIERPTUVsZW1lbnQgb3IgTm9kZUxpc3QgdG8gYXR0YWNoIGEgbGlzdGVuZXIuXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZSBUaGUgZXZlbnQgbmFtZSB0byBhdHRhY2ggdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3NlbGVjdG9yXSBBIHNlbGVjdG9yIHdoaWNoIHRha2VzIHRoZSBhcmd1bWVudHMgZnJvbSB0aGUgZXZlbnQgaGFuZGxlciB0byBwcm9kdWNlIGEgc2luZ2xlIGl0ZW0gdG8geWllbGQgb24gbmV4dC5cclxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvZiBldmVudHMgZnJvbSB0aGUgc3BlY2lmaWVkIGVsZW1lbnQgYW5kIHRoZSBzcGVjaWZpZWQgZXZlbnQuXHJcbiAgICovXHJcbiAgT2JzZXJ2YWJsZS5mcm9tRXZlbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnROYW1lLCBzZWxlY3Rvcikge1xyXG4gICAgLy8gTm9kZS5qcyBzcGVjaWZpY1xyXG4gICAgaWYgKGVsZW1lbnQuYWRkTGlzdGVuZXIpIHtcclxuICAgICAgcmV0dXJuIGZyb21FdmVudFBhdHRlcm4oXHJcbiAgICAgICAgZnVuY3Rpb24gKGgpIHsgZWxlbWVudC5hZGRMaXN0ZW5lcihldmVudE5hbWUsIGgpOyB9LFxyXG4gICAgICAgIGZ1bmN0aW9uIChoKSB7IGVsZW1lbnQucmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBoKTsgfSxcclxuICAgICAgICBzZWxlY3Rvcik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVXNlIG9ubHkgaWYgbm9uLW5hdGl2ZSBldmVudHMgYXJlIGFsbG93ZWRcclxuICAgIGlmICghUnguY29uZmlnLnVzZU5hdGl2ZUV2ZW50cykge1xyXG4gICAgICBpZiAobWFyaW9uZXR0ZSkge1xyXG4gICAgICAgIHJldHVybiBmcm9tRXZlbnRQYXR0ZXJuKFxyXG4gICAgICAgICAgZnVuY3Rpb24gKGgpIHsgZWxlbWVudC5vbihldmVudE5hbWUsIGgpOyB9LFxyXG4gICAgICAgICAgZnVuY3Rpb24gKGgpIHsgZWxlbWVudC5vZmYoZXZlbnROYW1lLCBoKTsgfSxcclxuICAgICAgICAgIHNlbGVjdG9yKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoZW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gZnJvbUV2ZW50UGF0dGVybihcclxuICAgICAgICAgIGZ1bmN0aW9uIChoKSB7IEVtYmVyLmFkZExpc3RlbmVyKGVsZW1lbnQsIGV2ZW50TmFtZSwgaCk7IH0sXHJcbiAgICAgICAgICBmdW5jdGlvbiAoaCkgeyBFbWJlci5yZW1vdmVMaXN0ZW5lcihlbGVtZW50LCBldmVudE5hbWUsIGgpOyB9LFxyXG4gICAgICAgICAgc2VsZWN0b3IpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChqcSkge1xyXG4gICAgICAgIHZhciAkZWxlbSA9IGpxKGVsZW1lbnQpO1xyXG4gICAgICAgIHJldHVybiBmcm9tRXZlbnRQYXR0ZXJuKFxyXG4gICAgICAgICAgZnVuY3Rpb24gKGgpIHsgJGVsZW0ub24oZXZlbnROYW1lLCBoKTsgfSxcclxuICAgICAgICAgIGZ1bmN0aW9uIChoKSB7ICRlbGVtLm9mZihldmVudE5hbWUsIGgpOyB9LFxyXG4gICAgICAgICAgc2VsZWN0b3IpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgIHJldHVybiBjcmVhdGVFdmVudExpc3RlbmVyKFxyXG4gICAgICAgIGVsZW1lbnQsXHJcbiAgICAgICAgZXZlbnROYW1lLFxyXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZXIgKGUpIHtcclxuICAgICAgICAgIHZhciByZXN1bHRzID0gZTtcclxuXHJcbiAgICAgICAgICBpZiAoc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICByZXN1bHRzID0gc2VsZWN0b3IoYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlcnIpO1xyXG4gICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KHJlc3VsdHMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSkucHVibGlzaCgpLnJlZkNvdW50KCk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGZyb20gYW4gZXZlbnQgZW1pdHRlciB2aWEgYW4gYWRkSGFuZGxlci9yZW1vdmVIYW5kbGVyIHBhaXIuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gYWRkSGFuZGxlciBUaGUgZnVuY3Rpb24gdG8gYWRkIGEgaGFuZGxlciB0byB0aGUgZW1pdHRlci5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVtb3ZlSGFuZGxlcl0gVGhlIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIHJlbW92ZSBhIGhhbmRsZXIgZnJvbSBhbiBlbWl0dGVyLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzZWxlY3Rvcl0gQSBzZWxlY3RvciB3aGljaCB0YWtlcyB0aGUgYXJndW1lbnRzIGZyb20gdGhlIGV2ZW50IGhhbmRsZXIgdG8gcHJvZHVjZSBhIHNpbmdsZSBpdGVtIHRvIHlpZWxkIG9uIG5leHQuXHJcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hpY2ggd3JhcHMgYW4gZXZlbnQgZnJvbSBhbiBldmVudCBlbWl0dGVyXHJcbiAgICovXHJcbiAgdmFyIGZyb21FdmVudFBhdHRlcm4gPSBPYnNlcnZhYmxlLmZyb21FdmVudFBhdHRlcm4gPSBmdW5jdGlvbiAoYWRkSGFuZGxlciwgcmVtb3ZlSGFuZGxlciwgc2VsZWN0b3IpIHtcclxuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgZnVuY3Rpb24gaW5uZXJIYW5kbGVyIChlKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IGU7XHJcbiAgICAgICAgaWYgKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBzZWxlY3Rvcihhcmd1bWVudHMpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBvYnNlcnZlci5vbk5leHQocmVzdWx0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHJldHVyblZhbHVlID0gYWRkSGFuZGxlcihpbm5lckhhbmRsZXIpO1xyXG4gICAgICByZXR1cm4gZGlzcG9zYWJsZUNyZWF0ZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHJlbW92ZUhhbmRsZXIpIHtcclxuICAgICAgICAgIHJlbW92ZUhhbmRsZXIoaW5uZXJIYW5kbGVyLCByZXR1cm5WYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0pLnB1Ymxpc2goKS5yZWZDb3VudCgpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEludm9rZXMgdGhlIGFzeW5jaHJvbm91cyBmdW5jdGlvbiwgc3VyZmFjaW5nIHRoZSByZXN1bHQgdGhyb3VnaCBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmN0aW9uQXN5bmMgQXN5bmNocm9ub3VzIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYSBQcm9taXNlIHRvIHJ1bi5cclxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBleHBvc2luZyB0aGUgZnVuY3Rpb24ncyByZXN1bHQgdmFsdWUsIG9yIGFuIGV4Y2VwdGlvbi5cclxuICAgKi9cclxuICBPYnNlcnZhYmxlLnN0YXJ0QXN5bmMgPSBmdW5jdGlvbiAoZnVuY3Rpb25Bc3luYykge1xyXG4gICAgdmFyIHByb21pc2U7XHJcbiAgICB0cnkge1xyXG4gICAgICBwcm9taXNlID0gZnVuY3Rpb25Bc3luYygpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICByZXR1cm4gb2JzZXJ2YWJsZVRocm93KGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9ic2VydmFibGVGcm9tUHJvbWlzZShwcm9taXNlKTtcclxuICB9XHJcblxyXG4gIHZhciBQYXVzYWJsZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG5cclxuICAgIGluaGVyaXRzKFBhdXNhYmxlT2JzZXJ2YWJsZSwgX3N1cGVyKTtcclxuXHJcbiAgICBmdW5jdGlvbiBzdWJzY3JpYmUob2JzZXJ2ZXIpIHtcclxuICAgICAgdmFyIGNvbm4gPSB0aGlzLnNvdXJjZS5wdWJsaXNoKCksXHJcbiAgICAgICAgc3Vic2NyaXB0aW9uID0gY29ubi5zdWJzY3JpYmUob2JzZXJ2ZXIpLFxyXG4gICAgICAgIGNvbm5lY3Rpb24gPSBkaXNwb3NhYmxlRW1wdHk7XHJcblxyXG4gICAgICB2YXIgcGF1c2FibGUgPSB0aGlzLnBhdXNlci5kaXN0aW5jdFVudGlsQ2hhbmdlZCgpLnN1YnNjcmliZShmdW5jdGlvbiAoYikge1xyXG4gICAgICAgIGlmIChiKSB7XHJcbiAgICAgICAgICBjb25uZWN0aW9uID0gY29ubi5jb25uZWN0KCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNvbm5lY3Rpb24uZGlzcG9zZSgpO1xyXG4gICAgICAgICAgY29ubmVjdGlvbiA9IGRpc3Bvc2FibGVFbXB0eTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKHN1YnNjcmlwdGlvbiwgY29ubmVjdGlvbiwgcGF1c2FibGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIFBhdXNhYmxlT2JzZXJ2YWJsZShzb3VyY2UsIHBhdXNlcikge1xyXG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcclxuICAgICAgdGhpcy5jb250cm9sbGVyID0gbmV3IFN1YmplY3QoKTtcclxuXHJcbiAgICAgIGlmIChwYXVzZXIgJiYgcGF1c2VyLnN1YnNjcmliZSkge1xyXG4gICAgICAgIHRoaXMucGF1c2VyID0gdGhpcy5jb250cm9sbGVyLm1lcmdlKHBhdXNlcik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5wYXVzZXIgPSB0aGlzLmNvbnRyb2xsZXI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHN1YnNjcmliZSk7XHJcbiAgICB9XHJcblxyXG4gICAgUGF1c2FibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5jb250cm9sbGVyLm9uTmV4dChmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFBhdXNhYmxlT2JzZXJ2YWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLmNvbnRyb2xsZXIub25OZXh0KHRydWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gUGF1c2FibGVPYnNlcnZhYmxlO1xyXG5cclxuICB9KE9ic2VydmFibGUpKTtcclxuXHJcbiAgLyoqXHJcbiAgICogUGF1c2VzIHRoZSB1bmRlcmx5aW5nIG9ic2VydmFibGUgc2VxdWVuY2UgYmFzZWQgdXBvbiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aGljaCB5aWVsZHMgdHJ1ZS9mYWxzZS5cclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIHZhciBwYXVzZXIgPSBuZXcgUnguU3ViamVjdCgpO1xyXG4gICAqIHZhciBzb3VyY2UgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMCkucGF1c2FibGUocGF1c2VyKTtcclxuICAgKiBAcGFyYW0ge09ic2VydmFibGV9IHBhdXNlciBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB1c2VkIHRvIHBhdXNlIHRoZSB1bmRlcmx5aW5nIHNlcXVlbmNlLlxyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aGljaCBpcyBwYXVzZWQgYmFzZWQgdXBvbiB0aGUgcGF1c2VyLlxyXG4gICAqL1xyXG4gIG9ic2VydmFibGVQcm90by5wYXVzYWJsZSA9IGZ1bmN0aW9uIChwYXVzZXIpIHtcclxuICAgIHJldHVybiBuZXcgUGF1c2FibGVPYnNlcnZhYmxlKHRoaXMsIHBhdXNlcik7XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gY29tYmluZUxhdGVzdFNvdXJjZShzb3VyY2UsIHN1YmplY3QsIHJlc3VsdFNlbGVjdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgIHZhciBuID0gMixcclxuICAgICAgICBoYXNWYWx1ZSA9IFtmYWxzZSwgZmFsc2VdLFxyXG4gICAgICAgIGhhc1ZhbHVlQWxsID0gZmFsc2UsXHJcbiAgICAgICAgaXNEb25lID0gZmFsc2UsXHJcbiAgICAgICAgdmFsdWVzID0gbmV3IEFycmF5KG4pO1xyXG5cclxuICAgICAgZnVuY3Rpb24gbmV4dCh4LCBpKSB7XHJcbiAgICAgICAgdmFsdWVzW2ldID0geFxyXG4gICAgICAgIHZhciByZXM7XHJcbiAgICAgICAgaGFzVmFsdWVbaV0gPSB0cnVlO1xyXG4gICAgICAgIGlmIChoYXNWYWx1ZUFsbCB8fCAoaGFzVmFsdWVBbGwgPSBoYXNWYWx1ZS5ldmVyeShpZGVudGl0eSkpKSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXMgPSByZXN1bHRTZWxlY3Rvci5hcHBseShudWxsLCB2YWx1ZXMpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZXgpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihleCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIG9ic2VydmVyLm9uTmV4dChyZXMpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNEb25lKSB7XHJcbiAgICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKFxyXG4gICAgICAgIHNvdXJjZS5zdWJzY3JpYmUoXHJcbiAgICAgICAgICBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICBuZXh0KHgsIDApO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IuYmluZChvYnNlcnZlciksXHJcbiAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlzRG9uZSA9IHRydWU7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgICAgICB9KSxcclxuICAgICAgICBzdWJqZWN0LnN1YnNjcmliZShcclxuICAgICAgICAgIGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIG5leHQoeCwgMSk7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgb2JzZXJ2ZXIub25FcnJvci5iaW5kKG9ic2VydmVyKSlcclxuICAgICAgICApO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICB2YXIgUGF1c2FibGVCdWZmZXJlZE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG5cclxuICAgIGluaGVyaXRzKFBhdXNhYmxlQnVmZmVyZWRPYnNlcnZhYmxlLCBfc3VwZXIpO1xyXG5cclxuICAgIGZ1bmN0aW9uIHN1YnNjcmliZShvYnNlcnZlcikge1xyXG4gICAgICB2YXIgcSA9IFtdLCBwcmV2aW91c1Nob3VsZEZpcmU7XHJcblxyXG4gICAgICB2YXIgc3Vic2NyaXB0aW9uID1cclxuICAgICAgICBjb21iaW5lTGF0ZXN0U291cmNlKFxyXG4gICAgICAgICAgdGhpcy5zb3VyY2UsXHJcbiAgICAgICAgICB0aGlzLnBhdXNlci5kaXN0aW5jdFVudGlsQ2hhbmdlZCgpLnN0YXJ0V2l0aChmYWxzZSksXHJcbiAgICAgICAgICBmdW5jdGlvbiAoZGF0YSwgc2hvdWxkRmlyZSkge1xyXG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiBkYXRhLCBzaG91bGRGaXJlOiBzaG91bGRGaXJlIH07XHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgLnN1YnNjcmliZShcclxuICAgICAgICAgICAgZnVuY3Rpb24gKHJlc3VsdHMpIHtcclxuICAgICAgICAgICAgICBpZiAocHJldmlvdXNTaG91bGRGaXJlICE9PSB1bmRlZmluZWQgJiYgcmVzdWx0cy5zaG91bGRGaXJlICE9IHByZXZpb3VzU2hvdWxkRmlyZSkge1xyXG4gICAgICAgICAgICAgICAgcHJldmlvdXNTaG91bGRGaXJlID0gcmVzdWx0cy5zaG91bGRGaXJlO1xyXG4gICAgICAgICAgICAgICAgLy8gY2hhbmdlIGluIHNob3VsZEZpcmVcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzLnNob3VsZEZpcmUpIHtcclxuICAgICAgICAgICAgICAgICAgd2hpbGUgKHEubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm9uTmV4dChxLnNoaWZ0KCkpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHByZXZpb3VzU2hvdWxkRmlyZSA9IHJlc3VsdHMuc2hvdWxkRmlyZTtcclxuICAgICAgICAgICAgICAgIC8vIG5ldyBkYXRhXHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0cy5zaG91bGRGaXJlKSB7XHJcbiAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm9uTmV4dChyZXN1bHRzLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgcS5wdXNoKHJlc3VsdHMuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgLy8gRW1wdHkgYnVmZmVyIGJlZm9yZSBzZW5kaW5nIGVycm9yXHJcbiAgICAgICAgICAgICAgd2hpbGUgKHEubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KHEuc2hpZnQoKSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgIC8vIEVtcHR5IGJ1ZmZlciBiZWZvcmUgc2VuZGluZyBjb21wbGV0aW9uXHJcbiAgICAgICAgICAgICAgd2hpbGUgKHEubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KHEuc2hpZnQoKSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICk7XHJcbiAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gUGF1c2FibGVCdWZmZXJlZE9ic2VydmFibGUoc291cmNlLCBwYXVzZXIpIHtcclxuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICAgIHRoaXMuY29udHJvbGxlciA9IG5ldyBTdWJqZWN0KCk7XHJcblxyXG4gICAgICBpZiAocGF1c2VyICYmIHBhdXNlci5zdWJzY3JpYmUpIHtcclxuICAgICAgICB0aGlzLnBhdXNlciA9IHRoaXMuY29udHJvbGxlci5tZXJnZShwYXVzZXIpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMucGF1c2VyID0gdGhpcy5jb250cm9sbGVyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzdWJzY3JpYmUpO1xyXG4gICAgfVxyXG5cclxuICAgIFBhdXNhYmxlQnVmZmVyZWRPYnNlcnZhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5jb250cm9sbGVyLm9uTmV4dChmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFBhdXNhYmxlQnVmZmVyZWRPYnNlcnZhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMuY29udHJvbGxlci5vbk5leHQodHJ1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBQYXVzYWJsZUJ1ZmZlcmVkT2JzZXJ2YWJsZTtcclxuXHJcbiAgfShPYnNlcnZhYmxlKSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhdXNlcyB0aGUgdW5kZXJseWluZyBvYnNlcnZhYmxlIHNlcXVlbmNlIGJhc2VkIHVwb24gdGhlIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hpY2ggeWllbGRzIHRydWUvZmFsc2UsXHJcbiAgICogYW5kIHlpZWxkcyB0aGUgdmFsdWVzIHRoYXQgd2VyZSBidWZmZXJlZCB3aGlsZSBwYXVzZWQuXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiB2YXIgcGF1c2VyID0gbmV3IFJ4LlN1YmplY3QoKTtcclxuICAgKiB2YXIgc291cmNlID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDApLnBhdXNhYmxlQnVmZmVyZWQocGF1c2VyKTtcclxuICAgKiBAcGFyYW0ge09ic2VydmFibGV9IHBhdXNlciBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB1c2VkIHRvIHBhdXNlIHRoZSB1bmRlcmx5aW5nIHNlcXVlbmNlLlxyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aGljaCBpcyBwYXVzZWQgYmFzZWQgdXBvbiB0aGUgcGF1c2VyLlxyXG4gICAqL1xyXG4gIG9ic2VydmFibGVQcm90by5wYXVzYWJsZUJ1ZmZlcmVkID0gZnVuY3Rpb24gKHN1YmplY3QpIHtcclxuICAgIHJldHVybiBuZXcgUGF1c2FibGVCdWZmZXJlZE9ic2VydmFibGUodGhpcywgc3ViamVjdCk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgYSBjb250cm9sbGVyIHRvIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggdGhlIGFiaWxpdHkgdG8gcXVldWUuXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiB2YXIgc291cmNlID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDApLmNvbnRyb2xsZWQoKTtcclxuICAgKiBzb3VyY2UucmVxdWVzdCgzKTsgLy8gUmVhZHMgMyB2YWx1ZXNcclxuICAgKiBAcGFyYW0ge09ic2VydmFibGV9IHBhdXNlciBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB1c2VkIHRvIHBhdXNlIHRoZSB1bmRlcmx5aW5nIHNlcXVlbmNlLlxyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aGljaCBpcyBwYXVzZWQgYmFzZWQgdXBvbiB0aGUgcGF1c2VyLlxyXG4gICAqL1xyXG4gIG9ic2VydmFibGVQcm90by5jb250cm9sbGVkID0gZnVuY3Rpb24gKGVuYWJsZVF1ZXVlKSB7XHJcbiAgICBpZiAoZW5hYmxlUXVldWUgPT0gbnVsbCkgeyAgZW5hYmxlUXVldWUgPSB0cnVlOyB9XHJcbiAgICByZXR1cm4gbmV3IENvbnRyb2xsZWRPYnNlcnZhYmxlKHRoaXMsIGVuYWJsZVF1ZXVlKTtcclxuICB9O1xyXG5cclxuICB2YXIgQ29udHJvbGxlZE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG5cclxuICAgIGluaGVyaXRzKENvbnRyb2xsZWRPYnNlcnZhYmxlLCBfc3VwZXIpO1xyXG5cclxuICAgIGZ1bmN0aW9uIHN1YnNjcmliZSAob2JzZXJ2ZXIpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShvYnNlcnZlcik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gQ29udHJvbGxlZE9ic2VydmFibGUgKHNvdXJjZSwgZW5hYmxlUXVldWUpIHtcclxuICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3Vic2NyaWJlKTtcclxuICAgICAgdGhpcy5zdWJqZWN0ID0gbmV3IENvbnRyb2xsZWRTdWJqZWN0KGVuYWJsZVF1ZXVlKTtcclxuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2UubXVsdGljYXN0KHRoaXMuc3ViamVjdCkucmVmQ291bnQoKTtcclxuICAgIH1cclxuXHJcbiAgICBDb250cm9sbGVkT2JzZXJ2YWJsZS5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIChudW1iZXJPZkl0ZW1zKSB7XHJcbiAgICAgIGlmIChudW1iZXJPZkl0ZW1zID09IG51bGwpIHsgbnVtYmVyT2ZJdGVtcyA9IC0xOyB9XHJcbiAgICAgIHJldHVybiB0aGlzLnN1YmplY3QucmVxdWVzdChudW1iZXJPZkl0ZW1zKTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIENvbnRyb2xsZWRPYnNlcnZhYmxlO1xyXG5cclxuICB9KE9ic2VydmFibGUpKTtcclxuXHJcbiAgICB2YXIgQ29udHJvbGxlZFN1YmplY3QgPSBSeC5Db250cm9sbGVkU3ViamVjdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHN1YnNjcmliZSAob2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ViamVjdC5zdWJzY3JpYmUob2JzZXJ2ZXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW5oZXJpdHMoQ29udHJvbGxlZFN1YmplY3QsIF9zdXBlcik7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIENvbnRyb2xsZWRTdWJqZWN0KGVuYWJsZVF1ZXVlKSB7XHJcbiAgICAgICAgICAgIGlmIChlbmFibGVRdWV1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBlbmFibGVRdWV1ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHN1YnNjcmliZSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3ViamVjdCA9IG5ldyBTdWJqZWN0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlUXVldWUgPSBlbmFibGVRdWV1ZTtcclxuICAgICAgICAgICAgdGhpcy5xdWV1ZSA9IGVuYWJsZVF1ZXVlID8gW10gOiBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RlZENvdW50ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0ZWREaXNwb3NhYmxlID0gZGlzcG9zYWJsZUVtcHR5O1xyXG4gICAgICAgICAgICB0aGlzLmVycm9yID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5oYXNGYWlsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5jb250cm9sbGVkRGlzcG9zYWJsZSA9IGRpc3Bvc2FibGVFbXB0eTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGFkZFByb3BlcnRpZXMoQ29udHJvbGxlZFN1YmplY3QucHJvdG90eXBlLCBPYnNlcnZlciwge1xyXG4gICAgICAgICAgICBvbkNvbXBsZXRlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY2hlY2tEaXNwb3NlZC5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5lbmFibGVRdWV1ZSB8fCB0aGlzLnF1ZXVlLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3ViamVjdC5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvbkVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGNoZWNrRGlzcG9zZWQuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGFzRmFpbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZW5hYmxlUXVldWUgfHwgdGhpcy5xdWV1ZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YmplY3Qub25FcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uTmV4dDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBjaGVja0Rpc3Bvc2VkLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGFzUmVxdWVzdGVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVxdWVzdGVkQ291bnQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmFibGVRdWV1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2godmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVxdWVzdGVkQ291bnQgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlcXVlc3RlZENvdW50LS0gPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZUN1cnJlbnRSZXF1ZXN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzUmVxdWVzdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzUmVxdWVzdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJqZWN0Lm9uTmV4dCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIF9wcm9jZXNzUmVxdWVzdDogZnVuY3Rpb24gKG51bWJlck9mSXRlbXMpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVuYWJsZVF1ZXVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygncXVldWUgbGVuZ3RoJywgdGhpcy5xdWV1ZS5sZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5xdWV1ZS5sZW5ndGggPj0gbnVtYmVyT2ZJdGVtcyAmJiBudW1iZXJPZkl0ZW1zID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdudW1iZXIgb2YgaXRlbXMnLCBudW1iZXJPZkl0ZW1zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJqZWN0Lm9uTmV4dCh0aGlzLnF1ZXVlLnNoaWZ0KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBudW1iZXJPZkl0ZW1zLS07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbnVtYmVyT2ZJdGVtczogbnVtYmVyT2ZJdGVtcywgcmV0dXJuVmFsdWU6IHRydWUgfTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBudW1iZXJPZkl0ZW1zOiBudW1iZXJPZkl0ZW1zLCByZXR1cm5WYWx1ZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzRmFpbGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJqZWN0Lm9uRXJyb3IodGhpcy5lcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250cm9sbGVkRGlzcG9zYWJsZS5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250cm9sbGVkRGlzcG9zYWJsZSA9IGRpc3Bvc2FibGVFbXB0eTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5oYXNDb21wbGV0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YmplY3Qub25Db21wbGV0ZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xsZWREaXNwb3NhYmxlLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xsZWREaXNwb3NhYmxlID0gZGlzcG9zYWJsZUVtcHR5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB7IG51bWJlck9mSXRlbXM6IG51bWJlck9mSXRlbXMsIHJldHVyblZhbHVlOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZXF1ZXN0OiBmdW5jdGlvbiAobnVtYmVyKSB7XHJcbiAgICAgICAgICAgICAgICBjaGVja0Rpc3Bvc2VkLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2VDdXJyZW50UmVxdWVzdCgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgIHIgPSB0aGlzLl9wcm9jZXNzUmVxdWVzdChudW1iZXIpO1xyXG5cclxuICAgICAgICAgICAgICAgIG51bWJlciA9IHIubnVtYmVyT2ZJdGVtcztcclxuICAgICAgICAgICAgICAgIGlmICghci5yZXR1cm5WYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdGVkQ291bnQgPSBudW1iZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0ZWREaXNwb3NhYmxlID0gZGlzcG9zYWJsZUNyZWF0ZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVxdWVzdGVkQ291bnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0ZWREaXNwb3NhYmxlXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRpc3Bvc2VDdXJyZW50UmVxdWVzdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0ZWREaXNwb3NhYmxlLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdGVkRGlzcG9zYWJsZSA9IGRpc3Bvc2FibGVFbXB0eTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ViamVjdC5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RlZERpc3Bvc2FibGUuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBDb250cm9sbGVkU3ViamVjdDtcclxuICAgIH0oT2JzZXJ2YWJsZSkpO1xyXG5cclxuICAvKipcclxuICAgKiBNdWx0aWNhc3RzIHRoZSBzb3VyY2Ugc2VxdWVuY2Ugbm90aWZpY2F0aW9ucyB0aHJvdWdoIGFuIGluc3RhbnRpYXRlZCBzdWJqZWN0IGludG8gYWxsIHVzZXMgb2YgdGhlIHNlcXVlbmNlIHdpdGhpbiBhIHNlbGVjdG9yIGZ1bmN0aW9uLiBFYWNoXHJcbiAgICogc3Vic2NyaXB0aW9uIHRvIHRoZSByZXN1bHRpbmcgc2VxdWVuY2UgY2F1c2VzIGEgc2VwYXJhdGUgbXVsdGljYXN0IGludm9jYXRpb24sIGV4cG9zaW5nIHRoZSBzZXF1ZW5jZSByZXN1bHRpbmcgZnJvbSB0aGUgc2VsZWN0b3IgZnVuY3Rpb24nc1xyXG4gICAqIGludm9jYXRpb24uIEZvciBzcGVjaWFsaXphdGlvbnMgd2l0aCBmaXhlZCBzdWJqZWN0IHR5cGVzLCBzZWUgUHVibGlzaCwgUHVibGlzaExhc3QsIGFuZCBSZXBsYXkuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIDEgLSByZXMgPSBzb3VyY2UubXVsdGljYXN0KG9ic2VydmFibGUpO1xyXG4gICAqIDIgLSByZXMgPSBzb3VyY2UubXVsdGljYXN0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBTdWJqZWN0KCk7IH0sIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9KTtcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb258U3ViamVjdH0gc3ViamVjdE9yU3ViamVjdFNlbGVjdG9yXHJcbiAgICogRmFjdG9yeSBmdW5jdGlvbiB0byBjcmVhdGUgYW4gaW50ZXJtZWRpYXRlIHN1YmplY3QgdGhyb3VnaCB3aGljaCB0aGUgc291cmNlIHNlcXVlbmNlJ3MgZWxlbWVudHMgd2lsbCBiZSBtdWx0aWNhc3QgdG8gdGhlIHNlbGVjdG9yIGZ1bmN0aW9uLlxyXG4gICAqIE9yOlxyXG4gICAqIFN1YmplY3QgdG8gcHVzaCBzb3VyY2UgZWxlbWVudHMgaW50by5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzZWxlY3Rvcl0gT3B0aW9uYWwgc2VsZWN0b3IgZnVuY3Rpb24gd2hpY2ggY2FuIHVzZSB0aGUgbXVsdGljYXN0ZWQgc291cmNlIHNlcXVlbmNlIHN1YmplY3QgdG8gdGhlIHBvbGljaWVzIGVuZm9yY2VkIGJ5IHRoZSBjcmVhdGVkIHN1YmplY3QuIFNwZWNpZmllZCBvbmx5IGlmIDxwYXJhbXJlZiBuYW1lPVwic3ViamVjdE9yU3ViamVjdFNlbGVjdG9yXCIgaXMgYSBmYWN0b3J5IGZ1bmN0aW9uLlxyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIGVsZW1lbnRzIG9mIGEgc2VxdWVuY2UgcHJvZHVjZWQgYnkgbXVsdGljYXN0aW5nIHRoZSBzb3VyY2Ugc2VxdWVuY2Ugd2l0aGluIGEgc2VsZWN0b3IgZnVuY3Rpb24uXHJcbiAgICovXHJcbiAgb2JzZXJ2YWJsZVByb3RvLm11bHRpY2FzdCA9IGZ1bmN0aW9uIChzdWJqZWN0T3JTdWJqZWN0U2VsZWN0b3IsIHNlbGVjdG9yKSB7XHJcbiAgICB2YXIgc291cmNlID0gdGhpcztcclxuICAgIHJldHVybiB0eXBlb2Ygc3ViamVjdE9yU3ViamVjdFNlbGVjdG9yID09PSAnZnVuY3Rpb24nID9cclxuICAgICAgbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgICAgdmFyIGNvbm5lY3RhYmxlID0gc291cmNlLm11bHRpY2FzdChzdWJqZWN0T3JTdWJqZWN0U2VsZWN0b3IoKSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKHNlbGVjdG9yKGNvbm5lY3RhYmxlKS5zdWJzY3JpYmUob2JzZXJ2ZXIpLCBjb25uZWN0YWJsZS5jb25uZWN0KCkpO1xyXG4gICAgICB9KSA6XHJcbiAgICAgIG5ldyBDb25uZWN0YWJsZU9ic2VydmFibGUoc291cmNlLCBzdWJqZWN0T3JTdWJqZWN0U2VsZWN0b3IpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGlzIHRoZSByZXN1bHQgb2YgaW52b2tpbmcgdGhlIHNlbGVjdG9yIG9uIGEgY29ubmVjdGFibGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHNoYXJlcyBhIHNpbmdsZSBzdWJzY3JpcHRpb24gdG8gdGhlIHVuZGVybHlpbmcgc2VxdWVuY2UuXHJcbiAgICogVGhpcyBvcGVyYXRvciBpcyBhIHNwZWNpYWxpemF0aW9uIG9mIE11bHRpY2FzdCB1c2luZyBhIHJlZ3VsYXIgU3ViamVjdC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogdmFyIHJlc3JlcyA9IHNvdXJjZS5wdWJsaXNoKCk7XHJcbiAgICogdmFyIHJlcyA9IHNvdXJjZS5wdWJsaXNoKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9KTtcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzZWxlY3Rvcl0gU2VsZWN0b3IgZnVuY3Rpb24gd2hpY2ggY2FuIHVzZSB0aGUgbXVsdGljYXN0ZWQgc291cmNlIHNlcXVlbmNlIGFzIG1hbnkgdGltZXMgYXMgbmVlZGVkLCB3aXRob3V0IGNhdXNpbmcgbXVsdGlwbGUgc3Vic2NyaXB0aW9ucyB0byB0aGUgc291cmNlIHNlcXVlbmNlLiBTdWJzY3JpYmVycyB0byB0aGUgZ2l2ZW4gc291cmNlIHdpbGwgcmVjZWl2ZSBhbGwgbm90aWZpY2F0aW9ucyBvZiB0aGUgc291cmNlIGZyb20gdGhlIHRpbWUgb2YgdGhlIHN1YnNjcmlwdGlvbiBvbi5cclxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGNvbnRhaW5zIHRoZSBlbGVtZW50cyBvZiBhIHNlcXVlbmNlIHByb2R1Y2VkIGJ5IG11bHRpY2FzdGluZyB0aGUgc291cmNlIHNlcXVlbmNlIHdpdGhpbiBhIHNlbGVjdG9yIGZ1bmN0aW9uLlxyXG4gICAqL1xyXG4gIG9ic2VydmFibGVQcm90by5wdWJsaXNoID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XHJcbiAgICByZXR1cm4gc2VsZWN0b3IgJiYgaXNGdW5jdGlvbihzZWxlY3RvcikgP1xyXG4gICAgICB0aGlzLm11bHRpY2FzdChmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgU3ViamVjdCgpOyB9LCBzZWxlY3RvcikgOlxyXG4gICAgICB0aGlzLm11bHRpY2FzdChuZXcgU3ViamVjdCgpKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBzaGFyZXMgYSBzaW5nbGUgc3Vic2NyaXB0aW9uIHRvIHRoZSB1bmRlcmx5aW5nIHNlcXVlbmNlLlxyXG4gICAqIFRoaXMgb3BlcmF0b3IgaXMgYSBzcGVjaWFsaXphdGlvbiBvZiBwdWJsaXNoIHdoaWNoIGNyZWF0ZXMgYSBzdWJzY3JpcHRpb24gd2hlbiB0aGUgbnVtYmVyIG9mIG9ic2VydmVycyBnb2VzIGZyb20gemVybyB0byBvbmUsIHRoZW4gc2hhcmVzIHRoYXQgc3Vic2NyaXB0aW9uIHdpdGggYWxsIHN1YnNlcXVlbnQgb2JzZXJ2ZXJzIHVudGlsIHRoZSBudW1iZXIgb2Ygb2JzZXJ2ZXJzIHJldHVybnMgdG8gemVybywgYXQgd2hpY2ggcG9pbnQgdGhlIHN1YnNjcmlwdGlvbiBpcyBkaXNwb3NlZC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogdmFyIHJlcyA9IHNvdXJjZS5zaGFyZSgpO1xyXG4gICAqXHJcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyB0aGUgZWxlbWVudHMgb2YgYSBzZXF1ZW5jZSBwcm9kdWNlZCBieSBtdWx0aWNhc3RpbmcgdGhlIHNvdXJjZSBzZXF1ZW5jZS5cclxuICAgKi9cclxuICBvYnNlcnZhYmxlUHJvdG8uc2hhcmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoKCkucmVmQ291bnQoKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBpcyB0aGUgcmVzdWx0IG9mIGludm9raW5nIHRoZSBzZWxlY3RvciBvbiBhIGNvbm5lY3RhYmxlIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBzaGFyZXMgYSBzaW5nbGUgc3Vic2NyaXB0aW9uIHRvIHRoZSB1bmRlcmx5aW5nIHNlcXVlbmNlIGNvbnRhaW5pbmcgb25seSB0aGUgbGFzdCBub3RpZmljYXRpb24uXHJcbiAgICogVGhpcyBvcGVyYXRvciBpcyBhIHNwZWNpYWxpemF0aW9uIG9mIE11bHRpY2FzdCB1c2luZyBhIEFzeW5jU3ViamVjdC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogdmFyIHJlcyA9IHNvdXJjZS5wdWJsaXNoTGFzdCgpO1xyXG4gICAqIHZhciByZXMgPSBzb3VyY2UucHVibGlzaExhc3QoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0pO1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHNlbGVjdG9yIFtPcHRpb25hbF0gU2VsZWN0b3IgZnVuY3Rpb24gd2hpY2ggY2FuIHVzZSB0aGUgbXVsdGljYXN0ZWQgc291cmNlIHNlcXVlbmNlIGFzIG1hbnkgdGltZXMgYXMgbmVlZGVkLCB3aXRob3V0IGNhdXNpbmcgbXVsdGlwbGUgc3Vic2NyaXB0aW9ucyB0byB0aGUgc291cmNlIHNlcXVlbmNlLiBTdWJzY3JpYmVycyB0byB0aGUgZ2l2ZW4gc291cmNlIHdpbGwgb25seSByZWNlaXZlIHRoZSBsYXN0IG5vdGlmaWNhdGlvbiBvZiB0aGUgc291cmNlLlxyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIGVsZW1lbnRzIG9mIGEgc2VxdWVuY2UgcHJvZHVjZWQgYnkgbXVsdGljYXN0aW5nIHRoZSBzb3VyY2Ugc2VxdWVuY2Ugd2l0aGluIGEgc2VsZWN0b3IgZnVuY3Rpb24uXHJcbiAgICovXHJcbiAgb2JzZXJ2YWJsZVByb3RvLnB1Ymxpc2hMYXN0ID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XHJcbiAgICByZXR1cm4gc2VsZWN0b3IgJiYgaXNGdW5jdGlvbihzZWxlY3RvcikgP1xyXG4gICAgICB0aGlzLm11bHRpY2FzdChmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgQXN5bmNTdWJqZWN0KCk7IH0sIHNlbGVjdG9yKSA6XHJcbiAgICAgIHRoaXMubXVsdGljYXN0KG5ldyBBc3luY1N1YmplY3QoKSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgaXMgdGhlIHJlc3VsdCBvZiBpbnZva2luZyB0aGUgc2VsZWN0b3Igb24gYSBjb25uZWN0YWJsZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgc2hhcmVzIGEgc2luZ2xlIHN1YnNjcmlwdGlvbiB0byB0aGUgdW5kZXJseWluZyBzZXF1ZW5jZSBhbmQgc3RhcnRzIHdpdGggaW5pdGlhbFZhbHVlLlxyXG4gICAqIFRoaXMgb3BlcmF0b3IgaXMgYSBzcGVjaWFsaXphdGlvbiBvZiBNdWx0aWNhc3QgdXNpbmcgYSBCZWhhdmlvclN1YmplY3QuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIHZhciByZXMgPSBzb3VyY2UucHVibGlzaFZhbHVlKDQyKTtcclxuICAgKiB2YXIgcmVzID0gc291cmNlLnB1Ymxpc2hWYWx1ZShmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5zZWxlY3QoZnVuY3Rpb24gKHkpIHsgcmV0dXJuIHkgKiB5OyB9KSB9LCA0Mik7XHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc2VsZWN0b3JdIE9wdGlvbmFsIHNlbGVjdG9yIGZ1bmN0aW9uIHdoaWNoIGNhbiB1c2UgdGhlIG11bHRpY2FzdGVkIHNvdXJjZSBzZXF1ZW5jZSBhcyBtYW55IHRpbWVzIGFzIG5lZWRlZCwgd2l0aG91dCBjYXVzaW5nIG11bHRpcGxlIHN1YnNjcmlwdGlvbnMgdG8gdGhlIHNvdXJjZSBzZXF1ZW5jZS4gU3Vic2NyaWJlcnMgdG8gdGhlIGdpdmVuIHNvdXJjZSB3aWxsIHJlY2VpdmUgaW1tZWRpYXRlbHkgcmVjZWl2ZSB0aGUgaW5pdGlhbCB2YWx1ZSwgZm9sbG93ZWQgYnkgYWxsIG5vdGlmaWNhdGlvbnMgb2YgdGhlIHNvdXJjZSBmcm9tIHRoZSB0aW1lIG9mIHRoZSBzdWJzY3JpcHRpb24gb24uXHJcbiAgICogQHBhcmFtIHtNaXhlZH0gaW5pdGlhbFZhbHVlIEluaXRpYWwgdmFsdWUgcmVjZWl2ZWQgYnkgb2JzZXJ2ZXJzIHVwb24gc3Vic2NyaXB0aW9uLlxyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIGVsZW1lbnRzIG9mIGEgc2VxdWVuY2UgcHJvZHVjZWQgYnkgbXVsdGljYXN0aW5nIHRoZSBzb3VyY2Ugc2VxdWVuY2Ugd2l0aGluIGEgc2VsZWN0b3IgZnVuY3Rpb24uXHJcbiAgICovXHJcbiAgb2JzZXJ2YWJsZVByb3RvLnB1Ymxpc2hWYWx1ZSA9IGZ1bmN0aW9uIChpbml0aWFsVmFsdWVPclNlbGVjdG9yLCBpbml0aWFsVmFsdWUpIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAyID9cclxuICAgICAgdGhpcy5tdWx0aWNhc3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmVoYXZpb3JTdWJqZWN0KGluaXRpYWxWYWx1ZSk7XHJcbiAgICAgIH0sIGluaXRpYWxWYWx1ZU9yU2VsZWN0b3IpIDpcclxuICAgICAgdGhpcy5tdWx0aWNhc3QobmV3IEJlaGF2aW9yU3ViamVjdChpbml0aWFsVmFsdWVPclNlbGVjdG9yKSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgc2hhcmVzIGEgc2luZ2xlIHN1YnNjcmlwdGlvbiB0byB0aGUgdW5kZXJseWluZyBzZXF1ZW5jZSBhbmQgc3RhcnRzIHdpdGggYW4gaW5pdGlhbFZhbHVlLlxyXG4gICAqIFRoaXMgb3BlcmF0b3IgaXMgYSBzcGVjaWFsaXphdGlvbiBvZiBwdWJsaXNoVmFsdWUgd2hpY2ggY3JlYXRlcyBhIHN1YnNjcmlwdGlvbiB3aGVuIHRoZSBudW1iZXIgb2Ygb2JzZXJ2ZXJzIGdvZXMgZnJvbSB6ZXJvIHRvIG9uZSwgdGhlbiBzaGFyZXMgdGhhdCBzdWJzY3JpcHRpb24gd2l0aCBhbGwgc3Vic2VxdWVudCBvYnNlcnZlcnMgdW50aWwgdGhlIG51bWJlciBvZiBvYnNlcnZlcnMgcmV0dXJucyB0byB6ZXJvLCBhdCB3aGljaCBwb2ludCB0aGUgc3Vic2NyaXB0aW9uIGlzIGRpc3Bvc2VkLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiB2YXIgcmVzID0gc291cmNlLnNoYXJlVmFsdWUoNDIpO1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtNaXhlZH0gaW5pdGlhbFZhbHVlIEluaXRpYWwgdmFsdWUgcmVjZWl2ZWQgYnkgb2JzZXJ2ZXJzIHVwb24gc3Vic2NyaXB0aW9uLlxyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIGVsZW1lbnRzIG9mIGEgc2VxdWVuY2UgcHJvZHVjZWQgYnkgbXVsdGljYXN0aW5nIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXHJcbiAgICovXHJcbiAgb2JzZXJ2YWJsZVByb3RvLnNoYXJlVmFsdWUgPSBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoVmFsdWUoaW5pdGlhbFZhbHVlKS5yZWZDb3VudCgpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGlzIHRoZSByZXN1bHQgb2YgaW52b2tpbmcgdGhlIHNlbGVjdG9yIG9uIGEgY29ubmVjdGFibGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHNoYXJlcyBhIHNpbmdsZSBzdWJzY3JpcHRpb24gdG8gdGhlIHVuZGVybHlpbmcgc2VxdWVuY2UgcmVwbGF5aW5nIG5vdGlmaWNhdGlvbnMgc3ViamVjdCB0byBhIG1heGltdW0gdGltZSBsZW5ndGggZm9yIHRoZSByZXBsYXkgYnVmZmVyLlxyXG4gICAqIFRoaXMgb3BlcmF0b3IgaXMgYSBzcGVjaWFsaXphdGlvbiBvZiBNdWx0aWNhc3QgdXNpbmcgYSBSZXBsYXlTdWJqZWN0LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiB2YXIgcmVzID0gc291cmNlLnJlcGxheShudWxsLCAzKTtcclxuICAgKiB2YXIgcmVzID0gc291cmNlLnJlcGxheShudWxsLCAzLCA1MDApO1xyXG4gICAqIHZhciByZXMgPSBzb3VyY2UucmVwbGF5KG51bGwsIDMsIDUwMCwgc2NoZWR1bGVyKTtcclxuICAgKiB2YXIgcmVzID0gc291cmNlLnJlcGxheShmdW5jdGlvbiAoeCkgeyByZXR1cm4geC50YWtlKDYpLnJlcGVhdCgpOyB9LCAzLCA1MDAsIHNjaGVkdWxlcik7XHJcbiAgICpcclxuICAgKiBAcGFyYW0gc2VsZWN0b3IgW09wdGlvbmFsXSBTZWxlY3RvciBmdW5jdGlvbiB3aGljaCBjYW4gdXNlIHRoZSBtdWx0aWNhc3RlZCBzb3VyY2Ugc2VxdWVuY2UgYXMgbWFueSB0aW1lcyBhcyBuZWVkZWQsIHdpdGhvdXQgY2F1c2luZyBtdWx0aXBsZSBzdWJzY3JpcHRpb25zIHRvIHRoZSBzb3VyY2Ugc2VxdWVuY2UuIFN1YnNjcmliZXJzIHRvIHRoZSBnaXZlbiBzb3VyY2Ugd2lsbCByZWNlaXZlIGFsbCB0aGUgbm90aWZpY2F0aW9ucyBvZiB0aGUgc291cmNlIHN1YmplY3QgdG8gdGhlIHNwZWNpZmllZCByZXBsYXkgYnVmZmVyIHRyaW1taW5nIHBvbGljeS5cclxuICAgKiBAcGFyYW0gYnVmZmVyU2l6ZSBbT3B0aW9uYWxdIE1heGltdW0gZWxlbWVudCBjb3VudCBvZiB0aGUgcmVwbGF5IGJ1ZmZlci5cclxuICAgKiBAcGFyYW0gd2luZG93IFtPcHRpb25hbF0gTWF4aW11bSB0aW1lIGxlbmd0aCBvZiB0aGUgcmVwbGF5IGJ1ZmZlci5cclxuICAgKiBAcGFyYW0gc2NoZWR1bGVyIFtPcHRpb25hbF0gU2NoZWR1bGVyIHdoZXJlIGNvbm5lY3RlZCBvYnNlcnZlcnMgd2l0aGluIHRoZSBzZWxlY3RvciBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgb24uXHJcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyB0aGUgZWxlbWVudHMgb2YgYSBzZXF1ZW5jZSBwcm9kdWNlZCBieSBtdWx0aWNhc3RpbmcgdGhlIHNvdXJjZSBzZXF1ZW5jZSB3aXRoaW4gYSBzZWxlY3RvciBmdW5jdGlvbi5cclxuICAgKi9cclxuICBvYnNlcnZhYmxlUHJvdG8ucmVwbGF5ID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBidWZmZXJTaXplLCB3aW5kb3csIHNjaGVkdWxlcikge1xyXG4gICAgcmV0dXJuIHNlbGVjdG9yICYmIGlzRnVuY3Rpb24oc2VsZWN0b3IpID9cclxuICAgICAgdGhpcy5tdWx0aWNhc3QoZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFJlcGxheVN1YmplY3QoYnVmZmVyU2l6ZSwgd2luZG93LCBzY2hlZHVsZXIpOyB9LCBzZWxlY3RvcikgOlxyXG4gICAgICB0aGlzLm11bHRpY2FzdChuZXcgUmVwbGF5U3ViamVjdChidWZmZXJTaXplLCB3aW5kb3csIHNjaGVkdWxlcikpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHNoYXJlcyBhIHNpbmdsZSBzdWJzY3JpcHRpb24gdG8gdGhlIHVuZGVybHlpbmcgc2VxdWVuY2UgcmVwbGF5aW5nIG5vdGlmaWNhdGlvbnMgc3ViamVjdCB0byBhIG1heGltdW0gdGltZSBsZW5ndGggZm9yIHRoZSByZXBsYXkgYnVmZmVyLlxyXG4gICAqIFRoaXMgb3BlcmF0b3IgaXMgYSBzcGVjaWFsaXphdGlvbiBvZiByZXBsYXkgd2hpY2ggY3JlYXRlcyBhIHN1YnNjcmlwdGlvbiB3aGVuIHRoZSBudW1iZXIgb2Ygb2JzZXJ2ZXJzIGdvZXMgZnJvbSB6ZXJvIHRvIG9uZSwgdGhlbiBzaGFyZXMgdGhhdCBzdWJzY3JpcHRpb24gd2l0aCBhbGwgc3Vic2VxdWVudCBvYnNlcnZlcnMgdW50aWwgdGhlIG51bWJlciBvZiBvYnNlcnZlcnMgcmV0dXJucyB0byB6ZXJvLCBhdCB3aGljaCBwb2ludCB0aGUgc3Vic2NyaXB0aW9uIGlzIGRpc3Bvc2VkLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiB2YXIgcmVzID0gc291cmNlLnNoYXJlUmVwbGF5KDMpO1xyXG4gICAqIHZhciByZXMgPSBzb3VyY2Uuc2hhcmVSZXBsYXkoMywgNTAwKTtcclxuICAgKiB2YXIgcmVzID0gc291cmNlLnNoYXJlUmVwbGF5KDMsIDUwMCwgc2NoZWR1bGVyKTtcclxuICAgKlxyXG5cclxuICAgKiBAcGFyYW0gYnVmZmVyU2l6ZSBbT3B0aW9uYWxdIE1heGltdW0gZWxlbWVudCBjb3VudCBvZiB0aGUgcmVwbGF5IGJ1ZmZlci5cclxuICAgKiBAcGFyYW0gd2luZG93IFtPcHRpb25hbF0gTWF4aW11bSB0aW1lIGxlbmd0aCBvZiB0aGUgcmVwbGF5IGJ1ZmZlci5cclxuICAgKiBAcGFyYW0gc2NoZWR1bGVyIFtPcHRpb25hbF0gU2NoZWR1bGVyIHdoZXJlIGNvbm5lY3RlZCBvYnNlcnZlcnMgd2l0aGluIHRoZSBzZWxlY3RvciBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgb24uXHJcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyB0aGUgZWxlbWVudHMgb2YgYSBzZXF1ZW5jZSBwcm9kdWNlZCBieSBtdWx0aWNhc3RpbmcgdGhlIHNvdXJjZSBzZXF1ZW5jZS5cclxuICAgKi9cclxuICBvYnNlcnZhYmxlUHJvdG8uc2hhcmVSZXBsYXkgPSBmdW5jdGlvbiAoYnVmZmVyU2l6ZSwgd2luZG93LCBzY2hlZHVsZXIpIHtcclxuICAgIHJldHVybiB0aGlzLnJlcGxheShudWxsLCBidWZmZXJTaXplLCB3aW5kb3csIHNjaGVkdWxlcikucmVmQ291bnQoKTtcclxuICB9O1xyXG5cclxuICAgIC8qKiBAcHJpdmF0ZSAqL1xyXG4gICAgdmFyIElubmVyU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKHN1YmplY3QsIG9ic2VydmVyKSB7XHJcbiAgICAgICAgdGhpcy5zdWJqZWN0ID0gc3ViamVjdDtcclxuICAgICAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZW1iZXJPZiBJbm5lclN1YnNjcmlwdGlvblxyXG4gICAgICovXHJcbiAgICBJbm5lclN1YnNjcmlwdGlvbi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuc3ViamVjdC5pc0Rpc3Bvc2VkICYmIHRoaXMub2JzZXJ2ZXIgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdmFyIGlkeCA9IHRoaXMuc3ViamVjdC5vYnNlcnZlcnMuaW5kZXhPZih0aGlzLm9ic2VydmVyKTtcclxuICAgICAgICAgICAgdGhpcy5zdWJqZWN0Lm9ic2VydmVycy5zcGxpY2UoaWR4LCAxKTtcclxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogIFJlcHJlc2VudHMgYSB2YWx1ZSB0aGF0IGNoYW5nZXMgb3ZlciB0aW1lLlxyXG4gICAqICBPYnNlcnZlcnMgY2FuIHN1YnNjcmliZSB0byB0aGUgc3ViamVjdCB0byByZWNlaXZlIHRoZSBsYXN0IChvciBpbml0aWFsKSB2YWx1ZSBhbmQgYWxsIHN1YnNlcXVlbnQgbm90aWZpY2F0aW9ucy5cclxuICAgKi9cclxuICB2YXIgQmVoYXZpb3JTdWJqZWN0ID0gUnguQmVoYXZpb3JTdWJqZWN0ID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcclxuICAgIGZ1bmN0aW9uIHN1YnNjcmliZShvYnNlcnZlcikge1xyXG4gICAgICBjaGVja0Rpc3Bvc2VkLmNhbGwodGhpcyk7XHJcbiAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcclxuICAgICAgICB0aGlzLm9ic2VydmVycy5wdXNoKG9ic2VydmVyKTtcclxuICAgICAgICBvYnNlcnZlci5vbk5leHQodGhpcy52YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbm5lclN1YnNjcmlwdGlvbih0aGlzLCBvYnNlcnZlcik7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGV4ID0gdGhpcy5leGNlcHRpb247XHJcbiAgICAgIGlmIChleCkge1xyXG4gICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZXgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGRpc3Bvc2FibGVFbXB0eTtcclxuICAgIH1cclxuXHJcbiAgICBpbmhlcml0cyhCZWhhdmlvclN1YmplY3QsIF9fc3VwZXJfXyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqICBJbml0aWFsaXplcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgQmVoYXZpb3JTdWJqZWN0IGNsYXNzIHdoaWNoIGNyZWF0ZXMgYSBzdWJqZWN0IHRoYXQgY2FjaGVzIGl0cyBsYXN0IHZhbHVlIGFuZCBzdGFydHMgd2l0aCB0aGUgc3BlY2lmaWVkIHZhbHVlLlxyXG4gICAgICogIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIEluaXRpYWwgdmFsdWUgc2VudCB0byBvYnNlcnZlcnMgd2hlbiBubyBvdGhlciB2YWx1ZSBoYXMgYmVlbiByZWNlaXZlZCBieSB0aGUgc3ViamVjdCB5ZXQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEJlaGF2aW9yU3ViamVjdCh2YWx1ZSkge1xyXG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzLCBzdWJzY3JpYmUpO1xyXG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWUsXHJcbiAgICAgIHRoaXMub2JzZXJ2ZXJzID0gW10sXHJcbiAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlLFxyXG4gICAgICB0aGlzLmlzU3RvcHBlZCA9IGZhbHNlLFxyXG4gICAgICB0aGlzLmV4Y2VwdGlvbiA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgYWRkUHJvcGVydGllcyhCZWhhdmlvclN1YmplY3QucHJvdG90eXBlLCBPYnNlcnZlciwge1xyXG4gICAgICAvKipcclxuICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHN1YmplY3QgaGFzIG9ic2VydmVycyBzdWJzY3JpYmVkIHRvIGl0LlxyXG4gICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHN1YmplY3QgaGFzIG9ic2VydmVycyBzdWJzY3JpYmVkIHRvIGl0LlxyXG4gICAgICAgKi9cclxuICAgICAgaGFzT2JzZXJ2ZXJzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA+IDA7XHJcbiAgICAgIH0sXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBOb3RpZmllcyBhbGwgc3Vic2NyaWJlZCBvYnNlcnZlcnMgYWJvdXQgdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2UuXHJcbiAgICAgICAqL1xyXG4gICAgICBvbkNvbXBsZXRlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNoZWNrRGlzcG9zZWQuY2FsbCh0aGlzKTtcclxuICAgICAgICBpZiAodGhpcy5pc1N0b3BwZWQpIHsgcmV0dXJuOyB9XHJcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBvcyA9IHRoaXMub2JzZXJ2ZXJzLnNsaWNlKDApLCBsZW4gPSBvcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgb3NbaV0ub25Db21wbGV0ZWQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gW107XHJcbiAgICAgIH0sXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBOb3RpZmllcyBhbGwgc3Vic2NyaWJlZCBvYnNlcnZlcnMgYWJvdXQgdGhlIGV4Y2VwdGlvbi5cclxuICAgICAgICogQHBhcmFtIHtNaXhlZH0gZXJyb3IgVGhlIGV4Y2VwdGlvbiB0byBzZW5kIHRvIGFsbCBvYnNlcnZlcnMuXHJcbiAgICAgICAqL1xyXG4gICAgICBvbkVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICBjaGVja0Rpc3Bvc2VkLmNhbGwodGhpcyk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNTdG9wcGVkKSB7IHJldHVybjsgfVxyXG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmV4Y2VwdGlvbiA9IGVycm9yO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgb3MgPSB0aGlzLm9ic2VydmVycy5zbGljZSgwKSwgbGVuID0gb3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgIG9zW2ldLm9uRXJyb3IoZXJyb3IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcclxuICAgICAgfSxcclxuICAgICAgLyoqXHJcbiAgICAgICAqIE5vdGlmaWVzIGFsbCBzdWJzY3JpYmVkIG9ic2VydmVycyBhYm91dCB0aGUgYXJyaXZhbCBvZiB0aGUgc3BlY2lmaWVkIGVsZW1lbnQgaW4gdGhlIHNlcXVlbmNlLlxyXG4gICAgICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VuZCB0byBhbGwgb2JzZXJ2ZXJzLlxyXG4gICAgICAgKi9cclxuICAgICAgb25OZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBjaGVja0Rpc3Bvc2VkLmNhbGwodGhpcyk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNTdG9wcGVkKSB7IHJldHVybjsgfVxyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgb3MgPSB0aGlzLm9ic2VydmVycy5zbGljZSgwKSwgbGVuID0gb3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgIG9zW2ldLm9uTmV4dCh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICAvKipcclxuICAgICAgICogVW5zdWJzY3JpYmUgYWxsIG9ic2VydmVycyBhbmQgcmVsZWFzZSByZXNvdXJjZXMuXHJcbiAgICAgICAqL1xyXG4gICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLm9ic2VydmVycyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5leGNlcHRpb24gPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gQmVoYXZpb3JTdWJqZWN0O1xyXG4gIH0oT2JzZXJ2YWJsZSkpO1xyXG5cclxuICAvKipcclxuICAgKiBSZXByZXNlbnRzIGFuIG9iamVjdCB0aGF0IGlzIGJvdGggYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBhcyB3ZWxsIGFzIGFuIG9ic2VydmVyLlxyXG4gICAqIEVhY2ggbm90aWZpY2F0aW9uIGlzIGJyb2FkY2FzdGVkIHRvIGFsbCBzdWJzY3JpYmVkIGFuZCBmdXR1cmUgb2JzZXJ2ZXJzLCBzdWJqZWN0IHRvIGJ1ZmZlciB0cmltbWluZyBwb2xpY2llcy5cclxuICAgKi9cclxuICB2YXIgUmVwbGF5U3ViamVjdCA9IFJ4LlJlcGxheVN1YmplY3QgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlbW92YWJsZURpc3Bvc2FibGUoc3ViamVjdCwgb2JzZXJ2ZXIpIHtcclxuICAgICAgcmV0dXJuIGRpc3Bvc2FibGVDcmVhdGUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIG9ic2VydmVyLmRpc3Bvc2UoKTtcclxuICAgICAgICAhc3ViamVjdC5pc0Rpc3Bvc2VkICYmIHN1YmplY3Qub2JzZXJ2ZXJzLnNwbGljZShzdWJqZWN0Lm9ic2VydmVycy5pbmRleE9mKG9ic2VydmVyKSwgMSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHN1YnNjcmliZShvYnNlcnZlcikge1xyXG4gICAgICB2YXIgc28gPSBuZXcgU2NoZWR1bGVkT2JzZXJ2ZXIodGhpcy5zY2hlZHVsZXIsIG9ic2VydmVyKSxcclxuICAgICAgICBzdWJzY3JpcHRpb24gPSBjcmVhdGVSZW1vdmFibGVEaXNwb3NhYmxlKHRoaXMsIHNvKTtcclxuICAgICAgY2hlY2tEaXNwb3NlZC5jYWxsKHRoaXMpO1xyXG4gICAgICB0aGlzLl90cmltKHRoaXMuc2NoZWR1bGVyLm5vdygpKTtcclxuICAgICAgdGhpcy5vYnNlcnZlcnMucHVzaChzbyk7XHJcblxyXG4gICAgICB2YXIgbiA9IHRoaXMucS5sZW5ndGg7XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5xLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgc28ub25OZXh0KHRoaXMucVtpXS52YWx1ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLmhhc0Vycm9yKSB7XHJcbiAgICAgICAgbisrO1xyXG4gICAgICAgIHNvLm9uRXJyb3IodGhpcy5lcnJvcik7XHJcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1N0b3BwZWQpIHtcclxuICAgICAgICBuKys7XHJcbiAgICAgICAgc28ub25Db21wbGV0ZWQoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc28uZW5zdXJlQWN0aXZlKG4pO1xyXG4gICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIGluaGVyaXRzKFJlcGxheVN1YmplY3QsIF9fc3VwZXJfXyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAgSW5pdGlhbGl6ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIFJlcGxheVN1YmplY3QgY2xhc3Mgd2l0aCB0aGUgc3BlY2lmaWVkIGJ1ZmZlciBzaXplLCB3aW5kb3cgc2l6ZSBhbmQgc2NoZWR1bGVyLlxyXG4gICAgICogIEBwYXJhbSB7TnVtYmVyfSBbYnVmZmVyU2l6ZV0gTWF4aW11bSBlbGVtZW50IGNvdW50IG9mIHRoZSByZXBsYXkgYnVmZmVyLlxyXG4gICAgICogIEBwYXJhbSB7TnVtYmVyfSBbd2luZG93U2l6ZV0gTWF4aW11bSB0aW1lIGxlbmd0aCBvZiB0aGUgcmVwbGF5IGJ1ZmZlci5cclxuICAgICAqICBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gU2NoZWR1bGVyIHRoZSBvYnNlcnZlcnMgYXJlIGludm9rZWQgb24uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFJlcGxheVN1YmplY3QoYnVmZmVyU2l6ZSwgd2luZG93U2l6ZSwgc2NoZWR1bGVyKSB7XHJcbiAgICAgIHRoaXMuYnVmZmVyU2l6ZSA9IGJ1ZmZlclNpemUgPT0gbnVsbCA/IE51bWJlci5NQVhfVkFMVUUgOiBidWZmZXJTaXplO1xyXG4gICAgICB0aGlzLndpbmRvd1NpemUgPSB3aW5kb3dTaXplID09IG51bGwgPyBOdW1iZXIuTUFYX1ZBTFVFIDogd2luZG93U2l6ZTtcclxuICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXIgfHwgY3VycmVudFRocmVhZFNjaGVkdWxlcjtcclxuICAgICAgdGhpcy5xID0gW107XHJcbiAgICAgIHRoaXMub2JzZXJ2ZXJzID0gW107XHJcbiAgICAgIHRoaXMuaXNTdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xyXG4gICAgICB0aGlzLmhhc0Vycm9yID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuZXJyb3IgPSBudWxsO1xyXG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzLCBzdWJzY3JpYmUpO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZFByb3BlcnRpZXMoUmVwbGF5U3ViamVjdC5wcm90b3R5cGUsIE9ic2VydmVyLCB7XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc3ViamVjdCBoYXMgb2JzZXJ2ZXJzIHN1YnNjcmliZWQgdG8gaXQuXHJcbiAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc3ViamVjdCBoYXMgb2JzZXJ2ZXJzIHN1YnNjcmliZWQgdG8gaXQuXHJcbiAgICAgICAqL1xyXG4gICAgICBoYXNPYnNlcnZlcnM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vYnNlcnZlcnMubGVuZ3RoID4gMDtcclxuICAgICAgfSxcclxuICAgICAgX3RyaW06IGZ1bmN0aW9uIChub3cpIHtcclxuICAgICAgICB3aGlsZSAodGhpcy5xLmxlbmd0aCA+IHRoaXMuYnVmZmVyU2l6ZSkge1xyXG4gICAgICAgICAgdGhpcy5xLnNoaWZ0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlICh0aGlzLnEubGVuZ3RoID4gMCAmJiAobm93IC0gdGhpcy5xWzBdLmludGVydmFsKSA+IHRoaXMud2luZG93U2l6ZSkge1xyXG4gICAgICAgICAgdGhpcy5xLnNoaWZ0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICAvKipcclxuICAgICAgICogTm90aWZpZXMgYWxsIHN1YnNjcmliZWQgb2JzZXJ2ZXJzIGFib3V0IHRoZSBhcnJpdmFsIG9mIHRoZSBzcGVjaWZpZWQgZWxlbWVudCBpbiB0aGUgc2VxdWVuY2UuXHJcbiAgICAgICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZW5kIHRvIGFsbCBvYnNlcnZlcnMuXHJcbiAgICAgICAqL1xyXG4gICAgICBvbk5leHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGNoZWNrRGlzcG9zZWQuY2FsbCh0aGlzKTtcclxuICAgICAgICBpZiAodGhpcy5pc1N0b3BwZWQpIHsgcmV0dXJuOyB9XHJcbiAgICAgICAgdmFyIG5vdyA9IHRoaXMuc2NoZWR1bGVyLm5vdygpO1xyXG4gICAgICAgIHRoaXMucS5wdXNoKHsgaW50ZXJ2YWw6IG5vdywgdmFsdWU6IHZhbHVlIH0pO1xyXG4gICAgICAgIHRoaXMuX3RyaW0obm93KTtcclxuXHJcbiAgICAgICAgdmFyIG8gPSB0aGlzLm9ic2VydmVycy5zbGljZSgwKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gby5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgdmFyIG9ic2VydmVyID0gb1tpXTtcclxuICAgICAgICAgIG9ic2VydmVyLm9uTmV4dCh2YWx1ZSk7XHJcbiAgICAgICAgICBvYnNlcnZlci5lbnN1cmVBY3RpdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBOb3RpZmllcyBhbGwgc3Vic2NyaWJlZCBvYnNlcnZlcnMgYWJvdXQgdGhlIGV4Y2VwdGlvbi5cclxuICAgICAgICogQHBhcmFtIHtNaXhlZH0gZXJyb3IgVGhlIGV4Y2VwdGlvbiB0byBzZW5kIHRvIGFsbCBvYnNlcnZlcnMuXHJcbiAgICAgICAqL1xyXG4gICAgICBvbkVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICBjaGVja0Rpc3Bvc2VkLmNhbGwodGhpcyk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNTdG9wcGVkKSB7IHJldHVybjsgfVxyXG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XHJcbiAgICAgICAgdGhpcy5oYXNFcnJvciA9IHRydWU7XHJcbiAgICAgICAgdmFyIG5vdyA9IHRoaXMuc2NoZWR1bGVyLm5vdygpO1xyXG4gICAgICAgIHRoaXMuX3RyaW0obm93KTtcclxuICAgICAgICB2YXIgbyA9IHRoaXMub2JzZXJ2ZXJzLnNsaWNlKDApO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBvW2ldO1xyXG4gICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlcnJvcik7XHJcbiAgICAgICAgICBvYnNlcnZlci5lbnN1cmVBY3RpdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcclxuICAgICAgfSxcclxuICAgICAgLyoqXHJcbiAgICAgICAqIE5vdGlmaWVzIGFsbCBzdWJzY3JpYmVkIG9ic2VydmVycyBhYm91dCB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZS5cclxuICAgICAgICovXHJcbiAgICAgIG9uQ29tcGxldGVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY2hlY2tEaXNwb3NlZC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIGlmICh0aGlzLmlzU3RvcHBlZCkgeyByZXR1cm47IH1cclxuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgdmFyIG5vdyA9IHRoaXMuc2NoZWR1bGVyLm5vdygpO1xyXG4gICAgICAgIHRoaXMuX3RyaW0obm93KTtcclxuICAgICAgICB2YXIgbyA9IHRoaXMub2JzZXJ2ZXJzLnNsaWNlKDApO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBvW2ldO1xyXG4gICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgICAgIG9ic2VydmVyLmVuc3VyZUFjdGl2ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm9ic2VydmVycyA9IFtdO1xyXG4gICAgICB9LFxyXG4gICAgICAvKipcclxuICAgICAgICogVW5zdWJzY3JpYmUgYWxsIG9ic2VydmVycyBhbmQgcmVsZWFzZSByZXNvdXJjZXMuXHJcbiAgICAgICAqL1xyXG4gICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLm9ic2VydmVycyA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBSZXBsYXlTdWJqZWN0O1xyXG4gIH0oT2JzZXJ2YWJsZSkpO1xyXG5cclxuICB2YXIgQ29ubmVjdGFibGVPYnNlcnZhYmxlID0gUnguQ29ubmVjdGFibGVPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcclxuICAgIGluaGVyaXRzKENvbm5lY3RhYmxlT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcclxuXHJcbiAgICBmdW5jdGlvbiBDb25uZWN0YWJsZU9ic2VydmFibGUoc291cmNlLCBzdWJqZWN0KSB7XHJcbiAgICAgIHZhciBoYXNTdWJzY3JpcHRpb24gPSBmYWxzZSxcclxuICAgICAgICBzdWJzY3JpcHRpb24sXHJcbiAgICAgICAgc291cmNlT2JzZXJ2YWJsZSA9IHNvdXJjZS5hc09ic2VydmFibGUoKTtcclxuXHJcbiAgICAgIHRoaXMuY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIWhhc1N1YnNjcmlwdGlvbikge1xyXG4gICAgICAgICAgaGFzU3Vic2NyaXB0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKHNvdXJjZU9ic2VydmFibGUuc3Vic2NyaWJlKHN1YmplY3QpLCBkaXNwb3NhYmxlQ3JlYXRlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaGFzU3Vic2NyaXB0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzLCBzdWJqZWN0LnN1YnNjcmliZS5iaW5kKHN1YmplY3QpKTtcclxuICAgIH1cclxuXHJcbiAgICBDb25uZWN0YWJsZU9ic2VydmFibGUucHJvdG90eXBlLnJlZkNvdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgY29ubmVjdGFibGVTdWJzY3JpcHRpb24sIGNvdW50ID0gMCwgc291cmNlID0gdGhpcztcclxuICAgICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgICAgdmFyIHNob3VsZENvbm5lY3QgPSArK2NvdW50ID09PSAxLFxyXG4gICAgICAgICAgICBzdWJzY3JpcHRpb24gPSBzb3VyY2Uuc3Vic2NyaWJlKG9ic2VydmVyKTtcclxuICAgICAgICAgIHNob3VsZENvbm5lY3QgJiYgKGNvbm5lY3RhYmxlU3Vic2NyaXB0aW9uID0gc291cmNlLmNvbm5lY3QoKSk7XHJcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAtLWNvdW50ID09PSAwICYmIGNvbm5lY3RhYmxlU3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcclxuICAgICAgICAgIH07XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gQ29ubmVjdGFibGVPYnNlcnZhYmxlO1xyXG4gIH0oT2JzZXJ2YWJsZSkpO1xyXG5cclxuICB2YXIgRGljdGlvbmFyeSA9IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIHByaW1lcyA9IFsxLCAzLCA3LCAxMywgMzEsIDYxLCAxMjcsIDI1MSwgNTA5LCAxMDIxLCAyMDM5LCA0MDkzLCA4MTkxLCAxNjM4MSwgMzI3NDksIDY1NTIxLCAxMzEwNzEsIDI2MjEzOSwgNTI0Mjg3LCAxMDQ4NTczLCAyMDk3MTQzLCA0MTk0MzAxLCA4Mzg4NTkzLCAxNjc3NzIxMywgMzM1NTQzOTMsIDY3MTA4ODU5LCAxMzQyMTc2ODksIDI2ODQzNTM5OSwgNTM2ODcwOTA5LCAxMDczNzQxNzg5LCAyMTQ3NDgzNjQ3XSxcclxuICAgICAgbm9TdWNoa2V5ID0gXCJubyBzdWNoIGtleVwiLFxyXG4gICAgICBkdXBsaWNhdGVrZXkgPSBcImR1cGxpY2F0ZSBrZXlcIjtcclxuXHJcbiAgICBmdW5jdGlvbiBpc1ByaW1lKGNhbmRpZGF0ZSkge1xyXG4gICAgICBpZiAoY2FuZGlkYXRlICYgMSA9PT0gMCkgeyByZXR1cm4gY2FuZGlkYXRlID09PSAyOyB9XHJcbiAgICAgIHZhciBudW0xID0gTWF0aC5zcXJ0KGNhbmRpZGF0ZSksXHJcbiAgICAgICAgbnVtMiA9IDM7XHJcbiAgICAgIHdoaWxlIChudW0yIDw9IG51bTEpIHtcclxuICAgICAgICBpZiAoY2FuZGlkYXRlICUgbnVtMiA9PT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cclxuICAgICAgICBudW0yICs9IDI7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0UHJpbWUobWluKSB7XHJcbiAgICAgIHZhciBpbmRleCwgbnVtLCBjYW5kaWRhdGU7XHJcbiAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHByaW1lcy5sZW5ndGg7ICsraW5kZXgpIHtcclxuICAgICAgICBudW0gPSBwcmltZXNbaW5kZXhdO1xyXG4gICAgICAgIGlmIChudW0gPj0gbWluKSB7IHJldHVybiBudW07IH1cclxuICAgICAgfVxyXG4gICAgICBjYW5kaWRhdGUgPSBtaW4gfCAxO1xyXG4gICAgICB3aGlsZSAoY2FuZGlkYXRlIDwgcHJpbWVzW3ByaW1lcy5sZW5ndGggLSAxXSkge1xyXG4gICAgICAgIGlmIChpc1ByaW1lKGNhbmRpZGF0ZSkpIHsgcmV0dXJuIGNhbmRpZGF0ZTsgfVxyXG4gICAgICAgIGNhbmRpZGF0ZSArPSAyO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBtaW47XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc3RyaW5nSGFzaEZuKHN0cikge1xyXG4gICAgICB2YXIgaGFzaCA9IDc1NzYwMjA0NjtcclxuICAgICAgaWYgKCFzdHIubGVuZ3RoKSB7IHJldHVybiBoYXNoOyB9XHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdHIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICB2YXIgY2hhcmFjdGVyID0gc3RyLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaGFzaCA9ICgoaGFzaDw8NSktaGFzaCkrY2hhcmFjdGVyO1xyXG4gICAgICAgIGhhc2ggPSBoYXNoICYgaGFzaDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gaGFzaDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBudW1iZXJIYXNoRm4oa2V5KSB7XHJcbiAgICAgIHZhciBjMiA9IDB4MjdkNGViMmQ7XHJcbiAgICAgIGtleSA9IChrZXkgXiA2MSkgXiAoa2V5ID4+PiAxNik7XHJcbiAgICAgIGtleSA9IGtleSArIChrZXkgPDwgMyk7XHJcbiAgICAgIGtleSA9IGtleSBeIChrZXkgPj4+IDQpO1xyXG4gICAgICBrZXkgPSBrZXkgKiBjMjtcclxuICAgICAga2V5ID0ga2V5IF4gKGtleSA+Pj4gMTUpO1xyXG4gICAgICByZXR1cm4ga2V5O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBnZXRIYXNoQ29kZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciB1bmlxdWVJZENvdW50ZXIgPSAwO1xyXG5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICBpZiAob2JqID09IG51bGwpIHsgdGhyb3cgbmV3IEVycm9yKG5vU3VjaGtleSk7IH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGJ1aWx0LWlucyBiZWZvcmUgdGFja2luZyBvbiBvdXIgb3duIGZvciBhbnkgb2JqZWN0XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7IHJldHVybiBzdHJpbmdIYXNoRm4ob2JqKTsgfVxyXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnbnVtYmVyJykgeyByZXR1cm4gbnVtYmVySGFzaEZuKG9iaik7IH1cclxuICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ2Jvb2xlYW4nKSB7IHJldHVybiBvYmogPT09IHRydWUgPyAxIDogMDsgfVxyXG4gICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBEYXRlKSB7IHJldHVybiBudW1iZXJIYXNoRm4ob2JqLnZhbHVlT2YoKSk7IH1cclxuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgUmVnRXhwKSB7IHJldHVybiBzdHJpbmdIYXNoRm4ob2JqLnRvU3RyaW5nKCkpOyB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvYmoudmFsdWVPZiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgLy8gSGFjayBjaGVjayBmb3IgdmFsdWVPZlxyXG4gICAgICAgICAgdmFyIHZhbHVlT2YgPSBvYmoudmFsdWVPZigpO1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZU9mID09PSAnbnVtYmVyJykgeyByZXR1cm4gbnVtYmVySGFzaEZuKHZhbHVlT2YpOyB9XHJcbiAgICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIHN0cmluZ0hhc2hGbih2YWx1ZU9mKTsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob2JqLmdldEhhc2hDb2RlKSB7IHJldHVybiBvYmouZ2V0SGFzaENvZGUoKTsgfVxyXG5cclxuICAgICAgICB2YXIgaWQgPSAxNyAqIHVuaXF1ZUlkQ291bnRlcisrO1xyXG4gICAgICAgIG9iai5nZXRIYXNoQ29kZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlkOyB9O1xyXG4gICAgICAgIHJldHVybiBpZDtcclxuICAgICAgfTtcclxuICAgIH0oKSk7XHJcblxyXG4gICAgZnVuY3Rpb24gbmV3RW50cnkoKSB7XHJcbiAgICAgIHJldHVybiB7IGtleTogbnVsbCwgdmFsdWU6IG51bGwsIG5leHQ6IDAsIGhhc2hDb2RlOiAwIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gRGljdGlvbmFyeShjYXBhY2l0eSwgY29tcGFyZXIpIHtcclxuICAgICAgaWYgKGNhcGFjaXR5IDwgMCkgeyB0aHJvdyBuZXcgRXJyb3IoJ291dCBvZiByYW5nZScpOyB9XHJcbiAgICAgIGlmIChjYXBhY2l0eSA+IDApIHsgdGhpcy5faW5pdGlhbGl6ZShjYXBhY2l0eSk7IH1cclxuXHJcbiAgICAgIHRoaXMuY29tcGFyZXIgPSBjb21wYXJlciB8fCBkZWZhdWx0Q29tcGFyZXI7XHJcbiAgICAgIHRoaXMuZnJlZUNvdW50ID0gMDtcclxuICAgICAgdGhpcy5zaXplID0gMDtcclxuICAgICAgdGhpcy5mcmVlTGlzdCA9IC0xO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBkaWN0aW9uYXJ5UHJvdG8gPSBEaWN0aW9uYXJ5LnByb3RvdHlwZTtcclxuXHJcbiAgICBkaWN0aW9uYXJ5UHJvdG8uX2luaXRpYWxpemUgPSBmdW5jdGlvbiAoY2FwYWNpdHkpIHtcclxuICAgICAgdmFyIHByaW1lID0gZ2V0UHJpbWUoY2FwYWNpdHkpLCBpO1xyXG4gICAgICB0aGlzLmJ1Y2tldHMgPSBuZXcgQXJyYXkocHJpbWUpO1xyXG4gICAgICB0aGlzLmVudHJpZXMgPSBuZXcgQXJyYXkocHJpbWUpO1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcHJpbWU7IGkrKykge1xyXG4gICAgICAgIHRoaXMuYnVja2V0c1tpXSA9IC0xO1xyXG4gICAgICAgIHRoaXMuZW50cmllc1tpXSA9IG5ld0VudHJ5KCk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5mcmVlTGlzdCA9IC0xO1xyXG4gICAgfTtcclxuXHJcbiAgICBkaWN0aW9uYXJ5UHJvdG8uYWRkID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2luc2VydChrZXksIHZhbHVlLCB0cnVlKTtcclxuICAgIH07XHJcblxyXG4gICAgZGljdGlvbmFyeVByb3RvLl9pbnNlcnQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgYWRkKSB7XHJcbiAgICAgIGlmICghdGhpcy5idWNrZXRzKSB7IHRoaXMuX2luaXRpYWxpemUoMCk7IH1cclxuICAgICAgdmFyIGluZGV4MyxcclxuICAgICAgICBudW0gPSBnZXRIYXNoQ29kZShrZXkpICYgMjE0NzQ4MzY0NyxcclxuICAgICAgICBpbmRleDEgPSBudW0gJSB0aGlzLmJ1Y2tldHMubGVuZ3RoO1xyXG4gICAgICBmb3IgKHZhciBpbmRleDIgPSB0aGlzLmJ1Y2tldHNbaW5kZXgxXTsgaW5kZXgyID49IDA7IGluZGV4MiA9IHRoaXMuZW50cmllc1tpbmRleDJdLm5leHQpIHtcclxuICAgICAgICBpZiAodGhpcy5lbnRyaWVzW2luZGV4Ml0uaGFzaENvZGUgPT09IG51bSAmJiB0aGlzLmNvbXBhcmVyKHRoaXMuZW50cmllc1tpbmRleDJdLmtleSwga2V5KSkge1xyXG4gICAgICAgICAgaWYgKGFkZCkgeyB0aHJvdyBuZXcgRXJyb3IoZHVwbGljYXRla2V5KTsgfVxyXG4gICAgICAgICAgdGhpcy5lbnRyaWVzW2luZGV4Ml0udmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuZnJlZUNvdW50ID4gMCkge1xyXG4gICAgICAgIGluZGV4MyA9IHRoaXMuZnJlZUxpc3Q7XHJcbiAgICAgICAgdGhpcy5mcmVlTGlzdCA9IHRoaXMuZW50cmllc1tpbmRleDNdLm5leHQ7XHJcbiAgICAgICAgLS10aGlzLmZyZWVDb3VudDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAodGhpcy5zaXplID09PSB0aGlzLmVudHJpZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICB0aGlzLl9yZXNpemUoKTtcclxuICAgICAgICAgIGluZGV4MSA9IG51bSAlIHRoaXMuYnVja2V0cy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluZGV4MyA9IHRoaXMuc2l6ZTtcclxuICAgICAgICArK3RoaXMuc2l6ZTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmVudHJpZXNbaW5kZXgzXS5oYXNoQ29kZSA9IG51bTtcclxuICAgICAgdGhpcy5lbnRyaWVzW2luZGV4M10ubmV4dCA9IHRoaXMuYnVja2V0c1tpbmRleDFdO1xyXG4gICAgICB0aGlzLmVudHJpZXNbaW5kZXgzXS5rZXkgPSBrZXk7XHJcbiAgICAgIHRoaXMuZW50cmllc1tpbmRleDNdLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgIHRoaXMuYnVja2V0c1tpbmRleDFdID0gaW5kZXgzO1xyXG4gICAgfTtcclxuXHJcbiAgICBkaWN0aW9uYXJ5UHJvdG8uX3Jlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHByaW1lID0gZ2V0UHJpbWUodGhpcy5zaXplICogMiksXHJcbiAgICAgICAgbnVtQXJyYXkgPSBuZXcgQXJyYXkocHJpbWUpO1xyXG4gICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBudW1BcnJheS5sZW5ndGg7ICsraW5kZXgpIHsgIG51bUFycmF5W2luZGV4XSA9IC0xOyB9XHJcbiAgICAgIHZhciBlbnRyeUFycmF5ID0gbmV3IEFycmF5KHByaW1lKTtcclxuICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5zaXplOyArK2luZGV4KSB7IGVudHJ5QXJyYXlbaW5kZXhdID0gdGhpcy5lbnRyaWVzW2luZGV4XTsgfVxyXG4gICAgICBmb3IgKHZhciBpbmRleCA9IHRoaXMuc2l6ZTsgaW5kZXggPCBwcmltZTsgKytpbmRleCkgeyBlbnRyeUFycmF5W2luZGV4XSA9IG5ld0VudHJ5KCk7IH1cclxuICAgICAgZm9yICh2YXIgaW5kZXgxID0gMDsgaW5kZXgxIDwgdGhpcy5zaXplOyArK2luZGV4MSkge1xyXG4gICAgICAgIHZhciBpbmRleDIgPSBlbnRyeUFycmF5W2luZGV4MV0uaGFzaENvZGUgJSBwcmltZTtcclxuICAgICAgICBlbnRyeUFycmF5W2luZGV4MV0ubmV4dCA9IG51bUFycmF5W2luZGV4Ml07XHJcbiAgICAgICAgbnVtQXJyYXlbaW5kZXgyXSA9IGluZGV4MTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmJ1Y2tldHMgPSBudW1BcnJheTtcclxuICAgICAgdGhpcy5lbnRyaWVzID0gZW50cnlBcnJheTtcclxuICAgIH07XHJcblxyXG4gICAgZGljdGlvbmFyeVByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgaWYgKHRoaXMuYnVja2V0cykge1xyXG4gICAgICAgIHZhciBudW0gPSBnZXRIYXNoQ29kZShrZXkpICYgMjE0NzQ4MzY0NyxcclxuICAgICAgICAgIGluZGV4MSA9IG51bSAlIHRoaXMuYnVja2V0cy5sZW5ndGgsXHJcbiAgICAgICAgICBpbmRleDIgPSAtMTtcclxuICAgICAgICBmb3IgKHZhciBpbmRleDMgPSB0aGlzLmJ1Y2tldHNbaW5kZXgxXTsgaW5kZXgzID49IDA7IGluZGV4MyA9IHRoaXMuZW50cmllc1tpbmRleDNdLm5leHQpIHtcclxuICAgICAgICAgIGlmICh0aGlzLmVudHJpZXNbaW5kZXgzXS5oYXNoQ29kZSA9PT0gbnVtICYmIHRoaXMuY29tcGFyZXIodGhpcy5lbnRyaWVzW2luZGV4M10ua2V5LCBrZXkpKSB7XHJcbiAgICAgICAgICAgIGlmIChpbmRleDIgPCAwKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5idWNrZXRzW2luZGV4MV0gPSB0aGlzLmVudHJpZXNbaW5kZXgzXS5uZXh0O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHRoaXMuZW50cmllc1tpbmRleDJdLm5leHQgPSB0aGlzLmVudHJpZXNbaW5kZXgzXS5uZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZW50cmllc1tpbmRleDNdLmhhc2hDb2RlID0gLTE7XHJcbiAgICAgICAgICAgIHRoaXMuZW50cmllc1tpbmRleDNdLm5leHQgPSB0aGlzLmZyZWVMaXN0O1xyXG4gICAgICAgICAgICB0aGlzLmVudHJpZXNbaW5kZXgzXS5rZXkgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmVudHJpZXNbaW5kZXgzXS52YWx1ZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuZnJlZUxpc3QgPSBpbmRleDM7XHJcbiAgICAgICAgICAgICsrdGhpcy5mcmVlQ291bnQ7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaW5kZXgyID0gaW5kZXgzO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIGRpY3Rpb25hcnlQcm90by5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGluZGV4LCBsZW47XHJcbiAgICAgIGlmICh0aGlzLnNpemUgPD0gMCkgeyByZXR1cm47IH1cclxuICAgICAgZm9yIChpbmRleCA9IDAsIGxlbiA9IHRoaXMuYnVja2V0cy5sZW5ndGg7IGluZGV4IDwgbGVuOyArK2luZGV4KSB7XHJcbiAgICAgICAgdGhpcy5idWNrZXRzW2luZGV4XSA9IC0xO1xyXG4gICAgICB9XHJcbiAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuc2l6ZTsgKytpbmRleCkge1xyXG4gICAgICAgIHRoaXMuZW50cmllc1tpbmRleF0gPSBuZXdFbnRyeSgpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuZnJlZUxpc3QgPSAtMTtcclxuICAgICAgdGhpcy5zaXplID0gMDtcclxuICAgIH07XHJcblxyXG4gICAgZGljdGlvbmFyeVByb3RvLl9maW5kRW50cnkgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgIGlmICh0aGlzLmJ1Y2tldHMpIHtcclxuICAgICAgICB2YXIgbnVtID0gZ2V0SGFzaENvZGUoa2V5KSAmIDIxNDc0ODM2NDc7XHJcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSB0aGlzLmJ1Y2tldHNbbnVtICUgdGhpcy5idWNrZXRzLmxlbmd0aF07IGluZGV4ID49IDA7IGluZGV4ID0gdGhpcy5lbnRyaWVzW2luZGV4XS5uZXh0KSB7XHJcbiAgICAgICAgICBpZiAodGhpcy5lbnRyaWVzW2luZGV4XS5oYXNoQ29kZSA9PT0gbnVtICYmIHRoaXMuY29tcGFyZXIodGhpcy5lbnRyaWVzW2luZGV4XS5rZXksIGtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gLTE7XHJcbiAgICB9O1xyXG5cclxuICAgIGRpY3Rpb25hcnlQcm90by5jb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc2l6ZSAtIHRoaXMuZnJlZUNvdW50O1xyXG4gICAgfTtcclxuXHJcbiAgICBkaWN0aW9uYXJ5UHJvdG8udHJ5R2V0VmFsdWUgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgIHZhciBlbnRyeSA9IHRoaXMuX2ZpbmRFbnRyeShrZXkpO1xyXG4gICAgICByZXR1cm4gZW50cnkgPj0gMCA/XHJcbiAgICAgICAgdGhpcy5lbnRyaWVzW2VudHJ5XS52YWx1ZSA6XHJcbiAgICAgICAgdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuXHJcbiAgICBkaWN0aW9uYXJ5UHJvdG8uZ2V0VmFsdWVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgaW5kZXggPSAwLCByZXN1bHRzID0gW107XHJcbiAgICAgIGlmICh0aGlzLmVudHJpZXMpIHtcclxuICAgICAgICBmb3IgKHZhciBpbmRleDEgPSAwOyBpbmRleDEgPCB0aGlzLnNpemU7IGluZGV4MSsrKSB7XHJcbiAgICAgICAgICBpZiAodGhpcy5lbnRyaWVzW2luZGV4MV0uaGFzaENvZGUgPj0gMCkge1xyXG4gICAgICAgICAgICByZXN1bHRzW2luZGV4KytdID0gdGhpcy5lbnRyaWVzW2luZGV4MV0udmFsdWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgfTtcclxuXHJcbiAgICBkaWN0aW9uYXJ5UHJvdG8uZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICB2YXIgZW50cnkgPSB0aGlzLl9maW5kRW50cnkoa2V5KTtcclxuICAgICAgaWYgKGVudHJ5ID49IDApIHsgcmV0dXJuIHRoaXMuZW50cmllc1tlbnRyeV0udmFsdWU7IH1cclxuICAgICAgdGhyb3cgbmV3IEVycm9yKG5vU3VjaGtleSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGRpY3Rpb25hcnlQcm90by5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICB0aGlzLl9pbnNlcnQoa2V5LCB2YWx1ZSwgZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICBkaWN0aW9uYXJ5UHJvdG8uY29udGFpbnNrZXkgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9maW5kRW50cnkoa2V5KSA+PSAwO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gRGljdGlvbmFyeTtcclxuICB9KCkpO1xyXG5cclxuICAvKipcclxuICAgKiAgQ29ycmVsYXRlcyB0aGUgZWxlbWVudHMgb2YgdHdvIHNlcXVlbmNlcyBiYXNlZCBvbiBvdmVybGFwcGluZyBkdXJhdGlvbnMuXHJcbiAgICpcclxuICAgKiAgQHBhcmFtIHtPYnNlcnZhYmxlfSByaWdodCBUaGUgcmlnaHQgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0byBqb2luIGVsZW1lbnRzIGZvci5cclxuICAgKiAgQHBhcmFtIHtGdW5jdGlvbn0gbGVmdER1cmF0aW9uU2VsZWN0b3IgQSBmdW5jdGlvbiB0byBzZWxlY3QgdGhlIGR1cmF0aW9uIChleHByZXNzZWQgYXMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSkgb2YgZWFjaCBlbGVtZW50IG9mIHRoZSBsZWZ0IG9ic2VydmFibGUgc2VxdWVuY2UsIHVzZWQgdG8gZGV0ZXJtaW5lIG92ZXJsYXAuXHJcbiAgICogIEBwYXJhbSB7RnVuY3Rpb259IHJpZ2h0RHVyYXRpb25TZWxlY3RvciBBIGZ1bmN0aW9uIHRvIHNlbGVjdCB0aGUgZHVyYXRpb24gKGV4cHJlc3NlZCBhcyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlKSBvZiBlYWNoIGVsZW1lbnQgb2YgdGhlIHJpZ2h0IG9ic2VydmFibGUgc2VxdWVuY2UsIHVzZWQgdG8gZGV0ZXJtaW5lIG92ZXJsYXAuXHJcbiAgICogIEBwYXJhbSB7RnVuY3Rpb259IHJlc3VsdFNlbGVjdG9yIEEgZnVuY3Rpb24gaW52b2tlZCB0byBjb21wdXRlIGEgcmVzdWx0IGVsZW1lbnQgZm9yIGFueSB0d28gb3ZlcmxhcHBpbmcgZWxlbWVudHMgb2YgdGhlIGxlZnQgYW5kIHJpZ2h0IG9ic2VydmFibGUgc2VxdWVuY2VzLiBUaGUgcGFyYW1ldGVycyBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uIGNvcnJlc3BvbmQgd2l0aCB0aGUgZWxlbWVudHMgZnJvbSB0aGUgbGVmdCBhbmQgcmlnaHQgc291cmNlIHNlcXVlbmNlcyBmb3Igd2hpY2ggb3ZlcmxhcCBvY2N1cnMuXHJcbiAgICogIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgcmVzdWx0IGVsZW1lbnRzIGNvbXB1dGVkIGZyb20gc291cmNlIGVsZW1lbnRzIHRoYXQgaGF2ZSBhbiBvdmVybGFwcGluZyBkdXJhdGlvbi5cclxuICAgKi9cclxuICBvYnNlcnZhYmxlUHJvdG8uam9pbiA9IGZ1bmN0aW9uIChyaWdodCwgbGVmdER1cmF0aW9uU2VsZWN0b3IsIHJpZ2h0RHVyYXRpb25TZWxlY3RvciwgcmVzdWx0U2VsZWN0b3IpIHtcclxuICAgIHZhciBsZWZ0ID0gdGhpcztcclxuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgdmFyIGdyb3VwID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKTtcclxuICAgICAgdmFyIGxlZnREb25lID0gZmFsc2UsIHJpZ2h0RG9uZSA9IGZhbHNlO1xyXG4gICAgICB2YXIgbGVmdElkID0gMCwgcmlnaHRJZCA9IDA7XHJcbiAgICAgIHZhciBsZWZ0TWFwID0gbmV3IERpY3Rpb25hcnkoKSwgcmlnaHRNYXAgPSBuZXcgRGljdGlvbmFyeSgpO1xyXG5cclxuICAgICAgZ3JvdXAuYWRkKGxlZnQuc3Vic2NyaWJlKFxyXG4gICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgdmFyIGlkID0gbGVmdElkKys7XHJcbiAgICAgICAgICB2YXIgbWQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcclxuXHJcbiAgICAgICAgICBsZWZ0TWFwLmFkZChpZCwgdmFsdWUpO1xyXG4gICAgICAgICAgZ3JvdXAuYWRkKG1kKTtcclxuXHJcbiAgICAgICAgICB2YXIgZXhwaXJlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBsZWZ0TWFwLnJlbW92ZShpZCkgJiYgbGVmdE1hcC5jb3VudCgpID09PSAwICYmIGxlZnREb25lICYmIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgICAgICAgIGdyb3VwLnJlbW92ZShtZCk7XHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIHZhciBkdXJhdGlvbjtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGR1cmF0aW9uID0gbGVmdER1cmF0aW9uU2VsZWN0b3IodmFsdWUpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBvYnNlcnZlci5vbkVycm9yKGUpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgbWQuc2V0RGlzcG9zYWJsZShkdXJhdGlvbi50YWtlKDEpLnN1YnNjcmliZShub29wLCBvYnNlcnZlci5vbkVycm9yLmJpbmQob2JzZXJ2ZXIpLCBleHBpcmUpKTtcclxuXHJcbiAgICAgICAgICByaWdodE1hcC5nZXRWYWx1ZXMoKS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0U2VsZWN0b3IodmFsdWUsIHYpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChleG4pIHtcclxuICAgICAgICAgICAgICBvYnNlcnZlci5vbkVycm9yKGV4bik7XHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBvYnNlcnZlci5vbk5leHQocmVzdWx0KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb2JzZXJ2ZXIub25FcnJvci5iaW5kKG9ic2VydmVyKSxcclxuICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBsZWZ0RG9uZSA9IHRydWU7XHJcbiAgICAgICAgICAocmlnaHREb25lIHx8IGxlZnRNYXAuY291bnQoKSA9PT0gMCkgJiYgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgICB9KVxyXG4gICAgICApO1xyXG5cclxuICAgICAgZ3JvdXAuYWRkKHJpZ2h0LnN1YnNjcmliZShcclxuICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgIHZhciBpZCA9IHJpZ2h0SWQrKztcclxuICAgICAgICAgIHZhciBtZCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xyXG5cclxuICAgICAgICAgIHJpZ2h0TWFwLmFkZChpZCwgdmFsdWUpO1xyXG4gICAgICAgICAgZ3JvdXAuYWRkKG1kKTtcclxuXHJcbiAgICAgICAgICB2YXIgZXhwaXJlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByaWdodE1hcC5yZW1vdmUoaWQpICYmIHJpZ2h0TWFwLmNvdW50KCkgPT09IDAgJiYgcmlnaHREb25lICYmIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgICAgICAgIGdyb3VwLnJlbW92ZShtZCk7XHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIHZhciBkdXJhdGlvbjtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGR1cmF0aW9uID0gcmlnaHREdXJhdGlvblNlbGVjdG9yKHZhbHVlKTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIG1kLnNldERpc3Bvc2FibGUoZHVyYXRpb24udGFrZSgxKS5zdWJzY3JpYmUobm9vcCwgb2JzZXJ2ZXIub25FcnJvci5iaW5kKG9ic2VydmVyKSwgZXhwaXJlKSk7XHJcblxyXG4gICAgICAgICAgbGVmdE1hcC5nZXRWYWx1ZXMoKS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0U2VsZWN0b3IodiwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9IGNhdGNoKGV4bikge1xyXG4gICAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZXhuKTtcclxuICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG9ic2VydmVyLm9uTmV4dChyZXN1bHQpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvYnNlcnZlci5vbkVycm9yLmJpbmQob2JzZXJ2ZXIpLFxyXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHJpZ2h0RG9uZSA9IHRydWU7XHJcbiAgICAgICAgICAobGVmdERvbmUgfHwgcmlnaHRNYXAuY291bnQoKSA9PT0gMCkgJiYgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgICB9KVxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gZ3JvdXA7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiAgQ29ycmVsYXRlcyB0aGUgZWxlbWVudHMgb2YgdHdvIHNlcXVlbmNlcyBiYXNlZCBvbiBvdmVybGFwcGluZyBkdXJhdGlvbnMsIGFuZCBncm91cHMgdGhlIHJlc3VsdHMuXHJcbiAgICpcclxuICAgKiAgQHBhcmFtIHtPYnNlcnZhYmxlfSByaWdodCBUaGUgcmlnaHQgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0byBqb2luIGVsZW1lbnRzIGZvci5cclxuICAgKiAgQHBhcmFtIHtGdW5jdGlvbn0gbGVmdER1cmF0aW9uU2VsZWN0b3IgQSBmdW5jdGlvbiB0byBzZWxlY3QgdGhlIGR1cmF0aW9uIChleHByZXNzZWQgYXMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSkgb2YgZWFjaCBlbGVtZW50IG9mIHRoZSBsZWZ0IG9ic2VydmFibGUgc2VxdWVuY2UsIHVzZWQgdG8gZGV0ZXJtaW5lIG92ZXJsYXAuXHJcbiAgICogIEBwYXJhbSB7RnVuY3Rpb259IHJpZ2h0RHVyYXRpb25TZWxlY3RvciBBIGZ1bmN0aW9uIHRvIHNlbGVjdCB0aGUgZHVyYXRpb24gKGV4cHJlc3NlZCBhcyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlKSBvZiBlYWNoIGVsZW1lbnQgb2YgdGhlIHJpZ2h0IG9ic2VydmFibGUgc2VxdWVuY2UsIHVzZWQgdG8gZGV0ZXJtaW5lIG92ZXJsYXAuXHJcbiAgICogIEBwYXJhbSB7RnVuY3Rpb259IHJlc3VsdFNlbGVjdG9yIEEgZnVuY3Rpb24gaW52b2tlZCB0byBjb21wdXRlIGEgcmVzdWx0IGVsZW1lbnQgZm9yIGFueSBlbGVtZW50IG9mIHRoZSBsZWZ0IHNlcXVlbmNlIHdpdGggb3ZlcmxhcHBpbmcgZWxlbWVudHMgZnJvbSB0aGUgcmlnaHQgb2JzZXJ2YWJsZSBzZXF1ZW5jZS4gVGhlIGZpcnN0IHBhcmFtZXRlciBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uIGlzIGFuIGVsZW1lbnQgb2YgdGhlIGxlZnQgc2VxdWVuY2UuIFRoZSBzZWNvbmQgcGFyYW1ldGVyIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24gaXMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIGVsZW1lbnRzIGZyb20gdGhlIHJpZ2h0IHNlcXVlbmNlIHRoYXQgb3ZlcmxhcCB3aXRoIHRoZSBsZWZ0IHNlcXVlbmNlJ3MgZWxlbWVudC5cclxuICAgKiAgQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyByZXN1bHQgZWxlbWVudHMgY29tcHV0ZWQgZnJvbSBzb3VyY2UgZWxlbWVudHMgdGhhdCBoYXZlIGFuIG92ZXJsYXBwaW5nIGR1cmF0aW9uLlxyXG4gICAqL1xyXG4gIG9ic2VydmFibGVQcm90by5ncm91cEpvaW4gPSBmdW5jdGlvbiAocmlnaHQsIGxlZnREdXJhdGlvblNlbGVjdG9yLCByaWdodER1cmF0aW9uU2VsZWN0b3IsIHJlc3VsdFNlbGVjdG9yKSB7XHJcbiAgICB2YXIgbGVmdCA9IHRoaXM7XHJcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgIHZhciBncm91cCA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCk7XHJcbiAgICAgIHZhciByID0gbmV3IFJlZkNvdW50RGlzcG9zYWJsZShncm91cCk7XHJcbiAgICAgIHZhciBsZWZ0TWFwID0gbmV3IERpY3Rpb25hcnkoKSwgcmlnaHRNYXAgPSBuZXcgRGljdGlvbmFyeSgpO1xyXG4gICAgICB2YXIgbGVmdElkID0gMCwgcmlnaHRJZCA9IDA7XHJcblxyXG4gICAgICBmdW5jdGlvbiBoYW5kbGVFcnJvcihlKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyB2Lm9uRXJyb3IoZSk7IH07IH07XHJcblxyXG4gICAgICBncm91cC5hZGQobGVmdC5zdWJzY3JpYmUoXHJcbiAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICB2YXIgcyA9IG5ldyBTdWJqZWN0KCk7XHJcbiAgICAgICAgICB2YXIgaWQgPSBsZWZ0SWQrKztcclxuICAgICAgICAgIGxlZnRNYXAuYWRkKGlkLCBzKTtcclxuXHJcbiAgICAgICAgICB2YXIgcmVzdWx0O1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0U2VsZWN0b3IodmFsdWUsIGFkZFJlZihzLCByKSk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGxlZnRNYXAuZ2V0VmFsdWVzKCkuZm9yRWFjaChoYW5kbGVFcnJvcihlKSk7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIG9ic2VydmVyLm9uTmV4dChyZXN1bHQpO1xyXG5cclxuICAgICAgICAgIHJpZ2h0TWFwLmdldFZhbHVlcygpLmZvckVhY2goZnVuY3Rpb24gKHYpIHsgcy5vbk5leHQodik7IH0pO1xyXG5cclxuICAgICAgICAgIHZhciBtZCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xyXG4gICAgICAgICAgZ3JvdXAuYWRkKG1kKTtcclxuXHJcbiAgICAgICAgICB2YXIgZXhwaXJlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBsZWZ0TWFwLnJlbW92ZShpZCkgJiYgcy5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgICAgICBncm91cC5yZW1vdmUobWQpO1xyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICB2YXIgZHVyYXRpb247XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBkdXJhdGlvbiA9IGxlZnREdXJhdGlvblNlbGVjdG9yKHZhbHVlKTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgbGVmdE1hcC5nZXRWYWx1ZXMoKS5mb3JFYWNoKGhhbmRsZUVycm9yKGUpKTtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIG1kLnNldERpc3Bvc2FibGUoZHVyYXRpb24udGFrZSgxKS5zdWJzY3JpYmUoXHJcbiAgICAgICAgICAgIG5vb3AsXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgbGVmdE1hcC5nZXRWYWx1ZXMoKS5mb3JFYWNoKGhhbmRsZUVycm9yKGUpKTtcclxuICAgICAgICAgICAgICBvYnNlcnZlci5vbkVycm9yKGUpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBleHBpcmUpXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgIGxlZnRNYXAuZ2V0VmFsdWVzKCkuZm9yRWFjaChoYW5kbGVFcnJvcihlKSk7XHJcbiAgICAgICAgICBvYnNlcnZlci5vbkVycm9yKGUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQuYmluZChvYnNlcnZlcikpXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBncm91cC5hZGQocmlnaHQuc3Vic2NyaWJlKFxyXG4gICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgdmFyIGlkID0gcmlnaHRJZCsrO1xyXG4gICAgICAgICAgcmlnaHRNYXAuYWRkKGlkLCB2YWx1ZSk7XHJcblxyXG4gICAgICAgICAgdmFyIG1kID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XHJcbiAgICAgICAgICBncm91cC5hZGQobWQpO1xyXG5cclxuICAgICAgICAgIHZhciBleHBpcmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJpZ2h0TWFwLnJlbW92ZShpZCk7XHJcbiAgICAgICAgICAgIGdyb3VwLnJlbW92ZShtZCk7XHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIHZhciBkdXJhdGlvbjtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGR1cmF0aW9uID0gcmlnaHREdXJhdGlvblNlbGVjdG9yKHZhbHVlKTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgbGVmdE1hcC5nZXRWYWx1ZXMoKS5mb3JFYWNoKGhhbmRsZUVycm9yKGUpKTtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbWQuc2V0RGlzcG9zYWJsZShkdXJhdGlvbi50YWtlKDEpLnN1YnNjcmliZShcclxuICAgICAgICAgICAgbm9vcCxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICBsZWZ0TWFwLmdldFZhbHVlcygpLmZvckVhY2goaGFuZGxlRXJyb3IoZSkpO1xyXG4gICAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGV4cGlyZSlcclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgbGVmdE1hcC5nZXRWYWx1ZXMoKS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7IHYub25OZXh0KHZhbHVlKTsgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgbGVmdE1hcC5nZXRWYWx1ZXMoKS5mb3JFYWNoKGhhbmRsZUVycm9yKGUpKTtcclxuICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgKTtcclxuXHJcbiAgICAgIHJldHVybiByO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqICBQcm9qZWN0cyBlYWNoIGVsZW1lbnQgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBpbnRvIHplcm8gb3IgbW9yZSBidWZmZXJzLlxyXG4gICAgICpcclxuICAgICAqICBAcGFyYW0ge01peGVkfSBidWZmZXJPcGVuaW5nc09yQ2xvc2luZ1NlbGVjdG9yIE9ic2VydmFibGUgc2VxdWVuY2Ugd2hvc2UgZWxlbWVudHMgZGVub3RlIHRoZSBjcmVhdGlvbiBvZiBuZXcgd2luZG93cywgb3IsIGEgZnVuY3Rpb24gaW52b2tlZCB0byBkZWZpbmUgdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHByb2R1Y2VkIHdpbmRvd3MgKGEgbmV3IHdpbmRvdyBpcyBzdGFydGVkIHdoZW4gdGhlIHByZXZpb3VzIG9uZSBpcyBjbG9zZWQsIHJlc3VsdGluZyBpbiBub24tb3ZlcmxhcHBpbmcgd2luZG93cykuXHJcbiAgICAgKiAgQHBhcmFtIHtGdW5jdGlvbn0gW2J1ZmZlckNsb3NpbmdTZWxlY3Rvcl0gQSBmdW5jdGlvbiBpbnZva2VkIHRvIGRlZmluZSB0aGUgY2xvc2luZyBvZiBlYWNoIHByb2R1Y2VkIHdpbmRvdy4gSWYgYSBjbG9zaW5nIHNlbGVjdG9yIGZ1bmN0aW9uIGlzIHNwZWNpZmllZCBmb3IgdGhlIGZpcnN0IHBhcmFtZXRlciwgdGhpcyBwYXJhbWV0ZXIgaXMgaWdub3JlZC5cclxuICAgICAqICBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvZiB3aW5kb3dzLlxyXG4gICAgICovXHJcbiAgICBvYnNlcnZhYmxlUHJvdG8uYnVmZmVyID0gZnVuY3Rpb24gKGJ1ZmZlck9wZW5pbmdzT3JDbG9zaW5nU2VsZWN0b3IsIGJ1ZmZlckNsb3NpbmdTZWxlY3Rvcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLndpbmRvdy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLnNlbGVjdE1hbnkoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgudG9BcnJheSgpOyB9KTtcclxuICAgIH07XHJcblxyXG4gIC8qKlxyXG4gICAqICBQcm9qZWN0cyBlYWNoIGVsZW1lbnQgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBpbnRvIHplcm8gb3IgbW9yZSB3aW5kb3dzLlxyXG4gICAqXHJcbiAgICogIEBwYXJhbSB7TWl4ZWR9IHdpbmRvd09wZW5pbmdzT3JDbG9zaW5nU2VsZWN0b3IgT2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aG9zZSBlbGVtZW50cyBkZW5vdGUgdGhlIGNyZWF0aW9uIG9mIG5ldyB3aW5kb3dzLCBvciwgYSBmdW5jdGlvbiBpbnZva2VkIHRvIGRlZmluZSB0aGUgYm91bmRhcmllcyBvZiB0aGUgcHJvZHVjZWQgd2luZG93cyAoYSBuZXcgd2luZG93IGlzIHN0YXJ0ZWQgd2hlbiB0aGUgcHJldmlvdXMgb25lIGlzIGNsb3NlZCwgcmVzdWx0aW5nIGluIG5vbi1vdmVybGFwcGluZyB3aW5kb3dzKS5cclxuICAgKiAgQHBhcmFtIHtGdW5jdGlvbn0gW3dpbmRvd0Nsb3NpbmdTZWxlY3Rvcl0gQSBmdW5jdGlvbiBpbnZva2VkIHRvIGRlZmluZSB0aGUgY2xvc2luZyBvZiBlYWNoIHByb2R1Y2VkIHdpbmRvdy4gSWYgYSBjbG9zaW5nIHNlbGVjdG9yIGZ1bmN0aW9uIGlzIHNwZWNpZmllZCBmb3IgdGhlIGZpcnN0IHBhcmFtZXRlciwgdGhpcyBwYXJhbWV0ZXIgaXMgaWdub3JlZC5cclxuICAgKiAgQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugb2Ygd2luZG93cy5cclxuICAgKi9cclxuICBvYnNlcnZhYmxlUHJvdG8ud2luZG93ID0gZnVuY3Rpb24gKHdpbmRvd09wZW5pbmdzT3JDbG9zaW5nU2VsZWN0b3IsIHdpbmRvd0Nsb3NpbmdTZWxlY3Rvcikge1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGFyZ3VtZW50c1swXSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICByZXR1cm4gb2JzZXJ2YWJsZVdpbmRvd1dpdGhCb3VuYXJpZXMuY2FsbCh0aGlzLCB3aW5kb3dPcGVuaW5nc09yQ2xvc2luZ1NlbGVjdG9yKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0eXBlb2Ygd2luZG93T3BlbmluZ3NPckNsb3NpbmdTZWxlY3RvciA9PT0gJ2Z1bmN0aW9uJyA/XHJcbiAgICAgIG9ic2VydmFibGVXaW5kb3dXaXRoQ2xvc2luZ1NlbGVjdG9yLmNhbGwodGhpcywgd2luZG93T3BlbmluZ3NPckNsb3NpbmdTZWxlY3RvcikgOlxyXG4gICAgICBvYnNlcnZhYmxlV2luZG93V2l0aE9wZW5pbmdzLmNhbGwodGhpcywgd2luZG93T3BlbmluZ3NPckNsb3NpbmdTZWxlY3Rvciwgd2luZG93Q2xvc2luZ1NlbGVjdG9yKTtcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBvYnNlcnZhYmxlV2luZG93V2l0aE9wZW5pbmdzKHdpbmRvd09wZW5pbmdzLCB3aW5kb3dDbG9zaW5nU2VsZWN0b3IpIHtcclxuICAgIHJldHVybiB3aW5kb3dPcGVuaW5ncy5ncm91cEpvaW4odGhpcywgd2luZG93Q2xvc2luZ1NlbGVjdG9yLCBvYnNlcnZhYmxlRW1wdHksIGZ1bmN0aW9uIChfLCB3aW4pIHtcclxuICAgICAgcmV0dXJuIHdpbjtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gb2JzZXJ2YWJsZVdpbmRvd1dpdGhCb3VuYXJpZXMod2luZG93Qm91bmRhcmllcykge1xyXG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XHJcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgIHZhciB3aW4gPSBuZXcgU3ViamVjdCgpLFxyXG4gICAgICAgIGQgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpLFxyXG4gICAgICAgIHIgPSBuZXcgUmVmQ291bnREaXNwb3NhYmxlKGQpO1xyXG5cclxuICAgICAgb2JzZXJ2ZXIub25OZXh0KGFkZFJlZih3aW4sIHIpKTtcclxuXHJcbiAgICAgIGQuYWRkKHNvdXJjZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICB3aW4ub25OZXh0KHgpO1xyXG4gICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgd2luLm9uRXJyb3IoZXJyKTtcclxuICAgICAgICBvYnNlcnZlci5vbkVycm9yKGVycik7XHJcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB3aW4ub25Db21wbGV0ZWQoKTtcclxuICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICB9KSk7XHJcblxyXG4gICAgICBpc1Byb21pc2Uod2luZG93Qm91bmRhcmllcykgJiYgKHdpbmRvd0JvdW5kYXJpZXMgPSBvYnNlcnZhYmxlRnJvbVByb21pc2Uod2luZG93Qm91bmRhcmllcykpO1xyXG5cclxuICAgICAgZC5hZGQod2luZG93Qm91bmRhcmllcy5zdWJzY3JpYmUoZnVuY3Rpb24gKHcpIHtcclxuICAgICAgICB3aW4ub25Db21wbGV0ZWQoKTtcclxuICAgICAgICB3aW4gPSBuZXcgU3ViamVjdCgpO1xyXG4gICAgICAgIG9ic2VydmVyLm9uTmV4dChhZGRSZWYod2luLCByKSk7XHJcbiAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICB3aW4ub25FcnJvcihlcnIpO1xyXG4gICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZXJyKTtcclxuICAgICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHdpbi5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgIH0pKTtcclxuXHJcbiAgICAgIHJldHVybiByO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBvYnNlcnZhYmxlV2luZG93V2l0aENsb3NpbmdTZWxlY3Rvcih3aW5kb3dDbG9zaW5nU2VsZWN0b3IpIHtcclxuICAgIHZhciBzb3VyY2UgPSB0aGlzO1xyXG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICB2YXIgbSA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCksXHJcbiAgICAgICAgZCA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKG0pLFxyXG4gICAgICAgIHIgPSBuZXcgUmVmQ291bnREaXNwb3NhYmxlKGQpLFxyXG4gICAgICAgIHdpbiA9IG5ldyBTdWJqZWN0KCk7XHJcbiAgICAgIG9ic2VydmVyLm9uTmV4dChhZGRSZWYod2luLCByKSk7XHJcbiAgICAgIGQuYWRkKHNvdXJjZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgIHdpbi5vbk5leHQoeCk7XHJcbiAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgIHdpbi5vbkVycm9yKGVycik7XHJcbiAgICAgICAgICBvYnNlcnZlci5vbkVycm9yKGVycik7XHJcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHdpbi5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgfSkpO1xyXG4gICAgICBcclxuICAgICAgZnVuY3Rpb24gY3JlYXRlV2luZG93Q2xvc2UgKCkge1xyXG4gICAgICAgIHZhciB3aW5kb3dDbG9zZTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgd2luZG93Q2xvc2UgPSB3aW5kb3dDbG9zaW5nU2VsZWN0b3IoKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICBvYnNlcnZlci5vbkVycm9yKGUpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaXNQcm9taXNlKHdpbmRvd0Nsb3NlKSAmJiAod2luZG93Q2xvc2UgPSBvYnNlcnZhYmxlRnJvbVByb21pc2Uod2luZG93Q2xvc2UpKTtcclxuXHJcbiAgICAgICAgdmFyIG0xID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XHJcbiAgICAgICAgbS5zZXREaXNwb3NhYmxlKG0xKTtcclxuICAgICAgICBtMS5zZXREaXNwb3NhYmxlKHdpbmRvd0Nsb3NlLnRha2UoMSkuc3Vic2NyaWJlKG5vb3AsIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgIHdpbi5vbkVycm9yKGVycik7XHJcbiAgICAgICAgICBvYnNlcnZlci5vbkVycm9yKGVycik7XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgd2luLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgICAgICB3aW4gPSBuZXcgU3ViamVjdCgpO1xyXG4gICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KGFkZFJlZih3aW4sIHIpKTtcclxuICAgICAgICAgIGNyZWF0ZVdpbmRvd0Nsb3NlKCk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjcmVhdGVXaW5kb3dDbG9zZSgpO1xyXG4gICAgICByZXR1cm4gcjtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIG5ldyBvYnNlcnZhYmxlIHRoYXQgdHJpZ2dlcnMgb24gdGhlIHNlY29uZCBhbmQgc3Vic2VxdWVudCB0cmlnZ2VyaW5ncyBvZiB0aGUgaW5wdXQgb2JzZXJ2YWJsZS5cclxuICAgKiBUaGUgTnRoIHRyaWdnZXJpbmcgb2YgdGhlIGlucHV0IG9ic2VydmFibGUgcGFzc2VzIHRoZSBhcmd1bWVudHMgZnJvbSB0aGUgTi0xdGggYW5kIE50aCB0cmlnZ2VyaW5nIGFzIGEgcGFpci5cclxuICAgKiBUaGUgYXJndW1lbnQgcGFzc2VkIHRvIHRoZSBOLTF0aCB0cmlnZ2VyaW5nIGlzIGhlbGQgaW4gaGlkZGVuIGludGVybmFsIHN0YXRlIHVudGlsIHRoZSBOdGggdHJpZ2dlcmluZyBvY2N1cnMuXHJcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgdGhhdCB0cmlnZ2VycyBvbiBzdWNjZXNzaXZlIHBhaXJzIG9mIG9ic2VydmF0aW9ucyBmcm9tIHRoZSBpbnB1dCBvYnNlcnZhYmxlIGFzIGFuIGFycmF5LlxyXG4gICAqL1xyXG4gIG9ic2VydmFibGVQcm90by5wYWlyd2lzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBzb3VyY2UgPSB0aGlzO1xyXG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICB2YXIgcHJldmlvdXMsIGhhc1ByZXZpb3VzID0gZmFsc2U7XHJcbiAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKFxyXG4gICAgICAgIGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICBpZiAoaGFzUHJldmlvdXMpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KFtwcmV2aW91cywgeF0pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaGFzUHJldmlvdXMgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcHJldmlvdXMgPSB4O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb2JzZXJ2ZXIub25FcnJvci5iaW5kKG9ic2VydmVyKSxcclxuICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZC5iaW5kKG9ic2VydmVyKSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHR3byBvYnNlcnZhYmxlcyB3aGljaCBwYXJ0aXRpb24gdGhlIG9ic2VydmF0aW9ucyBvZiB0aGUgc291cmNlIGJ5IHRoZSBnaXZlbiBmdW5jdGlvbi5cclxuICAgKiBUaGUgZmlyc3Qgd2lsbCB0cmlnZ2VyIG9ic2VydmF0aW9ucyBmb3IgdGhvc2UgdmFsdWVzIGZvciB3aGljaCB0aGUgcHJlZGljYXRlIHJldHVybnMgdHJ1ZS5cclxuICAgKiBUaGUgc2Vjb25kIHdpbGwgdHJpZ2dlciBvYnNlcnZhdGlvbnMgZm9yIHRob3NlIHZhbHVlcyB3aGVyZSB0aGUgcHJlZGljYXRlIHJldHVybnMgZmFsc2UuXHJcbiAgICogVGhlIHByZWRpY2F0ZSBpcyBleGVjdXRlZCBvbmNlIGZvciBlYWNoIHN1YnNjcmliZWQgb2JzZXJ2ZXIuXHJcbiAgICogQm90aCBhbHNvIHByb3BhZ2F0ZSBhbGwgZXJyb3Igb2JzZXJ2YXRpb25zIGFyaXNpbmcgZnJvbSB0aGUgc291cmNlIGFuZCBlYWNoIGNvbXBsZXRlc1xyXG4gICAqIHdoZW4gdGhlIHNvdXJjZSBjb21wbGV0ZXMuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlXHJcbiAgICogICAgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSB3aGljaCBvdXRwdXQgT2JzZXJ2YWJsZSB3aWxsIHRyaWdnZXIgYSBwYXJ0aWN1bGFyIG9ic2VydmF0aW9uLlxyXG4gICAqIEByZXR1cm5zIHtBcnJheX1cclxuICAgKiAgICBBbiBhcnJheSBvZiBvYnNlcnZhYmxlcy4gVGhlIGZpcnN0IHRyaWdnZXJzIHdoZW4gdGhlIHByZWRpY2F0ZSByZXR1cm5zIHRydWUsXHJcbiAgICogICAgYW5kIHRoZSBzZWNvbmQgdHJpZ2dlcnMgd2hlbiB0aGUgcHJlZGljYXRlIHJldHVybnMgZmFsc2UuXHJcbiAgKi9cclxuICBvYnNlcnZhYmxlUHJvdG8ucGFydGl0aW9uID0gZnVuY3Rpb24ocHJlZGljYXRlLCB0aGlzQXJnKSB7XHJcbiAgICB2YXIgcHVibGlzaGVkID0gdGhpcy5wdWJsaXNoKCkucmVmQ291bnQoKTtcclxuICAgIHJldHVybiBbXHJcbiAgICAgIHB1Ymxpc2hlZC5maWx0ZXIocHJlZGljYXRlLCB0aGlzQXJnKSxcclxuICAgICAgcHVibGlzaGVkLmZpbHRlcihmdW5jdGlvbiAoeCwgaSwgbykgeyByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXNBcmcsIHgsIGksIG8pOyB9KVxyXG4gICAgXTtcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBlbnVtZXJhYmxlV2hpbGUoY29uZGl0aW9uLCBzb3VyY2UpIHtcclxuICAgIHJldHVybiBuZXcgRW51bWVyYWJsZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBuZXcgRW51bWVyYXRvcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbmRpdGlvbigpID9cclxuICAgICAgICAgIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBzb3VyY2UgfSA6XHJcbiAgICAgICAgICB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGlzIHRoZSByZXN1bHQgb2YgaW52b2tpbmcgdGhlIHNlbGVjdG9yIG9uIHRoZSBzb3VyY2Ugc2VxdWVuY2UsIHdpdGhvdXQgc2hhcmluZyBzdWJzY3JpcHRpb25zLlxyXG4gICAgICogIFRoaXMgb3BlcmF0b3IgYWxsb3dzIGZvciBhIGZsdWVudCBzdHlsZSBvZiB3cml0aW5nIHF1ZXJpZXMgdGhhdCB1c2UgdGhlIHNhbWUgc2VxdWVuY2UgbXVsdGlwbGUgdGltZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2VsZWN0b3IgU2VsZWN0b3IgZnVuY3Rpb24gd2hpY2ggY2FuIHVzZSB0aGUgc291cmNlIHNlcXVlbmNlIGFzIG1hbnkgdGltZXMgYXMgbmVlZGVkLCB3aXRob3V0IHNoYXJpbmcgc3Vic2NyaXB0aW9ucyB0byB0aGUgc291cmNlIHNlcXVlbmNlLlxyXG4gICAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyB0aGUgZWxlbWVudHMgb2YgYSBzZXF1ZW5jZSBwcm9kdWNlZCBieSBtdWx0aWNhc3RpbmcgdGhlIHNvdXJjZSBzZXF1ZW5jZSB3aXRoaW4gYSBzZWxlY3RvciBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgb2JzZXJ2YWJsZVByb3RvLmxldEJpbmQgPSBvYnNlcnZhYmxlUHJvdG9bJ2xldCddID0gZnVuY3Rpb24gKGZ1bmMpIHtcclxuICAgICAgICByZXR1cm4gZnVuYyh0aGlzKTtcclxuICAgIH07XHJcblxyXG4gICAvKipcclxuICAgKiAgRGV0ZXJtaW5lcyB3aGV0aGVyIGFuIG9ic2VydmFibGUgY29sbGVjdGlvbiBjb250YWlucyB2YWx1ZXMuIFRoZXJlIGlzIGFuIGFsaWFzIGZvciB0aGlzIG1ldGhvZCBjYWxsZWQgJ2lmVGhlbicgZm9yIGJyb3dzZXJzIDxJRTlcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogIDEgLSByZXMgPSBSeC5PYnNlcnZhYmxlLmlmKGNvbmRpdGlvbiwgb2JzMSk7XHJcbiAgICogIDIgLSByZXMgPSBSeC5PYnNlcnZhYmxlLmlmKGNvbmRpdGlvbiwgb2JzMSwgb2JzMik7XHJcbiAgICogIDMgLSByZXMgPSBSeC5PYnNlcnZhYmxlLmlmKGNvbmRpdGlvbiwgb2JzMSwgc2NoZWR1bGVyKTtcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25kaXRpb24gVGhlIGNvbmRpdGlvbiB3aGljaCBkZXRlcm1pbmVzIGlmIHRoZSB0aGVuU291cmNlIG9yIGVsc2VTb3VyY2Ugd2lsbCBiZSBydW4uXHJcbiAgICogQHBhcmFtIHtPYnNlcnZhYmxlfSB0aGVuU291cmNlIFRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIG9yIFByb21pc2UgdGhhdCB3aWxsIGJlIHJ1biBpZiB0aGUgY29uZGl0aW9uIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZS5cclxuICAgKiBAcGFyYW0ge09ic2VydmFibGV9IFtlbHNlU291cmNlXSBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvciBQcm9taXNlIHRoYXQgd2lsbCBiZSBydW4gaWYgdGhlIGNvbmRpdGlvbiBmdW5jdGlvbiByZXR1cm5zIGZhbHNlLiBJZiB0aGlzIGlzIG5vdCBwcm92aWRlZCwgaXQgZGVmYXVsdHMgdG8gUnguT2JzZXJ2YWJlLkVtcHR5IHdpdGggdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIuXHJcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hpY2ggaXMgZWl0aGVyIHRoZSB0aGVuU291cmNlIG9yIGVsc2VTb3VyY2UuXHJcbiAgICovXHJcbiAgT2JzZXJ2YWJsZVsnaWYnXSA9IE9ic2VydmFibGUuaWZUaGVuID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgdGhlblNvdXJjZSwgZWxzZVNvdXJjZU9yU2NoZWR1bGVyKSB7XHJcbiAgICByZXR1cm4gb2JzZXJ2YWJsZURlZmVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgZWxzZVNvdXJjZU9yU2NoZWR1bGVyIHx8IChlbHNlU291cmNlT3JTY2hlZHVsZXIgPSBvYnNlcnZhYmxlRW1wdHkoKSk7XHJcblxyXG4gICAgICBpc1Byb21pc2UodGhlblNvdXJjZSkgJiYgKHRoZW5Tb3VyY2UgPSBvYnNlcnZhYmxlRnJvbVByb21pc2UodGhlblNvdXJjZSkpO1xyXG4gICAgICBpc1Byb21pc2UoZWxzZVNvdXJjZU9yU2NoZWR1bGVyKSAmJiAoZWxzZVNvdXJjZU9yU2NoZWR1bGVyID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKGVsc2VTb3VyY2VPclNjaGVkdWxlcikpO1xyXG5cclxuICAgICAgLy8gQXNzdW1lIGEgc2NoZWR1bGVyIGZvciBlbXB0eSBvbmx5XHJcbiAgICAgIHR5cGVvZiBlbHNlU291cmNlT3JTY2hlZHVsZXIubm93ID09PSAnZnVuY3Rpb24nICYmIChlbHNlU291cmNlT3JTY2hlZHVsZXIgPSBvYnNlcnZhYmxlRW1wdHkoZWxzZVNvdXJjZU9yU2NoZWR1bGVyKSk7XHJcbiAgICAgIHJldHVybiBjb25kaXRpb24oKSA/IHRoZW5Tb3VyY2UgOiBlbHNlU291cmNlT3JTY2hlZHVsZXI7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAgLyoqXHJcbiAgICogIENvbmNhdGVuYXRlcyB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgb2J0YWluZWQgYnkgcnVubmluZyB0aGUgc3BlY2lmaWVkIHJlc3VsdCBzZWxlY3RvciBmb3IgZWFjaCBlbGVtZW50IGluIHNvdXJjZS5cclxuICAgKiBUaGVyZSBpcyBhbiBhbGlhcyBmb3IgdGhpcyBtZXRob2QgY2FsbGVkICdmb3JJbicgZm9yIGJyb3dzZXJzIDxJRTlcclxuICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2VzIEFuIGFycmF5IG9mIHZhbHVlcyB0byB0dXJuIGludG8gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXN1bHRTZWxlY3RvciBBIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbiB0aGUgc291cmNlcyBhcnJheSB0byB0dXJuIGl0IGludG8gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cclxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBmcm9tIHRoZSBjb25jYXRlbmF0ZWQgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMuXHJcbiAgICovXHJcbiAgT2JzZXJ2YWJsZVsnZm9yJ10gPSBPYnNlcnZhYmxlLmZvckluID0gZnVuY3Rpb24gKHNvdXJjZXMsIHJlc3VsdFNlbGVjdG9yLCB0aGlzQXJnKSB7XHJcbiAgICByZXR1cm4gZW51bWVyYWJsZU9mKHNvdXJjZXMsIHJlc3VsdFNlbGVjdG9yLCB0aGlzQXJnKS5jb25jYXQoKTtcclxuICB9O1xyXG5cclxuICAgLyoqXHJcbiAgICogIFJlcGVhdHMgc291cmNlIGFzIGxvbmcgYXMgY29uZGl0aW9uIGhvbGRzIGVtdWxhdGluZyBhIHdoaWxlIGxvb3AuXHJcbiAgICogVGhlcmUgaXMgYW4gYWxpYXMgZm9yIHRoaXMgbWV0aG9kIGNhbGxlZCAnd2hpbGVEbycgZm9yIGJyb3dzZXJzIDxJRTlcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbmRpdGlvbiBUaGUgY29uZGl0aW9uIHdoaWNoIGRldGVybWluZXMgaWYgdGhlIHNvdXJjZSB3aWxsIGJlIHJlcGVhdGVkLlxyXG4gICAqIEBwYXJhbSB7T2JzZXJ2YWJsZX0gc291cmNlIFRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgd2lsbCBiZSBydW4gaWYgdGhlIGNvbmRpdGlvbiBmdW5jdGlvbiByZXR1cm5zIHRydWUuXHJcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hpY2ggaXMgcmVwZWF0ZWQgYXMgbG9uZyBhcyB0aGUgY29uZGl0aW9uIGhvbGRzLlxyXG4gICAqL1xyXG4gIHZhciBvYnNlcnZhYmxlV2hpbGVEbyA9IE9ic2VydmFibGVbJ3doaWxlJ10gPSBPYnNlcnZhYmxlLndoaWxlRG8gPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBzb3VyY2UpIHtcclxuICAgIGlzUHJvbWlzZShzb3VyY2UpICYmIChzb3VyY2UgPSBvYnNlcnZhYmxlRnJvbVByb21pc2Uoc291cmNlKSk7XHJcbiAgICByZXR1cm4gZW51bWVyYWJsZVdoaWxlKGNvbmRpdGlvbiwgc291cmNlKS5jb25jYXQoKTtcclxuICB9O1xyXG5cclxuICAgICAvKipcclxuICAgICAqICBSZXBlYXRzIHNvdXJjZSBhcyBsb25nIGFzIGNvbmRpdGlvbiBob2xkcyBlbXVsYXRpbmcgYSBkbyB3aGlsZSBsb29wLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbmRpdGlvbiBUaGUgY29uZGl0aW9uIHdoaWNoIGRldGVybWluZXMgaWYgdGhlIHNvdXJjZSB3aWxsIGJlIHJlcGVhdGVkLlxyXG4gICAgICogQHBhcmFtIHtPYnNlcnZhYmxlfSBzb3VyY2UgVGhlIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCB3aWxsIGJlIHJ1biBpZiB0aGUgY29uZGl0aW9uIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZS5cclxuICAgICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdoaWNoIGlzIHJlcGVhdGVkIGFzIGxvbmcgYXMgdGhlIGNvbmRpdGlvbiBob2xkcy5cclxuICAgICAqL1xyXG4gICAgb2JzZXJ2YWJsZVByb3RvLmRvV2hpbGUgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGVDb25jYXQoW3RoaXMsIG9ic2VydmFibGVXaGlsZURvKGNvbmRpdGlvbiwgdGhpcyldKTtcclxuICAgIH07XHJcblxyXG4gICAvKipcclxuICAgKiAgVXNlcyBzZWxlY3RvciB0byBkZXRlcm1pbmUgd2hpY2ggc291cmNlIGluIHNvdXJjZXMgdG8gdXNlLlxyXG4gICAqICBUaGVyZSBpcyBhbiBhbGlhcyAnc3dpdGNoQ2FzZScgZm9yIGJyb3dzZXJzIDxJRTkuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqICAxIC0gcmVzID0gUnguT2JzZXJ2YWJsZS5jYXNlKHNlbGVjdG9yLCB7ICcxJzogb2JzMSwgJzInOiBvYnMyIH0pO1xyXG4gICAqICAxIC0gcmVzID0gUnguT2JzZXJ2YWJsZS5jYXNlKHNlbGVjdG9yLCB7ICcxJzogb2JzMSwgJzInOiBvYnMyIH0sIG9iczApO1xyXG4gICAqICAxIC0gcmVzID0gUnguT2JzZXJ2YWJsZS5jYXNlKHNlbGVjdG9yLCB7ICcxJzogb2JzMSwgJzInOiBvYnMyIH0sIHNjaGVkdWxlcik7XHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZWxlY3RvciBUaGUgZnVuY3Rpb24gd2hpY2ggZXh0cmFjdHMgdGhlIHZhbHVlIGZvciB0byB0ZXN0IGluIGEgY2FzZSBzdGF0ZW1lbnQuXHJcbiAgICogQHBhcmFtIHtBcnJheX0gc291cmNlcyBBIG9iamVjdCB3aGljaCBoYXMga2V5cyB3aGljaCBjb3JyZXNwb25kIHRvIHRoZSBjYXNlIHN0YXRlbWVudCBsYWJlbHMuXHJcbiAgICogQHBhcmFtIHtPYnNlcnZhYmxlfSBbZWxzZVNvdXJjZV0gVGhlIG9ic2VydmFibGUgc2VxdWVuY2Ugb3IgUHJvbWlzZSB0aGF0IHdpbGwgYmUgcnVuIGlmIHRoZSBzb3VyY2VzIGFyZSBub3QgbWF0Y2hlZC4gSWYgdGhpcyBpcyBub3QgcHJvdmlkZWQsIGl0IGRlZmF1bHRzIHRvIFJ4Lk9ic2VydmFiZS5lbXB0eSB3aXRoIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVyLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hpY2ggaXMgZGV0ZXJtaW5lZCBieSBhIGNhc2Ugc3RhdGVtZW50LlxyXG4gICAqL1xyXG4gIE9ic2VydmFibGVbJ2Nhc2UnXSA9IE9ic2VydmFibGUuc3dpdGNoQ2FzZSA9IGZ1bmN0aW9uIChzZWxlY3Rvciwgc291cmNlcywgZGVmYXVsdFNvdXJjZU9yU2NoZWR1bGVyKSB7XHJcbiAgICByZXR1cm4gb2JzZXJ2YWJsZURlZmVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgaXNQcm9taXNlKGRlZmF1bHRTb3VyY2VPclNjaGVkdWxlcikgJiYgKGRlZmF1bHRTb3VyY2VPclNjaGVkdWxlciA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShkZWZhdWx0U291cmNlT3JTY2hlZHVsZXIpKTtcclxuICAgICAgZGVmYXVsdFNvdXJjZU9yU2NoZWR1bGVyIHx8IChkZWZhdWx0U291cmNlT3JTY2hlZHVsZXIgPSBvYnNlcnZhYmxlRW1wdHkoKSk7XHJcblxyXG4gICAgICB0eXBlb2YgZGVmYXVsdFNvdXJjZU9yU2NoZWR1bGVyLm5vdyA9PT0gJ2Z1bmN0aW9uJyAmJiAoZGVmYXVsdFNvdXJjZU9yU2NoZWR1bGVyID0gb2JzZXJ2YWJsZUVtcHR5KGRlZmF1bHRTb3VyY2VPclNjaGVkdWxlcikpO1xyXG5cclxuICAgICAgdmFyIHJlc3VsdCA9IHNvdXJjZXNbc2VsZWN0b3IoKV07XHJcbiAgICAgIGlzUHJvbWlzZShyZXN1bHQpICYmIChyZXN1bHQgPSBvYnNlcnZhYmxlRnJvbVByb21pc2UocmVzdWx0KSk7XHJcblxyXG4gICAgICByZXR1cm4gcmVzdWx0IHx8IGRlZmF1bHRTb3VyY2VPclNjaGVkdWxlcjtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gICAvKipcclxuICAgKiAgRXhwYW5kcyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGJ5IHJlY3Vyc2l2ZWx5IGludm9raW5nIHNlbGVjdG9yLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2VsZWN0b3IgU2VsZWN0b3IgZnVuY3Rpb24gdG8gaW52b2tlIGZvciBlYWNoIHByb2R1Y2VkIGVsZW1lbnQsIHJlc3VsdGluZyBpbiBhbm90aGVyIHNlcXVlbmNlIHRvIHdoaWNoIHRoZSBzZWxlY3RvciB3aWxsIGJlIGludm9rZWQgcmVjdXJzaXZlbHkgYWdhaW4uXHJcbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIFNjaGVkdWxlciBvbiB3aGljaCB0byBwZXJmb3JtIHRoZSBleHBhbnNpb24uIElmIG5vdCBwcm92aWRlZCwgdGhpcyBkZWZhdWx0cyB0byB0aGUgY3VycmVudCB0aHJlYWQgc2NoZWR1bGVyLlxyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgYWxsIHRoZSBlbGVtZW50cyBwcm9kdWNlZCBieSB0aGUgcmVjdXJzaXZlIGV4cGFuc2lvbi5cclxuICAgKi9cclxuICBvYnNlcnZhYmxlUHJvdG8uZXhwYW5kID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBzY2hlZHVsZXIpIHtcclxuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGltbWVkaWF0ZVNjaGVkdWxlcik7XHJcbiAgICB2YXIgc291cmNlID0gdGhpcztcclxuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgdmFyIHEgPSBbXSxcclxuICAgICAgICBtID0gbmV3IFNlcmlhbERpc3Bvc2FibGUoKSxcclxuICAgICAgICBkID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUobSksXHJcbiAgICAgICAgYWN0aXZlQ291bnQgPSAwLFxyXG4gICAgICAgIGlzQWNxdWlyZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgIHZhciBlbnN1cmVBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGlzT3duZXIgPSBmYWxzZTtcclxuICAgICAgICBpZiAocS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGlzT3duZXIgPSAhaXNBY3F1aXJlZDtcclxuICAgICAgICAgICAgaXNBY3F1aXJlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc093bmVyKSB7XHJcbiAgICAgICAgICBtLnNldERpc3Bvc2FibGUoc2NoZWR1bGVyLnNjaGVkdWxlUmVjdXJzaXZlKGZ1bmN0aW9uIChzZWxmKSB7XHJcbiAgICAgICAgICAgIHZhciB3b3JrO1xyXG4gICAgICAgICAgICBpZiAocS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgd29yayA9IHEuc2hpZnQoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBpc0FjcXVpcmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBtMSA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xyXG4gICAgICAgICAgICBkLmFkZChtMSk7XHJcbiAgICAgICAgICAgIG0xLnNldERpc3Bvc2FibGUod29yay5zdWJzY3JpYmUoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICBvYnNlcnZlci5vbk5leHQoeCk7XHJcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNlbGVjdG9yKHgpO1xyXG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHEucHVzaChyZXN1bHQpO1xyXG4gICAgICAgICAgICAgIGFjdGl2ZUNvdW50Kys7XHJcbiAgICAgICAgICAgICAgZW5zdXJlQWN0aXZlKCk7XHJcbiAgICAgICAgICAgIH0sIG9ic2VydmVyLm9uRXJyb3IuYmluZChvYnNlcnZlciksIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICBkLnJlbW92ZShtMSk7XHJcbiAgICAgICAgICAgICAgYWN0aXZlQ291bnQtLTtcclxuICAgICAgICAgICAgICBpZiAoYWN0aXZlQ291bnQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIHNlbGYoKTtcclxuICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBxLnB1c2goc291cmNlKTtcclxuICAgICAgYWN0aXZlQ291bnQrKztcclxuICAgICAgZW5zdXJlQWN0aXZlKCk7XHJcbiAgICAgIHJldHVybiBkO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgIC8qKlxyXG4gICAqICBSdW5zIGFsbCBvYnNlcnZhYmxlIHNlcXVlbmNlcyBpbiBwYXJhbGxlbCBhbmQgY29sbGVjdCB0aGVpciBsYXN0IGVsZW1lbnRzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiAgMSAtIHJlcyA9IFJ4Lk9ic2VydmFibGUuZm9ya0pvaW4oW29iczEsIG9iczJdKTtcclxuICAgKiAgMSAtIHJlcyA9IFJ4Lk9ic2VydmFibGUuZm9ya0pvaW4ob2JzMSwgb2JzMiwgLi4uKTtcclxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIGFuIGFycmF5IGNvbGxlY3RpbmcgdGhlIGxhc3QgZWxlbWVudHMgb2YgYWxsIHRoZSBpbnB1dCBzZXF1ZW5jZXMuXHJcbiAgICovXHJcbiAgT2JzZXJ2YWJsZS5mb3JrSm9pbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBhbGxTb3VyY2VzID0gYXJnc09yQXJyYXkoYXJndW1lbnRzLCAwKTtcclxuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xyXG4gICAgICB2YXIgY291bnQgPSBhbGxTb3VyY2VzLmxlbmd0aDtcclxuICAgICAgaWYgKGNvdW50ID09PSAwKSB7XHJcbiAgICAgICAgc3Vic2NyaWJlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGdyb3VwID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKSxcclxuICAgICAgICBmaW5pc2hlZCA9IGZhbHNlLFxyXG4gICAgICAgIGhhc1Jlc3VsdHMgPSBuZXcgQXJyYXkoY291bnQpLFxyXG4gICAgICAgIGhhc0NvbXBsZXRlZCA9IG5ldyBBcnJheShjb3VudCksXHJcbiAgICAgICAgcmVzdWx0cyA9IG5ldyBBcnJheShjb3VudCk7XHJcblxyXG4gICAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBjb3VudDsgaWR4KyspIHtcclxuICAgICAgICAoZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgIHZhciBzb3VyY2UgPSBhbGxTb3VyY2VzW2ldO1xyXG4gICAgICAgICAgaXNQcm9taXNlKHNvdXJjZSkgJiYgKHNvdXJjZSA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShzb3VyY2UpKTtcclxuICAgICAgICAgIGdyb3VwLmFkZChcclxuICAgICAgICAgICAgc291cmNlLnN1YnNjcmliZShcclxuICAgICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICBpZiAoIWZpbmlzaGVkKSB7XHJcbiAgICAgICAgICAgICAgICBoYXNSZXN1bHRzW2ldID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdHNbaV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgIHN1YnNjcmliZXIub25FcnJvcihlKTtcclxuICAgICAgICAgICAgICBncm91cC5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICBpZiAoIWZpbmlzaGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWhhc1Jlc3VsdHNbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaGFzQ29tcGxldGVkW2ldID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGl4ID0gMDsgaXggPCBjb3VudDsgaXgrKykge1xyXG4gICAgICAgICAgICAgICAgICBpZiAoIWhhc0NvbXBsZXRlZFtpeF0pIHsgcmV0dXJuOyB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm9uTmV4dChyZXN1bHRzKTtcclxuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9KShpZHgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZ3JvdXA7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAgLyoqXHJcbiAgICogIFJ1bnMgdHdvIG9ic2VydmFibGUgc2VxdWVuY2VzIGluIHBhcmFsbGVsIGFuZCBjb21iaW5lcyB0aGVpciBsYXN0IGVsZW1lbmV0cy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JzZXJ2YWJsZX0gc2Vjb25kIFNlY29uZCBvYnNlcnZhYmxlIHNlcXVlbmNlLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc3VsdFNlbGVjdG9yIFJlc3VsdCBzZWxlY3RvciBmdW5jdGlvbiB0byBpbnZva2Ugd2l0aCB0aGUgbGFzdCBlbGVtZW50cyBvZiBib3RoIHNlcXVlbmNlcy5cclxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgc2VsZWN0b3IgZnVuY3Rpb24gd2l0aCB0aGUgbGFzdCBlbGVtZW50cyBvZiBib3RoIGlucHV0IHNlcXVlbmNlcy5cclxuICAgKi9cclxuICBvYnNlcnZhYmxlUHJvdG8uZm9ya0pvaW4gPSBmdW5jdGlvbiAoc2Vjb25kLCByZXN1bHRTZWxlY3Rvcikge1xyXG4gICAgdmFyIGZpcnN0ID0gdGhpcztcclxuXHJcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgIHZhciBsZWZ0U3RvcHBlZCA9IGZhbHNlLCByaWdodFN0b3BwZWQgPSBmYWxzZSxcclxuICAgICAgICBoYXNMZWZ0ID0gZmFsc2UsIGhhc1JpZ2h0ID0gZmFsc2UsXHJcbiAgICAgICAgbGFzdExlZnQsIGxhc3RSaWdodCxcclxuICAgICAgICBsZWZ0U3Vic2NyaXB0aW9uID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCksIHJpZ2h0U3Vic2NyaXB0aW9uID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XHJcblxyXG4gICAgICBpc1Byb21pc2Uoc2Vjb25kKSAmJiAoc2Vjb25kID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHNlY29uZCkpO1xyXG5cclxuICAgICAgbGVmdFN1YnNjcmlwdGlvbi5zZXREaXNwb3NhYmxlKFxyXG4gICAgICAgICAgZmlyc3Quc3Vic2NyaWJlKGZ1bmN0aW9uIChsZWZ0KSB7XHJcbiAgICAgICAgICAgIGhhc0xlZnQgPSB0cnVlO1xyXG4gICAgICAgICAgICBsYXN0TGVmdCA9IGxlZnQ7XHJcbiAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgIHJpZ2h0U3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlcnIpO1xyXG4gICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBsZWZ0U3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmIChyaWdodFN0b3BwZWQpIHtcclxuICAgICAgICAgICAgICBpZiAoIWhhc0xlZnQpIHtcclxuICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFoYXNSaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0U2VsZWN0b3IobGFzdExlZnQsIGxhc3RSaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG9ic2VydmVyLm9uTmV4dChyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pXHJcbiAgICAgICk7XHJcblxyXG4gICAgICByaWdodFN1YnNjcmlwdGlvbi5zZXREaXNwb3NhYmxlKFxyXG4gICAgICAgIHNlY29uZC5zdWJzY3JpYmUoZnVuY3Rpb24gKHJpZ2h0KSB7XHJcbiAgICAgICAgICBoYXNSaWdodCA9IHRydWU7XHJcbiAgICAgICAgICBsYXN0UmlnaHQgPSByaWdodDtcclxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICBsZWZ0U3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcclxuICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZXJyKTtcclxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICByaWdodFN0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgICAgaWYgKGxlZnRTdG9wcGVkKSB7XHJcbiAgICAgICAgICAgIGlmICghaGFzTGVmdCkge1xyXG4gICAgICAgICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWhhc1JpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB2YXIgcmVzdWx0O1xyXG4gICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRTZWxlY3RvcihsYXN0TGVmdCwgbGFzdFJpZ2h0KTtcclxuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5vbkVycm9yKGUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBvYnNlcnZlci5vbk5leHQocmVzdWx0KTtcclxuICAgICAgICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgKTtcclxuXHJcbiAgICAgIHJldHVybiBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZShsZWZ0U3Vic2NyaXB0aW9uLCByaWdodFN1YnNjcmlwdGlvbik7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDb21vbmFkaWMgYmluZCBvcGVyYXRvci5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZWxlY3RvciBBIHRyYW5zZm9ybSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGVsZW1lbnQuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHNjaGVkdWxlciBTY2hlZHVsZXIgdXNlZCB0byBleGVjdXRlIHRoZSBvcGVyYXRpb24uIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIHRoZSBJbW1lZGlhdGVTY2hlZHVsZXIuXHJcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hpY2ggcmVzdWx0cyBmcm9tIHRoZSBjb21vbmFkaWMgYmluZCBvcGVyYXRpb24uXHJcbiAgICovXHJcbiAgb2JzZXJ2YWJsZVByb3RvLm1hbnlTZWxlY3QgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHNjaGVkdWxlcikge1xyXG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gaW1tZWRpYXRlU2NoZWR1bGVyKTtcclxuICAgIHZhciBzb3VyY2UgPSB0aGlzO1xyXG4gICAgcmV0dXJuIG9ic2VydmFibGVEZWZlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBjaGFpbjtcclxuXHJcbiAgICAgIHJldHVybiBzb3VyY2VcclxuICAgICAgICAubWFwKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICB2YXIgY3VyciA9IG5ldyBDaGFpbk9ic2VydmFibGUoeCk7XHJcblxyXG4gICAgICAgICAgY2hhaW4gJiYgY2hhaW4ub25OZXh0KHgpO1xyXG4gICAgICAgICAgY2hhaW4gPSBjdXJyO1xyXG5cclxuICAgICAgICAgIHJldHVybiBjdXJyO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnRhcChcclxuICAgICAgICAgIG5vb3AsXHJcbiAgICAgICAgICBmdW5jdGlvbiAoZSkgeyBjaGFpbiAmJiBjaGFpbi5vbkVycm9yKGUpOyB9LFxyXG4gICAgICAgICAgZnVuY3Rpb24gKCkgeyBjaGFpbiAmJiBjaGFpbi5vbkNvbXBsZXRlZCgpOyB9XHJcbiAgICAgICAgKVxyXG4gICAgICAgIC5vYnNlcnZlT24oc2NoZWR1bGVyKVxyXG4gICAgICAgIC5tYXAoc2VsZWN0b3IpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgdmFyIENoYWluT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XHJcblxyXG4gICAgZnVuY3Rpb24gc3Vic2NyaWJlIChvYnNlcnZlcikge1xyXG4gICAgICB2YXIgc2VsZiA9IHRoaXMsIGcgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpO1xyXG4gICAgICBnLmFkZChjdXJyZW50VGhyZWFkU2NoZWR1bGVyLnNjaGVkdWxlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBvYnNlcnZlci5vbk5leHQoc2VsZi5oZWFkKTtcclxuICAgICAgICBnLmFkZChzZWxmLnRhaWwubWVyZ2VPYnNlcnZhYmxlKCkuc3Vic2NyaWJlKG9ic2VydmVyKSk7XHJcbiAgICAgIH0pKTtcclxuXHJcbiAgICAgIHJldHVybiBnO1xyXG4gICAgfVxyXG5cclxuICAgIGluaGVyaXRzKENoYWluT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcclxuXHJcbiAgICBmdW5jdGlvbiBDaGFpbk9ic2VydmFibGUoaGVhZCkge1xyXG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzLCBzdWJzY3JpYmUpO1xyXG4gICAgICB0aGlzLmhlYWQgPSBoZWFkO1xyXG4gICAgICB0aGlzLnRhaWwgPSBuZXcgQXN5bmNTdWJqZWN0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgYWRkUHJvcGVydGllcyhDaGFpbk9ic2VydmFibGUucHJvdG90eXBlLCBPYnNlcnZlciwge1xyXG4gICAgICBvbkNvbXBsZXRlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMub25OZXh0KE9ic2VydmFibGUuZW1wdHkoKSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgdGhpcy5vbk5leHQoT2JzZXJ2YWJsZS50aHJvd0V4Y2VwdGlvbihlKSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIG9uTmV4dDogZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB0aGlzLnRhaWwub25OZXh0KHYpO1xyXG4gICAgICAgIHRoaXMudGFpbC5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gQ2hhaW5PYnNlcnZhYmxlO1xyXG5cclxuICB9KE9ic2VydmFibGUpKTtcclxuXHJcbiAgLyoqIEBwcml2YXRlICovXHJcbiAgdmFyIE1hcCA9IHJvb3QuTWFwIHx8IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgZnVuY3Rpb24gTWFwKCkge1xyXG4gICAgICB0aGlzLl9rZXlzID0gW107XHJcbiAgICAgIHRoaXMuX3ZhbHVlcyA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIE1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICB2YXIgaSA9IHRoaXMuX2tleXMuaW5kZXhPZihrZXkpO1xyXG4gICAgICByZXR1cm4gaSAhPT0gLTEgPyB0aGlzLl92YWx1ZXNbaV0gOiB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIE1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgdmFyIGkgPSB0aGlzLl9rZXlzLmluZGV4T2Yoa2V5KTtcclxuICAgICAgaSAhPT0gLTEgJiYgKHRoaXMuX3ZhbHVlc1tpXSA9IHZhbHVlKTtcclxuICAgICAgdGhpcy5fdmFsdWVzW3RoaXMuX2tleXMucHVzaChrZXkpIC0gMV0gPSB2YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgTWFwLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzQXJnKSB7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9rZXlzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLl92YWx1ZXNbaV0sIHRoaXMuX2tleXNbaV0pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBNYXA7XHJcbiAgfSgpKTtcclxuXHJcbiAgLyoqXHJcbiAgICogQGNvbnN0cnVjdG9yXHJcbiAgICogUmVwcmVzZW50cyBhIGpvaW4gcGF0dGVybiBvdmVyIG9ic2VydmFibGUgc2VxdWVuY2VzLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIFBhdHRlcm4ocGF0dGVybnMpIHtcclxuICAgIHRoaXMucGF0dGVybnMgPSBwYXR0ZXJucztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqICBDcmVhdGVzIGEgcGF0dGVybiB0aGF0IG1hdGNoZXMgdGhlIGN1cnJlbnQgcGxhbiBtYXRjaGVzIGFuZCB3aGVuIHRoZSBzcGVjaWZpZWQgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaGFzIGFuIGF2YWlsYWJsZSB2YWx1ZS5cclxuICAgKiAgQHBhcmFtIG90aGVyIE9ic2VydmFibGUgc2VxdWVuY2UgdG8gbWF0Y2ggaW4gYWRkaXRpb24gdG8gdGhlIGN1cnJlbnQgcGF0dGVybi5cclxuICAgKiAgQHJldHVybiB7UGF0dGVybn0gUGF0dGVybiBvYmplY3QgdGhhdCBtYXRjaGVzIHdoZW4gYWxsIG9ic2VydmFibGUgc2VxdWVuY2VzIGluIHRoZSBwYXR0ZXJuIGhhdmUgYW4gYXZhaWxhYmxlIHZhbHVlLlxyXG4gICAqL1xyXG4gIFBhdHRlcm4ucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIChvdGhlcikge1xyXG4gICAgcmV0dXJuIG5ldyBQYXR0ZXJuKHRoaXMucGF0dGVybnMuY29uY2F0KG90aGVyKSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogIE1hdGNoZXMgd2hlbiBhbGwgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaW4gdGhlIHBhdHRlcm4gKHNwZWNpZmllZCB1c2luZyBhIGNoYWluIG9mIGFuZCBvcGVyYXRvcnMpIGhhdmUgYW4gYXZhaWxhYmxlIHZhbHVlIGFuZCBwcm9qZWN0cyB0aGUgdmFsdWVzLlxyXG4gICAqICBAcGFyYW0ge0Z1bmN0aW9ufSBzZWxlY3RvciBTZWxlY3RvciB0aGF0IHdpbGwgYmUgaW52b2tlZCB3aXRoIGF2YWlsYWJsZSB2YWx1ZXMgZnJvbSB0aGUgc291cmNlIHNlcXVlbmNlcywgaW4gdGhlIHNhbWUgb3JkZXIgb2YgdGhlIHNlcXVlbmNlcyBpbiB0aGUgcGF0dGVybi5cclxuICAgKiAgQHJldHVybiB7UGxhbn0gUGxhbiB0aGF0IHByb2R1Y2VzIHRoZSBwcm9qZWN0ZWQgdmFsdWVzLCB0byBiZSBmZWQgKHdpdGggb3RoZXIgcGxhbnMpIHRvIHRoZSB3aGVuIG9wZXJhdG9yLlxyXG4gICAqL1xyXG4gIFBhdHRlcm4ucHJvdG90eXBlLnRoZW5EbyA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xyXG4gICAgcmV0dXJuIG5ldyBQbGFuKHRoaXMsIHNlbGVjdG9yKTtcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBQbGFuKGV4cHJlc3Npb24sIHNlbGVjdG9yKSB7XHJcbiAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XHJcbiAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcclxuICB9XHJcblxyXG4gIFBsYW4ucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gKGV4dGVybmFsU3Vic2NyaXB0aW9ucywgb2JzZXJ2ZXIsIGRlYWN0aXZhdGUpIHtcclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgIHZhciBqb2luT2JzZXJ2ZXJzID0gW107XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5leHByZXNzaW9uLnBhdHRlcm5zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgIGpvaW5PYnNlcnZlcnMucHVzaChwbGFuQ3JlYXRlT2JzZXJ2ZXIoZXh0ZXJuYWxTdWJzY3JpcHRpb25zLCB0aGlzLmV4cHJlc3Npb24ucGF0dGVybnNbaV0sIG9ic2VydmVyLm9uRXJyb3IuYmluZChvYnNlcnZlcikpKTtcclxuICAgIH1cclxuICAgIHZhciBhY3RpdmVQbGFuID0gbmV3IEFjdGl2ZVBsYW4oam9pbk9ic2VydmVycywgZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgcmVzdWx0O1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHJlc3VsdCA9IHNlbGYuc2VsZWN0b3IuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIG9ic2VydmVyLm9uTmV4dChyZXN1bHQpO1xyXG4gICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IGpvaW5PYnNlcnZlcnMubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XHJcbiAgICAgICAgam9pbk9ic2VydmVyc1tqXS5yZW1vdmVBY3RpdmVQbGFuKGFjdGl2ZVBsYW4pO1xyXG4gICAgICB9XHJcbiAgICAgIGRlYWN0aXZhdGUoYWN0aXZlUGxhbik7XHJcbiAgICB9KTtcclxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGpvaW5PYnNlcnZlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgam9pbk9ic2VydmVyc1tpXS5hZGRBY3RpdmVQbGFuKGFjdGl2ZVBsYW4pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFjdGl2ZVBsYW47XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gcGxhbkNyZWF0ZU9ic2VydmVyKGV4dGVybmFsU3Vic2NyaXB0aW9ucywgb2JzZXJ2YWJsZSwgb25FcnJvcikge1xyXG4gICAgdmFyIGVudHJ5ID0gZXh0ZXJuYWxTdWJzY3JpcHRpb25zLmdldChvYnNlcnZhYmxlKTtcclxuICAgIGlmICghZW50cnkpIHtcclxuICAgICAgdmFyIG9ic2VydmVyID0gbmV3IEpvaW5PYnNlcnZlcihvYnNlcnZhYmxlLCBvbkVycm9yKTtcclxuICAgICAgZXh0ZXJuYWxTdWJzY3JpcHRpb25zLnNldChvYnNlcnZhYmxlLCBvYnNlcnZlcik7XHJcbiAgICAgIHJldHVybiBvYnNlcnZlcjtcclxuICAgIH1cclxuICAgIHJldHVybiBlbnRyeTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIEFjdGl2ZVBsYW4oam9pbk9ic2VydmVyQXJyYXksIG9uTmV4dCwgb25Db21wbGV0ZWQpIHtcclxuICAgIHRoaXMuam9pbk9ic2VydmVyQXJyYXkgPSBqb2luT2JzZXJ2ZXJBcnJheTtcclxuICAgIHRoaXMub25OZXh0ID0gb25OZXh0O1xyXG4gICAgdGhpcy5vbkNvbXBsZXRlZCA9IG9uQ29tcGxldGVkO1xyXG4gICAgdGhpcy5qb2luT2JzZXJ2ZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuam9pbk9ic2VydmVyQXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgdmFyIGpvaW5PYnNlcnZlciA9IHRoaXMuam9pbk9ic2VydmVyQXJyYXlbaV07XHJcbiAgICAgIHRoaXMuam9pbk9ic2VydmVycy5zZXQoam9pbk9ic2VydmVyLCBqb2luT2JzZXJ2ZXIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgQWN0aXZlUGxhbi5wcm90b3R5cGUuZGVxdWV1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuam9pbk9ic2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7IHYucXVldWUuc2hpZnQoKTsgfSk7XHJcbiAgfTtcclxuXHJcbiAgQWN0aXZlUGxhbi5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgaSwgbGVuLCBoYXNWYWx1ZXMgPSB0cnVlO1xyXG4gICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy5qb2luT2JzZXJ2ZXJBcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICBpZiAodGhpcy5qb2luT2JzZXJ2ZXJBcnJheVtpXS5xdWV1ZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICBoYXNWYWx1ZXMgPSBmYWxzZTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGhhc1ZhbHVlcykge1xyXG4gICAgICB2YXIgZmlyc3RWYWx1ZXMgPSBbXSxcclxuICAgICAgICAgIGlzQ29tcGxldGVkID0gZmFsc2U7XHJcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuam9pbk9ic2VydmVyQXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBmaXJzdFZhbHVlcy5wdXNoKHRoaXMuam9pbk9ic2VydmVyQXJyYXlbaV0ucXVldWVbMF0pO1xyXG4gICAgICAgIHRoaXMuam9pbk9ic2VydmVyQXJyYXlbaV0ucXVldWVbMF0ua2luZCA9PT0gJ0MnICYmIChpc0NvbXBsZXRlZCA9IHRydWUpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpc0NvbXBsZXRlZCkge1xyXG4gICAgICAgIHRoaXMub25Db21wbGV0ZWQoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmRlcXVldWUoKTtcclxuICAgICAgICB2YXIgdmFsdWVzID0gW107XHJcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gZmlyc3RWYWx1ZXMubGVuZ3RoOyBpIDwgZmlyc3RWYWx1ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIHZhbHVlcy5wdXNoKGZpcnN0VmFsdWVzW2ldLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5vbk5leHQuYXBwbHkodGhpcywgdmFsdWVzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHZhciBKb2luT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xyXG5cclxuICAgIGluaGVyaXRzKEpvaW5PYnNlcnZlciwgX19zdXBlcl9fKTtcclxuXHJcbiAgICBmdW5jdGlvbiBKb2luT2JzZXJ2ZXIoc291cmNlLCBvbkVycm9yKSB7XHJcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xyXG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcclxuICAgICAgdGhpcy5vbkVycm9yID0gb25FcnJvcjtcclxuICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xyXG4gICAgICB0aGlzLmFjdGl2ZVBsYW5zID0gW107XHJcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XHJcbiAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBKb2luT2JzZXJ2ZXJQcm90b3R5cGUgPSBKb2luT2JzZXJ2ZXIucHJvdG90eXBlO1xyXG5cclxuICAgIEpvaW5PYnNlcnZlclByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKG5vdGlmaWNhdGlvbikge1xyXG4gICAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCkge1xyXG4gICAgICAgIGlmIChub3RpZmljYXRpb24ua2luZCA9PT0gJ0UnKSB7XHJcbiAgICAgICAgICB0aGlzLm9uRXJyb3Iobm90aWZpY2F0aW9uLmV4Y2VwdGlvbik7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucXVldWUucHVzaChub3RpZmljYXRpb24pO1xyXG4gICAgICAgIHZhciBhY3RpdmVQbGFucyA9IHRoaXMuYWN0aXZlUGxhbnMuc2xpY2UoMCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFjdGl2ZVBsYW5zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICBhY3RpdmVQbGFuc1tpXS5tYXRjaCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBKb2luT2JzZXJ2ZXJQcm90b3R5cGUuZXJyb3IgPSBub29wO1xyXG4gICAgSm9pbk9ic2VydmVyUHJvdG90eXBlLmNvbXBsZXRlZCA9IG5vb3A7XHJcblxyXG4gICAgSm9pbk9ic2VydmVyUHJvdG90eXBlLmFkZEFjdGl2ZVBsYW4gPSBmdW5jdGlvbiAoYWN0aXZlUGxhbikge1xyXG4gICAgICB0aGlzLmFjdGl2ZVBsYW5zLnB1c2goYWN0aXZlUGxhbik7XHJcbiAgICB9O1xyXG5cclxuICAgIEpvaW5PYnNlcnZlclByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnNldERpc3Bvc2FibGUodGhpcy5zb3VyY2UubWF0ZXJpYWxpemUoKS5zdWJzY3JpYmUodGhpcykpO1xyXG4gICAgfTtcclxuXHJcbiAgICBKb2luT2JzZXJ2ZXJQcm90b3R5cGUucmVtb3ZlQWN0aXZlUGxhbiA9IGZ1bmN0aW9uIChhY3RpdmVQbGFuKSB7XHJcbiAgICAgIHRoaXMuYWN0aXZlUGxhbnMuc3BsaWNlKHRoaXMuYWN0aXZlUGxhbnMuaW5kZXhPZihhY3RpdmVQbGFuKSwgMSk7XHJcbiAgICAgIHRoaXMuYWN0aXZlUGxhbnMubGVuZ3RoID09PSAwICYmIHRoaXMuZGlzcG9zZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBKb2luT2JzZXJ2ZXJQcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgX19zdXBlcl9fLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XHJcbiAgICAgIGlmICghdGhpcy5pc0Rpc3Bvc2VkKSB7XHJcbiAgICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIEpvaW5PYnNlcnZlcjtcclxuICB9IChBYnN0cmFjdE9ic2VydmVyKSk7XHJcblxyXG4gIC8qKlxyXG4gICAqICBDcmVhdGVzIGEgcGF0dGVybiB0aGF0IG1hdGNoZXMgd2hlbiBib3RoIG9ic2VydmFibGUgc2VxdWVuY2VzIGhhdmUgYW4gYXZhaWxhYmxlIHZhbHVlLlxyXG4gICAqXHJcbiAgICogIEBwYXJhbSByaWdodCBPYnNlcnZhYmxlIHNlcXVlbmNlIHRvIG1hdGNoIHdpdGggdGhlIGN1cnJlbnQgc2VxdWVuY2UuXHJcbiAgICogIEByZXR1cm4ge1BhdHRlcm59IFBhdHRlcm4gb2JqZWN0IHRoYXQgbWF0Y2hlcyB3aGVuIGJvdGggb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaGF2ZSBhbiBhdmFpbGFibGUgdmFsdWUuXHJcbiAgICovXHJcbiAgb2JzZXJ2YWJsZVByb3RvLmFuZCA9IGZ1bmN0aW9uIChyaWdodCkge1xyXG4gICAgcmV0dXJuIG5ldyBQYXR0ZXJuKFt0aGlzLCByaWdodF0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqICBNYXRjaGVzIHdoZW4gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UgaGFzIGFuIGF2YWlsYWJsZSB2YWx1ZSBhbmQgcHJvamVjdHMgdGhlIHZhbHVlLlxyXG4gICAqXHJcbiAgICogIEBwYXJhbSBzZWxlY3RvciBTZWxlY3RvciB0aGF0IHdpbGwgYmUgaW52b2tlZCBmb3IgdmFsdWVzIGluIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXHJcbiAgICogIEByZXR1cm5zIHtQbGFufSBQbGFuIHRoYXQgcHJvZHVjZXMgdGhlIHByb2plY3RlZCB2YWx1ZXMsIHRvIGJlIGZlZCAod2l0aCBvdGhlciBwbGFucykgdG8gdGhlIHdoZW4gb3BlcmF0b3IuXHJcbiAgICovXHJcbiAgb2JzZXJ2YWJsZVByb3RvLnRoZW5EbyA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xyXG4gICAgcmV0dXJuIG5ldyBQYXR0ZXJuKFt0aGlzXSkudGhlbkRvKHNlbGVjdG9yKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiAgSm9pbnMgdG9nZXRoZXIgdGhlIHJlc3VsdHMgZnJvbSBzZXZlcmFsIHBhdHRlcm5zLlxyXG4gICAqXHJcbiAgICogIEBwYXJhbSBwbGFucyBBIHNlcmllcyBvZiBwbGFucyAoc3BlY2lmaWVkIGFzIGFuIEFycmF5IG9mIGFzIGEgc2VyaWVzIG9mIGFyZ3VtZW50cykgY3JlYXRlZCBieSB1c2Ugb2YgdGhlIFRoZW4gb3BlcmF0b3Igb24gcGF0dGVybnMuXHJcbiAgICogIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBPYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggdGhlIHJlc3VsdHMgZm9ybSBtYXRjaGluZyBzZXZlcmFsIHBhdHRlcm5zLlxyXG4gICAqL1xyXG4gIE9ic2VydmFibGUud2hlbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBwbGFucyA9IGFyZ3NPckFycmF5KGFyZ3VtZW50cywgMCk7XHJcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgIHZhciBhY3RpdmVQbGFucyA9IFtdLFxyXG4gICAgICAgICAgZXh0ZXJuYWxTdWJzY3JpcHRpb25zID0gbmV3IE1hcCgpO1xyXG4gICAgICB2YXIgb3V0T2JzZXJ2ZXIgPSBvYnNlcnZlckNyZWF0ZShcclxuICAgICAgICBvYnNlcnZlci5vbk5leHQuYmluZChvYnNlcnZlciksXHJcbiAgICAgICAgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgZXh0ZXJuYWxTdWJzY3JpcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKHYpIHsgdi5vbkVycm9yKGVycik7IH0pO1xyXG4gICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlcnIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQuYmluZChvYnNlcnZlcilcclxuICAgICAgKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGxhbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgIGFjdGl2ZVBsYW5zLnB1c2gocGxhbnNbaV0uYWN0aXZhdGUoZXh0ZXJuYWxTdWJzY3JpcHRpb25zLCBvdXRPYnNlcnZlciwgZnVuY3Rpb24gKGFjdGl2ZVBsYW4pIHtcclxuICAgICAgICAgICAgdmFyIGlkeCA9IGFjdGl2ZVBsYW5zLmluZGV4T2YoYWN0aXZlUGxhbik7XHJcbiAgICAgICAgICAgIGFjdGl2ZVBsYW5zLnNwbGljZShpZHgsIDEpO1xyXG4gICAgICAgICAgICBhY3RpdmVQbGFucy5sZW5ndGggPT09IDAgJiYgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBvYnNlcnZhYmxlVGhyb3coZSkuc3Vic2NyaWJlKG9ic2VydmVyKTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgZ3JvdXAgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpO1xyXG4gICAgICBleHRlcm5hbFN1YnNjcmlwdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoam9pbk9ic2VydmVyKSB7XHJcbiAgICAgICAgam9pbk9ic2VydmVyLnN1YnNjcmliZSgpO1xyXG4gICAgICAgIGdyb3VwLmFkZChqb2luT2JzZXJ2ZXIpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJldHVybiBncm91cDtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIG9ic2VydmFibGVUaW1lckRhdGUoZHVlVGltZSwgc2NoZWR1bGVyKSB7XHJcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGVXaXRoQWJzb2x1dGUoZHVlVGltZSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIG9ic2VydmVyLm9uTmV4dCgwKTtcclxuICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gb2JzZXJ2YWJsZVRpbWVyRGF0ZUFuZFBlcmlvZChkdWVUaW1lLCBwZXJpb2QsIHNjaGVkdWxlcikge1xyXG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICB2YXIgY291bnQgPSAwLCBkID0gZHVlVGltZSwgcCA9IG5vcm1hbGl6ZVRpbWUocGVyaW9kKTtcclxuICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZVJlY3Vyc2l2ZVdpdGhBYnNvbHV0ZShkLCBmdW5jdGlvbiAoc2VsZikge1xyXG4gICAgICAgIGlmIChwID4gMCkge1xyXG4gICAgICAgICAgdmFyIG5vdyA9IHNjaGVkdWxlci5ub3coKTtcclxuICAgICAgICAgIGQgPSBkICsgcDtcclxuICAgICAgICAgIGQgPD0gbm93ICYmIChkID0gbm93ICsgcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9ic2VydmVyLm9uTmV4dChjb3VudCsrKTtcclxuICAgICAgICBzZWxmKGQpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gb2JzZXJ2YWJsZVRpbWVyVGltZVNwYW4oZHVlVGltZSwgc2NoZWR1bGVyKSB7XHJcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGVXaXRoUmVsYXRpdmUobm9ybWFsaXplVGltZShkdWVUaW1lKSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIG9ic2VydmVyLm9uTmV4dCgwKTtcclxuICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gb2JzZXJ2YWJsZVRpbWVyVGltZVNwYW5BbmRQZXJpb2QoZHVlVGltZSwgcGVyaW9kLCBzY2hlZHVsZXIpIHtcclxuICAgIHJldHVybiBkdWVUaW1lID09PSBwZXJpb2QgP1xyXG4gICAgICBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlUGVyaW9kaWNXaXRoU3RhdGUoMCwgcGVyaW9kLCBmdW5jdGlvbiAoY291bnQpIHtcclxuICAgICAgICAgIG9ic2VydmVyLm9uTmV4dChjb3VudCk7XHJcbiAgICAgICAgICByZXR1cm4gY291bnQgKyAxO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KSA6XHJcbiAgICAgIG9ic2VydmFibGVEZWZlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGVUaW1lckRhdGVBbmRQZXJpb2Qoc2NoZWR1bGVyLm5vdygpICsgZHVlVGltZSwgcGVyaW9kLCBzY2hlZHVsZXIpO1xyXG4gICAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqICBSZXR1cm5zIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBwcm9kdWNlcyBhIHZhbHVlIGFmdGVyIGVhY2ggcGVyaW9kLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiAgMSAtIHJlcyA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XHJcbiAgICogIDIgLSByZXMgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDAsIFJ4LlNjaGVkdWxlci50aW1lb3V0KTtcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwZXJpb2QgUGVyaW9kIGZvciBwcm9kdWNpbmcgdGhlIHZhbHVlcyBpbiB0aGUgcmVzdWx0aW5nIHNlcXVlbmNlIChzcGVjaWZpZWQgYXMgYW4gaW50ZWdlciBkZW5vdGluZyBtaWxsaXNlY29uZHMpLlxyXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBTY2hlZHVsZXIgdG8gcnVuIHRoZSB0aW1lciBvbi4gSWYgbm90IHNwZWNpZmllZCwgUnguU2NoZWR1bGVyLnRpbWVvdXQgaXMgdXNlZC5cclxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHByb2R1Y2VzIGEgdmFsdWUgYWZ0ZXIgZWFjaCBwZXJpb2QuXHJcbiAgICovXHJcbiAgdmFyIG9ic2VydmFibGVpbnRlcnZhbCA9IE9ic2VydmFibGUuaW50ZXJ2YWwgPSBmdW5jdGlvbiAocGVyaW9kLCBzY2hlZHVsZXIpIHtcclxuICAgIHJldHVybiBvYnNlcnZhYmxlVGltZXJUaW1lU3BhbkFuZFBlcmlvZChwZXJpb2QsIHBlcmlvZCwgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSA/IHNjaGVkdWxlciA6IHRpbWVvdXRTY2hlZHVsZXIpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqICBSZXR1cm5zIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBwcm9kdWNlcyBhIHZhbHVlIGFmdGVyIGR1ZVRpbWUgaGFzIGVsYXBzZWQgYW5kIHRoZW4gYWZ0ZXIgZWFjaCBwZXJpb2QuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGR1ZVRpbWUgQWJzb2x1dGUgKHNwZWNpZmllZCBhcyBhIERhdGUgb2JqZWN0KSBvciByZWxhdGl2ZSB0aW1lIChzcGVjaWZpZWQgYXMgYW4gaW50ZWdlciBkZW5vdGluZyBtaWxsaXNlY29uZHMpIGF0IHdoaWNoIHRvIHByb2R1Y2UgdGhlIGZpcnN0IHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7TWl4ZWR9IFtwZXJpb2RPclNjaGVkdWxlcl0gIFBlcmlvZCB0byBwcm9kdWNlIHN1YnNlcXVlbnQgdmFsdWVzIChzcGVjaWZpZWQgYXMgYW4gaW50ZWdlciBkZW5vdGluZyBtaWxsaXNlY29uZHMpLCBvciB0aGUgc2NoZWR1bGVyIHRvIHJ1biB0aGUgdGltZXIgb24uIElmIG5vdCBzcGVjaWZpZWQsIHRoZSByZXN1bHRpbmcgdGltZXIgaXMgbm90IHJlY3VycmluZy5cclxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gIFNjaGVkdWxlciB0byBydW4gdGhlIHRpbWVyIG9uLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgdGltZW91dCBzY2hlZHVsZXIgaXMgdXNlZC5cclxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHByb2R1Y2VzIGEgdmFsdWUgYWZ0ZXIgZHVlIHRpbWUgaGFzIGVsYXBzZWQgYW5kIHRoZW4gZWFjaCBwZXJpb2QuXHJcbiAgICovXHJcbiAgdmFyIG9ic2VydmFibGVUaW1lciA9IE9ic2VydmFibGUudGltZXIgPSBmdW5jdGlvbiAoZHVlVGltZSwgcGVyaW9kT3JTY2hlZHVsZXIsIHNjaGVkdWxlcikge1xyXG4gICAgdmFyIHBlcmlvZDtcclxuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IHRpbWVvdXRTY2hlZHVsZXIpO1xyXG4gICAgaWYgKHBlcmlvZE9yU2NoZWR1bGVyICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHBlcmlvZE9yU2NoZWR1bGVyID09PSAnbnVtYmVyJykge1xyXG4gICAgICBwZXJpb2QgPSBwZXJpb2RPclNjaGVkdWxlcjtcclxuICAgIH0gZWxzZSBpZiAoaXNTY2hlZHVsZXIocGVyaW9kT3JTY2hlZHVsZXIpKSB7XHJcbiAgICAgIHNjaGVkdWxlciA9IHBlcmlvZE9yU2NoZWR1bGVyO1xyXG4gICAgfVxyXG4gICAgaWYgKGR1ZVRpbWUgaW5zdGFuY2VvZiBEYXRlICYmIHBlcmlvZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJldHVybiBvYnNlcnZhYmxlVGltZXJEYXRlKGR1ZVRpbWUuZ2V0VGltZSgpLCBzY2hlZHVsZXIpO1xyXG4gICAgfVxyXG4gICAgaWYgKGR1ZVRpbWUgaW5zdGFuY2VvZiBEYXRlICYmIHBlcmlvZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHBlcmlvZCA9IHBlcmlvZE9yU2NoZWR1bGVyO1xyXG4gICAgICByZXR1cm4gb2JzZXJ2YWJsZVRpbWVyRGF0ZUFuZFBlcmlvZChkdWVUaW1lLmdldFRpbWUoKSwgcGVyaW9kLCBzY2hlZHVsZXIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBlcmlvZCA9PT0gdW5kZWZpbmVkID9cclxuICAgICAgb2JzZXJ2YWJsZVRpbWVyVGltZVNwYW4oZHVlVGltZSwgc2NoZWR1bGVyKSA6XHJcbiAgICAgIG9ic2VydmFibGVUaW1lclRpbWVTcGFuQW5kUGVyaW9kKGR1ZVRpbWUsIHBlcmlvZCwgc2NoZWR1bGVyKTtcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBvYnNlcnZhYmxlRGVsYXlUaW1lU3Bhbihzb3VyY2UsIGR1ZVRpbWUsIHNjaGVkdWxlcikge1xyXG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICB2YXIgYWN0aXZlID0gZmFsc2UsXHJcbiAgICAgICAgY2FuY2VsYWJsZSA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCksXHJcbiAgICAgICAgZXhjZXB0aW9uID0gbnVsbCxcclxuICAgICAgICBxID0gW10sXHJcbiAgICAgICAgcnVubmluZyA9IGZhbHNlLFxyXG4gICAgICAgIHN1YnNjcmlwdGlvbjtcclxuICAgICAgc3Vic2NyaXB0aW9uID0gc291cmNlLm1hdGVyaWFsaXplKCkudGltZXN0YW1wKHNjaGVkdWxlcikuc3Vic2NyaWJlKGZ1bmN0aW9uIChub3RpZmljYXRpb24pIHtcclxuICAgICAgICB2YXIgZCwgc2hvdWxkUnVuO1xyXG4gICAgICAgIGlmIChub3RpZmljYXRpb24udmFsdWUua2luZCA9PT0gJ0UnKSB7XHJcbiAgICAgICAgICBxID0gW107XHJcbiAgICAgICAgICBxLnB1c2gobm90aWZpY2F0aW9uKTtcclxuICAgICAgICAgIGV4Y2VwdGlvbiA9IG5vdGlmaWNhdGlvbi52YWx1ZS5leGNlcHRpb247XHJcbiAgICAgICAgICBzaG91bGRSdW4gPSAhcnVubmluZztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcS5wdXNoKHsgdmFsdWU6IG5vdGlmaWNhdGlvbi52YWx1ZSwgdGltZXN0YW1wOiBub3RpZmljYXRpb24udGltZXN0YW1wICsgZHVlVGltZSB9KTtcclxuICAgICAgICAgIHNob3VsZFJ1biA9ICFhY3RpdmU7XHJcbiAgICAgICAgICBhY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hvdWxkUnVuKSB7XHJcbiAgICAgICAgICBpZiAoZXhjZXB0aW9uICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZXhjZXB0aW9uKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcclxuICAgICAgICAgICAgY2FuY2VsYWJsZS5zZXREaXNwb3NhYmxlKGQpO1xyXG4gICAgICAgICAgICBkLnNldERpc3Bvc2FibGUoc2NoZWR1bGVyLnNjaGVkdWxlUmVjdXJzaXZlV2l0aFJlbGF0aXZlKGR1ZVRpbWUsIGZ1bmN0aW9uIChzZWxmKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGUsIHJlY3Vyc2VEdWVUaW1lLCByZXN1bHQsIHNob3VsZFJlY3Vyc2U7XHJcbiAgICAgICAgICAgICAgaWYgKGV4Y2VwdGlvbiAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBydW5uaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKHEubGVuZ3RoID4gMCAmJiBxWzBdLnRpbWVzdGFtcCAtIHNjaGVkdWxlci5ub3coKSA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHEuc2hpZnQoKS52YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgcmVzdWx0LmFjY2VwdChvYnNlcnZlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSB3aGlsZSAocmVzdWx0ICE9PSBudWxsKTtcclxuICAgICAgICAgICAgICBzaG91bGRSZWN1cnNlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgcmVjdXJzZUR1ZVRpbWUgPSAwO1xyXG4gICAgICAgICAgICAgIGlmIChxLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHNob3VsZFJlY3Vyc2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcmVjdXJzZUR1ZVRpbWUgPSBNYXRoLm1heCgwLCBxWzBdLnRpbWVzdGFtcCAtIHNjaGVkdWxlci5ub3coKSk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBlID0gZXhjZXB0aW9uO1xyXG4gICAgICAgICAgICAgIHJ1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICBpZiAoZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlKTtcclxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNob3VsZFJlY3Vyc2UpIHtcclxuICAgICAgICAgICAgICAgIHNlbGYocmVjdXJzZUR1ZVRpbWUpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZShzdWJzY3JpcHRpb24sIGNhbmNlbGFibGUpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBvYnNlcnZhYmxlRGVsYXlEYXRlKHNvdXJjZSwgZHVlVGltZSwgc2NoZWR1bGVyKSB7XHJcbiAgICByZXR1cm4gb2JzZXJ2YWJsZURlZmVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIG9ic2VydmFibGVEZWxheVRpbWVTcGFuKHNvdXJjZSwgZHVlVGltZSAtIHNjaGVkdWxlci5ub3coKSwgc2NoZWR1bGVyKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogIFRpbWUgc2hpZnRzIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIGJ5IGR1ZVRpbWUuIFRoZSByZWxhdGl2ZSB0aW1lIGludGVydmFscyBiZXR3ZWVuIHRoZSB2YWx1ZXMgYXJlIHByZXNlcnZlZC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogIDEgLSByZXMgPSBSeC5PYnNlcnZhYmxlLmRlbGF5KG5ldyBEYXRlKCkpO1xyXG4gICAqICAyIC0gcmVzID0gUnguT2JzZXJ2YWJsZS5kZWxheShuZXcgRGF0ZSgpLCBSeC5TY2hlZHVsZXIudGltZW91dCk7XHJcbiAgICpcclxuICAgKiAgMyAtIHJlcyA9IFJ4Lk9ic2VydmFibGUuZGVsYXkoNTAwMCk7XHJcbiAgICogIDQgLSByZXMgPSBSeC5PYnNlcnZhYmxlLmRlbGF5KDUwMDAsIDEwMDAsIFJ4LlNjaGVkdWxlci50aW1lb3V0KTtcclxuICAgKiBAbWVtYmVyT2YgT2JzZXJ2YWJsZSNcclxuICAgKiBAcGFyYW0ge051bWJlcn0gZHVlVGltZSBBYnNvbHV0ZSAoc3BlY2lmaWVkIGFzIGEgRGF0ZSBvYmplY3QpIG9yIHJlbGF0aXZlIHRpbWUgKHNwZWNpZmllZCBhcyBhbiBpbnRlZ2VyIGRlbm90aW5nIG1pbGxpc2Vjb25kcykgYnkgd2hpY2ggdG8gc2hpZnQgdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuXHJcbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIFNjaGVkdWxlciB0byBydW4gdGhlIGRlbGF5IHRpbWVycyBvbi4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHRpbWVvdXQgc2NoZWR1bGVyIGlzIHVzZWQuXHJcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFRpbWUtc2hpZnRlZCBzZXF1ZW5jZS5cclxuICAgKi9cclxuICBvYnNlcnZhYmxlUHJvdG8uZGVsYXkgPSBmdW5jdGlvbiAoZHVlVGltZSwgc2NoZWR1bGVyKSB7XHJcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSB0aW1lb3V0U2NoZWR1bGVyKTtcclxuICAgIHJldHVybiBkdWVUaW1lIGluc3RhbmNlb2YgRGF0ZSA/XHJcbiAgICAgIG9ic2VydmFibGVEZWxheURhdGUodGhpcywgZHVlVGltZS5nZXRUaW1lKCksIHNjaGVkdWxlcikgOlxyXG4gICAgICBvYnNlcnZhYmxlRGVsYXlUaW1lU3Bhbih0aGlzLCBkdWVUaW1lLCBzY2hlZHVsZXIpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqICBJZ25vcmVzIHZhbHVlcyBmcm9tIGFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hpY2ggYXJlIGZvbGxvd2VkIGJ5IGFub3RoZXIgdmFsdWUgYmVmb3JlIGR1ZVRpbWUuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqICAxIC0gcmVzID0gc291cmNlLnRocm90dGxlKDUwMDApOyAvLyA1IHNlY29uZHNcclxuICAgKiAgMiAtIHJlcyA9IHNvdXJjZS50aHJvdHRsZSg1MDAwLCBzY2hlZHVsZXIpO1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGR1ZVRpbWUgRHVyYXRpb24gb2YgdGhlIHRocm90dGxlIHBlcmlvZCBmb3IgZWFjaCB2YWx1ZSAoc3BlY2lmaWVkIGFzIGFuIGludGVnZXIgZGVub3RpbmcgbWlsbGlzZWNvbmRzKS5cclxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gIFNjaGVkdWxlciB0byBydW4gdGhlIHRocm90dGxlIHRpbWVycyBvbi4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHRpbWVvdXQgc2NoZWR1bGVyIGlzIHVzZWQuXHJcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSB0aHJvdHRsZWQgc2VxdWVuY2UuXHJcbiAgICovXHJcbiAgb2JzZXJ2YWJsZVByb3RvLnRocm90dGxlID0gZnVuY3Rpb24gKGR1ZVRpbWUsIHNjaGVkdWxlcikge1xyXG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gdGltZW91dFNjaGVkdWxlcik7XHJcbiAgICB2YXIgc291cmNlID0gdGhpcztcclxuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgdmFyIGNhbmNlbGFibGUgPSBuZXcgU2VyaWFsRGlzcG9zYWJsZSgpLCBoYXN2YWx1ZSA9IGZhbHNlLCB2YWx1ZSwgaWQgPSAwO1xyXG4gICAgICB2YXIgc3Vic2NyaXB0aW9uID0gc291cmNlLnN1YnNjcmliZShcclxuICAgICAgICBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgaGFzdmFsdWUgPSB0cnVlO1xyXG4gICAgICAgICAgdmFsdWUgPSB4O1xyXG4gICAgICAgICAgaWQrKztcclxuICAgICAgICAgIHZhciBjdXJyZW50SWQgPSBpZCxcclxuICAgICAgICAgICAgZCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xyXG4gICAgICAgICAgY2FuY2VsYWJsZS5zZXREaXNwb3NhYmxlKGQpO1xyXG4gICAgICAgICAgZC5zZXREaXNwb3NhYmxlKHNjaGVkdWxlci5zY2hlZHVsZVdpdGhSZWxhdGl2ZShkdWVUaW1lLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGhhc3ZhbHVlICYmIGlkID09PSBjdXJyZW50SWQgJiYgb2JzZXJ2ZXIub25OZXh0KHZhbHVlKTtcclxuICAgICAgICAgICAgaGFzdmFsdWUgPSBmYWxzZTtcclxuICAgICAgICAgIH0pKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICBjYW5jZWxhYmxlLmRpc3Bvc2UoKTtcclxuICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XHJcbiAgICAgICAgICBoYXN2YWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgaWQrKztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGNhbmNlbGFibGUuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgaGFzdmFsdWUgJiYgb2JzZXJ2ZXIub25OZXh0KHZhbHVlKTtcclxuICAgICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgICAgICBoYXN2YWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgaWQrKztcclxuICAgICAgICB9KTtcclxuICAgICAgcmV0dXJuIG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKHN1YnNjcmlwdGlvbiwgY2FuY2VsYWJsZSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiAgUHJvamVjdHMgZWFjaCBlbGVtZW50IG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgaW50byB6ZXJvIG9yIG1vcmUgd2luZG93cyB3aGljaCBhcmUgcHJvZHVjZWQgYmFzZWQgb24gdGltaW5nIGluZm9ybWF0aW9uLlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lU3BhbiBMZW5ndGggb2YgZWFjaCB3aW5kb3cgKHNwZWNpZmllZCBhcyBhbiBpbnRlZ2VyIGRlbm90aW5nIG1pbGxpc2Vjb25kcykuXHJcbiAgICogQHBhcmFtIHtNaXhlZH0gW3RpbWVTaGlmdE9yU2NoZWR1bGVyXSAgSW50ZXJ2YWwgYmV0d2VlbiBjcmVhdGlvbiBvZiBjb25zZWN1dGl2ZSB3aW5kb3dzIChzcGVjaWZpZWQgYXMgYW4gaW50ZWdlciBkZW5vdGluZyBtaWxsaXNlY29uZHMpLCBvciBhbiBvcHRpb25hbCBzY2hlZHVsZXIgcGFyYW1ldGVyLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgdGltZSBzaGlmdCBjb3JyZXNwb25kcyB0byB0aGUgdGltZVNwYW4gcGFyYW1ldGVyLCByZXN1bHRpbmcgaW4gbm9uLW92ZXJsYXBwaW5nIGFkamFjZW50IHdpbmRvd3MuXHJcbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdICBTY2hlZHVsZXIgdG8gcnVuIHdpbmRvd2luZyB0aW1lcnMgb24uIElmIG5vdCBzcGVjaWZpZWQsIHRoZSB0aW1lb3V0IHNjaGVkdWxlciBpcyB1c2VkLlxyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIG9mIHdpbmRvd3MuXHJcbiAgICovXHJcbiAgb2JzZXJ2YWJsZVByb3RvLndpbmRvd1dpdGhUaW1lID0gZnVuY3Rpb24gKHRpbWVTcGFuLCB0aW1lU2hpZnRPclNjaGVkdWxlciwgc2NoZWR1bGVyKSB7XHJcbiAgICB2YXIgc291cmNlID0gdGhpcywgdGltZVNoaWZ0O1xyXG4gICAgdGltZVNoaWZ0T3JTY2hlZHVsZXIgPT0gbnVsbCAmJiAodGltZVNoaWZ0ID0gdGltZVNwYW4pO1xyXG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gdGltZW91dFNjaGVkdWxlcik7XHJcbiAgICBpZiAodHlwZW9mIHRpbWVTaGlmdE9yU2NoZWR1bGVyID09PSAnbnVtYmVyJykge1xyXG4gICAgICB0aW1lU2hpZnQgPSB0aW1lU2hpZnRPclNjaGVkdWxlcjtcclxuICAgIH0gZWxzZSBpZiAoaXNTY2hlZHVsZXIodGltZVNoaWZ0T3JTY2hlZHVsZXIpKSB7XHJcbiAgICAgIHRpbWVTaGlmdCA9IHRpbWVTcGFuO1xyXG4gICAgICBzY2hlZHVsZXIgPSB0aW1lU2hpZnRPclNjaGVkdWxlcjtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgdmFyIGdyb3VwRGlzcG9zYWJsZSxcclxuICAgICAgICBuZXh0U2hpZnQgPSB0aW1lU2hpZnQsXHJcbiAgICAgICAgbmV4dFNwYW4gPSB0aW1lU3BhbixcclxuICAgICAgICBxID0gW10sXHJcbiAgICAgICAgcmVmQ291bnREaXNwb3NhYmxlLFxyXG4gICAgICAgIHRpbWVyRCA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCksXHJcbiAgICAgICAgdG90YWxUaW1lID0gMDtcclxuICAgICAgICBncm91cERpc3Bvc2FibGUgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSh0aW1lckQpLFxyXG4gICAgICAgIHJlZkNvdW50RGlzcG9zYWJsZSA9IG5ldyBSZWZDb3VudERpc3Bvc2FibGUoZ3JvdXBEaXNwb3NhYmxlKTtcclxuXHJcbiAgICAgICBmdW5jdGlvbiBjcmVhdGVUaW1lciAoKSB7XHJcbiAgICAgICAgdmFyIG0gPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKSxcclxuICAgICAgICAgIGlzU3BhbiA9IGZhbHNlLFxyXG4gICAgICAgICAgaXNTaGlmdCA9IGZhbHNlO1xyXG4gICAgICAgIHRpbWVyRC5zZXREaXNwb3NhYmxlKG0pO1xyXG4gICAgICAgIGlmIChuZXh0U3BhbiA9PT0gbmV4dFNoaWZ0KSB7XHJcbiAgICAgICAgICBpc1NwYW4gPSB0cnVlO1xyXG4gICAgICAgICAgaXNTaGlmdCA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0U3BhbiA8IG5leHRTaGlmdCkge1xyXG4gICAgICAgICAgICBpc1NwYW4gPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpc1NoaWZ0ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG5ld1RvdGFsVGltZSA9IGlzU3BhbiA/IG5leHRTcGFuIDogbmV4dFNoaWZ0LFxyXG4gICAgICAgICAgdHMgPSBuZXdUb3RhbFRpbWUgLSB0b3RhbFRpbWU7XHJcbiAgICAgICAgdG90YWxUaW1lID0gbmV3VG90YWxUaW1lO1xyXG4gICAgICAgIGlmIChpc1NwYW4pIHtcclxuICAgICAgICAgIG5leHRTcGFuICs9IHRpbWVTaGlmdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzU2hpZnQpIHtcclxuICAgICAgICAgIG5leHRTaGlmdCArPSB0aW1lU2hpZnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG0uc2V0RGlzcG9zYWJsZShzY2hlZHVsZXIuc2NoZWR1bGVXaXRoUmVsYXRpdmUodHMsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGlmIChpc1NoaWZ0KSB7XHJcbiAgICAgICAgICAgIHZhciBzID0gbmV3IFN1YmplY3QoKTtcclxuICAgICAgICAgICAgcS5wdXNoKHMpO1xyXG4gICAgICAgICAgICBvYnNlcnZlci5vbk5leHQoYWRkUmVmKHMsIHJlZkNvdW50RGlzcG9zYWJsZSkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaXNTcGFuICYmIHEuc2hpZnQoKS5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgICAgY3JlYXRlVGltZXIoKTtcclxuICAgICAgICB9KSk7XHJcbiAgICAgIH07XHJcbiAgICAgIHEucHVzaChuZXcgU3ViamVjdCgpKTtcclxuICAgICAgb2JzZXJ2ZXIub25OZXh0KGFkZFJlZihxWzBdLCByZWZDb3VudERpc3Bvc2FibGUpKTtcclxuICAgICAgY3JlYXRlVGltZXIoKTtcclxuICAgICAgZ3JvdXBEaXNwb3NhYmxlLmFkZChzb3VyY2Uuc3Vic2NyaWJlKFxyXG4gICAgICAgIGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcS5sZW5ndGg7IGkgPCBsZW47IGkrKykgeyBxW2ldLm9uTmV4dCh4KTsgfVxyXG4gICAgICAgIH0sIFxyXG4gICAgICAgIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcS5sZW5ndGg7IGkgPCBsZW47IGkrKykgeyBxW2ldLm9uRXJyb3IoZSk7IH1cclxuICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XHJcbiAgICAgICAgfSwgXHJcbiAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHsgcVtpXS5vbkNvbXBsZXRlZCgpOyB9XHJcbiAgICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgKSk7XHJcbiAgICAgIHJldHVybiByZWZDb3VudERpc3Bvc2FibGU7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiAgUHJvamVjdHMgZWFjaCBlbGVtZW50IG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgaW50byBhIHdpbmRvdyB0aGF0IGlzIGNvbXBsZXRlZCB3aGVuIGVpdGhlciBpdCdzIGZ1bGwgb3IgYSBnaXZlbiBhbW91bnQgb2YgdGltZSBoYXMgZWxhcHNlZC5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZVNwYW4gTWF4aW11bSB0aW1lIGxlbmd0aCBvZiBhIHdpbmRvdy5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gY291bnQgTWF4aW11bSBlbGVtZW50IGNvdW50IG9mIGEgd2luZG93LlxyXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSAgU2NoZWR1bGVyIHRvIHJ1biB3aW5kb3dpbmcgdGltZXJzIG9uLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgdGltZW91dCBzY2hlZHVsZXIgaXMgdXNlZC5cclxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvZiB3aW5kb3dzLlxyXG4gICAqL1xyXG4gIG9ic2VydmFibGVQcm90by53aW5kb3dXaXRoVGltZU9yQ291bnQgPSBmdW5jdGlvbiAodGltZVNwYW4sIGNvdW50LCBzY2hlZHVsZXIpIHtcclxuICAgIHZhciBzb3VyY2UgPSB0aGlzO1xyXG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gdGltZW91dFNjaGVkdWxlcik7XHJcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgIHZhciB0aW1lckQgPSBuZXcgU2VyaWFsRGlzcG9zYWJsZSgpLFxyXG4gICAgICAgICAgZ3JvdXBEaXNwb3NhYmxlID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUodGltZXJEKSxcclxuICAgICAgICAgIHJlZkNvdW50RGlzcG9zYWJsZSA9IG5ldyBSZWZDb3VudERpc3Bvc2FibGUoZ3JvdXBEaXNwb3NhYmxlKSxcclxuICAgICAgICAgIG4gPSAwLFxyXG4gICAgICAgICAgd2luZG93SWQgPSAwLFxyXG4gICAgICAgICAgcyA9IG5ldyBTdWJqZWN0KCk7XHJcblxyXG4gICAgICBmdW5jdGlvbiBjcmVhdGVUaW1lcihpZCkge1xyXG4gICAgICAgIHZhciBtID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XHJcbiAgICAgICAgdGltZXJELnNldERpc3Bvc2FibGUobSk7XHJcbiAgICAgICAgbS5zZXREaXNwb3NhYmxlKHNjaGVkdWxlci5zY2hlZHVsZVdpdGhSZWxhdGl2ZSh0aW1lU3BhbiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgaWYgKGlkICE9PSB3aW5kb3dJZCkgeyByZXR1cm47IH1cclxuICAgICAgICAgIG4gPSAwO1xyXG4gICAgICAgICAgdmFyIG5ld0lkID0gKyt3aW5kb3dJZDtcclxuICAgICAgICAgIHMub25Db21wbGV0ZWQoKTtcclxuICAgICAgICAgIHMgPSBuZXcgU3ViamVjdCgpO1xyXG4gICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KGFkZFJlZihzLCByZWZDb3VudERpc3Bvc2FibGUpKTtcclxuICAgICAgICAgIGNyZWF0ZVRpbWVyKG5ld0lkKTtcclxuICAgICAgICB9KSk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIG9ic2VydmVyLm9uTmV4dChhZGRSZWYocywgcmVmQ291bnREaXNwb3NhYmxlKSk7XHJcbiAgICAgIGNyZWF0ZVRpbWVyKDApO1xyXG5cclxuICAgICAgZ3JvdXBEaXNwb3NhYmxlLmFkZChzb3VyY2Uuc3Vic2NyaWJlKFxyXG4gICAgICAgIGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICB2YXIgbmV3SWQgPSAwLCBuZXdXaW5kb3cgPSBmYWxzZTtcclxuICAgICAgICAgIHMub25OZXh0KHgpO1xyXG4gICAgICAgICAgaWYgKCsrbiA9PT0gY291bnQpIHtcclxuICAgICAgICAgICAgbmV3V2luZG93ID0gdHJ1ZTtcclxuICAgICAgICAgICAgbiA9IDA7XHJcbiAgICAgICAgICAgIG5ld0lkID0gKyt3aW5kb3dJZDtcclxuICAgICAgICAgICAgcy5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgICAgICBzID0gbmV3IFN1YmplY3QoKTtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KGFkZFJlZihzLCByZWZDb3VudERpc3Bvc2FibGUpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIG5ld1dpbmRvdyAmJiBjcmVhdGVUaW1lcihuZXdJZCk7XHJcbiAgICAgICAgfSwgXHJcbiAgICAgICAgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgIHMub25FcnJvcihlKTtcclxuICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgcy5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICkpO1xyXG4gICAgICByZXR1cm4gcmVmQ291bnREaXNwb3NhYmxlO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqICBQcm9qZWN0cyBlYWNoIGVsZW1lbnQgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBpbnRvIHplcm8gb3IgbW9yZSBidWZmZXJzIHdoaWNoIGFyZSBwcm9kdWNlZCBiYXNlZCBvbiB0aW1pbmcgaW5mb3JtYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAxIC0gcmVzID0geHMuYnVmZmVyV2l0aFRpbWUoMTAwMCwgc2NoZWR1bGVyKTsgLy8gbm9uLW92ZXJsYXBwaW5nIHNlZ21lbnRzIG9mIDEgc2Vjb25kXHJcbiAgICAgKiAgMiAtIHJlcyA9IHhzLmJ1ZmZlcldpdGhUaW1lKDEwMDAsIDUwMCwgc2NoZWR1bGVyOyAvLyBzZWdtZW50cyBvZiAxIHNlY29uZCB3aXRoIHRpbWUgc2hpZnQgMC41IHNlY29uZHNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGltZVNwYW4gTGVuZ3RoIG9mIGVhY2ggYnVmZmVyIChzcGVjaWZpZWQgYXMgYW4gaW50ZWdlciBkZW5vdGluZyBtaWxsaXNlY29uZHMpLlxyXG4gICAgICogQHBhcmFtIHtNaXhlZH0gW3RpbWVTaGlmdE9yU2NoZWR1bGVyXSAgSW50ZXJ2YWwgYmV0d2VlbiBjcmVhdGlvbiBvZiBjb25zZWN1dGl2ZSBidWZmZXJzIChzcGVjaWZpZWQgYXMgYW4gaW50ZWdlciBkZW5vdGluZyBtaWxsaXNlY29uZHMpLCBvciBhbiBvcHRpb25hbCBzY2hlZHVsZXIgcGFyYW1ldGVyLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgdGltZSBzaGlmdCBjb3JyZXNwb25kcyB0byB0aGUgdGltZVNwYW4gcGFyYW1ldGVyLCByZXN1bHRpbmcgaW4gbm9uLW92ZXJsYXBwaW5nIGFkamFjZW50IGJ1ZmZlcnMuXHJcbiAgICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gIFNjaGVkdWxlciB0byBydW4gYnVmZmVyIHRpbWVycyBvbi4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHRpbWVvdXQgc2NoZWR1bGVyIGlzIHVzZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvZiBidWZmZXJzLlxyXG4gICAgICovXHJcbiAgICBvYnNlcnZhYmxlUHJvdG8uYnVmZmVyV2l0aFRpbWUgPSBmdW5jdGlvbiAodGltZVNwYW4sIHRpbWVTaGlmdE9yU2NoZWR1bGVyLCBzY2hlZHVsZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy53aW5kb3dXaXRoVGltZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLnNlbGVjdE1hbnkoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgudG9BcnJheSgpOyB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAgUHJvamVjdHMgZWFjaCBlbGVtZW50IG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgaW50byBhIGJ1ZmZlciB0aGF0IGlzIGNvbXBsZXRlZCB3aGVuIGVpdGhlciBpdCdzIGZ1bGwgb3IgYSBnaXZlbiBhbW91bnQgb2YgdGltZSBoYXMgZWxhcHNlZC5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogIDEgLSByZXMgPSBzb3VyY2UuYnVmZmVyV2l0aFRpbWVPckNvdW50KDUwMDAsIDUwKTsgLy8gNXMgb3IgNTAgaXRlbXMgaW4gYW4gYXJyYXlcclxuICAgICAqICAyIC0gcmVzID0gc291cmNlLmJ1ZmZlcldpdGhUaW1lT3JDb3VudCg1MDAwLCA1MCwgc2NoZWR1bGVyKTsgLy8gNXMgb3IgNTAgaXRlbXMgaW4gYW4gYXJyYXlcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGltZVNwYW4gTWF4aW11bSB0aW1lIGxlbmd0aCBvZiBhIGJ1ZmZlci5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBNYXhpbXVtIGVsZW1lbnQgY291bnQgb2YgYSBidWZmZXIuXHJcbiAgICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gIFNjaGVkdWxlciB0byBydW4gYnVmZmVyaW4gdGltZXJzIG9uLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgdGltZW91dCBzY2hlZHVsZXIgaXMgdXNlZC5cclxuICAgICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIG9mIGJ1ZmZlcnMuXHJcbiAgICAgKi9cclxuICAgIG9ic2VydmFibGVQcm90by5idWZmZXJXaXRoVGltZU9yQ291bnQgPSBmdW5jdGlvbiAodGltZVNwYW4sIGNvdW50LCBzY2hlZHVsZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy53aW5kb3dXaXRoVGltZU9yQ291bnQodGltZVNwYW4sIGNvdW50LCBzY2hlZHVsZXIpLnNlbGVjdE1hbnkoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHgudG9BcnJheSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogIFJlY29yZHMgdGhlIHRpbWUgaW50ZXJ2YWwgYmV0d2VlbiBjb25zZWN1dGl2ZSB2YWx1ZXMgaW4gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogIDEgLSByZXMgPSBzb3VyY2UudGltZUludGVydmFsKCk7XHJcbiAgICogIDIgLSByZXMgPSBzb3VyY2UudGltZUludGVydmFsKFJ4LlNjaGVkdWxlci50aW1lb3V0KTtcclxuICAgKlxyXG4gICAqIEBwYXJhbSBbc2NoZWR1bGVyXSAgU2NoZWR1bGVyIHVzZWQgdG8gY29tcHV0ZSB0aW1lIGludGVydmFscy4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHRpbWVvdXQgc2NoZWR1bGVyIGlzIHVzZWQuXHJcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCB0aW1lIGludGVydmFsIGluZm9ybWF0aW9uIG9uIHZhbHVlcy5cclxuICAgKi9cclxuICBvYnNlcnZhYmxlUHJvdG8udGltZUludGVydmFsID0gZnVuY3Rpb24gKHNjaGVkdWxlcikge1xyXG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XHJcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSB0aW1lb3V0U2NoZWR1bGVyKTtcclxuICAgIHJldHVybiBvYnNlcnZhYmxlRGVmZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgbGFzdCA9IHNjaGVkdWxlci5ub3coKTtcclxuICAgICAgcmV0dXJuIHNvdXJjZS5tYXAoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICB2YXIgbm93ID0gc2NoZWR1bGVyLm5vdygpLCBzcGFuID0gbm93IC0gbGFzdDtcclxuICAgICAgICBsYXN0ID0gbm93O1xyXG4gICAgICAgIHJldHVybiB7IHZhbHVlOiB4LCBpbnRlcnZhbDogc3BhbiB9O1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqICBSZWNvcmRzIHRoZSB0aW1lc3RhbXAgZm9yIGVhY2ggdmFsdWUgaW4gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogIDEgLSByZXMgPSBzb3VyY2UudGltZXN0YW1wKCk7IC8vIHByb2R1Y2VzIHsgdmFsdWU6IHgsIHRpbWVzdGFtcDogdHMgfVxyXG4gICAqICAyIC0gcmVzID0gc291cmNlLnRpbWVzdGFtcChSeC5TY2hlZHVsZXIudGltZW91dCk7XHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gIFNjaGVkdWxlciB1c2VkIHRvIGNvbXB1dGUgdGltZXN0YW1wcy4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHRpbWVvdXQgc2NoZWR1bGVyIGlzIHVzZWQuXHJcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCB0aW1lc3RhbXAgaW5mb3JtYXRpb24gb24gdmFsdWVzLlxyXG4gICAqL1xyXG4gIG9ic2VydmFibGVQcm90by50aW1lc3RhbXAgPSBmdW5jdGlvbiAoc2NoZWR1bGVyKSB7XHJcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSB0aW1lb3V0U2NoZWR1bGVyKTtcclxuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoeCkge1xyXG4gICAgICByZXR1cm4geyB2YWx1ZTogeCwgdGltZXN0YW1wOiBzY2hlZHVsZXIubm93KCkgfTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIHNhbXBsZU9ic2VydmFibGUoc291cmNlLCBzYW1wbGVyKSB7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICB2YXIgYXRFbmQsIHZhbHVlLCBoYXNWYWx1ZTtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIHNhbXBsZVN1YnNjcmliZSgpIHtcclxuICAgICAgICBpZiAoaGFzVmFsdWUpIHtcclxuICAgICAgICAgIGhhc1ZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgICBvYnNlcnZlci5vbk5leHQodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhdEVuZCAmJiBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoXHJcbiAgICAgICAgc291cmNlLnN1YnNjcmliZShmdW5jdGlvbiAobmV3VmFsdWUpIHtcclxuICAgICAgICAgIGhhc1ZhbHVlID0gdHJ1ZTtcclxuICAgICAgICAgIHZhbHVlID0gbmV3VmFsdWU7XHJcbiAgICAgICAgfSwgb2JzZXJ2ZXIub25FcnJvci5iaW5kKG9ic2VydmVyKSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgYXRFbmQgPSB0cnVlO1xyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIHNhbXBsZXIuc3Vic2NyaWJlKHNhbXBsZVN1YnNjcmliZSwgb2JzZXJ2ZXIub25FcnJvci5iaW5kKG9ic2VydmVyKSwgc2FtcGxlU3Vic2NyaWJlKVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiAgU2FtcGxlcyB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBhdCBlYWNoIGludGVydmFsLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiAgMSAtIHJlcyA9IHNvdXJjZS5zYW1wbGUoc2FtcGxlT2JzZXJ2YWJsZSk7IC8vIFNhbXBsZXIgdGljayBzZXF1ZW5jZVxyXG4gICAqICAyIC0gcmVzID0gc291cmNlLnNhbXBsZSg1MDAwKTsgLy8gNSBzZWNvbmRzXHJcbiAgICogIDIgLSByZXMgPSBzb3VyY2Uuc2FtcGxlKDUwMDAsIFJ4LlNjaGVkdWxlci50aW1lb3V0KTsgLy8gNSBzZWNvbmRzXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge01peGVkfSBpbnRlcnZhbE9yU2FtcGxlciBJbnRlcnZhbCBhdCB3aGljaCB0byBzYW1wbGUgKHNwZWNpZmllZCBhcyBhbiBpbnRlZ2VyIGRlbm90aW5nIG1pbGxpc2Vjb25kcykgb3IgU2FtcGxlciBPYnNlcnZhYmxlLlxyXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSAgU2NoZWR1bGVyIHRvIHJ1biB0aGUgc2FtcGxpbmcgdGltZXIgb24uIElmIG5vdCBzcGVjaWZpZWQsIHRoZSB0aW1lb3V0IHNjaGVkdWxlciBpcyB1c2VkLlxyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBTYW1wbGVkIG9ic2VydmFibGUgc2VxdWVuY2UuXHJcbiAgICovXHJcbiAgb2JzZXJ2YWJsZVByb3RvLnNhbXBsZSA9IGZ1bmN0aW9uIChpbnRlcnZhbE9yU2FtcGxlciwgc2NoZWR1bGVyKSB7XHJcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSB0aW1lb3V0U2NoZWR1bGVyKTtcclxuICAgIHJldHVybiB0eXBlb2YgaW50ZXJ2YWxPclNhbXBsZXIgPT09ICdudW1iZXInID9cclxuICAgICAgc2FtcGxlT2JzZXJ2YWJsZSh0aGlzLCBvYnNlcnZhYmxlaW50ZXJ2YWwoaW50ZXJ2YWxPclNhbXBsZXIsIHNjaGVkdWxlcikpIDpcclxuICAgICAgc2FtcGxlT2JzZXJ2YWJsZSh0aGlzLCBpbnRlcnZhbE9yU2FtcGxlcik7XHJcbiAgfTtcclxuXHJcbiAgLyoqXG4gICAqICBSZXR1cm5zIHRoZSBzb3VyY2Ugb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvciB0aGUgb3RoZXIgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBpZiBkdWVUaW1lIGVsYXBzZXMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkdWVUaW1lIEFic29sdXRlIChzcGVjaWZpZWQgYXMgYSBEYXRlIG9iamVjdCkgb3IgcmVsYXRpdmUgdGltZSAoc3BlY2lmaWVkIGFzIGFuIGludGVnZXIgZGVub3RpbmcgbWlsbGlzZWNvbmRzKSB3aGVuIGEgdGltZW91dCBvY2N1cnMuXG4gICAqIEBwYXJhbSB7T2JzZXJ2YWJsZX0gW290aGVyXSAgU2VxdWVuY2UgdG8gcmV0dXJuIGluIGNhc2Ugb2YgYSB0aW1lb3V0LiBJZiBub3Qgc3BlY2lmaWVkLCBhIHRpbWVvdXQgZXJyb3IgdGhyb3dpbmcgc2VxdWVuY2Ugd2lsbCBiZSB1c2VkLlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gIFNjaGVkdWxlciB0byBydW4gdGhlIHRpbWVvdXQgdGltZXJzIG9uLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgdGltZW91dCBzY2hlZHVsZXIgaXMgdXNlZC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBzb3VyY2Ugc2VxdWVuY2Ugc3dpdGNoaW5nIHRvIHRoZSBvdGhlciBzZXF1ZW5jZSBpbiBjYXNlIG9mIGEgdGltZW91dC5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by50aW1lb3V0ID0gZnVuY3Rpb24gKGR1ZVRpbWUsIG90aGVyLCBzY2hlZHVsZXIpIHtcbiAgICAob3RoZXIgPT0gbnVsbCB8fCB0eXBlb2Ygb3RoZXIgPT09ICdzdHJpbmcnKSAmJiAob3RoZXIgPSBvYnNlcnZhYmxlVGhyb3cobmV3IEVycm9yKG90aGVyIHx8ICdUaW1lb3V0JykpKTtcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSB0aW1lb3V0U2NoZWR1bGVyKTtcblxuICAgIHZhciBzb3VyY2UgPSB0aGlzLCBzY2hlZHVsZXJNZXRob2QgPSBkdWVUaW1lIGluc3RhbmNlb2YgRGF0ZSA/XG4gICAgICAnc2NoZWR1bGVXaXRoQWJzb2x1dGUnIDpcbiAgICAgICdzY2hlZHVsZVdpdGhSZWxhdGl2ZSc7XG5cbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICB2YXIgaWQgPSAwLFxuICAgICAgICBvcmlnaW5hbCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpLFxuICAgICAgICBzdWJzY3JpcHRpb24gPSBuZXcgU2VyaWFsRGlzcG9zYWJsZSgpLFxuICAgICAgICBzd2l0Y2hlZCA9IGZhbHNlLFxuICAgICAgICB0aW1lciA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCk7XG5cbiAgICAgIHN1YnNjcmlwdGlvbi5zZXREaXNwb3NhYmxlKG9yaWdpbmFsKTtcblxuICAgICAgZnVuY3Rpb24gY3JlYXRlVGltZXIoKSB7XG4gICAgICAgIHZhciBteUlkID0gaWQ7XG4gICAgICAgIHRpbWVyLnNldERpc3Bvc2FibGUoc2NoZWR1bGVyW3NjaGVkdWxlck1ldGhvZF0oZHVlVGltZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChpZCA9PT0gbXlJZCkge1xuICAgICAgICAgICAgaXNQcm9taXNlKG90aGVyKSAmJiAob3RoZXIgPSBvYnNlcnZhYmxlRnJvbVByb21pc2Uob3RoZXIpKTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5zZXREaXNwb3NhYmxlKG90aGVyLnN1YnNjcmliZShvYnNlcnZlcikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICBjcmVhdGVUaW1lcigpO1xuXG4gICAgICBvcmlnaW5hbC5zZXREaXNwb3NhYmxlKHNvdXJjZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgaWYgKCFzd2l0Y2hlZCkge1xuICAgICAgICAgIGlkKys7XG4gICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KHgpO1xuICAgICAgICAgIGNyZWF0ZVRpbWVyKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICghc3dpdGNoZWQpIHtcbiAgICAgICAgICBpZCsrO1xuICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFzd2l0Y2hlZCkge1xuICAgICAgICAgIGlkKys7XG4gICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKHN1YnNjcmlwdGlvbiwgdGltZXIpO1xuICAgIH0pO1xuICB9O1xuXHJcbiAgLyoqXHJcbiAgICogIEdlbmVyYXRlcyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGJ5IGl0ZXJhdGluZyBhIHN0YXRlIGZyb20gYW4gaW5pdGlhbCBzdGF0ZSB1bnRpbCB0aGUgY29uZGl0aW9uIGZhaWxzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiAgcmVzID0gc291cmNlLmdlbmVyYXRlV2l0aEFic29sdXRlVGltZSgwLFxyXG4gICAqICAgICAgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHJldHVybiB0cnVlOyB9LFxyXG4gICAqICAgICAgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggKyAxOyB9LFxyXG4gICAqICAgICAgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0sXHJcbiAgICogICAgICBmdW5jdGlvbiAoeCkgeyByZXR1cm4gbmV3IERhdGUoKTsgfVxyXG4gICAqICB9KTtcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGluaXRpYWxTdGF0ZSBJbml0aWFsIHN0YXRlLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbmRpdGlvbiBDb25kaXRpb24gdG8gdGVybWluYXRlIGdlbmVyYXRpb24gKHVwb24gcmV0dXJuaW5nIGZhbHNlKS5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlIEl0ZXJhdGlvbiBzdGVwIGZ1bmN0aW9uLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc3VsdFNlbGVjdG9yIFNlbGVjdG9yIGZ1bmN0aW9uIGZvciByZXN1bHRzIHByb2R1Y2VkIGluIHRoZSBzZXF1ZW5jZS5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0aW1lU2VsZWN0b3IgVGltZSBzZWxlY3RvciBmdW5jdGlvbiB0byBjb250cm9sIHRoZSBzcGVlZCBvZiB2YWx1ZXMgYmVpbmcgcHJvZHVjZWQgZWFjaCBpdGVyYXRpb24sIHJldHVybmluZyBEYXRlIHZhbHVlcy5cclxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gIFNjaGVkdWxlciBvbiB3aGljaCB0byBydW4gdGhlIGdlbmVyYXRvciBsb29wLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgdGltZW91dCBzY2hlZHVsZXIgaXMgdXNlZC5cclxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gVGhlIGdlbmVyYXRlZCBzZXF1ZW5jZS5cclxuICAgKi9cclxuICBPYnNlcnZhYmxlLmdlbmVyYXRlV2l0aEFic29sdXRlVGltZSA9IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUsIGNvbmRpdGlvbiwgaXRlcmF0ZSwgcmVzdWx0U2VsZWN0b3IsIHRpbWVTZWxlY3Rvciwgc2NoZWR1bGVyKSB7XHJcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSB0aW1lb3V0U2NoZWR1bGVyKTtcclxuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgdmFyIGZpcnN0ID0gdHJ1ZSxcclxuICAgICAgICBoYXNSZXN1bHQgPSBmYWxzZSxcclxuICAgICAgICByZXN1bHQsXHJcbiAgICAgICAgc3RhdGUgPSBpbml0aWFsU3RhdGUsXHJcbiAgICAgICAgdGltZTtcclxuICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZVJlY3Vyc2l2ZVdpdGhBYnNvbHV0ZShzY2hlZHVsZXIubm93KCksIGZ1bmN0aW9uIChzZWxmKSB7XHJcbiAgICAgICAgaGFzUmVzdWx0ICYmIG9ic2VydmVyLm9uTmV4dChyZXN1bHQpO1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgaWYgKGZpcnN0KSB7XHJcbiAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzdGF0ZSA9IGl0ZXJhdGUoc3RhdGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaGFzUmVzdWx0ID0gY29uZGl0aW9uKHN0YXRlKTtcclxuICAgICAgICAgIGlmIChoYXNSZXN1bHQpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0U2VsZWN0b3Ioc3RhdGUpO1xyXG4gICAgICAgICAgICB0aW1lID0gdGltZVNlbGVjdG9yKHN0YXRlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICBvYnNlcnZlci5vbkVycm9yKGUpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGFzUmVzdWx0KSB7XHJcbiAgICAgICAgICBzZWxmKHRpbWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiAgR2VuZXJhdGVzIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgYnkgaXRlcmF0aW5nIGEgc3RhdGUgZnJvbSBhbiBpbml0aWFsIHN0YXRlIHVudGlsIHRoZSBjb25kaXRpb24gZmFpbHMuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqICByZXMgPSBzb3VyY2UuZ2VuZXJhdGVXaXRoUmVsYXRpdmVUaW1lKDAsXHJcbiAgICogICAgICBmdW5jdGlvbiAoeCkgeyByZXR1cm4gcmV0dXJuIHRydWU7IH0sXHJcbiAgICogICAgICBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCArIDE7IH0sXHJcbiAgICogICAgICBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSxcclxuICAgKiAgICAgIGZ1bmN0aW9uICh4KSB7IHJldHVybiA1MDA7IH1cclxuICAgKiAgKTtcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGluaXRpYWxTdGF0ZSBJbml0aWFsIHN0YXRlLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbmRpdGlvbiBDb25kaXRpb24gdG8gdGVybWluYXRlIGdlbmVyYXRpb24gKHVwb24gcmV0dXJuaW5nIGZhbHNlKS5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlIEl0ZXJhdGlvbiBzdGVwIGZ1bmN0aW9uLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc3VsdFNlbGVjdG9yIFNlbGVjdG9yIGZ1bmN0aW9uIGZvciByZXN1bHRzIHByb2R1Y2VkIGluIHRoZSBzZXF1ZW5jZS5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0aW1lU2VsZWN0b3IgVGltZSBzZWxlY3RvciBmdW5jdGlvbiB0byBjb250cm9sIHRoZSBzcGVlZCBvZiB2YWx1ZXMgYmVpbmcgcHJvZHVjZWQgZWFjaCBpdGVyYXRpb24sIHJldHVybmluZyBpbnRlZ2VyIHZhbHVlcyBkZW5vdGluZyBtaWxsaXNlY29uZHMuXHJcbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdICBTY2hlZHVsZXIgb24gd2hpY2ggdG8gcnVuIHRoZSBnZW5lcmF0b3IgbG9vcC4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHRpbWVvdXQgc2NoZWR1bGVyIGlzIHVzZWQuXHJcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBnZW5lcmF0ZWQgc2VxdWVuY2UuXHJcbiAgICovXHJcbiAgT2JzZXJ2YWJsZS5nZW5lcmF0ZVdpdGhSZWxhdGl2ZVRpbWUgPSBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlLCBjb25kaXRpb24sIGl0ZXJhdGUsIHJlc3VsdFNlbGVjdG9yLCB0aW1lU2VsZWN0b3IsIHNjaGVkdWxlcikge1xyXG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gdGltZW91dFNjaGVkdWxlcik7XHJcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgIHZhciBmaXJzdCA9IHRydWUsXHJcbiAgICAgICAgaGFzUmVzdWx0ID0gZmFsc2UsXHJcbiAgICAgICAgcmVzdWx0LFxyXG4gICAgICAgIHN0YXRlID0gaW5pdGlhbFN0YXRlLFxyXG4gICAgICAgIHRpbWU7XHJcbiAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGVSZWN1cnNpdmVXaXRoUmVsYXRpdmUoMCwgZnVuY3Rpb24gKHNlbGYpIHtcclxuICAgICAgICBoYXNSZXN1bHQgJiYgb2JzZXJ2ZXIub25OZXh0KHJlc3VsdCk7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBpZiAoZmlyc3QpIHtcclxuICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHN0YXRlID0gaXRlcmF0ZShzdGF0ZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBoYXNSZXN1bHQgPSBjb25kaXRpb24oc3RhdGUpO1xyXG4gICAgICAgICAgaWYgKGhhc1Jlc3VsdCkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHRTZWxlY3RvcihzdGF0ZSk7XHJcbiAgICAgICAgICAgIHRpbWUgPSB0aW1lU2VsZWN0b3Ioc3RhdGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChoYXNSZXN1bHQpIHtcclxuICAgICAgICAgIHNlbGYodGltZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqICBUaW1lIHNoaWZ0cyB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBieSBkZWxheWluZyB0aGUgc3Vic2NyaXB0aW9uLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiAgMSAtIHJlcyA9IHNvdXJjZS5kZWxheVN1YnNjcmlwdGlvbig1MDAwKTsgLy8gNXNcclxuICAgKiAgMiAtIHJlcyA9IHNvdXJjZS5kZWxheVN1YnNjcmlwdGlvbig1MDAwLCBSeC5TY2hlZHVsZXIudGltZW91dCk7IC8vIDUgc2Vjb25kc1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGR1ZVRpbWUgQWJzb2x1dGUgb3IgcmVsYXRpdmUgdGltZSB0byBwZXJmb3JtIHRoZSBzdWJzY3JpcHRpb24gYXQuXHJcbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdICBTY2hlZHVsZXIgdG8gcnVuIHRoZSBzdWJzY3JpcHRpb24gZGVsYXkgdGltZXIgb24uIElmIG5vdCBzcGVjaWZpZWQsIHRoZSB0aW1lb3V0IHNjaGVkdWxlciBpcyB1c2VkLlxyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaW1lLXNoaWZ0ZWQgc2VxdWVuY2UuXHJcbiAgICovXHJcbiAgb2JzZXJ2YWJsZVByb3RvLmRlbGF5U3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKGR1ZVRpbWUsIHNjaGVkdWxlcikge1xyXG4gICAgcmV0dXJuIHRoaXMuZGVsYXlXaXRoU2VsZWN0b3Iob2JzZXJ2YWJsZVRpbWVyKGR1ZVRpbWUsIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgPyBzY2hlZHVsZXIgOiB0aW1lb3V0U2NoZWR1bGVyKSwgb2JzZXJ2YWJsZUVtcHR5KTtcclxuICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogIFRpbWUgc2hpZnRzIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIGJhc2VkIG9uIGEgc3Vic2NyaXB0aW9uIGRlbGF5IGFuZCBhIGRlbGF5IHNlbGVjdG9yIGZ1bmN0aW9uIGZvciBlYWNoIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAxIC0gcmVzID0gc291cmNlLmRlbGF5V2l0aFNlbGVjdG9yKGZ1bmN0aW9uICh4KSB7IHJldHVybiBSeC5TY2hlZHVsZXIudGltZXIoNTAwMCk7IH0pOyAvLyB3aXRoIHNlbGVjdG9yIG9ubHlcclxuICAgICAqICAxIC0gcmVzID0gc291cmNlLmRlbGF5V2l0aFNlbGVjdG9yKFJ4Lk9ic2VydmFibGUudGltZXIoMjAwMCksIGZ1bmN0aW9uICh4KSB7IHJldHVybiBSeC5PYnNlcnZhYmxlLnRpbWVyKHgpOyB9KTsgLy8gd2l0aCBkZWxheSBhbmQgc2VsZWN0b3JcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09ic2VydmFibGV9IFtzdWJzY3JpcHRpb25EZWxheV0gIFNlcXVlbmNlIGluZGljYXRpbmcgdGhlIGRlbGF5IGZvciB0aGUgc3Vic2NyaXB0aW9uIHRvIHRoZSBzb3VyY2UuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkZWxheUR1cmF0aW9uU2VsZWN0b3IgU2VsZWN0b3IgZnVuY3Rpb24gdG8gcmV0cmlldmUgYSBzZXF1ZW5jZSBpbmRpY2F0aW5nIHRoZSBkZWxheSBmb3IgZWFjaCBnaXZlbiBlbGVtZW50LlxyXG4gICAgICogQHJldHVybnMge09ic2VydmFibGV9IFRpbWUtc2hpZnRlZCBzZXF1ZW5jZS5cclxuICAgICAqL1xyXG4gICAgb2JzZXJ2YWJsZVByb3RvLmRlbGF5V2l0aFNlbGVjdG9yID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbkRlbGF5LCBkZWxheUR1cmF0aW9uU2VsZWN0b3IpIHtcclxuICAgICAgICB2YXIgc291cmNlID0gdGhpcywgc3ViRGVsYXksIHNlbGVjdG9yO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc3Vic2NyaXB0aW9uRGVsYXkgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgc2VsZWN0b3IgPSBzdWJzY3JpcHRpb25EZWxheTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzdWJEZWxheSA9IHN1YnNjcmlwdGlvbkRlbGF5O1xyXG4gICAgICAgICAgICBzZWxlY3RvciA9IGRlbGF5RHVyYXRpb25TZWxlY3RvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgICAgICB2YXIgZGVsYXlzID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKSwgYXRFbmQgPSBmYWxzZSwgZG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhdEVuZCAmJiBkZWxheXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgc3Vic2NyaXB0aW9uID0gbmV3IFNlcmlhbERpc3Bvc2FibGUoKSwgc3RhcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24uc2V0RGlzcG9zYWJsZShzb3VyY2Uuc3Vic2NyaWJlKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbGF5O1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5ID0gc2VsZWN0b3IoeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcclxuICAgICAgICAgICAgICAgICAgICBkZWxheXMuYWRkKGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGQuc2V0RGlzcG9zYWJsZShkZWxheS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5vbk5leHQoeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5cy5yZW1vdmUoZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCBvYnNlcnZlci5vbkVycm9yLmJpbmQob2JzZXJ2ZXIpLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm9uTmV4dCh4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsYXlzLnJlbW92ZShkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIH0sIG9ic2VydmVyLm9uRXJyb3IuYmluZChvYnNlcnZlciksIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBhdEVuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICBkb25lKCk7XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBpZiAoIXN1YkRlbGF5KSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydCgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnNldERpc3Bvc2FibGUoc3ViRGVsYXkuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydCgpO1xyXG4gICAgICAgICAgICAgICAgfSwgb2JzZXJ2ZXIub25FcnJvci5iaW5kKG9ic2VydmVyKSwgZnVuY3Rpb24gKCkgeyBzdGFydCgpOyB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZShzdWJzY3JpcHRpb24sIGRlbGF5cyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdGhlIHNvdXJjZSBvYnNlcnZhYmxlIHNlcXVlbmNlLCBzd2l0Y2hpbmcgdG8gdGhlIG90aGVyIG9ic2VydmFibGUgc2VxdWVuY2UgaWYgYSB0aW1lb3V0IGlzIHNpZ25hbGVkLlxyXG4gICAgICogQHBhcmFtIHtPYnNlcnZhYmxlfSBbZmlyc3RUaW1lb3V0XSAgT2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHJlcHJlc2VudHMgdGhlIHRpbWVvdXQgZm9yIHRoZSBmaXJzdCBlbGVtZW50LiBJZiBub3QgcHJvdmlkZWQsIHRoaXMgZGVmYXVsdHMgdG8gT2JzZXJ2YWJsZS5uZXZlcigpLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3RpbWVvdXREdXJhdGlvblNlbGVjdG9yXSBTZWxlY3RvciB0byByZXRyaWV2ZSBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgcmVwcmVzZW50cyB0aGUgdGltZW91dCBiZXR3ZWVuIHRoZSBjdXJyZW50IGVsZW1lbnQgYW5kIHRoZSBuZXh0IGVsZW1lbnQuXHJcbiAgICAgKiBAcGFyYW0ge09ic2VydmFibGV9IFtvdGhlcl0gIFNlcXVlbmNlIHRvIHJldHVybiBpbiBjYXNlIG9mIGEgdGltZW91dC4gSWYgbm90IHByb3ZpZGVkLCB0aGlzIGlzIHNldCB0byBPYnNlcnZhYmxlLnRocm93RXhjZXB0aW9uKCkuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gVGhlIHNvdXJjZSBzZXF1ZW5jZSBzd2l0Y2hpbmcgdG8gdGhlIG90aGVyIHNlcXVlbmNlIGluIGNhc2Ugb2YgYSB0aW1lb3V0LlxyXG4gICAgICovXHJcbiAgICBvYnNlcnZhYmxlUHJvdG8udGltZW91dFdpdGhTZWxlY3RvciA9IGZ1bmN0aW9uIChmaXJzdFRpbWVvdXQsIHRpbWVvdXRkdXJhdGlvblNlbGVjdG9yLCBvdGhlcikge1xyXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgdGltZW91dGR1cmF0aW9uU2VsZWN0b3IgPSBmaXJzdFRpbWVvdXQ7XHJcbiAgICAgICAgICBmaXJzdFRpbWVvdXQgPSBvYnNlcnZhYmxlTmV2ZXIoKTtcclxuICAgICAgfVxyXG4gICAgICBvdGhlciB8fCAob3RoZXIgPSBvYnNlcnZhYmxlVGhyb3cobmV3IEVycm9yKCdUaW1lb3V0JykpKTtcclxuICAgICAgdmFyIHNvdXJjZSA9IHRoaXM7XHJcbiAgICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gbmV3IFNlcmlhbERpc3Bvc2FibGUoKSwgdGltZXIgPSBuZXcgU2VyaWFsRGlzcG9zYWJsZSgpLCBvcmlnaW5hbCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xyXG5cclxuICAgICAgICBzdWJzY3JpcHRpb24uc2V0RGlzcG9zYWJsZShvcmlnaW5hbCk7XHJcblxyXG4gICAgICAgIHZhciBpZCA9IDAsIHN3aXRjaGVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHNldFRpbWVyKHRpbWVvdXQpIHtcclxuICAgICAgICAgIHZhciBteUlkID0gaWQ7XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gdGltZXJXaW5zICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlkID09PSBteUlkO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHZhciBkID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XHJcbiAgICAgICAgICB0aW1lci5zZXREaXNwb3NhYmxlKGQpO1xyXG4gICAgICAgICAgZC5zZXREaXNwb3NhYmxlKHRpbWVvdXQuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGltZXJXaW5zKCkgJiYgc3Vic2NyaXB0aW9uLnNldERpc3Bvc2FibGUob3RoZXIuc3Vic2NyaWJlKG9ic2VydmVyKSk7XHJcbiAgICAgICAgICAgIGQuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgfSwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgdGltZXJXaW5zKCkgJiYgb2JzZXJ2ZXIub25FcnJvcihlKTtcclxuICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGltZXJXaW5zKCkgJiYgc3Vic2NyaXB0aW9uLnNldERpc3Bvc2FibGUob3RoZXIuc3Vic2NyaWJlKG9ic2VydmVyKSk7XHJcbiAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgc2V0VGltZXIoZmlyc3RUaW1lb3V0KTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gb2JzZXJ2ZXJXaW5zKCkge1xyXG4gICAgICAgICAgdmFyIHJlcyA9ICFzd2l0Y2hlZDtcclxuICAgICAgICAgIGlmIChyZXMpIHsgaWQrKzsgfVxyXG4gICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG9yaWdpbmFsLnNldERpc3Bvc2FibGUoc291cmNlLnN1YnNjcmliZShmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgaWYgKG9ic2VydmVyV2lucygpKSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm9uTmV4dCh4KTtcclxuICAgICAgICAgICAgdmFyIHRpbWVvdXQ7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgdGltZW91dCA9IHRpbWVvdXRkdXJhdGlvblNlbGVjdG9yKHgpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlKTtcclxuICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2V0VGltZXIoaXNQcm9taXNlKHRpbWVvdXQpID8gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHRpbWVvdXQpIDogdGltZW91dCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgIG9ic2VydmVyV2lucygpICYmIG9ic2VydmVyLm9uRXJyb3IoZSk7XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgb2JzZXJ2ZXJXaW5zKCkgJiYgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKHN1YnNjcmlwdGlvbiwgdGltZXIpO1xyXG4gICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gIC8qKlxyXG4gICAqICBJZ25vcmVzIHZhbHVlcyBmcm9tIGFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hpY2ggYXJlIGZvbGxvd2VkIGJ5IGFub3RoZXIgdmFsdWUgd2l0aGluIGEgY29tcHV0ZWQgdGhyb3R0bGUgZHVyYXRpb24uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqICAxIC0gcmVzID0gc291cmNlLmRlbGF5V2l0aFNlbGVjdG9yKGZ1bmN0aW9uICh4KSB7IHJldHVybiBSeC5TY2hlZHVsZXIudGltZXIoeCArIHgpOyB9KTtcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHRocm90dGxlRHVyYXRpb25TZWxlY3RvciBTZWxlY3RvciBmdW5jdGlvbiB0byByZXRyaWV2ZSBhIHNlcXVlbmNlIGluZGljYXRpbmcgdGhlIHRocm90dGxlIGR1cmF0aW9uIGZvciBlYWNoIGdpdmVuIGVsZW1lbnQuXHJcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSB0aHJvdHRsZWQgc2VxdWVuY2UuXHJcbiAgICovXHJcbiAgb2JzZXJ2YWJsZVByb3RvLnRocm90dGxlV2l0aFNlbGVjdG9yID0gZnVuY3Rpb24gKHRocm90dGxlRHVyYXRpb25TZWxlY3Rvcikge1xyXG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XHJcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgIHZhciB2YWx1ZSwgaGFzVmFsdWUgPSBmYWxzZSwgY2FuY2VsYWJsZSA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCksIGlkID0gMDtcclxuICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHNvdXJjZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICB2YXIgdGhyb3R0bGU7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHRocm90dGxlID0gdGhyb3R0bGVEdXJhdGlvblNlbGVjdG9yKHgpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpc1Byb21pc2UodGhyb3R0bGUpICYmICh0aHJvdHRsZSA9IG9ic2VydmFibGVGcm9tUHJvbWlzZSh0aHJvdHRsZSkpO1xyXG5cclxuICAgICAgICBoYXNWYWx1ZSA9IHRydWU7XHJcbiAgICAgICAgdmFsdWUgPSB4O1xyXG4gICAgICAgIGlkKys7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRpZCA9IGlkLCBkID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XHJcbiAgICAgICAgY2FuY2VsYWJsZS5zZXREaXNwb3NhYmxlKGQpO1xyXG4gICAgICAgIGQuc2V0RGlzcG9zYWJsZSh0aHJvdHRsZS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgaGFzVmFsdWUgJiYgaWQgPT09IGN1cnJlbnRpZCAmJiBvYnNlcnZlci5vbk5leHQodmFsdWUpO1xyXG4gICAgICAgICAgaGFzVmFsdWUgPSBmYWxzZTtcclxuICAgICAgICAgIGQuZGlzcG9zZSgpO1xyXG4gICAgICAgIH0sIG9ic2VydmVyLm9uRXJyb3IuYmluZChvYnNlcnZlciksIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGhhc1ZhbHVlICYmIGlkID09PSBjdXJyZW50aWQgJiYgb2JzZXJ2ZXIub25OZXh0KHZhbHVlKTtcclxuICAgICAgICAgIGhhc1ZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgICBkLmRpc3Bvc2UoKTtcclxuICAgICAgICB9KSk7XHJcbiAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgY2FuY2VsYWJsZS5kaXNwb3NlKCk7XHJcbiAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlKTtcclxuICAgICAgICBoYXNWYWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgIGlkKys7XHJcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjYW5jZWxhYmxlLmRpc3Bvc2UoKTtcclxuICAgICAgICBoYXNWYWx1ZSAmJiBvYnNlcnZlci5vbk5leHQodmFsdWUpO1xyXG4gICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgICAgaGFzVmFsdWUgPSBmYWxzZTtcclxuICAgICAgICBpZCsrO1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKHN1YnNjcmlwdGlvbiwgY2FuY2VsYWJsZSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiAgU2tpcHMgZWxlbWVudHMgZm9yIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24gZnJvbSB0aGUgZW5kIG9mIHRoZSBvYnNlcnZhYmxlIHNvdXJjZSBzZXF1ZW5jZSwgdXNpbmcgdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIgdG8gcnVuIHRpbWVycy5cclxuICAgKlxyXG4gICAqICAxIC0gcmVzID0gc291cmNlLnNraXBMYXN0V2l0aFRpbWUoNTAwMCk7XHJcbiAgICogIDIgLSByZXMgPSBzb3VyY2Uuc2tpcExhc3RXaXRoVGltZSg1MDAwLCBzY2hlZHVsZXIpO1xyXG4gICAqXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogIFRoaXMgb3BlcmF0b3IgYWNjdW11bGF0ZXMgYSBxdWV1ZSB3aXRoIGEgbGVuZ3RoIGVub3VnaCB0byBzdG9yZSBlbGVtZW50cyByZWNlaXZlZCBkdXJpbmcgdGhlIGluaXRpYWwgZHVyYXRpb24gd2luZG93LlxyXG4gICAqICBBcyBtb3JlIGVsZW1lbnRzIGFyZSByZWNlaXZlZCwgZWxlbWVudHMgb2xkZXIgdGhhbiB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uIGFyZSB0YWtlbiBmcm9tIHRoZSBxdWV1ZSBhbmQgcHJvZHVjZWQgb24gdGhlXHJcbiAgICogIHJlc3VsdCBzZXF1ZW5jZS4gVGhpcyBjYXVzZXMgZWxlbWVudHMgdG8gYmUgZGVsYXllZCB3aXRoIGR1cmF0aW9uLlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvbiBEdXJhdGlvbiBmb3Igc2tpcHBpbmcgZWxlbWVudHMgZnJvbSB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZS5cclxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gIFNjaGVkdWxlciB0byBydW4gdGhlIHRpbWVyIG9uLiBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byBSeC5TY2hlZHVsZXIudGltZW91dFxyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggdGhlIGVsZW1lbnRzIHNraXBwZWQgZHVyaW5nIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24gZnJvbSB0aGUgZW5kIG9mIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXHJcbiAgICovXHJcbiAgb2JzZXJ2YWJsZVByb3RvLnNraXBMYXN0V2l0aFRpbWUgPSBmdW5jdGlvbiAoZHVyYXRpb24sIHNjaGVkdWxlcikge1xyXG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gdGltZW91dFNjaGVkdWxlcik7XHJcbiAgICB2YXIgc291cmNlID0gdGhpcztcclxuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgdmFyIHEgPSBbXTtcclxuICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICB2YXIgbm93ID0gc2NoZWR1bGVyLm5vdygpO1xyXG4gICAgICAgIHEucHVzaCh7IGludGVydmFsOiBub3csIHZhbHVlOiB4IH0pO1xyXG4gICAgICAgIHdoaWxlIChxLmxlbmd0aCA+IDAgJiYgbm93IC0gcVswXS5pbnRlcnZhbCA+PSBkdXJhdGlvbikge1xyXG4gICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KHEuc2hpZnQoKS52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LCBvYnNlcnZlci5vbkVycm9yLmJpbmQob2JzZXJ2ZXIpLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG5vdyA9IHNjaGVkdWxlci5ub3coKTtcclxuICAgICAgICB3aGlsZSAocS5sZW5ndGggPiAwICYmIG5vdyAtIHFbMF0uaW50ZXJ2YWwgPj0gZHVyYXRpb24pIHtcclxuICAgICAgICAgIG9ic2VydmVyLm9uTmV4dChxLnNoaWZ0KCkudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqICBSZXR1cm5zIGVsZW1lbnRzIHdpdGhpbiB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uIGZyb20gdGhlIGVuZCBvZiB0aGUgb2JzZXJ2YWJsZSBzb3VyY2Ugc2VxdWVuY2UsIHVzaW5nIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVycyB0byBydW4gdGltZXJzIGFuZCB0byBkcmFpbiB0aGUgY29sbGVjdGVkIGVsZW1lbnRzLlxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICBUaGlzIG9wZXJhdG9yIGFjY3VtdWxhdGVzIGEgcXVldWUgd2l0aCBhIGxlbmd0aCBlbm91Z2ggdG8gc3RvcmUgZWxlbWVudHMgcmVjZWl2ZWQgZHVyaW5nIHRoZSBpbml0aWFsIGR1cmF0aW9uIHdpbmRvdy5cclxuICAgKiAgQXMgbW9yZSBlbGVtZW50cyBhcmUgcmVjZWl2ZWQsIGVsZW1lbnRzIG9sZGVyIHRoYW4gdGhlIHNwZWNpZmllZCBkdXJhdGlvbiBhcmUgdGFrZW4gZnJvbSB0aGUgcXVldWUgYW5kIHByb2R1Y2VkIG9uIHRoZVxyXG4gICAqICByZXN1bHQgc2VxdWVuY2UuIFRoaXMgY2F1c2VzIGVsZW1lbnRzIHRvIGJlIGRlbGF5ZWQgd2l0aCBkdXJhdGlvbi5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gZHVyYXRpb24gRHVyYXRpb24gZm9yIHRha2luZyBlbGVtZW50cyBmcm9tIHRoZSBlbmQgb2YgdGhlIHNlcXVlbmNlLlxyXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSAgU2NoZWR1bGVyIHRvIHJ1biB0aGUgdGltZXIgb24uIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIFJ4LlNjaGVkdWxlci50aW1lb3V0LlxyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggdGhlIGVsZW1lbnRzIHRha2VuIGR1cmluZyB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uIGZyb20gdGhlIGVuZCBvZiB0aGUgc291cmNlIHNlcXVlbmNlLlxyXG4gICAqL1xyXG4gIG9ic2VydmFibGVQcm90by50YWtlTGFzdFdpdGhUaW1lID0gZnVuY3Rpb24gKGR1cmF0aW9uLCBzY2hlZHVsZXIpIHtcclxuICAgIHZhciBzb3VyY2UgPSB0aGlzO1xyXG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gdGltZW91dFNjaGVkdWxlcik7XHJcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgIHZhciBxID0gW107XHJcbiAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgdmFyIG5vdyA9IHNjaGVkdWxlci5ub3coKTtcclxuICAgICAgICBxLnB1c2goeyBpbnRlcnZhbDogbm93LCB2YWx1ZTogeCB9KTtcclxuICAgICAgICB3aGlsZSAocS5sZW5ndGggPiAwICYmIG5vdyAtIHFbMF0uaW50ZXJ2YWwgPj0gZHVyYXRpb24pIHtcclxuICAgICAgICAgIHEuc2hpZnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sIG9ic2VydmVyLm9uRXJyb3IuYmluZChvYnNlcnZlciksIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbm93ID0gc2NoZWR1bGVyLm5vdygpO1xyXG4gICAgICAgIHdoaWxlIChxLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIHZhciBuZXh0ID0gcS5zaGlmdCgpO1xyXG4gICAgICAgICAgaWYgKG5vdyAtIG5leHQuaW50ZXJ2YWwgPD0gZHVyYXRpb24pIHsgb2JzZXJ2ZXIub25OZXh0KG5leHQudmFsdWUpOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogIFJldHVybnMgYW4gYXJyYXkgd2l0aCB0aGUgZWxlbWVudHMgd2l0aGluIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24gZnJvbSB0aGUgZW5kIG9mIHRoZSBvYnNlcnZhYmxlIHNvdXJjZSBzZXF1ZW5jZSwgdXNpbmcgdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIgdG8gcnVuIHRpbWVycy5cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgVGhpcyBvcGVyYXRvciBhY2N1bXVsYXRlcyBhIHF1ZXVlIHdpdGggYSBsZW5ndGggZW5vdWdoIHRvIHN0b3JlIGVsZW1lbnRzIHJlY2VpdmVkIGR1cmluZyB0aGUgaW5pdGlhbCBkdXJhdGlvbiB3aW5kb3cuXHJcbiAgICogIEFzIG1vcmUgZWxlbWVudHMgYXJlIHJlY2VpdmVkLCBlbGVtZW50cyBvbGRlciB0aGFuIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24gYXJlIHRha2VuIGZyb20gdGhlIHF1ZXVlIGFuZCBwcm9kdWNlZCBvbiB0aGVcclxuICAgKiAgcmVzdWx0IHNlcXVlbmNlLiBUaGlzIGNhdXNlcyBlbGVtZW50cyB0byBiZSBkZWxheWVkIHdpdGggZHVyYXRpb24uXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uIER1cmF0aW9uIGZvciB0YWtpbmcgZWxlbWVudHMgZnJvbSB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZS5cclxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gc2NoZWR1bGVyIFNjaGVkdWxlciB0byBydW4gdGhlIHRpbWVyIG9uLiBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byBSeC5TY2hlZHVsZXIudGltZW91dC5cclxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIGEgc2luZ2xlIGFycmF5IHdpdGggdGhlIGVsZW1lbnRzIHRha2VuIGR1cmluZyB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uIGZyb20gdGhlIGVuZCBvZiB0aGUgc291cmNlIHNlcXVlbmNlLlxyXG4gICAqL1xyXG4gIG9ic2VydmFibGVQcm90by50YWtlTGFzdEJ1ZmZlcldpdGhUaW1lID0gZnVuY3Rpb24gKGR1cmF0aW9uLCBzY2hlZHVsZXIpIHtcclxuICAgIHZhciBzb3VyY2UgPSB0aGlzO1xyXG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gdGltZW91dFNjaGVkdWxlcik7XHJcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgIHZhciBxID0gW107XHJcbiAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgdmFyIG5vdyA9IHNjaGVkdWxlci5ub3coKTtcclxuICAgICAgICBxLnB1c2goeyBpbnRlcnZhbDogbm93LCB2YWx1ZTogeCB9KTtcclxuICAgICAgICB3aGlsZSAocS5sZW5ndGggPiAwICYmIG5vdyAtIHFbMF0uaW50ZXJ2YWwgPj0gZHVyYXRpb24pIHtcclxuICAgICAgICAgIHEuc2hpZnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sIG9ic2VydmVyLm9uRXJyb3IuYmluZChvYnNlcnZlciksIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbm93ID0gc2NoZWR1bGVyLm5vdygpLCByZXMgPSBbXTtcclxuICAgICAgICB3aGlsZSAocS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICB2YXIgbmV4dCA9IHEuc2hpZnQoKTtcclxuICAgICAgICAgIGlmIChub3cgLSBuZXh0LmludGVydmFsIDw9IGR1cmF0aW9uKSB7IHJlcy5wdXNoKG5leHQudmFsdWUpOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9ic2VydmVyLm9uTmV4dChyZXMpO1xyXG4gICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogIFRha2VzIGVsZW1lbnRzIGZvciB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBvYnNlcnZhYmxlIHNvdXJjZSBzZXF1ZW5jZSwgdXNpbmcgdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIgdG8gcnVuIHRpbWVycy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogIDEgLSByZXMgPSBzb3VyY2UudGFrZVdpdGhUaW1lKDUwMDAsICBbb3B0aW9uYWwgc2NoZWR1bGVyXSk7XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogIFRoaXMgb3BlcmF0b3IgYWNjdW11bGF0ZXMgYSBxdWV1ZSB3aXRoIGEgbGVuZ3RoIGVub3VnaCB0byBzdG9yZSBlbGVtZW50cyByZWNlaXZlZCBkdXJpbmcgdGhlIGluaXRpYWwgZHVyYXRpb24gd2luZG93LlxyXG4gICAqICBBcyBtb3JlIGVsZW1lbnRzIGFyZSByZWNlaXZlZCwgZWxlbWVudHMgb2xkZXIgdGhhbiB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uIGFyZSB0YWtlbiBmcm9tIHRoZSBxdWV1ZSBhbmQgcHJvZHVjZWQgb24gdGhlXHJcbiAgICogIHJlc3VsdCBzZXF1ZW5jZS4gVGhpcyBjYXVzZXMgZWxlbWVudHMgdG8gYmUgZGVsYXllZCB3aXRoIGR1cmF0aW9uLlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvbiBEdXJhdGlvbiBmb3IgdGFraW5nIGVsZW1lbnRzIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBzZXF1ZW5jZS5cclxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gc2NoZWR1bGVyIFNjaGVkdWxlciB0byBydW4gdGhlIHRpbWVyIG9uLiBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byBSeC5TY2hlZHVsZXIudGltZW91dC5cclxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIHRoZSBlbGVtZW50cyB0YWtlbiBkdXJpbmcgdGhlIHNwZWNpZmllZCBkdXJhdGlvbiBmcm9tIHRoZSBzdGFydCBvZiB0aGUgc291cmNlIHNlcXVlbmNlLlxyXG4gICAqL1xyXG4gIG9ic2VydmFibGVQcm90by50YWtlV2l0aFRpbWUgPSBmdW5jdGlvbiAoZHVyYXRpb24sIHNjaGVkdWxlcikge1xyXG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XHJcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSB0aW1lb3V0U2NoZWR1bGVyKTtcclxuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgcmV0dXJuIG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKHNjaGVkdWxlci5zY2hlZHVsZVdpdGhSZWxhdGl2ZShkdXJhdGlvbiwgb2JzZXJ2ZXIub25Db21wbGV0ZWQuYmluZChvYnNlcnZlcikpLCBzb3VyY2Uuc3Vic2NyaWJlKG9ic2VydmVyKSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiAgU2tpcHMgZWxlbWVudHMgZm9yIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24gZnJvbSB0aGUgc3RhcnQgb2YgdGhlIG9ic2VydmFibGUgc291cmNlIHNlcXVlbmNlLCB1c2luZyB0aGUgc3BlY2lmaWVkIHNjaGVkdWxlciB0byBydW4gdGltZXJzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiAgMSAtIHJlcyA9IHNvdXJjZS5za2lwV2l0aFRpbWUoNTAwMCwgW29wdGlvbmFsIHNjaGVkdWxlcl0pO1xyXG4gICAqXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogIFNwZWNpZnlpbmcgYSB6ZXJvIHZhbHVlIGZvciBkdXJhdGlvbiBkb2Vzbid0IGd1YXJhbnRlZSBubyBlbGVtZW50cyB3aWxsIGJlIGRyb3BwZWQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIHNvdXJjZSBzZXF1ZW5jZS5cclxuICAgKiAgVGhpcyBpcyBhIHNpZGUtZWZmZWN0IG9mIHRoZSBhc3luY2hyb255IGludHJvZHVjZWQgYnkgdGhlIHNjaGVkdWxlciwgd2hlcmUgdGhlIGFjdGlvbiB0aGF0IGNhdXNlcyBjYWxsYmFja3MgZnJvbSB0aGUgc291cmNlIHNlcXVlbmNlIHRvIGJlIGZvcndhcmRlZFxyXG4gICAqICBtYXkgbm90IGV4ZWN1dGUgaW1tZWRpYXRlbHksIGRlc3BpdGUgdGhlIHplcm8gZHVlIHRpbWUuXHJcbiAgICpcclxuICAgKiAgRXJyb3JzIHByb2R1Y2VkIGJ5IHRoZSBzb3VyY2Ugc2VxdWVuY2UgYXJlIGFsd2F5cyBmb3J3YXJkZWQgdG8gdGhlIHJlc3VsdCBzZXF1ZW5jZSwgZXZlbiBpZiB0aGUgZXJyb3Igb2NjdXJzIGJlZm9yZSB0aGUgZHVyYXRpb24uXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uIER1cmF0aW9uIGZvciBza2lwcGluZyBlbGVtZW50cyBmcm9tIHRoZSBzdGFydCBvZiB0aGUgc2VxdWVuY2UuXHJcbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IHNjaGVkdWxlciBTY2hlZHVsZXIgdG8gcnVuIHRoZSB0aW1lciBvbi4gSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gUnguU2NoZWR1bGVyLnRpbWVvdXQuXHJcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCB0aGUgZWxlbWVudHMgc2tpcHBlZCBkdXJpbmcgdGhlIHNwZWNpZmllZCBkdXJhdGlvbiBmcm9tIHRoZSBzdGFydCBvZiB0aGUgc291cmNlIHNlcXVlbmNlLlxyXG4gICAqL1xyXG4gIG9ic2VydmFibGVQcm90by5za2lwV2l0aFRpbWUgPSBmdW5jdGlvbiAoZHVyYXRpb24sIHNjaGVkdWxlcikge1xyXG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XHJcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSB0aW1lb3V0U2NoZWR1bGVyKTtcclxuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgdmFyIG9wZW4gPSBmYWxzZTtcclxuICAgICAgcmV0dXJuIG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKFxyXG4gICAgICAgIHNjaGVkdWxlci5zY2hlZHVsZVdpdGhSZWxhdGl2ZShkdXJhdGlvbiwgZnVuY3Rpb24gKCkgeyBvcGVuID0gdHJ1ZTsgfSksXHJcbiAgICAgICAgc291cmNlLnN1YnNjcmliZShmdW5jdGlvbiAoeCkgeyBvcGVuICYmIG9ic2VydmVyLm9uTmV4dCh4KTsgfSwgb2JzZXJ2ZXIub25FcnJvci5iaW5kKG9ic2VydmVyKSwgb2JzZXJ2ZXIub25Db21wbGV0ZWQuYmluZChvYnNlcnZlcikpKTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqICBTa2lwcyBlbGVtZW50cyBmcm9tIHRoZSBvYnNlcnZhYmxlIHNvdXJjZSBzZXF1ZW5jZSB1bnRpbCB0aGUgc3BlY2lmaWVkIHN0YXJ0IHRpbWUsIHVzaW5nIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVyIHRvIHJ1biB0aW1lcnMuXHJcbiAgICogIEVycm9ycyBwcm9kdWNlZCBieSB0aGUgc291cmNlIHNlcXVlbmNlIGFyZSBhbHdheXMgZm9yd2FyZGVkIHRvIHRoZSByZXN1bHQgc2VxdWVuY2UsIGV2ZW4gaWYgdGhlIGVycm9yIG9jY3VycyBiZWZvcmUgdGhlIHN0YXJ0IHRpbWUuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZXNcclxuICAgKiAgMSAtIHJlcyA9IHNvdXJjZS5za2lwVW50aWxXaXRoVGltZShuZXcgRGF0ZSgpLCBbc2NoZWR1bGVyXSk7XHJcbiAgICogIDIgLSByZXMgPSBzb3VyY2Uuc2tpcFVudGlsV2l0aFRpbWUoNTAwMCwgW3NjaGVkdWxlcl0pO1xyXG4gICAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IHN0YXJ0VGltZSBUaW1lIHRvIHN0YXJ0IHRha2luZyBlbGVtZW50cyBmcm9tIHRoZSBzb3VyY2Ugc2VxdWVuY2UuIElmIHRoaXMgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIERhdGUoKSwgbm8gZWxlbWVudHMgd2lsbCBiZSBza2lwcGVkLlxyXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBTY2hlZHVsZXIgdG8gcnVuIHRoZSB0aW1lciBvbi4gSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gUnguU2NoZWR1bGVyLnRpbWVvdXQuXHJcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCB0aGUgZWxlbWVudHMgc2tpcHBlZCB1bnRpbCB0aGUgc3BlY2lmaWVkIHN0YXJ0IHRpbWUuXHJcbiAgICovXHJcbiAgb2JzZXJ2YWJsZVByb3RvLnNraXBVbnRpbFdpdGhUaW1lID0gZnVuY3Rpb24gKHN0YXJ0VGltZSwgc2NoZWR1bGVyKSB7XHJcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSB0aW1lb3V0U2NoZWR1bGVyKTtcclxuICAgIHZhciBzb3VyY2UgPSB0aGlzLCBzY2hlZHVsZXJNZXRob2QgPSBzdGFydFRpbWUgaW5zdGFuY2VvZiBEYXRlID9cclxuICAgICAgJ3NjaGVkdWxlV2l0aEFic29sdXRlJyA6XHJcbiAgICAgICdzY2hlZHVsZVdpdGhSZWxhdGl2ZSc7XHJcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgIHZhciBvcGVuID0gZmFsc2U7XHJcblxyXG4gICAgICByZXR1cm4gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoXHJcbiAgICAgICAgc2NoZWR1bGVyW3NjaGVkdWxlck1ldGhvZF0oc3RhcnRUaW1lLCBmdW5jdGlvbiAoKSB7IG9wZW4gPSB0cnVlOyB9KSxcclxuICAgICAgICBzb3VyY2Uuc3Vic2NyaWJlKFxyXG4gICAgICAgICAgZnVuY3Rpb24gKHgpIHsgb3BlbiAmJiBvYnNlcnZlci5vbk5leHQoeCk7IH0sXHJcbiAgICAgICAgICBvYnNlcnZlci5vbkVycm9yLmJpbmQob2JzZXJ2ZXIpLFxyXG4gICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQuYmluZChvYnNlcnZlcikpKTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqICBUYWtlcyBlbGVtZW50cyBmb3IgdGhlIHNwZWNpZmllZCBkdXJhdGlvbiB1bnRpbCB0aGUgc3BlY2lmaWVkIGVuZCB0aW1lLCB1c2luZyB0aGUgc3BlY2lmaWVkIHNjaGVkdWxlciB0byBydW4gdGltZXJzLlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyIHwgRGF0ZX0gZW5kVGltZSBUaW1lIHRvIHN0b3AgdGFraW5nIGVsZW1lbnRzIGZyb20gdGhlIHNvdXJjZSBzZXF1ZW5jZS4gSWYgdGhpcyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gbmV3IERhdGUoKSwgdGhlIHJlc3VsdCBzdHJlYW0gd2lsbCBjb21wbGV0ZSBpbW1lZGlhdGVseS5cclxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gU2NoZWR1bGVyIHRvIHJ1biB0aGUgdGltZXIgb24uXHJcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCB0aGUgZWxlbWVudHMgdGFrZW4gdW50aWwgdGhlIHNwZWNpZmllZCBlbmQgdGltZS5cclxuICAgKi9cclxuICBvYnNlcnZhYmxlUHJvdG8udGFrZVVudGlsV2l0aFRpbWUgPSBmdW5jdGlvbiAoZW5kVGltZSwgc2NoZWR1bGVyKSB7XHJcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSB0aW1lb3V0U2NoZWR1bGVyKTtcclxuICAgIHZhciBzb3VyY2UgPSB0aGlzLCBzY2hlZHVsZXJNZXRob2QgPSBlbmRUaW1lIGluc3RhbmNlb2YgRGF0ZSA/XHJcbiAgICAgICdzY2hlZHVsZVdpdGhBYnNvbHV0ZScgOlxyXG4gICAgICAnc2NoZWR1bGVXaXRoUmVsYXRpdmUnO1xyXG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICByZXR1cm4gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoXHJcbiAgICAgICAgc2NoZWR1bGVyW3NjaGVkdWxlck1ldGhvZF0oZW5kVGltZSwgb2JzZXJ2ZXIub25Db21wbGV0ZWQuYmluZChvYnNlcnZlcikpLFxyXG4gICAgICAgIHNvdXJjZS5zdWJzY3JpYmUob2JzZXJ2ZXIpKTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIHRyYW5zZHVjZXIgdG8gdHJhbnNmb3JtIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIFxuICAgKiBAcGFyYW0ge1RyYW5zZHVjZXJ9IHRyYW5zZHVjZXIgQSB0cmFuc2R1Y2VyIHRvIGV4ZWN1dGVcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyB0aGUgcmVzdWx0cyBmcm9tIHRoZSB0cmFuc2R1Y2VyLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnRyYW5zZHVjZSA9IGZ1bmN0aW9uKHRyYW5zZHVjZXIpIHtcbiAgICB2YXIgc291cmNlID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybUZvck9ic2VydmVyKG9ic2VydmVyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgICAgIH0sXG4gICAgICAgIHN0ZXA6IGZ1bmN0aW9uKG9icywgaW5wdXQpIHtcbiAgICAgICAgICByZXR1cm4gb2JzLm9uTmV4dChpbnB1dCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc3VsdDogZnVuY3Rpb24ob2JzKSB7XG4gICAgICAgICAgcmV0dXJuIG9icy5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbihvYnNlcnZlcikge1xuICAgICAgdmFyIHhmb3JtID0gdHJhbnNkdWNlcih0cmFuc2Zvcm1Gb3JPYnNlcnZlcihvYnNlcnZlcikpO1xuICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUoXG4gICAgICAgIGZ1bmN0aW9uKHYpIHsgXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHhmb3JtLnN0ZXAob2JzZXJ2ZXIsIHYpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBcbiAgICAgICAgb2JzZXJ2ZXIub25FcnJvci5iaW5kKG9ic2VydmVyKSwgXG4gICAgICAgIGZ1bmN0aW9uKCkgeyB4Zm9ybS5yZXN1bHQob2JzZXJ2ZXIpOyB9XG4gICAgICApO1xuICAgIH0pO1xuICB9O1xuXHJcbiAgLypcclxuICAgKiBQZXJmb3JtcyBhIGV4Y2x1c2l2ZSB3YWl0aW5nIGZvciB0aGUgZmlyc3QgdG8gZmluaXNoIGJlZm9yZSBzdWJzY3JpYmluZyB0byBhbm90aGVyIG9ic2VydmFibGUuXHJcbiAgICogT2JzZXJ2YWJsZXMgdGhhdCBjb21lIGluIGJldHdlZW4gc3Vic2NyaXB0aW9ucyB3aWxsIGJlIGRyb3BwZWQgb24gdGhlIGZsb29yLlxyXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBIGV4Y2x1c2l2ZSBvYnNlcnZhYmxlIHdpdGggb25seSB0aGUgcmVzdWx0cyB0aGF0IGhhcHBlbiB3aGVuIHN1YnNjcmliZWQuXHJcbiAgICovXHJcbiAgb2JzZXJ2YWJsZVByb3RvLmV4Y2x1c2l2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBzb3VyY2VzID0gdGhpcztcclxuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgdmFyIGhhc0N1cnJlbnQgPSBmYWxzZSxcclxuICAgICAgICBpc1N0b3BwZWQgPSBmYWxzZSxcclxuICAgICAgICBtID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCksXHJcbiAgICAgICAgZyA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCk7XHJcblxyXG4gICAgICBnLmFkZChtKTtcclxuXHJcbiAgICAgIG0uc2V0RGlzcG9zYWJsZShzb3VyY2VzLnN1YnNjcmliZShcclxuICAgICAgICBmdW5jdGlvbiAoaW5uZXJTb3VyY2UpIHtcclxuICAgICAgICAgIGlmICghaGFzQ3VycmVudCkge1xyXG4gICAgICAgICAgICBoYXNDdXJyZW50ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIGlzUHJvbWlzZShpbm5lclNvdXJjZSkgJiYgKGlubmVyU291cmNlID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKGlubmVyU291cmNlKSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgaW5uZXJTdWJzY3JpcHRpb24gPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcclxuICAgICAgICAgICAgZy5hZGQoaW5uZXJTdWJzY3JpcHRpb24pO1xyXG5cclxuICAgICAgICAgICAgaW5uZXJTdWJzY3JpcHRpb24uc2V0RGlzcG9zYWJsZShpbm5lclNvdXJjZS5zdWJzY3JpYmUoXHJcbiAgICAgICAgICAgICAgb2JzZXJ2ZXIub25OZXh0LmJpbmQob2JzZXJ2ZXIpLFxyXG4gICAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IuYmluZChvYnNlcnZlciksXHJcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgZy5yZW1vdmUoaW5uZXJTdWJzY3JpcHRpb24pO1xyXG4gICAgICAgICAgICAgICAgaGFzQ3VycmVudCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcHBlZCAmJiBnLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvYnNlcnZlci5vbkVycm9yLmJpbmQob2JzZXJ2ZXIpLFxyXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGlzU3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgICBpZiAoIWhhc0N1cnJlbnQgJiYgZy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KSk7XHJcblxyXG4gICAgICByZXR1cm4gZztcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qXHJcbiAgICogUGVyZm9ybXMgYSBleGNsdXNpdmUgbWFwIHdhaXRpbmcgZm9yIHRoZSBmaXJzdCB0byBmaW5pc2ggYmVmb3JlIHN1YnNjcmliaW5nIHRvIGFub3RoZXIgb2JzZXJ2YWJsZS5cclxuICAgKiBPYnNlcnZhYmxlcyB0aGF0IGNvbWUgaW4gYmV0d2VlbiBzdWJzY3JpcHRpb25zIHdpbGwgYmUgZHJvcHBlZCBvbiB0aGUgZmxvb3IuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2VsZWN0b3IgU2VsZWN0b3IgdG8gaW52b2tlIGZvciBldmVyeSBpdGVtIGluIHRoZSBjdXJyZW50IHN1YnNjcmlwdGlvbi5cclxuICAgKiBAcGFyYW0ge0FueX0gW3RoaXNBcmddIEFuIG9wdGlvbmFsIGNvbnRleHQgdG8gaW52b2tlIHdpdGggdGhlIHNlbGVjdG9yIHBhcmFtZXRlci5cclxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gZXhjbHVzaXZlIG9ic2VydmFibGUgd2l0aCBvbmx5IHRoZSByZXN1bHRzIHRoYXQgaGFwcGVuIHdoZW4gc3Vic2NyaWJlZC5cclxuICAgKi9cclxuICBvYnNlcnZhYmxlUHJvdG8uZXhjbHVzaXZlTWFwID0gZnVuY3Rpb24gKHNlbGVjdG9yLCB0aGlzQXJnKSB7XHJcbiAgICB2YXIgc291cmNlcyA9IHRoaXM7XHJcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgIHZhciBpbmRleCA9IDAsXHJcbiAgICAgICAgaGFzQ3VycmVudCA9IGZhbHNlLFxyXG4gICAgICAgIGlzU3RvcHBlZCA9IHRydWUsXHJcbiAgICAgICAgbSA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpLFxyXG4gICAgICAgIGcgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpO1xyXG5cclxuICAgICAgZy5hZGQobSk7XHJcblxyXG4gICAgICBtLnNldERpc3Bvc2FibGUoc291cmNlcy5zdWJzY3JpYmUoXHJcbiAgICAgICAgZnVuY3Rpb24gKGlubmVyU291cmNlKSB7XHJcblxyXG4gICAgICAgICAgaWYgKCFoYXNDdXJyZW50KSB7XHJcbiAgICAgICAgICAgIGhhc0N1cnJlbnQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgaW5uZXJTdWJzY3JpcHRpb24gPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcclxuICAgICAgICAgICAgZy5hZGQoaW5uZXJTdWJzY3JpcHRpb24pO1xyXG5cclxuICAgICAgICAgICAgaXNQcm9taXNlKGlubmVyU291cmNlKSAmJiAoaW5uZXJTb3VyY2UgPSBvYnNlcnZhYmxlRnJvbVByb21pc2UoaW5uZXJTb3VyY2UpKTtcclxuXHJcbiAgICAgICAgICAgIGlubmVyU3Vic2NyaXB0aW9uLnNldERpc3Bvc2FibGUoaW5uZXJTb3VyY2Uuc3Vic2NyaWJlKFxyXG4gICAgICAgICAgICAgIGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gc2VsZWN0b3IuY2FsbCh0aGlzQXJnLCB4LCBpbmRleCsrLCBpbm5lclNvdXJjZSk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5vbk5leHQocmVzdWx0KTtcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IuYmluZChvYnNlcnZlciksXHJcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgZy5yZW1vdmUoaW5uZXJTdWJzY3JpcHRpb24pO1xyXG4gICAgICAgICAgICAgICAgaGFzQ3VycmVudCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpc1N0b3BwZWQgJiYgZy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvYnNlcnZlci5vbkVycm9yLmJpbmQob2JzZXJ2ZXIpLFxyXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGlzU3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgICBpZiAoZy5sZW5ndGggPT09IDEgJiYgIWhhc0N1cnJlbnQpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KSk7XHJcbiAgICAgIHJldHVybiBnO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqIFByb3ZpZGVzIGEgc2V0IG9mIGV4dGVuc2lvbiBtZXRob2RzIGZvciB2aXJ0dWFsIHRpbWUgc2NoZWR1bGluZy4gKi9cclxuICBSeC5WaXJ0dWFsVGltZVNjaGVkdWxlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XHJcblxyXG4gICAgZnVuY3Rpb24gbm90SW1wbGVtZW50ZWQoKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBsb2NhbE5vdygpIHtcclxuICAgICAgcmV0dXJuIHRoaXMudG9EYXRlVGltZU9mZnNldCh0aGlzLmNsb2NrKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzY2hlZHVsZU5vdyhzdGF0ZSwgYWN0aW9uKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNjaGVkdWxlQWJzb2x1dGVXaXRoU3RhdGUoc3RhdGUsIHRoaXMuY2xvY2ssIGFjdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVSZWxhdGl2ZShzdGF0ZSwgZHVlVGltZSwgYWN0aW9uKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNjaGVkdWxlUmVsYXRpdmVXaXRoU3RhdGUoc3RhdGUsIHRoaXMudG9SZWxhdGl2ZShkdWVUaW1lKSwgYWN0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzY2hlZHVsZUFic29sdXRlKHN0YXRlLCBkdWVUaW1lLCBhY3Rpb24pIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc2NoZWR1bGVSZWxhdGl2ZVdpdGhTdGF0ZShzdGF0ZSwgdGhpcy50b1JlbGF0aXZlKGR1ZVRpbWUgLSB0aGlzLm5vdygpKSwgYWN0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpbnZva2VBY3Rpb24oc2NoZWR1bGVyLCBhY3Rpb24pIHtcclxuICAgICAgYWN0aW9uKCk7XHJcbiAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XHJcbiAgICB9XHJcblxyXG4gICAgaW5oZXJpdHMoVmlydHVhbFRpbWVTY2hlZHVsZXIsIF9fc3VwZXJfXyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHZpcnR1YWwgdGltZSBzY2hlZHVsZXIgd2l0aCB0aGUgc3BlY2lmaWVkIGluaXRpYWwgY2xvY2sgdmFsdWUgYW5kIGFic29sdXRlIHRpbWUgY29tcGFyZXIuXHJcbiAgICAgKlxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5pdGlhbENsb2NrIEluaXRpYWwgdmFsdWUgZm9yIHRoZSBjbG9jay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmVyIENvbXBhcmVyIHRvIGRldGVybWluZSBjYXVzYWxpdHkgb2YgZXZlbnRzIGJhc2VkIG9uIGFic29sdXRlIHRpbWUuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFZpcnR1YWxUaW1lU2NoZWR1bGVyKGluaXRpYWxDbG9jaywgY29tcGFyZXIpIHtcclxuICAgICAgdGhpcy5jbG9jayA9IGluaXRpYWxDbG9jaztcclxuICAgICAgdGhpcy5jb21wYXJlciA9IGNvbXBhcmVyO1xyXG4gICAgICB0aGlzLmlzRW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICB0aGlzLnF1ZXVlID0gbmV3IFByaW9yaXR5UXVldWUoMTAyNCk7XHJcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMsIGxvY2FsTm93LCBzY2hlZHVsZU5vdywgc2NoZWR1bGVSZWxhdGl2ZSwgc2NoZWR1bGVBYnNvbHV0ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIFZpcnR1YWxUaW1lU2NoZWR1bGVyUHJvdG90eXBlID0gVmlydHVhbFRpbWVTY2hlZHVsZXIucHJvdG90eXBlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHJlbGF0aXZlIHRpbWUgdmFsdWUgdG8gYW4gYWJzb2x1dGUgdGltZSB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhYnNvbHV0ZSBBYnNvbHV0ZSB2aXJ0dWFsIHRpbWUgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmVsYXRpdmUgUmVsYXRpdmUgdmlydHVhbCB0aW1lIHZhbHVlIHRvIGFkZC5cclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gUmVzdWx0aW5nIGFic29sdXRlIHZpcnR1YWwgdGltZSBzdW0gdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIFZpcnR1YWxUaW1lU2NoZWR1bGVyUHJvdG90eXBlLmFkZCA9IG5vdEltcGxlbWVudGVkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgYW4gYWJzb2x1dGUgdGltZSB0byBhIG51bWJlclxyXG4gICAgICogQHBhcmFtIHtBbnl9IFRoZSBhYnNvbHV0ZSB0aW1lLlxyXG4gICAgICogQHJldHVybnMge051bWJlcn0gVGhlIGFic29sdXRlIHRpbWUgaW4gbXNcclxuICAgICAqL1xyXG4gICAgVmlydHVhbFRpbWVTY2hlZHVsZXJQcm90b3R5cGUudG9EYXRlVGltZU9mZnNldCA9IG5vdEltcGxlbWVudGVkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhlIFRpbWVTcGFuIHZhbHVlIHRvIGEgcmVsYXRpdmUgdmlydHVhbCB0aW1lIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVTcGFuIFRpbWVTcGFuIHZhbHVlIHRvIGNvbnZlcnQuXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IENvcnJlc3BvbmRpbmcgcmVsYXRpdmUgdmlydHVhbCB0aW1lIHZhbHVlLlxyXG4gICAgICovXHJcbiAgICBWaXJ0dWFsVGltZVNjaGVkdWxlclByb3RvdHlwZS50b1JlbGF0aXZlID0gbm90SW1wbGVtZW50ZWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTY2hlZHVsZXMgYSBwZXJpb2RpYyBwaWVjZSBvZiB3b3JrIGJ5IGR5bmFtaWNhbGx5IGRpc2NvdmVyaW5nIHRoZSBzY2hlZHVsZXIncyBjYXBhYmlsaXRpZXMuIFRoZSBwZXJpb2RpYyB0YXNrIHdpbGwgYmUgZW11bGF0ZWQgdXNpbmcgcmVjdXJzaXZlIHNjaGVkdWxpbmcuXHJcbiAgICAgKiBAcGFyYW0ge01peGVkfSBzdGF0ZSBJbml0aWFsIHN0YXRlIHBhc3NlZCB0byB0aGUgYWN0aW9uIHVwb24gdGhlIGZpcnN0IGl0ZXJhdGlvbi5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwZXJpb2QgUGVyaW9kIGZvciBydW5uaW5nIHRoZSB3b3JrIHBlcmlvZGljYWxseS5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFjdGlvbiBBY3Rpb24gdG8gYmUgZXhlY3V0ZWQsIHBvdGVudGlhbGx5IHVwZGF0aW5nIHRoZSBzdGF0ZS5cclxuICAgICAqIEByZXR1cm5zIHtEaXNwb3NhYmxlfSBUaGUgZGlzcG9zYWJsZSBvYmplY3QgdXNlZCB0byBjYW5jZWwgdGhlIHNjaGVkdWxlZCByZWN1cnJpbmcgYWN0aW9uIChiZXN0IGVmZm9ydCkuXHJcbiAgICAgKi9cclxuICAgIFZpcnR1YWxUaW1lU2NoZWR1bGVyUHJvdG90eXBlLnNjaGVkdWxlUGVyaW9kaWNXaXRoU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIHBlcmlvZCwgYWN0aW9uKSB7XHJcbiAgICAgIHZhciBzID0gbmV3IFNjaGVkdWxlUGVyaW9kaWNSZWN1cnNpdmUodGhpcywgc3RhdGUsIHBlcmlvZCwgYWN0aW9uKTtcclxuICAgICAgcmV0dXJuIHMuc3RhcnQoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTY2hlZHVsZXMgYW4gYWN0aW9uIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIGR1ZVRpbWUuXHJcbiAgICAgKiBAcGFyYW0ge01peGVkfSBzdGF0ZSBTdGF0ZSBwYXNzZWQgdG8gdGhlIGFjdGlvbiB0byBiZSBleGVjdXRlZC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkdWVUaW1lIFJlbGF0aXZlIHRpbWUgYWZ0ZXIgd2hpY2ggdG8gZXhlY3V0ZSB0aGUgYWN0aW9uLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYWN0aW9uIEFjdGlvbiB0byBiZSBleGVjdXRlZC5cclxuICAgICAqIEByZXR1cm5zIHtEaXNwb3NhYmxlfSBUaGUgZGlzcG9zYWJsZSBvYmplY3QgdXNlZCB0byBjYW5jZWwgdGhlIHNjaGVkdWxlZCBhY3Rpb24gKGJlc3QgZWZmb3J0KS5cclxuICAgICAqL1xyXG4gICAgVmlydHVhbFRpbWVTY2hlZHVsZXJQcm90b3R5cGUuc2NoZWR1bGVSZWxhdGl2ZVdpdGhTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZHVlVGltZSwgYWN0aW9uKSB7XHJcbiAgICAgIHZhciBydW5BdCA9IHRoaXMuYWRkKHRoaXMuY2xvY2ssIGR1ZVRpbWUpO1xyXG4gICAgICByZXR1cm4gdGhpcy5zY2hlZHVsZUFic29sdXRlV2l0aFN0YXRlKHN0YXRlLCBydW5BdCwgYWN0aW9uKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTY2hlZHVsZXMgYW4gYWN0aW9uIHRvIGJlIGV4ZWN1dGVkIGF0IGR1ZVRpbWUuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZHVlVGltZSBSZWxhdGl2ZSB0aW1lIGFmdGVyIHdoaWNoIHRvIGV4ZWN1dGUgdGhlIGFjdGlvbi5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFjdGlvbiBBY3Rpb24gdG8gYmUgZXhlY3V0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7RGlzcG9zYWJsZX0gVGhlIGRpc3Bvc2FibGUgb2JqZWN0IHVzZWQgdG8gY2FuY2VsIHRoZSBzY2hlZHVsZWQgYWN0aW9uIChiZXN0IGVmZm9ydCkuXHJcbiAgICAgKi9cclxuICAgIFZpcnR1YWxUaW1lU2NoZWR1bGVyUHJvdG90eXBlLnNjaGVkdWxlUmVsYXRpdmUgPSBmdW5jdGlvbiAoZHVlVGltZSwgYWN0aW9uKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNjaGVkdWxlUmVsYXRpdmVXaXRoU3RhdGUoYWN0aW9uLCBkdWVUaW1lLCBpbnZva2VBY3Rpb24pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0cyB0aGUgdmlydHVhbCB0aW1lIHNjaGVkdWxlci5cclxuICAgICAqL1xyXG4gICAgVmlydHVhbFRpbWVTY2hlZHVsZXJQcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmICghdGhpcy5pc0VuYWJsZWQpIHtcclxuICAgICAgICB0aGlzLmlzRW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgdmFyIG5leHQgPSB0aGlzLmdldE5leHQoKTtcclxuICAgICAgICAgIGlmIChuZXh0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29tcGFyZXIobmV4dC5kdWVUaW1lLCB0aGlzLmNsb2NrKSA+IDAgJiYgKHRoaXMuY2xvY2sgPSBuZXh0LmR1ZVRpbWUpO1xyXG4gICAgICAgICAgICBuZXh0Lmludm9rZSgpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5pc0VuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IHdoaWxlICh0aGlzLmlzRW5hYmxlZCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wcyB0aGUgdmlydHVhbCB0aW1lIHNjaGVkdWxlci5cclxuICAgICAqL1xyXG4gICAgVmlydHVhbFRpbWVTY2hlZHVsZXJQcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5pc0VuYWJsZWQgPSBmYWxzZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZHZhbmNlcyB0aGUgc2NoZWR1bGVyJ3MgY2xvY2sgdG8gdGhlIHNwZWNpZmllZCB0aW1lLCBydW5uaW5nIGFsbCB3b3JrIHRpbGwgdGhhdCBwb2ludC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIEFic29sdXRlIHRpbWUgdG8gYWR2YW5jZSB0aGUgc2NoZWR1bGVyJ3MgY2xvY2sgdG8uXHJcbiAgICAgKi9cclxuICAgIFZpcnR1YWxUaW1lU2NoZWR1bGVyUHJvdG90eXBlLmFkdmFuY2VUbyA9IGZ1bmN0aW9uICh0aW1lKSB7XHJcbiAgICAgIHZhciBkdWVUb0Nsb2NrID0gdGhpcy5jb21wYXJlcih0aGlzLmNsb2NrLCB0aW1lKTtcclxuICAgICAgaWYgKHRoaXMuY29tcGFyZXIodGhpcy5jbG9jaywgdGltZSkgPiAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGFyZ3VtZW50T3V0T2ZSYW5nZSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGR1ZVRvQ2xvY2sgPT09IDApIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCF0aGlzLmlzRW5hYmxlZCkge1xyXG4gICAgICAgIHRoaXMuaXNFbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICB2YXIgbmV4dCA9IHRoaXMuZ2V0TmV4dCgpO1xyXG4gICAgICAgICAgaWYgKG5leHQgIT09IG51bGwgJiYgdGhpcy5jb21wYXJlcihuZXh0LmR1ZVRpbWUsIHRpbWUpIDw9IDApIHtcclxuICAgICAgICAgICAgdGhpcy5jb21wYXJlcihuZXh0LmR1ZVRpbWUsIHRoaXMuY2xvY2spID4gMCAmJiAodGhpcy5jbG9jayA9IG5leHQuZHVlVGltZSk7XHJcbiAgICAgICAgICAgIG5leHQuaW52b2tlKCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmlzRW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gd2hpbGUgKHRoaXMuaXNFbmFibGVkKTtcclxuICAgICAgICB0aGlzLmNsb2NrID0gdGltZTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkdmFuY2VzIHRoZSBzY2hlZHVsZXIncyBjbG9jayBieSB0aGUgc3BlY2lmaWVkIHJlbGF0aXZlIHRpbWUsIHJ1bm5pbmcgYWxsIHdvcmsgc2NoZWR1bGVkIGZvciB0aGF0IHRpbWVzcGFuLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgUmVsYXRpdmUgdGltZSB0byBhZHZhbmNlIHRoZSBzY2hlZHVsZXIncyBjbG9jayBieS5cclxuICAgICAqL1xyXG4gICAgVmlydHVhbFRpbWVTY2hlZHVsZXJQcm90b3R5cGUuYWR2YW5jZUJ5ID0gZnVuY3Rpb24gKHRpbWUpIHtcclxuICAgICAgdmFyIGR0ID0gdGhpcy5hZGQodGhpcy5jbG9jaywgdGltZSksXHJcbiAgICAgICAgICBkdWVUb0Nsb2NrID0gdGhpcy5jb21wYXJlcih0aGlzLmNsb2NrLCBkdCk7XHJcbiAgICAgIGlmIChkdWVUb0Nsb2NrID4gMCkgeyB0aHJvdyBuZXcgRXJyb3IoYXJndW1lbnRPdXRPZlJhbmdlKTsgfVxyXG4gICAgICBpZiAoZHVlVG9DbG9jayA9PT0gMCkgeyAgcmV0dXJuOyB9XHJcblxyXG4gICAgICB0aGlzLmFkdmFuY2VUbyhkdCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWR2YW5jZXMgdGhlIHNjaGVkdWxlcidzIGNsb2NrIGJ5IHRoZSBzcGVjaWZpZWQgcmVsYXRpdmUgdGltZS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIFJlbGF0aXZlIHRpbWUgdG8gYWR2YW5jZSB0aGUgc2NoZWR1bGVyJ3MgY2xvY2sgYnkuXHJcbiAgICAgKi9cclxuICAgIFZpcnR1YWxUaW1lU2NoZWR1bGVyUHJvdG90eXBlLnNsZWVwID0gZnVuY3Rpb24gKHRpbWUpIHtcclxuICAgICAgdmFyIGR0ID0gdGhpcy5hZGQodGhpcy5jbG9jaywgdGltZSk7XHJcbiAgICAgIGlmICh0aGlzLmNvbXBhcmVyKHRoaXMuY2xvY2ssIGR0KSA+PSAwKSB7IHRocm93IG5ldyBFcnJvcihhcmd1bWVudE91dE9mUmFuZ2UpOyB9XHJcblxyXG4gICAgICB0aGlzLmNsb2NrID0gZHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbmV4dCBzY2hlZHVsZWQgaXRlbSB0byBiZSBleGVjdXRlZC5cclxuICAgICAqIEByZXR1cm5zIHtTY2hlZHVsZWRJdGVtfSBUaGUgbmV4dCBzY2hlZHVsZWQgaXRlbS5cclxuICAgICAqL1xyXG4gICAgVmlydHVhbFRpbWVTY2hlZHVsZXJQcm90b3R5cGUuZ2V0TmV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgd2hpbGUgKHRoaXMucXVldWUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHZhciBuZXh0ID0gdGhpcy5xdWV1ZS5wZWVrKCk7XHJcbiAgICAgICAgaWYgKG5leHQuaXNDYW5jZWxsZWQoKSkge1xyXG4gICAgICAgICAgdGhpcy5xdWV1ZS5kZXF1ZXVlKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiBuZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTY2hlZHVsZXMgYW4gYWN0aW9uIHRvIGJlIGV4ZWN1dGVkIGF0IGR1ZVRpbWUuXHJcbiAgICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gc2NoZWR1bGVyIFNjaGVkdWxlciB0byBleGVjdXRlIHRoZSBhY3Rpb24gb24uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZHVlVGltZSBBYnNvbHV0ZSB0aW1lIGF0IHdoaWNoIHRvIGV4ZWN1dGUgdGhlIGFjdGlvbi5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFjdGlvbiBBY3Rpb24gdG8gYmUgZXhlY3V0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7RGlzcG9zYWJsZX0gVGhlIGRpc3Bvc2FibGUgb2JqZWN0IHVzZWQgdG8gY2FuY2VsIHRoZSBzY2hlZHVsZWQgYWN0aW9uIChiZXN0IGVmZm9ydCkuXHJcbiAgICAgKi9cclxuICAgIFZpcnR1YWxUaW1lU2NoZWR1bGVyUHJvdG90eXBlLnNjaGVkdWxlQWJzb2x1dGUgPSBmdW5jdGlvbiAoZHVlVGltZSwgYWN0aW9uKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNjaGVkdWxlQWJzb2x1dGVXaXRoU3RhdGUoYWN0aW9uLCBkdWVUaW1lLCBpbnZva2VBY3Rpb24pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNjaGVkdWxlcyBhbiBhY3Rpb24gdG8gYmUgZXhlY3V0ZWQgYXQgZHVlVGltZS5cclxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IHN0YXRlIFN0YXRlIHBhc3NlZCB0byB0aGUgYWN0aW9uIHRvIGJlIGV4ZWN1dGVkLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGR1ZVRpbWUgQWJzb2x1dGUgdGltZSBhdCB3aGljaCB0byBleGVjdXRlIHRoZSBhY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY3Rpb24gQWN0aW9uIHRvIGJlIGV4ZWN1dGVkLlxyXG4gICAgICogQHJldHVybnMge0Rpc3Bvc2FibGV9IFRoZSBkaXNwb3NhYmxlIG9iamVjdCB1c2VkIHRvIGNhbmNlbCB0aGUgc2NoZWR1bGVkIGFjdGlvbiAoYmVzdCBlZmZvcnQpLlxyXG4gICAgICovXHJcbiAgICBWaXJ0dWFsVGltZVNjaGVkdWxlclByb3RvdHlwZS5zY2hlZHVsZUFic29sdXRlV2l0aFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlLCBkdWVUaW1lLCBhY3Rpb24pIHtcclxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgZnVuY3Rpb24gcnVuKHNjaGVkdWxlciwgc3RhdGUxKSB7XHJcbiAgICAgICAgc2VsZi5xdWV1ZS5yZW1vdmUoc2kpO1xyXG4gICAgICAgIHJldHVybiBhY3Rpb24oc2NoZWR1bGVyLCBzdGF0ZTEpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgc2kgPSBuZXcgU2NoZWR1bGVkSXRlbSh0aGlzLCBzdGF0ZSwgcnVuLCBkdWVUaW1lLCB0aGlzLmNvbXBhcmVyKTtcclxuICAgICAgdGhpcy5xdWV1ZS5lbnF1ZXVlKHNpKTtcclxuXHJcbiAgICAgIHJldHVybiBzaS5kaXNwb3NhYmxlO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gVmlydHVhbFRpbWVTY2hlZHVsZXI7XHJcbiAgfShTY2hlZHVsZXIpKTtcclxuXHJcbiAgLyoqIFByb3ZpZGVzIGEgdmlydHVhbCB0aW1lIHNjaGVkdWxlciB0aGF0IHVzZXMgRGF0ZSBmb3IgYWJzb2x1dGUgdGltZSBhbmQgbnVtYmVyIGZvciByZWxhdGl2ZSB0aW1lLiAqL1xyXG4gIFJ4Lkhpc3RvcmljYWxTY2hlZHVsZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xyXG4gICAgaW5oZXJpdHMoSGlzdG9yaWNhbFNjaGVkdWxlciwgX19zdXBlcl9fKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaGlzdG9yaWNhbCBzY2hlZHVsZXIgd2l0aCB0aGUgc3BlY2lmaWVkIGluaXRpYWwgY2xvY2sgdmFsdWUuXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbml0aWFsQ2xvY2sgSW5pdGlhbCB2YWx1ZSBmb3IgdGhlIGNsb2NrLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyZXIgQ29tcGFyZXIgdG8gZGV0ZXJtaW5lIGNhdXNhbGl0eSBvZiBldmVudHMgYmFzZWQgb24gYWJzb2x1dGUgdGltZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gSGlzdG9yaWNhbFNjaGVkdWxlcihpbml0aWFsQ2xvY2ssIGNvbXBhcmVyKSB7XHJcbiAgICAgIHZhciBjbG9jayA9IGluaXRpYWxDbG9jayA9PSBudWxsID8gMCA6IGluaXRpYWxDbG9jaztcclxuICAgICAgdmFyIGNtcCA9IGNvbXBhcmVyIHx8IGRlZmF1bHRTdWJDb21wYXJlcjtcclxuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcywgY2xvY2ssIGNtcCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIEhpc3RvcmljYWxTY2hlZHVsZXJQcm90byA9IEhpc3RvcmljYWxTY2hlZHVsZXIucHJvdG90eXBlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHJlbGF0aXZlIHRpbWUgdmFsdWUgdG8gYW4gYWJzb2x1dGUgdGltZSB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhYnNvbHV0ZSBBYnNvbHV0ZSB2aXJ0dWFsIHRpbWUgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmVsYXRpdmUgUmVsYXRpdmUgdmlydHVhbCB0aW1lIHZhbHVlIHRvIGFkZC5cclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gUmVzdWx0aW5nIGFic29sdXRlIHZpcnR1YWwgdGltZSBzdW0gdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIEhpc3RvcmljYWxTY2hlZHVsZXJQcm90by5hZGQgPSBmdW5jdGlvbiAoYWJzb2x1dGUsIHJlbGF0aXZlKSB7XHJcbiAgICAgIHJldHVybiBhYnNvbHV0ZSArIHJlbGF0aXZlO1xyXG4gICAgfTtcclxuXHJcbiAgICBIaXN0b3JpY2FsU2NoZWR1bGVyUHJvdG8udG9EYXRlVGltZU9mZnNldCA9IGZ1bmN0aW9uIChhYnNvbHV0ZSkge1xyXG4gICAgICByZXR1cm4gbmV3IERhdGUoYWJzb2x1dGUpLmdldFRpbWUoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGUgVGltZVNwYW4gdmFsdWUgdG8gYSByZWxhdGl2ZSB2aXJ0dWFsIHRpbWUgdmFsdWUuXHJcbiAgICAgKiBAbWVtYmVyT2YgSGlzdG9yaWNhbFNjaGVkdWxlclxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVTcGFuIFRpbWVTcGFuIHZhbHVlIHRvIGNvbnZlcnQuXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IENvcnJlc3BvbmRpbmcgcmVsYXRpdmUgdmlydHVhbCB0aW1lIHZhbHVlLlxyXG4gICAgICovXHJcbiAgICBIaXN0b3JpY2FsU2NoZWR1bGVyUHJvdG8udG9SZWxhdGl2ZSA9IGZ1bmN0aW9uICh0aW1lU3Bhbikge1xyXG4gICAgICByZXR1cm4gdGltZVNwYW47XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBIaXN0b3JpY2FsU2NoZWR1bGVyO1xyXG4gIH0oUnguVmlydHVhbFRpbWVTY2hlZHVsZXIpKTtcclxuXHJcbiAgdmFyIEFub255bW91c09ic2VydmFibGUgPSBSeC5Bbm9ueW1vdXNPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcclxuICAgIGluaGVyaXRzKEFub255bW91c09ic2VydmFibGUsIF9fc3VwZXJfXyk7XHJcblxyXG4gICAgLy8gRml4IHN1YnNjcmliZXIgdG8gY2hlY2sgZm9yIHVuZGVmaW5lZCBvciBmdW5jdGlvbiByZXR1cm5lZCB0byBkZWNvcmF0ZSBhcyBEaXNwb3NhYmxlXHJcbiAgICBmdW5jdGlvbiBmaXhTdWJzY3JpYmVyKHN1YnNjcmliZXIpIHtcclxuICAgICAgaWYgKHN1YnNjcmliZXIgJiYgdHlwZW9mIHN1YnNjcmliZXIuZGlzcG9zZSA9PT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gc3Vic2NyaWJlcjsgfVxyXG5cclxuICAgICAgcmV0dXJuIHR5cGVvZiBzdWJzY3JpYmVyID09PSAnZnVuY3Rpb24nID9cclxuICAgICAgICBkaXNwb3NhYmxlQ3JlYXRlKHN1YnNjcmliZXIpIDpcclxuICAgICAgICBkaXNwb3NhYmxlRW1wdHk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gQW5vbnltb3VzT2JzZXJ2YWJsZShzdWJzY3JpYmUpIHtcclxuICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEFub255bW91c09ic2VydmFibGUpKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKHN1YnNjcmliZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIHMob2JzZXJ2ZXIpIHtcclxuICAgICAgICB2YXIgc2V0RGlzcG9zYWJsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGF1dG9EZXRhY2hPYnNlcnZlci5zZXREaXNwb3NhYmxlKGZpeFN1YnNjcmliZXIoc3Vic2NyaWJlKGF1dG9EZXRhY2hPYnNlcnZlcikpKTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgaWYgKCFhdXRvRGV0YWNoT2JzZXJ2ZXIuZmFpbChlKSkge1xyXG4gICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB2YXIgYXV0b0RldGFjaE9ic2VydmVyID0gbmV3IEF1dG9EZXRhY2hPYnNlcnZlcihvYnNlcnZlcik7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRUaHJlYWRTY2hlZHVsZXIuc2NoZWR1bGVSZXF1aXJlZCgpKSB7XHJcbiAgICAgICAgICBjdXJyZW50VGhyZWFkU2NoZWR1bGVyLnNjaGVkdWxlKHNldERpc3Bvc2FibGUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzZXREaXNwb3NhYmxlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYXV0b0RldGFjaE9ic2VydmVyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzLCBzKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gQW5vbnltb3VzT2JzZXJ2YWJsZTtcclxuXHJcbiAgfShPYnNlcnZhYmxlKSk7XHJcblxyXG4gICAgLyoqIEBwcml2YXRlICovXHJcbiAgICB2YXIgQXV0b0RldGFjaE9ic2VydmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBpbmhlcml0cyhBdXRvRGV0YWNoT2JzZXJ2ZXIsIF9zdXBlcik7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIEF1dG9EZXRhY2hPYnNlcnZlcihvYnNlcnZlcikge1xyXG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xyXG4gICAgICAgICAgICB0aGlzLm0gPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBBdXRvRGV0YWNoT2JzZXJ2ZXJQcm90b3R5cGUgPSBBdXRvRGV0YWNoT2JzZXJ2ZXIucHJvdG90eXBlO1xyXG5cclxuICAgICAgICBBdXRvRGV0YWNoT2JzZXJ2ZXJQcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgbm9FcnJvciA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5vbk5leHQodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgbm9FcnJvciA9IHRydWU7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW5vRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIEF1dG9EZXRhY2hPYnNlcnZlclByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChleG4pIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIub25FcnJvcihleG4pO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBBdXRvRGV0YWNoT2JzZXJ2ZXJQcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBBdXRvRGV0YWNoT2JzZXJ2ZXJQcm90b3R5cGUuc2V0RGlzcG9zYWJsZSA9IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLm0uc2V0RGlzcG9zYWJsZSh2YWx1ZSk7IH07XHJcbiAgICAgICAgQXV0b0RldGFjaE9ic2VydmVyUHJvdG90eXBlLmdldERpc3Bvc2FibGUgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHRoaXMubS5nZXREaXNwb3NhYmxlKCk7IH07XHJcbiAgICAgICAgLyogQHByaXZhdGUgKi9cclxuICAgICAgICBBdXRvRGV0YWNoT2JzZXJ2ZXJQcm90b3R5cGUuZGlzcG9zYWJsZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMuZ2V0RGlzcG9zYWJsZSgpIDogc2V0RGlzcG9zYWJsZSh2YWx1ZSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgQXV0b0RldGFjaE9ic2VydmVyUHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLm0uZGlzcG9zZSgpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBBdXRvRGV0YWNoT2JzZXJ2ZXI7XHJcbiAgICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcclxuXHJcbiAgdmFyIEdyb3VwZWRPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcclxuICAgIGluaGVyaXRzKEdyb3VwZWRPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xyXG5cclxuICAgIGZ1bmN0aW9uIHN1YnNjcmliZShvYnNlcnZlcikge1xyXG4gICAgICByZXR1cm4gdGhpcy51bmRlcmx5aW5nT2JzZXJ2YWJsZS5zdWJzY3JpYmUob2JzZXJ2ZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEdyb3VwZWRPYnNlcnZhYmxlKGtleSwgdW5kZXJseWluZ09ic2VydmFibGUsIG1lcmdlZERpc3Bvc2FibGUpIHtcclxuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcywgc3Vic2NyaWJlKTtcclxuICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgICAgIHRoaXMudW5kZXJseWluZ09ic2VydmFibGUgPSAhbWVyZ2VkRGlzcG9zYWJsZSA/XHJcbiAgICAgICAgdW5kZXJseWluZ09ic2VydmFibGUgOlxyXG4gICAgICAgIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgICAgcmV0dXJuIG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKG1lcmdlZERpc3Bvc2FibGUuZ2V0RGlzcG9zYWJsZSgpLCB1bmRlcmx5aW5nT2JzZXJ2YWJsZS5zdWJzY3JpYmUob2JzZXJ2ZXIpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gR3JvdXBlZE9ic2VydmFibGU7XHJcbiAgfShPYnNlcnZhYmxlKSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmVwcmVzZW50cyBhbiBvYmplY3QgdGhhdCBpcyBib3RoIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgYXMgd2VsbCBhcyBhbiBvYnNlcnZlci5cclxuICAgICAqICBFYWNoIG5vdGlmaWNhdGlvbiBpcyBicm9hZGNhc3RlZCB0byBhbGwgc3Vic2NyaWJlZCBvYnNlcnZlcnMuXHJcbiAgICAgKi9cclxuICAgIHZhciBTdWJqZWN0ID0gUnguU3ViamVjdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gc3Vic2NyaWJlKG9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgIGNoZWNrRGlzcG9zZWQuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IElubmVyU3Vic2NyaXB0aW9uKHRoaXMsIG9ic2VydmVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5leGNlcHRpb24pIHtcclxuICAgICAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IodGhpcy5leGNlcHRpb24pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGVFbXB0eTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gZGlzcG9zYWJsZUVtcHR5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW5oZXJpdHMoU3ViamVjdCwgX3N1cGVyKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIHN1YmplY3QuXHJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gU3ViamVjdCgpIHtcclxuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3Vic2NyaWJlKTtcclxuICAgICAgICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gZmFsc2UsXHJcbiAgICAgICAgICAgIHRoaXMuaXNTdG9wcGVkID0gZmFsc2UsXHJcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gW107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhZGRQcm9wZXJ0aWVzKFN1YmplY3QucHJvdG90eXBlLCBPYnNlcnZlciwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHN1YmplY3QgaGFzIG9ic2VydmVycyBzdWJzY3JpYmVkIHRvIGl0LlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHN1YmplY3QgaGFzIG9ic2VydmVycyBzdWJzY3JpYmVkIHRvIGl0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgaGFzT2JzZXJ2ZXJzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYnNlcnZlcnMubGVuZ3RoID4gMDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE5vdGlmaWVzIGFsbCBzdWJzY3JpYmVkIG9ic2VydmVycyBhYm91dCB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIG9uQ29tcGxldGVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjaGVja0Rpc3Bvc2VkLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9zID0gdGhpcy5vYnNlcnZlcnMuc2xpY2UoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvc1tpXS5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE5vdGlmaWVzIGFsbCBzdWJzY3JpYmVkIG9ic2VydmVycyBhYm91dCB0aGUgZXhjZXB0aW9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge01peGVkfSBlcnJvciBUaGUgZXhjZXB0aW9uIHRvIHNlbmQgdG8gYWxsIG9ic2VydmVycy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIChleGNlcHRpb24pIHtcclxuICAgICAgICAgICAgICAgIGNoZWNrRGlzcG9zZWQuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3MgPSB0aGlzLm9ic2VydmVycy5zbGljZSgwKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leGNlcHRpb24gPSBleGNlcHRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9zW2ldLm9uRXJyb3IoZXhjZXB0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBOb3RpZmllcyBhbGwgc3Vic2NyaWJlZCBvYnNlcnZlcnMgYWJvdXQgdGhlIGFycml2YWwgb2YgdGhlIHNwZWNpZmllZCBlbGVtZW50IGluIHRoZSBzZXF1ZW5jZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlbmQgdG8gYWxsIG9ic2VydmVycy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIG9uTmV4dDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBjaGVja0Rpc3Bvc2VkLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9zID0gdGhpcy5vYnNlcnZlcnMuc2xpY2UoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9zW2ldLm9uTmV4dCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVW5zdWJzY3JpYmUgYWxsIG9ic2VydmVycyBhbmQgcmVsZWFzZSByZXNvdXJjZXMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBzdWJqZWN0IGZyb20gdGhlIHNwZWNpZmllZCBvYnNlcnZlciBhbmQgb2JzZXJ2YWJsZS5cclxuICAgICAgICAgKiBAcGFyYW0ge09ic2VydmVyfSBvYnNlcnZlciBUaGUgb2JzZXJ2ZXIgdXNlZCB0byBzZW5kIG1lc3NhZ2VzIHRvIHRoZSBzdWJqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JzZXJ2YWJsZX0gb2JzZXJ2YWJsZSBUaGUgb2JzZXJ2YWJsZSB1c2VkIHRvIHN1YnNjcmliZSB0byBtZXNzYWdlcyBzZW50IGZyb20gdGhlIHN1YmplY3QuXHJcbiAgICAgICAgICogQHJldHVybnMge1N1YmplY3R9IFN1YmplY3QgaW1wbGVtZW50ZWQgdXNpbmcgdGhlIGdpdmVuIG9ic2VydmVyIGFuZCBvYnNlcnZhYmxlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFN1YmplY3QuY3JlYXRlID0gZnVuY3Rpb24gKG9ic2VydmVyLCBvYnNlcnZhYmxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQW5vbnltb3VzU3ViamVjdChvYnNlcnZlciwgb2JzZXJ2YWJsZSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIFN1YmplY3Q7XHJcbiAgICB9KE9ic2VydmFibGUpKTtcclxuXHJcbiAgLyoqXHJcbiAgICogIFJlcHJlc2VudHMgdGhlIHJlc3VsdCBvZiBhbiBhc3luY2hyb25vdXMgb3BlcmF0aW9uLlxyXG4gICAqICBUaGUgbGFzdCB2YWx1ZSBiZWZvcmUgdGhlIE9uQ29tcGxldGVkIG5vdGlmaWNhdGlvbiwgb3IgdGhlIGVycm9yIHJlY2VpdmVkIHRocm91Z2ggT25FcnJvciwgaXMgc2VudCB0byBhbGwgc3Vic2NyaWJlZCBvYnNlcnZlcnMuXHJcbiAgICovXHJcbiAgdmFyIEFzeW5jU3ViamVjdCA9IFJ4LkFzeW5jU3ViamVjdCA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XHJcblxyXG4gICAgZnVuY3Rpb24gc3Vic2NyaWJlKG9ic2VydmVyKSB7XHJcbiAgICAgIGNoZWNrRGlzcG9zZWQuY2FsbCh0aGlzKTtcclxuXHJcbiAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcclxuICAgICAgICB0aGlzLm9ic2VydmVycy5wdXNoKG9ic2VydmVyKTtcclxuICAgICAgICByZXR1cm4gbmV3IElubmVyU3Vic2NyaXB0aW9uKHRoaXMsIG9ic2VydmVyKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGV4ID0gdGhpcy5leGNlcHRpb24sXHJcbiAgICAgICAgaHYgPSB0aGlzLmhhc1ZhbHVlLFxyXG4gICAgICAgIHYgPSB0aGlzLnZhbHVlO1xyXG5cclxuICAgICAgaWYgKGV4KSB7XHJcbiAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihleCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoaHYpIHtcclxuICAgICAgICBvYnNlcnZlci5vbk5leHQodik7XHJcbiAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZGlzcG9zYWJsZUVtcHR5O1xyXG4gICAgfVxyXG5cclxuICAgIGluaGVyaXRzKEFzeW5jU3ViamVjdCwgX19zdXBlcl9fKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBzdWJqZWN0IHRoYXQgY2FuIG9ubHkgcmVjZWl2ZSBvbmUgdmFsdWUgYW5kIHRoYXQgdmFsdWUgaXMgY2FjaGVkIGZvciBhbGwgZnV0dXJlIG9ic2VydmF0aW9ucy5cclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBBc3luY1N1YmplY3QoKSB7XHJcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMsIHN1YnNjcmliZSk7XHJcblxyXG4gICAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcclxuICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XHJcbiAgICAgIHRoaXMuaGFzVmFsdWUgPSBmYWxzZTtcclxuICAgICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcclxuICAgICAgdGhpcy5leGNlcHRpb24gPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZFByb3BlcnRpZXMoQXN5bmNTdWJqZWN0LnByb3RvdHlwZSwgT2JzZXJ2ZXIsIHtcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzdWJqZWN0IGhhcyBvYnNlcnZlcnMgc3Vic2NyaWJlZCB0byBpdC5cclxuICAgICAgICogQHJldHVybnMge0Jvb2xlYW59IEluZGljYXRlcyB3aGV0aGVyIHRoZSBzdWJqZWN0IGhhcyBvYnNlcnZlcnMgc3Vic2NyaWJlZCB0byBpdC5cclxuICAgICAgICovXHJcbiAgICAgIGhhc09ic2VydmVyczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNoZWNrRGlzcG9zZWQuY2FsbCh0aGlzKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5vYnNlcnZlcnMubGVuZ3RoID4gMDtcclxuICAgICAgfSxcclxuICAgICAgLyoqXHJcbiAgICAgICAqIE5vdGlmaWVzIGFsbCBzdWJzY3JpYmVkIG9ic2VydmVycyBhYm91dCB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZSwgYWxzbyBjYXVzaW5nIHRoZSBsYXN0IHJlY2VpdmVkIHZhbHVlIHRvIGJlIHNlbnQgb3V0IChpZiBhbnkpLlxyXG4gICAgICAgKi9cclxuICAgICAgb25Db21wbGV0ZWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbywgaSwgbGVuO1xyXG4gICAgICAgIGNoZWNrRGlzcG9zZWQuY2FsbCh0aGlzKTtcclxuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XHJcbiAgICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgICB2YXIgb3MgPSB0aGlzLm9ic2VydmVycy5zbGljZSgwKSxcclxuICAgICAgICAgICAgdiA9IHRoaXMudmFsdWUsXHJcbiAgICAgICAgICAgIGh2ID0gdGhpcy5oYXNWYWx1ZTtcclxuXHJcbiAgICAgICAgICBpZiAoaHYpIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gb3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICBvID0gb3NbaV07XHJcbiAgICAgICAgICAgICAgby5vbk5leHQodik7XHJcbiAgICAgICAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBvcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgIG9zW2ldLm9uQ29tcGxldGVkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB0aGlzLm9ic2VydmVycyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgLyoqXHJcbiAgICAgICAqIE5vdGlmaWVzIGFsbCBzdWJzY3JpYmVkIG9ic2VydmVycyBhYm91dCB0aGUgZXJyb3IuXHJcbiAgICAgICAqIEBwYXJhbSB7TWl4ZWR9IGVycm9yIFRoZSBFcnJvciB0byBzZW5kIHRvIGFsbCBvYnNlcnZlcnMuXHJcbiAgICAgICAqL1xyXG4gICAgICBvbkVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICBjaGVja0Rpc3Bvc2VkLmNhbGwodGhpcyk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xyXG4gICAgICAgICAgdmFyIG9zID0gdGhpcy5vYnNlcnZlcnMuc2xpY2UoMCk7XHJcbiAgICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgICB0aGlzLmV4Y2VwdGlvbiA9IGVycm9yO1xyXG5cclxuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBvc1tpXS5vbkVycm9yKGVycm9yKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB0aGlzLm9ic2VydmVycyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgLyoqXHJcbiAgICAgICAqIFNlbmRzIGEgdmFsdWUgdG8gdGhlIHN1YmplY3QuIFRoZSBsYXN0IHZhbHVlIHJlY2VpdmVkIGJlZm9yZSBzdWNjZXNzZnVsIHRlcm1pbmF0aW9uIHdpbGwgYmUgc2VudCB0byBhbGwgc3Vic2NyaWJlZCBhbmQgZnV0dXJlIG9ic2VydmVycy5cclxuICAgICAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgVGhlIHZhbHVlIHRvIHN0b3JlIGluIHRoZSBzdWJqZWN0LlxyXG4gICAgICAgKi9cclxuICAgICAgb25OZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBjaGVja0Rpc3Bvc2VkLmNhbGwodGhpcyk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNTdG9wcGVkKSB7IHJldHVybjsgfVxyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLmhhc1ZhbHVlID0gdHJ1ZTtcclxuICAgICAgfSxcclxuICAgICAgLyoqXHJcbiAgICAgICAqIFVuc3Vic2NyaWJlIGFsbCBvYnNlcnZlcnMgYW5kIHJlbGVhc2UgcmVzb3VyY2VzLlxyXG4gICAgICAgKi9cclxuICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZXhjZXB0aW9uID0gbnVsbDtcclxuICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIEFzeW5jU3ViamVjdDtcclxuICB9KE9ic2VydmFibGUpKTtcclxuXHJcbiAgdmFyIEFub255bW91c1N1YmplY3QgPSBSeC5Bbm9ueW1vdXNTdWJqZWN0ID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcclxuICAgIGluaGVyaXRzKEFub255bW91c1N1YmplY3QsIF9fc3VwZXJfXyk7XHJcblxyXG4gICAgZnVuY3Rpb24gQW5vbnltb3VzU3ViamVjdChvYnNlcnZlciwgb2JzZXJ2YWJsZSkge1xyXG4gICAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XHJcbiAgICAgIHRoaXMub2JzZXJ2YWJsZSA9IG9ic2VydmFibGU7XHJcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMsIHRoaXMub2JzZXJ2YWJsZS5zdWJzY3JpYmUuYmluZCh0aGlzLm9ic2VydmFibGUpKTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRQcm9wZXJ0aWVzKEFub255bW91c1N1YmplY3QucHJvdG90eXBlLCBPYnNlcnZlciwge1xyXG4gICAgICBvbkNvbXBsZXRlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcclxuICAgICAgfSxcclxuICAgICAgb25FcnJvcjogZnVuY3Rpb24gKGV4Y2VwdGlvbikge1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXIub25FcnJvcihleGNlcHRpb24pO1xyXG4gICAgICB9LFxyXG4gICAgICBvbk5leHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXIub25OZXh0KHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIEFub255bW91c1N1YmplY3Q7XHJcbiAgfShPYnNlcnZhYmxlKSk7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgcm9vdC5SeCA9IFJ4O1xyXG5cclxuICAgICAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBSeDtcclxuICAgICAgICB9KTtcclxuICAgIH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xyXG4gICAgICAgIC8vIGluIE5vZGUuanMgb3IgUmluZ29KU1xyXG4gICAgICAgIGlmIChtb2R1bGVFeHBvcnRzKSB7XHJcbiAgICAgICAgICAgIChmcmVlTW9kdWxlLmV4cG9ydHMgPSBSeCkuUnggPSBSeDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZnJlZUV4cG9ydHMuUnggPSBSeDtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIGluIGEgYnJvd3NlciBvciBSaGlub1xyXG4gICAgICAgIHJvb3QuUnggPSBSeDtcclxuICAgIH1cclxuXHJcbn0uY2FsbCh0aGlzKSk7XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4L2Rpc3QvcnguYWxsLmpzXG4gKiogbW9kdWxlIGlkID0gOVxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0bW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufVxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXJcclxuICAgIF8gPSByZXF1aXJlKCd2ZW5kb3InKS5sb2Rhc2gsXHJcbiAgICBSeCA9IHJlcXVpcmUoJ3NjcmlwdHMvcnguaGVscGVyJyksXHJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnc2NyaXB0cy9hZGFwdG9ycy9yYWN0aXZlLWFkYXB0b3JzLXJ4anMnKSxcclxuICAgIGVuZ2luZSA9IHJlcXVpcmUoJ2VuZ2luZS9lbmdpbmUnKSxcclxuICAgIHBhcnNlciA9IGVuZ2luZS5wYXJzZXIsXHJcbiAgICByZW5kZXJlciA9IGVuZ2luZS5yZW5kZXIsXHJcbiAgICBkaWZmID0gZW5naW5lLmRpZmYsXHJcbiAgICBkaXNwYXRjaGVyID0gcmVxdWlyZSgnZW5naW5lL2Rpc3BhdGNoZXInKTtcclxuXHJcbnJlcXVpcmUoJ3NjcmlwdHMvdHJhbnNpdGlvbnMvcmFjdGl2ZS50cmFuc2l0aW9ucy5mYWRlJyk7XHJcbnJlcXVpcmUoJ3NjcmlwdHMvdHJhbnNpdGlvbnMvcmFjdGl2ZS50cmFuc2l0aW9ucy5mbHknKTtcclxuXHJcbnZhciBlbXB0eVR1bmVOYW1lID0gXCJVbnRpdGxlZCBUdW5lXCI7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHJhY3RpdmUsIGNvbnRleHQpIHtcclxuXHJcbiAgICByZW5kZXJlci5pbml0aWFsaXplKCk7XHJcblxyXG4gICAgdmFyIGxpbmVzID0gW107XHJcblxyXG4gICAgcmFjdGl2ZS5zZXQoXCJ0aXRsZVwiLCBlbXB0eVR1bmVOYW1lKTtcclxuXHJcbiAgICAvL2luY29ycG9yYXRlcyBhbiBlbGVtZW50cyBpbmRleCBpbnRvIGl0cyBvYmplY3RcclxuICAgIGZ1bmN0aW9uIGFkZEluZGV4VG9PYmplY3QoZWxlbWVudCwgaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICByYXc6IGVsZW1lbnQsXHJcbiAgICAgICAgICAgIGk6IGluZGV4XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvL2NvbXBvc2l0aW9uIHJvb3RcclxuICAgIHZhciBtYWluT2JzZXJ2YWJsZSA9IFJ4Lk9ic2VydmFibGUuZnJvbVJhY3RpdmUocmFjdGl2ZSwgJ2lucHV0VmFsdWUnKVxyXG4gICAgICAgIC50aHJvdHRsZSgyNSlcclxuICAgICAgICAuc2VsZWN0TWFueShkaWZmKVxyXG4gICAgICAgIC5tYXAocGFyc2VyKVxyXG4gICAgICAgIC5tYXAocmVuZGVyZXIub25OZXh0KVxyXG4gICAgICAgIC5zdWJzY3JpYmUoZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICBpZiAoIWEuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJhY3RpdmUuc2V0KFwiZXJyb3JzXCIsIFwiXCIpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmFjdGl2ZS5zZXQoXCJlcnJvcnNcIiwgYS5lcnJvcl9kZXRhaWxzLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vaWYoYS5hY3Rpb24gIT0gXCJkZWxcIiljb25zb2xlLmxvZyhhLnBhcnNlZCk7IFxyXG4gICAgICAgICAgICAvKmlmKGEudHlwZV9jbGFzcyA9PT0gXCJkYXRhXCIgJiYgYS5wYXJzZWRbMF0udHlwZSA9PT0gXCJ0aXRsZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIShhLmFjdGlvbiA9PT0gXCJkZWxcIikgJiYgYS5wYXJzZWRbMF0uZGF0YS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhY3RpdmUuc2V0KFwidGl0bGVcIiwgYS5wYXJzZWRbMF0uZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmFjdGl2ZS5zZXQoXCJ0aXRsZVwiLCBlbXB0eVR1bmVOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgfSAgKi9cclxuICAgICAgICB9KTtcclxuXHJcbiAgICB2YXIgb2xkU3RhcnQgPSAtMSwgb2xkU3RvcCA9IC0xO1xyXG4gICAgZnVuY3Rpb24gY2hlY2tUZXh0QXJlYVNlbGVjdGlvbigpIHtcclxuICAgICAgICB2YXIgZmllbGQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImFiY1wiKSxcclxuICAgICAgICAgICAgc3RhcnQgPSBmaWVsZC52YWx1ZS5zdWJzdHIoMCwgZmllbGQuc2VsZWN0aW9uU3RhcnQpLnNwbGl0KFwiXFxuXCIpLmxlbmd0aCxcclxuICAgICAgICAgICAgc3RvcCA9IGZpZWxkLnZhbHVlLnN1YnN0cigwLCBmaWVsZC5zZWxlY3Rpb25FbmQpLnNwbGl0KFwiXFxuXCIpLmxlbmd0aDtcclxuXHJcbiAgICAgICAgaWYoc3RhcnQgIT0gb2xkU3RhcnQgfHwgc3RvcCAhPSBvbGRTdG9wKSB7XHJcbiAgICAgICAgICAgIGRpc3BhdGNoZXIuc2VuZCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInNlbGVjdGlvbi1jaGFuZ2VkXCIsXHJcbiAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcbiAgICAgICAgICAgICAgICBzdG9wOiBzdG9wXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBvbGRTdGFydCA9IHN0YXJ0O1xyXG4gICAgICAgICAgICBvbGRTdG9wID0gc3RvcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy9oYW5kbGUgZXZlbnRzXHJcbiAgICByYWN0aXZlLm9uKHtcclxuICAgICAgICBcIm5hdmlnYXRlX2JhY2tcIjogZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBcIlwiO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJlZGl0b3JfbW91c2V1cFwiOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGZpZWxkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJhYmNcIik7XHJcbiAgICAgICAgICAgIGNoZWNrVGV4dEFyZWFTZWxlY3Rpb24oKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZWRpdG9yX2tleXVwXCI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgZmllbGQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImFiY1wiKTtcclxuICAgICAgICAgICAgaWYgKGZpZWxkLnNjcm9sbEhlaWdodCA+IGZpZWxkLmNsaWVudEhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJncm93XCIpO1xyXG4gICAgICAgICAgICAgICAgZmllbGQuc3R5bGUuaGVpZ2h0ID0gZmllbGQuc2Nyb2xsSGVpZ2h0ICsgXCJweFwiO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjaGVja1RleHRBcmVhU2VsZWN0aW9uKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImFwcF9tb3VzZXVwXCI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBjaGVja1RleHRBcmVhU2VsZWN0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9hcHAvZWRpdG9yL2VkaXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDExXG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJkZWZpbmUgY2Fubm90IGJlIHVzZWQgaW5kaXJlY3RcIik7IH07XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spL2J1aWxkaW4vYW1kLWRlZmluZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgJCA9IHJlcXVpcmUoXCJ2ZW5kb3JcIikuanF1ZXJ5O1xyXG5cclxudmFyXHJcbiAgICBSeCA9IHJlcXVpcmUoJ3NjcmlwdHMvcnguaGVscGVyJyksXHJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnc2NyaXB0cy9hZGFwdG9ycy9yYWN0aXZlLWFkYXB0b3JzLXJ4anMnKSxcclxuICAgIGZhZGUgPSByZXF1aXJlKCdzY3JpcHRzL3RyYW5zaXRpb25zL3JhY3RpdmUudHJhbnNpdGlvbnMuZmFkZScpLFxyXG4gICAgZmx5ID0gcmVxdWlyZSgnc2NyaXB0cy90cmFuc2l0aW9ucy9yYWN0aXZlLnRyYW5zaXRpb25zLmZseScpLFxyXG4gICAgdG9hc3RyID0gcmVxdWlyZSgndmVuZG9yJykudG9hc3RyO1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocmFjdGl2ZSwgY29udGV4dCkge1xyXG5cclxuICAgIHJhY3RpdmUuc2V0KFwibG9nZ2VkSW5cIiwgZmFsc2UpO1xyXG5cclxuICAgIHJhY3RpdmUub24oJ25ld190dW5lJywgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9IFwiZWRpdG9yXCI7XHJcbiAgICB9KTtcclxuXHJcbiAgICAkLmdldEpTT04oXCIvYXBpL3R1bmVzXCIpXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgICAgICByYWN0aXZlLnNldChcInR1bmVOYW1lc1wiLCBkYXRhKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAkLmdldEpTT04oXCIvYXBpL3VzZXIvY3VycmVudFwiKVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJDVVJSRU5UIFVTRVJcIiwgZGF0YSk7XHJcbiAgICAgICAgICAgIHJhY3RpdmUuc2V0KFwibG9nZ2VkSW5cIiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHJhY3RpdmUuc2V0KFwidXNlclwiLCBkYXRhKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICByYWN0aXZlLnNldChcImZpbHRlclR1bmVOYW1lc1wiLCBmdW5jdGlvbih0dW5lTmFtZXMsIGZpbHRlcikge1xyXG4gICAgICAgIGlmIChmaWx0ZXIubGVuZ3RoIDw9IDApIHJldHVybiB0dW5lTmFtZXM7XHJcbiAgICAgICAgcmV0dXJuIHR1bmVOYW1lcy5maWx0ZXIoZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYS5uYW1lLnRvTG93ZXJDYXNlKCkubGFzdEluZGV4T2YoZmlsdGVyLnRvTG93ZXJDYXNlKCksIDApID09PSAwO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gdG9hc3RyLnN1Y2Nlc3MoXCJZQVlcIik7XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2FwcC9ob21lL2hvbWUuanNcbiAqKiBtb2R1bGUgaWQgPSAxM1xuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0cGFyc2VyOiByZXF1aXJlKCcuL3BhcnNlcicpLFxyXG5cdHJlbmRlcjogcmVxdWlyZSgnLi9yZW5kZXInKSxcclxuXHRkaWZmOiByZXF1aXJlKCcuL2RpZmYnKVxyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9lbmdpbmUvZW5naW5lLmpzXG4gKiogbW9kdWxlIGlkID0gMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyIsInZhciBSeCA9IHJlcXVpcmUoJ3ZlbmRvcicpLlJ4LFxyXG5cdF8gPSByZXF1aXJlKCd2ZW5kb3InKS5sb2Rhc2g7XHJcblxyXG52YXIgc3Vic2NyaWJlcnMgPSBbXTtcclxuXHJcbmZ1bmN0aW9uIHNlbmQoZGF0YSkge1xyXG5cdC8vY29uc29sZS5sb2coXCJESVNQQVRDSFwiLCBkYXRhKTtcclxuXHRfKHN1YnNjcmliZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKHN1Yikge1xyXG5cdFx0c3ViKGRhdGEpO1xyXG5cdH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdWJzY3JpYmUoZnVuYykge1xyXG5cdHN1YnNjcmliZXJzLnB1c2goZnVuYyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cdHN1YnNjcmliZTogc3Vic2NyaWJlLFxyXG5cdHNlbmQ6IHNlbmRcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZW5naW5lL2Rpc3BhdGNoZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxNVxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIiwibW9kdWxlLmV4cG9ydHM9e1widlwiOjEsXCJ0XCI6W3tcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcImhlYWRlciByb3dcIn0sXCJ0MVwiOlwiZmFkZVwiLFwidlwiOntcIm1vdXNldXBcIjpcImFwcF9tb3VzZXVwXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJiYWNrLWJ1dHRvblwifSxcInZcIjp7XCJjbGlja1wiOlwibmF2aWdhdGVfYmFja1wifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJwXCIsXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiaVwiLFwiYVwiOntcImNsYXNzXCI6XCJmYSBmYS1hcnJvdy1sZWZ0XCJ9fV19XX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwiY2VudHJhbC1tZW51XCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImgzXCIsXCJhXCI6e1wiY2xhc3NcIjpcInR1bmUtdGl0bGVcIn0sXCJmXCI6W3tcInRcIjoyLFwiclwiOlwidGl0bGVcIn1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImJyXCJ9LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcImZsYXQtYnV0dG9uXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcInBcIixcImZcIjpbXCJGaWxlXCJdfV19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcImZsYXQtYnV0dG9uXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcInBcIixcImZcIjpbXCJFZGl0XCJdfV19XX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwidXNlci1ib3hcIn0sXCJmXCI6W3tcInRcIjo0LFwiblwiOjUwLFwieFwiOntcInJcIjpbXCJsb2dnZWRJblwiXSxcInNcIjpcIl8wPT09ZmFsc2VcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiYVwiLFwiYVwiOntcImhyZWZcIjpcIi9hdXRoL2dvb2dsZVwiLFwiY2xhc3NcIjpcImdvb2dsZS1idXR0b25cIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwic3BhblwiLFwiYVwiOntcImNsYXNzXCI6XCJmYSBmYS1nb29nbGUtcGx1c1wifX0sXCIgR29vZ2xlXCJdfV19LHtcInRcIjo0LFwiblwiOjUxLFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcInNwYW5cIixcImZcIjpbXCJIaSBcIix7XCJ0XCI6MixcInJcIjpcInVzZXIubmFtZS5naXZlbk5hbWVcIn1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImFcIixcImFcIjp7XCJocmVmXCI6XCIvbG9nb3V0XCJ9LFwiZlwiOltcIkxvZyBvdXRcIl19XSxcInhcIjp7XCJyXCI6W1wibG9nZ2VkSW5cIl0sXCJzXCI6XCJfMD09PWZhbHNlXCJ9fV19XX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwicm93IHRvb2xiYXJcIn0sXCJ2XCI6e1wibW91c2V1cFwiOlwiYXBwX21vdXNldXBcIn0sXCJmXCI6W3tcInRcIjoyLFwiclwiOlwiZXJyb3JzXCJ9XX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwicm93IGVkaXRvclwifSxcInQxXCI6XCJmYWRlXCIsXCJ2XCI6e1wibW91c2V1cFwiOlwiYXBwX21vdXNldXBcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcImNvbHVtbiB0aGlyZFwiLFwiaWRcIjpcImFiYy1jb250YWluZXJcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwidGV4dGFyZWFcIixcImFcIjp7XCJpZFwiOlwiYWJjXCIsXCJ2YWx1ZVwiOlt7XCJ0XCI6MixcInJcIjpcImlucHV0VmFsdWVcIn1dLFwicGxhY2Vob2xkZXJcIjpcIlN0YXJ0IHR5cGluZyBhIHR1bmUuLlwiLFwic3BlbGxjaGVja1wiOlwiZmFsc2VcIn0sXCJ2XCI6e1wia2V5dXBcIjpcImVkaXRvcl9rZXl1cFwiLFwibW91c2V1cFwiOlwiZWRpdG9yX21vdXNldXBcIixcInBhc3RlXCI6XCJlZGl0b3JfcGFzdGVcIn19XX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwiY29sdW1uIHR3by10aGlyZHNcIixcImlkXCI6XCJjYW52YXNcIn0sXCJmXCI6W119XX1dfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vYXBwL2VkaXRvci9lZGl0b3IuaHRtbFxuICoqIG1vZHVsZSBpZCA9IDE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cz17XCJ2XCI6MSxcInRcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwiaGVhZGVyIHJvdyBjb2xvdXJlZFwifSxcInQxXCI6XCJmYWRlXCIsXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcImNlbnRyYWwtbWVudVwifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJoMVwiLFwiZlwiOltcIldlbGNvbWUgdG8gV2ViQUJDXCJdfSx7XCJ0XCI6NyxcImVcIjpcInNtYWxsXCIsXCJmXCI6W1wiVmVyc2lvbiAwLjAuMVwiXX1dfSxcIiBcIl19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcInJvdyBlZGl0b3JcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcImNvbHVtbiBxdWFydGVyIHJpZ2h0LWRpdmlkZVwifSxcInQxXCI6e1wiblwiOlwiZmFkZVwiLFwiYVwiOlt7XCJkZWxheVwiOjEwMH1dfSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwidGV4dC1hcmVhLXBhZGRpbmdcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiaDNcIixcImZcIjpbXCJSZWNlbnQgVHVuZXNcIl19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiaWRcIjpcInNlYXJjaC1ib3hcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiaVwiLFwiYVwiOntcImNsYXNzXCI6XCJmYSBmYS1zZWFyY2hcIn19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiaW5wdXRcIixcInZcIjp7XCJjaGFuZ2VcIjpcInVwZGF0ZWRfc2VhcmNoXCJ9LFwiYVwiOntcInR5cGVcIjpcInRleHRcIixcInZhbHVlXCI6W3tcInRcIjoyLFwiclwiOlwic2VhcmNoX2ZpbHRlclwifV19fV19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwidWxcIixcImFcIjp7XCJjbGFzc1wiOlwiaXRlbS1saXN0XCJ9LFwiZlwiOlt7XCJ0XCI6NCxcIm5cIjo1MixcInhcIjp7XCJyXCI6W1wiZmlsdGVyVHVuZU5hbWVzXCIsXCJ0dW5lTmFtZXNcIixcInNlYXJjaF9maWx0ZXJcIl0sXCJzXCI6XCJfMChfMSxfMilcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwibGlcIixcInZcIjp7XCJjbGlja1wiOlwibmV3X3R1bmVcIn0sXCJmXCI6W3tcInRcIjoyLFwiclwiOlwibmFtZVwifSx7XCJ0XCI6NyxcImVcIjpcImJyXCJ9LHtcInRcIjo3LFwiZVwiOlwic21hbGxcIixcImZcIjpbXCIxMi8wOS8yMDE0IC0gUmVlbCAtIEdtXCJdfV19XX1dfV19XX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwiY29sdW1uIHRocmVlLXF1YXJ0ZXJzXCIsXCJpZFwiOlwidGFzay1wYW5lXCJ9LFwidDFcIjp7XCJuXCI6XCJmYWRlXCIsXCJhXCI6W3tcImRlbGF5XCI6MjAwfV19LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJ0aWxlLWJ1dHRvbi1jb250YWluZXJcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcInRpbGUtYnV0dG9uXCJ9LFwidlwiOntcImNsaWNrXCI6XCJuZXdfdHVuZVwifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJoNFwiLFwiZlwiOltcIisgTmV3IFR1bmVcIl19XX1dfV19XX1dfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vYXBwL2hvbWUvaG9tZS5odG1sXG4gKiogbW9kdWxlIGlkID0gMTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyIsIlxyXG4gICAgUnggPSByZXF1aXJlKCd2ZW5kb3InKS5SeDtcclxuXHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICBcclxuICAgIC8vY3JlYXRlIFJ4T2JzZXJ2ZWFibGVzIGZyb20gcmFjdGl2ZSBvYnNlcnZlXHJcbiAgICBSeC5PYnNlcnZhYmxlLmZyb21SYWN0aXZlID0gZnVuY3Rpb24ocmFjdGl2ZSwgbmFtZSkge1xyXG4gICAgICAgIHJldHVybiBSeC5PYnNlcnZhYmxlLmNyZWF0ZShmdW5jdGlvbihvYnNlcnZlcikge1xyXG4gICAgICAgICAgICByYWN0aXZlLm9ic2VydmUobmFtZSwgZnVuY3Rpb24obmV3VmFsdWUsIG9sZFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5vbk5leHQoeyBuZXdWYWx1ZTogbmV3VmFsdWUsIG9sZFZhbHVlOiBvbGRWYWx1ZX0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTsgICAgICAgXHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vY3JlYXRlIFJ4T2JzZXJ2ZWFibGVzIGZyb20gbGV4ZXJcclxuICAgIFJ4Lk9ic2VydmFibGUuZnJvbUpzTGV4ID0gZnVuY3Rpb24obGV4ZXIsIGlucHV0VmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gUnguT2JzZXJ2YWJsZS5jcmVhdGUoZnVuY3Rpb24ob2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgbGV4ZXIubGV4KGlucHV0VmFsdWUsIGZ1bmN0aW9uKGEpIHsgb2JzZXJ2ZXIub25OZXh0KGEpOyB9KTtcclxuICAgICAgICB9KTsgICAgICAgXHJcbiAgICB9ICAgIFxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBSeDtcclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2VuZ2luZS9zY3JpcHRzL3J4LmhlbHBlci5qc1xuICoqIG1vZHVsZSBpZCA9IDE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iLCIvKlxyXG5cclxuXHRyYWN0aXZlLWFkYXB0b3JzLXJ4anNcclxuXHQ9PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG5cdFZlcnNpb24gMC4xLjAuXHJcblxyXG5cdFJ4SlMgYWRhcHRvciBmb3IgUmFjdGl2ZVxyXG5cclxuXHQ9PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuXHRUcm91Ymxlc2hvb3Rpbmc6IElmIHlvdSdyZSB1c2luZyBhIG1vZHVsZSBzeXN0ZW0gaW4geW91ciBhcHAgKEFNRCBvclxyXG5cdHNvbWV0aGluZyBtb3JlIG5vZGV5KSB0aGVuIHlvdSBtYXkgbmVlZCB0byBjaGFuZ2UgdGhlIHBhdGhzIGJlbG93LFxyXG5cdHdoZXJlIGl0IHNheXMgYHJlcXVpcmUoICdyYWN0aXZlJyApYCBvciBgZGVmaW5lKFsgJ3JhY3RpdmUnIF0uLi4pYC5cclxuXHJcblx0PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcblx0VXNhZ2U6IEluY2x1ZGUgdGhpcyBmaWxlIG9uIHlvdXIgcGFnZSBiZWxvdyBSYWN0aXZlLCBlLmc6XHJcblxyXG5cdCAgICA8c2NyaXB0IHNyYz0nbGliL3JhY3RpdmUuanMnPjwvc2NyaXB0PlxyXG5cdCAgICA8c2NyaXB0IHNyYz0nbGliL3J4anMuanMnPjwvc2NyaXB0PlxyXG5cdCAgICA8c2NyaXB0IHNyYz0nbGliL3JhY3RpdmUtYWRhcHRvcnMtcnhqcy5qcyc+PC9zY3JpcHQ+XHJcblxyXG5cdE9yLCBpZiB5b3UncmUgdXNpbmcgYSBtb2R1bGUgbG9hZGVyLCByZXF1aXJlIHRoaXMgbW9kdWxlOlxyXG5cclxuXHQgICAgLy8gcmVxdWlyaW5nIHRoZSBwbHVnaW4gd2lsbCAnYWN0aXZhdGUnIGl0IC0gbm8gbmVlZCB0byB1c2VcclxuXHQgICAgLy8gdGhlIHJldHVybiB2YWx1ZVxyXG5cdCAgICByZXF1aXJlKCAncmFjdGl2ZS1hZGFwdG9ycy1yeGpzJyApO1xyXG5cclxuXHRUaGVuLCB0ZWxsIFJhY3RpdmUgdG8gdXNlIHRoZSBgUnhKU2AgYWRhcHRvcjpcclxuXHJcblx0XHRyYWN0aXZlID0gbmV3IFJhY3RpdmUoe1xyXG5cdFx0XHRlbDogJ2JvZHknLFxyXG5cdFx0XHR0ZW1wbGF0ZTogbXlUZW1wbGF0ZSxcclxuXHRcdFx0YWRhcHQ6ICdSeEpTJyxcclxuXHRcdFx0ZGF0YToge1xyXG5cdFx0XHRcdGZvbzogc29tZVJlYWN0aXZlUHJvcGVydHlcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG4qL1xyXG5cclxuKGZ1bmN0aW9uICggZ2xvYmFsLCBmYWN0b3J5ICkge1xyXG5cclxuXHRmYWN0b3J5KCByZXF1aXJlKCAndmVuZG9yJykuUmFjdGl2ZSwgcmVxdWlyZSgndmVuZG9yJykuUnggKTtcclxuXHRcclxuXHJcbn0oIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24gKCBSYWN0aXZlLCBSeCApIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHR2YXIgUnhXcmFwcGVyID0gZnVuY3Rpb24gKCByYWN0aXZlLCBvYnNlcnZhYmxlLCBrZXlwYXRoICkge1xyXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuXHRcdHRoaXMucmFjdGl2ZSA9IHJhY3RpdmU7XHJcblx0XHR0aGlzLnZhbHVlID0gb2JzZXJ2YWJsZTtcclxuXHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XHJcblxyXG5cdFx0dGhpcy5kaXNwb3NlID0gb2JzZXJ2YWJsZS5zdWJzY3JpYmUoIGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblx0XHRcdGlmICggc2VsZi51cGRhdGluZyApIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHNlbGYuX3ZhbHVlID0gdmFsdWU7XHJcblxyXG5cdFx0XHRzZWxmLnVwZGF0aW5nID0gdHJ1ZTtcclxuXHRcdFx0cmFjdGl2ZS5zZXQoIGtleXBhdGgsIHZhbHVlICk7XHJcblx0XHRcdHNlbGYudXBkYXRpbmcgPSBmYWxzZTtcclxuXHRcdH0pO1xyXG5cdH07XHJcblxyXG5cdFJ4V3JhcHBlci5wcm90b3R5cGUgPSB7XHJcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuX3ZhbHVlO1xyXG5cdFx0fSxcclxuXHRcdHRlYXJkb3duOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXMuZGlzcG9zZSgpO1xyXG5cdFx0fSxcclxuXHRcdHJlc2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cdFx0XHRpZiAoIHRoaXMudXBkYXRpbmcgKSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHZhbHVlIGluc3RhbmNlb2YgUnguT2JzZXJ2YWJsZSApIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMudXBkYXRpbmcgPSB0cnVlO1xyXG5cdFx0XHQvLyBUT0RPIGhvdyBkbyB5b3Ugc2V0IHRoZSB2YWx1ZSBvZiBhIFJ4Lk9ic2VydmFibGU/IVxyXG5cdFx0XHR0aGlzLnVwZGF0aW5nID0gZmFsc2U7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0UmFjdGl2ZS5hZGFwdG9ycy5SeEpTID0ge1xyXG5cdFx0ZmlsdGVyOiBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHRcdFx0cmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIFJ4Lk9ic2VydmFibGU7XHJcblx0XHR9LFxyXG5cdFx0d3JhcDogZnVuY3Rpb24gKCByYWN0aXZlLCBvYnNlcnZhYmxlLCBrZXlwYXRoICkge1xyXG5cdFx0XHRyZXR1cm4gbmV3IFJ4V3JhcHBlciggcmFjdGl2ZSwgb2JzZXJ2YWJsZSwga2V5cGF0aCApO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG59KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2VuZ2luZS9zY3JpcHRzL2FkYXB0b3JzL3JhY3RpdmUtYWRhcHRvcnMtcnhqcy5qc1xuICoqIG1vZHVsZSBpZCA9IDE5XG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iLCIvKlxyXG5cclxuXHRyYWN0aXZlLXRyYW5zaXRpb25zLWZhZGVcclxuXHQ9PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcblx0VmVyc2lvbiAwLjEuMi5cclxuXHJcblx0VGhpcyBwbHVnaW4gZG9lcyBleGFjdGx5IHdoYXQgaXQgc2F5cyBvbiB0aGUgdGluIC0gaXQgZmFkZXMgZWxlbWVudHNcclxuXHRpbiBhbmQgb3V0LCB1c2luZyBDU1MgdHJhbnNpdGlvbnMuIFlvdSBjYW4gY29udHJvbCB0aGUgZm9sbG93aW5nXHJcblx0cHJvcGVydGllczogYGR1cmF0aW9uYCwgYGRlbGF5YCBhbmQgYGVhc2luZ2AgKHdoaWNoIG11c3QgYmUgYSB2YWxpZFxyXG5cdENTUyB0cmFuc2l0aW9uIHRpbWluZyBmdW5jdGlvbiwgYW5kIGRlZmF1bHRzIHRvIGBsaW5lYXJgKS5cclxuXHJcblx0VGhlIGBkdXJhdGlvbmAgcHJvcGVydHkgaXMgaW4gbWlsbGlzZWNvbmRzLCBhbmQgZGVmYXVsdHMgdG8gMzAwICh5b3VcclxuXHRjYW4gYWxzbyB1c2UgYGZhc3RgIG9yIGBzbG93YCBpbnN0ZWFkIG9mIGEgbWlsbGlzZWNvbmQgdmFsdWUsIHdoaWNoXHJcblx0ZXF1YXRlIHRvIDIwMCBhbmQgNjAwIHJlc3BlY3RpdmVseSkuIEFzIGEgc2hvcnRoYW5kLCB5b3UgY2FuIHVzZVxyXG5cdGBpbnRybz0nZmFkZTo1MDAnYCBpbnN0ZWFkIG9mIGBpbnRybz0nZmFkZTp7XCJkdXJhdGlvblwiOjUwMH0nYCAtIHRoaXNcclxuXHRhcHBsaWVzIHRvIG1hbnkgb3RoZXIgdHJhbnNpdGlvbiBwbHVnaW5zIGFzIHdlbGwuXHJcblxyXG5cdElmIGFuIGVsZW1lbnQgaGFzIGFuIG9wYWNpdHkgb3RoZXIgdGhhbiAxICh3aGV0aGVyIGRpcmVjdGx5LCBiZWNhdXNlXHJcblx0b2YgYW4gaW5saW5lIHN0eWxlLCBvciBpbmRpcmVjdGx5IGJlY2F1c2Ugb2YgYSBDU1MgcnVsZSksIGl0IHdpbGwgYmVcclxuXHRyZXNwZWN0ZWQuIFlvdSBjYW4gb3ZlcnJpZGUgdGhlIHRhcmdldCBvcGFjaXR5IG9mIGFuIGludHJvIGZhZGUgYnlcclxuXHRzcGVjaWZ5aW5nIGEgYHRvYCBwcm9wZXJ0eSBiZXR3ZWVuIDAgYW5kIDEuXHJcblxyXG5cdD09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG5cdFRyb3VibGVzaG9vdGluZzogSWYgeW91J3JlIHVzaW5nIGEgbW9kdWxlIHN5c3RlbSBpbiB5b3VyIGFwcCAoQU1EIG9yXHJcblx0c29tZXRoaW5nIG1vcmUgbm9kZXkpIHRoZW4geW91IG1heSBuZWVkIHRvIGNoYW5nZSB0aGUgcGF0aHMgYmVsb3csXHJcblx0d2hlcmUgaXQgc2F5cyBgcmVxdWlyZSggJ1JhY3RpdmUnIClgIG9yIGBkZWZpbmUoWyAnUmFjdGl2ZScgXS4uLilgLlxyXG5cclxuXHQ9PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuXHRVc2FnZTogSW5jbHVkZSB0aGlzIGZpbGUgb24geW91ciBwYWdlIGJlbG93IFJhY3RpdmUsIGUuZzpcclxuXHJcblx0ICAgIDxzY3JpcHQgc3JjPSdsaWIvcmFjdGl2ZS5qcyc+PC9zY3JpcHQ+XHJcblx0ICAgIDxzY3JpcHQgc3JjPSdsaWIvcmFjdGl2ZS10cmFuc2l0aW9ucy1mYWRlLmpzJz48L3NjcmlwdD5cclxuXHJcblx0T3IsIGlmIHlvdSdyZSB1c2luZyBhIG1vZHVsZSBsb2FkZXIsIHJlcXVpcmUgdGhpcyBtb2R1bGU6XHJcblxyXG5cdCAgICAvLyByZXF1aXJpbmcgdGhlIHBsdWdpbiB3aWxsICdhY3RpdmF0ZScgaXQgLSBubyBuZWVkIHRvIHVzZVxyXG5cdCAgICAvLyB0aGUgcmV0dXJuIHZhbHVlXHJcblx0ICAgIHJlcXVpcmUoICdyYWN0aXZlLXRyYW5zaXRpb25zLWZhZGUnICk7XHJcblxyXG5cdEFkZCBhIGZhZGUgdHJhbnNpdGlvbiBsaWtlIHNvOlxyXG5cclxuXHQgICAgPGRpdiBpbnRybz0nZmFkZSc+dGhpcyB3aWxsIGZhZGUgaW48L2Rpdj5cclxuXHJcbiovXHJcblxyXG4oZnVuY3Rpb24gKCBnbG9iYWwsIGZhY3RvcnkgKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHJcblx0Ly8gQ29tbW9uIEpTIChpLmUuIGJyb3dzZXJpZnkpIGVudmlyb25tZW50XHJcblx0aWYgKCB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cyAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyApIHtcclxuXHRcdGZhY3RvcnkoIHJlcXVpcmUoICd2ZW5kb3InICkuUmFjdGl2ZSApO1xyXG5cdH1cclxuXHJcblx0Ly8gQU1EP1xyXG5cdGVsc2UgaWYgKCB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XHJcblx0XHRkZWZpbmUoWyAncmFjdGl2ZScgXSwgZmFjdG9yeSApO1xyXG5cdH1cclxuXHJcblx0Ly8gYnJvd3NlciBnbG9iYWxcclxuXHRlbHNlIGlmICggZ2xvYmFsLlJhY3RpdmUgKSB7XHJcblx0XHRmYWN0b3J5KCBnbG9iYWwuUmFjdGl2ZSApO1xyXG5cdH1cclxuXHJcblx0ZWxzZSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoICdDb3VsZCBub3QgZmluZCBSYWN0aXZlISBJdCBtdXN0IGJlIGxvYWRlZCBiZWZvcmUgdGhlIHJhY3RpdmUtdHJhbnNpdGlvbnMtZmFkZSBwbHVnaW4nICk7XHJcblx0fVxyXG5cclxufSggdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiAoIFJhY3RpdmUgKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHJcblx0dmFyIGZhZGUsIGRlZmF1bHRzO1xyXG5cclxuXHRkZWZhdWx0cyA9IHtcclxuXHRcdGRlbGF5OiAwLFxyXG5cdFx0ZHVyYXRpb246IDMwMCxcclxuXHRcdGVhc2luZzogJ2xpbmVhcidcclxuXHR9O1xyXG5cclxuXHRmYWRlID0gZnVuY3Rpb24gKCB0LCBwYXJhbXMgKSB7XHJcblx0XHR2YXIgdGFyZ2V0T3BhY2l0eTtcclxuXHJcblx0XHRwYXJhbXMgPSB0LnByb2Nlc3NQYXJhbXMoIHBhcmFtcywgZGVmYXVsdHMgKTtcclxuXHJcblx0XHRpZiAoIHQuaXNJbnRybyApIHtcclxuXHRcdFx0dGFyZ2V0T3BhY2l0eSA9IHQuZ2V0U3R5bGUoICdvcGFjaXR5JyApO1xyXG5cdFx0XHR0LnNldFN0eWxlKCAnb3BhY2l0eScsIDAgKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRhcmdldE9wYWNpdHkgPSAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdHQuYW5pbWF0ZVN0eWxlKCAnb3BhY2l0eScsIHRhcmdldE9wYWNpdHksIHBhcmFtcyApLnRoZW4oIHQuY29tcGxldGUgKTtcclxuXHR9O1xyXG5cclxuXHRSYWN0aXZlLnRyYW5zaXRpb25zLmZhZGUgPSBmYWRlO1xyXG5cclxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9lbmdpbmUvc2NyaXB0cy90cmFuc2l0aW9ucy9yYWN0aXZlLnRyYW5zaXRpb25zLmZhZGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyMFxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIiwiLypcclxuXHJcblx0cmFjdGl2ZS10cmFuc2l0aW9ucy1mbHlcclxuXHQ9PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuXHRWZXJzaW9uIDAuMS4zLlxyXG5cclxuXHRUaGlzIHRyYW5zaXRpb24gdXNlcyBDU1MgdHJhbnNmb3JtcyB0byAnZmx5JyBlbGVtZW50cyB0byB0aGVpclxyXG5cdG5hdHVyYWwgbG9jYXRpb24gb24gdGhlIHBhZ2UsIGZhZGluZyBpbiBmcm9tIHRyYW5zcGFyZW50IGFzIHRoZXkgZ28uXHJcblx0QnkgZGVmYXVsdCwgdGhleSB3aWxsIGZseSBpbiBmcm9tIGxlZnQuXHJcblxyXG5cdD09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG5cdFRyb3VibGVzaG9vdGluZzogSWYgeW91J3JlIHVzaW5nIGEgbW9kdWxlIHN5c3RlbSBpbiB5b3VyIGFwcCAoQU1EIG9yXHJcblx0c29tZXRoaW5nIG1vcmUgbm9kZXkpIHRoZW4geW91IG1heSBuZWVkIHRvIGNoYW5nZSB0aGUgcGF0aHMgYmVsb3csXHJcblx0d2hlcmUgaXQgc2F5cyBgcmVxdWlyZSggJ3JhY3RpdmUnIClgIG9yIGBkZWZpbmUoWyAncmFjdGl2ZScgXS4uLilgLlxyXG5cclxuXHQ9PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuXHRVc2FnZTogSW5jbHVkZSB0aGlzIGZpbGUgb24geW91ciBwYWdlIGJlbG93IFJhY3RpdmUsIGUuZzpcclxuXHJcblx0ICAgIDxzY3JpcHQgc3JjPSdsaWIvcmFjdGl2ZS5qcyc+PC9zY3JpcHQ+XHJcblx0ICAgIDxzY3JpcHQgc3JjPSdsaWIvcmFjdGl2ZS10cmFuc2l0aW9ucy1mbHkuanMnPjwvc2NyaXB0PlxyXG5cclxuXHRPciwgaWYgeW91J3JlIHVzaW5nIGEgbW9kdWxlIGxvYWRlciwgcmVxdWlyZSB0aGlzIG1vZHVsZTpcclxuXHJcblx0ICAgIC8vIHJlcXVpcmluZyB0aGUgcGx1Z2luIHdpbGwgJ2FjdGl2YXRlJyBpdCAtIG5vIG5lZWQgdG8gdXNlXHJcblx0ICAgIC8vIHRoZSByZXR1cm4gdmFsdWVcclxuXHQgICAgcmVxdWlyZSggJ3JhY3RpdmUtdHJhbnNpdGlvbnMtZmx5JyApO1xyXG5cclxuXHRZb3UgY2FuIGFkanVzdCB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6IGB4YCwgYHlgLCBgZHVyYXRpb25gLFxyXG5cdGBkZWxheWAgYW5kIGBlYXNpbmdgLlxyXG5cclxuKi9cclxuXHJcbihmdW5jdGlvbiAoIGdsb2JhbCwgZmFjdG9yeSApIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHQvLyBDb21tb24gSlMgKGkuZS4gYnJvd3NlcmlmeSkgZW52aXJvbm1lbnRcclxuXHRpZiAoIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nICkge1xyXG5cdFx0ZmFjdG9yeSggcmVxdWlyZSggJ3ZlbmRvcicgKS5SYWN0aXZlICk7XHJcblx0fVxyXG5cclxuXHQvLyBBTUQ/XHJcblx0ZWxzZSBpZiAoIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcclxuXHRcdGRlZmluZShbICdyYWN0aXZlJyBdLCBmYWN0b3J5ICk7XHJcblx0fVxyXG5cclxuXHQvLyBicm93c2VyIGdsb2JhbFxyXG5cdGVsc2UgaWYgKCBnbG9iYWwuUmFjdGl2ZSApIHtcclxuXHRcdGZhY3RvcnkoIGdsb2JhbC5SYWN0aXZlICk7XHJcblx0fVxyXG5cclxuXHRlbHNlIHtcclxuXHRcdHRocm93IG5ldyBFcnJvciggJ0NvdWxkIG5vdCBmaW5kIFJhY3RpdmUhIEl0IG11c3QgYmUgbG9hZGVkIGJlZm9yZSB0aGUgcmFjdGl2ZS10cmFuc2l0aW9ucy1mbHkgcGx1Z2luJyApO1xyXG5cdH1cclxuXHJcbn0oIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24gKCBSYWN0aXZlICkge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblxyXG5cdHZhciBmbHksIGFkZFB4LCBkZWZhdWx0cztcclxuXHJcblx0ZGVmYXVsdHMgPSB7XHJcblx0XHRkdXJhdGlvbjogNDAwLFxyXG5cdFx0ZWFzaW5nOiAnZWFzZU91dCcsXHJcblx0XHRvcGFjaXR5OiAwLFxyXG5cdFx0eDogLTUwMCxcclxuXHRcdHk6IDBcclxuXHR9O1xyXG5cclxuXHRhZGRQeCA9IGZ1bmN0aW9uICggbnVtICkge1xyXG5cdFx0aWYgKCBudW0gPT09IDAgfHwgdHlwZW9mIG51bSA9PT0gJ3N0cmluZycgKSB7XHJcblx0XHRcdHJldHVybiBudW07XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG51bSArICdweCc7XHJcblx0fTtcclxuXHJcblx0Zmx5ID0gZnVuY3Rpb24gKCB0LCBwYXJhbXMgKSB7XHJcblx0XHR2YXIgeCwgeSwgb2Zmc2NyZWVuLCB0YXJnZXQ7XHJcblxyXG5cdFx0cGFyYW1zID0gdC5wcm9jZXNzUGFyYW1zKCBwYXJhbXMsIGRlZmF1bHRzICk7XHJcblxyXG5cdFx0eCA9IGFkZFB4KCBwYXJhbXMueCApO1xyXG5cdFx0eSA9IGFkZFB4KCBwYXJhbXMueSApO1xyXG5cclxuXHRcdG9mZnNjcmVlbiA9IHtcclxuXHRcdFx0dHJhbnNmb3JtOiAndHJhbnNsYXRlKCcgKyB4ICsgJywnICsgeSArICcpJyxcclxuXHRcdFx0b3BhY2l0eTogMFxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAoIHQuaXNJbnRybyApIHtcclxuXHRcdFx0Ly8gYW5pbWF0ZSB0byB0aGUgY3VycmVudCBzdHlsZVxyXG5cdFx0XHR0YXJnZXQgPSB0LmdldFN0eWxlKFsgJ29wYWNpdHknLCAndHJhbnNmb3JtJyBdKTtcclxuXHJcblx0XHRcdC8vIHNldCBvZmZzY3JlZW4gc3R5bGVcclxuXHRcdFx0dC5zZXRTdHlsZSggb2Zmc2NyZWVuICk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0YXJnZXQgPSBvZmZzY3JlZW47XHJcblx0XHR9XHJcblxyXG5cdFx0dC5hbmltYXRlU3R5bGUoIHRhcmdldCwgcGFyYW1zICkudGhlbiggdC5jb21wbGV0ZSApO1xyXG5cdH07XHJcblxyXG5cdFJhY3RpdmUudHJhbnNpdGlvbnMuZmx5ID0gZmx5O1xyXG5cclxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9lbmdpbmUvc2NyaXB0cy90cmFuc2l0aW9ucy9yYWN0aXZlLnRyYW5zaXRpb25zLmZseS5qc1xuICoqIG1vZHVsZSBpZCA9IDIxXG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5wcm9jZXNzLm5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FuU2V0SW1tZWRpYXRlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cuc2V0SW1tZWRpYXRlO1xuICAgIHZhciBjYW5Qb3N0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cucG9zdE1lc3NhZ2UgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXJcbiAgICA7XG5cbiAgICBpZiAoY2FuU2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZikgeyByZXR1cm4gd2luZG93LnNldEltbWVkaWF0ZShmKSB9O1xuICAgIH1cblxuICAgIGlmIChjYW5Qb3N0KSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGV2LnNvdXJjZTtcbiAgICAgICAgICAgIGlmICgoc291cmNlID09PSB3aW5kb3cgfHwgc291cmNlID09PSBudWxsKSAmJiBldi5kYXRhID09PSAncHJvY2Vzcy10aWNrJykge1xuICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZm4pO1xuICAgICAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKCdwcm9jZXNzLXRpY2snLCAnKicpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICB9O1xufSkoKTtcblxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spL34vbm9kZS1saWJzLWJyb3dzZXIvfi9wcm9jZXNzL2Jyb3dzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyMlxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyXHJcbiAgICBsZXhlciA9IHJlcXVpcmUoJy4vbGV4ZXIuanMnKSxcclxuICAgIGRhdGFfdGFibGVzID0gcmVxdWlyZSgnLi9kYXRhX3RhYmxlcy5qcycpLFxyXG4gICAgXyA9IHJlcXVpcmUoJ3ZlbmRvcicpLmxvZGFzaCxcclxuICAgIGVudW1zID0gcmVxdWlyZSgnLi90eXBlcycpLFxyXG5cclxuICAgIGNhY2hlID0ge30sXHJcbiAgICBkcmF3YWJsZUluZGV4ID0gMCxcclxuICAgIGRlY29yYXRpb25zdGFjayA9IFtdO1xyXG5cclxuZnVuY3Rpb24gUGFyc2VyRXhjZXB0aW9uKG1lc3NhZ2UpIHtcclxuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XHJcbiAgICB0aGlzLm5hbWUgPSBcIlBhcnNlckV4Y2VwdGlvblwiO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJzZU5vdGUobGV4ZXIsIHBhcnNlZCkge1xyXG4gICAgdmFyIG5ld05vdGUgPSB7XHJcbiAgICAgICAgdHlwZTogXCJub3RlXCIsXHJcbiAgICAgICAgdHlwZV9jbGFzczogXCJkcmF3YWJsZVwiLFxyXG4gICAgICAgIG5vdGVsZW5ndGg6IDFcclxuICAgIH07XHJcblxyXG4gICAgd2hpbGUgKGxleGVyWzBdICYmIGxleGVyWzBdLnN1YlR5cGUgPT09IFwiZGVjb3JhdGlvblwiKSB7XHJcbiAgICAgICAgbGV4ZXIuc2hpZnQoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobGV4ZXJbMF0uc3ViVHlwZSA9PSBcImFjY2lkZW50YWxcIikge1xyXG4gICAgICAgIG5ld05vdGUuYWNjaWRlbnRhbCA9IGxleGVyLnNoaWZ0KCkuZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWxleGVyWzBdIHx8IGxleGVyWzBdLnN1YlR5cGUgIT09IFwibGV0dGVyXCIpIHtcclxuICAgICAgICBsZXhlci5zaGlmdCgpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VyRXhjZXB0aW9uKFwiTWlzc2luZyBub3RlIG5hbWVcIik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGxleGVyWzBdICYmIGxleGVyWzBdLnN1YlR5cGUgPT0gXCJsZXR0ZXJcIikge1xyXG4gICAgICAgIG5ld05vdGUubm90ZSA9IGxleGVyLnNoaWZ0KCkuZGF0YTtcclxuICAgICAgICBuZXdOb3RlLnBpdGNoID0gZGF0YV90YWJsZXMubm90ZXNbbmV3Tm90ZS5ub3RlXS5waXRjaDtcclxuICAgICAgICBuZXdOb3RlLm9jdGF2ZSA9IGRhdGFfdGFibGVzLm5vdGVzW25ld05vdGUubm90ZV0ub2N0YXZlO1xyXG4gICAgICAgIG5ld05vdGUucG9zID0gZGF0YV90YWJsZXMubm90ZXNbbmV3Tm90ZS5ub3RlXS5wb3M7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGxleGVyWzBdICYmIGxleGVyWzBdLnN1YlR5cGUgPT0gXCJwaXRjaFwiKSB7XHJcbiAgICAgICAgbmV3Tm90ZS5vY3RhdmUgKz0gbGV4ZXIuc2hpZnQoKS5kYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChsZXhlclswXSAmJiBsZXhlclswXS5zdWJUeXBlID09IFwibGVuZ3RoXCIpIHtcclxuICAgICAgICBuZXdOb3RlLm5vdGVsZW5ndGggPSBsZXhlci5zaGlmdCgpLmRhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgcGFyc2VkLndlaWdodCArPSBuZXdOb3RlLm5vdGVsZW5ndGg7XHJcbiAgICBwYXJzZWQuc3ltYm9scy5wdXNoKG5ld05vdGUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJzZVJlc3QobGV4ZXIpIHtcclxuICAgIHZhciBuZXdSZXN0ID0ge307XHJcblxyXG4gICAgbmV3UmVzdC50eXBlX2NsYXNzID0gbGV4ZXJbMF0uc3ViVHlwZSA9PT0gXCJ2aXNpYmxlXCIgPyBcImRyYXdhYmxlXCIgOiBcImhpZGRlblwiO1xyXG4gICAgbmV3UmVzdC50eXBlID0gbGV4ZXJbMF0uZGF0YSA9PT0gXCJzaG9ydFwiID8gXCJiZWF0X3Jlc3RcIiA6IFwiYmFyX3Jlc3RcIjtcclxuXHJcbiAgICBsZXhlci5zaGlmdCgpO1xyXG5cclxuICAgIGlmIChsZXhlclswXSAmJiBsZXhlclswXS5zdWJUeXBlID09IFwibGVuZ3RoXCIpIHtcclxuICAgICAgICBuZXdSZXN0Lm5vdGVsZW5ndGggPSBsZXhlci5zaGlmdCgpLmRhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ld1Jlc3Q7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJzZXMgYSBncm91cCBvZiBub3Rlc1xyXG4gKiBAcGFyYW0gIHtBcnJheX0gVGhlIG91dHB1dCBhcnJheSBmb3IgdGhlIGVudGlyZSBwYXJzZSBwcm9jZXNzXHJcbiAqIEBwYXJhbSAge0FycmF5fSBUaGUgaW5wdXQgYXJyYXkgb2YgbGV4ZWQgdG9rZW5zXHJcbiAqIEBwYXJhbSAge1N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIHR5cGUgb2Ygbm90ZSBncm91cFxyXG4gKiBAcGFyYW0gIHtTdHJpbmd9IFRoZSB0eXBlIG9mIHRva2VuIHRoYXQgc3RhcnRzIHRoZSBub3RlIGdyb3VwXHJcbiAqIEBwYXJhbSAge1N0cmluZ30gVGhlIHR5cGUgb2YgdG9rZW4gdGhhdCBlbmRzIHRoZSBub3RlIGdyb3VwXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgVFJVRSBpZiB0aGUgc3BlY2lmaWVkIG5vdGUgZ3JvdXAgd2FzIGZvdW5kXHJcbiAqL1xyXG5mdW5jdGlvbiBub3RlR3JvdXAocGFyc2VkLCBsZXhlZCwgbmFtZSwgc3RhcnQsIHN0b3ApIHtcclxuICAgIGlmIChsZXhlZFswXS50eXBlID09PSBzdGFydCkge1xyXG4gICAgICAgIGxleGVkLnNoaWZ0KCk7XHJcblxyXG4gICAgICAgIHZhciBncm91cE5vdGVzID0gW107XHJcblxyXG4gICAgICAgIHdoaWxlIChsZXhlZC5sZW5ndGggPiAwICYmIGxleGVkWzBdLnR5cGUgIT0gc3RvcCkge1xyXG4gICAgICAgICAgICBpZiAobGV4ZWRbMF0udHlwZSA9PT0gXCJub3RlXCIpIHtcclxuICAgICAgICAgICAgICAgIGdyb3VwTm90ZXMucHVzaChwYXJzZU5vdGUobGV4ZWQpKTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLyp0aHJvdyBuZXcqL1xyXG4gICAgICAgICAgICAgICAgZ3JvdXBOb3Rlcy5wdXNoKG5ldyBQYXJzZXJFeGNlcHRpb24oXCJPbmx5IG5vdGVzIGFyZSBhbGxvd2VkIGluIFwiICsgbmFtZSArIFwic1wiKSk7XHJcbiAgICAgICAgICAgICAgICBsZXhlZC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHBhcnNlZC5wdXNoKHtcclxuICAgICAgICAgICAgdHlwZTogbmFtZSxcclxuICAgICAgICAgICAgdHlwZV9jbGFzczogXCJkcmF3YWJsZVwiLFxyXG4gICAgICAgICAgICBub3RlczogZ3JvdXBOb3Rlc1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBsZXhlZC5zaGlmdCgpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChsZXhlZFswXS50eXBlID09PSBzdG9wKSB7XHJcbiAgICAgICAgcGFyc2VkLnB1c2gobmV3IFBhcnNlckV4Y2VwdGlvbihcIkNsb3NpbmcgXCIgKyBuYW1lICsgXCIgZm91bmQgYmVmb3JlIHN0YXJ0aW5nIGl0XCIpKTtcclxuICAgICAgICBsZXhlZC5zaGlmdCgpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEEgcmVjdXJzaXZlIGRlY2VudCBwYXJzZXIgdGhhdCBjb21iaW5lcyBsZXhlZCB0b2tlbnMgaW50byBhIG1lYW5pbmdmdWwgZGF0YSBzdHJ1Y3R1cmVcclxuICogQHBhcmFtICB7QXJyYXl9IEFuIGFycmF5IG9mIGxleGVkIHRva2Vuc1xyXG4gKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgcGFyc2VkIHN5bWJvbHNcclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlKGxleGVkKSB7XHJcblxyXG4gICAgdmFyIHBhcnNlZCA9IHtcclxuICAgICAgICBzeW1ib2xzOiBbXSxcclxuICAgICAgICB3ZWlnaHQ6IDBcclxuICAgIH07XHJcblxyXG4gICAgd2hpbGUgKGxleGVkLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBpZiAobGV4ZWRbMF0udHlwZSA9PT0gXCJlcnJcIikge1xyXG4gICAgICAgICAgICAvKnRocm93IG5ldyovXHJcbiAgICAgICAgICAgIHBhcnNlZC5zeW1ib2xzLnB1c2gobmV3IFBhcnNlckV4Y2VwdGlvbihcIlVucmVjb2duaXNlZCBzZXF1ZW5jZTogXCIgKyBsZXhlZFswXS5kYXRhKSk7XHJcbiAgICAgICAgICAgIGxleGVkLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGxleGVkWzBdLnR5cGVfY2xhc3MgPT09IFwiZGF0YVwiKSB7XHJcbiAgICAgICAgICAgIGxleGVkLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGxleGVkWzBdLnR5cGUgPT09IFwiYmVhbVwiKSB7XHJcbiAgICAgICAgICAgIGxleGVkLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGxleGVkWzBdLnR5cGUgPT09IFwiY2hvcmRfYW5ub3RhdGlvblwiKSB7XHJcbiAgICAgICAgICAgIHBhcnNlZC5zeW1ib2xzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdHlwZV9jbGFzczogXCJkcmF3YWJsZVwiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJjaG9yZF9hbm5vdGF0aW9uXCIsXHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBsZXhlZFswXS5kYXRhXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBsZXhlZC5zaGlmdCgpO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChsZXhlZFswXS50eXBlID09PSBcIm5vdGVcIikge1xyXG4gICAgICAgICAgICBwYXJzZU5vdGUobGV4ZWQsIHBhcnNlZCk7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGxleGVkWzBdLnR5cGUgPT09IFwicmVzdFwiKSB7XHJcbiAgICAgICAgICAgIHBhcnNlZC5zeW1ib2xzLnB1c2gocGFyc2VSZXN0KGxleGVkKSk7XHJcbiAgICAgICAgICAgIHBhcnNlZC53ZWlnaHQgKz0gMTtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobGV4ZWRbMF0udHlwZSA9PT0gXCJzcGFjZVwiKSB7XHJcbiAgICAgICAgICAgIHBhcnNlZC5zeW1ib2xzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJzcGFjZVwiLFxyXG4gICAgICAgICAgICAgICAgdHlwZV9jbGFzczogXCJoaWRkZW5cIlxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbGV4ZWQuc2hpZnQoKTtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobm90ZUdyb3VwKHBhcnNlZCwgbGV4ZWQsIFwiY2hvcmRcIiwgXCJjaG9yZF9zdGFydFwiLCBcImNob3JkX3N0b3BcIikpIGNvbnRpbnVlO1xyXG4gICAgICAgIGlmIChub3RlR3JvdXAocGFyc2VkLCBsZXhlZCwgXCJzbHVyXCIsIFwic2x1cl9zdGFydFwiLCBcInNsdXJfc3RvcFwiKSkgY29udGludWU7XHJcbiAgICAgICAgaWYgKG5vdGVHcm91cChwYXJzZWQsIGxleGVkLCBcImdyYWNlXCIsIFwiZ3JhY2Vfc3RhcnRcIiwgXCJncmFjZV9zdG9wXCIpKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgaWYgKGxleGVkWzBdLnR5cGUgPT09IFwiYmFybGluZVwiKSB7XHJcbiAgICAgICAgICAgIGxleGVkLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIHBhcnNlZC5zeW1ib2xzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJiYXJsaW5lXCIsXHJcbiAgICAgICAgICAgICAgICB0eXBlX2NsYXNzOiBcImRyYXdhYmxlXCJcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHBhcnNlZC53ZWlnaHQgKz0gMTtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwYXJzZWQ7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGluZSkge1xyXG5cclxuICAgIGlmIChsaW5lLmFjdGlvbiAhPT0gZW51bXMubGluZV9hY3Rpb25zLm1vdmUpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YXIgbGV4ZWQgPSBsZXhlcihsaW5lLnJhdyk7XHJcblxyXG4gICAgICAgICAgICBpZiAobGV4ZWQubGVuZ3RoID4gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBwYXJzZU91dHB1dCA9IHBhcnNlKGxleGVkKVxyXG4gICAgICAgICAgICAgICAgbGluZS5wYXJzZWQgPSBwYXJzZU91dHB1dC5zeW1ib2xzO1xyXG4gICAgICAgICAgICAgICAgbGluZS53ZWlnaHQgPSBwYXJzZU91dHB1dC53ZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCEobGV4ZWQubGVuZ3RoID09PSAxICYmIGxleGVyWzBdLnR5cGVfY2xhc3MgPT09IFwiZGF0YVwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmUudHlwZV9jbGFzcyA9IGVudW1zLmxpbmVfdHlwZXMuZHJhd2FibGU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmUudHlwZV9jbGFzcyA9IGVudW1zLmxpbmVfdHlwZXMuZGF0YTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxpbmUucGFyc2VkID0gW107XHJcbiAgICAgICAgICAgICAgICBsaW5lLnR5cGVfY2xhc3MgPSBlbnVtcy5saW5lX3R5cGVzLmhpZGRlbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRVJSXCIsIGVycik7XHJcbiAgICAgICAgICAgIGxpbmUudHlwZV9jbGFzcyA9IGVudW1zLmxpbmVfdHlwZXMuaGlkZGVuO1xyXG4gICAgICAgICAgICBsaW5lLmVycm9yX2RldGFpbHMgPSBlcnI7XHJcbiAgICAgICAgICAgIGxpbmUuZXJyb3IgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGxpbmU7XHJcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZW5naW5lL3BhcnNlci5qc1xuICoqIG1vZHVsZSBpZCA9IDIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXJcclxuICAgIF8gPSByZXF1aXJlKCd2ZW5kb3InKS5sb2Rhc2gsXHJcbiAgICBzdmcgPSByZXF1aXJlKCd2ZW5kb3InKS5zdmdqcywgXHJcbiAgICBlbnVtcyA9IHJlcXVpcmUoJy4vdHlwZXMnKSxcclxuICAgIHN0YXZlX3N5bWJvbHMgPSByZXF1aXJlKFwiLi9yZW5kZXJpbmcvc3RhdmVfc3ltYm9sc1wiKSxcclxuICAgIGFkZF9kYXRhX2ZpZWxkcyA9IHJlcXVpcmUoXCIuL3JlbmRlcmluZy9kYXRhX2ZpZWxkc1wiKS5hZGQsXHJcbiAgICByZW1vdmVfZGF0YV9maWVsZHMgPSByZXF1aXJlKFwiLi9yZW5kZXJpbmcvZGF0YV9maWVsZHNcIikucmVtb3ZlLFxyXG4gICAgZ2x5cGhzID0gcmVxdWlyZSgnLi9yZW5kZXJpbmcvZ2x5cGhzJyksXHJcbiAgICBkaXNwYXRjaGVyID0gcmVxdWlyZSgnLi9kaXNwYXRjaGVyJyksXHJcbiAgICBkYXRhX3RhYmxlcyA9IHJlcXVpcmUoJy4vZGF0YV90YWJsZXMnKTtcclxuXHJcbnZhclxyXG4gICAgZHJhdyxcclxuICAgIHNjb3JlTGluZXMsXHJcbiAgICBsaW5lSGVpZ2h0ID0gODAsXHJcbiAgICBsaW5lV2lkdGggPSAxMDI0LFxyXG4gICAgc2VsZWN0ZWRMaW5lO1xyXG5cclxudmFyIHNlbGVjdGlvblJlY3RzID0gW107XHJcblxyXG52YXIgYXJyYW5nZUdyb3VwcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIG9mZnNldCA9IDE7XHJcblxyXG4gICAgLy9pZiAoZGF0YS50aXRsZSAhPSBudWxsKSBvZmZzZXQgPSA0O1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2NvcmVMaW5lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChzY29yZUxpbmVzW2ldID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICBpZiAoc2NvcmVMaW5lc1tpXSAhPSAwKSB7XHJcbiAgICAgICAgICAgIHNjb3JlTGluZXNbaV0ubW92ZSg1MCwgbGluZUhlaWdodCAqIG9mZnNldCk7XHJcbiAgICAgICAgICAgIG9mZnNldCArPSAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4gXHJcbnZhciBoYW5kbGVyID0gW107XHJcblxyXG5oYW5kbGVyWyhlbnVtcy5saW5lX2FjdGlvbnMuYWRkIDw8IDIpICsgZW51bXMubGluZV90eXBlcy5kcmF3YWJsZV0gPSBmdW5jdGlvbihhKSB7XHJcblxyXG4gICAgaWYgKHNjb3JlTGluZXNbYS5pXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgc2NvcmVMaW5lc1thLmldID0gZHJhdy5ncm91cCgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBzY29yZUxpbmVzLnNwbGljZShhLmksIDAsIGRyYXcuZ3JvdXAoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGdyb3VwRHJhdyA9IHNjb3JlTGluZXNbYS5pXTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDU7IGkrKykge1xyXG4gICAgICAgIGdyb3VwRHJhdy5yZWN0KGxpbmVXaWR0aCwgMSkubW92ZSgwLCBpICogOCkuYXR0cih7XHJcbiAgICAgICAgICAgIGZpbGw6ICdibGFjaydcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBncm91cERyYXcucmVjdCgxLCAzMikubW92ZSgwLCAwKS5hdHRyKHtcclxuICAgICAgICBmaWxsOiAnYmxhY2snXHJcbiAgICB9KTtcclxuXHJcbiAgICBncm91cERyYXcucmVjdCgxLCAzMikubW92ZSgxMDI0LCAwKS5hdHRyKHtcclxuICAgICAgICBmaWxsOiAnYmxhY2snXHJcbiAgICB9KTtcclxuXHJcbiAgICBpZihhLmkgPT09IHNlbGVjdGVkTGluZSkge1xyXG4gICAgICAgIHNlbGVjdGlvblJlY3RzLnB1c2goZ3JvdXBEcmF3LnJlY3QoNCwgMzQpLm1vdmUoLTgsIDApLmF0dHIoeyBmaWxsOiAnIzIyMzM3OCcgfSkpXHJcbiAgICB9XHJcblxyXG4gICAgZ3JvdXBEcmF3LnNlbGVjdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHNlbGVjdGlvblJlY3RzLnB1c2goZ3JvdXBEcmF3LnJlY3QoNCwgMzQpLm1vdmUoLTgsIDApLmF0dHIoeyBmaWxsOiAnIzIyMzM3OCcgfSkpOyAgICBcclxuICAgIH1cclxuXHJcbiAgICBzdGF2ZV9zeW1ib2xzLnRyZWJsZV9jbGVmKGdyb3VwRHJhdyk7XHJcblxyXG4gICAgdmFyIHBvc19tb2QgPSBsaW5lV2lkdGgvKGEud2VpZ2h0KzEpO1xyXG5cclxuICAgIGZvciAodmFyIGogPSAwLCB0b3RhbE9mZnNldCA9IDE7IGogPCBhLnBhcnNlZC5sZW5ndGg7IGorKykge1xyXG5cclxuICAgICAgICB2YXIgY3VycmVudFN5bWJvbCA9IGEucGFyc2VkW2pdO1xyXG5cclxuICAgICAgICBpZighXyhPYmplY3Qua2V5cyhzdGF2ZV9zeW1ib2xzKSkuY29udGFpbnMoY3VycmVudFN5bWJvbC50eXBlKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIldhbnRlZCB0byBkcmF3IGEgXCIgKyBjdXJyZW50U3ltYm9sLnR5cGUgKyBcIiBkb24ndCBrbm93IGhvd1wiKTtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGF2ZV9zeW1ib2xzW2N1cnJlbnRTeW1ib2wudHlwZV0oZ3JvdXBEcmF3LCBjdXJyZW50U3ltYm9sLCBwb3NfbW9kICogdG90YWxPZmZzZXQpO1xyXG5cclxuICAgICAgICBpZihfLmlzRnVuY3Rpb24oZGF0YV90YWJsZXMuc3ltYm9sX3dpZHRoW2N1cnJlbnRTeW1ib2wudHlwZV0pKSB7XHJcbiAgICAgICAgICAgIHRvdGFsT2Zmc2V0ICs9IGRhdGFfdGFibGVzLnN5bWJvbF93aWR0aFtjdXJyZW50U3ltYm9sLnR5cGVdKGN1cnJlbnRTeW1ib2wpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRvdGFsT2Zmc2V0ICs9IGRhdGFfdGFibGVzLnN5bWJvbF93aWR0aFtjdXJyZW50U3ltYm9sLnR5cGVdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbmhhbmRsZXJbKGVudW1zLmxpbmVfYWN0aW9ucy5kZWxldGUgPDwgMikgKyBlbnVtcy5saW5lX3R5cGVzLmRyYXdhYmxlXSA9IGZ1bmN0aW9uKGEpIHtcclxuICAgIGlmIChzY29yZUxpbmVzW2EuaV0pIHNjb3JlTGluZXNbYS5pXS5yZW1vdmUoKTtcclxuICAgIHNjb3JlTGluZXNbYS5pXSA9IHVuZGVmaW5lZDtcclxufTtcclxuXHJcbmhhbmRsZXJbKGVudW1zLmxpbmVfYWN0aW9ucy5hZGQgPDwgMikgKyBlbnVtcy5saW5lX3R5cGVzLmRhdGFdID0gZnVuY3Rpb24oYSkge1xyXG5cclxuICAgIHNjb3JlTGluZXNbYS5pXSA9IDA7XHJcblxyXG4gICAgaWYgKGFkZF9kYXRhX2ZpZWxkc1thLnBhcnNlZFswXS50eXBlXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJOT1QgWUVUIElNUExFTUVOVEVEXCIpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBhZGRfZGF0YV9maWVsZHNbYS5wYXJzZWRbMF0udHlwZV0oYSk7XHJcbn07XHJcblxyXG5oYW5kbGVyWyhlbnVtcy5saW5lX2FjdGlvbnMuZGVsZXRlIDw8IDIpICsgZW51bXMubGluZV90eXBlcy5kYXRhXSA9IGZ1bmN0aW9uKGEpIHtcclxuXHJcbiAgICBzY29yZUxpbmVzW2EuaV0gPSB1bmRlZmluZWQ7XHJcbiAgICBpZiAocmVtb3ZlX2RhdGFfZmllbGRzW2EucGFyc2VkWzBdLnR5cGVdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIk5PVCBZRVQgSU1QTEVNRU5URURcIik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbW92ZV9kYXRhX2ZpZWxkc1thLnBhcnNlZFswXS50eXBlXShhKTtcclxufTtcclxuXHJcbmhhbmRsZXJbKGVudW1zLmxpbmVfYWN0aW9ucy5hZGQgPDwgMikgKyBlbnVtcy5saW5lX3R5cGVzLmhpZGRlbl0gPSBmdW5jdGlvbihhKSB7XHJcbiAgICBzY29yZUxpbmVzW2EuaV0gPSAwO1xyXG59O1xyXG5cclxuaGFuZGxlclsoZW51bXMubGluZV9hY3Rpb25zLmRlbGV0ZSA8PCAyKSArIGVudW1zLmxpbmVfdHlwZXMuaGlkZGVuXSA9IGZ1bmN0aW9uKGEpIHtcclxuICAgIHNjb3JlTGluZXNbYS5pXSA9IHVuZGVmaW5lZDtcclxufVxyXG5cclxuaGFuZGxlclsoZW51bXMubGluZV9hY3Rpb25zLm1vdmUgPDwgMikgKyBlbnVtcy5saW5lX3R5cGVzLmRyYXdhYmxlXSA9XHJcbiAgICBoYW5kbGVyWyhlbnVtcy5saW5lX2FjdGlvbnMubW92ZSA8PCAyKSArIGVudW1zLmxpbmVfdHlwZXMuZGF0YV0gPVxyXG4gICAgaGFuZGxlclsoZW51bXMubGluZV9hY3Rpb25zLm1vdmUgPDwgMikgKyBlbnVtcy5saW5lX3R5cGVzLmhpZGRlbl0gPSBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgaWYgKGEuaSA8IGEuaikge1xyXG4gICAgICAgICAgICBzY29yZUxpbmVzW2EuaV0gPSBzY29yZUxpbmVzW2Eual07XHJcbiAgICAgICAgICAgIHNjb3JlTGluZXNbYS5qXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJNT1ZcIiwgc2NvcmVMaW5lcyk7XHJcbn1cclxuXHJcbi8vZXhwb3J0ZWQgZnVuY3Rpb25zXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oY2FudmFzU2VsZWN0b3IpIHtcclxuICAgICAgICBkcmF3ID0gc3ZnKCdjYW52YXMnKTtcclxuICAgICAgICBkcmF3LnBhdGgoZ2x5cGhzW1wiZmxhZ3MudTh0aFwiXS5kKS5hdHRyKHsgZmlsbDogJ2JsYWNrJ30pLm1vdmUoMTAsMTApLnNjYWxlKDEpO1xyXG4gICAgICAgIHNjb3JlTGluZXMgPSBbXTtcclxuXHJcbiAgICAgICAgZGlzcGF0Y2hlci5zdWJzY3JpYmUoZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICBpZihhLnR5cGUgPT09IFwic2VsZWN0aW9uLWNoYW5nZWRcIikge1xyXG4gICAgICAgICAgICAgICAgXyhzZWxlY3Rpb25SZWN0cykuZm9yRWFjaChmdW5jdGlvbihzcikgeyBzci5yZW1vdmUoKTsgfSk7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RlZExpbmUgPSBhLnN0YXJ0IC0gMTtcclxuICAgICAgICAgICAgICAgIGlmKHNjb3JlTGluZXNbc2VsZWN0ZWRMaW5lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNjb3JlTGluZXNbc2VsZWN0ZWRMaW5lXS5zZWxlY3QoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBvbk5leHQ6IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICBpZighYS5lcnJvcikge1xyXG4gICAgICAgICAgICBoYW5kbGVyWyhhLmFjdGlvbiA8PCAyKSArIGEudHlwZV9jbGFzc10oYSk7XHJcbiAgICAgICAgICAgIGFycmFuZ2VHcm91cHMoKTtcclxuICAgICAgICAgICAgc2NvcmVMaW5lcyA9IHNjb3JlTGluZXMuc2xpY2UoMCwgYS5uZXdMZW5ndGgpOyAgICAgICAgICAgIFxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYTtcclxuICAgIH1cclxuXHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2VuZ2luZS9yZW5kZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyNFxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIiwiIC8vc2VsZWN0IG1hbnk6XHJcbiB2YXIgUnggPSByZXF1aXJlKCdzY3JpcHRzL3J4LmhlbHBlcicpLFxyXG4gIGVudW1zID0gcmVxdWlyZSgnLi90eXBlcycpO1xyXG5cclxuIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2hhbmdlKSB7XHJcblxyXG4gICAgIHJldHVybiBSeC5PYnNlcnZhYmxlLmNyZWF0ZShmdW5jdGlvbihvYnNlcnZlcikge1xyXG5cclxuICAgICAgICAgdmFyXHJcbiAgICAgICAgICAgICBuZXdTcGxpdCA9IChjaGFuZ2UubmV3VmFsdWUgfHwgXCJcIikuc3BsaXQoJ1xcbicpLFxyXG4gICAgICAgICAgICAgb2xkU3BsaXQgPSAoY2hhbmdlLm9sZFZhbHVlIHx8IFwiXCIpLnNwbGl0KCdcXG4nKSxcclxuICAgICAgICAgICAgIG5ld0xlbmd0aCA9IE1hdGgubWF4KG5ld1NwbGl0Lmxlbmd0aCwgb2xkU3BsaXQubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgIGZ1bmN0aW9uIGdldF9kaWZmKG1hdHJpeCwgYTEsIGEyLCB4LCB5KSB7XHJcbiAgICAgICAgICAgICBpZiAoeCA+IDAgJiYgeSA+IDAgJiYgYTFbeSAtIDFdID09PSBhMlt4IC0gMV0pIHtcclxuICAgICAgICAgICAgICAgICBnZXRfZGlmZihtYXRyaXgsIGExLCBhMiwgeCAtIDEsIHkgLSAxKTtcclxuICAgICAgICAgICAgICAgICAvL21ha2Vfcm93KHgsIHksICcgJywgYTFbeS0xXSk7XHJcbiAgICAgICAgICAgICAgICAgaWYgKHggIT09IHkpXHJcbiAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm9uTmV4dCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IGVudW1zLmxpbmVfYWN0aW9ucy5tb3ZlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgaTogeCAtIDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBqOiB5IC0gMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xlbmd0aDogbmV3TGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICBpZiAoeCA+IDAgJiYgKHkgPT09IDAgfHwgbWF0cml4W3ldW3ggLSAxXSA+PSBtYXRyaXhbeSAtIDFdW3hdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICBnZXRfZGlmZihtYXRyaXgsIGExLCBhMiwgeCAtIDEsIHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAvL21ha2Vfcm93KHgsICcnLCAnKycsIGEyW3gtMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5vbk5leHQoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgcmF3OiBhMlt4IC0gMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBpOiB4IC0gMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogZW51bXMubGluZV9hY3Rpb25zLmFkZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xlbmd0aDogbmV3TGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoeSA+IDAgJiYgKHggPT09IDAgfHwgbWF0cml4W3ldW3ggLSAxXSA8IG1hdHJpeFt5IC0gMV1beF0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgIGdldF9kaWZmKG1hdHJpeCwgYTEsIGEyLCB4LCB5IC0gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgIC8vbWFrZV9yb3coJycsIHksICctJywgYTFbeS0xXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm9uTmV4dCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICByYXc6IGExW3kgLSAxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIGk6IHkgLSAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBlbnVtcy5saW5lX2FjdGlvbnMuZGVsZXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGVuZ3RoOiBuZXdMZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgIH1cclxuICAgICAgICAgfVxyXG5cclxuICAgICAgICAgZnVuY3Rpb24gZGlmZihhMSwgYTIpIHtcclxuICAgICAgICAgICAgIHZhciBtYXRyaXggPSBuZXcgQXJyYXkoYTEubGVuZ3RoICsgMSk7XHJcbiAgICAgICAgICAgICB2YXIgeCwgeTtcclxuXHJcbiAgICAgICAgICAgICBmb3IgKHkgPSAwOyB5IDwgbWF0cml4Lmxlbmd0aDsgeSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgbWF0cml4W3ldID0gbmV3IEFycmF5KGEyLmxlbmd0aCArIDEpO1xyXG5cclxuICAgICAgICAgICAgICAgICBmb3IgKHggPSAwOyB4IDwgbWF0cml4W3ldLmxlbmd0aDsgeCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgIG1hdHJpeFt5XVt4XSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgIGZvciAoeSA9IDE7IHkgPCBtYXRyaXgubGVuZ3RoOyB5KyspIHtcclxuICAgICAgICAgICAgICAgICBmb3IgKHggPSAxOyB4IDwgbWF0cml4W3ldLmxlbmd0aDsgeCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgIGlmIChhMVt5IC0gMV0gPT09IGEyW3ggLSAxXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4W3ldW3hdID0gMSArIG1hdHJpeFt5IC0gMV1beCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4W3ldW3hdID0gTWF0aC5tYXgobWF0cml4W3kgLSAxXVt4XSwgbWF0cml4W3ldW3ggLSAxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgZ2V0X2RpZmYobWF0cml4LCBhMSwgYTIsIHggLSAxLCB5IC0gMSk7XHJcbiAgICAgICAgIH1cclxuXHJcbiAgICAgICAgIGRpZmYob2xkU3BsaXQsIG5ld1NwbGl0KTtcclxuICAgICAgICAgLy9vYnNlcnZlci5vbk5leHQoeyBhY3Rpb246IFwiZW5kb2ZpbnB1dFwiIH0pO1xyXG4gICAgIH0pO1xyXG4gfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9lbmdpbmUvZGlmZi5qc1xuICoqIG1vZHVsZSBpZCA9IDI1XG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgbGluZV90eXBlcyA9IHtcclxuXHRcImRyYXdhYmxlXCI6IDAsXHJcblx0XCJkYXRhXCI6IDEsXHJcblx0XCJoaWRkZW5cIjogMlxyXG59O1xyXG5cclxudmFyIGxpbmVfYWN0aW9ucyA9IHtcclxuXHRcImRlbGV0ZVwiOiAwLFxyXG5cdFwiYWRkXCI6IDEsXHJcblx0XCJtb3ZlXCI6IDJcclxufTtcclxuXHJcbk9iamVjdC5mcmVlemUobGluZV90eXBlcyk7XHJcbk9iamVjdC5mcmVlemUobGluZV9hY3Rpb25zKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cdGxpbmVfdHlwZXM6IGxpbmVfdHlwZXMsXHJcblx0bGluZV9hY3Rpb25zOiBsaW5lX2FjdGlvbnNcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZW5naW5lL3R5cGVzLmpzXG4gKiogbW9kdWxlIGlkID0gMjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBkYXRhX3RhYmxlcyA9IHt9O1xyXG5cclxuZGF0YV90YWJsZXNbXCJub3Rlc1wiXSA9IHtcclxuICAgIFwiQ1wiOiB7XHJcbiAgICAgICAgb2N0YXZlOiA0LFxyXG4gICAgICAgIHBpdGNoOiA2MCxcclxuICAgICAgICBwb3M6IDBcclxuICAgIH0sXHJcbiAgICBcIkRcIjoge1xyXG4gICAgICAgIG9jdGF2ZTogNCxcclxuICAgICAgICBwaXRjaDogNjIsXHJcbiAgICAgICAgcG9zOiAxXHJcbiAgICB9LFxyXG4gICAgXCJFXCI6IHtcclxuICAgICAgICBvY3RhdmU6IDQsXHJcbiAgICAgICAgcGl0Y2g6IDY0LFxyXG4gICAgICAgIHBvczogMlxyXG4gICAgfSxcclxuICAgIFwiRlwiOiB7XHJcbiAgICAgICAgb2N0YXZlOiA0LFxyXG4gICAgICAgIHBpdGNoOiA2NSxcclxuICAgICAgICBwb3M6IDNcclxuICAgIH0sXHJcbiAgICBcIkdcIjoge1xyXG4gICAgICAgIG9jdGF2ZTogNCxcclxuICAgICAgICBwaXRjaDogNjcsXHJcbiAgICAgICAgcG9zOiA0XHJcbiAgICB9LFxyXG4gICAgXCJBXCI6IHtcclxuICAgICAgICBvY3RhdmU6IDQsXHJcbiAgICAgICAgcGl0Y2g6IDY5LFxyXG4gICAgICAgIHBvczogNVxyXG4gICAgfSxcclxuICAgIFwiQlwiOiB7XHJcbiAgICAgICAgb2N0YXZlOiA0LFxyXG4gICAgICAgIHBpdGNoOiA3MSxcclxuICAgICAgICBwb3M6IDZcclxuICAgIH0sXHJcbiAgICBcImNcIjoge1xyXG4gICAgICAgIG9jdGF2ZTogNSxcclxuICAgICAgICBwaXRjaDogNjAsXHJcbiAgICAgICAgcG9zOiA3XHJcbiAgICB9LFxyXG4gICAgXCJkXCI6IHtcclxuICAgICAgICBvY3RhdmU6IDUsXHJcbiAgICAgICAgcGl0Y2g6IDYyLFxyXG4gICAgICAgIHBvczogOFxyXG4gICAgfSxcclxuICAgIFwiZVwiOiB7XHJcbiAgICAgICAgb2N0YXZlOiA1LFxyXG4gICAgICAgIHBpdGNoOiA2NCxcclxuICAgICAgICBwb3M6IDlcclxuICAgIH0sXHJcbiAgICBcImZcIjoge1xyXG4gICAgICAgIG9jdGF2ZTogNSxcclxuICAgICAgICBwaXRjaDogNjUsXHJcbiAgICAgICAgcG9zOiAxMFxyXG4gICAgfSxcclxuICAgIFwiZ1wiOiB7XHJcbiAgICAgICAgb2N0YXZlOiA1LFxyXG4gICAgICAgIHBpdGNoOiA2NyxcclxuICAgICAgICBwb3M6IDExXHJcbiAgICB9LFxyXG4gICAgXCJhXCI6IHtcclxuICAgICAgICBvY3RhdmU6IDUsXHJcbiAgICAgICAgcGl0Y2g6IDY5LFxyXG4gICAgICAgIHBvczogMTJcclxuICAgIH0sXHJcbiAgICBcImJcIjoge1xyXG4gICAgICAgIG9jdGF2ZTogNSxcclxuICAgICAgICBwaXRjaDogNzEsXHJcbiAgICAgICAgcG9zOiAxM1xyXG4gICAgfSxcclxufTtcclxuXHJcbmRhdGFfdGFibGVzLnN5bWJvbF93aWR0aCA9IHtcclxuICAgIFwibm90ZVwiOiBmdW5jdGlvbihub3RlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5vdGUubm90ZWxlbmd0aDtcclxuICAgIH0sXHJcbiAgICBcInJlc3RcIjogMSxcclxuICAgIFwiYmVhdF9yZXN0XCI6IDEsXHJcbiAgICBcImJhcmxpbmVcIjogMVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBkYXRhX3RhYmxlcztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZW5naW5lL2RhdGFfdGFibGVzLmpzXG4gKiogbW9kdWxlIGlkID0gMjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhclxyXG4gICAgXyA9IHJlcXVpcmUoJ3ZlbmRvcicpLmxvZGFzaCxcclxuICAgIExleGVyID0gcmVxdWlyZSgndmVuZG9yJykubGV4O1xyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vLyBIRUxQRVIgRlVOQ1RJT05TIC8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxudmFyIHNpbXBsZVR5cGUgPSBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogbmFtZVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciBjaGFyQ291bnRJblN0cmluZyA9IGZ1bmN0aW9uKHN0cmluZywgY2hhcmFjdGVyKSB7XHJcbiAgICByZXR1cm4gc3RyaW5nLnNwbGl0KGNoYXJhY3RlcikubGVuZ3RoIC0gMTtcclxufVxyXG5cclxudmFyIGFkZFNpbXBsZVN0cmluZ0luZm9ybWF0aW9uRmllbGQgPSBmdW5jdGlvbihzcGVjLCBrZXksIHR5cGUpIHtcclxuICAgIHNwZWMuc3RhcnRba2V5ICsgXCI6ICooW15cXG5dKilcXG4/XCJdID0gZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGVfY2xhc3M6IFwiZGF0YVwiLFxyXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgICAgICBkYXRhOiBkYXRhXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8gICAgICAgICAgICBMRVhFUiAgICAgICAgICAgLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbnZhciBsZXhlciA9IG5ldyBMZXhlcjtcclxuXHJcbi8vLy8vLy8vLy8vXHJcbi8vIE5PVEVTIC8vXHJcbi8vLy8vLy8vLy8vXHJcbmxleGVyLmFkZFJ1bGUoLyhbQS1HYS1nXSkvLCBmdW5jdGlvbihub3RlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IFwibm90ZVwiLFxyXG4gICAgICAgIHN1YlR5cGU6IFwibGV0dGVyXCIsXHJcbiAgICAgICAgZGF0YTogbm90ZVxyXG4gICAgfVxyXG59KTtcclxuXHJcbi8vLy8vLy8vLy8vXHJcbi8vIFJFU1RTIC8vXHJcbi8vLy8vLy8vLy8vXHJcbmxleGVyLmFkZFJ1bGUoL3ovLCBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogXCJyZXN0XCIsXHJcbiAgICAgICAgc3ViVHlwZTogXCJ2aXNpYmxlXCIsXHJcbiAgICAgICAgZGF0YTogXCJzaG9ydFwiXHJcbiAgICB9XHJcbn0pLmFkZFJ1bGUoL3gvLCBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogXCJyZXN0XCIsXHJcbiAgICAgICAgc3ViVHlwZTogXCJpbnZpc2libGVcIixcclxuICAgICAgICBkYXRhOiBcInNob3J0XCJcclxuICAgIH1cclxufSkuYWRkUnVsZSgvWi8sIGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiBcInJlc3RcIixcclxuICAgICAgICBzdWJUeXBlOiBcInZpc2libGVcIixcclxuICAgICAgICBkYXRhOiBcImxvbmdcIlxyXG4gICAgfVxyXG59KS5hZGRSdWxlKC9YLywgZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IFwicmVzdFwiLFxyXG4gICAgICAgIHN1YlR5cGU6IFwiaW52aXNpYmxlXCIsXHJcbiAgICAgICAgZGF0YTogXCJsb25nXCJcclxuICAgIH1cclxufSk7XHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vIE5PVEUgQU5EIFJFU1QgREVDT1JBVElPTlMgLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5sZXhlci5hZGRSdWxlKC8oWzAtOV0rKVxcLz8oWzAtOV0rKT8vLCBmdW5jdGlvbihhbGwsIG5vdGVsZW5ndGgsIG5vdGVkZW5vbSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiBcIm5vdGVcIixcclxuICAgICAgICBzdWJUeXBlOiBcImxlbmd0aFwiLFxyXG4gICAgICAgIGRhdGE6IG5vdGVkZW5vbSAmJiBub3RlZGVub20ubGVuZ3RoID4gMCA/IHBhcnNlRmxvYXQobm90ZWxlbmd0aCkgLyBwYXJzZUZsb2F0KG5vdGVkZW5vbSkgOiBwYXJzZUludChub3RlbGVuZ3RoKSxcclxuICAgIH1cclxufSkuYWRkUnVsZSgvKFsnLF0rKS8sIGZ1bmN0aW9uKHBpdGNoTW9kaWZpZXIpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogXCJub3RlXCIsXHJcbiAgICAgICAgc3ViVHlwZTogXCJwaXRjaFwiLFxyXG4gICAgICAgIGRhdGE6IGNoYXJDb3VudEluU3RyaW5nKHBpdGNoTW9kaWZpZXIsIFwiJ1wiKSAtIGNoYXJDb3VudEluU3RyaW5nKHBpdGNoTW9kaWZpZXIsIFwiLFwiKVxyXG4gICAgfVxyXG59KS5hZGRSdWxlKC8oX3xcXF58PXxfX3xcXF5cXF4pLywgZnVuY3Rpb24oYWNjaWRlbnRhbCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiBcIm5vdGVcIixcclxuICAgICAgICBzdWJUeXBlOiBcImFjY2lkZW50YWxcIixcclxuICAgICAgICBkYXRhOiBhY2NpZGVudGFsXHJcbiAgICB9XHJcbn0pLmFkZFJ1bGUoL1wiKFteXCJdKylcIi8sIGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogXCJjaG9yZF9hbm5vdGF0aW9uXCIsXHJcbiAgICAgICAgZGF0YTogZGF0YVxyXG4gICAgfVxyXG59KS5hZGRSdWxlKC8hKFteIV0rKSEvLCBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IFwiZGVjb3JhdGlvblwiLFxyXG4gICAgICAgIGRhdGE6IGRhdGFcclxuICAgIH1cclxufSk7XHJcblxyXG4vLy8vLy8vLy8vLy8vLy9cclxuLy8gQkFSIExJTkVTIC8vXHJcbi8vLy8vLy8vLy8vLy8vL1xyXG5sZXhlci5hZGRSdWxlKC9cXHwvLCBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogXCJiYXJsaW5lXCJcclxuICAgIH1cclxufSkuYWRkUnVsZSgvXFx8XFxdLywgZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IFwiYmFybGluZVwiXHJcbiAgICB9XHJcbn0pLmFkZFJ1bGUoL1xcfFxcfC8sIGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiBcImJhcmxpbmVcIlxyXG4gICAgfVxyXG59KS5hZGRSdWxlKC9cXFtcXHwvLCBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogXCJiYXJsaW5lXCJcclxuICAgIH1cclxufSkuYWRkUnVsZSgvOlxcfC8sIGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiBcImJhcmxpbmVcIlxyXG4gICAgfVxyXG59KS5hZGRSdWxlKC9cXHw6LywgZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IFwiYmFybGluZVwiXHJcbiAgICB9XHJcbn0pLmFkZFJ1bGUoLzo6LywgZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IFwiYmFybGluZVwiXHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8gTk9URSBHUk9VUFMgLy9cclxuLy8vLy8vLy8vLy8vLy8vLy9cclxubGV4ZXIuYWRkUnVsZSgvXFxbLywgZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IFwiY2hvcmRfc3RhcnRcIlxyXG4gICAgfVxyXG59KS5hZGRSdWxlKC9cXF0vLCBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogXCJjaG9yZF9zdG9wXCJcclxuICAgIH1cclxuXHJcbn0pLmFkZFJ1bGUoL3svLCBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogXCJncmFjZV9zdGFydFwiXHJcbiAgICB9XHJcbn0pLmFkZFJ1bGUoL30vLCBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogXCJncmFjZV9zdG9wXCJcclxuICAgIH1cclxufSkuYWRkUnVsZSgvXFwoLywgZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IFwic2x1cl9zdGFydFwiXHJcbiAgICB9XHJcbn0pLmFkZFJ1bGUoL1xcKS8sIGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiBcInNsdXJfc3RvcFwiXHJcbiAgICB9XHJcbn0pO1xyXG5cclxuXHJcblxyXG4vLy8vLy8vLy8vL1xyXG4vLyBPVEhFUiAvL1xyXG4vLy8vLy8vLy8vL1xyXG5sZXhlci5hZGRSdWxlKC8gLywgZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IFwic3BhY2VcIlxyXG4gICAgfVxyXG59KS5hZGRSdWxlKC9gLywgZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IFwiYmVhbVwiXHJcbiAgICB9XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpbnB1dCkge1xyXG4gICAgbGV4ZXIuc2V0SW5wdXQoaW5wdXQpO1xyXG4gICAgdmFyIG91dHB1dCA9IFtdO1xyXG4gICAgZm9yKHZhciBpPTAsIGRhdGEgPSBsZXhlci5sZXgoKTsgZGF0YSAhPSB1bmRlZmluZWQ7IGRhdGEgPSBsZXhlci5sZXgoKSkge1xyXG4gICAgICAgIG91dHB1dFtpXSA9IGRhdGE7XHJcbiAgICAgICAgaSsrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG91dHB1dDtcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZW5naW5lL2xleGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBkcmF3aW5nX2Z1bmN0aW9ucyA9IHt9LFxyXG4gICAgcmFuZG9tQ29sb3IgPSByZXF1aXJlKCdyYW5kb21jb2xvcicpLFxyXG4gICAgZ2x5cGhzID0gcmVxdWlyZSgnLi9nbHlwaHMnKSxcclxuICAgIF8gPSByZXF1aXJlKCd2ZW5kb3InKS5sb2Rhc2g7XHJcblxyXG5kcmF3aW5nX2Z1bmN0aW9ucy5ub3RlID0gZnVuY3Rpb24obGluZSwgY3VycmVudE5vdGUsIHRvdGFsT2Zmc2V0LCBmb3JjZV9kb3duX3N0ZW0pIHtcclxuXHJcbiAgICB2YXIgbm90ZWRvdCA9IG51bGw7XHJcblxyXG4gICAgdmFyIG5vdGVHcm91cCA9IGxpbmUuZ3JvdXAoKTtcclxuXHJcbiAgICB2YXIgY29sb3IgPSAnIzAwMCc7XHJcblxyXG4gICAgaWYoY3VycmVudE5vdGUubm90ZWxlbmd0aCA8IDQpIHtcclxuICAgICAgICAvL25vdGVkb3QgPSBub3RlR3JvdXAuZWxsaXBzZSgxMCwgOCkuYXR0cih7XHJcbiAgICAgICAgLy8gICAgZmlsbDogY29sb3JcclxuICAgICAgICAvL30pO1xyXG4gICAgICAgIG5vdGVkb3QgPSBub3RlR3JvdXAucGF0aChnbHlwaHNbXCJub3RlaGVhZHMucXVhcnRlclwiXS5kKS5hdHRyKHsgZmlsbDogJ2JsYWNrJ30pLm1vdmUoMCw0KTtcclxuICAgIH0gZWxzZSBpZiAoY3VycmVudE5vdGUubm90ZWxlbmd0aCA8IDgpe1xyXG4gICAgICAgIG5vdGVkb3QgPSBub3RlR3JvdXAucGF0aChnbHlwaHNbXCJub3RlaGVhZHMuaGFsZlwiXS5kKS5hdHRyKHsgZmlsbDogJ2JsYWNrJ30pLm1vdmUoMCw0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbm90ZWRvdCA9IG5vdGVHcm91cC5wYXRoKGdseXBoc1tcIm5vdGVoZWFkcy53aG9sZVwiXS5kKS5hdHRyKHsgZmlsbDogJ2JsYWNrJ30pLm1vdmUoMCw0KTtcclxuICAgIH1cclxuXHJcbiAgICBpZihjdXJyZW50Tm90ZS5ub3RlbGVuZ3RoIDwgOCkge1xyXG4gICAgICAgIGlmIChjdXJyZW50Tm90ZS5wb3MgPiA1IHx8IGZvcmNlX2Rvd25fc3RlbSA9PT0gMSkge1xyXG4gICAgICAgICAgICBub3RlR3JvdXAubGluZSgwLCA4LCAwLCAzNCkuc3Ryb2tlKHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiAxLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZihjdXJyZW50Tm90ZS5ub3RlbGVuZ3RoID09IDEpIG5vdGVHcm91cC5wYXRoKGdseXBoc1tcImZsYWdzLnU4dGhcIl0uZCkuYXR0cih7IGZpbGw6ICdibGFjayd9KS5zY2FsZSgxLjIsIC0wLjkpLm1vdmUoMCwtMzgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5vdGVHcm91cC5saW5lKDAsIDQuNSwgMCwgLTI0KS5zdHJva2Uoe1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3JcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIG5vdGVkb3QubW92ZSgtMTAsIDApO1xyXG4gICAgICAgICAgICBpZihjdXJyZW50Tm90ZS5ub3RlbGVuZ3RoID09IDEpIG5vdGVHcm91cC5wYXRoKGdseXBoc1tcImZsYWdzLnU4dGhcIl0uZCkuYXR0cih7IGZpbGw6ICdibGFjayd9KS5tb3ZlKDAsLTI0KS5zY2FsZSgxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbm90ZUdyb3VwLm1vdmUodG90YWxPZmZzZXQsIDM2IC0gKGN1cnJlbnROb3RlLnBvcyAqIDQpKTtcclxufTtcclxuXHJcbmRyYXdpbmdfZnVuY3Rpb25zLmJhcmxpbmUgPSBmdW5jdGlvbihsaW5lLCBjdXJyZW50U3ltYm9sLCB0b3RhbE9mZnNldCkge1xyXG4gICAgbGluZS5yZWN0KDEsIDMyKS5tb3ZlKHRvdGFsT2Zmc2V0LCAwKS5hdHRyKHtcclxuICAgICAgICBmaWxsOiAnYmxhY2snXHJcbiAgICB9KTtcclxufTtcclxuXHJcbmRyYXdpbmdfZnVuY3Rpb25zLnNwYWNlID0gXy5ub29wO1xyXG5cclxuZHJhd2luZ19mdW5jdGlvbnMuYmVhdF9yZXN0ID0gZnVuY3Rpb24obGluZSwgY3VycmVudFN5bWJvbCwgdG90YWxPZmZzZXQpIHtcclxuICAgIGxpbmUucGF0aChnbHlwaHNbXCJyZXN0cy5xdWFydGVyXCJdLmQpLmF0dHIoeyBmaWxsOiAnYmxhY2snfSkubW92ZSh0b3RhbE9mZnNldCw2KTtcclxufVxyXG5cclxuZHJhd2luZ19mdW5jdGlvbnMudHJlYmxlX2NsZWYgPSBmdW5jdGlvbihsaW5lKSB7XHJcbiAgICBsaW5lLnBhdGgoZ2x5cGhzW1wiY2xlZnMuR1wiXS5kKS5hdHRyKHsgZmlsbDogJ2JsYWNrJ30pLm1vdmUoOCwtMTIpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGRyYXdpbmdfZnVuY3Rpb25zO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9lbmdpbmUvcmVuZGVyaW5nL3N0YXZlX3N5bWJvbHMuanNcbiAqKiBtb2R1bGUgaWQgPSAyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGRhdGEgPSB7fTtcclxuXHJcbnZhciBpbmZvcm1hdGlvbkZpZWxkRnVuY3Rpb25zID0ge1xyXG4gICAgXCJ0aXRsZVwiOiBmdW5jdGlvbihhLCBkcmF3KSB7XHJcbiAgICAgICAgaWYgKGRhdGEudGl0bGUpIGRhdGEudGl0bGUucmVtb3ZlKCk7XHJcbiAgICAgICAgZGF0YS50aXRsZSA9IGRyYXcudGV4dChhLnBhcnNlZFswXS5kYXRhKS5mb250KHtcclxuICAgICAgICAgICAgZmFtaWx5OiAnR2VvcmdpYScsXHJcbiAgICAgICAgICAgIHNpemU6IDMyLFxyXG4gICAgICAgICAgICBhbmNob3I6ICdtaWRkbGUnLFxyXG4gICAgICAgICAgICBsZWFkaW5nOiAnMS41ZW0nXHJcbiAgICAgICAgfSkubW92ZSg0MDAsIDApO1xyXG4gICAgfSxcclxuICAgIFwicmh5dGhtXCI6IGZ1bmN0aW9uKGEsIGRyYXcpIHtcclxuICAgICAgICBpZiAoZGF0YS5yaHl0aG0pIGRhdGEucmh5dGhtLnJlbW92ZSgpO1xyXG4gICAgICAgIGRhdGEucmh5dGhtID0gZHJhdy50ZXh0KGEucGFyc2VkWzBdLmRhdGEpLmZvbnQoe1xyXG4gICAgICAgICAgICBmYW1pbHk6ICdHZW9yZ2lhJyxcclxuICAgICAgICAgICAgc2l6ZTogMTYsXHJcbiAgICAgICAgICAgIGFuY2hvcjogJ21pZGRsZScsXHJcbiAgICAgICAgICAgIGxlYWRpbmc6ICcxLjVlbSdcclxuICAgICAgICB9KS5tb3ZlKDIwLCA2MCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciBkZWxJbmZvcm1hdGlvbkZpZWxkRnVuY3Rpb25zID0ge1xyXG4gICAgXCJ0aXRsZVwiOiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgZGF0YS50aXRsZS5yZW1vdmUoKTtcclxuICAgICAgICBkYXRhLnRpdGxlID0gbnVsbDtcclxuICAgIH0sXHJcbiAgICBcInJoeXRobVwiOiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgZGF0YS5yaHl0aG0ucmVtb3ZlKCk7XHJcbiAgICAgICAgZGF0YS5yaHl0aG0gPSBudWxsO1xyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGFkZDogaW5mb3JtYXRpb25GaWVsZEZ1bmN0aW9ucyxcclxuICAgIHJlbW92ZTogZGVsSW5mb3JtYXRpb25GaWVsZEZ1bmN0aW9uc1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9lbmdpbmUvcmVuZGVyaW5nL2RhdGFfZmllbGRzLmpzXG4gKiogbW9kdWxlIGlkID0gMzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgXCIwXCI6IHtcclxuICAgICAgICBcIndcIjogMTAuNzgsXHJcbiAgICAgICAgXCJoXCI6IDE0Ljk1OSxcclxuICAgICAgICBcImRcIjogXCJNNC44MywtMTQuOTdjMC4zMywtMC4wMywxLjExLDAsMS40NywwLjA2YzEuNjgsMC4zNiwyLjk3LDEuNTksMy43OCwzLjZjMS4yLDIuOTcsMC44MSw2Ljk2LC0wLjksOS4yN2MtMC43OCwxLjA4LC0xLjcxLDEuNzEsLTIuOTEsMS45NWMtMC40NSwwLjA5LC0xLjMyLDAuMDksLTEuNzcsMGMtMC44MSwtMC4xOCwtMS40NywtMC41MSwtMi4wNywtMS4wMmMtMi4zNCwtMi4wNywtMy4xNSwtNi43MiwtMS43NCwtMTAuMmMwLjg3LC0yLjE2LDIuMjgsLTMuNDIsNC4xNCwtMy42NnptMS4xMSwwLjg3Yy0wLjIxLC0wLjA2LC0wLjY5LC0wLjA5LC0wLjg3LC0wLjA2Yy0wLjU0LDAuMTIsLTAuODcsMC40MiwtMS4xNywwLjk5Yy0wLjM2LDAuNjYsLTAuNTEsMS41NiwtMC42LDNjLTAuMDMsMC43NSwtMC4wMyw0LjU5LDAsNS4zMWMwLjA5LDEuNSwwLjI3LDIuNCwwLjYsMy4wNmMwLjI0LDAuNDgsMC41NywwLjc4LDAuOTYsMC45YzAuMjcsMC4wOSwwLjc4LDAuMDksMS4wNSwwYzAuMzksLTAuMTIsMC43MiwtMC40MiwwLjk2LC0wLjljMC4zMywtMC42NiwwLjUxLC0xLjU2LDAuNiwtMy4wNmMwLjAzLC0wLjcyLDAuMDMsLTQuNTYsMCwtNS4zMWMtMC4wOSwtMS40NywtMC4yNywtMi4zNywtMC42LC0zLjAzYy0wLjI0LC0wLjQ4LC0wLjU0LC0wLjc4LC0wLjkzLC0wLjl6XCJcclxuICAgIH0sXHJcbiAgICBcIjFcIjoge1xyXG4gICAgICAgIFwid1wiOiA4Ljk0LFxyXG4gICAgICAgIFwiaFwiOiAxNS4wNTgsXHJcbiAgICAgICAgXCJkXCI6IFwiTTMuMywtMTUuMDZjMC4wNiwtMC4wNiwwLjIxLC0wLjAzLDAuNjYsMC4xNWMwLjgxLDAuMzksMS4wOCwwLjM5LDEuODMsMC4wM2MwLjIxLC0wLjA5LDAuMzksLTAuMTUsMC40MiwtMC4xNWMwLjEyLDAsMC4yMSwwLjA5LDAuMjcsMC4yMWMwLjA2LDAuMTIsMC4wNiwwLjMzLDAuMDYsNS45NGMwLDMuOTMsMCw1Ljg1LDAuMDMsNi4wM2MwLjA2LDAuMzYsMC4xNSwwLjY5LDAuMjcsMC45NmMwLjM2LDAuNzUsMC45MywxLjE3LDEuNjgsMS4yNmMwLjMsMC4wMywwLjM5LDAuMDksMC4zOSwwLjNjMCwwLjE1LC0wLjAzLDAuMTgsLTAuMDksMC4yNGMtMC4wNiwwLjA2LC0wLjA5LDAuMDYsLTAuNDgsMC4wNmMtMC40MiwwLC0wLjY5LC0wLjAzLC0yLjEsLTAuMjRjLTAuOSwtMC4xNSwtMS43NywtMC4xNSwtMi42NywwYy0xLjQxLDAuMjEsLTEuNjgsMC4yNCwtMi4xLDAuMjRjLTAuMzksMCwtMC40MiwwLC0wLjQ4LC0wLjA2Yy0wLjA2LC0wLjA2LC0wLjA2LC0wLjA5LC0wLjA2LC0wLjI0YzAsLTAuMjEsMC4wNiwtMC4yNywwLjM2LC0wLjNjMC43NSwtMC4wOSwxLjMyLC0wLjUxLDEuNjgsLTEuMjZjMC4xMiwtMC4yNywwLjIxLC0wLjYsMC4yNywtMC45NmMwLjAzLC0wLjE4LDAuMDMsLTEuNTksMC4wMywtNC4yOWMwLC0zLjg3LDAsLTQuMDUsLTAuMDYsLTQuMTRjLTAuMDksLTAuMTUsLTAuMTgsLTAuMjQsLTAuMzksLTAuMjRjLTAuMTIsMCwtMC4xNSwwLjAzLC0wLjIxLDAuMDZjLTAuMDMsMC4wNiwtMC40NSwwLjk5LC0wLjk2LDIuMTNjLTAuNDgsMS4xNCwtMC45LDIuMSwtMC45MywyLjE2Yy0wLjA2LDAuMTUsLTAuMjEsMC4yNCwtMC4zMywwLjI0Yy0wLjI0LDAsLTAuNDIsLTAuMTgsLTAuNDIsLTAuMzljMCwtMC4wNiwzLjI3LC03LjYyLDMuMzMsLTcuNzR6XCJcclxuICAgIH0sXHJcbiAgICBcIjJcIjoge1xyXG4gICAgICAgIFwid1wiOiAxMC43NjQsXHJcbiAgICAgICAgXCJoXCI6IDE0Ljk5MyxcclxuICAgICAgICBcImRcIjogXCJNNC4yMywtMTQuOTdjMC41NywtMC4wNiwxLjY4LDAsMi4zNCwwLjE4YzAuNjksMC4xOCwxLjUsMC41NCwyLjAxLDAuOWMxLjM1LDAuOTYsMS45NSwyLjI1LDEuNzcsMy44MWMtMC4xNSwxLjM1LC0wLjY2LDIuMzQsLTEuNjgsMy4xNWMtMC42LDAuNDgsLTEuNDQsMC45MywtMy4xMiwxLjY1Yy0xLjMyLDAuNTcsLTEuOCwwLjgxLC0yLjM3LDEuMTRjLTAuNTcsMC4zMywtMC41NywwLjMzLC0wLjI0LDAuMjdjMC4zOSwtMC4wOSwxLjI2LC0wLjA5LDEuNjgsMGMwLjcyLDAuMTUsMS40MSwwLjQ1LDIuMSwwLjljMC45OSwwLjYzLDEuODYsMC44NywyLjU1LDAuNzVjMC4yNCwtMC4wNiwwLjQyLC0wLjE1LDAuNTcsLTAuM2MwLjEyLC0wLjA5LDAuMywtMC40MiwwLjMsLTAuNTFjMCwtMC4wOSwwLjEyLC0wLjIxLDAuMjQsLTAuMjRjMC4xOCwtMC4wMywwLjM5LDAuMTIsMC4zOSwwLjNjMCwwLjEyLC0wLjE1LDAuNTcsLTAuMywwLjg3Yy0wLjU0LDEuMDIsLTEuNTYsMS43NCwtMi43OSwyLjAxYy0wLjQyLDAuMDksLTEuMjMsMC4wOSwtMS42MiwwLjAzYy0wLjgxLC0wLjE4LC0xLjMyLC0wLjQ1LC0yLjAxLC0xLjExYy0wLjQ1LC0wLjQ1LC0wLjYzLC0wLjU3LC0wLjk2LC0wLjY5Yy0wLjg0LC0wLjI3LC0xLjg5LDAuMTIsLTIuMjUsMC45Yy0wLjEyLDAuMjEsLTAuMjEsMC41NCwtMC4yMSwwLjcyYzAsMC4xMiwtMC4xMiwwLjIxLC0wLjI3LDAuMjRjLTAuMTUsMCwtMC4yNywtMC4wMywtMC4zMywtMC4xNWMtMC4wOSwtMC4yMSwwLjA5LC0xLjA4LDAuMzMsLTEuNzFjMC4yNCwtMC42NiwwLjY2LC0xLjI2LDEuMjksLTEuODljMC40NSwtMC40NSwwLjksLTAuODEsMS45MiwtMS41NmMxLjI5LC0wLjkzLDEuODksLTEuNDQsMi4zNCwtMS45OGMwLjg3LC0xLjA1LDEuMjYsLTIuMTksMS4yLC0zLjYzYy0wLjA2LC0xLjI5LC0wLjM5LC0yLjMxLC0wLjk2LC0yLjkxYy0wLjM2LC0wLjMzLC0wLjcyLC0wLjUxLC0xLjE3LC0wLjU0Yy0wLjg0LC0wLjAzLC0xLjUzLDAuNDIsLTEuNTksMS4wNWMtMC4wMywwLjMzLDAuMTIsMC42LDAuNTcsMS4xNGMwLjQ1LDAuNTQsMC41NCwwLjg3LDAuNDIsMS40MWMtMC4xNSwwLjYzLC0wLjU0LDEuMTEsLTEuMDgsMS4zOGMtMC42MywwLjMzLC0xLjIsMC4zMywtMS44MywwYy0wLjI0LC0wLjEyLC0wLjMzLC0wLjE4LC0wLjU0LC0wLjM5Yy0wLjE4LC0wLjE4LC0wLjI3LC0wLjMsLTAuMzYsLTAuNTFjLTAuMjQsLTAuNDUsLTAuMjcsLTAuODQsLTAuMjEsLTEuMzhjMC4xMiwtMC43NSwwLjQ1LC0xLjQxLDEuMDIsLTEuOThjMC43MiwtMC43MiwxLjc0LC0xLjE3LDIuODUsLTEuMzJ6XCJcclxuICAgIH0sXHJcbiAgICBcIjNcIjoge1xyXG4gICAgICAgIFwid1wiOiA5LjczNSxcclxuICAgICAgICBcImhcIjogMTQuOTY3LFxyXG4gICAgICAgIFwiZFwiOiBcIk0zLjc4LC0xNC45N2MwLjMsLTAuMDMsMS40MSwwLDEuODMsMC4wNmMyLjIyLDAuMywzLjUxLDEuMzIsMy43MiwyLjkxYzAuMDMsMC4zMywwLjAzLDEuMjYsLTAuMDMsMS42NWMtMC4xMiwwLjg0LC0wLjQ4LDEuNDcsLTEuMDUsMS43N2MtMC4yNywwLjE1LC0wLjM2LDAuMjQsLTAuNDUsMC4zOWMtMC4wOSwwLjIxLC0wLjA5LDAuMzYsMCwwLjU3YzAuMDksMC4xNSwwLjE4LDAuMjQsMC41MSwwLjM5YzAuNzUsMC40MiwxLjIzLDEuMTQsMS40MSwyLjEzYzAuMDYsMC40MiwwLjA2LDEuMzUsMCwxLjcxYy0wLjE4LDAuODEsLTAuNDgsMS4zOCwtMS4wMiwxLjk1Yy0wLjc1LDAuNzIsLTEuOCwxLjIsLTMuMTgsMS4zOGMtMC40MiwwLjA2LC0xLjU2LDAuMDYsLTEuOTUsMGMtMS44OSwtMC4zMywtMy4xOCwtMS4yOSwtMy41MSwtMi42NGMtMC4wMywtMC4xMiwtMC4wMywtMC4zMywtMC4wMywtMC42YzAsLTAuMzYsMCwtMC40MiwwLjA2LC0wLjYzYzAuMTIsLTAuMywwLjI3LC0wLjUxLDAuNTEsLTAuNzVjMC4yNCwtMC4yNCwwLjQ1LC0wLjM5LDAuNzUsLTAuNTFjMC4yMSwtMC4wNiwwLjI3LC0wLjA2LDAuNiwtMC4wNmMwLjMzLDAsMC4zOSwwLDAuNiwwLjA2YzAuMywwLjEyLDAuNTEsMC4yNywwLjc1LDAuNTFjMC4zNiwwLjMzLDAuNTcsMC43NSwwLjYsMS4yYzAsMC4yMSwwLDAuMjcsLTAuMDYsMC40MmMtMC4wOSwwLjE4LC0wLjEyLDAuMjQsLTAuNTQsMC41NGMtMC41MSwwLjM2LC0wLjYzLDAuNTQsLTAuNiwwLjg3YzAuMDYsMC41NCwwLjU0LDAuOSwxLjM4LDAuOTljMC4zNiwwLjA2LDAuNzIsMC4wMywwLjk2LC0wLjA2YzAuODEsLTAuMjcsMS4yOSwtMS4yMywxLjQ0LC0yLjc5YzAuMDMsLTAuNDUsMC4wMywtMS45NSwtMC4wMywtMi4zN2MtMC4wOSwtMC43NSwtMC4zMywtMS4yMywtMC43NSwtMS40NGMtMC4zMywtMC4xOCwtMC40NSwtMC4xOCwtMS45OCwtMC4xOGMtMS4zNSwwLC0xLjQxLDAsLTEuNSwtMC4wNmMtMC4xOCwtMC4xMiwtMC4yNCwtMC4zOSwtMC4xMiwtMC42YzAuMTIsLTAuMTUsMC4xNSwtMC4xNSwxLjY4LC0wLjE1YzEuNSwwLDEuNjIsMCwxLjg5LC0wLjE1YzAuMTgsLTAuMDksMC40MiwtMC4zNiwwLjU0LC0wLjU3YzAuMTgsLTAuNDIsMC4yNywtMC45LDAuMywtMS45NWMwLjAzLC0xLjIsLTAuMDYsLTEuOCwtMC4zNiwtMi4zN2MtMC4yNCwtMC40OCwtMC42MywtMC44MSwtMS4xNCwtMC45NmMtMC4zLC0wLjA2LC0xLjA4LC0wLjA2LC0xLjM4LDAuMDNjLTAuNiwwLjE1LC0wLjksMC40MiwtMC45NiwwLjg0Yy0wLjAzLDAuMywwLjA2LDAuNDUsMC42MywwLjg0YzAuMzMsMC4yNCwwLjQyLDAuMzksMC40NSwwLjYzYzAuMDMsMC43MiwtMC41NywxLjUsLTEuMzIsMS42NWMtMS4wNSwwLjI3LC0yLjEsLTAuNTcsLTIuMSwtMS42NWMwLC0wLjQ1LDAuMTUsLTAuOTYsMC4zOSwtMS4zOGMwLjEyLC0wLjIxLDAuNTQsLTAuNjMsMC44MSwtMC44MWMwLjU3LC0wLjQyLDEuMzgsLTAuNjksMi4yNSwtMC44MXpcIlxyXG4gICAgfSxcclxuICAgIFwiNFwiOiB7XHJcbiAgICAgICAgXCJ3XCI6IDExLjc5NSxcclxuICAgICAgICBcImhcIjogMTQuOTk0LFxyXG4gICAgICAgIFwiZFwiOiBcIk04LjY0LC0xNC45NGMwLjI3LC0wLjA5LDAuNDIsLTAuMTIsMC41NCwtMC4wM2MwLjA5LDAuMDYsMC4xNSwwLjIxLDAuMTUsMC4zYy0wLjAzLDAuMDYsLTEuOTIsMi4zMSwtNC4yMyw1LjA0Yy0yLjMxLDIuNzMsLTQuMjMsNC45OCwtNC4yNiw1LjAxYy0wLjAzLDAuMDYsMC4xMiwwLjA2LDIuNTUsMC4wNmwyLjYxLDBsMCwtMi4zN2MwLC0yLjE5LDAuMDMsLTIuMzcsMC4wNiwtMi40NmMwLjAzLC0wLjA2LDAuMjEsLTAuMTgsMC41NywtMC40MmMxLjA4LC0wLjcyLDEuMzgsLTEuMDgsMS44NiwtMi4xNmMwLjEyLC0wLjMsMC4yNCwtMC41NCwwLjI3LC0wLjU3YzAuMTIsLTAuMTIsMC4zOSwtMC4wNiwwLjQ1LDAuMTJjMC4wNiwwLjA5LDAuMDYsMC41NywwLjA2LDMuOTZsMCwzLjlsMS4wOCwwYzEuMDUsMCwxLjExLDAsMS4yLDAuMDZjMC4yNCwwLjE1LDAuMjQsMC41NCwwLDAuNjljLTAuMDksMC4wNiwtMC4xNSwwLjA2LC0xLjIsMC4wNmwtMS4wOCwwbDAsMC4zM2MwLDAuNTcsMC4wOSwxLjExLDAuMywxLjUzYzAuMzYsMC43NSwwLjkzLDEuMTcsMS42OCwxLjI2YzAuMywwLjAzLDAuMzksMC4wOSwwLjM5LDAuM2MwLDAuMTUsLTAuMDMsMC4xOCwtMC4wOSwwLjI0Yy0wLjA2LDAuMDYsLTAuMDksMC4wNiwtMC40OCwwLjA2Yy0wLjQyLDAsLTAuNjksLTAuMDMsLTIuMSwtMC4yNGMtMC45LC0wLjE1LC0xLjc3LC0wLjE1LC0yLjY3LDBjLTEuNDEsMC4yMSwtMS42OCwwLjI0LC0yLjEsMC4yNGMtMC4zOSwwLC0wLjQyLDAsLTAuNDgsLTAuMDZjLTAuMDYsLTAuMDYsLTAuMDYsLTAuMDksLTAuMDYsLTAuMjRjMCwtMC4yMSwwLjA2LC0wLjI3LDAuMzYsLTAuM2MwLjc1LC0wLjA5LDEuMzIsLTAuNTEsMS42OCwtMS4yNmMwLjIxLC0wLjQyLDAuMywtMC45NiwwLjMsLTEuNTNsMCwtMC4zM2wtMi43LDBjLTIuOTEsMCwtMi44NSwwLC0zLjA5LC0wLjE1Yy0wLjE4LC0wLjEyLC0wLjMsLTAuMzksLTAuMjcsLTAuNTRjMC4wMywtMC4wNiwwLjE4LC0wLjI0LDAuMzMsLTAuNDVjMC43NSwtMC45LDEuNTksLTIuMDcsMi4xMywtMy4wM2MwLjMzLC0wLjU0LDAuODQsLTEuNjIsMS4wNSwtMi4xNmMwLjU3LC0xLjQxLDAuODQsLTIuNjQsMC45LC00LjA1YzAuMDMsLTAuNjMsMC4wNiwtMC43MiwwLjI0LC0wLjgxbDAuMTIsLTAuMDZsMC40NSwwLjEyYzAuNjYsMC4xOCwxLjAyLDAuMjQsMS40NywwLjI3YzAuNiwwLjAzLDEuMjMsLTAuMDksMi4wMSwtMC4zM3pcIlxyXG4gICAgfSxcclxuICAgIFwiNVwiOiB7XHJcbiAgICAgICAgXCJ3XCI6IDEwLjIxMixcclxuICAgICAgICBcImhcIjogMTQuOTk3LFxyXG4gICAgICAgIFwiZFwiOiBcIk0xLjAyLC0xNC45NGMwLjEyLC0wLjA5LDAuMDMsLTAuMDksMS4wOCwwLjA2YzIuNDksMC4zNiw0LjM1LDAuMzYsNi45NiwtMC4wNmMwLjU3LC0wLjA5LDAuNjYsLTAuMDYsMC44MSwwLjA2YzAuMTUsMC4xOCwwLjEyLDAuMjQsLTAuMTUsMC41MWMtMS4yOSwxLjI2LC0zLjI0LDIuMDQsLTUuNTgsMi4zMWMtMC42LDAuMDksLTEuMiwwLjEyLC0xLjcxLDAuMTJjLTAuMzksMCwtMC40NSwwLC0wLjU3LDAuMDZjLTAuMDksMC4wNiwtMC4xNSwwLjEyLC0wLjIxLDAuMjFsLTAuMDYsMC4xMmwwLDEuNjVsMCwxLjY1bDAuMjEsLTAuMjFjMC42NiwtMC41NywxLjQxLC0wLjk2LDIuMTksLTEuMTRjMC4zMywtMC4wNiwxLjQxLC0wLjA2LDEuOTUsMGMyLjYxLDAuMzYsNC4wMiwxLjc0LDQuMjYsNC4xNGMwLjAzLDAuNDUsMC4wMywxLjA4LC0wLjAzLDEuNDRjLTAuMTgsMS4wMiwtMC43OCwyLjAxLC0xLjU5LDIuN2MtMC43MiwwLjU3LC0xLjYyLDEuMDIsLTIuNDksMS4yYy0xLjM4LDAuMjcsLTMuMDMsMC4wNiwtNC4yLC0wLjU0Yy0xLjA4LC0wLjU0LC0xLjcxLC0xLjMyLC0xLjg2LC0yLjI4Yy0wLjA5LC0wLjY5LDAuMDksLTEuMjksMC41NywtMS43NGMwLjI0LC0wLjI0LDAuNDUsLTAuMzksMC43NSwtMC41MWMwLjIxLC0wLjA2LDAuMjcsLTAuMDYsMC42LC0wLjA2YzAuMzMsMCwwLjM5LDAsMC42LDAuMDZjMC4zLDAuMTIsMC41MSwwLjI3LDAuNzUsMC41MWMwLjM2LDAuMzMsMC41NywwLjc1LDAuNiwxLjJjMCwwLjIxLDAsMC4yNywtMC4wNiwwLjQyYy0wLjA5LDAuMTgsLTAuMTIsMC4yNCwtMC41NCwwLjU0Yy0wLjE4LDAuMTIsLTAuMzYsMC4zLC0wLjQyLDAuMzNjLTAuMzYsMC40MiwtMC4xOCwwLjk5LDAuMzYsMS4yNmMwLjUxLDAuMjcsMS40NywwLjM2LDIuMDEsMC4yN2MwLjkzLC0wLjIxLDEuNDcsLTEuMTcsMS42NSwtMi45MWMwLjA2LC0wLjQ1LDAuMDYsLTEuODksMCwtMi4zMWMtMC4xNSwtMS4yLC0wLjUxLC0yLjEsLTEuMDUsLTIuNTVjLTAuMjEsLTAuMTgsLTAuNTQsLTAuMzYsLTAuODEsLTAuMzljLTAuMywtMC4wNiwtMC44NCwtMC4wMywtMS4yNiwwLjA2Yy0wLjkzLDAuMTgsLTEuNjUsMC42LC0yLjE2LDEuMmMtMC4xNSwwLjIxLC0wLjI3LDAuMywtMC4zOSwwLjNjLTAuMTUsMCwtMC4zLC0wLjA5LC0wLjM2LC0wLjE4Yy0wLjA2LC0wLjA5LC0wLjA2LC0wLjE1LC0wLjA2LC0zLjY2YzAsLTMuMzksMCwtMy41NywwLjA2LC0zLjY2YzAuMDMsLTAuMDYsMC4wOSwtMC4xNSwwLjE1LC0wLjE4elwiXHJcbiAgICB9LFxyXG4gICAgXCI2XCI6IHtcclxuICAgICAgICBcIndcIjogOS45NTYsXHJcbiAgICAgICAgXCJoXCI6IDE0Ljk4MixcclxuICAgICAgICBcImRcIjogXCJNNC45OCwtMTQuOTdjMC4zNiwtMC4wMywxLjIsMCwxLjU5LDAuMDZjMC45LDAuMTUsMS42OCwwLjUxLDIuMjUsMS4wNWMwLjU3LDAuNTEsMC44NywxLjIzLDAuODQsMS45OGMtMC4wMywwLjUxLC0wLjIxLDAuOSwtMC42LDEuMjZjLTAuMjQsMC4yNCwtMC40NSwwLjM5LC0wLjc1LDAuNTFjLTAuMjEsMC4wNiwtMC4yNywwLjA2LC0wLjYsMC4wNmMtMC4zMywwLC0wLjM5LDAsLTAuNiwtMC4wNmMtMC4zLC0wLjEyLC0wLjUxLC0wLjI3LC0wLjc1LC0wLjUxYy0wLjM5LC0wLjM2LC0wLjU3LC0wLjc4LC0wLjU3LC0xLjI2YzAsLTAuMjcsMCwtMC4zLDAuMDksLTAuNDJjMC4wMywtMC4wOSwwLjE4LC0wLjIxLDAuMywtMC4zYzAuMTIsLTAuMDksMC4zLC0wLjIxLDAuMzksLTAuMjdjMC4wOSwtMC4wNiwwLjIxLC0wLjE4LDAuMjcsLTAuMjRjMC4wNiwtMC4xMiwwLjA5LC0wLjE1LDAuMDksLTAuMzNjMCwtMC4xOCwtMC4wMywtMC4yNCwtMC4wOSwtMC4zNmMtMC4yNCwtMC4zOSwtMC43NSwtMC42LC0xLjM4LC0wLjU3Yy0wLjU0LDAuMDMsLTAuOSwwLjE4LC0xLjIzLDAuNDhjLTAuODEsMC43MiwtMS4wOCwyLjE2LC0wLjk2LDUuMzdsMCwwLjYzbDAuMywtMC4xMmMwLjc4LC0wLjI3LDEuMjksLTAuMzMsMi4xLC0wLjI3YzEuNDcsMC4xMiwyLjQ5LDAuNTQsMy4yNywxLjI5YzAuNDgsMC41MSwwLjgxLDEuMTEsMC45NiwxLjg5YzAuMDYsMC4yNywwLjA2LDAuNDIsMC4wNiwwLjkzYzAsMC41NCwwLDAuNjksLTAuMDYsMC45NmMtMC4xNSwwLjc4LC0wLjQ4LDEuMzgsLTAuOTYsMS44OWMtMC41NCwwLjUxLC0xLjE3LDAuODcsLTEuOTgsMS4wOGMtMS4xNCwwLjMsLTIuNCwwLjMzLC0zLjI0LDAuMDNjLTEuNSwtMC40OCwtMi42NCwtMS44OSwtMy4yNywtNC4wMmMtMC4zNiwtMS4yMywtMC41MSwtMi44MiwtMC40MiwtNC4wOGMwLjMsLTMuNjYsMi4yOCwtNi4zLDQuOTUsLTYuNjZ6bTAuNjYsNy40MWMtMC4yNywtMC4wOSwtMC44MSwtMC4xMiwtMS4wOCwtMC4wNmMtMC43MiwwLjE4LC0xLjA4LDAuNjksLTEuMjMsMS43MWMtMC4wNiwwLjU0LC0wLjA2LDMsMCwzLjU0YzAuMTgsMS4yNiwwLjcyLDEuNzcsMS44LDEuNzRjMC4zOSwtMC4wMywwLjYzLC0wLjA5LDAuOSwtMC4yN2MwLjY2LC0wLjQyLDAuOSwtMS4zMiwwLjksLTMuMjRjMCwtMi4yMiwtMC4zNiwtMy4xMiwtMS4yOSwtMy40MnpcIlxyXG4gICAgfSxcclxuICAgIFwiN1wiOiB7XHJcbiAgICAgICAgXCJ3XCI6IDEwLjU2MSxcclxuICAgICAgICBcImhcIjogMTUuMDkzLFxyXG4gICAgICAgIFwiZFwiOiBcIk0wLjIxLC0xNC45N2MwLjIxLC0wLjA2LDAuNDUsMCwwLjU0LDAuMTVjMC4wNiwwLjA5LDAuMDYsMC4xNSwwLjA2LDAuMzljMCwwLjI0LDAsMC4zMywwLjA2LDAuNDJjMC4wNiwwLjEyLDAuMjEsMC4yNCwwLjI3LDAuMjRjMC4wMywwLDAuMTIsLTAuMTIsMC4yNCwtMC4yMWMwLjk2LC0xLjIsMi41OCwtMS4zNSwzLjk5LC0wLjQyYzAuMTUsMC4xMiwwLjQyLDAuMywwLjU0LDAuNDVjMC40OCwwLjM5LDAuODEsMC41NywxLjI5LDAuNmMwLjY5LDAuMDMsMS41LC0wLjMsMi4xMywtMC44N2MwLjA5LC0wLjA5LDAuMjcsLTAuMywwLjM5LC0wLjQ1YzAuMTIsLTAuMTUsMC4yNCwtMC4yNywwLjMsLTAuM2MwLjE4LC0wLjA2LDAuMzksMC4wMywwLjUxLDAuMjFjMC4wNiwwLjE4LDAuMDYsMC4yNCwtMC4yNywwLjcyYy0wLjE4LDAuMjQsLTAuNTQsMC43OCwtMC43OCwxLjE3Yy0yLjM3LDMuNTQsLTMuNTQsNi4yNywtMy44Nyw5Yy0wLjAzLDAuMzMsLTAuMDMsMC42NiwtMC4wMywxLjI2YzAsMC45LDAsMS4wOCwwLjE1LDEuODljMC4wNiwwLjQ1LDAuMDYsMC40OCwwLjAzLDAuNmMtMC4wNiwwLjA5LC0wLjIxLDAuMjEsLTAuMywwLjIxYy0wLjAzLDAsLTAuMjcsLTAuMDYsLTAuNTQsLTAuMTVjLTAuODQsLTAuMjcsLTEuMTEsLTAuMywtMS42NSwtMC4zYy0wLjU3LDAsLTAuODQsMC4wMywtMS41NiwwLjI3Yy0wLjYsMC4xOCwtMC42OSwwLjIxLC0wLjgxLDAuMTVjLTAuMTIsLTAuMDYsLTAuMjEsLTAuMTgsLTAuMjEsLTAuM2MwLC0wLjE1LDAuNiwtMS40NCwxLjIsLTIuNjFjMS4xNCwtMi4yMiwyLjczLC00LjY4LDUuMSwtOC4wMWMwLjIxLC0wLjI3LDAuMzYsLTAuNDgsMC4zMywtMC40OGMwLDAsLTAuMTIsMC4wNiwtMC4yNywwLjEyYy0wLjU0LDAuMywtMC45OSwwLjM5LC0xLjU2LDAuMzljLTAuNzUsMC4wMywtMS4yLC0wLjE4LC0xLjgzLC0wLjc1Yy0wLjk5LC0wLjksLTEuODMsLTEuMTcsLTIuMzEsLTAuNzJjLTAuMTgsMC4xNSwtMC4zNiwwLjUxLC0wLjQ1LDAuODRjLTAuMDYsMC4yNCwtMC4wNiwwLjMzLC0wLjA5LDEuOThjMCwxLjYyLC0wLjAzLDEuNzQsLTAuMDYsMS44Yy0wLjE1LDAuMjQsLTAuNTQsMC4yNCwtMC42OSwwYy0wLjA2LC0wLjA5LC0wLjA2LC0wLjE1LC0wLjA2LC0zLjU3YzAsLTMuNDIsMCwtMy40OCwwLjA2LC0zLjU3YzAuMDMsLTAuMDYsMC4wOSwtMC4xMiwwLjE1LC0wLjE1elwiXHJcbiAgICB9LFxyXG4gICAgXCI4XCI6IHtcclxuICAgICAgICBcIndcIjogMTAuOTI2LFxyXG4gICAgICAgIFwiaFwiOiAxNC45ODksXHJcbiAgICAgICAgXCJkXCI6IFwiTTQuOTgsLTE0Ljk3YzAuMzMsLTAuMDMsMS4wMiwtMC4wMywxLjMyLDBjMS4zMiwwLjEyLDIuNDksMC42LDMuMjEsMS4zMmMwLjM5LDAuMzksMC42NiwwLjgxLDAuNzgsMS4yOWMwLjA5LDAuMzYsMC4wOSwxLjA4LDAsMS40NGMtMC4yMSwwLjg0LC0wLjY2LDEuNTksLTEuNTksMi41NWwtMC4zLDAuM2wwLjI3LDAuMThjMS40NywwLjkzLDIuMzEsMi4zMSwyLjI1LDMuNzVjLTAuMDMsMC43NSwtMC4yNCwxLjM1LC0wLjYzLDEuOTVjLTAuNDUsMC42NiwtMS4wMiwxLjE0LC0xLjgzLDEuNTNjLTEuOCwwLjg3LC00LjIsMC44NywtNiwwLjAzYy0xLjYyLC0wLjc4LC0yLjUyLC0yLjE2LC0yLjQ2LC0zLjY2YzAuMDYsLTAuOTksMC41NCwtMS43NywxLjgsLTIuOTdjMC41NCwtMC41MSwwLjU0LC0wLjU0LDAuNDgsLTAuNTdjLTAuMzksLTAuMjcsLTAuOTYsLTAuNzgsLTEuMiwtMS4xNGMtMC43NSwtMS4xMSwtMC44NywtMi40LC0wLjMsLTMuNmMwLjY5LC0xLjM1LDIuMjUsLTIuMjUsNC4yLC0yLjR6bTEuNTMsMC42OWMtMC40MiwtMC4wOSwtMS4xMSwtMC4xMiwtMS4zOCwtMC4wNmMtMC4zLDAuMDYsLTAuNiwwLjE4LC0wLjgxLDAuM2MtMC4yMSwwLjEyLC0wLjYsMC41MSwtMC43MiwwLjcyYy0wLjUxLDAuODcsLTAuNDIsMS44OSwwLjIxLDIuNTJjMC4yMSwwLjIxLDAuMzYsMC4zLDEuOTUsMS4yM2MwLjk2LDAuNTQsMS43NCwwLjk5LDEuNzcsMS4wMmMwLjA5LDAsMC42MywtMC42LDAuOTksLTEuMTFjMC4yMSwtMC4zNiwwLjQ4LC0wLjg3LDAuNTcsLTEuMjNjMC4wNiwtMC4yNCwwLjA2LC0wLjM2LDAuMDYsLTAuNzJjMCwtMC40NSwtMC4wMywtMC42NiwtMC4xNSwtMC45OWMtMC4zOSwtMC44MSwtMS4yOSwtMS40NCwtMi40OSwtMS42OHptLTEuNDQsOC4wN2wtMS44OSwtMS4wOGMtMC4wMywwLC0wLjE4LDAuMTUsLTAuMzksMC4zM2MtMS4yLDEuMDgsLTEuNjUsMS45NSwtMS41OSwzYzAuMDksMS41OSwxLjM1LDIuODUsMy4yMSwzLjI0YzAuMzMsMC4wNiwwLjQ1LDAuMDYsMC45MywwLjA2YzAuNjMsMCwwLjgxLC0wLjAzLDEuMjksLTAuMjdjMC45LC0wLjQyLDEuNDcsLTEuNDEsMS40MSwtMi40Yy0wLjA2LC0wLjY2LC0wLjM5LC0xLjI5LC0wLjksLTEuNjVjLTAuMTIsLTAuMDksLTEuMDUsLTAuNjMsLTIuMDcsLTEuMjN6XCJcclxuICAgIH0sXHJcbiAgICBcIjlcIjoge1xyXG4gICAgICAgIFwid1wiOiA5Ljk1OSxcclxuICAgICAgICBcImhcIjogMTQuOTg2LFxyXG4gICAgICAgIFwiZFwiOiBcIk00LjIzLC0xNC45N2MwLjQyLC0wLjAzLDEuMjksMCwxLjYyLDAuMDZjMC41MSwwLjEyLDAuOTMsMC4zLDEuMzgsMC41N2MxLjUzLDEuMDIsMi41MiwzLjI0LDIuNzMsNS45NGMwLjE4LDIuNTUsLTAuNDgsNC45OCwtMS44Myw2LjU3Yy0xLjA1LDEuMjYsLTIuNCwxLjg5LC0zLjkzLDEuODNjLTEuMjMsLTAuMDYsLTIuMzEsLTAuNDUsLTMuMDMsLTEuMTRjLTAuNTcsLTAuNTEsLTAuODcsLTEuMjMsLTAuODQsLTEuOThjMC4wMywtMC41MSwwLjIxLC0wLjksMC42LC0xLjI2YzAuMjQsLTAuMjQsMC40NSwtMC4zOSwwLjc1LC0wLjUxYzAuMjEsLTAuMDYsMC4yNywtMC4wNiwwLjYsLTAuMDZjMC4zMywwLDAuMzksMCwwLjYsMC4wNmMwLjMsMC4xMiwwLjUxLDAuMjcsMC43NSwwLjUxYzAuMzksMC4zNiwwLjU3LDAuNzgsMC41NywxLjI2YzAsMC4yNywwLDAuMywtMC4wOSwwLjQyYy0wLjAzLDAuMDksLTAuMTgsMC4yMSwtMC4zLDAuM2MtMC4xMiwwLjA5LC0wLjMsMC4yMSwtMC4zOSwwLjI3Yy0wLjA5LDAuMDYsLTAuMjEsMC4xOCwtMC4yNywwLjI0Yy0wLjA2LDAuMTIsLTAuMDYsMC4xNSwtMC4wNiwwLjMzYzAsMC4xOCwwLDAuMjQsMC4wNiwwLjM2YzAuMjQsMC4zOSwwLjc1LDAuNiwxLjM4LDAuNTdjMC41NCwtMC4wMywwLjksLTAuMTgsMS4yMywtMC40OGMwLjgxLC0wLjcyLDEuMDgsLTIuMTYsMC45NiwtNS4zN2wwLC0wLjYzbC0wLjMsMC4xMmMtMC43OCwwLjI3LC0xLjI5LDAuMzMsLTIuMSwwLjI3Yy0xLjQ3LC0wLjEyLC0yLjQ5LC0wLjU0LC0zLjI3LC0xLjI5Yy0wLjQ4LC0wLjUxLC0wLjgxLC0xLjExLC0wLjk2LC0xLjg5Yy0wLjA2LC0wLjI3LC0wLjA2LC0wLjQyLC0wLjA2LC0wLjk2YzAsLTAuNTEsMCwtMC42NiwwLjA2LC0wLjkzYzAuMTUsLTAuNzgsMC40OCwtMS4zOCwwLjk2LC0xLjg5YzAuMTUsLTAuMTIsMC4zMywtMC4yNywwLjQyLC0wLjM2YzAuNjksLTAuNTEsMS42MiwtMC44MSwyLjc2LC0wLjkzem0xLjE3LDAuNjZjLTAuMjEsLTAuMDYsLTAuNTcsLTAuMDYsLTAuODEsLTAuMDNjLTAuNzgsMC4xMiwtMS4yNiwwLjY5LC0xLjQxLDEuNzRjLTAuMTIsMC42MywtMC4xNSwxLjk1LC0wLjA5LDIuNzljMC4xMiwxLjcxLDAuNjMsMi40LDEuNzcsMi40NmMxLjA4LDAuMDMsMS42MiwtMC40OCwxLjgsLTEuNzRjMC4wNiwtMC41NCwwLjA2LC0zLDAsLTMuNTRjLTAuMTUsLTEuMDUsLTAuNTEsLTEuNTMsLTEuMjYsLTEuNjh6XCJcclxuICAgIH0sXHJcbiAgICBcInJlc3RzLndob2xlXCI6IHtcclxuICAgICAgICBcIndcIjogMTEuMjUsXHJcbiAgICAgICAgXCJoXCI6IDQuNjgsXHJcbiAgICAgICAgXCJkXCI6IFwiTTAuMDYsMC4wM2wwLjA5LC0wLjA2bDUuNDYsMGw1LjQ5LDBsMC4wOSwwLjA2bDAuMDYsMC4wOWwwLDIuMTlsMCwyLjE5bC0wLjA2LDAuMDlsLTAuMDksMC4wNmwtNS40OSwwbC01LjQ2LDBsLTAuMDksLTAuMDZsLTAuMDYsLTAuMDlsMCwtMi4xOWwwLC0yLjE5elwiXHJcbiAgICB9LFxyXG4gICAgXCJyZXN0cy5oYWxmXCI6IHtcclxuICAgICAgICBcIndcIjogMTEuMjUsXHJcbiAgICAgICAgXCJoXCI6IDQuNjgsXHJcbiAgICAgICAgXCJkXCI6IFwiTTAuMDYsLTQuNjJsMC4wOSwtMC4wNmw1LjQ2LDBsNS40OSwwbDAuMDksMC4wNmwwLjA2LDAuMDlsMCwyLjE5bDAsMi4xOWwtMC4wNiwwLjA5bC0wLjA5LDAuMDZsLTUuNDksMGwtNS40NiwwbC0wLjA5LC0wLjA2bC0wLjA2LC0wLjA5bDAsLTIuMTlsMCwtMi4xOXpcIlxyXG4gICAgfSxcclxuICAgIFwicmVzdHMucXVhcnRlclwiOiB7XHJcbiAgICAgICAgXCJ3XCI6IDcuODg4LFxyXG4gICAgICAgIFwiaFwiOiAyMS40MzUsXHJcbiAgICAgICAgXCJkXCI6IFwiTTEuODksLTExLjgyYzAuMTIsLTAuMDYsMC4yNCwtMC4wNiwwLjM2LC0wLjAzYzAuMDksMC4wNiw0Ljc0LDUuNTgsNC44Niw1LjgyYzAuMjEsMC4zOSwwLjE1LDAuNzgsLTAuMTUsMS4yNmMtMC4yNCwwLjMzLC0wLjcyLDAuODEsLTEuNjIsMS41NmMtMC40NSwwLjM2LC0wLjg3LDAuNzUsLTAuOTYsMC44NGMtMC45MywwLjk5LC0xLjE0LDIuNDksLTAuNiwzLjYzYzAuMTgsMC4zOSwwLjI3LDAuNDgsMS4zMiwxLjY4YzEuOTIsMi4yNSwxLjgzLDIuMTYsMS44MywyLjM0YzAsMC4xOCwtMC4xOCwwLjM2LC0wLjM2LDAuMzljLTAuMTUsMCwtMC4yNywtMC4wNiwtMC40OCwtMC4yN2MtMC43NSwtMC43NSwtMi40NiwtMS4yOSwtMy4zOSwtMS4wOGMtMC40NSwwLjA5LC0wLjY5LDAuMjcsLTAuOSwwLjY5Yy0wLjEyLDAuMywtMC4yMSwwLjY2LC0wLjI0LDEuMTRjLTAuMDMsMC42NiwwLjA5LDEuMzUsMC4zLDIuMDFjMC4xNSwwLjQyLDAuMjQsMC42NiwwLjQ1LDAuOTZjMC4xOCwwLjI0LDAuMTgsMC4zMywwLjAzLDAuNDJjLTAuMTIsMC4wNiwtMC4xOCwwLjAzLC0wLjQ1LC0wLjNjLTEuMDgsLTEuMzgsLTIuMDcsLTMuMzYsLTIuNCwtNC44M2MtMC4yNywtMS4wNSwtMC4xNSwtMS43NywwLjI3LC0yLjA3YzAuMjEsLTAuMTIsMC40MiwtMC4xNSwwLjg3LC0wLjE1YzAuODcsMC4wNiwyLjEsMC4zOSwzLjMsMC45bDAuMzksMC4xOGwtMS42NSwtMS45NWMtMi41MiwtMi45NywtMi42MSwtMy4wOSwtMi43LC0zLjI3Yy0wLjA5LC0wLjI0LC0wLjEyLC0wLjQ4LC0wLjAzLC0wLjc1YzAuMTUsLTAuNDgsMC41NywtMC45NiwxLjgzLC0yLjAxYzAuNDUsLTAuMzYsMC44NCwtMC43MiwwLjkzLC0wLjc4YzAuNjksLTAuNzUsMS4wMiwtMS44LDAuOSwtMi43OWMtMC4wNiwtMC4zMywtMC4yMSwtMC44NCwtMC4zOSwtMS4xMWMtMC4wOSwtMC4xNSwtMC40NSwtMC42LC0wLjgxLC0xLjA1Yy0wLjM2LC0wLjQyLC0wLjY5LC0wLjgxLC0wLjcyLC0wLjg3Yy0wLjA5LC0wLjE4LDAsLTAuNDIsMC4yMSwtMC41MXpcIlxyXG4gICAgfSxcclxuICAgIFwicmVzdHMuOHRoXCI6IHtcclxuICAgICAgICBcIndcIjogNy41MzQsXHJcbiAgICAgICAgXCJoXCI6IDEzLjg4MyxcclxuICAgICAgICBcImRcIjogXCJNMS42OCwtNi4xMmMwLjY2LC0wLjA5LDEuMjMsMC4wOSwxLjY4LDAuNTFjMC4yNywwLjMsMC4zOSwwLjU0LDAuNTcsMS4yNmMwLjA5LDAuMzMsMC4xOCwwLjY2LDAuMjEsMC43MmMwLjEyLDAuMjcsMC4zMywwLjQ1LDAuNiwwLjQ4YzAuMTIsMCwwLjE4LDAsMC4zMywtMC4wOWMwLjM5LC0wLjE4LDEuMzIsLTEuMjksMS42OCwtMS45OGMwLjA5LC0wLjIxLDAuMjQsLTAuMywwLjM5LC0wLjNjMC4xMiwwLDAuMjcsMC4wOSwwLjMzLDAuMThjMC4wMywwLjA2LC0wLjI3LDEuMTEsLTEuODYsNi40MmMtMS4wMiwzLjQ4LC0xLjg5LDYuMzksLTEuOTIsNi40MmMwLDAuMDMsLTAuMTIsMC4xMiwtMC4yNCwwLjE1Yy0wLjE4LDAuMDksLTAuMjEsMC4wOSwtMC40NSwwLjA5Yy0wLjI0LDAsLTAuMywwLC0wLjQ4LC0wLjA2Yy0wLjA5LC0wLjA2LC0wLjIxLC0wLjEyLC0wLjIxLC0wLjE1Yy0wLjA2LC0wLjAzLDAuMTUsLTAuNTcsMS42OCwtNC45MmMwLjk2LC0yLjY3LDEuNzQsLTQuODksMS43MSwtNC44OWwtMC41MSwwLjE1Yy0xLjA4LDAuMzYsLTEuNzQsMC40OCwtMi41NSwwLjQ4Yy0wLjY2LDAsLTAuODQsLTAuMDMsLTEuMzIsLTAuMjdjLTEuMzIsLTAuNjMsLTEuNzcsLTIuMTYsLTEuMDIsLTMuM2MwLjMzLC0wLjQ1LDAuODQsLTAuODEsMS4zOCwtMC45elwiXHJcbiAgICB9LFxyXG4gICAgXCJyZXN0cy4xNnRoXCI6IHtcclxuICAgICAgICBcIndcIjogOS43MjQsXHJcbiAgICAgICAgXCJoXCI6IDIxLjM4MyxcclxuICAgICAgICBcImRcIjogXCJNMy4zMywtNi4xMmMwLjY2LC0wLjA5LDEuMjMsMC4wOSwxLjY4LDAuNTFjMC4yNywwLjMsMC4zOSwwLjU0LDAuNTcsMS4yNmMwLjA5LDAuMzMsMC4xOCwwLjY2LDAuMjEsMC43MmMwLjE1LDAuMzksMC41NywwLjU3LDAuODcsMC40MmMwLjM5LC0wLjE4LDEuMiwtMS4yMywxLjYyLC0yLjA3YzAuMDYsLTAuMTUsMC4yNCwtMC4yNCwwLjM2LC0wLjI0YzAuMTIsMCwwLjI3LDAuMDksMC4zMywwLjE4YzAuMDMsMC4wNiwtMC40NSwxLjg2LC0yLjY3LDEwLjE3Yy0xLjUsNS41NSwtMi43MywxMC4xNCwtMi43NiwxMC4xN2MtMC4wMywwLjAzLC0wLjEyLDAuMTIsLTAuMjQsMC4xNWMtMC4xOCwwLjA5LC0wLjIxLDAuMDksLTAuNDUsMC4wOWMtMC4yNCwwLC0wLjMsMCwtMC40OCwtMC4wNmMtMC4wOSwtMC4wNiwtMC4yMSwtMC4xMiwtMC4yMSwtMC4xNWMtMC4wNiwtMC4wMywwLjEyLC0wLjU3LDEuNDQsLTQuOTJjMC44MSwtMi42NywxLjQ3LC00Ljg2LDEuNDcsLTQuODljLTAuMDMsMCwtMC4yNywwLjA2LC0wLjU0LDAuMTVjLTEuMDgsMC4zNiwtMS43NywwLjQ4LC0yLjU4LDAuNDhjLTAuNjYsMCwtMC44NCwtMC4wMywtMS4zMiwtMC4yN2MtMS4zMiwtMC42MywtMS43NywtMi4xNiwtMS4wMiwtMy4zYzAuNzIsLTEuMDUsMi4yMiwtMS4yMywzLjA2LC0wLjQyYzAuMywwLjMzLDAuNDIsMC42LDAuNiwxLjM4YzAuMDksMC40NSwwLjIxLDAuNzgsMC4zMywwLjljMC4wOSwwLjA5LDAuMjcsMC4xOCwwLjQ1LDAuMjFjMC4xMiwwLDAuMTgsMCwwLjMzLC0wLjA5YzAuMzMsLTAuMTUsMS4wMiwtMC45MywxLjQxLC0xLjU5YzAuMTIsLTAuMjEsMC4xOCwtMC4zOSwwLjM5LC0xLjA4YzAuNjYsLTIuMSwxLjE3LC0zLjg0LDEuMTcsLTMuODdjMCwwLC0wLjIxLDAuMDYsLTAuNDIsMC4xNWMtMC41MSwwLjE1LC0xLjIsMC4zMywtMS42OCwwLjQyYy0wLjMzLDAuMDYsLTAuNTEsMC4wNiwtMC45NiwwLjA2Yy0wLjY2LDAsLTAuODQsLTAuMDMsLTEuMzIsLTAuMjdjLTEuMzIsLTAuNjMsLTEuNzcsLTIuMTYsLTEuMDIsLTMuM2MwLjMzLC0wLjQ1LDAuODQsLTAuODEsMS4zOCwtMC45elwiXHJcbiAgICB9LFxyXG4gICAgXCJyZXN0cy4zMm5kXCI6IHtcclxuICAgICAgICBcIndcIjogMTEuMzczLFxyXG4gICAgICAgIFwiaFwiOiAyOC44ODMsXHJcbiAgICAgICAgXCJkXCI6IFwiTTQuMjMsLTEzLjYyYzAuNjYsLTAuMDksMS4yMywwLjA5LDEuNjgsMC41MWMwLjI3LDAuMywwLjM5LDAuNTQsMC41NywxLjI2YzAuMDksMC4zMywwLjE4LDAuNjYsMC4yMSwwLjcyYzAuMTIsMC4yNywwLjMzLDAuNDUsMC42LDAuNDhjMC4xMiwwLDAuMTgsMCwwLjI3LC0wLjA2YzAuMzMsLTAuMjEsMC45OSwtMS4xMSwxLjQ0LC0xLjk4YzAuMDksLTAuMjQsMC4yMSwtMC4zMywwLjM5LC0wLjMzYzAuMTIsMCwwLjI3LDAuMDksMC4zMywwLjE4YzAuMDMsMC4wNiwtMC41NywyLjY3LC0zLjIxLDEzLjg5Yy0xLjgsNy42MiwtMy4zLDEzLjg5LC0zLjMsMTMuOTJjLTAuMDMsMC4wNiwtMC4xMiwwLjEyLC0wLjI0LDAuMThjLTAuMjEsMC4wOSwtMC4yNCwwLjA5LC0wLjQ4LDAuMDljLTAuMjQsMCwtMC4zLDAsLTAuNDgsLTAuMDZjLTAuMDksLTAuMDYsLTAuMjEsLTAuMTIsLTAuMjEsLTAuMTVjLTAuMDYsLTAuMDMsMC4wOSwtMC41NywxLjIzLC00LjkyYzAuNjksLTIuNjcsMS4yNiwtNC44NiwxLjI5LC00Ljg5YzAsLTAuMDMsLTAuMTIsLTAuMDMsLTAuNDgsMC4xMmMtMS4xNywwLjM5LC0yLjIyLDAuNTcsLTMsMC41NGMtMC40MiwtMC4wMywtMC43NSwtMC4xMiwtMS4xMSwtMC4zYy0xLjMyLC0wLjYzLC0xLjc3LC0yLjE2LC0xLjAyLC0zLjNjMC43MiwtMS4wNSwyLjIyLC0xLjIzLDMuMDYsLTAuNDJjMC4zLDAuMzMsMC40MiwwLjYsMC42LDEuMzhjMC4wOSwwLjQ1LDAuMjEsMC43OCwwLjMzLDAuOWMwLjEyLDAuMDksMC4zLDAuMTgsMC40OCwwLjIxYzAuMTIsMCwwLjE4LDAsMC4zLC0wLjA5YzAuNDIsLTAuMjEsMS4yOSwtMS4yOSwxLjU2LC0xLjg5YzAuMDMsLTAuMTIsMS4yMywtNC41OSwxLjIzLC00LjY1YzAsLTAuMDMsLTAuMTgsMC4wMywtMC4zOSwwLjEyYy0wLjYzLDAuMTgsLTEuMiwwLjM2LC0xLjc0LDAuNDVjLTAuMzksMC4wNiwtMC41NCwwLjA2LC0xLjAyLDAuMDZjLTAuNjYsMCwtMC44NCwtMC4wMywtMS4zMiwtMC4yN2MtMS4zMiwtMC42MywtMS43NywtMi4xNiwtMS4wMiwtMy4zYzAuNzIsLTEuMDUsMi4yMiwtMS4yMywzLjA2LC0wLjQyYzAuMywwLjMzLDAuNDIsMC42LDAuNiwxLjM4YzAuMDksMC40NSwwLjIxLDAuNzgsMC4zMywwLjljMC4xOCwwLjE4LDAuNTEsMC4yNywwLjcyLDAuMTVjMC4zLC0wLjEyLDAuNjksLTAuNTcsMS4wOCwtMS4xN2MwLjQyLC0wLjYsMC4zOSwtMC41MSwxLjA1LC0zLjAzYzAuMzMsLTEuMjYsMC42LC0yLjMxLDAuNiwtMi4zNGMwLDAsLTAuMjEsMC4wMywtMC40NSwwLjEyYy0wLjU3LDAuMTgsLTEuMTQsMC4zMywtMS42MiwwLjQyYy0wLjMzLDAuMDYsLTAuNTEsMC4wNiwtMC45NiwwLjA2Yy0wLjY2LDAsLTAuODQsLTAuMDMsLTEuMzIsLTAuMjdjLTEuMzIsLTAuNjMsLTEuNzcsLTIuMTYsLTEuMDIsLTMuM2MwLjMzLC0wLjQ1LDAuODQsLTAuODEsMS4zOCwtMC45elwiXHJcbiAgICB9LFxyXG4gICAgXCJyZXN0cy42NHRoXCI6IHtcclxuICAgICAgICBcIndcIjogMTIuNDUzLFxyXG4gICAgICAgIFwiaFwiOiAzNi4zODMsXHJcbiAgICAgICAgXCJkXCI6IFwiTTUuMTMsLTEzLjYyYzAuNjYsLTAuMDksMS4yMywwLjA5LDEuNjgsMC41MWMwLjI3LDAuMywwLjM5LDAuNTQsMC41NywxLjI2YzAuMTUsMC42MywwLjIxLDAuODEsMC4zMywwLjk2YzAuMTgsMC4yMSwwLjU0LDAuMywwLjc1LDAuMThjMC4yNCwtMC4xMiwwLjYzLC0wLjY2LDEuMDgsLTEuNTZjMC4zMywtMC42NiwwLjM5LC0wLjcyLDAuNiwtMC43MmMwLjEyLDAsMC4yNywwLjA5LDAuMzMsMC4xOGMwLjAzLDAuMDYsLTAuNjksMy42NiwtMy41NCwxNy42NGMtMS45NSw5LjY2LC0zLjU3LDE3LjYxLC0zLjU3LDE3LjY0Yy0wLjAzLDAuMDYsLTAuMTIsMC4xMiwtMC4yNCwwLjE4Yy0wLjIxLDAuMDksLTAuMjQsMC4wOSwtMC40OCwwLjA5Yy0wLjI0LDAsLTAuMywwLC0wLjQ4LC0wLjA2Yy0wLjA5LC0wLjA2LC0wLjIxLC0wLjEyLC0wLjIxLC0wLjE1Yy0wLjA2LC0wLjAzLDAuMDYsLTAuNTcsMS4wNSwtNC45NWMwLjYsLTIuNywxLjA4LC00Ljg5LDEuMDgsLTQuOTJjMCwwLC0wLjI0LDAuMDYsLTAuNTEsMC4xNWMtMC42NiwwLjI0LC0xLjIsMC4zNiwtMS43NywwLjQ4Yy0wLjQyLDAuMDYsLTAuNTcsMC4wNiwtMS4wNSwwLjA2Yy0wLjY5LDAsLTAuODcsLTAuMDMsLTEuMzUsLTAuMjdjLTEuMzIsLTAuNjMsLTEuNzcsLTIuMTYsLTEuMDIsLTMuM2MwLjcyLC0xLjA1LDIuMjIsLTEuMjMsMy4wNiwtMC40MmMwLjMsMC4zMywwLjQyLDAuNiwwLjYsMS4zOGMwLjA5LDAuNDUsMC4yMSwwLjc4LDAuMzMsMC45YzAuMDksMC4wOSwwLjI3LDAuMTgsMC40NSwwLjIxYzAuMjEsMC4wMywwLjM5LC0wLjA5LDAuNzIsLTAuNDJjMC40NSwtMC40NSwxLjAyLC0xLjI2LDEuMTcsLTEuNjVjMC4wMywtMC4wOSwwLjI3LC0xLjE0LDAuNTQsLTIuMzRjMC4yNywtMS4yLDAuNDgsLTIuMTksMC41MSwtMi4yMmMwLC0wLjAzLC0wLjA5LC0wLjAzLC0wLjQ4LDAuMTJjLTEuMTcsMC4zOSwtMi4yMiwwLjU3LC0zLDAuNTRjLTAuNDIsLTAuMDMsLTAuNzUsLTAuMTIsLTEuMTEsLTAuM2MtMS4zMiwtMC42MywtMS43NywtMi4xNiwtMS4wMiwtMy4zYzAuMzYsLTAuNTQsMC45NiwtMC44NywxLjY1LC0wLjkzYzAuNTQsLTAuMDMsMS4wMiwwLjE1LDEuNDEsMC41NGMwLjI3LDAuMywwLjM5LDAuNTQsMC41NywxLjI2YzAuMDksMC4zMywwLjE4LDAuNjYsMC4yMSwwLjcyYzAuMTUsMC4zOSwwLjU3LDAuNTcsMC45LDAuNDJjMC4zNiwtMC4xOCwxLjIsLTEuMjYsMS40NywtMS44OWMwLjAzLC0wLjA5LDAuMywtMS4yLDAuNTcsLTIuNDNsMC41MSwtMi4yOGwtMC41NCwwLjE4Yy0xLjExLDAuMzYsLTEuOCwwLjQ4LC0yLjYxLDAuNDhjLTAuNjYsMCwtMC44NCwtMC4wMywtMS4zMiwtMC4yN2MtMS4zMiwtMC42MywtMS43NywtMi4xNiwtMS4wMiwtMy4zYzAuMzYsLTAuNTQsMC45NiwtMC44NywxLjY1LC0wLjkzYzAuNTQsLTAuMDMsMS4wMiwwLjE1LDEuNDEsMC41NGMwLjI3LDAuMywwLjM5LDAuNTQsMC41NywxLjI2YzAuMTUsMC42MywwLjIxLDAuODEsMC4zMywwLjk2YzAuMjEsMC4yMSwwLjU0LDAuMywwLjc1LDAuMThjMC4zNiwtMC4xOCwwLjkzLC0wLjkzLDEuMjksLTEuNjhjMC4xMiwtMC4yNCwwLjE4LC0wLjQ4LDAuNjMsLTIuNTVsMC41MSwtMi4zMWMwLC0wLjAzLC0wLjE4LDAuMDMsLTAuMzksMC4xMmMtMS4xNCwwLjM2LC0yLjEsMC41NCwtMi44MiwwLjUxYy0wLjQyLC0wLjAzLC0wLjc1LC0wLjEyLC0xLjExLC0wLjNjLTEuMzIsLTAuNjMsLTEuNzcsLTIuMTYsLTEuMDIsLTMuM2MwLjMzLC0wLjQ1LDAuODQsLTAuODEsMS4zOCwtMC45elwiXHJcbiAgICB9LFxyXG4gICAgXCJyZXN0cy4xMjh0aFwiOiB7XHJcbiAgICAgICAgXCJ3XCI6IDEyLjk5MixcclxuICAgICAgICBcImhcIjogNDMuODgzLFxyXG4gICAgICAgIFwiZFwiOiBcIk02LjAzLC0yMS4xMmMwLjY2LC0wLjA5LDEuMjMsMC4wOSwxLjY4LDAuNTFjMC4yNywwLjMsMC4zOSwwLjU0LDAuNTcsMS4yNmMwLjA5LDAuMzMsMC4xOCwwLjY2LDAuMjEsMC43MmMwLjEyLDAuMjcsMC4zMywwLjQ1LDAuNiwwLjQ4YzAuMjEsMCwwLjMzLC0wLjA2LDAuNTQsLTAuMzZjMC4xNSwtMC4yMSwwLjU0LC0wLjkzLDAuNzgsLTEuNDdjMC4xNSwtMC4zMywwLjE4LC0wLjM5LDAuMywtMC40OGMwLjE4LC0wLjA5LDAuNDUsMCwwLjUxLDAuMTVjMC4wMywwLjA5LC03LjExLDQyLjc1LC03LjE3LDQyLjg0Yy0wLjAzLDAuMDMsLTAuMTUsMC4wOSwtMC4yNCwwLjE1Yy0wLjE4LDAuMDYsLTAuMjQsMC4wNiwtMC40NSwwLjA2Yy0wLjI0LDAsLTAuMywwLC0wLjQ4LC0wLjA2Yy0wLjA5LC0wLjA2LC0wLjIxLC0wLjEyLC0wLjIxLC0wLjE1Yy0wLjA2LC0wLjAzLDAuMDMsLTAuNTcsMC44NCwtNC45OGMwLjUxLC0yLjcsMC45MywtNC45MiwwLjksLTQuOTJjMCwwLC0wLjE1LDAuMDYsLTAuMzYsMC4xMmMtMC43OCwwLjI3LC0xLjYyLDAuNDgsLTIuMzEsMC41N2MtMC4xNSwwLjAzLC0wLjU0LDAuMDMsLTAuODEsMC4wM2MtMC42NiwwLC0wLjg0LC0wLjAzLC0xLjMyLC0wLjI3Yy0xLjMyLC0wLjYzLC0xLjc3LC0yLjE2LC0xLjAyLC0zLjNjMC4zNiwtMC41NCwwLjk2LC0wLjg3LDEuNjUsLTAuOTNjMC41NCwtMC4wMywxLjAyLDAuMTUsMS40MSwwLjU0YzAuMjcsMC4zLDAuMzksMC41NCwwLjU3LDEuMjZjMC4wOSwwLjMzLDAuMTgsMC42NiwwLjIxLDAuNzJjMC4xMiwwLjI3LDAuMzMsMC40NSwwLjYzLDAuNDhjMC4xMiwwLDAuMTgsMCwwLjMsLTAuMDljMC40MiwtMC4yMSwxLjE0LC0xLjExLDEuNSwtMS44M2MwLjEyLC0wLjI3LDAuMTIsLTAuMjcsMC41NCwtMi41MmMwLjI0LC0xLjIzLDAuNDIsLTIuMjUsMC4zOSwtMi4yNWMwLDAsLTAuMjQsMC4wNiwtMC41MSwwLjE4Yy0xLjI2LDAuMzksLTIuMjUsMC41NywtMy4wNiwwLjU0Yy0wLjQyLC0wLjAzLC0wLjc1LC0wLjEyLC0xLjExLC0wLjNjLTEuMzIsLTAuNjMsLTEuNzcsLTIuMTYsLTEuMDIsLTMuM2MwLjM2LC0wLjU0LDAuOTYsLTAuODcsMS42NSwtMC45M2MwLjU0LC0wLjAzLDEuMDIsMC4xNSwxLjQxLDAuNTRjMC4yNywwLjMsMC4zOSwwLjU0LDAuNTcsMS4yNmMwLjE1LDAuNjMsMC4yMSwwLjgxLDAuMzMsMC45NmMwLjE4LDAuMjEsMC41MSwwLjMsMC43NSwwLjE4YzAuMzYsLTAuMTUsMS4wNSwtMC45OSwxLjQxLC0xLjc3bDAuMTUsLTAuM2wwLjQyLC0yLjI1YzAuMjEsLTEuMjYsMC40MiwtMi4yOCwwLjM5LC0yLjI4bC0wLjUxLDAuMTVjLTEuMTEsMC4zOSwtMS44OSwwLjUxLC0yLjcsMC41MWMtMC42NiwwLC0wLjg0LC0wLjAzLC0xLjMyLC0wLjI3Yy0xLjMyLC0wLjYzLC0xLjc3LC0yLjE2LC0xLjAyLC0zLjNjMC4zNiwtMC41NCwwLjk2LC0wLjg3LDEuNjUsLTAuOTNjMC41NCwtMC4wMywxLjAyLDAuMTUsMS40MSwwLjU0YzAuMjcsMC4zLDAuMzksMC41NCwwLjU3LDEuMjZjMC4xNSwwLjYzLDAuMjEsMC44MSwwLjMzLDAuOTZjMC4xOCwwLjE4LDAuNDgsMC4yNywwLjcyLDAuMjFjMC4zMywtMC4xMiwxLjE0LC0xLjI2LDEuNDEsLTEuOTVjMCwtMC4wOSwwLjIxLC0xLjExLDAuNDUsLTIuMzRjMC4yMSwtMS4yLDAuMzksLTIuMjIsMC4zOSwtMi4yOGMwLjAzLC0wLjAzLDAsLTAuMDMsLTAuNDUsMC4xMmMtMC41NywwLjE4LC0xLjIsMC4zMywtMS43MSwwLjQyYy0wLjMsMC4wNiwtMC41MSwwLjA2LC0wLjkzLDAuMDZjLTAuNjYsMCwtMC44NCwtMC4wMywtMS4zMiwtMC4yN2MtMS4zMiwtMC42MywtMS43NywtMi4xNiwtMS4wMiwtMy4zYzAuMzYsLTAuNTQsMC45NiwtMC44NywxLjY1LC0wLjkzYzAuNTQsLTAuMDMsMS4wMiwwLjE1LDEuNDEsMC41NGMwLjI3LDAuMywwLjM5LDAuNTQsMC41NywxLjI2YzAuMDksMC4zMywwLjE4LDAuNjYsMC4yMSwwLjcyYzAuMTIsMC4yNywwLjMzLDAuNDUsMC42LDAuNDhjMC4xOCwwLDAuMzYsLTAuMDksMC41NywtMC4zM2MwLjMzLC0wLjM2LDAuNzgsLTEuMTQsMC45MywtMS41NmMwLjAzLC0wLjEyLDAuMjQsLTEuMiwwLjQ1LC0yLjRjMC4yNCwtMS4yLDAuNDIsLTIuMjIsMC40MiwtMi4yOGMwLjAzLC0wLjAzLDAsLTAuMDMsLTAuMzksMC4wOWMtMS4wNSwwLjM2LC0xLjgsMC40OCwtMi41OCwwLjQ4Yy0wLjYzLDAsLTAuODQsLTAuMDMsLTEuMjksLTAuMjdjLTEuMzIsLTAuNjMsLTEuNzcsLTIuMTYsLTEuMDIsLTMuM2MwLjMzLC0wLjQ1LDAuODQsLTAuODEsMS4zOCwtMC45elwiXHJcbiAgICB9LFxyXG4gICAgXCJhY2NpZGVudGFscy5zaGFycFwiOiB7XHJcbiAgICAgICAgXCJ3XCI6IDguMjUsXHJcbiAgICAgICAgXCJoXCI6IDIyLjQ2MixcclxuICAgICAgICBcImRcIjogXCJNNS43MywtMTEuMTljMC4yMSwtMC4xMiwwLjU0LC0wLjAzLDAuNjYsMC4yNGMwLjA2LDAuMTIsMC4wNiwwLjIxLDAuMDYsMi4zMWMwLDEuMjMsMCwyLjIyLDAuMDMsMi4yMmMwLDAsMC4yNywtMC4xMiwwLjYsLTAuMjRjMC42OSwtMC4yNywwLjc4LC0wLjMsMC45NiwtMC4xNWMwLjIxLDAuMTUsMC4yMSwwLjE4LDAuMjEsMS4zOGMwLDEuMDIsMCwxLjExLC0wLjA2LDEuMmMtMC4wMywwLjA2LC0wLjA5LDAuMTIsLTAuMTIsMC4xNWMtMC4wNiwwLjAzLC0wLjQyLDAuMjEsLTAuODQsMC4zNmwtMC43NSwwLjMzbC0wLjAzLDIuNDNjMCwxLjMyLDAsMi40MywwLjAzLDIuNDNjMCwwLDAuMjcsLTAuMTIsMC42LC0wLjI0YzAuNjksLTAuMjcsMC43OCwtMC4zLDAuOTYsLTAuMTVjMC4yMSwwLjE1LDAuMjEsMC4xOCwwLjIxLDEuMzhjMCwxLjAyLDAsMS4xMSwtMC4wNiwxLjJjLTAuMDMsMC4wNiwtMC4wOSwwLjEyLC0wLjEyLDAuMTVjLTAuMDYsMC4wMywtMC40MiwwLjIxLC0wLjg0LDAuMzZsLTAuNzUsMC4zM2wtMC4wMywyLjUyYzAsMi4yOCwtMC4wMywyLjU1LC0wLjA2LDIuNjRjLTAuMjEsMC4zNiwtMC43MiwwLjM2LC0wLjkzLDBjLTAuMDMsLTAuMDksLTAuMDYsLTAuMzMsLTAuMDYsLTIuNDNsMCwtMi4zMWwtMS4yOSwwLjUxbC0xLjI2LDAuNTFsMCwyLjQzYzAsMi41OCwwLDIuNTIsLTAuMTUsMi42N2MtMC4wNiwwLjA5LC0wLjI3LDAuMTgsLTAuMzYsMC4xOGMtMC4xMiwwLC0wLjMzLC0wLjA5LC0wLjM5LC0wLjE4Yy0wLjE1LC0wLjE1LC0wLjE1LC0wLjA5LC0wLjE1LC0yLjQzYzAsLTEuMjMsMCwtMi4yMiwtMC4wMywtMi4yMmMwLDAsLTAuMjcsMC4xMiwtMC42LDAuMjRjLTAuNjksMC4yNywtMC43OCwwLjMsLTAuOTYsMC4xNWMtMC4yMSwtMC4xNSwtMC4yMSwtMC4xOCwtMC4yMSwtMS4zOGMwLC0xLjAyLDAsLTEuMTEsMC4wNiwtMS4yYzAuMDMsLTAuMDYsMC4wOSwtMC4xMiwwLjEyLC0wLjE1YzAuMDYsLTAuMDMsMC40MiwtMC4yMSwwLjg0LC0wLjM2bDAuNzgsLTAuMzNsMCwtMi40M2MwLC0xLjMyLDAsLTIuNDMsLTAuMDMsLTIuNDNjMCwwLC0wLjI3LDAuMTIsLTAuNiwwLjI0Yy0wLjY5LDAuMjcsLTAuNzgsMC4zLC0wLjk2LDAuMTVjLTAuMjEsLTAuMTUsLTAuMjEsLTAuMTgsLTAuMjEsLTEuMzhjMCwtMS4wMiwwLC0xLjExLDAuMDYsLTEuMmMwLjAzLC0wLjA2LDAuMDksLTAuMTIsMC4xMiwtMC4xNWMwLjA2LC0wLjAzLDAuNDIsLTAuMjEsMC44NCwtMC4zNmwwLjc4LC0wLjMzbDAsLTIuNTJjMCwtMi4yOCwwLjAzLC0yLjU1LDAuMDYsLTIuNjRjMC4yMSwtMC4zNiwwLjcyLC0wLjM2LDAuOTMsMGMwLjAzLDAuMDksMC4wNiwwLjMzLDAuMDYsMi40M2wwLjAzLDIuMzFsMS4yNiwtMC41MWwxLjI2LC0wLjUxbDAsLTIuNDNjMCwtMi4yOCwwLC0yLjQzLDAuMDYsLTIuNTVjMC4wNiwtMC4xMiwwLjEyLC0wLjE4LDAuMjcsLTAuMjR6bS0wLjMzLDEwLjY1bDAsLTIuNDNsLTEuMjksMC41MWwtMS4yNiwwLjUxbDAsMi40NmwwLDIuNDNsMC4wOSwtMC4wM2MwLjA2LC0wLjAzLDAuNjMsLTAuMjcsMS4yOSwtMC41MWwxLjE3LC0wLjQ4bDAsLTIuNDZ6XCJcclxuICAgIH0sXHJcbiAgICBcImFjY2lkZW50YWxzLmhhbGZzaGFycFwiOiB7XHJcbiAgICAgICAgXCJ3XCI6IDUuMjUsXHJcbiAgICAgICAgXCJoXCI6IDIwLjE3NCxcclxuICAgICAgICBcImRcIjogXCJNMi40MywtMTAuMDVjMC4yMSwtMC4xMiwwLjU0LC0wLjAzLDAuNjYsMC4yNGMwLjA2LDAuMTIsMC4wNiwwLjIxLDAuMDYsMi4wMWMwLDEuMDUsMCwxLjg5LDAuMDMsMS44OWwwLjcyLC0wLjQ4YzAuNjksLTAuNDgsMC42OSwtMC41MSwwLjg3LC0wLjUxYzAuMTUsMCwwLjE4LDAuMDMsMC4yNywwLjA5YzAuMjEsMC4xNSwwLjIxLDAuMTgsMC4yMSwxLjQxYzAsMS4xMSwtMC4wMywxLjE0LC0wLjA5LDEuMjNjLTAuMDMsMC4wMywtMC40OCwwLjM5LC0xLjAyLDAuNzVsLTAuOTksMC42NmwwLDIuMzdjMCwxLjMyLDAsMi4zNywwLjAzLDIuMzdsMC43MiwtMC40OGMwLjY5LC0wLjQ4LDAuNjksLTAuNTEsMC44NywtMC41MWMwLjE1LDAsMC4xOCwwLjAzLDAuMjcsMC4wOWMwLjIxLDAuMTUsMC4yMSwwLjE4LDAuMjEsMS40MWMwLDEuMTEsLTAuMDMsMS4xNCwtMC4wOSwxLjIzYy0wLjAzLDAuMDMsLTAuNDgsMC4zOSwtMS4wMiwwLjc1bC0wLjk5LDAuNjZsMCwyLjI1YzAsMS45NSwwLDIuMjgsLTAuMDYsMi4zN2MtMC4wNiwwLjEyLC0wLjEyLDAuMjEsLTAuMjQsMC4yN2MtMC4yNywwLjEyLC0wLjU0LDAuMDMsLTAuNjksLTAuMjRjLTAuMDYsLTAuMTIsLTAuMDYsLTAuMjEsLTAuMDYsLTIuMDFjMCwtMS4wNSwwLC0xLjg5LC0wLjAzLC0xLjg5bC0wLjcyLDAuNDhjLTAuNjksMC40OCwtMC42OSwwLjQ4LC0wLjg3LDAuNDhjLTAuMTUsMCwtMC4xOCwwLC0wLjI3LC0wLjA2Yy0wLjIxLC0wLjE1LC0wLjIxLC0wLjE4LC0wLjIxLC0xLjQxYzAsLTEuMTEsMC4wMywtMS4xNCwwLjA5LC0xLjIzYzAuMDMsLTAuMDMsMC40OCwtMC4zOSwxLjAyLC0wLjc1bDAuOTksLTAuNjZsMCwtMi4zN2MwLC0xLjMyLDAsLTIuMzcsLTAuMDMsLTIuMzdsLTAuNzIsMC40OGMtMC42OSwwLjQ4LC0wLjY5LDAuNDgsLTAuODcsMC40OGMtMC4xNSwwLC0wLjE4LDAsLTAuMjcsLTAuMDZjLTAuMjEsLTAuMTUsLTAuMjEsLTAuMTgsLTAuMjEsLTEuNDFjMCwtMS4xMSwwLjAzLC0xLjE0LDAuMDksLTEuMjNjMC4wMywtMC4wMywwLjQ4LC0wLjM5LDEuMDIsLTAuNzVsMC45OSwtMC42NmwwLC0yLjI1YzAsLTIuMTMsMCwtMi4yOCwwLjA2LC0yLjRjMC4wNiwtMC4xMiwwLjEyLC0wLjE4LDAuMjcsLTAuMjR6XCJcclxuICAgIH0sXHJcbiAgICBcImFjY2lkZW50YWxzLm5hdFwiOiB7XHJcbiAgICAgICAgXCJ3XCI6IDUuNDExLFxyXG4gICAgICAgIFwiaFwiOiAyMi44LFxyXG4gICAgICAgIFwiZFwiOiBcIk0wLjIwNCwtMTEuNGMwLjI0LC0wLjA2LDAuNzgsMCwwLjk5LDAuMTVjMC4wMywwLjAzLDAuMDMsMC40OCwwLDIuNjFjLTAuMDMsMS40NCwtMC4wMywyLjYxLC0wLjAzLDIuNjFjMCwwLjAzLDAuNzUsLTAuMDksMS42OCwtMC4yNGMwLjk2LC0wLjE4LDEuNzEsLTAuMjcsMS43NCwtMC4yN2MwLjE1LDAuMDMsMC4yNywwLjE1LDAuMzYsMC4zbDAuMDYsMC4xMmwwLjA5LDguNjdjMC4wOSw2Ljk2LDAuMTIsOC42NywwLjA5LDguNjdjLTAuMDMsMC4wMywtMC4xMiwwLjA2LC0wLjIxLDAuMDljLTAuMjQsMC4wOSwtMC43MiwwLjA5LC0wLjk2LDBjLTAuMDksLTAuMDMsLTAuMTgsLTAuMDYsLTAuMjEsLTAuMDljLTAuMDMsLTAuMDMsLTAuMDMsLTAuNDgsMCwtMi42MWMwLjAzLC0xLjQ0LDAuMDMsLTIuNjEsMC4wMywtMi42MWMwLC0wLjAzLC0wLjc1LDAuMDksLTEuNjgsMC4yNGMtMC45NiwwLjE4LC0xLjcxLDAuMjcsLTEuNzQsMC4yN2MtMC4xNSwtMC4wMywtMC4yNywtMC4xNSwtMC4zNiwtMC4zbC0wLjA2LC0wLjE1bC0wLjA5LC03LjUzYy0wLjA2LC00LjE0LC0wLjA5LC04LjA0LC0wLjEyLC04LjY3bDAsLTEuMTFsMC4xNSwtMC4wNmMwLjA5LC0wLjAzLDAuMjEsLTAuMDYsMC4yNywtMC4wOXptMy43NSw4LjRjMCwtMC4zMywwLC0wLjQyLC0wLjAzLC0wLjQyYy0wLjEyLDAsLTIuNzksMC40NSwtMi43OSwwLjQ4Yy0wLjAzLDAsLTAuMDksNi4zLC0wLjA5LDYuMzNjMC4wMywwLDIuNzksLTAuNDUsMi44MiwtMC40OGMwLDAsMC4wOSwtNC41MywwLjA5LC01LjkxelwiXHJcbiAgICB9LFxyXG4gICAgXCJhY2NpZGVudGFscy5mbGF0XCI6IHtcclxuICAgICAgICBcIndcIjogNi43NSxcclxuICAgICAgICBcImhcIjogMTguODAxLFxyXG4gICAgICAgIFwiZFwiOiBcIk0tMC4zNiwtMTQuMDdjMC4zMywtMC4wNiwwLjg3LDAsMS4wOCwwLjE1YzAuMDYsMC4wMywwLjA2LDAuMzYsLTAuMDMsNS4yNWMtMC4wNiwyLjg1LC0wLjA5LDUuMTksLTAuMDksNS4xOWMwLDAuMDMsMC4xMiwtMC4wMywwLjI0LC0wLjEyYzAuNjMsLTAuNDIsMS40MSwtMC42NiwyLjE5LC0wLjcyYzAuODEsLTAuMDMsMS40NywwLjIxLDIuMDQsMC43OGMwLjU3LDAuNTQsMC44NywxLjI2LDAuOTMsMi4wNGMwLjAzLDAuNTcsLTAuMDksMS4wOCwtMC4zNiwxLjYyYy0wLjQyLDAuODEsLTEuMDIsMS4zOCwtMi44MiwyLjYxYy0xLjE0LDAuNzgsLTEuNDQsMS4wMiwtMS44LDEuNDRjLTAuMTgsMC4xOCwtMC4zOSwwLjM5LC0wLjQ1LDAuNDJjLTAuMjcsMC4xOCwtMC41NywwLjE1LC0wLjgxLC0wLjA2Yy0wLjA2LC0wLjA5LC0wLjEyLC0wLjE4LC0wLjE1LC0wLjI3Yy0wLjAzLC0wLjA2LC0wLjA5LC0zLjI3LC0wLjE4LC04LjM0Yy0wLjA5LC00LjUzLC0wLjE1LC04LjU4LC0wLjE4LC05LjAzbDAsLTAuNzhsMC4xMiwtMC4wNmMwLjA2LC0wLjAzLDAuMTgsLTAuMDksMC4yNywtMC4xMnptMy4xOCwxMS4wMWMtMC4yMSwtMC4xMiwtMC41NCwtMC4xNSwtMC44MSwtMC4wNmMtMC41NCwwLjE1LC0wLjk5LDAuNjMsLTEuMTcsMS4yNmMtMC4wNiwwLjMsLTAuMTIsMi44OCwtMC4wNiwzLjg3YzAuMDMsMC40MiwwLjAzLDAuODEsMC4wNiwwLjlsMC4wMywwLjEybDAuNDUsLTAuMzljMC42MywtMC41NCwxLjI2LC0xLjE3LDEuNTYsLTEuNTljMC4zLC0wLjQyLDAuNiwtMC45OSwwLjcyLC0xLjQxYzAuMTgsLTAuNjksMC4wOSwtMS40NywtMC4xOCwtMi4wN2MtMC4xNSwtMC4zLC0wLjMzLC0wLjUxLC0wLjYsLTAuNjN6XCJcclxuICAgIH0sXHJcbiAgICBcImFjY2lkZW50YWxzLmhhbGZmbGF0XCI6IHtcclxuICAgICAgICBcIndcIjogNi43MjgsXHJcbiAgICAgICAgXCJoXCI6IDE4LjgwMSxcclxuICAgICAgICBcImRcIjogXCJNNC44MywtMTQuMDdjMC4zMywtMC4wNiwwLjg3LDAsMS4wOCwwLjE1YzAuMDYsMC4wMywwLjA2LDAuNiwtMC4xMiw5LjA2Yy0wLjA5LDUuNTUsLTAuMTUsOS4wNiwtMC4xOCw5LjEyYy0wLjAzLDAuMDksLTAuMDksMC4xOCwtMC4xNSwwLjI3Yy0wLjI0LDAuMjEsLTAuNTQsMC4yNCwtMC44MSwwLjA2Yy0wLjA2LC0wLjAzLC0wLjI3LC0wLjI0LC0wLjQ1LC0wLjQyYy0wLjM2LC0wLjQyLC0wLjY2LC0wLjY2LC0xLjgsLTEuNDRjLTEuMjMsLTAuODQsLTEuODMsLTEuMzIsLTIuMjUsLTEuNzdjLTAuNjYsLTAuNzgsLTAuOTYsLTEuNTYsLTAuOTMsLTIuNDZjMC4wOSwtMS40MSwxLjExLC0yLjU4LDIuNCwtMi43OWMwLjMsLTAuMDYsMC44NCwtMC4wMywxLjIzLDAuMDZjMC41NCwwLjEyLDEuMDgsMC4zMywxLjUzLDAuNjNjMC4xMiwwLjA5LDAuMjQsMC4xNSwwLjI0LDAuMTJjMCwwLC0wLjEyLC04LjM3LC0wLjE4LC05Ljc1bDAsLTAuNjZsMC4xMiwtMC4wNmMwLjA2LC0wLjAzLDAuMTgsLTAuMDksMC4yNywtMC4xMnptLTEuNjUsMTAuOTVjLTAuNiwtMC4xOCwtMS4wOCwwLjA5LC0xLjM4LDAuNjljLTAuMjcsMC42LC0wLjM2LDEuMzgsLTAuMTgsMi4wN2MwLjEyLDAuNDIsMC40MiwwLjk5LDAuNzIsMS40MWMwLjMsMC40MiwwLjkzLDEuMDUsMS41NiwxLjU5bDAuNDgsMC4zOWwwLC0wLjEyYzAuMDMsLTAuMDksMC4wMywtMC40OCwwLjA2LC0wLjljMC4wMywtMC41NywwLjAzLC0xLjA4LDAsLTIuMjJjLTAuMDMsLTEuNjIsLTAuMDMsLTEuNjIsLTAuMjQsLTIuMDdjLTAuMjEsLTAuNDIsLTAuNiwtMC43NSwtMS4wMiwtMC44NHpcIlxyXG4gICAgfSxcclxuICAgIFwiYWNjaWRlbnRhbHMuZGJsZmxhdFwiOiB7XHJcbiAgICAgICAgXCJ3XCI6IDExLjYxMyxcclxuICAgICAgICBcImhcIjogMTguODA0LFxyXG4gICAgICAgIFwiZFwiOiBcIk0tMC4zNiwtMTQuMDdjMC4zMywtMC4wNiwwLjg3LDAsMS4wOCwwLjE1YzAuMDYsMC4wMywwLjA2LDAuMzMsLTAuMDMsNC44OWMtMC4wNiwyLjY3LC0wLjA5LDUuMDEsLTAuMDksNS4yMmwwLDAuMzZsMC4xNSwtMC4xNWMwLjM2LC0wLjMsMC43NSwtMC41MSwxLjIsLTAuNjNjMC4zMywtMC4wOSwwLjk2LC0wLjA5LDEuMjYsLTAuMDNjMC4yNywwLjA5LDAuNjMsMC4yNywwLjg3LDAuNDVsMC4yMSwwLjE1bDAsLTAuMjdjMCwtMC4xNSwtMC4wMywtMi40MywtMC4wOSwtNS4xYy0wLjA5LC00LjU2LC0wLjA5LC00Ljg2LC0wLjAzLC00Ljg5YzAuMTUsLTAuMTIsMC4zOSwtMC4xNSwwLjcyLC0wLjE1YzAuMywwLDAuNTQsMC4wMywwLjY5LDAuMTVjMC4wNiwwLjAzLDAuMDYsMC4zMywtMC4wMyw0Ljk1Yy0wLjA2LDIuNywtMC4wOSw1LjA0LC0wLjA5LDUuMjJsMC4wMywwLjNsMC4yMSwtMC4xNWMwLjY5LC0wLjQ4LDEuNDQsLTAuNjksMi4yOCwtMC42OWMwLjUxLDAsMC43OCwwLjAzLDEuMiwwLjIxYzEuMzIsMC42MywyLjAxLDIuMjgsMS41MywzLjY5Yy0wLjIxLDAuNTcsLTAuNTEsMS4wMiwtMS4wNSwxLjU2Yy0wLjQyLDAuNDIsLTAuODEsMC43MiwtMS45MiwxLjVjLTEuMjYsMC44NywtMS41LDEuMDgsLTEuODYsMS41Yy0wLjM5LDAuNDUsLTAuNTQsMC41NCwtMC44MSwwLjUxYy0wLjE4LDAsLTAuMjEsMCwtMC4zMywtMC4wNmwtMC4yMSwtMC4yMWwtMC4wNiwtMC4xMmwtMC4wMywtMC45OWMtMC4wMywtMC41NCwtMC4wMywtMS4yOSwtMC4wNiwtMS42OGwwLC0wLjY5bC0wLjIxLDAuMjRjLTAuMzYsMC40MiwtMC43NSwwLjc1LC0xLjgsMS42MmMtMS4wMiwwLjg0LC0xLjIsMC45OSwtMS40NCwxLjM4Yy0wLjM2LDAuNTEsLTAuNTQsMC42LC0wLjksMC41MWMtMC4xNSwtMC4wMywtMC4zOSwtMC4yNywtMC40MiwtMC40MmMtMC4wMywtMC4wNiwtMC4wOSwtMy4yNywtMC4xOCwtOC4zNGMtMC4wOSwtNC41MywtMC4xNSwtOC41OCwtMC4xOCwtOS4wM2wwLC0wLjc4bDAuMTIsLTAuMDZjMC4wNiwtMC4wMywwLjE4LC0wLjA5LDAuMjcsLTAuMTJ6bTIuNTIsMTAuOThjLTAuMTgsLTAuMDksLTAuNDgsLTAuMTIsLTAuNjYsLTAuMDZjLTAuMzksMC4xNSwtMC42OSwwLjU0LC0wLjg0LDEuMTRjLTAuMDYsMC4yNCwtMC4wNiwwLjM5LC0wLjA5LDEuNzRjLTAuMDMsMS40NCwwLDIuNzMsMC4wNiwzLjE4bDAuMDMsMC4xNWwwLjI3LC0wLjI3YzAuOTMsLTAuOTYsMS41LC0xLjk1LDEuNzQsLTMuMDZjMC4wNiwtMC4yNywwLjA2LC0wLjM5LDAuMDYsLTAuOTZjMCwtMC41NCwwLC0wLjY5LC0wLjA2LC0wLjkzYy0wLjA5LC0wLjUxLC0wLjI3LC0wLjgxLC0wLjUxLC0wLjkzem01LjQzLDBjLTAuMTgsLTAuMDksLTAuNTEsLTAuMTIsLTAuNzIsLTAuMDZjLTAuNTQsMC4xMiwtMC45NiwwLjYzLC0xLjE3LDEuMjZjLTAuMDYsMC4zLC0wLjEyLDIuODgsLTAuMDYsMy45YzAuMDMsMC40MiwwLjAzLDAuODEsMC4wNiwwLjlsMC4wMywwLjEybDAuMzYsLTAuM2MwLjQyLC0wLjM2LDEuMDIsLTAuOTYsMS4yOSwtMS4yOWMwLjM2LC0wLjQ1LDAuNjYsLTAuOTksMC44MSwtMS40MWMwLjQyLC0xLjIzLDAuMTUsLTIuNzYsLTAuNiwtMy4xMnpcIlxyXG4gICAgfSxcclxuICAgIFwiYWNjaWRlbnRhbHMuZGJsc2hhcnBcIjoge1xyXG4gICAgICAgIFwid1wiOiA3Ljk2MSxcclxuICAgICAgICBcImhcIjogNy45NzcsXHJcbiAgICAgICAgXCJkXCI6IFwiTS0wLjE4NiwtMy45NmMwLjA2LC0wLjAzLDAuMTIsLTAuMDYsMC4xNSwtMC4wNmMwLjA5LDAsMi43NiwwLjI3LDIuNzksMC4zYzAuMTIsMC4wMywwLjE1LDAuMTIsMC4xNSwwLjUxYzAuMDYsMC45NiwwLjI0LDEuNTksMC41NywyLjFjMC4wNiwwLjA5LDAuMTUsMC4yMSwwLjE4LDAuMjRsMC4wOSwwLjA2bDAuMDksLTAuMDZjMC4wMywtMC4wMywwLjEyLC0wLjE1LDAuMTgsLTAuMjRjMC4zMywtMC41MSwwLjUxLC0xLjE0LDAuNTcsLTIuMWMwLC0wLjM5LDAuMDMsLTAuNDUsMC4xMiwtMC41MWMwLjAzLDAsMC42NiwtMC4wOSwxLjQ0LC0wLjE1YzEuNDcsLTAuMTUsMS41LC0wLjE1LDEuNTYsLTAuMDNjMC4wMywwLjA2LDAsMC40MiwtMC4wOSwxLjQ0Yy0wLjA5LDAuNzIsLTAuMTUsMS4zNSwtMC4xNSwxLjM4YzAsMC4wMywtMC4wMywwLjA5LC0wLjA2LDAuMTJjLTAuMDYsMC4wNiwtMC4xMiwwLjA5LC0wLjUxLDAuMDljLTEuMDgsMC4wNiwtMS44LDAuMywtMi4yOCwwLjc1bC0wLjEyLDAuMDlsMC4wOSwwLjA5YzAuMTIsMC4xNSwwLjM5LDAuMzMsMC42MywwLjQ1YzAuNDIsMC4xOCwwLjk2LDAuMjcsMS42OCwwLjMzYzAuMzksMCwwLjQ1LDAuMDMsMC41MSwwLjA5YzAuMDMsMC4wMywwLjA2LDAuMDksMC4wNiwwLjEyYzAsMC4wMywwLjA2LDAuNjYsMC4xNSwxLjM4YzAuMDksMS4wMiwwLjEyLDEuMzgsMC4wOSwxLjQ0Yy0wLjA2LDAuMTIsLTAuMDksMC4xMiwtMS41NiwtMC4wM2MtMC43OCwtMC4wNiwtMS40MSwtMC4xNSwtMS40NCwtMC4xNWMtMC4wOSwtMC4wNiwtMC4xMiwtMC4xMiwtMC4xMiwtMC41NGMtMC4wNiwtMC45MywtMC4yNCwtMS41NiwtMC41NywtMi4wN2MtMC4wNiwtMC4wOSwtMC4xNSwtMC4yMSwtMC4xOCwtMC4yNGwtMC4wOSwtMC4wNmwtMC4wOSwwLjA2Yy0wLjAzLDAuMDMsLTAuMTIsMC4xNSwtMC4xOCwwLjI0Yy0wLjMzLDAuNTEsLTAuNTEsMS4xNCwtMC41NywyLjA3YzAsMC40MiwtMC4wMywwLjQ4LC0wLjEyLDAuNTRjLTAuMDMsMCwtMC42NiwwLjA5LC0xLjQ0LDAuMTVjLTEuNDcsMC4xNSwtMS41LDAuMTUsLTEuNTYsMC4wM2MtMC4wMywtMC4wNiwwLC0wLjQyLDAuMDksLTEuNDRjMC4wOSwtMC43MiwwLjE1LC0xLjM1LDAuMTUsLTEuMzhjMCwtMC4wMywwLjAzLC0wLjA5LDAuMDYsLTAuMTJjMC4wNiwtMC4wNiwwLjEyLC0wLjA5LDAuNTEsLTAuMDljMC43MiwtMC4wNiwxLjI2LC0wLjE1LDEuNjgsLTAuMzNjMC4yNCwtMC4xMiwwLjUxLC0wLjMsMC42MywtMC40NWwwLjA5LC0wLjA5bC0wLjEyLC0wLjA5Yy0wLjQ4LC0wLjQ1LC0xLjIsLTAuNjksLTIuMjgsLTAuNzVjLTAuMzksMCwtMC40NSwtMC4wMywtMC41MSwtMC4wOWMtMC4wMywtMC4wMywtMC4wNiwtMC4wOSwtMC4wNiwtMC4xMmMwLC0wLjAzLC0wLjA2LC0wLjYzLC0wLjEyLC0xLjM4Yy0wLjA5LC0wLjcyLC0wLjE1LC0xLjM1LC0wLjE1LC0xLjM4elwiXHJcbiAgICB9LFxyXG4gICAgXCJkb3RzLmRvdFwiOiB7XHJcbiAgICAgICAgXCJ3XCI6IDMuNDUsXHJcbiAgICAgICAgXCJoXCI6IDMuNDUsXHJcbiAgICAgICAgXCJkXCI6IFwiTTEuMzIsLTEuNjhjMC4wOSwtMC4wMywwLjI3LC0wLjA2LDAuMzksLTAuMDZjMC45NiwwLDEuNzQsMC43OCwxLjc0LDEuNzFjMCwwLjk2LC0wLjc4LDEuNzQsLTEuNzEsMS43NGMtMC45NiwwLC0xLjc0LC0wLjc4LC0xLjc0LC0xLjcxYzAsLTAuNzgsMC41NCwtMS41LDEuMzIsLTEuNjh6XCJcclxuICAgIH0sXHJcbiAgICBcIm5vdGVoZWFkcy5kYmxcIjoge1xyXG4gICAgICAgIFwid1wiOiAxNi44MyxcclxuICAgICAgICBcImhcIjogOC4xNDUsXHJcbiAgICAgICAgXCJkXCI6IFwiTS0wLjY5LC00LjAyYzAuMTgsLTAuMDksMC4zNiwtMC4wOSwwLjU0LDBjMC4xOCwwLjA5LDAuMjQsMC4xNSwwLjMzLDAuM2MwLjA2LDAuMTUsMC4wNiwwLjE4LDAuMDYsMS40MWwwLDEuMjNsMC4xMiwtMC4xOGMwLjcyLC0xLjI2LDIuNjQsLTIuMzEsNC44NiwtMi42NGMwLjgxLC0wLjE1LDEuMTEsLTAuMTUsMi4xMywtMC4xNWMwLjk5LDAsMS4yOSwwLDIuMSwwLjE1YzAuNzUsMC4xMiwxLjM4LDAuMjcsMi4wNCwwLjU0YzEuMzUsMC41MSwyLjM0LDEuMjYsMi44MiwyLjFsMC4xMiwwLjE4bDAsLTEuMjNjMCwtMS4yLDAsLTEuMjYsMC4wNiwtMS4zOGMwLjA5LC0wLjE4LDAuMTUsLTAuMjQsMC4zMywtMC4zM2MwLjE4LC0wLjA5LDAuMzYsLTAuMDksMC41NCwwYzAuMTgsMC4wOSwwLjI0LDAuMTUsMC4zMywwLjNsMC4wNiwwLjE1bDAsMy41NGwwLDMuNTRsLTAuMDYsMC4xNWMtMC4wOSwwLjE4LC0wLjE1LDAuMjQsLTAuMzMsMC4zM2MtMC4xOCwwLjA5LC0wLjM2LDAuMDksLTAuNTQsMGMtMC4xOCwtMC4wOSwtMC4yNCwtMC4xNSwtMC4zMywtMC4zM2MtMC4wNiwtMC4xMiwtMC4wNiwtMC4xOCwtMC4wNiwtMS4zOGwwLC0xLjIzbC0wLjEyLDAuMThjLTAuNDgsMC44NCwtMS40NywxLjU5LC0yLjgyLDIuMWMtMC44NCwwLjMzLC0xLjcxLDAuNTQsLTIuODUsMC42NmMtMC40NSwwLjA2LC0yLjE2LDAuMDYsLTIuNjEsMGMtMS4xNCwtMC4xMiwtMi4wMSwtMC4zMywtMi44NSwtMC42NmMtMS4zNSwtMC41MSwtMi4zNCwtMS4yNiwtMi44MiwtMi4xbC0wLjEyLC0wLjE4bDAsMS4yM2MwLDEuMjMsMCwxLjI2LC0wLjA2LDEuMzhjLTAuMDksMC4xOCwtMC4xNSwwLjI0LC0wLjMzLDAuMzNjLTAuMTgsMC4wOSwtMC4zNiwwLjA5LC0wLjU0LDBjLTAuMTgsLTAuMDksLTAuMjQsLTAuMTUsLTAuMzMsLTAuMzNsLTAuMDYsLTAuMTVsMCwtMy41NGMwLC0zLjQ4LDAsLTMuNTQsMC4wNiwtMy42NmMwLjA5LC0wLjE4LDAuMTUsLTAuMjQsMC4zMywtMC4zM3ptNy43MSwwLjYzYy0wLjM2LC0wLjA2LC0wLjksLTAuMDYsLTEuMTQsMGMtMC4zLDAuMDMsLTAuNjYsMC4yNCwtMC44NywwLjQyYy0wLjYsMC41NCwtMC45LDEuNjIsLTAuNzUsMi44MmMwLjEyLDAuOTMsMC41MSwxLjY4LDEuMTEsMi4zMWMwLjc1LDAuNzIsMS44MywxLjIsMi44NSwxLjI2YzEuMDUsMC4wNiwxLjgzLC0wLjU0LDIuMSwtMS42NWMwLjIxLC0wLjksMC4xMiwtMS45NSwtMC4yNCwtMi44MmMtMC4zNiwtMC44MSwtMS4wOCwtMS41MywtMS45NSwtMS45NWMtMC4zLC0wLjE1LC0wLjc4LC0wLjMsLTEuMTEsLTAuMzl6XCJcclxuICAgIH0sXHJcbiAgICBcIm5vdGVoZWFkcy53aG9sZVwiOiB7XHJcbiAgICAgICAgXCJ3XCI6IDE0Ljk4NSxcclxuICAgICAgICBcImhcIjogOC4wOTcsXHJcbiAgICAgICAgXCJkXCI6IFwiTTYuNTEsLTQuMDVjMC41MSwtMC4wMywyLjAxLDAsMi41MiwwLjAzYzEuNDEsMC4xOCwyLjY0LDAuNTEsMy43MiwxLjA4YzEuMiwwLjYzLDEuOTUsMS40MSwyLjE5LDIuMzFjMC4wOSwwLjMzLDAuMDksMC45LDAsMS4yM2MtMC4yNCwwLjksLTAuOTksMS42OCwtMi4xOSwyLjMxYy0xLjA4LDAuNTcsLTIuMjgsMC45LC0zLjc1LDEuMDhjLTAuNjYsMC4wNiwtMi4zMSwwLjA2LC0yLjk3LDBjLTEuNDcsLTAuMTgsLTIuNjcsLTAuNTEsLTMuNzUsLTEuMDhjLTEuMiwtMC42MywtMS45NSwtMS40MSwtMi4xOSwtMi4zMWMtMC4wOSwtMC4zMywtMC4wOSwtMC45LDAsLTEuMjNjMC4yNCwtMC45LDAuOTksLTEuNjgsMi4xOSwtMi4zMWMxLjIsLTAuNjMsMi42MSwtMC45OSw0LjIzLC0xLjExem0wLjU3LDAuNjZjLTAuODcsLTAuMTUsLTEuNTMsMCwtMi4wNCwwLjUxYy0wLjE1LDAuMTUsLTAuMjQsMC4yNywtMC4zMywwLjQ4Yy0wLjI0LDAuNTEsLTAuMzYsMS4wOCwtMC4zMywxLjc3YzAuMDMsMC42OSwwLjE4LDEuMjYsMC40MiwxLjc3YzAuNiwxLjE3LDEuNzQsMS45OCwzLjE4LDIuMjJjMS4xMSwwLjIxLDEuOTUsLTAuMTUsMi4zNCwtMC45OWMwLjI0LC0wLjUxLDAuMzYsLTEuMDgsMC4zMywtMS44Yy0wLjA2LC0xLjExLC0wLjQ1LC0yLjA0LC0xLjE3LC0yLjc2Yy0wLjYzLC0wLjYzLC0xLjQ3LC0xLjA1LC0yLjQsLTEuMnpcIlxyXG4gICAgfSxcclxuICAgIFwibm90ZWhlYWRzLmhhbGZcIjoge1xyXG4gICAgICAgIFwid1wiOiAxMC4zNyxcclxuICAgICAgICBcImhcIjogOC4xMzIsXHJcbiAgICAgICAgXCJkXCI6IFwiTTcuNDQsLTQuMDVjMC4wNiwtMC4wMywwLjI3LC0wLjAzLDAuNDgsLTAuMDNjMS4wNSwwLDEuNzEsMC4yNCwyLjEsMC44MWMwLjQyLDAuNiwwLjQ1LDEuMzUsMC4xOCwyLjRjLTAuNDIsMS41OSwtMS4xNCwyLjczLC0yLjE2LDMuMzljLTEuNDEsMC45MywtMy4xOCwxLjQ0LC01LjQsMS41M2MtMS4xNywwLjAzLC0xLjg5LC0wLjIxLC0yLjI4LC0wLjgxYy0wLjQyLC0wLjYsLTAuNDUsLTEuMzUsLTAuMTgsLTIuNGMwLjQyLC0xLjU5LDEuMTQsLTIuNzMsMi4xNiwtMy4zOWMwLjYzLC0wLjQyLDEuMjMsLTAuNzIsMS45OCwtMC45NmMwLjksLTAuMywxLjY1LC0wLjQyLDMuMTIsLTAuNTR6bTEuMjksMC44N2MtMC4yNywtMC4wOSwtMC42MywtMC4xMiwtMC45LC0wLjAzYy0wLjcyLDAuMjQsLTEuNTMsMC42OSwtMy4yNywxLjhjLTIuMzQsMS41LC0zLjMsMi4yNSwtMy41NywyLjc5Yy0wLjM2LDAuNzIsLTAuMDYsMS41LDAuNjYsMS43N2MwLjI0LDAuMTIsMC42OSwwLjA5LDAuOTksMGMwLjg0LC0wLjMsMS45MiwtMC45Myw0LjE0LC0yLjM3YzEuNjIsLTEuMDgsMi4zNywtMS43MSwyLjYxLC0yLjE5YzAuMzYsLTAuNzIsMC4wNiwtMS41LC0wLjY2LC0xLjc3elwiXHJcbiAgICB9LFxyXG4gICAgXCJub3RlaGVhZHMucXVhcnRlclwiOiB7XHJcbiAgICAgICAgXCJ3XCI6IDkuODEsXHJcbiAgICAgICAgXCJoXCI6IDguMDk0LFxyXG4gICAgICAgIFwiZFwiOiBcIk02LjA5LC00LjA1YzAuMzYsLTAuMDMsMS4yLDAsMS41MywwLjA2YzEuMTcsMC4yNCwxLjg5LDAuODQsMi4xNiwxLjgzYzAuMDYsMC4xOCwwLjA2LDAuMywwLjA2LDAuNjZjMCwwLjQ1LDAsMC42MywtMC4xNSwxLjA4Yy0wLjY2LDIuMDQsLTMuMDYsMy45MywtNS41Miw0LjM4Yy0wLjU0LDAuMDksLTEuNDQsMC4wOSwtMS44MywwLjAzYy0xLjIzLC0wLjI3LC0xLjk4LC0wLjg3LC0yLjI1LC0xLjg2Yy0wLjA2LC0wLjE4LC0wLjA2LC0wLjMsLTAuMDYsLTAuNjZjMCwtMC40NSwwLC0wLjYzLDAuMTUsLTEuMDhjMC4yNCwtMC43OCwwLjc1LC0xLjUzLDEuNDQsLTIuMjJjMS4yLC0xLjIsMi44NSwtMi4wMSw0LjQ3LC0yLjIyelwiXHJcbiAgICB9LFxyXG4gICAgXCJzY3JpcHRzLnVmZXJtYXRhXCI6IHtcclxuICAgICAgICBcIndcIjogMTkuNzQ4LFxyXG4gICAgICAgIFwiaFwiOiAxMS4yODksXHJcbiAgICAgICAgXCJkXCI6IFwiTS0wLjc1LC0xMC43N2MwLjEyLDAsMC40NSwtMC4wMywwLjY5LC0wLjAzYzIuOTEsLTAuMDMsNS41NSwxLjUzLDcuNDEsNC4zNWMxLjE3LDEuNzEsMS45NSwzLjcyLDIuNDMsNi4wM2MwLjEyLDAuNTEsMC4xMiwwLjU3LDAuMDMsMC42OWMtMC4xMiwwLjIxLC0wLjQ4LDAuMjcsLTAuNjksMC4xMmMtMC4xMiwtMC4wOSwtMC4xOCwtMC4yNCwtMC4yNywtMC42OWMtMC43OCwtMy42MywtMy40MiwtNi41NCwtNi43OCwtNy4zOGMtMC43OCwtMC4yMSwtMS4yLC0wLjI0LC0yLjA3LC0wLjI0Yy0wLjYzLDAsLTAuODQsMCwtMS4yLDAuMDZjLTEuODMsMC4yNywtMy40MiwxLjA4LC00LjgsMi4zN2MtMS40MSwxLjM1LC0yLjQsMy4yMSwtMi44NSw1LjE5Yy0wLjA5LDAuNDUsLTAuMTUsMC42LC0wLjI3LDAuNjljLTAuMjEsMC4xNSwtMC41NywwLjA5LC0wLjY5LC0wLjEyYy0wLjA5LC0wLjEyLC0wLjA5LC0wLjE4LDAuMDMsLTAuNjljMC4zMywtMS42MiwwLjc4LC0zLDEuNDcsLTQuMzhjMS43NywtMy41NCw0LjQ0LC01LjY3LDcuNTYsLTUuOTd6bTAuMzMsNy40N2MxLjM4LC0wLjMsMi41OCwwLjksMi4zMSwyLjI1Yy0wLjE1LDAuNzIsLTAuNzgsMS4zNSwtMS40NywxLjVjLTEuMzgsMC4yNywtMi41OCwtMC45MywtMi4zMSwtMi4zMWMwLjE1LC0wLjY5LDAuNzgsLTEuMjksMS40NywtMS40NHpcIlxyXG4gICAgfSxcclxuICAgIFwic2NyaXB0cy5kZmVybWF0YVwiOiB7XHJcbiAgICAgICAgXCJ3XCI6IDE5Ljc0NCxcclxuICAgICAgICBcImhcIjogMTEuMjc0LFxyXG4gICAgICAgIFwiZFwiOiBcIk0tOS42MywtMC40MmMwLjE1LC0wLjA5LDAuMzYsLTAuMDYsMC41MSwwLjAzYzAuMTIsMC4wOSwwLjE4LDAuMjQsMC4yNywwLjY2YzAuNzgsMy42NiwzLjQyLDYuNTcsNi43OCw3LjQxYzAuNzgsMC4yMSwxLjIsMC4yNCwyLjA3LDAuMjRjMC42MywwLDAuODQsMCwxLjIsLTAuMDZjMS44MywtMC4yNywzLjQyLC0xLjA4LDQuOCwtMi4zN2MxLjQxLC0xLjM1LDIuNCwtMy4yMSwyLjg1LC01LjIyYzAuMDksLTAuNDIsMC4xNSwtMC41NywwLjI3LC0wLjY2YzAuMjEsLTAuMTUsMC41NywtMC4wOSwwLjY5LDAuMTJjMC4wOSwwLjEyLDAuMDksMC4xOCwtMC4wMywwLjY5Yy0wLjMzLDEuNjIsLTAuNzgsMywtMS40Nyw0LjM4Yy0xLjkyLDMuODQsLTQuODksNiwtOC4zMSw2Yy0zLjQyLDAsLTYuMzksLTIuMTYsLTguMzEsLTZjLTAuNDgsLTAuOTYsLTAuODQsLTEuOTIsLTEuMTQsLTIuOTdjLTAuMTgsLTAuNjksLTAuNDIsLTEuNzQsLTAuNDIsLTEuOTJjMCwtMC4xMiwwLjA5LC0wLjI3LDAuMjQsLTAuMzN6bTkuMjEsMGMxLjIsLTAuMjcsMi4zNCwwLjYzLDIuMzQsMS44NmMwLDAuOSwtMC42NiwxLjY4LC0xLjUsMS44OWMtMS4zOCwwLjI3LC0yLjU4LC0wLjkzLC0yLjMxLC0yLjMxYzAuMTUsLTAuNjksMC43OCwtMS4yOSwxLjQ3LC0xLjQ0elwiXHJcbiAgICB9LFxyXG4gICAgXCJzY3JpcHRzLnNmb3J6YXRvXCI6IHtcclxuICAgICAgICBcIndcIjogMTMuNSxcclxuICAgICAgICBcImhcIjogNy41LFxyXG4gICAgICAgIFwiZFwiOiBcIk0tNi40NSwtMy42OWMwLjA2LC0wLjAzLDAuMTUsLTAuMDYsMC4xOCwtMC4wNmMwLjA2LDAsMi44NSwwLjcyLDYuMjQsMS41OWw2LjMzLDEuNjVjMC4zMywwLjA2LDAuNDUsMC4yMSwwLjQ1LDAuNTFjMCwwLjMsLTAuMTIsMC40NSwtMC40NSwwLjUxbC02LjMzLDEuNjVjLTMuMzksMC44NywtNi4xOCwxLjU5LC02LjIxLDEuNTljLTAuMjEsMCwtMC40OCwtMC4yNCwtMC41MSwtMC40NWMwLC0wLjE1LDAuMDYsLTAuMzYsMC4xOCwtMC40NWMwLjA5LC0wLjA2LDAuODcsLTAuMjcsMy44NCwtMS4wNWMyLjA0LC0wLjU0LDMuODQsLTAuOTksNC4wMiwtMS4wMmMwLjE1LC0wLjA2LDEuMTQsLTAuMjQsMi4yMiwtMC40MmMxLjA1LC0wLjE4LDEuOTIsLTAuMzYsMS45MiwtMC4zNmMwLDAsLTAuODcsLTAuMTgsLTEuOTIsLTAuMzZjLTEuMDgsLTAuMTgsLTIuMDcsLTAuMzYsLTIuMjIsLTAuNDJjLTAuMTgsLTAuMDMsLTEuOTgsLTAuNDgsLTQuMDIsLTEuMDJjLTIuOTcsLTAuNzgsLTMuNzUsLTAuOTksLTMuODQsLTEuMDVjLTAuMTIsLTAuMDksLTAuMTgsLTAuMywtMC4xOCwtMC40NWMwLjAzLC0wLjE1LDAuMTUsLTAuMywwLjMsLTAuMzl6XCJcclxuICAgIH0sXHJcbiAgICBcInNjcmlwdHMuc3RhY2NhdG9cIjoge1xyXG4gICAgICAgIFwid1wiOiAyLjk4OSxcclxuICAgICAgICBcImhcIjogMy4wMDQsXHJcbiAgICAgICAgXCJkXCI6IFwiTS0wLjM2LC0xLjQ3YzAuOTMsLTAuMjEsMS44NiwwLjUxLDEuODYsMS40N2MwLDAuOTMsLTAuODcsMS42NSwtMS44LDEuNDdjLTAuNTQsLTAuMTIsLTEuMDIsLTAuNTcsLTEuMTQsLTEuMDhjLTAuMjEsLTAuODEsMC4yNywtMS42NSwxLjA4LC0xLjg2elwiXHJcbiAgICB9LFxyXG4gICAgXCJzY3JpcHRzLnRlbnV0b1wiOiB7XHJcbiAgICAgICAgXCJ3XCI6IDguOTg1LFxyXG4gICAgICAgIFwiaFwiOiAxLjA4LFxyXG4gICAgICAgIFwiZFwiOiBcIk0tNC4yLC0wLjQ4bDAuMTIsLTAuMDZsNC4wOCwwbDQuMDgsMGwwLjEyLDAuMDZjMC4zOSwwLjIxLDAuMzksMC43NSwwLDAuOTZsLTAuMTIsMC4wNmwtNC4wOCwwbC00LjA4LDBsLTAuMTIsLTAuMDZjLTAuMzksLTAuMjEsLTAuMzksLTAuNzUsMCwtMC45NnpcIlxyXG4gICAgfSxcclxuICAgIFwic2NyaXB0cy51bWFyY2F0b1wiOiB7XHJcbiAgICAgICAgXCJ3XCI6IDcuNSxcclxuICAgICAgICBcImhcIjogOC4yNDUsXHJcbiAgICAgICAgXCJkXCI6IFwiTS0wLjE1LC04LjE5YzAuMTUsLTAuMTIsMC4zNiwtMC4wMywwLjQ1LDAuMTVjMC4yMSwwLjQyLDMuNDUsNy42NSwzLjQ1LDcuNzFjMCwwLjEyLC0wLjEyLDAuMjcsLTAuMjEsMC4zYy0wLjAzLDAuMDMsLTAuNTEsMC4wMywtMS4xNCwwLjAzYy0xLjA1LDAsLTEuMDgsMCwtMS4xNywtMC4wNmMtMC4wOSwtMC4wNiwtMC4yNCwtMC4zNiwtMS4xNywtMi40Yy0wLjU3LC0xLjI5LC0xLjA1LC0yLjM0LC0xLjA4LC0yLjM0YzAsLTAuMDMsLTAuNTEsMS4wMiwtMS4wOCwyLjM0Yy0wLjkzLDIuMDcsLTEuMDgsMi4zNCwtMS4xNCwyLjRjLTAuMDYsMC4wMywtMC4xNSwwLjA2LC0wLjE4LDAuMDZjLTAuMTUsMCwtMC4zMywtMC4xOCwtMC4zMywtMC4zM2MwLC0wLjA2LDMuMjQsLTcuMzIsMy40NSwtNy43MWMwLjAzLC0wLjA2LDAuMDksLTAuMTUsMC4xNSwtMC4xNXpcIlxyXG4gICAgfSxcclxuICAgIFwic2NyaXB0cy5kbWFyY2F0b1wiOiB7XHJcbiAgICAgICAgXCJ3XCI6IDcuNSxcclxuICAgICAgICBcImhcIjogOC4yNSxcclxuICAgICAgICBcImRcIjogXCJNLTMuNTcsMC4wM2MwLjAzLDAsMC41NywtMC4wMywxLjE3LC0wLjAzYzEuMDUsMCwxLjA4LDAsMS4xNywwLjA2YzAuMDksMC4wNiwwLjI0LDAuMzYsMS4xNywyLjRjMC41NywxLjI5LDEuMDUsMi4zNCwxLjA4LDIuMzRjMCwwLjAzLDAuNTEsLTEuMDIsMS4wOCwtMi4zNGMwLjkzLC0yLjA3LDEuMDgsLTIuMzQsMS4xNCwtMi40YzAuMDYsLTAuMDMsMC4xNSwtMC4wNiwwLjE4LC0wLjA2YzAuMTUsMCwwLjMzLDAuMTgsMC4zMywwLjMzYzAsMC4wOSwtMy40NSw3Ljc0LC0zLjU0LDcuODNjLTAuMTIsMC4xMiwtMC4zLDAuMTIsLTAuNDIsMGMtMC4wOSwtMC4wOSwtMy41NCwtNy43NCwtMy41NCwtNy44M2MwLC0wLjA5LDAuMTIsLTAuMjcsMC4xOCwtMC4zelwiXHJcbiAgICB9LFxyXG4gICAgXCJzY3JpcHRzLnN0b3BwZWRcIjoge1xyXG4gICAgICAgIFwid1wiOiA4LjI5NSxcclxuICAgICAgICBcImhcIjogOC4yOTUsXHJcbiAgICAgICAgXCJkXCI6IFwiTS0wLjI3LC00LjA4YzAuMTgsLTAuMDksMC4zNiwtMC4wOSwwLjU0LDBjMC4xOCwwLjA5LDAuMjQsMC4xNSwwLjMzLDAuM2wwLjA2LDAuMTVsMCwxLjVsMCwxLjQ3bDEuNDcsMGwxLjUsMGwwLjE1LDAuMDZjMC4xNSwwLjA5LDAuMjEsMC4xNSwwLjMsMC4zM2MwLjA5LDAuMTgsMC4wOSwwLjM2LDAsMC41NGMtMC4wOSwwLjE4LC0wLjE1LDAuMjQsLTAuMzMsMC4zM2MtMC4xMiwwLjA2LC0wLjE4LDAuMDYsLTEuNjIsMC4wNmwtMS40NywwbDAsMS40N2wwLDEuNDdsLTAuMDYsMC4xNWMtMC4wOSwwLjE4LC0wLjE1LDAuMjQsLTAuMzMsMC4zM2MtMC4xOCwwLjA5LC0wLjM2LDAuMDksLTAuNTQsMGMtMC4xOCwtMC4wOSwtMC4yNCwtMC4xNSwtMC4zMywtMC4zM2wtMC4wNiwtMC4xNWwwLC0xLjQ3bDAsLTEuNDdsLTEuNDcsMGMtMS40NCwwLC0xLjUsMCwtMS42MiwtMC4wNmMtMC4xOCwtMC4wOSwtMC4yNCwtMC4xNSwtMC4zMywtMC4zM2MtMC4wOSwtMC4xOCwtMC4wOSwtMC4zNiwwLC0wLjU0YzAuMDksLTAuMTgsMC4xNSwtMC4yNCwwLjMzLC0wLjMzbDAuMTUsLTAuMDZsMS40NywwbDEuNDcsMGwwLC0xLjQ3YzAsLTEuNDQsMCwtMS41LDAuMDYsLTEuNjJjMC4wOSwtMC4xOCwwLjE1LC0wLjI0LDAuMzMsLTAuMzN6XCJcclxuICAgIH0sXHJcbiAgICBcInNjcmlwdHMudXBib3dcIjoge1xyXG4gICAgICAgIFwid1wiOiA5LjczLFxyXG4gICAgICAgIFwiaFwiOiAxNS42MDgsXHJcbiAgICAgICAgXCJkXCI6IFwiTS00LjY1LC0xNS41NGMwLjEyLC0wLjA5LDAuMzYsLTAuMDYsMC40OCwwLjAzYzAuMDMsMC4wMywwLjA5LDAuMDksMC4xMiwwLjE1YzAuMDMsMC4wNiwwLjY2LDIuMTMsMS40MSw0LjYyYzEuMzUsNC40MSwxLjM4LDQuNTYsMi4wMSw2Ljk2bDAuNjMsMi40NmwwLjYzLC0yLjQ2YzAuNjMsLTIuNCwwLjY2LC0yLjU1LDIuMDEsLTYuOTZjMC43NSwtMi40OSwxLjM4LC00LjU2LDEuNDEsLTQuNjJjMC4wNiwtMC4xNSwwLjE4LC0wLjIxLDAuMzYsLTAuMjRjMC4xNSwwLDAuMywwLjA2LDAuMzksMC4xOGMwLjE1LDAuMjEsMC4yNCwtMC4xOCwtMi4xLDcuNTZjLTEuMiwzLjk2LC0yLjIyLDcuMzIsLTIuMjUsNy40MWMwLDAuMTIsLTAuMDYsMC4yNywtMC4wOSwwLjNjLTAuMTIsMC4yMSwtMC42LDAuMjEsLTAuNzIsMGMtMC4wMywtMC4wMywtMC4wOSwtMC4xOCwtMC4wOSwtMC4zYy0wLjAzLC0wLjA5LC0xLjA1LC0zLjQ1LC0yLjI1LC03LjQxYy0yLjM0LC03Ljc0LC0yLjI1LC03LjM1LC0yLjEsLTcuNTZjMC4wMywtMC4wMywwLjA5LC0wLjA5LDAuMTUsLTAuMTJ6XCJcclxuICAgIH0sXHJcbiAgICBcInNjcmlwdHMuZG93bmJvd1wiOiB7XHJcbiAgICAgICAgXCJ3XCI6IDExLjIyLFxyXG4gICAgICAgIFwiaFwiOiA5Ljk5MixcclxuICAgICAgICBcImRcIjogXCJNLTUuNTUsLTkuOTNsMC4wOSwtMC4wNmw1LjQ2LDBsNS40NiwwbDAuMDksMC4wNmwwLjA2LDAuMDlsMCw0Ljc3YzAsNS4yOCwwLDQuODksLTAuMTgsNS4wMWMtMC4xOCwwLjEyLC0wLjQyLDAuMDYsLTAuNTQsLTAuMTJjLTAuMDYsLTAuMDksLTAuMDYsLTAuMTgsLTAuMDYsLTIuOTdsMCwtMi44NWwtNC44MywwbC00LjgzLDBsMCwyLjg1YzAsMi43OSwwLDIuODgsLTAuMDYsMi45N2MtMC4xNSwwLjI0LC0wLjUxLDAuMjQsLTAuNjYsMGMtMC4wNiwtMC4wOSwtMC4wNiwtMC4yMSwtMC4wNiwtNC44OWwwLC00Ljc3elwiXHJcbiAgICB9LFxyXG4gICAgXCJzY3JpcHRzLnR1cm5cIjoge1xyXG4gICAgICAgIFwid1wiOiAxNi4zNjYsXHJcbiAgICAgICAgXCJoXCI6IDcuODkzLFxyXG4gICAgICAgIFwiZFwiOiBcIk0tNC43NywtMy45YzAuMzYsLTAuMDYsMS4wNSwtMC4wNiwxLjQ0LDAuMDNjMC43OCwwLjE1LDEuNSwwLjUxLDIuMzQsMS4xNGMwLjYsMC40NSwxLjA1LDAuODcsMi4yMiwyLjAxYzEuMTEsMS4wOCwxLjYyLDEuNSwyLjIyLDEuODZjMC42LDAuMzYsMS4zMiwwLjU3LDEuOTIsMC41N2MwLjksMCwxLjcxLC0wLjU3LDEuODksLTEuMzVjMC4yNCwtMC45MywtMC4zOSwtMS44OSwtMS4zNSwtMi4xbC0wLjE1LC0wLjA2bC0wLjA5LDAuMTVjLTAuMDMsMC4wOSwtMC4xNSwwLjI0LC0wLjI0LDAuMzNjLTAuNzIsMC43MiwtMi4wNCwwLjU0LC0yLjQ5LC0wLjM2Yy0wLjQ4LC0wLjkzLDAuMDMsLTEuODYsMS4xNywtMi4xOWMwLjMsLTAuMDksMS4wMiwtMC4wOSwxLjM1LDBjMC45OSwwLjI3LDEuNzQsMC44NywyLjI1LDEuODNjMC42OSwxLjQxLDAuNjMsMywtMC4yMSw0LjI2Yy0wLjIxLDAuMywtMC42OSwwLjgxLC0wLjk5LDEuMDJjLTAuMywwLjIxLC0wLjg0LDAuNDUsLTEuMTcsMC41NGMtMS4yMywwLjM2LC0yLjQ5LDAuMTUsLTMuNzIsLTAuNmMtMC43NSwtMC40OCwtMS40MSwtMS4wMiwtMi44NSwtMi40NmMtMS4xMSwtMS4wOCwtMS42MiwtMS41LC0yLjIyLC0xLjg2Yy0wLjYsLTAuMzYsLTEuMzIsLTAuNTcsLTEuOTIsLTAuNTdjLTAuOSwwLC0xLjcxLDAuNTcsLTEuODksMS4zNWMtMC4yNCwwLjkzLDAuMzksMS44OSwxLjM1LDIuMWwwLjE1LDAuMDZsMC4wOSwtMC4xNWMwLjAzLC0wLjA5LDAuMTUsLTAuMjQsMC4yNCwtMC4zM2MwLjcyLC0wLjcyLDIuMDQsLTAuNTQsMi40OSwwLjM2YzAuNDgsMC45MywtMC4wMywxLjg2LC0xLjE3LDIuMTljLTAuMywwLjA5LC0xLjAyLDAuMDksLTEuMzUsMGMtMC45OSwtMC4yNywtMS43NCwtMC44NywtMi4yNSwtMS44M2MtMC42OSwtMS40MSwtMC42MywtMywwLjIxLC00LjI2YzAuMjEsLTAuMywwLjY5LC0wLjgxLDAuOTksLTEuMDJjMC40OCwtMC4zMywxLjExLC0wLjU3LDEuNzQsLTAuNjZ6XCJcclxuICAgIH0sXHJcbiAgICBcInNjcmlwdHMudHJpbGxcIjoge1xyXG4gICAgICAgIFwid1wiOiAxNy45NjMsXHJcbiAgICAgICAgXCJoXCI6IDE2LjQ5LFxyXG4gICAgICAgIFwiZFwiOiBcIk0tMC41MSwtMTYuMDJjMC4xMiwtMC4wOSwwLjIxLC0wLjE4LDAuMjEsLTAuMThsLTAuODEsNC4wMmwtMC44MSw0LjAyYzAuMDMsMCwwLjUxLC0wLjI3LDEuMDgsLTAuNmMwLjYsLTAuMywxLjE0LC0wLjYzLDEuMjYsLTAuNjZjMS4xNCwtMC41NCwyLjMxLC0wLjYsMy4wOSwtMC4xOGMwLjI3LDAuMTUsMC41NCwwLjM2LDAuNiwwLjUxbDAuMDYsMC4xMmwwLjIxLC0wLjIxYzAuOSwtMC44MSwyLjIyLC0wLjk5LDMuMTIsLTAuNDJjMC42LDAuNDIsMC45LDEuMTQsMC43OCwyLjA3Yy0wLjE1LDEuMjksLTEuMDUsMi4zMSwtMS45NSwyLjI1Yy0wLjQ4LC0wLjAzLC0wLjc4LC0wLjMsLTAuOTYsLTAuODFjLTAuMDksLTAuMjcsLTAuMDksLTAuOSwtMC4wMywtMS4yYzAuMjEsLTAuNzUsMC44MSwtMS4yMywxLjU5LC0xLjMybDAuMjQsLTAuMDNsLTAuMDksLTAuMTJjLTAuNTEsLTAuNjYsLTEuNjIsLTAuNjMsLTIuMzEsMC4wM2MtMC4zOSwwLjQyLC0wLjMsMC4wOSwtMS4yMyw0Ljc3bC0wLjgxLDQuMTRjLTAuMDMsMCwtMC4xMiwtMC4wMywtMC4yMSwtMC4wOWMtMC4zMywtMC4xNSwtMC41NCwtMC4xOCwtMC45OSwtMC4xOGMtMC40MiwwLC0wLjY2LDAuMDMsLTEuMDUsMC4xOGMtMC4xMiwwLjA2LC0wLjIxLDAuMDksLTAuMjEsMC4wOWMwLC0wLjAzLDAuMzYsLTEuODYsMC44MSwtNC4xMWMwLjksLTQuNDcsMC44NywtNC4yNiwwLjY5LC00LjUzYy0wLjIxLC0wLjM2LC0wLjY2LC0wLjUxLC0xLjE3LC0wLjM2Yy0wLjE1LDAuMDYsLTIuMjIsMS4xNCwtMi41OCwxLjM4Yy0wLjEyLDAuMDksLTAuMTIsMC4wOSwtMC4yMSwwLjZsLTAuMDksMC41MWwwLjIxLDAuMjRjMC42MywwLjc1LDEuMDIsMS40NywxLjIsMi4xOWMwLjA2LDAuMjcsMC4wNiwwLjM2LDAuMDYsMC44MWMwLDAuNDIsMCwwLjU0LC0wLjA2LDAuNzhjLTAuMTUsMC41NCwtMC4zMywwLjkzLC0wLjYzLDEuMzVjLTAuMTgsMC4yNCwtMC41NywwLjYzLC0wLjgxLDAuNzhjLTAuMjQsMC4xNSwtMC42MywwLjM2LC0wLjg0LDAuNDJjLTAuMjcsMC4wNiwtMC42NiwwLjA2LC0wLjg3LDAuMDNjLTAuODEsLTAuMTgsLTEuMzIsLTEuMDUsLTEuMzgsLTIuNDZjLTAuMDMsLTAuNiwwLjAzLC0wLjk5LDAuMzMsLTIuNDZjMC4yMSwtMS4wOCwwLjI0LC0xLjMyLDAuMjEsLTEuMjljLTEuMiwwLjQ4LC0yLjQsMC43NSwtMy4yMSwwLjcyYy0wLjY5LC0wLjA2LC0xLjE3LC0wLjMsLTEuNDEsLTAuNzJjLTAuMzksLTAuNzUsLTAuMTIsLTEuOCwwLjY2LC0yLjQ2YzAuMjQsLTAuMTgsMC42OSwtMC40MiwxLjAyLC0wLjUxYzAuNjksLTAuMTgsMS41MywtMC4xNSwyLjMxLDAuMDljMC4zLDAuMDksMC43NSwwLjMsMC45OSwwLjQ1YzAuMTIsMC4wOSwwLjE1LDAuMDksMC4xNSwwLjAzYzAuMDMsLTAuMDMsMC4zMywtMS41OSwwLjcyLC0zLjQ1YzAuMzYsLTEuODYsMC42NiwtMy40MiwwLjY5LC0zLjQ1YzAsLTAuMDMsMC4wMywtMC4wMywwLjIxLDAuMDNjMC4yMSwwLjA2LDAuMjcsMC4wNiwwLjQ4LDAuMDZjMC40MiwtMC4wMywwLjc4LC0wLjE4LDEuMjYsLTAuNDhjMC4xNSwtMC4xMiwwLjM2LC0wLjI3LDAuNDgsLTAuMzl6bS01LjczLDcuNjhjLTAuMjcsLTAuMDMsLTAuOTYsLTAuMDYsLTEuMiwtMC4wM2MtMC44MSwwLjEyLC0xLjM1LDAuNTcsLTEuNSwxLjJjLTAuMTgsMC42NiwwLjEyLDEuMTQsMC43NSwxLjI5YzAuNjYsMC4xMiwxLjkyLC0wLjEyLDMuMTgsLTAuNjZsMC4zMywtMC4xNWwwLjA5LC0wLjM5YzAuMDYsLTAuMjEsMC4wOSwtMC40MiwwLjA5LC0wLjQ1YzAsLTAuMDMsLTAuNDUsLTAuMywtMC43NSwtMC40NWMtMC4yNywtMC4xNSwtMC42NiwtMC4yNywtMC45OSwtMC4zNnptNC4yOSwzLjYzYy0wLjI0LC0wLjM5LC0wLjUxLC0wLjc1LC0wLjUxLC0wLjY5Yy0wLjA2LDAuMTIsLTAuMzksMS45MiwtMC40NSwyLjI4Yy0wLjA5LDAuNTQsLTAuMTIsMS4xNCwtMC4wNiwxLjM4YzAuMDYsMC40MiwwLjIxLDAuNiwwLjUxLDAuNTdjMC4zOSwtMC4wNiwwLjc1LC0wLjQ4LDAuOTMsLTEuMTRjMC4wOSwtMC4zMywwLjA5LC0xLjA1LDAsLTEuMzhjLTAuMDksLTAuMzksLTAuMjQsLTAuNjksLTAuNDIsLTEuMDJ6XCJcclxuICAgIH0sXHJcbiAgICBcInNjcmlwdHMuc2Vnbm9cIjoge1xyXG4gICAgICAgIFwid1wiOiAxNSxcclxuICAgICAgICBcImhcIjogMjIuNTA0LFxyXG4gICAgICAgIFwiZFwiOiBcIk0tMy43MiwtMTEuMjJjMC43OCwtMC4wOSwxLjU5LDAuMDMsMi4zMSwwLjQyYzEuMiwwLjYsMi4wMSwxLjcxLDIuMzEsMy4wOWMwLjA5LDAuNDIsMC4wOSwxLjIsMC4wMywxLjVjLTAuMTUsMC40NSwtMC4zOSwwLjgxLC0wLjY2LDAuOTNjLTAuMzMsMC4xOCwtMC44NCwwLjIxLC0xLjIzLDAuMTVjLTAuODEsLTAuMTgsLTEuMzIsLTAuOTMsLTEuMjYsLTEuODljMC4wMywtMC4zNiwwLjA5LC0wLjU3LDAuMjQsLTAuOWMwLjE1LC0wLjMzLDAuNDUsLTAuNiwwLjcyLC0wLjc1YzAuMTIsLTAuMDYsMC4xOCwtMC4wOSwwLjE4LC0wLjEyYzAsLTAuMDMsLTAuMDMsLTAuMTUsLTAuMDksLTAuMjRjLTAuMTgsLTAuNDUsLTAuNTQsLTAuODcsLTAuOTYsLTEuMDhjLTEuMTEsLTAuNTcsLTIuMzQsLTAuMTgsLTIuODgsMC45Yy0wLjI0LDAuNTEsLTAuMzMsMS4xMSwtMC4yNCwxLjgzYzAuMjcsMS45MiwxLjUsMy41NCwzLjkzLDUuMTNjMC40OCwwLjMzLDEuMjYsMC43OCwxLjI5LDAuNzhjMC4wMywwLDEuMzUsLTIuMTksMi45NCwtNC44OWwyLjg4LC00Ljg5bDAuODQsMGwwLjg3LDBsLTAuMDMsMC4wNmMtMC4xNSwwLjIxLC02LjE1LDEwLjQxLC02LjE1LDEwLjQ0YzAsMCwwLjIxLDAuMTUsMC40OCwwLjI3YzIuNjEsMS40Nyw0LjM1LDMuMDMsNS4xMyw0LjY1YzEuMTQsMi4zNCwwLjUxLDUuMDcsLTEuNDQsNi4zOWMtMC42NiwwLjQyLC0xLjMyLDAuNjMsLTIuMTMsMC42OWMtMi4wMSwwLjA5LC0zLjgxLC0xLjQxLC00LjI2LC0zLjU0Yy0wLjA5LC0wLjQyLC0wLjA5LC0xLjIsLTAuMDMsLTEuNWMwLjE1LC0wLjQ1LDAuMzksLTAuODEsMC42NiwtMC45M2MwLjMzLC0wLjE4LDAuODQsLTAuMjEsMS4yMywtMC4xNWMwLjgxLDAuMTgsMS4zMiwwLjkzLDEuMjYsMS44OWMtMC4wMywwLjM2LC0wLjA5LDAuNTcsLTAuMjQsMC45Yy0wLjE1LDAuMzMsLTAuNDUsMC42LC0wLjcyLDAuNzVjLTAuMTIsMC4wNiwtMC4xOCwwLjA5LC0wLjE4LDAuMTJjMCwwLjAzLDAuMDMsMC4xNSwwLjA5LDAuMjRjMC4xOCwwLjQ1LDAuNTQsMC44NywwLjk2LDEuMDhjMS4xMSwwLjU3LDIuMzQsMC4xOCwyLjg4LC0wLjljMC4yNCwtMC41MSwwLjMzLC0xLjExLDAuMjQsLTEuODNjLTAuMjcsLTEuOTIsLTEuNSwtMy41NCwtMy45MywtNS4xM2MtMC40OCwtMC4zMywtMS4yNiwtMC43OCwtMS4yOSwtMC43OGMtMC4wMywwLC0xLjM1LDIuMTksLTIuOTEsNC44OWwtMi44OCw0Ljg5bC0wLjg3LDBsLTAuODcsMGwwLjAzLC0wLjA2YzAuMTUsLTAuMjEsNi4xNSwtMTAuNDEsNi4xNSwtMTAuNDRjMCwwLC0wLjIxLC0wLjE1LC0wLjQ4LC0wLjNjLTIuNjEsLTEuNDQsLTQuMzUsLTMsLTUuMTMsLTQuNjJjLTAuOSwtMS44OSwtMC43MiwtNC4wMiwwLjQ4LC01LjUyYzAuNjksLTAuODQsMS42OCwtMS40MSwyLjczLC0xLjUzem04Ljc2LDkuMDljMC4wMywtMC4wMywwLjE1LC0wLjAzLDAuMjcsLTAuMDNjMC4zMywwLjAzLDAuNTcsMC4xOCwwLjcyLDAuNDhjMC4wOSwwLjE4LDAuMDksMC41NywwLDAuNzVjLTAuMDksMC4xOCwtMC4yMSwwLjMsLTAuMzYsMC4zOWMtMC4xNSwwLjA2LC0wLjIxLDAuMDYsLTAuMzksMC4wNmMtMC4yMSwwLC0wLjI3LDAsLTAuMzksLTAuMDZjLTAuMywtMC4xNSwtMC40OCwtMC40NSwtMC40OCwtMC43NWMwLC0wLjM5LDAuMjQsLTAuNzIsMC42MywtMC44NHptLTEwLjUzLDIuNjFjMC4wMywtMC4wMywwLjE1LC0wLjAzLDAuMjcsLTAuMDNjMC4zMywwLjAzLDAuNTcsMC4xOCwwLjcyLDAuNDhjMC4wOSwwLjE4LDAuMDksMC41NywwLDAuNzVjLTAuMDksMC4xOCwtMC4yMSwwLjMsLTAuMzYsMC4zOWMtMC4xNSwwLjA2LC0wLjIxLDAuMDYsLTAuMzksMC4wNmMtMC4yMSwwLC0wLjI3LDAsLTAuMzksLTAuMDZjLTAuMywtMC4xNSwtMC40OCwtMC40NSwtMC40OCwtMC43NWMwLC0wLjM5LDAuMjQsLTAuNzIsMC42MywtMC44NHpcIlxyXG4gICAgfSxcclxuICAgIFwic2NyaXB0cy5jb2RhXCI6IHtcclxuICAgICAgICBcIndcIjogMTYuMDM1LFxyXG4gICAgICAgIFwiaFwiOiAyMS4wNjIsXHJcbiAgICAgICAgXCJkXCI6IFwiTS0wLjIxLC0xMC40N2MwLjE4LC0wLjEyLDAuNDIsLTAuMDYsMC41NCwwLjEyYzAuMDYsMC4wOSwwLjA2LDAuMTgsMC4wNiwxLjVsMCwxLjM4bDAuMTgsMGMwLjM5LDAuMDYsMC45NiwwLjI0LDEuMzgsMC40OGMxLjY4LDAuOTMsMi44MiwzLjI0LDMuMDMsNi4xMmMwLjAzLDAuMjQsMC4wMywwLjQ1LDAuMDMsMC40NWMwLDAuMDMsMC42LDAuMDMsMS4zNSwwLjAzYzEuNSwwLDEuNDcsMCwxLjU5LDAuMThjMC4wOSwwLjEyLDAuMDksMC4zLDAsMC40MmMtMC4xMiwwLjE4LC0wLjA5LDAuMTgsLTEuNTksMC4xOGMtMC43NSwwLC0xLjM1LDAsLTEuMzUsMC4wM2MwLDAsMCwwLjIxLC0wLjAzLDAuNDJjLTAuMjQsMy4xNSwtMS41Myw1LjU4LC0zLjQ1LDYuMzZjLTAuMjcsMC4xMiwtMC43MiwwLjI0LC0wLjk2LDAuMjdsLTAuMTgsMGwwLDEuMzhjMCwxLjMyLDAsMS40MSwtMC4wNiwxLjVjLTAuMTUsMC4yNCwtMC41MSwwLjI0LC0wLjY2LDBjLTAuMDYsLTAuMDksLTAuMDYsLTAuMTgsLTAuMDYsLTEuNWwwLC0xLjM4bC0wLjE4LDBjLTAuMzksLTAuMDYsLTAuOTYsLTAuMjQsLTEuMzgsLTAuNDhjLTEuNjgsLTAuOTMsLTIuODIsLTMuMjQsLTMuMDMsLTYuMTVjLTAuMDMsLTAuMjEsLTAuMDMsLTAuNDIsLTAuMDMsLTAuNDJjMCwtMC4wMywtMC42LC0wLjAzLC0xLjM1LC0wLjAzYy0xLjUsMCwtMS40NywwLC0xLjU5LC0wLjE4Yy0wLjA5LC0wLjEyLC0wLjA5LC0wLjMsMCwtMC40MmMwLjEyLC0wLjE4LDAuMDksLTAuMTgsMS41OSwtMC4xOGMwLjc1LDAsMS4zNSwwLDEuMzUsLTAuMDNjMCwwLDAsLTAuMjEsMC4wMywtMC40NWMwLjI0LC0zLjEyLDEuNTMsLTUuNTUsMy40NSwtNi4zM2MwLjI3LC0wLjEyLDAuNzIsLTAuMjQsMC45NiwtMC4yN2wwLjE4LDBsMCwtMS4zOGMwLC0xLjUzLDAsLTEuNSwwLjE4LC0xLjYyem0tMC4xOCw2LjkzYzAsLTIuOTcsMCwtMy4xNSwtMC4wNiwtMy4xNWMtMC4wOSwwLC0wLjUxLDAuMTUsLTAuNjYsMC4yMWMtMC44NywwLjUxLC0xLjM4LDEuNjIsLTEuNTYsMy41MWMtMC4wNiwwLjU0LC0wLjEyLDEuNTksLTAuMTIsMi4xNmwwLDAuNDJsMS4yLDBsMS4yLDBsMCwtMy4xNXptMS4xNywtMy4wNmMtMC4wOSwtMC4wMywtMC4yMSwtMC4wNiwtMC4yNywtMC4wOWwtMC4xMiwwbDAsMy4xNWwwLDMuMTVsMS4yLDBsMS4yLDBsMCwtMC44MWMtMC4wNiwtMi40LC0wLjMzLC0zLjY5LC0wLjkzLC00LjU5Yy0wLjI3LC0wLjM5LC0wLjY2LC0wLjY5LC0xLjA4LC0wLjgxem0tMS4xNywxMC4xNGwwLC0zLjE1bC0xLjIsMGwtMS4yLDBsMCwwLjgxYzAuMDMsMC45NiwwLjA2LDEuNDcsMC4xNSwyLjEzYzAuMjQsMi4wNCwwLjk2LDMuMTIsMi4xMywzLjM2bDAuMTIsMGwwLC0zLjE1em0zLjE4LC0yLjM0bDAsLTAuODFsLTEuMiwwbC0xLjIsMGwwLDMuMTVsMCwzLjE1bDAuMTIsMGMxLjE3LC0wLjI0LDEuODksLTEuMzIsMi4xMywtMy4zNmMwLjA5LC0wLjY2LDAuMTIsLTEuMTcsMC4xNSwtMi4xM3pcIlxyXG4gICAgfSxcclxuICAgIFwic2NyaXB0cy5jb21tYVwiOiB7XHJcbiAgICAgICAgXCJ3XCI6IDMuMDQyLFxyXG4gICAgICAgIFwiaFwiOiA5LjIzNyxcclxuICAgICAgICBcImRcIjogXCJNMS4xNCwtNC42MmMwLjMsLTAuMTIsMC42OSwtMC4wMywwLjkzLDAuMTVjMC4xMiwwLjEyLDAuMzYsMC40NSwwLjUxLDAuNzhjMC45LDEuNzcsMC41NCw0LjA1LC0xLjA4LDYuNzVjLTAuMzYsMC42MywtMC44NywxLjM4LC0wLjk2LDEuNDRjLTAuMTgsMC4xMiwtMC40MiwwLjA2LC0wLjU0LC0wLjEyYy0wLjA5LC0wLjE4LC0wLjA5LC0wLjMsMC4xMiwtMC42YzAuOTYsLTEuNDQsMS40NCwtMi45NywxLjM4LC00LjM1Yy0wLjA2LC0wLjkzLC0wLjMsLTEuNjgsLTAuNzgsLTIuNDZjLTAuMjcsLTAuMzksLTAuMzMsLTAuNjMsLTAuMjQsLTAuOTZjMC4wOSwtMC4yNywwLjM2LC0wLjU0LDAuNjYsLTAuNjN6XCJcclxuICAgIH0sXHJcbiAgICBcInNjcmlwdHMucm9sbFwiOiB7XHJcbiAgICAgICAgXCJ3XCI6IDEwLjgxNyxcclxuICAgICAgICBcImhcIjogNi4xMjUsXHJcbiAgICAgICAgXCJkXCI6IFwiTTEuOTUsLTZjMC4yMSwtMC4wOSwwLjM2LC0wLjA5LDAuNTcsMGMwLjM5LDAuMTUsMC42MywwLjM5LDEuNDcsMS4zNWMwLjY2LDAuNzUsMC43OCwwLjg3LDEuMDgsMS4wNWMwLjc1LDAuNDUsMS42NSwwLjQyLDIuNCwtMC4wNmMwLjEyLC0wLjA5LDAuMjcsLTAuMjcsMC41NCwtMC42YzAuNDIsLTAuNTQsMC41MSwtMC42MywwLjY5LC0wLjYzYzAuMDksMCwwLjMsMC4xMiwwLjM2LDAuMjFjMC4wOSwwLjEyLDAuMTIsMC4zLDAuMDMsMC40MmMtMC4wNiwwLjEyLC0zLjE1LDMuOSwtMy4zLDQuMDhjLTAuMDYsMC4wNiwtMC4xOCwwLjEyLC0wLjI3LDAuMThjLTAuMjcsMC4xMiwtMC42LDAuMDYsLTAuOTksLTAuMjdjLTAuMjcsLTAuMjEsLTAuNDIsLTAuMzksLTEuMDgsLTEuMTRjLTAuNjMsLTAuNzIsLTAuODEsLTAuOSwtMS4xNywtMS4wOGMtMC4zNiwtMC4xOCwtMC41NywtMC4yMSwtMC45OSwtMC4yMWMtMC4zOSwwLC0wLjYzLDAuMDMsLTAuOTMsMC4xOGMtMC4zNiwwLjE1LC0wLjUxLDAuMjcsLTAuOSwwLjgxYy0wLjI0LDAuMjcsLTAuNDUsMC41MSwtMC40OCwwLjU0Yy0wLjEyLDAuMDksLTAuMjcsMC4wNiwtMC4zOSwwYy0wLjI0LC0wLjE1LC0wLjMzLC0wLjM5LC0wLjIxLC0wLjZjMC4wOSwtMC4xMiwzLjE4LC0zLjg3LDMuMzMsLTQuMDJjMC4wNiwtMC4wNiwwLjE4LC0wLjE1LDAuMjQsLTAuMjF6XCJcclxuICAgIH0sXHJcbiAgICBcInNjcmlwdHMucHJhbGxcIjoge1xyXG4gICAgICAgIFwid1wiOiAxNS4wMTEsXHJcbiAgICAgICAgXCJoXCI6IDcuNSxcclxuICAgICAgICBcImRcIjogXCJNLTQuMzgsLTMuNjljMC4wNiwtMC4wMywwLjE4LC0wLjA2LDAuMjQsLTAuMDZjMC4zLDAsMC4yNywtMC4wMywxLjg5LDEuOTVsMS41MywxLjgzYzAuMDMsMCwwLjU3LC0wLjg0LDEuMjMsLTEuODNjMS4xNCwtMS42OCwxLjIzLC0xLjgzLDEuMzUsLTEuODljMC4wNiwtMC4wMywwLjE4LC0wLjA2LDAuMjQsLTAuMDZjMC4zLDAsMC4yNywtMC4wMywxLjg5LDEuOTVsMS41MywxLjgzbDAuNDgsLTAuNjljMC41MSwtMC43OCwwLjU0LC0wLjg0LDAuNjksLTAuOWMwLjQyLC0wLjE4LDAuODcsMC4xNSwwLjgxLDAuNmMtMC4wMywwLjEyLC0wLjMsMC41MSwtMS41LDIuMzdjLTEuMzgsMi4wNywtMS41LDIuMjIsLTEuNjIsMi4yOGMtMC4wNiwwLjAzLC0wLjE4LDAuMDYsLTAuMjQsMC4wNmMtMC4zLDAsLTAuMjcsMC4wMywtMS44OSwtMS45NWwtMS41MywtMS44M2MtMC4wMywwLC0wLjU3LDAuODQsLTEuMjMsMS44M2MtMS4xNCwxLjY4LC0xLjIzLDEuODMsLTEuMzUsMS44OWMtMC4wNiwwLjAzLC0wLjE4LDAuMDYsLTAuMjQsMC4wNmMtMC4zLDAsLTAuMjcsMC4wMywtMS44OSwtMS45NWwtMS41MywtMS44M2wtMC40OCwwLjY5Yy0wLjUxLDAuNzgsLTAuNTQsMC44NCwtMC42OSwwLjljLTAuNDIsMC4xOCwtMC44NywtMC4xNSwtMC44MSwtMC42YzAuMDMsLTAuMTIsMC4zLC0wLjUxLDEuNSwtMi4zN2MxLjM4LC0yLjA3LDEuNSwtMi4yMiwxLjYyLC0yLjI4elwiXHJcbiAgICB9LFxyXG4gICAgXCJzY3JpcHRzLm1vcmRlbnRcIjoge1xyXG4gICAgICAgIFwid1wiOiAxNS4wMTEsXHJcbiAgICAgICAgXCJoXCI6IDEwLjAxMixcclxuICAgICAgICBcImRcIjogXCJNLTAuMjEsLTQuOTVjMC4yNywtMC4xNSwwLjYzLDAsMC43NSwwLjI3YzAuMDYsMC4xMiwwLjA2LDAuMjQsMC4wNiwxLjQ0bDAsMS4yOWwwLjU3LC0wLjg0YzAuNTEsLTAuNzUsMC41NywtMC44NCwwLjY5LC0wLjljMC4wNiwtMC4wMywwLjE4LC0wLjA2LDAuMjQsLTAuMDZjMC4zLDAsMC4yNywtMC4wMywxLjg5LDEuOTVsMS41MywxLjgzbDAuNDgsLTAuNjljMC41MSwtMC43OCwwLjU0LC0wLjg0LDAuNjksLTAuOWMwLjQyLC0wLjE4LDAuODcsMC4xNSwwLjgxLDAuNmMtMC4wMywwLjEyLC0wLjMsMC41MSwtMS41LDIuMzdjLTEuMzgsMi4wNywtMS41LDIuMjIsLTEuNjIsMi4yOGMtMC4wNiwwLjAzLC0wLjE4LDAuMDYsLTAuMjQsMC4wNmMtMC4zLDAsLTAuMjcsMC4wMywtMS44MywtMS44OWMtMC44MSwtMC45OSwtMS41LC0xLjgsLTEuNTMsLTEuODZjLTAuMDYsLTAuMDMsLTAuMDYsLTAuMDMsLTAuMTIsMC4wM2MtMC4wNiwwLjA2LC0wLjA2LDAuMTUsLTAuMDYsMi4yOGMwLDEuOTUsMCwyLjI1LC0wLjA2LDIuMzRjLTAuMTgsMC40NSwtMC44MSwwLjQ4LC0xLjA1LDAuMDNjLTAuMDMsLTAuMDYsLTAuMDYsLTAuMjQsLTAuMDYsLTEuNDFsMCwtMS4zNWwtMC41NywwLjg0Yy0wLjU0LDAuNzgsLTAuNiwwLjg3LC0wLjcyLDAuOTNjLTAuMDYsMC4wMywtMC4xOCwwLjA2LC0wLjI0LDAuMDZjLTAuMywwLC0wLjI3LDAuMDMsLTEuODksLTEuOTVsLTEuNTMsLTEuODNsLTAuNDgsMC42OWMtMC41MSwwLjc4LC0wLjU0LDAuODQsLTAuNjksMC45Yy0wLjQyLDAuMTgsLTAuODcsLTAuMTUsLTAuODEsLTAuNmMwLjAzLC0wLjEyLDAuMywtMC41MSwxLjUsLTIuMzdjMS4zOCwtMi4wNywxLjUsLTIuMjIsMS42MiwtMi4yOGMwLjA2LC0wLjAzLDAuMTgsLTAuMDYsMC4yNCwtMC4wNmMwLjMsMCwwLjI3LC0wLjAzLDEuODksMS45NWwxLjUzLDEuODNjMC4wMywwLDAuMDYsLTAuMDYsMC4wOSwtMC4wOWMwLjA2LC0wLjEyLDAuMDYsLTAuMTUsMC4wNiwtMi4yOGMwLC0xLjkyLDAsLTIuMjIsMC4wNiwtMi4zMWMwLjA2LC0wLjE1LDAuMTUsLTAuMjQsMC4zLC0wLjN6XCJcclxuICAgIH0sXHJcbiAgICBcImZsYWdzLnU4dGhcIjoge1xyXG4gICAgICAgIFwid1wiOiA2LjY5MixcclxuICAgICAgICBcImhcIjogMjIuNTksXHJcbiAgICAgICAgXCJkXCI6IFwiTS0wLjQyLDMuNzVsMCwtMy43NWwwLjIxLDBsMC4yMSwwbDAsMC4xOGMwLDAuMywwLjA2LDAuODQsMC4xMiwxLjIzYzAuMjQsMS41MywwLjksMy4xMiwyLjEzLDUuMTZsMC45OSwxLjU5YzAuODcsMS40NCwxLjM4LDIuMzQsMS43NywzLjA5YzAuODEsMS42OCwxLjIsMy4wNiwxLjI2LDQuNTNjMC4wMywxLjUzLC0wLjIxLDMuMjcsLTAuNzUsNS4wMWMtMC4yMSwwLjY5LC0wLjUxLDEuNSwtMC42LDEuNTljLTAuMDksMC4xMiwtMC4yNywwLjIxLC0wLjQyLDAuMjFjLTAuMTUsMCwtMC40MiwtMC4xMiwtMC41MSwtMC4yMWMtMC4xNSwtMC4xOCwtMC4xOCwtMC40MiwtMC4wOSwtMC42NmMwLjE1LC0wLjMzLDAuNDUsLTEuMiwwLjU3LC0xLjYyYzAuNDIsLTEuMzgsMC42LC0yLjU4LDAuNiwtMy45YzAsLTAuNjYsMCwtMC44MSwtMC4wNiwtMS4xMWMtMC4zOSwtMi4wNywtMS44LC00LjI2LC00LjU5LC03LjE0bC0wLjQyLC0wLjQ1bC0wLjIxLDBsLTAuMjEsMGwwLC0zLjc1elwiXHJcbiAgICB9LFxyXG4gICAgXCJmbGFncy51MTZ0aFwiOiB7XHJcbiAgICAgICAgXCJ3XCI6IDYuNjkzLFxyXG4gICAgICAgIFwiaFwiOiAyNi4zMzcsXHJcbiAgICAgICAgXCJkXCI6IFwiTS0wLjQyLDcuNWwwLC03LjVsMC4yMSwwbDAuMjEsMGwwLDAuMzljMC4wNiwxLjA4LDAuMzksMi4xOSwwLjk5LDMuMzljMC40NSwwLjksMC44NywxLjU5LDEuOTUsMy4xMmMxLjI5LDEuODYsMS43NywyLjY0LDIuMjIsMy41N2MwLjQ1LDAuOTMsMC43MiwxLjgsMC44NywyLjY0YzAuMDYsMC41MSwwLjA2LDEuNSwwLDEuOTJjLTAuMTIsMC42LC0wLjMsMS4yLC0wLjU0LDEuNzFsLTAuMDksMC4yNGwwLjE4LDAuNDVjMC41MSwxLjIsMC43MiwyLjIyLDAuNjksMy40MmMtMC4wNiwxLjUzLC0wLjM5LDMuMDMsLTAuOTksNC41M2MtMC4zLDAuNzUsLTAuMzYsMC44MSwtMC41NywwLjljLTAuMTUsMC4wOSwtMC4zMywwLjA2LC0wLjQ4LDBjLTAuMTgsLTAuMDksLTAuMjcsLTAuMTgsLTAuMzMsLTAuMzNjLTAuMDksLTAuMTgsLTAuMDYsLTAuMywwLjEyLC0wLjc1YzAuNjYsLTEuNDEsMS4wMiwtMi44OCwxLjA4LC00LjMyYzAsLTAuNiwtMC4wMywtMS4wNSwtMC4xOCwtMS41OWMtMC4zLC0xLjIsLTAuOTksLTIuNCwtMi4yNSwtMy44N2MtMC40MiwtMC40OCwtMS41MywtMS42MiwtMi4xOSwtMi4yMmwtMC40NSwtMC40MmwtMC4wMywxLjExbDAsMS4xMWwtMC4yMSwwbC0wLjIxLDBsMCwtNy41em0xLjY1LDAuMDljLTAuMywtMC4zLC0wLjY5LC0wLjcyLC0wLjksLTAuODdsLTAuMzMsLTAuMzNsMCwwLjE1YzAsMC4zLDAuMDYsMC44MSwwLjE1LDEuMjZjMC4yNywxLjI5LDAuODcsMi42MSwyLjA0LDQuMjljMC4xNSwwLjI0LDAuNiwwLjg3LDAuOTYsMS4zOGwxLjA4LDEuNTNsMC40MiwwLjYzYzAuMDMsMCwwLjEyLC0wLjM2LDAuMjEsLTAuNzJjMC4wNiwtMC4zMywwLjA2LC0xLjIsMCwtMS42MmMtMC4zMywtMS43MSwtMS40NCwtMy40OCwtMy42MywtNS43elwiXHJcbiAgICB9LFxyXG4gICAgXCJmbGFncy51MzJuZFwiOiB7XHJcbiAgICAgICAgXCJ3XCI6IDYuNjk3LFxyXG4gICAgICAgIFwiaFwiOiAzMi4xNDUsXHJcbiAgICAgICAgXCJkXCI6IFwiTS0wLjQyLDExLjI0N2wwLC0xMS4yNWwwLjIxLDBsMC4yMSwwbDAsMC4zNmMwLjA5LDEuNjgsMC42OSwzLjI3LDIuMDcsNS40NmwwLjg3LDEuMzVjMS4wMiwxLjYyLDEuNDcsMi4zNywxLjg2LDMuMThjMC40OCwxLjAyLDAuNzgsMS45MiwwLjkzLDIuODhjMC4wNiwwLjQ4LDAuMDYsMS41LDAsMS44OWMtMC4wOSwwLjQyLC0wLjIxLDAuODcsLTAuMzYsMS4yNmwtMC4xMiwwLjNsMC4xNSwwLjM5YzAuNjksMS41NiwwLjg0LDIuODgsMC41NCw0LjM4Yy0wLjA5LDAuNDUsLTAuMjcsMS4wOCwtMC40NSwxLjQ3bC0wLjEyLDAuMjRsMC4xOCwwLjM2YzAuMzMsMC43MiwwLjU3LDEuNTYsMC42OSwyLjM0YzAuMTIsMS4wMiwtMC4wNiwyLjUyLC0wLjQyLDMuODRjLTAuMjcsMC45MywtMC43NSwyLjEzLC0wLjkzLDIuMzFjLTAuMTgsMC4xNSwtMC40NSwwLjE4LC0wLjY2LDAuMDljLTAuMTgsLTAuMDksLTAuMjcsLTAuMTgsLTAuMzMsLTAuMzNjLTAuMDksLTAuMTgsLTAuMDYsLTAuMywwLjA2LC0wLjZjMC4yMSwtMC4zNiwwLjQyLC0wLjksMC41NywtMS4zOGMwLjUxLC0xLjQxLDAuNjksLTMuMDYsMC40OCwtNC4wOGMtMC4xNSwtMC44MSwtMC41NywtMS42OCwtMS4yLC0yLjU1Yy0wLjcyLC0wLjk5LC0xLjgzLC0yLjEzLC0zLjMsLTMuMzNsLTAuNDgsLTAuNDJsLTAuMDMsMS41M2wwLDEuNTZsLTAuMjEsMGwtMC4yMSwwbDAsLTExLjI1em0xLjI2LC0zLjk2Yy0wLjI3LC0wLjMsLTAuNTQsLTAuNiwtMC42NiwtMC43MmwtMC4xOCwtMC4yMWwwLDAuNDJjMC4wNiwwLjg3LDAuMjQsMS43NCwwLjY2LDIuNjdjMC4zNiwwLjg3LDAuOTYsMS44NiwxLjkyLDMuMThjMC4yMSwwLjMzLDAuNjMsMC44NywwLjg3LDEuMjNjMC4yNywwLjM5LDAuNiwwLjg0LDAuNzUsMS4wOGwwLjI3LDAuMzlsMC4wMywtMC4xMmMwLjEyLC0wLjQ1LDAuMTUsLTEuMDUsMC4wOSwtMS41OWMtMC4yNywtMS44NiwtMS4zOCwtMy43OCwtMy43NSwtNi4zM3ptLTAuMjcsNi4wOWMtMC4yNywtMC4yMSwtMC40OCwtMC40MiwtMC41MSwtMC40NWMtMC4wNiwtMC4wMywtMC4wNiwtMC4wMywtMC4wNiwwLjIxYzAsMC45LDAuMywyLjA0LDAuODEsMy4wOWMwLjQ4LDEuMDIsMC45NiwxLjc3LDIuMzcsMy42M2MwLjYsMC43OCwxLjA1LDEuNDQsMS4yOSwxLjc3YzAuMDYsMC4xMiwwLjE1LDAuMjEsMC4xNSwwLjE4YzAuMDMsLTAuMDMsMC4xOCwtMC41NywwLjI0LC0wLjg3YzAuMDYsLTAuNDUsMC4wNiwtMS4zMiwtMC4wMywtMS43NGMtMC4wOSwtMC40OCwtMC4yNCwtMC45LC0wLjUxLC0xLjQ0Yy0wLjY2LC0xLjM1LC0xLjgzLC0yLjcsLTMuNzUsLTQuMzh6XCJcclxuICAgIH0sXHJcbiAgICBcImZsYWdzLnU2NHRoXCI6IHtcclxuICAgICAgICBcIndcIjogNi42ODIsXHJcbiAgICAgICAgXCJoXCI6IDM5LjY5NCxcclxuICAgICAgICBcImRcIjogXCJNLTAuNDIsMTVsMCwtMTVsMC4yMSwwbDAuMjEsMGwwLDAuMzZjMC4wNiwxLjIsMC4zOSwyLjM3LDEuMDIsMy42NmMwLjM5LDAuODEsMC44NCwxLjU2LDEuOCwzLjA5YzAuODEsMS4yNiwxLjA1LDEuNjgsMS4zNSwyLjIyYzAuODcsMS41LDEuMzUsMi43OSwxLjU2LDQuMDhjMC4wNiwwLjU0LDAuMDYsMS41NiwtMC4wMywyLjA0Yy0wLjA5LDAuNDgsLTAuMjEsMC45OSwtMC4zNiwxLjM1bC0wLjEyLDAuMjdsMC4xMiwwLjI3YzAuMDksMC4xNSwwLjIxLDAuNDUsMC4yNywwLjY2YzAuNjksMS44OSwwLjYzLDMuNjYsLTAuMTgsNS40NmwtMC4xOCwwLjM5bDAuMTUsMC4zM2MwLjMsMC42NiwwLjUxLDEuNDQsMC42MywyLjFjMC4wNiwwLjQ4LDAuMDYsMS4zNSwwLDEuNzFjLTAuMTUsMC41NywtMC40MiwxLjIsLTAuNzgsMS42OGwtMC4yMSwwLjI3bDAuMTgsMC4zM2MwLjU3LDEuMDUsMC45MywyLjEzLDEuMDIsMy4xOGMwLjA2LDAuNzIsMCwxLjgzLC0wLjIxLDIuNzljLTAuMTgsMS4wMiwtMC42MywyLjM0LC0xLjAyLDMuMDljLTAuMTUsMC4zMywtMC40OCwwLjQ1LC0wLjc4LDAuM2MtMC4xOCwtMC4wOSwtMC4yNywtMC4xOCwtMC4zMywtMC4zM2MtMC4wOSwtMC4xOCwtMC4wNiwtMC4zLDAuMDMsLTAuNTRjMC43NSwtMS41LDEuMjMsLTMuNDUsMS4xNywtNC44OWMtMC4wNiwtMS4wMiwtMC40MiwtMi4wMSwtMS4xNywtMy4xNWMtMC40OCwtMC43MiwtMS4wMiwtMS4zNSwtMS44OSwtMi4yMmMtMC41NywtMC41NywtMS41NiwtMS41LC0xLjkyLC0xLjc3bC0wLjEyLC0wLjA5bDAsMS42OGwwLDEuNjhsLTAuMjEsMGwtMC4yMSwwbDAsLTE1em0wLjkzLC04LjA3Yy0wLjI3LC0wLjMsLTAuNDgsLTAuNTQsLTAuNTEsLTAuNTRjMCwwLDAsMC42OSwwLjAzLDEuMDJjMC4xNSwxLjQ3LDAuNzUsMi45NCwyLjA0LDQuODNsMS4wOCwxLjUzYzAuMzksMC41NywwLjg0LDEuMiwwLjk5LDEuNDRjMC4xNSwwLjI0LDAuMywwLjQ1LDAuMywwLjQ1YzAsMCwwLjAzLC0wLjA5LDAuMDYsLTAuMjFjMC4zNiwtMS41OSwtMC4xNSwtMy4zMywtMS40NywtNS40Yy0wLjYzLC0wLjkzLC0xLjM1LC0xLjgzLC0yLjUyLC0zLjEyem0wLjA2LDYuNzJjLTAuMjQsLTAuMjEsLTAuNDgsLTAuNDIsLTAuNTEsLTAuNDVsLTAuMDYsLTAuMDZsMCwwLjMzYzAsMS4yLDAuMywyLjM0LDAuOTMsMy42YzAuNDUsMC45LDAuOTYsMS42OCwyLjI1LDMuNTFjMC4zOSwwLjU0LDAuODQsMS4xNywxLjAyLDEuNDRjMC4yMSwwLjMzLDAuMzMsMC41MSwwLjMzLDAuNDhjMC4wNiwtMC4wOSwwLjIxLC0wLjYzLDAuMywtMC45OWMwLjA2LC0wLjMzLDAuMDYsLTAuNDUsMC4wNiwtMC45NmMwLC0wLjYsLTAuMDMsLTAuODQsLTAuMTgsLTEuMzVjLTAuMywtMS4wOCwtMS4wMiwtMi4yOCwtMi4xMywtMy41N2MtMC4zOSwtMC40NSwtMS40NCwtMS40NywtMi4wMSwtMS45OHptMCw2LjcyYy0wLjI0LC0wLjIxLC0wLjQ4LC0wLjM5LC0wLjUxLC0wLjQybC0wLjA2LC0wLjA2bDAsMC4zM2MwLDEuNDEsMC40NSwyLjgyLDEuMzgsNC4zNWMwLjQyLDAuNzIsMC43MiwxLjE0LDEuODYsMi43M2MwLjM2LDAuNDUsMC43NSwwLjk5LDAuODcsMS4yYzAuMTUsMC4yMSwwLjMsMC4zNiwwLjMsMC4zNmMwLjA2LDAsMC4zLC0wLjQ4LDAuMzksLTAuNzVjMC4wOSwtMC4zNiwwLjEyLC0wLjYzLDAuMTIsLTEuMDVjLTAuMDYsLTEuMDUsLTAuNDUsLTIuMDQsLTEuMiwtMy4xOGMtMC41NywtMC44NywtMS4xMSwtMS41MywtMi4wNywtMi40OWMtMC4zNiwtMC4zMywtMC44NCwtMC43OCwtMS4wOCwtMS4wMnpcIlxyXG4gICAgfSxcclxuICAgIFwiZmxhZ3MuZDh0aFwiOiB7XHJcbiAgICAgICAgXCJ3XCI6IDguNDkyLFxyXG4gICAgICAgIFwiaFwiOiAyMS42OTEsXHJcbiAgICAgICAgXCJkXCI6IFwiTTUuNjcsLTIxLjYzYzAuMjQsLTAuMTIsMC41NCwtMC4wNiwwLjY5LDAuMTVjMC4wNiwwLjA2LDAuMjEsMC4zNiwwLjM5LDAuNjZjMC44NCwxLjc3LDEuMjYsMy4zNiwxLjMyLDUuMWMwLjAzLDEuMjksLTAuMjEsMi4zNywtMC44MSwzLjYzYy0wLjYsMS4yMywtMS4yNiwyLjEzLC0zLjIxLDQuMzhjLTEuMzUsMS41MywtMS44NiwyLjE5LC0yLjQsMi45N2MtMC42MywwLjkzLC0xLjExLDEuOTIsLTEuMzgsMi43OWMtMC4xNSwwLjU0LC0wLjI3LDEuMzUsLTAuMjcsMS44bDAsMC4xNWwtMC4yMSwwbC0wLjIxLDBsMCwtMy43NWwwLC0zLjc1bDAuMjEsMGwwLjIxLDBsMC40OCwtMC4zYzEuODMsLTEuMTEsMy4xMiwtMi4xLDQuMTcsLTMuMTJjMC43OCwtMC44MSwxLjMyLC0xLjUzLDEuNzEsLTIuMzFjMC40NSwtMC45MywwLjYsLTEuNzQsMC41MSwtMi44OGMtMC4xMiwtMS41NiwtMC42MywtMy4xOCwtMS40NywtNC42OGMtMC4xMiwtMC4yMSwtMC4xNSwtMC4zMywtMC4wNiwtMC41MWMwLjA2LC0wLjE1LDAuMTUsLTAuMjQsMC4zMywtMC4zM3pcIlxyXG4gICAgfSxcclxuICAgIFwiZmxhZ3MudWdyYWNlXCI6IHtcclxuICAgICAgICBcIndcIjogMTIuMDE5LFxyXG4gICAgICAgIFwiaFwiOiA5Ljk1NCxcclxuICAgICAgICBcImRcIjogXCJNNi4wMyw2LjkzYzAuMTUsLTAuMDksMC4zMywtMC4wNiwwLjUxLDBjMC4xNSwwLjA5LDAuMjEsMC4xNSwwLjMsMC4zM2MwLjA5LDAuMTgsMC4wNiwwLjM5LC0wLjAzLDAuNTRjLTAuMDYsMC4xNSwtMTAuODksOC44OCwtMTEuMDcsOC45N2MtMC4xNSwwLjA5LC0wLjMzLDAuMDYsLTAuNDgsMGMtMC4xOCwtMC4wOSwtMC4yNCwtMC4xNSwtMC4zMywtMC4zM2MtMC4wOSwtMC4xOCwtMC4wNiwtMC4zOSwwLjAzLC0wLjU0YzAuMDYsLTAuMTUsMTAuODksLTguODgsMTEuMDcsLTguOTd6XCJcclxuICAgIH0sXHJcbiAgICBcImZsYWdzLmRncmFjZVwiOiB7XHJcbiAgICAgICAgXCJ3XCI6IDE1LjEyLFxyXG4gICAgICAgIFwiaFwiOiA5LjIxMixcclxuICAgICAgICBcImRcIjogXCJNLTYuMDYsLTE1LjkzYzAuMTgsLTAuMDksMC4zMywtMC4xMiwwLjQ4LC0wLjA2YzAuMTgsMC4wOSwxNC4wMSw4LjA0LDE0LjEsOC4xYzAuMTIsMC4xMiwwLjE4LDAuMzMsMC4xOCwwLjUxYy0wLjAzLDAuMjEsLTAuMTUsMC4zOSwtMC4zNiwwLjQ4Yy0wLjE4LDAuMDksLTAuMzMsMC4xMiwtMC40OCwwLjA2Yy0wLjE4LC0wLjA5LC0xNC4wMSwtOC4wNCwtMTQuMSwtOC4xYy0wLjEyLC0wLjEyLC0wLjE4LC0wLjMzLC0wLjE4LC0wLjUxYzAuMDMsLTAuMjEsMC4xNSwtMC4zOSwwLjM2LC0wLjQ4elwiXHJcbiAgICB9LFxyXG4gICAgXCJmbGFncy5kMTZ0aFwiOiB7XHJcbiAgICAgICAgXCJ3XCI6IDguNDc1LFxyXG4gICAgICAgIFwiaFwiOiAyMi41OTEsXHJcbiAgICAgICAgXCJkXCI6IFwiTTYuODQsLTIyLjUzYzAuMjcsLTAuMTIsMC41NywtMC4wNiwwLjcyLDAuMTVjMC4xNSwwLjE1LDAuMzMsMC44NywwLjQ1LDEuNTZjMC4wNiwwLjMzLDAuMDYsMS4zNSwwLDEuNjVjLTAuMDYsMC4zMywtMC4xNSwwLjc4LC0wLjI3LDEuMTFjLTAuMTIsMC4zMywtMC40NSwwLjk2LC0wLjY2LDEuMzJsLTAuMTgsMC4yN2wwLjA5LDAuMThjMC40OCwxLjAyLDAuNzIsMi4yNSwwLjY5LDMuM2MtMC4wNiwxLjIzLC0wLjQyLDIuMjgsLTEuMjYsMy40NWMtMC41NywwLjg3LC0wLjk5LDEuMzIsLTMsMy4zOWMtMS41NiwxLjU2LC0yLjIyLDIuNCwtMi43NiwzLjQ1Yy0wLjQyLDAuODQsLTAuNjYsMS44LC0wLjY2LDIuNTVsMCwwLjE1bC0wLjIxLDBsLTAuMjEsMGwwLC03LjVsMCwtNy41bDAuMjEsMGwwLjIxLDBsMCwxLjE0bDAsMS4xMWwwLjI3LC0wLjE1YzEuMTEsLTAuNTcsMS43NywtMC45OSwyLjUyLC0xLjQ3YzIuMzcsLTEuNTYsMy42OSwtMy4xNSw0LjA1LC00LjgzYzAuMDMsLTAuMTgsMC4wMywtMC4zOSwwLjAzLC0wLjc4YzAsLTAuNiwtMC4wMywtMC45MywtMC4yNCwtMS41Yy0wLjA2LC0wLjE4LC0wLjEyLC0wLjM5LC0wLjE1LC0wLjQ1Yy0wLjAzLC0wLjI0LDAuMTIsLTAuNDgsMC4zNiwtMC42em0tMC42Myw3LjVjLTAuMDYsLTAuMTgsLTAuMTUsLTAuMzYsLTAuMTUsLTAuMzZjLTAuMDMsMCwtMC4wMywwLjAzLC0wLjA2LDAuMDZjLTAuMDYsMC4xMiwtMC45NiwxLjAyLC0xLjk1LDEuOThjLTAuNjMsMC41NywtMS4yNiwxLjE3LC0xLjQ0LDEuMzVjLTEuNTMsMS42MiwtMi4yOCwyLjg1LC0yLjU1LDQuMzJjLTAuMDMsMC4xOCwtMC4wMywwLjU0LC0wLjA2LDAuOTlsMCwwLjY5bDAuMTgsLTAuMDljMC45MywtMC41NCwyLjEsLTEuMjksMi44MiwtMS44M2MwLjY5LC0wLjUxLDEuMDIsLTAuODEsMS41MywtMS4yOWMxLjg2LC0xLjg5LDIuMzcsLTMuNjYsMS42OCwtNS44MnpcIlxyXG4gICAgfSxcclxuICAgIFwiZmxhZ3MuZDMybmRcIjoge1xyXG4gICAgICAgIFwid1wiOiA4LjQ3NSxcclxuICAgICAgICBcImhcIjogMjkuMTkxLFxyXG4gICAgICAgIFwiZFwiOiBcIk02Ljc5NCwtMjkuMTNjMC4yNywtMC4xMiwwLjU3LC0wLjA2LDAuNzIsMC4xNWMwLjEyLDAuMTIsMC4yNywwLjYzLDAuMzYsMS4xMWMwLjMzLDEuNTksMC4wNiwzLjA2LC0wLjgxLDQuNDdsLTAuMTgsMC4yN2wwLjA5LDAuMTVjMC4xMiwwLjI0LDAuMzMsMC42OSwwLjQ1LDEuMDVjMC42MywxLjgzLDAuNDUsMy41NywtMC41Nyw1LjIybC0wLjE4LDAuM2wwLjE1LDAuMjdjMC40MiwwLjg3LDAuNiwxLjcxLDAuNTcsMi42MWMtMC4wNiwxLjI5LC0wLjQ4LDIuNDYsLTEuMzUsMy43OGMtMC41NCwwLjgxLC0wLjkzLDEuMjksLTIuNDYsM2MtMC41MSwwLjU0LC0xLjA1LDEuMTcsLTEuMjYsMS40MWMtMS41NiwxLjg2LC0yLjI1LDMuMzYsLTIuMzcsNS4wMWwwLDAuMzNsLTAuMjEsMGwtMC4yMSwwbDAsLTExLjI1bDAsLTExLjI1bDAuMjEsMGwwLjIxLDBsMCwxLjM1bDAuMDMsMS4zNWwwLjc4LC0wLjM5YzEuMzgsLTAuNjksMi4zNCwtMS4yNiwzLjI0LC0xLjkyYzEuMzgsLTEuMDIsMi4yOCwtMi4xMywyLjY0LC0zLjIxYzAuMTUsLTAuNDgsMC4xOCwtMC43MiwwLjE4LC0xLjI5YzAsLTAuNTcsLTAuMDYsLTAuOSwtMC4yNCwtMS40N2MtMC4wNiwtMC4xOCwtMC4xMiwtMC4zOSwtMC4xNSwtMC40NWMtMC4wMywtMC4yNCwwLjEyLC0wLjQ4LDAuMzYsLTAuNnptLTAuNjMsNy4yYy0wLjA5LC0wLjE4LC0wLjEyLC0wLjIxLC0wLjEyLC0wLjE1Yy0wLjAzLDAuMDksLTEuMDIsMS4wOCwtMi4wNCwyLjA0Yy0xLjE3LDEuMDgsLTEuNjUsMS41NiwtMi4wNywyLjA0Yy0wLjg0LDAuOTYsLTEuMzgsMS44NiwtMS42OCwyLjc2Yy0wLjIxLDAuNTcsLTAuMjcsMC45OSwtMC4zLDEuNjVsMCwwLjU0bDAuNjYsLTAuMzNjMy41NywtMS44Niw1LjQ5LC0zLjY5LDUuOTQsLTUuN2MwLjA2LC0wLjM5LDAuMDYsLTEuMiwtMC4wMywtMS42NWMtMC4wNiwtMC4zOSwtMC4yNCwtMC45LC0wLjM2LC0xLjJ6bS0wLjA2LDcuMmMtMC4wNiwtMC4xNSwtMC4xMiwtMC4zMywtMC4xNSwtMC40NWwtMC4wNiwtMC4xOGwtMC4xOCwwLjIxbC0xLjgzLDEuODNjLTAuODcsMC45LC0xLjc3LDEuOCwtMS45NSwyLjAxYy0xLjA4LDEuMjksLTEuNjIsMi4zMSwtMS44OSwzLjUxYy0wLjA2LDAuMywtMC4wNiwwLjUxLC0wLjA5LDAuOTNsMCwwLjU3bDAuMDksLTAuMDZjMC43NSwtMC40NSwxLjg5LC0xLjI2LDIuNTIsLTEuNzRjMC44MSwtMC42NiwxLjc0LC0xLjUzLDIuMjIsLTIuMTZjMS4yNiwtMS41MywxLjY4LC0zLjA2LDEuMzIsLTQuNDd6XCJcclxuICAgIH0sXHJcbiAgICBcImZsYWdzLmQ2NHRoXCI6IHtcclxuICAgICAgICBcIndcIjogOC40ODUsXHJcbiAgICAgICAgXCJoXCI6IDMyLjkzMixcclxuICAgICAgICBcImRcIjogXCJNNy4wOCwtMzIuODhjMC4zLC0wLjEyLDAuNjYsLTAuMDMsMC43OCwwLjI0YzAuMTgsMC4zMywwLjI3LDIuMSwwLjE1LDIuNjRjLTAuMDksMC4zOSwtMC4yMSwwLjc4LC0wLjM5LDEuMDhsLTAuMTUsMC4zbDAuMDksMC4yN2MwLjAzLDAuMTIsMC4wOSwwLjQ1LDAuMTIsMC42OWMwLjI3LDEuNDQsMC4xOCwyLjU1LC0wLjMsMy42bC0wLjEyLDAuMzNsMC4wNiwwLjQyYzAuMjcsMS4zNSwwLjMzLDIuODIsMC4yMSwzLjYzYy0wLjEyLDAuNiwtMC4zLDEuMjMsLTAuNTcsMS44bC0wLjE1LDAuMjdsMC4wMywwLjQyYzAuMDYsMS4wMiwwLjA2LDIuNywwLjAzLDMuMDZjLTAuMTUsMS40NywtMC42NiwyLjc2LC0xLjc0LDQuNDFjLTAuNDUsMC42OSwtMC43NSwxLjExLC0xLjc0LDIuMzdjLTEuMDUsMS4zOCwtMS41LDEuOTgsLTEuOTUsMi43M2MtMC45MywxLjUsLTEuMzgsMi44MiwtMS40NCw0LjJsMCwwLjQybC0wLjIxLDBsLTAuMjEsMGwwLC0xNWwwLC0xNWwwLjIxLDBsMC4yMSwwbDAsMS44NmwwLDEuODljMCwwLDAuMjEsLTAuMDMsMC40NSwtMC4wOWMyLjIyLC0wLjM5LDQuMDgsLTEuMTEsNS4xOSwtMi4wMWMwLjYzLC0wLjU0LDEuMDIsLTEuMTQsMS4yLC0xLjhjMC4wNiwtMC4zLDAuMDYsLTEuMTQsLTAuMDMsLTEuNjVjLTAuMDMsLTAuMTgsLTAuMDYsLTAuMzksLTAuMDksLTAuNDhjLTAuMDMsLTAuMjQsMC4xMiwtMC40OCwwLjM2LC0wLjZ6bS0wLjQ1LDYuMTVjLTAuMDMsLTAuMTgsLTAuMDYsLTAuNDIsLTAuMDYsLTAuNTRsLTAuMDMsLTAuMThsLTAuMzMsMC4zYy0wLjQyLDAuMzYsLTAuODcsMC43MiwtMS42OCwxLjI5Yy0xLjk4LDEuMzgsLTIuMjUsMS41OSwtMi44NSwyLjE2Yy0wLjc1LDAuNjksLTEuMjMsMS40NCwtMS40NywyLjE5Yy0wLjE1LDAuNDUsLTAuMTgsMC42MywtMC4yMSwxLjM1bDAsMC42NmwwLjM5LC0wLjE4YzEuODMsLTAuOSwzLjQ1LC0xLjk1LDQuNDcsLTIuOTFjMC45MywtMC45LDEuNTMsLTEuODMsMS43NCwtMi44MmMwLjA2LC0wLjMzLDAuMDYsLTAuODcsMC4wMywtMS4zMnptLTAuMjcsNC44NmMtMC4wMywtMC4yMSwtMC4wNiwtMC4zNiwtMC4wNiwtMC4zNmMwLC0wLjAzLC0wLjEyLDAuMDksLTAuMjQsMC4yNGMtMC4zOSwwLjQ4LC0wLjk5LDEuMDgsLTIuMTYsMi4xOWMtMS40NywxLjM4LC0xLjkyLDEuODMsLTIuNDYsMi40OWMtMC42NiwwLjg3LC0xLjA4LDEuNzQsLTEuMjksMi41OGMtMC4wOSwwLjQyLC0wLjE1LDAuODcsLTAuMTUsMS40NGwwLDAuNTRsMC40OCwtMC4zM2MxLjUsLTEuMDIsMi41OCwtMS44OSwzLjUxLC0yLjgyYzEuNDcsLTEuNDcsMi4yNSwtMi44NSwyLjQsLTQuMjZjMC4wMywtMC4zOSwwLjAzLC0xLjE3LC0wLjAzLC0xLjcxem0tMC42Niw3LjY4YzAuMDMsLTAuMTUsMC4wMywtMC42LDAuMDMsLTAuOTlsMCwtMC43MmwtMC4yNywwLjMzbC0xLjc0LDEuOThjLTEuNzcsMS45MiwtMi40MywyLjc2LC0yLjk3LDMuOWMtMC41MSwxLjAyLC0wLjcyLDEuNzcsLTAuNzUsMi45MWMwLDAuNjMsMCwwLjYzLDAuMDYsMC42YzAuMDMsLTAuMDMsMC4zLC0wLjI3LDAuNjMsLTAuNTRjMC42NiwtMC42LDEuODYsLTEuOCwyLjMxLC0yLjMxYzEuNjUsLTEuODksMi41MiwtMy41NCwyLjcsLTUuMTZ6XCJcclxuICAgIH0sXHJcbiAgICBcImNsZWZzLkNcIjoge1xyXG4gICAgICAgIFwid1wiOiAyMC4zMSxcclxuICAgICAgICBcImhcIjogMjkuOTcsXHJcbiAgICAgICAgXCJkXCI6IFwiTTAuMDYsLTE0Ljk0bDAuMDksLTAuMDZsMS45MiwwbDEuOTIsMGwwLjA5LDAuMDZsMC4wNiwwLjA5bDAsMTQuODVsMCwxNC44MmwtMC4wNiwwLjA5bC0wLjA5LDAuMDZsLTEuOTIsMGwtMS45MiwwbC0wLjA5LC0wLjA2bC0wLjA2LC0wLjA5bDAsLTE0LjgybDAsLTE0Ljg1em01LjM3LDBjMC4wOSwtMC4wNiwwLjA5LC0wLjA2LDAuNTcsLTAuMDZjMC40NSwwLDAuNDUsMCwwLjU0LDAuMDZsMC4wNiwwLjA5bDAsNy4xNGwwLDcuMTFsMC4wOSwtMC4wNmMwLjE4LC0wLjE4LDAuNzIsLTAuODQsMC45NiwtMS4yYzAuMywtMC40NSwwLjY2LC0xLjE3LDAuODQsLTEuNjVjMC4zNiwtMC45LDAuNTcsLTEuODMsMC42LC0yLjc5YzAuMDMsLTAuNDgsMC4wMywtMC41NCwwLjA5LC0wLjYzYzAuMTIsLTAuMTgsMC4zNiwtMC4yMSwwLjU0LC0wLjEyYzAuMTgsMC4wOSwwLjIxLDAuMTUsMC4yNCwwLjY2YzAuMDYsMC44NywwLjIxLDEuNTYsMC41NywyLjIyYzAuNTEsMS4wMiwxLjI2LDEuNjgsMi4yMiwxLjkyYzAuMjEsMC4wNiwwLjMzLDAuMDYsMC43OCwwLjA2YzAuNDUsMCwwLjU3LDAsMC44NCwtMC4wNmMwLjQ1LC0wLjEyLDAuODEsLTAuMzMsMS4wOCwtMC42YzAuNTcsLTAuNTcsMC44NywtMS40MSwwLjk5LC0yLjg4YzAuMDYsLTAuNTQsMC4wNiwtMywwLC0zLjU3Yy0wLjIxLC0yLjU4LC0wLjg0LC0zLjg3LC0yLjE2LC00LjVjLTAuNDgsLTAuMjEsLTEuMTcsLTAuMzYsLTEuNzcsLTAuMzZjLTAuNjksMCwtMS4yOSwwLjI3LC0xLjUsMC43MmMtMC4wNiwwLjE1LC0wLjA2LDAuMjEsLTAuMDYsMC40MmMwLDAuMjQsMCwwLjMsMC4wNiwwLjQ1YzAuMTIsMC4yNCwwLjI0LDAuMzksMC42MywwLjY2YzAuNDIsMC4zLDAuNTcsMC40OCwwLjY5LDAuNzJjMC4wNiwwLjE1LDAuMDYsMC4yMSwwLjA2LDAuNDhjMCwwLjM5LC0wLjAzLDAuNjMsLTAuMjEsMC45NmMtMC4zLDAuNiwtMC44NywxLjA4LC0xLjUsMS4yNmMtMC4yNywwLjA2LC0wLjg3LDAuMDYsLTEuMTQsMGMtMC43OCwtMC4yNCwtMS40NCwtMC44NywtMS42NSwtMS42OGMtMC4xMiwtMC40MiwtMC4wOSwtMS4xNywwLjA5LC0xLjcxYzAuNTEsLTEuNjUsMS45OCwtMi44MiwzLjgxLC0zLjA5YzAuODQsLTAuMDksMi40NiwwLjAzLDMuNTEsMC4yN2MyLjIyLDAuNTcsMy42OSwxLjgsNC40NCwzLjc1YzAuMzYsMC45MywwLjU3LDIuMTMsMC41NywzLjM2YzAsMS40NCwtMC40OCwyLjczLC0xLjM4LDMuODFjLTEuMjYsMS41LC0zLjI3LDIuNDMsLTUuMjgsMi40M2MtMC40OCwwLC0wLjUxLDAsLTAuNzUsLTAuMDljLTAuMTUsLTAuMDMsLTAuNDgsLTAuMjEsLTAuNzgsLTAuMzZjLTAuNjksLTAuMzYsLTAuODcsLTAuNDIsLTEuMjYsLTAuNDJjLTAuMjcsMCwtMC4zLDAsLTAuNTEsMC4wOWMtMC41NywwLjMsLTAuODEsMC45LC0wLjgxLDIuMWMwLDEuMjMsMC4yNCwxLjgzLDAuODEsMi4xM2MwLjIxLDAuMDksMC4yNCwwLjA5LDAuNTEsMC4wOWMwLjM5LDAsMC41NywtMC4wNiwxLjI2LC0wLjQyYzAuMywtMC4xNSwwLjYzLC0wLjMzLDAuNzgsLTAuMzZjMC4yNCwtMC4wOSwwLjI3LC0wLjA5LDAuNzUsLTAuMDljMi4wMSwwLDQuMDIsMC45Myw1LjI4LDIuNGMwLjksMS4xMSwxLjM4LDIuNCwxLjM4LDMuODRjMCwxLjUsLTAuMywyLjg4LC0wLjg0LDMuOTZjLTAuNzgsMS41OSwtMi4xOSwyLjY0LC00LjE3LDMuMTVjLTEuMDUsMC4yNCwtMi42NywwLjM2LC0zLjUxLDAuMjdjLTEuODMsLTAuMjcsLTMuMywtMS40NCwtMy44MSwtMy4wOWMtMC4xOCwtMC41NCwtMC4yMSwtMS4yOSwtMC4wOSwtMS43NGMwLjE1LC0wLjYsMC42MywtMS4yLDEuMjMsLTEuNDdjMC4zNiwtMC4xOCwwLjU3LC0wLjIxLDAuOTksLTAuMjFjMC40MiwwLDAuNjMsMC4wMywxLjAyLDAuMjFjMC40MiwwLjIxLDAuODQsMC42MywxLjA1LDEuMDVjMC4xOCwwLjM2LDAuMjEsMC42LDAuMjEsMC45NmMwLDAuMywwLDAuMzYsLTAuMDYsMC41MWMtMC4xMiwwLjI0LC0wLjI3LDAuNDIsLTAuNjksMC43MmMtMC41NywwLjQyLC0wLjY5LDAuNjMsLTAuNjksMS4wOGMwLDAuMjQsMCwwLjMsMC4wNiwwLjQ1YzAuMTIsMC4yMSwwLjMsMC4zOSwwLjU3LDAuNTRjMC40MiwwLjE4LDAuODcsMC4yMSwxLjUzLDAuMTVjMS4wOCwtMC4xNSwxLjgsLTAuNTcsMi4zNCwtMS4zMmMwLjU0LC0wLjc1LDAuODQsLTEuODMsMC45OSwtMy41MWMwLjA2LC0wLjU3LDAuMDYsLTMuMDMsMCwtMy41N2MtMC4xMiwtMS40NywtMC40MiwtMi4zMSwtMC45OSwtMi44OGMtMC4yNywtMC4yNywtMC42MywtMC40OCwtMS4wOCwtMC42Yy0wLjI3LC0wLjA2LC0wLjM5LC0wLjA2LC0wLjg0LC0wLjA2Yy0wLjQ1LDAsLTAuNTcsMCwtMC43OCwwLjA2Yy0xLjE0LDAuMjcsLTIuMDEsMS4xNywtMi40NiwyLjQ5Yy0wLjIxLDAuNTcsLTAuMywwLjk5LC0wLjMzLDEuNjVjLTAuMDMsMC41MSwtMC4wNiwwLjU3LC0wLjI0LDAuNjZjLTAuMTIsMC4wNiwtMC4yNywwLjA2LC0wLjM5LDBjLTAuMjEsLTAuMDksLTAuMjEsLTAuMTUsLTAuMjQsLTAuNzVjLTAuMDksLTEuOTIsLTAuNzgsLTMuNzIsLTIuMDEsLTUuMTljLTAuMTgsLTAuMjEsLTAuMzYsLTAuNDIsLTAuMzksLTAuNDVsLTAuMDksLTAuMDZsMCw3LjExbDAsNy4xNGwtMC4wNiwwLjA5Yy0wLjA5LDAuMDYsLTAuMDksMC4wNiwtMC41NCwwLjA2Yy0wLjQ4LDAsLTAuNDgsMCwtMC41NywtMC4wNmwtMC4wNiwtMC4wOWwwLC0xNC44MmwwLC0xNC44NXpcIlxyXG4gICAgfSxcclxuICAgIFwiY2xlZnMuRlwiOiB7XHJcbiAgICAgICAgXCJ3XCI6IDIwLjE1MyxcclxuICAgICAgICBcImhcIjogMjMuMTQyLFxyXG4gICAgICAgIFwiZFwiOiBcIk02LjMsLTcuOGMwLjM2LC0wLjAzLDEuNjUsMCwyLjEzLDAuMDNjMy42LDAuNDIsNi4wMywyLjEsNi45Myw0Ljg2YzAuMjcsMC44NCwwLjM2LDEuNSwwLjM2LDIuNThjMCwwLjksLTAuMDMsMS4zNSwtMC4xOCwyLjE2Yy0wLjc4LDMuNzgsLTMuNTQsNy4wOCwtOC4zNyw5Ljk2Yy0xLjc0LDEuMDUsLTMuODcsMi4xMywtNi4xOCwzLjEyYy0wLjM5LDAuMTgsLTAuNzUsMC4zMywtMC44MSwwLjM2Yy0wLjA2LDAuMDMsLTAuMTUsMC4wNiwtMC4xOCwwLjA2Yy0wLjE1LDAsLTAuMzMsLTAuMTgsLTAuMzMsLTAuMzNjMCwtMC4xNSwwLjA2LC0wLjIxLDAuNTEsLTAuNDhjMywtMS43Nyw1LjEzLC0zLjIxLDYuODQsLTQuNzRjMC41MSwtMC40NSwxLjU5LC0xLjUsMS45NSwtMS45NWMxLjg5LC0yLjE5LDIuODgsLTQuMzIsMy4xNSwtNi43OGMwLjA2LC0wLjQyLDAuMDYsLTEuNzcsMCwtMi4xOWMtMC4yNCwtMi4wMSwtMC45MywtMy42MywtMi4wNCwtNC43MWMtMC42MywtMC42MywtMS4yOSwtMS4wMiwtMi4wNywtMS4yYy0xLjYyLC0wLjM5LC0zLjM2LDAuMTUsLTQuNTYsMS40NGMtMC41NCwwLjYsLTEuMDUsMS40NywtMS4zMiwyLjIybC0wLjA5LDAuMjFsMC4yNCwtMC4xMmMwLjM5LC0wLjIxLDAuNjMsLTAuMjQsMS4xMSwtMC4yNGMwLjMsMCwwLjQ1LDAsMC42NiwwLjA2YzEuOTIsMC40OCwyLjg1LDIuNTUsMS45NSw0LjM4Yy0wLjQ1LDAuOTksLTEuNDEsMS42MiwtMi40NiwxLjcxYy0xLjQ3LDAuMDksLTIuOTEsLTAuODcsLTMuMzksLTIuMjVjLTAuMTgsLTAuNTcsLTAuMjEsLTEuMzIsLTAuMDMsLTIuMjhjMC4zOSwtMi4yNSwxLjgzLC00LjIsMy44MSwtNS4xOWMwLjY5LC0wLjM2LDEuNTksLTAuNiwyLjM3LC0wLjY5em0xMS41OCwyLjUyYzAuODQsLTAuMjEsMS43MSwwLjMsMS44OSwxLjE0YzAuMywxLjE3LC0wLjcyLDIuMTksLTEuODksMS44OWMtMC45OSwtMC4yMSwtMS41LC0xLjMyLC0xLjAyLC0yLjI1YzAuMTgsLTAuMzksMC42LC0wLjY5LDEuMDIsLTAuNzh6bTAsNy41YzAuODQsLTAuMjEsMS43MSwwLjMsMS44OSwxLjE0YzAuMjEsMC44NywtMC4zLDEuNzEsLTEuMTQsMS44OWMtMC44NywwLjIxLC0xLjcxLC0wLjMsLTEuODksLTEuMTRjLTAuMjEsLTAuODQsMC4zLC0xLjcxLDEuMTQsLTEuODl6XCJcclxuICAgIH0sXHJcbiAgICBcImNsZWZzLkdcIjoge1xyXG4gICAgICAgIFwid1wiOiAxOS4wNTEsXHJcbiAgICAgICAgXCJoXCI6IDU3LjA1NyxcclxuICAgICAgICBcImRcIjogXCJNOS42OSwtMzcuNDFjMC4wOSwtMC4wOSwwLjI0LC0wLjA2LDAuMzYsMGMwLjEyLDAuMDksMC41NywwLjYsMC45NiwxLjExYzEuNzcsMi4zNCwzLjIxLDUuODUsMy41Nyw4LjczYzAuMjEsMS41NiwwLjAzLDMuMjcsLTAuNDUsNC44NmMtMC42OSwyLjMxLC0xLjkyLDQuNDcsLTQuMjMsNy40NGMtMC4zLDAuMzksLTAuNTcsMC43MiwtMC42LDAuNzVjLTAuMDMsMC4wNiwwLDAuMTUsMC4xOCwwLjc4YzAuNTQsMS42OCwxLjM4LDQuNDQsMS42OCw1LjQ5bDAuMDksMC40MmwwLjM5LDBjMS40NywwLjA5LDIuNzYsMC41MSwzLjk2LDEuMjljMS44MywxLjIzLDMuMDYsMy4yMSwzLjM5LDUuNTJjMC4wOSwwLjQ1LDAuMTIsMS4yOSwwLjA2LDEuNzRjLTAuMDksMS4wMiwtMC4zMywxLjgzLC0wLjc1LDIuNzNjLTAuODQsMS43MSwtMi4yOCwzLjA2LC00LjAyLDMuNzJsLTAuMzMsMC4xMmwwLjAzLDEuMjZjMCwxLjc0LC0wLjA2LDMuNjMsLTAuMjEsNC42MmMtMC40NSwzLjA2LC0yLjE5LDUuNDksLTQuNDcsNi4yMWMtMC41NywwLjE4LC0wLjksMC4yMSwtMS41OSwwLjIxYy0wLjY5LDAsLTEuMDIsLTAuMDMsLTEuNjUsLTAuMjFjLTEuMTQsLTAuMjcsLTIuMTMsLTAuODQsLTIuOTQsLTEuNjVjLTAuOTksLTAuOTksLTEuNTYsLTIuMTYsLTEuNzEsLTMuNTRjLTAuMDksLTAuODEsMC4wNiwtMS41MywwLjQ1LC0yLjEzYzAuNjMsLTAuOTksMS44MywtMS41NiwzLC0xLjUzYzEuNSwwLjA5LDIuNjQsMS4zMiwyLjczLDIuOTRjMC4wNiwxLjQ3LC0wLjkzLDIuNywtMi4zNywyLjk3Yy0wLjQ1LDAuMDYsLTAuODQsMC4wMywtMS4yOSwtMC4wOWwtMC4yMSwtMC4wOWwwLjA5LDAuMTJjMC4zOSwwLjU0LDAuNzgsMC45MywxLjMyLDEuMjZjMS4zNSwwLjg3LDMuMDYsMS4wMiw0LjM1LDAuMzZjMS40NCwtMC43MiwyLjUyLC0yLjI4LDIuOTcsLTQuMzVjMC4xNSwtMC42NiwwLjI0LC0xLjUsMC4zLC0zLjAzYzAuMDMsLTAuODQsMC4wMywtMi45NCwwLC0zYy0wLjAzLDAsLTAuMTgsMCwtMC4zNiwwLjAzYy0wLjY2LDAuMTIsLTAuOTksMC4xMiwtMS44MywwLjEyYy0xLjA1LDAsLTEuNzEsLTAuMDYsLTIuNjEsLTAuM2MtNC4wMiwtMC45OSwtNy4xMSwtNC4zNSwtNy44LC04LjQ2Yy0wLjEyLC0wLjY2LC0wLjEyLC0wLjk5LC0wLjEyLC0xLjgzYzAsLTAuODQsMCwtMS4xNCwwLjE1LC0xLjkyYzAuMzYsLTIuMjgsMS40MSwtNC42MiwzLjMsLTcuMjlsMi43OSwtMy42YzAuNTQsLTAuNjYsMC45NiwtMS4yLDAuOTYsLTEuMjNjMCwtMC4wMywtMC4wOSwtMC4zMywtMC4xOCwtMC42OWMtMC45NiwtMy4yMSwtMS40MSwtNS4yOCwtMS41OSwtNy42OGMtMC4xMiwtMS4zOCwtMC4xNSwtMy4wOSwtMC4wNiwtMy45NmMwLjMzLC0yLjY3LDEuMzgsLTUuMDcsMy4xMiwtNy4wOGMwLjM2LC0wLjQyLDAuOTksLTEuMDUsMS4xNywtMS4xNHptMi4wMSw0LjcxYy0wLjE1LC0wLjMsLTAuMywtMC41NCwtMC4zLC0wLjU0Yy0wLjAzLDAsLTAuMTgsMC4wOSwtMC4zLDAuMjFjLTIuNCwxLjc0LC0zLjg3LDQuMiwtNC4yNiw3LjExYy0wLjA2LDAuNTQsLTAuMDYsMS40MSwtMC4wMywxLjg5YzAuMDksMS4yOSwwLjQ4LDMuMTIsMS4wOCw1LjIyYzAuMTUsMC40MiwwLjI0LDAuNzgsMC4yNCwwLjgxYzAsMC4wMywwLjg0LC0xLjExLDEuMjMsLTEuNjhjMS44OSwtMi43MywyLjg4LC01LjA3LDMuMTUsLTcuNTNjMC4wOSwtMC41NywwLjEyLC0xLjc0LDAuMDYsLTIuMzdjLTAuMDksLTEuMjMsLTAuMjcsLTEuOTIsLTAuODcsLTMuMTJ6bS0yLjk0LDIwLjdjLTAuMjEsLTAuNzIsLTAuMzksLTEuMzIsLTAuNDIsLTEuMzJjMCwwLC0xLjIsMS40NywtMS44NiwyLjM3Yy0yLjc5LDMuNjMsLTQuMDIsNi4zLC00LjM1LDkuM2MtMC4wMywwLjIxLC0wLjAzLDAuNjksLTAuMDMsMS4wOGMwLDAuNjksMCwwLjc1LDAuMDYsMS4xMWMwLjEyLDAuNTQsMC4yNywwLjk5LDAuNTEsMS40N2MwLjY5LDEuMzgsMS44MywyLjU1LDMuNDIsMy40MmMwLjk2LDAuNTQsMi4wNywwLjksMy4yMSwxLjA4YzAuNzgsMC4xMiwyLjA0LDAuMTIsMi45NCwtMC4wM2MwLjUxLC0wLjA2LDAuNDUsLTAuMDMsMC40MiwtMC4zYy0wLjI0LC0zLjMzLC0wLjcyLC02LjMzLC0xLjYyLC0xMC4wOGMtMC4wOSwtMC4zOSwtMC4xOCwtMC43NSwtMC4xOCwtMC43OGMtMC4wMywtMC4wMywtMC40MiwwLC0wLjgxLDAuMDljLTAuOSwwLjE4LC0xLjY1LDAuNTcsLTIuMjIsMS4xNGMtMC43MiwwLjcyLC0xLjA4LDEuNjUsLTEuMDUsMi42NGMwLjA2LDAuOTYsMC40OCwxLjgzLDEuMjMsMi41OGMwLjM2LDAuMzYsMC43MiwwLjYzLDEuMTcsMC45YzAuMzMsMC4xOCwwLjM2LDAuMjEsMC40MiwwLjMzYzAuMTgsMC40MiwtMC4xOCwwLjksLTAuNiwwLjg3Yy0wLjE4LC0wLjAzLC0wLjg0LC0wLjM2LC0xLjI2LC0wLjYzYy0wLjc4LC0wLjUxLC0xLjM4LC0xLjExLC0xLjg2LC0xLjgzYy0xLjc3LC0yLjcsLTAuOTksLTYuNDIsMS43MSwtOC4xOWMwLjMsLTAuMjEsMC44MSwtMC40OCwxLjE3LC0wLjYzYzAuMywtMC4wOSwxLjAyLC0wLjMsMS4xNCwtMC4zYzAuMDYsMCwwLjA5LDAsMC4wOSwtMC4wM2MwLjAzLC0wLjAzLC0wLjUxLC0xLjkyLC0xLjIzLC00LjI2em0zLjc4LDcuNDFjLTAuMTgsLTAuMDMsLTAuMzYsLTAuMDYsLTAuMzksLTAuMDZjLTAuMDMsMCwwLDAuMjEsMC4xOCwxLjAyYzAuNzUsMy4xOCwxLjI2LDYuMywxLjUsOS4wOWMwLjA2LDAuNzIsMCwwLjY5LDAuNTEsMC40MmMwLjc4LC0wLjM2LDEuNDQsLTAuOTYsMS45OCwtMS43N2MxLjA4LC0xLjYyLDEuMiwtMy42OSwwLjMsLTUuNTVjLTAuODEsLTEuNjIsLTIuMzEsLTIuNzksLTQuMDgsLTMuMTV6XCJcclxuICAgIH0sXHJcbiAgICBcImNsZWZzLnBlcmNcIjoge1xyXG4gICAgICAgIFwid1wiOiA5Ljk5LFxyXG4gICAgICAgIFwiaFwiOiAxNC45NyxcclxuICAgICAgICBcImRcIjogXCJNNS4wNywtNy40NGwwLjA5LC0wLjA2bDEuNTMsMGwxLjUzLDBsMC4wOSwwLjA2bDAuMDYsMC4wOWwwLDcuMzVsMCw3LjMybC0wLjA2LDAuMDlsLTAuMDksMC4wNmwtMS41MywwbC0xLjUzLDBsLTAuMDksLTAuMDZsLTAuMDYsLTAuMDlsMCwtNy4zMmwwLC03LjM1em02LjYzLDBsMC4wOSwtMC4wNmwxLjUzLDBsMS41MywwbDAuMDksMC4wNmwwLjA2LDAuMDlsMCw3LjM1bDAsNy4zMmwtMC4wNiwwLjA5bC0wLjA5LDAuMDZsLTEuNTMsMGwtMS41MywwbC0wLjA5LC0wLjA2bC0wLjA2LC0wLjA5bDAsLTcuMzJsMCwtNy4zNXpcIlxyXG4gICAgfSxcclxuICAgIFwidGltZXNpZy5jb21tb25cIjoge1xyXG4gICAgICAgIFwid1wiOiAxMy4wMzgsXHJcbiAgICAgICAgXCJoXCI6IDE1LjY5NyxcclxuICAgICAgICBcImRcIjogXCJNNi42NiwtNy44MjZjMC43MiwtMC4wNiwxLjQxLC0wLjAzLDEuOTgsMC4wOWMxLjIsMC4yNywyLjM0LDAuOTYsMy4wOSwxLjkyYzAuNjMsMC44MSwxLjA4LDEuODYsMS4xNCwyLjczYzAuMDYsMS4wMiwtMC41MSwxLjkyLC0xLjQ0LDIuMjJjLTAuMjQsMC4wOSwtMC4zLDAuMDksLTAuNjMsMC4wOWMtMC4zMywwLC0wLjQyLDAsLTAuNjMsLTAuMDZjLTAuNjYsLTAuMjQsLTEuMTQsLTAuNjMsLTEuNDEsLTEuMmMtMC4xNSwtMC4zLC0wLjIxLC0wLjUxLC0wLjI0LC0wLjljLTAuMDYsLTEuMDgsMC41NywtMi4wNCwxLjU2LC0yLjM3YzAuMTgsLTAuMDYsMC4yNywtMC4wNiwwLjYzLC0wLjA2bDAuNDUsMGMwLjA2LDAuMDMsMC4wOSwwLjAzLDAuMDksMGMwLDAsLTAuMDksLTAuMTIsLTAuMjQsLTAuMjdjLTEuMDIsLTEuMTEsLTIuNTUsLTEuNjgsLTQuMDgsLTEuNWMtMS4yOSwwLjE1LC0yLjA0LDAuNjksLTIuNCwxLjc0Yy0wLjM2LDAuOTMsLTAuNDIsMS44OSwtMC40Miw1LjM3YzAsMi45NywwLjA2LDMuOTYsMC4yNCw0Ljc3YzAuMjQsMS4wOCwwLjYzLDEuNjgsMS40MSwyLjA3YzAuODEsMC4zOSwyLjE2LDAuNDUsMy4xOCwwLjA5YzEuMjksLTAuNDUsMi4zNywtMS41MywzLjAzLC0yLjk3YzAuMTUsLTAuMzMsMC4zMywtMC44NywwLjM5LC0xLjE3YzAuMDksLTAuMjQsMC4xNSwtMC4zNiwwLjMsLTAuMzljMC4yMSwtMC4wMywwLjQyLDAuMTUsMC4zOSwwLjM2Yy0wLjA2LDAuMzksLTAuNDIsMS4zOCwtMC42OSwxLjg5Yy0wLjk2LDEuOCwtMi40OSwyLjk0LC00LjIzLDMuMThjLTAuOTksMC4xMiwtMi41OCwtMC4wNiwtMy42MywtMC40NWMtMC45NiwtMC4zNiwtMS43MSwtMC44NCwtMi40LC0xLjVjLTEuMTEsLTEuMTEsLTEuOCwtMi42MSwtMi4wNCwtNC41NmMtMC4wNiwtMC42LC0wLjA2LC0yLjAxLDAsLTIuNjFjMC4yNCwtMS45NSwwLjksLTMuNDUsMi4wMSwtNC41NmMwLjY5LC0wLjY2LDEuNDQsLTEuMTEsMi4zNywtMS40N2MwLjYzLC0wLjI0LDEuNDcsLTAuNDIsMi4yMiwtMC40OHpcIlxyXG4gICAgfSxcclxuICAgIFwidGltZXNpZy5jdXRcIjoge1xyXG4gICAgICAgIFwid1wiOiAxMy4wMzgsXHJcbiAgICAgICAgXCJoXCI6IDIwLjk3LFxyXG4gICAgICAgIFwiZFwiOiBcIk02LjI0LC0xMC40NGMwLjA5LC0wLjA2LDAuMDksLTAuMDYsMC40OCwtMC4wNmMwLjM2LDAsMC4zNiwwLDAuNDUsMC4wNmwwLjA2LDAuMDlsMCwxLjIzbDAsMS4yNmwwLjI3LDBjMS4yNiwwLDIuNDksMC40NSwzLjQ4LDEuMjljMS4wNSwwLjg3LDEuOCwyLjI4LDEuODksMy40OGMwLjA2LDEuMDIsLTAuNTEsMS45MiwtMS40NCwyLjIyYy0wLjI0LDAuMDksLTAuMywwLjA5LC0wLjYzLDAuMDljLTAuMzMsMCwtMC40MiwwLC0wLjYzLC0wLjA2Yy0wLjY2LC0wLjI0LC0xLjE0LC0wLjYzLC0xLjQxLC0xLjJjLTAuMTUsLTAuMywtMC4yMSwtMC41MSwtMC4yNCwtMC45Yy0wLjA2LC0xLjA4LDAuNTcsLTIuMDQsMS41NiwtMi4zN2MwLjE4LC0wLjA2LDAuMjcsLTAuMDYsMC42MywtMC4wNmwwLjQ1LDBjMC4wNiwwLjAzLDAuMDksMC4wMywwLjA5LDBjMCwtMC4wMywtMC40NSwtMC41MSwtMC42NiwtMC42OWMtMC44NywtMC42OSwtMS44MywtMS4wNSwtMi45NCwtMS4xMWwtMC40MiwwbDAsNy4xN2wwLDcuMTRsMC40MiwwYzAuNjksLTAuMDMsMS4yMywtMC4xOCwxLjg2LC0wLjUxYzEuMDUsLTAuNTEsMS44OSwtMS40NywyLjQ2LC0yLjdjMC4xNSwtMC4zMywwLjMzLC0wLjg3LDAuMzksLTEuMTdjMC4wOSwtMC4yNCwwLjE1LC0wLjM2LDAuMywtMC4zOWMwLjIxLC0wLjAzLDAuNDIsMC4xNSwwLjM5LDAuMzZjLTAuMDMsMC4yNCwtMC4yMSwwLjc4LC0wLjM5LDEuMmMtMC45NiwyLjM3LC0yLjk0LDMuOSwtNS4xMywzLjlsLTAuMywwbDAsMS4yNmwwLDEuMjNsLTAuMDYsMC4wOWMtMC4wOSwwLjA2LC0wLjA5LDAuMDYsLTAuNDUsMC4wNmMtMC4zOSwwLC0wLjM5LDAsLTAuNDgsLTAuMDZsLTAuMDYsLTAuMDlsMCwtMS4yOWwwLC0xLjI5bC0wLjIxLC0wLjAzYy0xLjIzLC0wLjIxLC0yLjMxLC0wLjYzLC0zLjIxLC0xLjI5Yy0wLjE1LC0wLjA5LC0wLjQ1LC0wLjM2LC0wLjY2LC0wLjU3Yy0xLjExLC0xLjExLC0xLjgsLTIuNjEsLTIuMDQsLTQuNTZjLTAuMDYsLTAuNiwtMC4wNiwtMi4wMSwwLC0yLjYxYzAuMjQsLTEuOTUsMC45MywtMy40NSwyLjA0LC00LjU5YzAuNDIsLTAuMzksMC43OCwtMC42NiwxLjI2LC0wLjkzYzAuNzUsLTAuNDUsMS42NSwtMC43NSwyLjYxLC0wLjlsMC4yMSwtMC4wM2wwLC0xLjI5bDAsLTEuMjl6bS0wLjA2LDEwLjQ0YzAsLTUuNTgsMCwtNi45OSwtMC4wMywtNi45OWMtMC4xNSwwLC0wLjYzLDAuMjcsLTAuODcsMC40NWMtMC40NSwwLjM2LC0wLjc1LDAuOTMsLTAuOTMsMS43N2MtMC4xOCwwLjgxLC0wLjI0LDEuOCwtMC4yNCw0Ljc0YzAsMi45NywwLjA2LDMuOTYsMC4yNCw0Ljc3YzAuMjQsMS4wOCwwLjY2LDEuNjgsMS40MSwyLjA3YzAuMTIsMC4wNiwwLjMsMC4xMiwwLjMzLDAuMTVsMC4wOSwwbDAsLTYuOTZ6XCJcclxuICAgIH0sXHJcbiAgICBcImZcIjoge1xyXG4gICAgICAgIFwid1wiOiAxNi4xNTUsXHJcbiAgICAgICAgXCJoXCI6IDE5LjQ0NSxcclxuICAgICAgICBcImRcIjogXCJNOS45MywtMTQuMjhjMS41MywtMC4xOCwyLjg4LDAuNDUsMy4xMiwxLjVjMC4xMiwwLjUxLDAsMS4zMiwtMC4yNywxLjg2Yy0wLjE1LDAuMywtMC40MiwwLjU3LC0wLjYzLDAuNjljLTAuNjksMC4zNiwtMS41NiwwLjAzLC0xLjgzLC0wLjY5Yy0wLjA5LC0wLjI0LC0wLjA5LC0wLjY5LDAsLTAuODdjMC4wNiwtMC4xMiwwLjIxLC0wLjI0LDAuNDUsLTAuNDJjMC40MiwtMC4yNCwwLjU3LC0wLjQ1LDAuNiwtMC43MmMwLjAzLC0wLjMzLC0wLjA5LC0wLjM5LC0wLjYzLC0wLjQyYy0wLjMsMCwtMC40NSwwLC0wLjYsMC4wM2MtMC44MSwwLjIxLC0xLjM1LDAuOTMsLTEuNzQsMi40NmMtMC4wNiwwLjI3LC0wLjQ4LDIuMjUsLTAuNDgsMi4zMWMwLDAuMDMsMC4zOSwwLjAzLDAuOSwwLjAzYzAuNzIsMCwwLjksMCwwLjk5LDAuMDZjMC40MiwwLjE1LDAuNDUsMC43MiwwLjAzLDAuOWMtMC4xMiwwLjA2LC0wLjI0LDAuMDYsLTEuMTcsMC4wNmwtMS4wNSwwbC0wLjc4LDIuNTVjLTAuNDUsMS40MSwtMC44NywyLjc5LC0wLjk2LDMuMDZjLTAuODcsMi4zNywtMi4zNyw0Ljc0LC0zLjc4LDUuOTFjLTEuMDUsMC45LC0yLjA0LDEuMjMsLTMuMDksMS4wOGMtMS4xMSwtMC4xOCwtMS44OSwtMC43OCwtMi4wNCwtMS41OWMtMC4xMiwtMC42NiwwLjE1LC0xLjcxLDAuNTQsLTIuMTljMC42OSwtMC43NSwxLjg2LC0wLjU0LDIuMjIsMC4zOWMwLjA2LDAuMTUsMC4wOSwwLjI3LDAuMDksMC40OGMwLDAuMjQsLTAuMDMsMC4yNywtMC4xMiwwLjQyYy0wLjAzLDAuMDksLTAuMTUsMC4xOCwtMC4yNywwLjI3Yy0wLjA5LDAuMDYsLTAuMjcsMC4yMSwtMC4zNiwwLjI3Yy0wLjI0LDAuMTgsLTAuMzYsMC4zNiwtMC4zOSwwLjZjLTAuMDMsMC4zMywwLjA5LDAuMzksMC42MywwLjQyYzAuNDIsMCwwLjYzLC0wLjAzLDAuOSwtMC4xNWMwLjYsLTAuMywwLjk2LC0wLjk2LDEuMzgsLTIuNjRjMC4wOSwtMC40MiwwLjYzLC0yLjU1LDEuMTcsLTQuNzdsMS4wMiwtNC4wOGMwLC0wLjAzLC0wLjM2LC0wLjAzLC0wLjgxLC0wLjAzYy0wLjcyLDAsLTAuODEsMCwtMC45MywtMC4wNmMtMC40MiwtMC4xOCwtMC4zOSwtMC43NSwwLjAzLC0wLjljMC4wOSwtMC4wNiwwLjI3LC0wLjA2LDEuMDUsLTAuMDZsMC45NiwwbDAsLTAuMDljMC4wNiwtMC4xOCwwLjMsLTAuNzIsMC41MSwtMS4xN2MxLjIsLTIuNDYsMy4zLC00LjIzLDUuMzQsLTQuNXpcIlxyXG4gICAgfSxcclxuICAgIFwibVwiOiB7XHJcbiAgICAgICAgXCJ3XCI6IDE0LjY4NyxcclxuICAgICAgICBcImhcIjogOS4xMjYsXHJcbiAgICAgICAgXCJkXCI6IFwiTTIuNzksLTguOTFjMC4wOSwwLDAuMywtMC4wMywwLjQ1LC0wLjAzYzAuMjQsMC4wMywwLjMsMC4wMywwLjQ1LDAuMTJjMC4zNiwwLjE1LDAuNjMsMC41NCwwLjc1LDEuMDJsMC4wMywwLjIxbDAuMzMsLTAuM2MwLjY5LC0wLjY5LDEuMzgsLTEuMDIsMi4wNywtMS4wMmMwLjI3LDAsMC4zMywwLDAuNDgsMC4wNmMwLjIxLDAuMDksMC40OCwwLjM2LDAuNjMsMC42YzAuMDMsMC4wOSwwLjEyLDAuMjcsMC4xOCwwLjQyYzAuMDMsMC4xNSwwLjA5LDAuMjcsMC4xMiwwLjI3YzAsMCwwLjA5LC0wLjA5LDAuMTgsLTAuMjFjMC4zMywtMC4zOSwwLjg3LC0wLjgxLDEuMjksLTAuOTljMC43OCwtMC4zMywxLjQ3LC0wLjIxLDIuMDEsMC4zM2MwLjMsMC4zMywwLjQ4LDAuNjksMC42LDEuMTRjMC4wOSwwLjQyLDAuMDYsMC41NCwtMC41NCwzLjA2Yy0wLjMzLDEuMjksLTAuNTcsMi40LC0wLjU3LDIuNDNjMCwwLjEyLDAuMDksMC4yMSwwLjIxLDAuMjFjMC4yNCwwLDAuNzUsLTAuMywxLjIsLTAuNzJjMC40NSwtMC4zOSwwLjYsLTAuNDUsMC43OCwtMC4yN2MwLjE4LDAuMTgsMC4wOSwwLjM2LC0wLjQ1LDAuODdjLTEuMDUsMC45NiwtMS44MywxLjQ3LC0yLjU4LDEuNzFjLTAuOTMsMC4zMywtMS41MywwLjIxLC0xLjgsLTAuMzNjLTAuMDYsLTAuMTUsLTAuMDYsLTAuMjEsLTAuMDYsLTAuNDVjMCwtMC4yNCwwLjAzLC0wLjQ4LDAuNiwtMi44MmMwLjQyLC0xLjcxLDAuNiwtMi42NCwwLjYzLC0yLjc5YzAuMDMsLTAuNTcsLTAuMywtMC43NSwtMC44NCwtMC40OGMtMC4yNCwwLjEyLC0wLjU0LDAuMzksLTAuNjYsMC42M2MtMC4wMywwLjA5LC0wLjQyLDEuMzgsLTAuOSwzYy0wLjksMy4xNSwtMC44NCwzLC0xLjE0LDMuMTVsLTAuMTUsMC4wOWwtMC43OCwwYy0wLjYsMCwtMC43OCwwLC0wLjg0LC0wLjA2Yy0wLjA5LC0wLjAzLC0wLjE4LC0wLjE4LC0wLjE4LC0wLjI3YzAsLTAuMDMsMC4zNiwtMS4zOCwwLjg0LC0yLjk3YzAuNTcsLTIuMDQsMC44MSwtMi45NywwLjg0LC0zLjEyYzAuMDMsLTAuNTQsLTAuMywtMC43MiwtMC44NCwtMC40NWMtMC4yNCwwLjEyLC0wLjU3LDAuNDIsLTAuNjYsMC42M2MtMC4wNiwwLjA5LC0wLjUxLDEuNDQsLTEuMDUsMi45N2MtMC41MSwxLjU2LC0wLjk5LDIuODUsLTAuOTksMi45MWMtMC4wNiwwLjEyLC0wLjIxLDAuMjQsLTAuMzYsMC4zYy0wLjEyLDAuMDYsLTAuMjEsMC4wNiwtMC45LDAuMDZjLTAuNiwwLC0wLjc4LDAsLTAuODQsLTAuMDZjLTAuMDksLTAuMDMsLTAuMTgsLTAuMTgsLTAuMTgsLTAuMjdjMCwtMC4wMywwLjQ1LC0xLjM4LDAuOTksLTIuOTdjMS4wNSwtMy4xOCwxLjA1LC0zLjE4LDAuOTMsLTMuNDVjLTAuMTIsLTAuMjcsLTAuMzksLTAuMywtMC43MiwtMC4xNWMtMC41NCwwLjI3LC0xLjE0LDEuMTcsLTEuNTYsMi40Yy0wLjA2LDAuMTUsLTAuMTUsMC4zLC0wLjE4LDAuMzZjLTAuMjEsMC4yMSwtMC41NywwLjI3LC0wLjcyLDAuMDljLTAuMDksLTAuMDksLTAuMDYsLTAuMjEsMC4wNiwtMC42M2MwLjQ4LC0xLjI2LDEuMjYsLTIuNDYsMi4wMSwtMy4yMWMwLjU3LC0wLjU0LDEuMiwtMC44NywxLjgzLC0xLjAyelwiXHJcbiAgICB9LFxyXG4gICAgXCJwXCI6IHtcclxuICAgICAgICBcIndcIjogMTQuNjg5LFxyXG4gICAgICAgIFwiaFwiOiAxMy4xMjcsXHJcbiAgICAgICAgXCJkXCI6IFwiTTEuOTIsLTguN2MwLjI3LC0wLjA5LDAuODEsLTAuMDYsMS4xMSwwLjAzYzAuNTQsMC4xOCwwLjkzLDAuNTEsMS4xNywwLjk5YzAuMDksMC4xNSwwLjE1LDAuMzMsMC4xOCwwLjM2bDAsMC4xMmwwLjMsLTAuMjdjMC42NiwtMC42LDEuMzUsLTEuMDIsMi4xMywtMS4yYzAuMjEsLTAuMDYsMC4zMywtMC4wNiwwLjc4LC0wLjA2YzAuNDUsMCwwLjUxLDAsMC44NCwwLjA5YzEuMjksMC4zMywyLjA3LDEuMzIsMi4yNSwyLjc5YzAuMDksMC44MSwtMC4wOSwyLjAxLC0wLjQ1LDIuNzljLTAuNTQsMS4yNiwtMS44NiwyLjU1LC0zLjE4LDMuMDNjLTAuNDUsMC4xOCwtMC44MSwwLjI0LC0xLjI5LDAuMjRjLTAuNjksLTAuMDMsLTEuMzUsLTAuMTgsLTEuODYsLTAuNDVjLTAuMywtMC4xNSwtMC41MSwtMC4xOCwtMC42OSwtMC4wOWMtMC4wOSwwLjAzLC0wLjE4LDAuMDksLTAuMTgsMC4xMmMtMC4wOSwwLjEyLC0xLjA1LDIuOTQsLTEuMDUsMy4wNmMwLDAuMjQsMC4xOCwwLjQ4LDAuNTEsMC42M2MwLjE4LDAuMDYsMC41NCwwLjE1LDAuNzUsMC4xNWMwLjIxLDAsMC4zNiwwLjA2LDAuNDIsMC4xOGMwLjEyLDAuMTgsMC4wNiwwLjQyLC0wLjEyLDAuNTRjLTAuMDksMC4wMywtMC4xNSwwLjAzLC0wLjc4LDBjLTEuOTgsLTAuMTUsLTMuODEsLTAuMTUsLTUuNzksMGMtMC42MywwLjAzLC0wLjY5LDAuMDMsLTAuNzgsMGMtMC4yNCwtMC4xNSwtMC4yNCwtMC41NywwLjAzLC0wLjY2YzAuMDYsLTAuMDMsMC40OCwtMC4wOSwwLjk5LC0wLjEyYzAuODcsLTAuMDYsMS4xMSwtMC4wOSwxLjM1LC0wLjIxYzAuMTgsLTAuMDYsMC4zMywtMC4xOCwwLjM5LC0wLjNjMC4wNiwtMC4xMiwzLjI0LC05LjQyLDMuMjcsLTkuNmMwLjA2LC0wLjMzLDAuMDMsLTAuNTcsLTAuMTUsLTAuNjljLTAuMDksLTAuMDYsLTAuMTIsLTAuMDYsLTAuMywtMC4wNmMtMC42OSwwLjA2LC0xLjUzLDEuMDIsLTIuMjgsMi42MWMtMC4wOSwwLjIxLC0wLjIxLDAuNDUsLTAuMjcsMC41MWMtMC4wOSwwLjEyLC0wLjMzLDAuMjQsLTAuNDgsMC4yNGMtMC4xOCwwLC0wLjM2LC0wLjE1LC0wLjM2LC0wLjNjMCwtMC4yNCwwLjc4LC0xLjgzLDEuMjYsLTIuNTVjMC43MiwtMS4xMSwxLjQ3LC0xLjc0LDIuMjgsLTEuOTJ6bTUuMzcsMS40N2MtMC4yNywtMC4xMiwtMC43NSwtMC4wMywtMS4xNCwwLjIxYy0wLjc1LDAuNDgsLTEuNDcsMS42OCwtMS44OSwzLjE1Yy0wLjQ1LDEuNDcsLTAuNDIsMi4zNCwwLDIuN2MwLjQ1LDAuMzksMS4yNiwwLjIxLDEuODMsLTAuMzZjMC41MSwtMC41MSwwLjk5LC0xLjY4LDEuMzgsLTMuMjdjMC4zLC0xLjE3LDAuMzMsLTEuNzQsMC4xNSwtMi4xM2MtMC4wOSwtMC4xNSwtMC4xNSwtMC4yMSwtMC4zMywtMC4zelwiXHJcbiAgICB9LFxyXG4gICAgXCJyXCI6IHtcclxuICAgICAgICBcIndcIjogOS40MSxcclxuICAgICAgICBcImhcIjogOS4xMzIsXHJcbiAgICAgICAgXCJkXCI6IFwiTTYuMzMsLTkuMTJjMC4yNywtMC4wMywwLjkzLDAsMS4yLDAuMDZjMC44NCwwLjIxLDEuMjMsMC44MSwxLjAyLDEuNTNjLTAuMjQsMC43NSwtMC45LDEuMTcsLTEuNTYsMC45NmMtMC4zMywtMC4wOSwtMC41MSwtMC4zLC0wLjY2LC0wLjc1Yy0wLjAzLC0wLjEyLC0wLjA5LC0wLjI0LC0wLjEyLC0wLjNjLTAuMDksLTAuMTUsLTAuMywtMC4yNCwtMC40OCwtMC4yNGMtMC41NywwLC0xLjM4LDAuNTQsLTEuNjUsMS4wOGMtMC4wNiwwLjE1LC0wLjMzLDEuMTcsLTAuOSwzLjI3Yy0wLjU3LDIuMzEsLTAuODEsMy4xMiwtMC44NywzLjIxYy0wLjAzLDAuMDYsLTAuMTIsMC4xNSwtMC4xOCwwLjIxbC0wLjEyLDAuMDZsLTAuODEsMC4wM2MtMC42OSwwLC0wLjgxLDAsLTAuOSwtMC4wM2MtMC4wOSwtMC4wNiwtMC4xOCwtMC4yMSwtMC4xOCwtMC4zYzAsLTAuMDYsMC4zOSwtMS42MiwwLjksLTMuNTFjMC44NCwtMy4yNCwwLjg3LC0zLjQ1LDAuODcsLTMuNzJjMCwtMC4yMSwwLC0wLjI3LC0wLjAzLC0wLjM2Yy0wLjEyLC0wLjE1LC0wLjIxLC0wLjI0LC0wLjQyLC0wLjI0Yy0wLjI0LDAsLTAuNDUsMC4xNSwtMC43OCwwLjQyYy0wLjMzLDAuMzYsLTAuNDUsMC41NCwtMC43MiwxLjE0Yy0wLjAzLDAuMTIsLTAuMjEsMC4yNCwtMC4zNiwwLjI3Yy0wLjEyLDAsLTAuMTUsMCwtMC4yNCwtMC4wNmMtMC4xOCwtMC4xMiwtMC4xOCwtMC4yMSwtMC4wNiwtMC41NGMwLjIxLC0wLjU3LDAuNDIsLTAuOTMsMC43OCwtMS4zMmMwLjU0LC0wLjUxLDEuMiwtMC44MSwxLjk1LC0wLjg3YzAuODEsLTAuMDMsMS41MywwLjMsMS45MiwwLjg3bDAuMTIsMC4xOGwwLjA5LC0wLjA5YzAuNTcsLTAuNDUsMS40MSwtMC44NCwyLjE5LC0wLjk2elwiXHJcbiAgICB9LFxyXG4gICAgXCJzXCI6IHtcclxuICAgICAgICBcIndcIjogNi42MzIsXHJcbiAgICAgICAgXCJoXCI6IDguNzU4LFxyXG4gICAgICAgIFwiZFwiOiBcIk00LjQ3LC04LjczYzAuMDksMCwwLjM2LC0wLjAzLDAuNTcsLTAuMDNjMC43NSwwLjAzLDEuMjksMC4yNCwxLjcxLDAuNjNjMC41MSwwLjU0LDAuNjYsMS4yNiwwLjM2LDEuODNjLTAuMjQsMC40MiwtMC42MywwLjU3LC0xLjExLDAuNDJjLTAuMzMsLTAuMDksLTAuNiwtMC4zNiwtMC42LC0wLjU3YzAsLTAuMDMsMC4wNiwtMC4yMSwwLjE1LC0wLjM5YzAuMTIsLTAuMjEsMC4xNSwtMC4zMywwLjE4LC0wLjQ4YzAsLTAuMjQsLTAuMDYsLTAuNDgsLTAuMTUsLTAuNmMtMC4xNSwtMC4yMSwtMC40MiwtMC4yNCwtMC43NSwtMC4xNWMtMC4yNywwLjA2LC0wLjQ4LDAuMTgsLTAuNjksMC4zNmMtMC4zOSwwLjM5LC0wLjUxLDAuOTYsLTAuMzMsMS4zOGMwLjA5LDAuMjEsMC40MiwwLjUxLDAuNzgsMC43MmMxLjExLDAuNjksMS41OSwxLjExLDEuODksMS42OGMwLjIxLDAuMzksMC4yNCwwLjc4LDAuMTUsMS4yOWMtMC4xOCwxLjIsLTEuMTcsMi4xNiwtMi41MiwyLjUyYy0xLjAyLDAuMjQsLTEuOTUsMC4xMiwtMi43LC0wLjQyYy0wLjcyLC0wLjUxLC0wLjk5LC0xLjQ3LC0wLjYsLTIuMTljMC4yNCwtMC40OCwwLjcyLC0wLjYzLDEuMTcsLTAuNDJjMC4zMywwLjE4LDAuNTQsMC40NSwwLjU3LDAuODFjMCwwLjIxLC0wLjAzLDAuMywtMC4zMywwLjUxYy0wLjMzLDAuMjQsLTAuMzksMC40MiwtMC4yNywwLjY5YzAuMDYsMC4xNSwwLjIxLDAuMjcsMC40NSwwLjMzYzAuMywwLjA5LDAuODcsMC4wOSwxLjIsMGMwLjc1LC0wLjIxLDEuMjMsLTAuNzIsMS4yOSwtMS4zNWMwLjAzLC0wLjQyLC0wLjE1LC0wLjgxLC0wLjU0LC0xLjJjLTAuMjQsLTAuMjQsLTAuNDgsLTAuNDIsLTEuNDEsLTEuMDJjLTAuNjksLTAuNDIsLTEuMDUsLTAuOTMsLTEuMDUsLTEuNDdjMCwtMC4zOSwwLjEyLC0wLjg3LDAuMywtMS4yM2MwLjI3LC0wLjU3LDAuNzgsLTEuMDUsMS4zOCwtMS4zNWMwLjI0LC0wLjEyLDAuNjMsLTAuMjcsMC45LC0wLjN6XCJcclxuICAgIH0sXHJcbiAgICBcInpcIjoge1xyXG4gICAgICAgIFwid1wiOiA4LjU3MyxcclxuICAgICAgICBcImhcIjogOC43NDMsXHJcbiAgICAgICAgXCJkXCI6IFwiTTIuNjQsLTcuOTVjMC4zNiwtMC4wOSwwLjgxLC0wLjAzLDEuNzEsMC4yN2MwLjc4LDAuMjEsMC45NiwwLjI3LDEuNzQsMC4zYzAuODcsMC4wNiwxLjAyLDAuMDMsMS4zOCwtMC4yMWMwLjIxLC0wLjE1LDAuMzMsLTAuMTUsMC40OCwtMC4wNmMwLjE1LDAuMDksMC4yMSwwLjMsMC4xNSwwLjQ1Yy0wLjAzLDAuMDYsLTEuMjYsMS4yNiwtMi43NiwyLjY3bC0yLjczLDIuNTVsMC41NCwwLjAzYzAuNTQsMC4wMywwLjcyLDAuMDMsMi4wMSwwLjE1YzAuMzYsMC4wMywwLjksMC4wNiwxLjIsMC4wOWMwLjY2LDAsMC44MSwtMC4wMywxLjAyLC0wLjI0YzAuMywtMC4zLDAuMzksLTAuNzIsMC4yNywtMS4yM2MtMC4wNiwtMC4yNywtMC4wNiwtMC4yNywtMC4wMywtMC4zOWMwLjE1LC0wLjMsMC41NCwtMC4yNywwLjY5LDAuMDNjMC4xNSwwLjMzLDAuMjcsMS4wMiwwLjI3LDEuNWMwLDEuNDcsLTEuMTEsMi43LC0yLjUyLDIuNzljLTAuNTcsMC4wMywtMS4wMiwtMC4wOSwtMi4wMSwtMC41MWMtMS4wMiwtMC40MiwtMS4yMywtMC40OCwtMi4xMywtMC41NGMtMC44MSwtMC4wNiwtMC45NiwtMC4wMywtMS4yNiwwLjE4Yy0wLjEyLDAuMDYsLTAuMjQsMC4xMiwtMC4yNywwLjEyYy0wLjI3LDAsLTAuNDUsLTAuMywtMC4zNiwtMC41MWMwLjAzLC0wLjA2LDEuMzIsLTEuMzIsMi45MSwtMi43OWwyLjg4LC0yLjczYy0wLjAzLDAsLTAuMjEsMC4wMywtMC40MiwwLjA2Yy0wLjIxLDAuMDMsLTAuNzgsMC4wOSwtMS4yMywwLjEyYy0xLjExLDAuMTIsLTEuMjMsMC4xNSwtMS45NSwwLjI3Yy0wLjcyLDAuMTUsLTEuMTcsMC4xOCwtMS4yOSwwLjA5Yy0wLjI3LC0wLjE4LC0wLjIxLC0wLjc1LDAuMTIsLTEuMjZjMC4zOSwtMC42LDAuOTMsLTEuMDIsMS41OSwtMS4yelwiXHJcbiAgICB9LFxyXG4gICAgXCIrXCI6IHtcclxuICAgICAgICBcIndcIjogNy41MDcsXHJcbiAgICAgICAgXCJoXCI6IDcuNTE1LFxyXG4gICAgICAgIFwiZFwiOiBcIk0zLjQ4LC0xMS4xOWMwLjE4LC0wLjA5LDAuMzYsLTAuMDksMC41NCwwYzAuMTgsMC4wOSwwLjI0LDAuMTUsMC4zMywwLjNsMC4wNiwwLjE1bDAsMS4yOWwwLDEuMjlsMS4yOSwwYzEuMjMsMCwxLjI5LDAsMS40MSwwLjA2YzAuMDYsMC4wMywwLjE1LDAuMDksMC4xOCwwLjEyYzAuMTIsMC4wOSwwLjIxLDAuMzMsMC4yMSwwLjQ4YzAsMC4xNSwtMC4wOSwwLjM5LC0wLjIxLDAuNDhjLTAuMDMsMC4wMywtMC4xMiwwLjA5LC0wLjE4LDAuMTJjLTAuMTIsMC4wNiwtMC4xOCwwLjA2LC0xLjQxLDAuMDZsLTEuMjksMGwwLDEuMjljMCwxLjIzLDAsMS4yOSwtMC4wNiwxLjQxYy0wLjA5LDAuMTgsLTAuMTUsMC4yNCwtMC4zLDAuMzNjLTAuMjEsMC4wOSwtMC4zOSwwLjA5LC0wLjU3LDBjLTAuMTgsLTAuMDksLTAuMjQsLTAuMTUsLTAuMzMsLTAuMzNjLTAuMDYsLTAuMTIsLTAuMDYsLTAuMTgsLTAuMDYsLTEuNDFsMCwtMS4yOWwtMS4yOSwwYy0xLjIzLDAsLTEuMjksMCwtMS40MSwtMC4wNmMtMC4xOCwtMC4wOSwtMC4yNCwtMC4xNSwtMC4zMywtMC4zM2MtMC4wOSwtMC4xOCwtMC4wOSwtMC4zNiwwLC0wLjU0YzAuMDksLTAuMTgsMC4xNSwtMC4yNCwwLjMzLC0wLjMzbDAuMTUsLTAuMDZsMS4yNiwwbDEuMjksMGwwLC0xLjI5YzAsLTEuMjMsMCwtMS4yOSwwLjA2LC0xLjQxYzAuMDksLTAuMTgsMC4xNSwtMC4yNCwwLjMzLC0wLjMzelwiXHJcbiAgICB9LFxyXG4gICAgXCIsXCI6IHtcclxuICAgICAgICBcIndcIjogMy40NTIsXHJcbiAgICAgICAgXCJoXCI6IDguMTQzLFxyXG4gICAgICAgIFwiZFwiOiBcIk0xLjMyLC0zLjM2YzAuNTcsLTAuMTUsMS4xNywwLjAzLDEuNTksMC40NWMwLjQ1LDAuNDUsMC42LDAuOTYsMC41MSwxLjg5Yy0wLjA5LDEuMjMsLTAuNDIsMi40NiwtMC45OSwzLjkzYy0wLjMsMC43MiwtMC43MiwxLjYyLC0wLjc4LDEuNjhjLTAuMTgsMC4yMSwtMC41MSwwLjE4LC0wLjY2LC0wLjA2Yy0wLjAzLC0wLjA2LC0wLjA2LC0wLjE1LC0wLjA2LC0wLjE4YzAsLTAuMDYsMC4xMiwtMC4zMywwLjI0LC0wLjYzYzAuODQsLTEuOCwxLjAyLC0yLjYxLDAuNjksLTMuMjRjLTAuMTIsLTAuMjQsLTAuMjcsLTAuMzYsLTAuNzUsLTAuNmMtMC4zNiwtMC4xNSwtMC40MiwtMC4yMSwtMC42LC0wLjM5Yy0wLjY5LC0wLjY5LC0wLjY5LC0xLjcxLDAsLTIuNGMwLjIxLC0wLjIxLDAuNTEsLTAuMzksMC44MSwtMC40NXpcIlxyXG4gICAgfSxcclxuICAgIFwiLVwiOiB7XHJcbiAgICAgICAgXCJ3XCI6IDUuMDAxLFxyXG4gICAgICAgIFwiaFwiOiAwLjgxLFxyXG4gICAgICAgIFwiZFwiOiBcIk0wLjE4LC01LjM0YzAuMDksLTAuMDYsMC4xNSwtMC4wNiwyLjMxLC0wLjA2YzIuNDYsMCwyLjM3LDAsMi40NiwwLjIxYzAuMTIsMC4yMSwwLjAzLDAuNDIsLTAuMTUsMC41NGMtMC4wOSwwLjA2LC0wLjE1LDAuMDYsLTIuMjgsMC4wNmMtMi4xNiwwLC0yLjIyLDAsLTIuMzEsLTAuMDZjLTAuMjcsLTAuMTUsLTAuMjcsLTAuNTQsLTAuMDMsLTAuNjl6XCJcclxuICAgIH0sXHJcbiAgICBcIi5cIjoge1xyXG4gICAgICAgIFwid1wiOiAzLjQxMyxcclxuICAgICAgICBcImhcIjogMy40MDIsXHJcbiAgICAgICAgXCJkXCI6IFwiTTEuMzIsLTMuMzZjMS4wNSwtMC4yNywyLjEsMC41NywyLjEsMS42NWMwLDEuMDgsLTEuMDUsMS45MiwtMi4xLDEuNjVjLTAuOSwtMC4yMSwtMS41LC0xLjE0LC0xLjI2LC0yLjA0YzAuMTIsLTAuNjMsMC42MywtMS4xMSwxLjI2LC0xLjI2elwiXHJcbiAgICB9XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2VuZ2luZS9yZW5kZXJpbmcvZ2x5cGhzLmpzXG4gKiogbW9kdWxlIGlkID0gMzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyIsIjsoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuXG4gIC8vIFN1cHBvcnQgQU1EXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoW10sIGZhY3RvcnkpO1xuXG4gIC8vIFN1cHBvcnQgQ29tbW9uSlNcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmFuZG9tQ29sb3IgPSBmYWN0b3J5KCk7XG4gICAgXG4gICAgLy8gU3VwcG9ydCBOb2RlSlMgJiBDb21wb25lbnQsIHdoaWNoIGFsbG93IG1vZHVsZS5leHBvcnRzIHRvIGJlIGEgZnVuY3Rpb25cbiAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByYW5kb21Db2xvcjtcbiAgICB9XG4gICAgXG4gICAgLy8gU3VwcG9ydCBDb21tb25KUyAxLjEuMSBzcGVjXG4gICAgZXhwb3J0cy5yYW5kb21Db2xvciA9IHJhbmRvbUNvbG9yO1xuICBcbiAgLy8gU3VwcG9ydCB2YW5pbGxhIHNjcmlwdCBsb2FkaW5nXG4gIH0gZWxzZSB7XG4gICAgcm9vdC5yYW5kb21Db2xvciA9IGZhY3RvcnkoKTtcbiAgfTtcblxufSh0aGlzLCBmdW5jdGlvbigpIHtcblxuICAvLyBTaGFyZWQgY29sb3IgZGljdGlvbmFyeVxuICB2YXIgY29sb3JEaWN0aW9uYXJ5ID0ge307XG5cbiAgLy8gUG9wdWxhdGUgdGhlIGNvbG9yIGRpY3Rpb25hcnlcbiAgbG9hZENvbG9yQm91bmRzKCk7XG5cbiAgdmFyIHJhbmRvbUNvbG9yID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIEgsUyxCO1xuXG4gICAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBnZW5lcmF0ZSBtdWx0aXBsZSBjb2xvcnNcbiAgICBpZiAob3B0aW9ucy5jb3VudCkge1xuXG4gICAgICB2YXIgdG90YWxDb2xvcnMgPSBvcHRpb25zLmNvdW50LFxuICAgICAgICAgIGNvbG9ycyA9IFtdO1xuXG4gICAgICBvcHRpb25zLmNvdW50ID0gZmFsc2U7XG5cbiAgICAgIHdoaWxlICh0b3RhbENvbG9ycyA+IGNvbG9ycy5sZW5ndGgpIHtcbiAgICAgICAgY29sb3JzLnB1c2gocmFuZG9tQ29sb3Iob3B0aW9ucykpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29sb3JzO1xuICAgIH1cblxuICAgIC8vIEZpcnN0IHdlIHBpY2sgYSBodWUgKEgpXG4gICAgSCA9IHBpY2tIdWUob3B0aW9ucyk7XG5cbiAgICAvLyBUaGVuIHVzZSBIIHRvIGRldGVybWluZSBzYXR1cmF0aW9uIChTKVxuICAgIFMgPSBwaWNrU2F0dXJhdGlvbihILCBvcHRpb25zKTtcblxuICAgIC8vIFRoZW4gdXNlIFMgYW5kIEggdG8gZGV0ZXJtaW5lIGJyaWdodG5lc3MgKEIpLlxuICAgIEIgPSBwaWNrQnJpZ2h0bmVzcyhILCBTLCBvcHRpb25zKTtcblxuICAgIC8vIFRoZW4gd2UgcmV0dXJuIHRoZSBIU0IgY29sb3IgaW4gdGhlIGRlc2lyZWQgZm9ybWF0XG4gICAgcmV0dXJuIHNldEZvcm1hdChbSCxTLEJdLCBvcHRpb25zKTtcbiAgfTtcblxuICBmdW5jdGlvbiBwaWNrSHVlIChvcHRpb25zKSB7XG5cbiAgICB2YXIgaHVlUmFuZ2UgPSBnZXRIdWVSYW5nZShvcHRpb25zLmh1ZSksXG4gICAgICAgIGh1ZSA9IHJhbmRvbVdpdGhpbihodWVSYW5nZSk7XG5cbiAgICAvLyBJbnN0ZWFkIG9mIHN0b3JpbmcgcmVkIGFzIHR3byBzZXBlcmF0ZSByYW5nZXMsXG4gICAgLy8gd2UgZ3JvdXAgdGhlbSwgdXNpbmcgbmVnYXRpdmUgbnVtYmVyc1xuICAgIGlmIChodWUgPCAwKSB7aHVlID0gMzYwICsgaHVlfVxuXG4gICAgcmV0dXJuIGh1ZTtcblxuICB9XG5cbiAgZnVuY3Rpb24gcGlja1NhdHVyYXRpb24gKGh1ZSwgb3B0aW9ucykge1xuXG4gICAgaWYgKG9wdGlvbnMubHVtaW5vc2l0eSA9PT0gJ3JhbmRvbScpIHtcbiAgICAgIHJldHVybiByYW5kb21XaXRoaW4oWzAsMTAwXSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaHVlID09PSAnbW9ub2Nocm9tZScpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHZhciBzYXR1cmF0aW9uUmFuZ2UgPSBnZXRTYXR1cmF0aW9uUmFuZ2UoaHVlKTtcblxuICAgIHZhciBzTWluID0gc2F0dXJhdGlvblJhbmdlWzBdLFxuICAgICAgICBzTWF4ID0gc2F0dXJhdGlvblJhbmdlWzFdO1xuXG4gICAgc3dpdGNoIChvcHRpb25zLmx1bWlub3NpdHkpIHtcblxuICAgICAgY2FzZSAnYnJpZ2h0JzpcbiAgICAgICAgc01pbiA9IDU1O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZGFyayc6XG4gICAgICAgIHNNaW4gPSBzTWF4IC0gMTA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdsaWdodCc6XG4gICAgICAgIHNNYXggPSA1NTtcbiAgICAgICAgYnJlYWs7XG4gICB9XG5cbiAgICByZXR1cm4gcmFuZG9tV2l0aGluKFtzTWluLCBzTWF4XSk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHBpY2tCcmlnaHRuZXNzIChILCBTLCBvcHRpb25zKSB7XG5cbiAgICB2YXIgYnJpZ2h0bmVzcyxcbiAgICAgICAgYk1pbiA9IGdldE1pbmltdW1CcmlnaHRuZXNzKEgsIFMpLFxuICAgICAgICBiTWF4ID0gMTAwO1xuXG4gICAgc3dpdGNoIChvcHRpb25zLmx1bWlub3NpdHkpIHtcblxuICAgICAgY2FzZSAnZGFyayc6XG4gICAgICAgIGJNYXggPSBiTWluICsgMjA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdsaWdodCc6XG4gICAgICAgIGJNaW4gPSAoYk1heCArIGJNaW4pLzI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdyYW5kb20nOlxuICAgICAgICBiTWluID0gMDtcbiAgICAgICAgYk1heCA9IDEwMDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmRvbVdpdGhpbihbYk1pbiwgYk1heF0pO1xuXG4gIH1cblxuICBmdW5jdGlvbiBzZXRGb3JtYXQgKGhzdiwgb3B0aW9ucykge1xuXG4gICAgc3dpdGNoIChvcHRpb25zLmZvcm1hdCkge1xuXG4gICAgICBjYXNlICdoc3ZBcnJheSc6XG4gICAgICAgIHJldHVybiBoc3Y7XG5cbiAgICAgIGNhc2UgJ2hzdic6XG4gICAgICAgIHJldHVybiBjb2xvclN0cmluZygnaHN2JywgaHN2KTtcblxuICAgICAgY2FzZSAncmdiQXJyYXknOlxuICAgICAgICByZXR1cm4gSFNWdG9SR0IoaHN2KTtcblxuICAgICAgY2FzZSAncmdiJzpcbiAgICAgICAgcmV0dXJuIGNvbG9yU3RyaW5nKCdyZ2InLCBIU1Z0b1JHQihoc3YpKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIEhTVnRvSGV4KGhzdik7XG4gICAgfVxuXG4gIH1cblxuICBmdW5jdGlvbiBnZXRNaW5pbXVtQnJpZ2h0bmVzcyhILCBTKSB7XG5cbiAgICB2YXIgbG93ZXJCb3VuZHMgPSBnZXRDb2xvckluZm8oSCkubG93ZXJCb3VuZHM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvd2VyQm91bmRzLmxlbmd0aCAtIDE7IGkrKykge1xuXG4gICAgICB2YXIgczEgPSBsb3dlckJvdW5kc1tpXVswXSxcbiAgICAgICAgICB2MSA9IGxvd2VyQm91bmRzW2ldWzFdO1xuXG4gICAgICB2YXIgczIgPSBsb3dlckJvdW5kc1tpKzFdWzBdLFxuICAgICAgICAgIHYyID0gbG93ZXJCb3VuZHNbaSsxXVsxXTtcblxuICAgICAgaWYgKFMgPj0gczEgJiYgUyA8PSBzMikge1xuXG4gICAgICAgICB2YXIgbSA9ICh2MiAtIHYxKS8oczIgLSBzMSksXG4gICAgICAgICAgICAgYiA9IHYxIC0gbSpzMTtcblxuICAgICAgICAgcmV0dXJuIG0qUyArIGI7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEh1ZVJhbmdlIChjb2xvcklucHV0KSB7XG5cbiAgICBpZiAodHlwZW9mIHBhcnNlSW50KGNvbG9ySW5wdXQpID09PSAnbnVtYmVyJykge1xuXG4gICAgICB2YXIgbnVtYmVyID0gcGFyc2VJbnQoY29sb3JJbnB1dCk7XG5cbiAgICAgIGlmIChudW1iZXIgPCAzNjAgJiYgbnVtYmVyID4gMCkge1xuICAgICAgICByZXR1cm4gW251bWJlciwgbnVtYmVyXTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29sb3JJbnB1dCA9PT0gJ3N0cmluZycpIHtcblxuICAgICAgaWYgKGNvbG9yRGljdGlvbmFyeVtjb2xvcklucHV0XSkge1xuICAgICAgICB2YXIgY29sb3IgPSBjb2xvckRpY3Rpb25hcnlbY29sb3JJbnB1dF07XG4gICAgICAgIGlmIChjb2xvci5odWVSYW5nZSkge3JldHVybiBjb2xvci5odWVSYW5nZX1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gWzAsMzYwXTtcblxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U2F0dXJhdGlvblJhbmdlIChodWUpIHtcbiAgICByZXR1cm4gZ2V0Q29sb3JJbmZvKGh1ZSkuc2F0dXJhdGlvblJhbmdlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q29sb3JJbmZvIChodWUpIHtcblxuICAgIC8vIE1hcHMgcmVkIGNvbG9ycyB0byBtYWtlIHBpY2tpbmcgaHVlIGVhc2llclxuICAgIGlmIChodWUgPj0gMzM0ICYmIGh1ZSA8PSAzNjApIHtcbiAgICAgIGh1ZS09IDM2MDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBjb2xvck5hbWUgaW4gY29sb3JEaWN0aW9uYXJ5KSB7XG4gICAgICAgdmFyIGNvbG9yID0gY29sb3JEaWN0aW9uYXJ5W2NvbG9yTmFtZV07XG4gICAgICAgaWYgKGNvbG9yLmh1ZVJhbmdlICYmXG4gICAgICAgICAgIGh1ZSA+PSBjb2xvci5odWVSYW5nZVswXSAmJlxuICAgICAgICAgICBodWUgPD0gY29sb3IuaHVlUmFuZ2VbMV0pIHtcbiAgICAgICAgICByZXR1cm4gY29sb3JEaWN0aW9uYXJ5W2NvbG9yTmFtZV07XG4gICAgICAgfVxuICAgIH0gcmV0dXJuICdDb2xvciBub3QgZm91bmQnO1xuICB9XG5cbiAgZnVuY3Rpb24gcmFuZG9tV2l0aGluIChyYW5nZSkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKHJhbmdlWzBdICsgTWF0aC5yYW5kb20oKSoocmFuZ2VbMV0gKyAxIC0gcmFuZ2VbMF0pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNoaWZ0SHVlIChoLCBkZWdyZWVzKSB7XG4gICAgcmV0dXJuIChoICsgZGVncmVlcyklMzYwO1xuICB9XG5cbiAgZnVuY3Rpb24gSFNWdG9IZXggKGhzdil7XG5cbiAgICB2YXIgcmdiID0gSFNWdG9SR0IoaHN2KTtcblxuICAgIGZ1bmN0aW9uIGNvbXBvbmVudFRvSGV4KGMpIHtcbiAgICAgICAgdmFyIGhleCA9IGMudG9TdHJpbmcoMTYpO1xuICAgICAgICByZXR1cm4gaGV4Lmxlbmd0aCA9PSAxID8gXCIwXCIgKyBoZXggOiBoZXg7XG4gICAgfVxuXG4gICAgdmFyIGhleCA9IFwiI1wiICsgY29tcG9uZW50VG9IZXgocmdiWzBdKSArIGNvbXBvbmVudFRvSGV4KHJnYlsxXSkgKyBjb21wb25lbnRUb0hleChyZ2JbMl0pO1xuXG4gICAgcmV0dXJuIGhleDtcblxuICB9XG5cbiAgZnVuY3Rpb24gZGVmaW5lQ29sb3IgKG5hbWUsIGh1ZVJhbmdlLCBsb3dlckJvdW5kcykge1xuXG4gICAgdmFyIHNNaW4gPSBsb3dlckJvdW5kc1swXVswXSxcbiAgICAgICAgc01heCA9IGxvd2VyQm91bmRzW2xvd2VyQm91bmRzLmxlbmd0aCAtIDFdWzBdLFxuXG4gICAgICAgIGJNaW4gPSBsb3dlckJvdW5kc1tsb3dlckJvdW5kcy5sZW5ndGggLSAxXVsxXSxcbiAgICAgICAgYk1heCA9IGxvd2VyQm91bmRzWzBdWzFdO1xuXG4gICAgY29sb3JEaWN0aW9uYXJ5W25hbWVdID0ge1xuICAgICAgaHVlUmFuZ2U6IGh1ZVJhbmdlLFxuICAgICAgbG93ZXJCb3VuZHM6IGxvd2VyQm91bmRzLFxuICAgICAgc2F0dXJhdGlvblJhbmdlOiBbc01pbiwgc01heF0sXG4gICAgICBicmlnaHRuZXNzUmFuZ2U6IFtiTWluLCBiTWF4XVxuICAgIH07XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGxvYWRDb2xvckJvdW5kcyAoKSB7XG5cbiAgICBkZWZpbmVDb2xvcihcbiAgICAgICdtb25vY2hyb21lJyxcbiAgICAgIG51bGwsXG4gICAgICBbWzAsMF0sWzEwMCwwXV1cbiAgICApO1xuXG4gICAgZGVmaW5lQ29sb3IoXG4gICAgICAncmVkJyxcbiAgICAgIFstMjYsMThdLFxuICAgICAgW1syMCwxMDBdLFszMCw5Ml0sWzQwLDg5XSxbNTAsODVdLFs2MCw3OF0sWzcwLDcwXSxbODAsNjBdLFs5MCw1NV0sWzEwMCw1MF1dXG4gICAgKTtcblxuICAgIGRlZmluZUNvbG9yKFxuICAgICAgJ29yYW5nZScsXG4gICAgICBbMTksNDZdLFxuICAgICAgW1syMCwxMDBdLFszMCw5M10sWzQwLDg4XSxbNTAsODZdLFs2MCw4NV0sWzcwLDcwXSxbMTAwLDcwXV1cbiAgICApO1xuXG4gICAgZGVmaW5lQ29sb3IoXG4gICAgICAneWVsbG93JyxcbiAgICAgIFs0Nyw2Ml0sXG4gICAgICBbWzI1LDEwMF0sWzQwLDk0XSxbNTAsODldLFs2MCw4Nl0sWzcwLDg0XSxbODAsODJdLFs5MCw4MF0sWzEwMCw3NV1dXG4gICAgKTtcblxuICAgIGRlZmluZUNvbG9yKFxuICAgICAgJ2dyZWVuJyxcbiAgICAgIFs2MywxNThdLFxuICAgICAgW1szMCwxMDBdLFs0MCw5MF0sWzUwLDg1XSxbNjAsODFdLFs3MCw3NF0sWzgwLDY0XSxbOTAsNTBdLFsxMDAsNDBdXVxuICAgICk7XG5cbiAgICBkZWZpbmVDb2xvcihcbiAgICAgICdibHVlJyxcbiAgICAgIFsxNTksIDI1N10sXG4gICAgICBbWzIwLDEwMF0sWzMwLDg2XSxbNDAsODBdLFs1MCw3NF0sWzYwLDYwXSxbNzAsNTJdLFs4MCw0NF0sWzkwLDM5XSxbMTAwLDM1XV1cbiAgICApO1xuXG4gICAgZGVmaW5lQ29sb3IoXG4gICAgICAncHVycGxlJyxcbiAgICAgIFsyNTgsIDI4Ml0sXG4gICAgICBbWzIwLDEwMF0sWzMwLDg3XSxbNDAsNzldLFs1MCw3MF0sWzYwLDY1XSxbNzAsNTldLFs4MCw1Ml0sWzkwLDQ1XSxbMTAwLDQyXV1cbiAgICApO1xuXG4gICAgZGVmaW5lQ29sb3IoXG4gICAgICAncGluaycsXG4gICAgICBbMjgzLCAzMzRdLFxuICAgICAgW1syMCwxMDBdLFszMCw5MF0sWzQwLDg2XSxbNjAsODRdLFs4MCw4MF0sWzkwLDc1XSxbMTAwLDczXV1cbiAgICApO1xuXG4gIH1cblxuICBmdW5jdGlvbiBIU1Z0b1JHQiAoaHN2KSB7XG5cbiAgICAvLyB0aGlzIGRvZXNuJ3Qgd29yayBmb3IgdGhlIHZhbHVlcyBvZiAwIGFuZCAzNjBcbiAgICAvLyBoZXJlJ3MgdGhlIGhhY2t5IGZpeFxuICAgIHZhciBoID0gaHN2WzBdO1xuICAgIGlmIChoID09PSAwKSB7aCA9IDF9XG4gICAgaWYgKGggPT09IDM2MCkge2ggPSAzNTl9XG5cbiAgICAvLyBSZWJhc2UgdGhlIGgscyx2IHZhbHVlc1xuICAgIGggPSBoLzM2MDtcbiAgICB2YXIgcyA9IGhzdlsxXS8xMDAsXG4gICAgICAgIHYgPSBoc3ZbMl0vMTAwO1xuXG4gICAgdmFyIGhfaSA9IE1hdGguZmxvb3IoaCo2KSxcbiAgICAgIGYgPSBoICogNiAtIGhfaSxcbiAgICAgIHAgPSB2ICogKDEgLSBzKSxcbiAgICAgIHEgPSB2ICogKDEgLSBmKnMpLFxuICAgICAgdCA9IHYgKiAoMSAtICgxIC0gZikqcyksXG4gICAgICByID0gMjU2LFxuICAgICAgZyA9IDI1NixcbiAgICAgIGIgPSAyNTY7XG5cbiAgICBzd2l0Y2goaF9pKSB7XG4gICAgICBjYXNlIDA6IHIgPSB2LCBnID0gdCwgYiA9IHA7ICBicmVhaztcbiAgICAgIGNhc2UgMTogciA9IHEsIGcgPSB2LCBiID0gcDsgIGJyZWFrO1xuICAgICAgY2FzZSAyOiByID0gcCwgZyA9IHYsIGIgPSB0OyAgYnJlYWs7XG4gICAgICBjYXNlIDM6IHIgPSBwLCBnID0gcSwgYiA9IHY7ICBicmVhaztcbiAgICAgIGNhc2UgNDogciA9IHQsIGcgPSBwLCBiID0gdjsgIGJyZWFrO1xuICAgICAgY2FzZSA1OiByID0gdiwgZyA9IHAsIGIgPSBxOyAgYnJlYWs7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBbTWF0aC5mbG9vcihyKjI1NSksIE1hdGguZmxvb3IoZyoyNTUpLCBNYXRoLmZsb29yKGIqMjU1KV07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbG9yU3RyaW5nIChwcmVmaXgsIHZhbHVlcykge1xuICAgIHJldHVybiBwcmVmaXggKyAnKCcgKyB2YWx1ZXMuam9pbignLCAnKSArICcpJztcbiAgfVxuXG4gIHJldHVybiByYW5kb21Db2xvcjtcbn0pKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yYW5kb21jb2xvci9yYW5kb21Db2xvci5qc1xuICoqIG1vZHVsZSBpZCA9IDMyXG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiIsImZpbGUiOiIxLjEuanMifQ==